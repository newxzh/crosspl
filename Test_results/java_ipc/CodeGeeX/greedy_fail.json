[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Java class that provides read-only access to file contents using MemorySegment and FileChannel for efficient memory-mapped file operations.\n\nClass Description: MemorySegmentReaderSupplier is a utility class that implements ReaderSupplier interface, designed to provide memory-mapped file reading capabilities. It uses Java NIO's FileChannel to map a file into memory as a MemorySegment, allowing efficient read operations. The class manages memory resources through an Arena and automatically handles resource cleanup.\n\nAttributes:\n- arena: Arena - Manages the lifecycle of the memory segment and ensures proper cleanup\n- memory: MemorySegment - The memory-mapped representation of the file content\n\nMethods:\n- Constructor: MemorySegmentReaderSupplier(Path path) throws IOException - Initializes the reader by opening the specified file and mapping it into memory. Throws IOException if file operations fail.\n- get: get() -> MemorySegmentReader - Returns a new MemorySegmentReader instance for accessing the memory-mapped file content\n- close: close() -> void - Releases all allocated resources by closing the arena and unmapping the memory segment",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.ofShared();\n        try (var ch = FileChannel.open(path, StandardOpenOption.READ)) {\n            this.memory = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size(), arena);\n        } catch (Throwable e) {\n            arena.close();\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    @Override\n    public void close() {\n        arena.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport org.bytedeco.javacpp.BytePointer;\nimport org.bytedeco.javacpp.Pointer;\nimport org.bytedeco.javacpp.PointerPointer;\nimport org.bytedeco.javacpp.indexer.ByteIndexer;\nimport org.bytedeco.javacpp.indexer.UByteIndexer;\nimport org.bytedeco.javacpp.indexer.UShortIndexer;\nimport org.bytedeco.javacpp.indexer.UBytePointerIndexer;\nimport org.bytedeco.javacpp.indexer.UShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.BytePointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer;\nimport org.bytedeco.javacpp.indexer.DoublePointerIndexer;\nimport org.bytedeco.javacpp.indexer.DoubleIndexer;\nimport org.bytedeco.javacpp.indexer.CharPointerIndexer;\nimport org.bytedeco.javacpp.indexer.CharIndexer;\nimport org.bytedeco.javacpp.indexer.ShortPointerIndexer;\nimport org.bytedeco.javacpp.indexer.ShortIndexer;\nimport org.bytedeco.javacpp.indexer.IntPointerIndexer;\nimport org.bytedeco.javacpp.indexer.IntIndexer;\nimport org.bytedeco.javacpp.indexer.LongPointerIndexer;\nimport org.bytedeco.javacpp.indexer.LongIndexer;\nimport org.bytedeco.javacpp.indexer.FloatPointerIndexer;\nimport org.bytedeco.javacpp.indexer.FloatIndexer"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Properties;\nimport java.util.UUID;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary = UUID.randomUUID().toString();\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private static HttpClient me;\n\n    private HttpClient() {\n    }\n\n    public static HttpClient getInstance() {\n        if (me == null) {\n            me = new HttpClient();\n        }\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            throw new HttpClientException(e);\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL u = new URL(url);\n        URLConnection uc = u.openConnection();\n        if (proxyHost != null && proxyPort != null) {\n            uc = u.openConnection(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort))));\n        }\n        con = (HttpURLConnection) uc;\n        con.setRequestMethod(method);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        if (props != null) {\n            for (Object key : props.keySet()) {\n                con.setRequestProperty(key.toString(), props.getProperty(key.toString()));\n            }\n        }\n        os = con.getOutputStream();\n    }\n\n    public byte[] downloadImage(String imgName) throws HttpClientException {\n        try {\n            URL u = new URL(url + imgName);\n            URLConnection uc = u.openConnection();\n            if (proxyHost != null && proxyPort != null) {\n                uc = u.openConnection(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort))));\n            }\n            con = (HttpURLConnection) uc;\n            con.setRequestMethod(\"GET\");\n            con.setDoOutput(true);\n            con.connect();\n            InputStream is = con.getInputStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = is.read(buffer)) > 0) {\n                baos.write(buffer, 0, len);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            throw new HttpClientException(e);\n        }\n    }\n\n    public void connectForMultipart() throws Exception {\n        connect(\"POST\", null);\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Disposition: form-data; name=\\\"description\\\"\\r\\n\\r\\n\".getBytes());\n        os.write(\"A small text\".getBytes());\n        os.write((\"\\r\\n\" + delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write((\"\\r\\n\" + delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: image/jpeg\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write((\"\\r\\n\" + delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((\"\\r\\n\" + delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        rd.close();\n        return sb.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write((\"\\r\\n\" + delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}\n```"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\npublic class HttpWeatherClient {\n\n    private static final String SUNRISE_KEY = \"sunrise\";\n    private static final String SUNSET_KEY = \"sunset\";\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String url = params[0];\n                InputStream inputStream = new java.net.URL(url).openStream();\n                String result = convertStreamToString(inputStream);\n                publishProgress(result);\n            } catch (Exception e) {\n                // Handle exception\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject jsonObject = new JSONObject(progress[0]);\n                JSONObject astronomy = jsonObject.getJSONObject(\"astronomy\");\n                String sunrise = astronomy.getString(SUNRISE_KEY);\n                String sunset = astronomy.getString(SUNSET_KEY);\n                // Process sunrise and sunset times\n            } catch (JSONException e) {\n                // Handle exception\n            }\n        }\n\n        private String convertStreamToString(InputStream inputStream) {\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder stringBuilder = new StringBuilder();\n            String line;\n            try {\n                while ((line = bufferedReader.readLine()) != null) {\n                    stringBuilder.append(line).append('\\n');\n                }\n            } catch (IOException e) {\n                // Handle exception\n            } finally {\n                try {\n                    inputStream.close();\n                } catch (IOException e) {\n                    // Handle exception\n                }\n            }\n            return stringBuilder.toString();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequestHandler {\n\n    private static final String TAG = \"HttpRequestHandler\";\n\n    public static class MyAsyncTaskGetNews extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            HttpURLConnection connection = null;\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(params[0]);\n                connection = (HttpURLConnection) url.openConnection();\n                connection.connect();\n\n                InputStream stream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(stream));\n                StringBuffer buffer = new StringBuffer();\n                String line = \"\";\n\n                while ((line = reader.readLine()) != null) {\n                    buffer.append(line);\n                }\n\n                return buffer.toString();\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (connection != null) {\n                    connection.disconnect();\n                }\n                try {\n                    if (reader != null) {\n                        reader.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            // Process the received JSON data here\n            try {\n                JSONArray jsonArray = new JSONArray(progress[0]);\n                List<JSONObject> newsList = new ArrayList<>();\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    newsList.add(jsonObject);\n                }\n                // Process the newsList as needed\n            } catch (JSONException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            super.onPostExecute(result2);\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String convertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error converting input stream to string: \" + e.getMessage());\n        }\n        return stringBuilder.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpHeaders;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Optional;\nimport java.util.logging.Logger;\n\npublic class HttpDownloader {\n\n    private static final Logger logger = Logger.getLogger(HttpDownloader.class.getName());\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        int redirects = 0;\n        String currentUrl = targetUrlString;\n        while (redirects < MAXIMUM_REDIRECTS) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrl, path, userAgent);\n            if (nextUrl.isEmpty()) {\n                logger.info(\"Download completed successfully.\");\n                return;\n            }\n            currentUrl = nextUrl.get();\n            redirects++;\n        }\n        throw new IOException(\"Too many redirects.\");\n    }\n\n    private Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        HttpClient client = HttpClient.newBuilder().build();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(urlString))\n                .header(\"User-Agent\", userAgent)\n                .build();\n        try {\n            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n            HttpHeaders headers = response.headers();\n            if (response.statusCode() == 301 || response.statusCode() == 302) {\n                String nextUrl = headers.firstValue(\"Location\").orElseThrow(() -> new IOException(\"Redirect without Location header.\"));\n                logger.info(\"Redirecting to: \" + nextUrl);\n                return Optional.of(nextUrl);\n            }\n            if (response.statusCode() != 200) {\n                throw new IOException(\"HTTP error code: \" + response.statusCode());\n            }\n            Files.write(path, response.body());\n            logger.info(\"Downloaded: \" + urlString);\n            return Optional.empty();\n        } catch (IOException | InterruptedException e) {\n            throw new IOException(\"Failed to download: \" + urlString, e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WebUtils {\n\n    private static final String USER_AGENT = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\";\n\n    public static String getBody(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        String body = getBody(reqURL);\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readTree(body);\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        try (InputStream in = con.getInputStream();\n             OutputStream out = new FileOutputStream(fileLocation)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setDoOutput(true);\n        try (OutputStream out = con.getOutputStream()) {\n            out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        }\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setDoOutput(true);\n        try (OutputStream out = con.getOutputStream()) {\n            String formBody = fields.entrySet().stream()\n                    .map(entry -> entry.getKey() + \"=\" + entry.getValue())\n                    .collect(Collectors.joining(\"&\"));\n            out.write(formBody.getBytes(StandardCharsets.UTF_8));\n        }\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        try (InputStream in = con.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n            return reader.lines();\n        }\n    }\n\n    public static String getUserAgent() {\n        return USER_AGENT;\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        try (InputStream in = con.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n            return reader.lines().collect(Collectors.joining(\"\\n\"));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class RealRequest {\n    private static String sRequestURL;\n    private HttpConfig httpConfig;\n    private static final String TAG = \"SA.HttpRequest\";\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n        setHeader(conn, headerMap);\n        return getRealResponse(conn);\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n        setHeader(conn, headerMap);\n        try {\n            conn.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());\n            wr.writeBytes(body);\n            wr.flush();\n            wr.close();\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n        return getRealResponse(conn);\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) {\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(requestURL);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setConnectTimeout(httpConfig.getConnectTimeout());\n            conn.setReadTimeout(httpConfig.getReadTimeout());\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        try {\n            int responseCode = conn.getResponseCode();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return new RealResponse(responseCode, response.toString());\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(500, e.getMessage());\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npublic class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n    private boolean allowCrossProtocolRedirects;\n    private int connectTimeoutMillis;\n    private int readTimeoutMillis;\n    private RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis, RequestProperties requestProperties) {\n        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\n        this.connectTimeoutMillis = connectTimeoutMillis;\n        this.readTimeoutMillis = readTimeoutMillis;\n        this.requestProperties = requestProperties;\n    }\n\n    @Override\n    public long open(DataSpec dataSpecParameter) throws IOException {\n        this.dataSpec = dataSpecParameter;\n        this.connection = makeConnection(dataSpec);\n        this.inputStream = connection.getInputStream();\n        this.opened = true;\n        return connection.getContentLength();\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        HttpURLConnection connection = openConnection(url);\n        int redirectCount = 0;\n        while (redirectCount++ < MAX_REDIRECTS) {\n            int responseCode = connection.getResponseCode();\n            if (responseCode < HTTP_TEMP_REDIRECT && responseCode >= HTTP_PERMANENT_REDIRECT) {\n                String location = connection.getHeaderField(\"Location\");\n                URL newUrl = handleRedirect(url, location, dataSpecToUse);\n                connection.disconnect();\n                connection = openConnection(newUrl);\n                url = newUrl;\n            } else {\n                return connection;\n            }\n        }\n        throw new IOException(\"Too many redirects\");\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws MalformedURLException {\n        if (location == null) {\n            throw new MalformedURLException(\"Null location redirect\");\n        }\n        if (!allowCrossProtocolRedirects && !originalUrl.getProtocol().equals(new URL(location).getProtocol())) {\n            throw new MalformedURLException(\"Cross-protocol redirects not allowed\");\n        }\n        return new URL(location);\n    }\n\n    private HttpURLConnection openConnection(URL url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(connectTimeoutMillis);\n        connection.setReadTimeout(readTimeoutMillis);\n        for (Map.Entry<String, String> requestProperty : requestProperties.getSnapshot().entrySet()) {\n            connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n        }\n        return connection;\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int readLength) throws IOException {\n        if (!opened) {\n            throw new IllegalStateException(\"Data source not open\");\n        }\n        int read = inputStream.read(buffer, offset, readLength);\n        if (read == -1) {\n            close();\n        }\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (inputStream != null) {\n            try {\n                maybeTerminateInputStream(connection, dataSpec.length);\n            } finally {\n                inputStream = null;\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } finally {\n                connection = null;\n            }\n        }\n        opened = false;\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        if (Util.SDK_INT < 21) {\n            return;\n        }\n        if (bytesRemaining == C.LENGTH_UNSET) {\n            connection.disconnect();\n        } else if (bytesRemaining != 0) {\n            connection.fixedLengthStreamingMode = true;\n            connection.setFixedLengthStreamingMode((int) bytesRemaining);\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                // Ignore\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n            connection.setDoOutput(true);\n\n            if (requestBody != null) {\n                try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n                    wr.writeBytes(requestBody);\n                    wr.flush();\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = in.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return response.toString();\n                }\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        String method = request.getMethod();\n        String path = request.getUrl();\n        Map<String, String> params = request.getParams();\n\n        // Build the URL with parameters\n        StringBuilder urlBuilder = new StringBuilder(path);\n        if (params != null && !params.isEmpty()) {\n            urlBuilder.append(\"?\");\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                urlBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&\");\n            }\n            urlBuilder.deleteCharAt(urlBuilder.length() - 1); // Remove the last '&'\n        }\n\n        return executeRequest(method, urlBuilder.toString(), null);\n    }\n}\n```"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class HttpClientUtil {\n\n    private HttpClientUtil() {\n        // Private constructor to prevent instantiation\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(method);\n        conn.setDoOutput(true);\n        conn.setSSLSocketFactory(createSSLSocketFactory());\n\n        if (method.equals(\"POST\")) {\n            OutputStream os = conn.getOutputStream();\n            os.write(outputStr.getBytes());\n            os.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return new HttpResponse(responseCode, response.toString());\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(method);\n        conn.setDoOutput(true);\n        conn.setSSLSocketFactory(createSSLSocketFactory());\n\n        if (method.equals(\"POST\")) {\n            OutputStream os = conn.getOutputStream();\n            os.write(outputStr.getBytes());\n            os.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return new HttpResponse(responseCode, response.toString());\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                }\n            }};\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"Failed to create SSL socket factory\", e);\n        }\n    }\n\n    public static class HttpResponse {\n        private final int responseCode;\n        private final String responseContent;\n\n        public HttpResponse(int responseCode, String responseContent) {\n            this.responseCode = responseCode;\n            this.responseContent = responseContent;\n        }\n\n        public int getResponseCode() {\n            return responseCode;\n        }\n\n        public String getResponseContent() {\n            return responseContent;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class WebSocketTestClient {\n    private Bootstrap bootstrap;\n    private Channel ch;\n    private URI uri;\n    private WebSocketVersion version;\n    private boolean closed;\n    private AtomicInteger count;\n\n    public WebSocketTestClient(URI uri, WebSocketVersion version) {\n        this.uri = uri;\n        this.version = version;\n        this.closed = false;\n        this.count = new AtomicInteger();\n        this.bootstrap = new Bootstrap();\n        this.bootstrap.group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new WSClientHandler());\n    }\n\n    public WebSocketTestClient connect() {\n        ChannelFuture future = bootstrap.connect(uri.getHost(), uri.getPort());\n        future.addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ch = future.channel();\n                    WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(uri, version, null, true, new DefaultHttpHeaders());\n                    handshaker.handshake(ch);\n                } else {\n                    future.cause().printStackTrace();\n                }\n            }\n        });\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        if (ch != null && ch.isActive()) {\n            ch.writeAndFlush(frame).addListener(new GenericFutureListener<ChannelFuture>() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.isSuccess()) {\n                        listener.onFrame(frame);\n                    } else {\n                        listener.onError(future.cause());\n                    }\n                }\n            });\n        }\n        return this;\n    }\n\n    public void destroy() {\n        destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n            ch = null;\n        }\n        closed = true;\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n\n        void onError(Throwable t);\n    }\n\n    private class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private ChannelPromise handshakeFuture;\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(uri, version, null, true, new DefaultHttpHeaders());\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!closed) {\n                if (msg instanceof FullHttpResponse) {\n                    FullHttpResponse response = (FullHttpResponse) msg;\n                    throw new IllegalStateException(\"Unexpected FullHttpResponse (getStatus=\" + response.status() + \", content=\" + response.content().toString(io.netty.util.CharsetUtil.UTF_8) + ')');\n                }\n                WebSocketFrame frame = (WebSocketFrame) msg;\n                if (frame instanceof TextWebSocketFrame) {\n                    TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;\n                    System.out.println(\"Received: \" + textFrame.text());\n                } else if (frame instanceof BinaryWebSocketFrame) {\n                    BinaryWebSocketFrame binaryFrame = (BinaryWebSocketFrame) frame;\n                    System.out.println(\"Received: \" + binaryFrame.content().readableBytes() + \" bytes\");\n                } else if (frame instanceof PongWebSocketFrame) {\n                    System.out.println(\"Received Pong: \" + frame.content().toString(io.netty.util.CharsetUtil.UTF_8));\n                } else if (frame instanceof CloseWebSocketFrame) {\n                    System.out.println(\"Received closing\");\n                    ctx.close();\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final EventLoopGroup workerGroup;\n    private final Bootstrap b;\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup(0, new DefaultThreadFactory(\"http-client-worker\"));\n        this.b = new Bootstrap();\n        this.results = new ConcurrentHashMap<>();\n        init();\n    }\n\n    private void init() {\n        b.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpClientCodec());\n                        ch.pipeline().addLast(new HttpContentDecompressor());\n                        ch.pipeline().addLast(new HttpObjectAggregator(1024 * 1024));\n                        ch.pipeline().addLast(new TestHttpClientHandler(results));\n                    }\n                });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        return send(createGetRequest(uri));\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        return send(createPostRequest(uri, params, headers));\n    }\n\n    private String send(HttpRequest request) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(request.headers().get(HttpHeaderNames.COOKIE), future);\n        ChannelFuture channelFuture = b.connect(host, port).syncUninterruptibly();\n        channelFuture.channel().writeAndFlush(request).addListener((GenericFutureListener<Future<? super Void>>) future1 -> {\n            if (!future1.isSuccess()) {\n                future.completeExceptionally(future1.cause());\n            }\n        });\n        try {\n            return future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private HttpRequest createGetRequest(String uri) {\n        try {\n            URI u = new URI(uri);\n            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, u.getRawPath());\n            request.headers().set(HttpHeaderNames.HOST, host);\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n            return request;\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private HttpRequest createPostRequest(String uri, Map<String, String> params, Map<String, String> headers) {\n        try {\n            URI u = new URI(uri);\n            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, u.getRawPath());\n            request.headers().set(HttpHeaderNames.HOST, host);\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n            StringBuilder content = new StringBuilder();\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                content.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&\");\n            }\n            request.content().writeCharSequence(content.toString(), io.netty.util.CharsetUtil.UTF_8);\n            return request;\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
    "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.stream.Stream;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n    private final SeekableByteChannel channel;\n    private final Pmtiles.Header header;\n\n    public ReadablePmtiles(SeekableByteChannel channel, Pmtiles.Header header) {\n        this.channel = channel;\n        this.header = header;\n    }\n\n    public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n        try (SeekableByteChannel channel = Files.newByteChannel(path)) {\n            Pmtiles.Header header = Pmtiles.readHeader(channel);\n            return new ReadablePmtiles(channel, header);\n        }\n    }\n\n    @Override\n    public byte[] getTile(int x, int y, int z) {\n        try {\n            long offset = header.getTileOffset(x, y, z);\n            if (offset == -1) {\n                return null;\n            }\n            int length = header.getTileLength(x, y, z);\n            return getBytes(offset, length);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    @Override\n    public CloseableIterator<Tile> getAllTiles() {\n        try {\n            List<Pmtiles.Entry> dir = readDir(0, header.getDirLength());\n            return new CloseableIterator<Tile>() {\n                private final Stream<Tile> tiles = getTiles(dir).onClose(() -> close());\n                private final Iterator<Tile> iterator = tiles.iterator();\n\n                @Override\n                public boolean hasNext() {\n                    return iterator.hasNext();\n                }\n\n                @Override\n                public Tile next() {\n                    return iterator.next();\n                }\n\n                @Override\n                public void close() {\n                    try {\n                        ReadablePmtiles.this.close();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            };\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private byte[] getBytes(long start, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.position(start);\n        channel.read(buffer);\n        return buffer.array();\n    }\n\n    private List<Pmtiles.Entry> readDir(long offset, int length) throws IOException {\n        byte[] bytes = getBytes(offset, length);\n        return Pmtiles.readDir(bytes);\n    }\n\n    private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n        return dir.stream().map(entry -> new Tile(entry.getOffset(), entry.getLength()));\n    }\n}\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Implement a TCP client using Java Netty framework that can maintain persistent connections to multiple hosts and send messages to them.\n\nClass Description: This class provides functionality to initialize and manage Netty TCP client connections to multiple hosts. It maintains a connection pool using maps to store active channels and their associated event loop groups.\n\nAttributes:\n- channelMap: Map<String, Channel> - Stores active channels mapped by host address\n- groupMap: Map<String, NioEventLoopGroup> - Stores event loop groups mapped by host address\n\nMethods:\n- initSocketClientAndSendMessage(String host, String message) -> Channel - Initializes a new TCP client connection to the specified host if one doesn't exist, or reuses an existing connection. Sends the provided message to the host. Returns the Channel object for the connection.\n  - Input Parameters:\n    - host: String - The host address to connect to\n    - message: String - The message to be sent to the host\n  - Return Type: Channel - The Netty Channel object representing the connection",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static Map<String, Channel> channelMap;\npublic static Map<String, NioEventLoopGroup> groupMap;\n\n@Override\npublic Channel initSocketClientAndSendMessage(String host, String message) throws Exception {\n    if(channelMap==null){\n        channelMap = new HashMap<>();\n    }\n    if(groupMap==null){\n        groupMap = new HashMap<>();\n    }\n\n    if(channelMap.get(host)==null){\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, 9003))\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder(Charset.forName(\"GBK\")));\n                        ch.pipeline().addLast(new ByteArrayEncoder());\n                        ch.pipeline().addLast(new ChunkedWriteHandler());\n                    }\n                });\n            ChannelFuture cf = b.connect();\n            channelMap.put(host, cf.channel());\n            groupMap.put(host, group);\n            return null;\n        } catch (Exception e){\n            group.shutdownGracefully().sync();\n            return null;\n        }\n    }else{\n        channelMap.get(host).writeAndFlush(StringTools.hexStringToBytes(message));\n        return channelMap.get(host);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class NettyTcpClient {\n\n    private Map<String, Channel> channelMap = new ConcurrentHashMap<>();\n    private Map<String, NioEventLoopGroup> groupMap = new ConcurrentHashMap<>();\n\n    public Channel initSocketClientAndSendMessage(String host, String message) {\n        Channel channel = channelMap.get(host);\n        if (channel == null || !channel.isActive()) {\n            EventLoopGroup group = groupMap.get(host);\n            if (group == null) {\n                group = new NioEventLoopGroup();\n                groupMap.put(host, group);\n            }\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new StringEncoder());\n                        }\n                    });\n            ChannelFuture future = bootstrap.connect(host, 8080).syncUninterruptibly();\n            channel = future.channel();\n            channelMap.put(host, channel);\n        }\n        channel.writeAndFlush(message);\n        return channel;\n    }\n}\n```"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, maintenance, and graceful shutdown.\n\nClass Description: HttpEventChannelManager is a Netty-based TCP client manager that creates and maintains connections to remote servers, provides connection metrics, and handles resource cleanup.\n\nAttributes:\n- LOG: [Logger] - Logger instance for logging debug and error messages\n- connectionSuccess: [Counter] - Metric counter for successful connections\n- connectionFailure: [Counter] - Metric counter for failed connections\n- liveConnections: [AtomicDouble] - Gauge metric for current active connections\n- nettyChannelBufferSize: [AtomicDouble] - Gauge metric for current channel buffer size\n- lowWriteBufferWatermark: [int] - Low watermark for write buffer\n- highWriteBufferWatermark: [int] - High watermark for write buffer\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- encoderEventLoopGroup: [EventLoopGroup] - Optional event loop group for compression\n- bootstrap: [Bootstrap] - Netty bootstrap for client configuration\n- channels: [ConcurrentMap<String, Channel>] - Map of active channels keyed by host:port\n\nMethods:\n- HttpEventChannelManager([Registry, MrePublishConfiguration]) -> [void] - Constructor that initializes metrics, event loops, and bootstrap configuration\n- findOrCreate([InetSocketAddress]) -> [Channel] - Finds existing or creates new channel for given address\n- find([InetSocketAddress]) -> [Channel] - Finds existing channel for given address\n- close([InetSocketAddress]) -> [void] - Closes channel for given address\n- getHostPortString([InetSocketAddress]) -> [String] - Helper method to format address as host:port string",
    "Canonical_solution": "import com.netflix.spectator.api.Counter;\nimport com.netflix.spectator.api.Registry;\nimport com.netflix.spectator.impl.AtomicDouble;\nimport io.mantisrx.publish.config.MrePublishConfiguration;\nimport io.mantisrx.publish.internal.metrics.SpectatorUtils;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpEventChannelManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannel.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(\n            Registry registry,\n            MrePublishConfiguration config) {\n\n        this.connectionSuccess =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionSuccess\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.connectionFailure =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionFailure\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.liveConnections =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"liveConnections\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.nettyChannelBufferSize =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"bufferSize\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup(config.getIoThreads());\n\n        boolean gzipEnabled = config.getGzipEnabled();\n        if (gzipEnabled) {\n            this.encoderEventLoopGroup = new DefaultEventLoopGroup(config.getCompressionThreads());\n        } else {\n            this.encoderEventLoopGroup = null;\n        }\n\n        this.bootstrap = new Bootstrap()\n                .group(this.eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, MantisMessageSizeEstimator.DEFAULT)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(\n                                lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new HttpEventChannelInitializer(\n                        registry, config, encoderEventLoopGroup));\n        this.channels = new ConcurrentHashMap<>();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this.eventLoopGroup::shutdownGracefully));\n    }\n\n    Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n\n        if (channel == null) {\n            LOG.debug(\"creating new channel for {}\", address);\n            ChannelFuture channelFuture = bootstrap.connect(address);\n            channel = channelFuture.channel();\n\n            channels.put(getHostPortString(address), channel);\n\n            channel.closeFuture().addListener(future -> {\n                LOG.debug(\"closing channel for {}\", address);\n                channels.remove(getHostPortString(address));\n                liveConnections.set((double) channels.size());\n            });\n\n            channelFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    LOG.debug(\"connection success for {}\", address);\n                    connectionSuccess.increment();\n                    liveConnections.set((double) channels.size());\n                } else {\n                    LOG.debug(\"failed to connect to {}\", address);\n                    connectionFailure.increment();\n                }\n            });\n        }\n\n        nettyChannelBufferSize.set(highWriteBufferWatermark - channel.bytesBeforeUnwritable());\n\n        return channel;\n    }\n\n    private Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + ':' + address.getPort();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.Gauge;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicDouble;\n\npublic class HttpEventChannelManager {\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannelManager.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final Gauge liveConnections;\n    private final Gauge nettyChannelBufferSize;\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(MeterRegistry registry, MrePublishConfiguration config) {\n        this.connectionSuccess = registry.counter(\"http.event.channel.manager.connection.success\");\n        this.connectionFailure = registry.counter(\"http.event.channel.manager.connection.failure\");\n        this.liveConnections = Gauge.builder(\"http.event.channel.manager.live.connections\", this::getLiveConnections).register(registry);\n        this.nettyChannelBufferSize = Gauge.builder(\"http.event.channel.manager.netty.channel.buffer.size\", this::getNettyChannelBufferSize).register(registry);\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.encoderEventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.channels = new ConcurrentHashMap<>();\n\n        this.bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, lowWriteBufferWatermark)\n                .option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, highWriteBufferWatermark)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpClientCodec());\n                        if (config.isSslEnabled()) {\n                            SslContext sslContext = SslContextBuilder.forClient()\n                                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                    .build();\n                            pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                        }\n                        pipeline.addLast(new HttpEventChannelHandler());\n                    }\n                });\n    }\n\n    public Channel findOrCreate(InetSocketAddress address) {\n        String hostPortString = getHostPortString(address);\n        return channels.computeIfAbsent(hostPortString, key -> {\n            ChannelFuture future = bootstrap.connect(address);\n            future.addListener((GenericFutureListener<Future<? super Void>>) future1 -> {\n                if (future1.isSuccess()) {\n                    connectionSuccess.increment();\n                    LOG.debug(\"Successfully connected to {}\", address);\n                } else {\n                    connectionFailure.increment();\n                    LOG.error(\"Failed to connect to {}\", address, future1.cause());\n                }\n            });\n            return future.channel();\n        });\n    }\n\n    public Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    public void close(InetSocketAddress address) {\n        Channel channel = channels.remove(getHostPortString(address));\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + \":\" + address.getPort();\n    }\n\n    private int getLiveConnections() {\n        return channels.size();\n    }\n\n    private int getNettyChannelBufferSize() {\n        return eventLoopGroup.submit(() -> {\n            for (EventLoop eventLoop : eventLoopGroup) {\n                if (eventLoop instanceof NioEventLoop) {\n                    return ((NioEventLoop) eventLoop).bufferedWriteBytes();\n                }\n            }\n            return 0;\n        }).get(1, TimeUnit.SECONDS);\n    }\n}\n```"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Implement a Netty-based TCP client for tracking device communication that supports secure connections and periodic reconnection.\n\nClass Description: The TrackerClient class is an abstract implementation of a TCP client using Netty framework for communicating with tracking devices. It handles secure connections (SSL/TLS), manages connection lifecycle, and supports periodic reconnection. The class serves as a base for specific protocol implementations.\n\nAttributes:\n- secure: [boolean] - Indicates whether SSL/TLS encryption should be used\n- interval: [long] - Reconnection interval in seconds (0 means no reconnection)\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- port: [int] - Target server port number\n- address: [String] - Target server address\n- devices: [String[]] - Array of device identifiers to track\n- channelGroup: [ChannelGroup] - Manages all active channels\n\nMethods:\n- TrackerClient([Config] config, [String] protocol) -> [void] - Constructor that initializes the client with configuration and protocol settings\n- addProtocolHandlers([PipelineBuilder] pipeline, [Config] config) -> [void] - Abstract method to be implemented by subclasses for protocol-specific handlers\n- start() -> [void] - Starts the client and establishes connection to server\n- stop() -> [void] - Stops the client and closes all connections\n- isDatagram() -> [boolean] - Returns false indicating this is a TCP client\n- isSecure() -> [boolean] - Returns whether SSL/TLS is enabled\n- getDevices() -> [String[]] - Returns array of device identifiers\n- getChannelGroup() -> [ChannelGroup] - Returns the channel group managing all connections",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class TrackerClient implements TrackerConnector {\n\n    private final boolean secure;\n    private final long interval;\n    private final Bootstrap bootstrap;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    public TrackerClient(Config config, String protocol) {\n        secure = config.getBoolean(Keys.PROTOCOL_SSL.withPrefix(protocol));\n        interval = config.getLong(Keys.PROTOCOL_INTERVAL.withPrefix(protocol));\n        address = config.getString(Keys.PROTOCOL_ADDRESS.withPrefix(protocol));\n        port = config.getInteger(Keys.PROTOCOL_PORT.withPrefix(protocol), secure ? 443 : 80);\n        devices = config.getString(Keys.PROTOCOL_DEVICES.withPrefix(protocol)).split(\"[, ]\");\n\n        BasePipelineFactory pipelineFactory = new BasePipelineFactory(this, config, protocol) {\n            @Override\n            protected void addTransportHandlers(PipelineBuilder pipeline) {\n                try {\n                    if (isSecure()) {\n                        SSLEngine engine = SSLContext.getDefault().createSSLEngine();\n                        engine.setUseClientMode(true);\n                        pipeline.addLast(new SslHandler(engine));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            @Override\n            protected void addProtocolHandlers(PipelineBuilder pipeline) {\n                try {\n                    TrackerClient.this.addProtocolHandlers(pipeline, config);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n\n        bootstrap = new Bootstrap()\n                .group(EventLoopGroupFactory.getWorkerGroup())\n                .channel(NioSocketChannel.class)\n                .handler(pipelineFactory);\n    }\n\n    protected abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config) throws Exception;\n\n    @Override\n    public void start() throws Exception {\n        bootstrap.connect(address, port)\n                .syncUninterruptibly().channel().closeFuture().addListener(new GenericFutureListener<>() {\n                    @Override\n                    public void operationComplete(Future<? super Void> future) {\n                        if (interval > 0) {\n                            GlobalEventExecutor.INSTANCE.schedule(() -> {\n                                bootstrap.connect(address, port)\n                                        .syncUninterruptibly().channel().closeFuture().addListener(this);\n                            }, interval, TimeUnit.SECONDS);\n                        }\n                    }\n                });\n    }\n\n    @Override\n    public void stop() {\n        channelGroup.close().awaitUninterruptibly();\n    }\n\n    @Override\n    public boolean isDatagram() {\n        return false;\n    }\n\n    @Override\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    @Override\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\npublic abstract class TrackerClient {\n    private final boolean secure;\n    private final long interval;\n    private final Bootstrap bootstrap;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final ChannelGroup channelGroup;\n\n    public TrackerClient(Config config, String protocol) {\n        this.secure = config.isSecure();\n        this.interval = config.getReconnectInterval();\n        this.bootstrap = new Bootstrap();\n        this.port = config.getPort();\n        this.address = config.getAddress();\n        this.devices = config.getDevices();\n        this.channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n    }\n\n    protected abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config);\n\n    public void start() {\n        // Implementation for starting the client and establishing connection to server\n    }\n\n    public void stop() {\n        // Implementation for stopping the client and closing all connections\n    }\n\n    public boolean isDatagram() {\n        return false;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.util.Queue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts;\n    private final AtomicBoolean callbackInvoked;\n    private final CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen;\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private Future<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SslContext sslCtx) {\n        this.hostname = hostname;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        this.responseParts = new ArrayDeque<>();\n        this.callbackInvoked = new AtomicBoolean(false);\n        this.communicationHandler = new CommunicationHandler();\n        this.isOpen = new AtomicBoolean(false);\n        this.b.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), hostname, port));\n                        }\n                        p.addLast(new HttpClientCodec());\n                        p.addLast(new HttpContentDecompressor());\n                        p.addLast(communicationHandler);\n                    }\n                });\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        this.responseFuture = new FutureResult<>();\n        this.callbackInvoked.set(false);\n        this.isOpen.set(true);\n        this.exception = null;\n        this.isKeepAlive = HttpUtil.isKeepAlive(request);\n\n        if (channelConnectFuture == null || !channelConnectFuture.channel().isActive()) {\n            createChannel();\n        } else {\n            resetState();\n            sendRequest();\n        }\n\n        return responseFuture;\n    }\n\n    public void close() {\n        isOpen.set(false);\n        if (channelConnectFuture != null) {\n            channelConnectFuture.channel().close();\n        }\n        group.shutdownGracefully();\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        if (content != null) {\n            content.close();\n        }\n        content = null;\n        request = null;\n        callback = null;\n        responseFuture = null;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(hostname, port);\n        channelConnectFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    sendRequest();\n                } else {\n                    exception = future.cause();\n                    invokeFutureAndCallback(\"Failed to connect to server\");\n                }\n            }\n        });\n    }\n\n    private void sendRequest() {\n        Channel channel = channelConnectFuture.channel();\n        if (channel.isActive()) {\n            channel.writeAndFlush(request);\n            if (content != null) {\n                content.sendChunks(new ChunkedInputListener() {\n                    @Override\n                    public void chunkSent() {\n                        if (!channel.isActive()) {\n                            exception = new Exception(\"Channel closed while sending content\");\n                            invokeFutureAndCallback(\"Channel closed while sending content\");\n                        }\n                    }\n\n                    @Override\n                    public void lastChunkSent() {\n                        if (isKeepAlive) {\n                            channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n                        }\n                    }\n                });\n            }\n        } else {\n            exception = new Exception(\"Channel not active\");\n            invokeFutureAndCallback(\"Channel not active\");\n        }\n    }\n\n    private void invokeFutureAndCallback(String message) {\n        if (responseFuture != null && !callbackInvoked.getAndSet(true)) {\n            if (exception != null) {\n                responseFuture.setFailure(exception);\n            } else {\n                responseFuture.setSuccess(new ResponseParts(responseParts, isKeepAlive));\n            }\n            if (callback != null) {\n                callback.onResponse(responseFuture.getNow());\n            }\n        }\n    }\n\n    private static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final boolean isKeepAlive;\n\n        public ResponseParts(Queue<HttpObject> parts, boolean isKeepAlive) {\n            this.parts = parts;\n            this.isKeepAlive = isKeepAlive;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public boolean isKeepAlive() {\n            return isKeepAlive;\n        }\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                if (HttpUtil.isContentLengthUnknown(response)) {\n                    exception = new Exception(\"Content length is unknown\");\n                    invokeFutureAndCallback(\"Content length is unknown\");\n                    return;\n                }\n            }\n            if (msg instanceof HttpContent) {\n                responseParts.add(msg);\n                if (msg instanceof LastHttpContent) {\n                    invokeFutureAndCallback(null);\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            exception = cause;\n            invokeFutureAndCallback(\"Exception caught\");\n        }\n    }\n\n    public interface Callback<T> {\n        void onResponse(T response);\n    }\n\n    private static class FutureResult<T> implements Future<T> {\n        private T result;\n        private boolean done;\n\n        public synchronized void setSuccess(T result) {\n            this.result = result;\n            this.done = true;\n            notifyAll();\n        }\n\n        public synchronized void setFailure(Throwable cause) {\n            this.result = null;\n            this.done = true;\n            notifyAll();\n        }\n\n        public synchronized T getNow() {\n            return result;\n        }\n\n        public boolean isSuccess() {\n            return done;\n        }\n\n        public boolean isCancellable() {\n            return false;\n        }\n\n        public boolean isDone() {\n            return done;\n        }\n\n        public T get() throws InterruptedException {\n            if (!isDone()) {\n                wait();\n            }\n            return result;\n        }\n\n        public T get(long timeout, TimeUnit unit) throws InterruptedException {\n            if (!isDone()) {\n                wait(unit.toMillis(timeout));\n            }\n            return result;\n        }\n\n        public boolean cancel(boolean mayInterruptIfRunning) {\n            return false;\n        }\n\n        public boolean awaitUninterruptibly() {\n            return true;\n        }\n\n        public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {\n            return true;\n        }\n\n        public boolean await(long timeout, TimeUnit unit) throws InterruptedException {\n            if (!isDone()) {\n                wait(unit.toMillis(timeout));\n            }\n            return true;\n        }\n\n        public T sync() throws InterruptedException {\n            if (!isDone()) {\n                wait();\n            }\n            return result;\n        }\n\n        public T syncUninterruptibly() {\n            return result;\n        }\n\n        public Future<T> addListener(GenericFutureListener<? extends Future<? super T>> listener) {\n            return this;\n        }\n\n        public Future<T> addListeners(GenericFutureListener<? extends Future<? super T>>... listeners) {\n            return this;\n        }\n\n        public Future<T> removeListener(GenericFutureListener<? extends Future<? super T>> listener) {\n            return this;\n        }\n\n        public Future<T> removeListeners(GenericFutureListener<? extends Future<? super T>>... listeners) {\n            return this;\n        }\n\n        public Future<T> await() throws InterruptedException {\n            if (!isDone()) {\n                wait();\n            }\n            return this;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport org.apache.lucene.store.OutputStreamDataOutput;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.stream.ReleasableBytesStreamOutput;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.shard.ShardId;\nimport org.elasticsearch.index.translog.Checkpoint;\nimport org.elasticsearch.index.translog.TranslogHeader;\nimport org.elasticsearch.index.translog.TranslogTragicExceptionHolder;\n\nimport java.io.Closeable;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private final long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock;\n    private final Object syncLock = new Object();\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint checkpoint, FileChannel channel, FileChannel checkpointChannel, Path checkpointPath, Path translogPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier, LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TranslogTragicExceptionHolder tragicExceptionHolder, LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) {\n        super(shardId, checkpoint, translogPath, header, tragicExceptionHolder);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = checkpoint.offset();\n        this.writeLock = bigArrays.newLock();\n        this.buffer = new ReleasableBytesStreamOutput(bigArrays.newBytesArray(bufferSize.getBytes(), false));\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference bytes) {\n        synchronized (syncLock) {\n            try {\n                writeLock.acquire();\n                buffer.reset();\n                try (OutputStreamDataOutput out = new OutputStreamDataOutput(buffer)) {\n                    bytes.writeTo(out);\n                }\n                writeToFile(buffer.slice());\n            } finally {\n                writeLock.release();\n            }\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) {\n        try {\n            Channels.writeFully(channel, totalOffset, buffer);\n            totalOffset += buffer.limit();\n        } catch (Exception e) {\n            tragicExceptionHolder.addException(e);\n        }\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) {\n        try {\n            channel.read(buffer, position);\n        } catch (Exception e) {\n            tragicExceptionHolder.addException(e);\n        }\n    }\n\n    public static void writeCheckpoint(FileChannel channel, Path checkpointPath, Checkpoint checkpoint) {\n        try {\n            channel.truncate(0);\n            channel.position(0);\n            checkpoint.writeTo(channel);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"failed to write checkpoint to \" + checkpointPath, e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                buffer.close();\n            } catch (Exception e) {\n                tragicExceptionHolder.addException(e);\n            }\n            try {\n                channel.close();\n            } catch (Exception e) {\n                tragicExceptionHolder.addException(e);\n            }\n            try {\n                checkpointChannel.close();\n            } catch (Exception e) {\n                tragicExceptionHolder.addException(e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles incoming client connections and processes requests using a RESTful service configuration.\n\nClass Description: NettyRestfulService is a final class that implements a RestfulService interface, providing functionality to start and stop a Netty TCP server with configurable host and port settings. It uses Netty's NIO event loop groups for efficient connection handling and includes proper resource cleanup during shutdown.\n\nAttributes:\n- DEFAULT_WORKER_GROUP_THREADS: [int] - Default number of worker threads calculated based on available processors\n- config: [NettyRestfulServiceConfiguration] - Configuration object containing host and port settings\n- serverBootstrap: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n- bossEventLoopGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerEventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n\nMethods:\n- initServerBootstrap() -> [void] - Initializes the server bootstrap with event loop groups, channel type, and pipeline handlers\n- startup() -> [void] - Starts the server by binding to the configured host and port, logs success/failure\n- shutdown() -> [void] - Gracefully shuts down the server by closing event loop groups and releasing resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.NettyRuntime;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shardingsphere.elasticjob.restful.pipeline.RestfulServiceChannelInitializer;\n\n@RequiredArgsConstructor\n@Slf4j\npublic final class NettyRestfulService implements RestfulService {\n\n    private static final int DEFAULT_WORKER_GROUP_THREADS = 1 + 2 * NettyRuntime.availableProcessors();\n\n    private final NettyRestfulServiceConfiguration config;\n\n    private ServerBootstrap serverBootstrap;\n\n    private EventLoopGroup bossEventLoopGroup;\n\n    private EventLoopGroup workerEventLoopGroup;\n\n    private void initServerBootstrap() {\n        bossEventLoopGroup = new NioEventLoopGroup();\n        workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n        serverBootstrap = new ServerBootstrap()\n                .group(bossEventLoopGroup, workerEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new RestfulServiceChannelInitializer(config));\n    }\n\n    @SneakyThrows(InterruptedException.class)\n    @Override\n    public void startup() {\n        initServerBootstrap();\n        ChannelFuture channelFuture = serverBootstrap.bind(config.getHost(), config.getPort());\n        channelFuture.addListener(future -> {\n            if (future.isSuccess()) {\n                log.info(\"Restful Service started on port {}.\", config.getPort());\n            } else {\n                log.error(\"Failed to start Restful Service.\", future.cause());\n            }\n        }).sync();\n    }\n\n    @Override\n    public void shutdown() {\n        bossEventLoopGroup.shutdownGracefully();\n        workerEventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic final class NettyRestfulService implements RestfulService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NettyRestfulService.class);\n    private static final int DEFAULT_WORKER_GROUP_THREADS = Runtime.getRuntime().availableProcessors() * 2;\n\n    private final NettyRestfulServiceConfiguration config;\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossEventLoopGroup;\n    private final EventLoopGroup workerEventLoopGroup;\n\n    public NettyRestfulService(NettyRestfulServiceConfiguration config) {\n        this.config = config;\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossEventLoopGroup = new NioEventLoopGroup();\n        this.workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n    }\n\n    @Override\n    public void startup() {\n        initServerBootstrap();\n        try {\n            ChannelFuture channelFuture = serverBootstrap.bind(config.getHost(), config.getPort()).sync();\n            LOGGER.info(\"Netty server started on {}:{}\", config.getHost(), config.getPort());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            LOGGER.error(\"Failed to start Netty server\", e);\n        } finally {\n            shutdown();\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        bossEventLoopGroup.shutdownGracefully();\n        workerEventLoopGroup.shutdownGracefully();\n        LOGGER.info(\"Netty server stopped\");\n    }\n\n    private void initServerBootstrap() {\n        serverBootstrap.group(bossEventLoopGroup, workerEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\"http-codec\", new HttpServerCodec());\n                        ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                        ch.pipeline().addLast(\"handler\", new NettyRestfulServiceHandler(config));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        // Process the chunk to calculate statistics for named numeric values\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel channel = FileChannel.open(filePath)) {\n            long fileSize = channel.size();\n            long chunkSize = 1024 * 1024; // 1MB chunk size\n            long position = 0;\n\n            while (position < fileSize) {\n                long remaining = fileSize - position;\n                long currentChunkSize = Math.min(chunkSize, remaining);\n\n                MappedByteBuffer chunk = channel.map(FileChannel.MapMode.READ_ONLY, position, currentChunkSize);\n                processChunk(chunk, currentChunkSize);\n\n                position += currentChunkSize;\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class AnonAllocator {\n    private static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        MAP_AND_UNLINK_SUPPORTED = testMapAndUnlinkSupport();\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                File tempFile = File.createTempFile(\"anon\", null);\n                tempFile.deleteOnExit();\n                RandomAccessFile file = new RandomAccessFile(tempFile, \"rw\");\n                FileChannel channel = file.getChannel();\n                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                channel.close();\n                file.close();\n                return buffer;\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to allocate memory-mapped buffer\", e);\n            }\n        } else {\n            return ByteBuffer.allocateDirect(size);\n        }\n    }\n\n    private static boolean testMapAndUnlinkSupport() {\n        try {\n            File tempFile = File.createTempFile(\"anon\", null);\n            tempFile.deleteOnExit();\n            RandomAccessFile file = new RandomAccessFile(tempFile, \"rw\");\n            FileChannel channel = file.getChannel();\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 4096);\n            channel.close();\n            file.close();\n            tempFile.delete();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.nio.channels.FileChannel;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic abstract class TransferType {\n    private String path;\n    private File file;\n    private long fileSize;\n    private int bufferSize;\n    private long syncSize;\n    private long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(bufferSize, remaining);\n    }\n\n    public boolean isSync(long position) {\n        return (position - syncPosition) >= syncSize;\n    }\n\n    public abstract List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable);\n\n    protected abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures);\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", file=\" + file +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                \", syncPosition=\" + syncPosition +\n                '}';\n    }\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a Java class for writing FLV (Flash Video) files using Java NIO's FileChannel and ByteBuffer for efficient file operations. The class should handle both new file creation and appending to existing files, including metadata management.\n\nClass Description: The FLVWriter class provides functionality to write FLV video files with proper headers, metadata tags, and media data tags. It uses Java NIO channels and buffers for efficient file operations, supporting both new file creation and appending to existing files while maintaining FLV format specifications.\n\nAttributes:\n- fileChannel: [SeekableByteChannel] - Channel for writing the final FLV output file\n- dataChannel: [SeekableByteChannel] - Temporary channel for storing tags before finalization\n- filePath: [String] - Path to the output FLV file\n- append: [boolean] - Flag indicating whether to append to an existing file\n- appendOffset: [long] - Position in existing file where new data should be appended\n- meta: [Map<String, ?>] - Metadata extracted from existing FLV file when appending\n\nMethods:\n- FLVWriter(String filePath) -> [void] - Constructor that initializes the writer with a file path for new file creation\n- FLVWriter(Path path, boolean append) -> [void] - Constructor that initializes the writer with append mode and handles existing file metadata\n- getMetaData(Path path, int maxTags) -> [Map<String, ?>] - Extracts metadata from an existing FLV file (private method)\n- createDataFile() -> [void] - Creates a temporary data file for storing tags (private method)\n- createOutputFile() -> [void] - Creates the final output FLV file (private method)\n- writeTag(ITag tag) -> [boolean] - Writes a media tag to the temporary data file\n- close() -> [void] - Finalizes the FLV file and cleans up resources\n- finalizeFlv() -> [long] - Combines temporary data with existing file (if appending) and writes final FLV file (private method)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Map;\n\npublic class FLVWriter {\n\n    private static final Logger log = LoggerFactory.getLogger(FLVWriter.class);\n\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset = 13L;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        try {\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        filePath = path.toFile().getAbsolutePath();\n        this.append = append;\n        try {\n            if (append) {\n                meta = getMetaData(path, 5);\n                Files.move(path, path.resolveSibling(path.toFile().getName().replace(\".flv\", \".old\")));\n            }\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) throws IOException {\n        Map<String, ?> meta = null;\n        try (SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n            long size = channel.size();\n            if (size > 0L) {\n                channel.position(appendOffset);\n                ByteBuffer dst = ByteBuffer.allocate(11);\n                do {\n                    int read = channel.read(dst);\n                    if (read > 0) {\n                        dst.flip();\n                        byte tagType = (byte) (dst.get() & 31);\n                        int bodySize = IOUtils.readUnsignedMediumInt(dst);\n                        if (tagType == ITag.TYPE_METADATA) {\n                            ByteBuffer buf = ByteBuffer.allocate(bodySize);\n                            read = channel.read(buf);\n                            if (read > 0) {\n                                buf.flip();\n                                Input input = new Input(IoBuffer.wrap(buf));\n                                String metaType = Deserializer.deserialize(input, String.class);\n                                meta = Deserializer.deserialize(input, Map.class);\n                                if (meta.containsKey(\"duration\")) {\n                                    appendOffset = channel.position() + 4L;\n                                    break;\n                                }\n                            }\n                            buf.compact();\n                        }\n                        channel.position(channel.position() + 4L);\n                        dst.compact();\n                    }\n                } while (--maxTags > 0);\n            }\n        }\n        return meta;\n    }\n\n    private void createDataFile() throws IOException {\n        Path path = Paths.get(filePath + \".ser\");\n        if (Files.deleteIfExists(path)) {\n            log.debug(\"Previous flv data file existed and was removed\");\n        }\n        this.dataChannel = Files.newByteChannel(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    private void createOutputFile() throws IOException {\n        this.fileChannel = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        try {\n            int bodySize = tag.getBodySize();\n            byte dataType = tag.getDataType();\n            IoBuffer tagBody = tag.getBody();\n            int totalTagSize = 11 + bodySize + 4;\n            ByteBuffer tagBuffer = ByteBuffer.allocate(totalTagSize);\n            int timestamp = tag.getTimestamp();\n            byte[] bodyBuf = new byte[bodySize];\n            tagBody.get(bodyBuf);\n            IOUtils.writeUnsignedByte(tagBuffer, dataType);\n            IOUtils.writeMediumInt(tagBuffer, bodySize);\n            IOUtils.writeExtendedMediumInt(tagBuffer, timestamp);\n            tagBuffer.put(new byte[] {0, 0, 0});\n            tagBuffer.put(bodyBuf);\n            tagBuffer.putInt(11 + bodySize);\n            tagBuffer.flip();\n            dataChannel.write(tagBuffer);\n            return true;\n        } catch (Exception e) {\n            log.error(\"Failed to write tag\", e);\n            return false;\n        }\n    }\n\n    public void close() {\n        try {\n            finalizeFlv();\n        } catch (Exception e) {\n            log.error(\"Failed to finalize FLV\", e);\n        } finally {\n            try {\n                if (dataChannel != null) dataChannel.close();\n                if (fileChannel != null) fileChannel.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close channels\", e);\n            }\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        createOutputFile();\n        writeHeader();\n        writeMetadataTag();\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n        if (append) {\n            Path prevFlv = Paths.get(filePath.replace(\".flv\", \".old\"));\n            if (Files.exists(prevFlv)) {\n                try (SeekableByteChannel prevChannel = Files.newByteChannel(prevFlv, StandardOpenOption.READ)) {\n                    prevChannel.position(appendOffset);\n                    int read;\n                    do {\n                        read = prevChannel.read(dst);\n                        if (read > 0) {\n                            dst.flip();\n                            fileChannel.write(dst);\n                            dst.compact();\n                        }\n                    } while (read > 0);\n                }\n                Files.deleteIfExists(prevFlv);\n            }\n        }\n        dataChannel.position(0L);\n        int read;\n        do {\n            read = dataChannel.read(dst);\n            if (read > 0) {\n                dst.flip();\n                fileChannel.write(dst);\n                dst.compact();\n            }\n        } while (read > 0);\n        Files.deleteIfExists(Paths.get(filePath + \".ser\"));\n        return fileChannel.position();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FLVWriter {\n\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        this.append = false;\n        this.appendOffset = 0;\n        this.meta = new HashMap<>();\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        this.filePath = path.toString();\n        this.append = append;\n        this.appendOffset = 0;\n        this.meta = new HashMap<>();\n        if (append) {\n            this.meta = getMetaData(path, 10);\n            this.appendOffset = (long) this.meta.get(\"fileSize\");\n        }\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) {\n        // TODO: Implement metadata extraction from existing FLV file\n        return new HashMap<>();\n    }\n\n    private void createDataFile() {\n        try {\n            Path dataFilePath = Files.createTempFile(\"flv_data\", \".tmp\");\n            dataChannel = Files.newByteChannel(dataFilePath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void createOutputFile() {\n        try {\n            fileChannel = Files.newByteChannel(Path.of(filePath), append ? StandardOpenOption.CREATE : StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean writeTag(ITag tag) {\n        // TODO: Implement writing a media tag to the temporary data file\n        return false;\n    }\n\n    public void close() {\n        try {\n            if (dataChannel != null) {\n                dataChannel.close();\n            }\n            if (fileChannel != null) {\n                fileChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private long finalizeFlv() {\n        // TODO: Implement combining temporary data with existing file (if appending) and writing final FLV file\n        return 0;\n    }\n}\n```"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Optional;\n\npublic class WidgetUtil {\n\n    private static final String WIDGET_URL = \"https://discordapp.com/api/guilds/%d/widget.json\";\n\n    public static Widget getWidget(long guildId) {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(String.format(WIDGET_URL, guildId)))\n                .GET()\n                .build();\n\n        try {\n            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            switch (response.statusCode()) {\n                case 200:\n                    return Widget.fromJson(response.body());\n                case 404:\n                    return null;\n                case 403:\n                    throw new RuntimeException(\"Access to the widget is forbidden.\");\n                case 429:\n                    throw new RateLimitedException(\"Rate limit exceeded.\");\n                default:\n                    throw new RuntimeException(\"Unexpected response code: \" + response.statusCode());\n            }\n        } catch (IOException | InterruptedException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private static class RateLimitedException extends RuntimeException {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n\n    private static class UncheckedIOException extends RuntimeException {\n        public UncheckedIOException(IOException e) {\n            super(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .build();\n\n    private static final OkHttpClient httpClientDoH = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .dns(new Dns())\n            .build();\n\n    private static final OkHttpClient httpClientWithCache = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .cache(new Cache(new File(System.getProperty(\"java.io.tmpdir\"), \"http-cache\"), 10 * 1024 * 1024))\n            .build();\n\n    private static final OkHttpClient httpClientWithCacheDoH = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .dns(new Dns())\n            .cache(new Cache(new File(System.getProperty(\"java.io.tmpdir\"), \"http-cache\"), 10 * 1024 * 1024))\n            .build();\n\n    private static final FallBackDNS fallbackDNS = new FallBackDNS();\n\n    private static final boolean doh = true;\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return followRedirects ? builder.followRedirects(true) : builder.followRedirects(false);\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        // Implementation not provided\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private final String json;\n\n        JsonRequestBody(String json) {\n            this.json = json;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.parse(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.writeUtf8(json);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.parse(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper;\n    private final String kmsToken;\n    private final Configuration hadoopConfiguration;\n    private final String endPointPrefix;\n    private final OkHttpClient httpClient;\n\n    public VaultClient(ObjectMapper objectMapper, String kmsToken, Configuration hadoopConfiguration, String endPointPrefix, OkHttpClient httpClient) {\n        this.objectMapper = objectMapper;\n        this.kmsToken = kmsToken;\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.httpClient = httpClient;\n    }\n\n    @Override\n    public String wrapKey(byte[] key, String masterKeyId) {\n        Map<String, String> payload = Map.of(\"plaintext\", Base64.getEncoder().encodeToString(key));\n        String response = getContentFromTransitEngine(\"encrypt\", masterKeyId, buildPayload(payload));\n        return parseReturn(response, \"ciphertext\");\n    }\n\n    @Override\n    public byte[] unwrapKey(String key, String masterKeyId) {\n        Map<String, String> payload = Map.of(\"ciphertext\", key);\n        String response = getContentFromTransitEngine(\"decrypt\", masterKeyId, buildPayload(payload));\n        return Base64.getDecoder().decode(parseReturn(response, \"plaintext\"));\n    }\n\n    private String getContentFromTransitEngine(String action, String masterKeyId, String payload) {\n        String url = endPointPrefix + \"/v1/transit/keys/\" + masterKeyId + \"/\" + action;\n        RequestBody body = RequestBody.create(payload, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .build();\n        return executeAndGetResponse(url, request);\n    }\n\n    private String executeAndGetResponse(String url, Request request) {\n        try {\n            return httpClient.newCall(request).execute().body().string();\n        } catch (IOException e) {\n            LOG.error(\"Error executing request to {}\", url, e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String buildPayload(Map<String, String> params) {\n        try {\n            return objectMapper.writeValueAsString(params);\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error building payload\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String parseReturn(String response, String key) {\n        try {\n            JsonNode node = objectMapper.readTree(response);\n            return node.get(\"data\").get(key).asText();\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error parsing response\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void refreshToken() {\n        // Implementation not shown\n    }\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.apache.hc.client5.http.classic.methods.HttpPost;\nimport org.apache.hc.client5.http.entity.UrlEncodedFormEntity;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\n\nimport java.io.IOException;\nimport java.util.Optional;\n\npublic class BeaconClient {\n    private final int port;\n    private final String token;\n\n    public BeaconClient(int port, String token) {\n        this.port = port;\n        this.token = token;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) {\n        HttpPost post = new HttpPost(\"http://localhost:\" + port + rawNode);\n        if (token != null) {\n            post.setHeader(\"Authorization\", \"Bearer \" + token);\n        }\n        try (CloseableHttpClient client = HttpClients.createDefault();\n             CloseableHttpResponse response = client.execute(post)) {\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                String result = EntityUtils.toString(entity);\n                return prov.parseResponse(result);\n            }\n        } catch (IOException | ParseException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) {\n        BeaconInterface<REQ> prov = req.getProvider();\n        String rawNode = prov.getEndpoint();\n        HttpPost post = new HttpPost(\"http://localhost:\" + port + rawNode);\n        if (token != null) {\n            post.setHeader(\"Authorization\", \"Bearer \" + token);\n        }\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            String json = mapper.writeValueAsString(req);\n            post.setEntity(new UrlEncodedFormEntity(prov.getParams()));\n            try (CloseableHttpClient client = HttpClients.createDefault();\n                 CloseableHttpResponse response = client.execute(post)) {\n                HttpEntity entity = response.getEntity();\n                if (entity != null) {\n                    String result = EntityUtils.toString(entity);\n                    return prov.parseResponse(result);\n                }\n            }\n        } catch (IOException | ParseException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        if (response.getCode() >= 400 && response.getCode() < 500) {\n            try {\n                ObjectMapper mapper = new ObjectMapper();\n                BeaconClientErrorResponse error = mapper.readValue(response.getBody(), BeaconClientErrorResponse.class);\n                return Optional.of(error);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return Optional.empty();\n    }\n\n    public Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        if (response.getCode() >= 500) {\n            try {\n                ObjectMapper mapper = new ObjectMapper();\n                BeaconServerErrorResponse error = mapper.readValue(response.getBody(), BeaconServerErrorResponse.class);\n                return Optional.of(error);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return Optional.empty();\n    }\n}\n```"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.util.Objects;\n\npublic class GraphHopperGeocoding {\n\n    private ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.objectMapper = new ObjectMapper();\n        this.downloader = new OkHttpClient();\n        this.routeServiceUrl = serviceUrl;\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) throws IOException {\n        OkHttpClient client = getClientForRequest(request);\n        String url = buildUrl(request);\n        Request httpRequest = new Request.Builder()\n                .url(url)\n                .build();\n        Response httpResponse = client.newCall(httpRequest).execute();\n        if (httpResponse.isSuccessful()) {\n            String json = httpResponse.body().string();\n            return objectMapper.readValue(json, GHGeocodingResponse.class);\n        } else {\n            throw new IOException(\"Request failed: \" + httpResponse.code() + \" \" + httpResponse.message());\n        }\n    }\n\n    public void setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        return downloader.newBuilder()\n                .connectTimeout(request.getTimeout() > 0 ? request.getTimeout() : DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .readTimeout(request.getTimeout() > 0 ? request.getTimeout() : DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        StringBuilder url = new StringBuilder(routeServiceUrl);\n        url.append(\"/geocode\");\n        url.append(\"?q=\").append(encodeURL(request.getQuery()));\n        if (request.getLocale() != null) {\n            url.append(\"&locale=\").append(encodeURL(request.getLocale()));\n        }\n        if (request.getPoints() != null) {\n            url.append(\"&points=\").append(encodeURL(request.getPoints()));\n        }\n        if (request.getBounds() != null) {\n            url.append(\"&bounds=\").append(encodeURL(request.getBounds()));\n        }\n        if (request.getPolygon() != null) {\n            url.append(\"&polygon=\").append(encodeURL(request.getPolygon()));\n        }\n        if (request.getLimit() > 0) {\n            url.append(\"&limit=\").append(request.getLimit());\n        }\n        if (request.getPolygonThreshold() > 0) {\n            url.append(\"&polygon_threshold=\").append(request.getPolygonThreshold());\n        }\n        if (request.getReverse() != null) {\n            url.append(\"&reverse=\").append(request.getReverse());\n        }\n        if (request.getPointHint() != null) {\n            url.append(\"&point_hint=\").append(encodeURL(request.getPointHint()));\n        }\n        if (request.getOsmType() != null) {\n            url.append(\"&osm_type=\").append(encodeURL(request.getOsmType()));\n        }\n        if (request.getOsmTags() != null) {\n            url.append(\"&osm_tags=\").append(encodeURL(request.getOsmTags()));\n        }\n        if (request.getPolygonSimplify() != null) {\n            url.append(\"&polygon_simplify=\").append(request.getPolygonSimplify());\n        }\n        if (request.getPolygonType() != null) {\n            url.append(\"&polygon_type=\").append(request.getPolygonType());\n        }\n        if (request.getIncludePolygon() != null) {\n            url.append(\"&include_polygon=\").append(request.getIncludePolygon());\n        }\n        if (request.getEle() != null) {\n            url.append(\"&ele=\").append(request.getEle());\n        }\n        if (request.getNamedetails() != null) {\n            url.append(\"&namedetails=\").append(request.getNamedetails());\n        }\n        if (request.getState() != null) {\n            url.append(\"&state=\").append(request.getState());\n        }\n        if (key != null) {\n            url.append(\"&key=\").append(key);\n        }\n        return url.toString();\n    }\n\n    private String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        GraphHopperGeocoding that = (GraphHopperGeocoding) o;\n        return DEFAULT_TIMEOUT == that.DEFAULT_TIMEOUT &&\n                Objects.equals(objectMapper, that.objectMapper) &&\n                Objects.equals(downloader, that.downloader) &&\n                Objects.equals(routeServiceUrl, that.routeServiceUrl) &&\n                Objects.equals(key, that.key);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(objectMapper, downloader, routeServiceUrl, key, DEFAULT_TIMEOUT);\n    }\n}\n```"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"https://danbooru.donmai.us\";\n    private OkHttpClient client;\n    private Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n        this.gidPattern = Pattern.compile(\"https?://danbooru\\\\.donmai\\\\.us/posts/\\\\d+\\\\.\\\\w+\");\n        this.currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        String url = String.format(\"%s/posts.json?page=%d\", DOMAIN, pageNum);\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n        Response response = client.newCall(request).execute();\n        return new JSONObject(response.body().string());\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String url = post.getString(\"file_url\");\n            urls.add(url);\n        }\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.toString());\n        if (!matcher.matches()) {\n            throw new MalformedURLException(\"Invalid Danbooru URL format\");\n        }\n        String[] parts = url.getPath().split(\"/\");\n        return parts[parts.length - 1].split(\"\\\\.\")[0];\n    }\n}\n```"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private OkHttpClient client;\n    private UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator(new String[]{\"http\", \"https\"}, UrlValidator.ALLOW_LOCAL_URLS);\n        this.expandBaseUrl = \"\";\n    }\n\n    public void setBaseUrl(String url) {\n        if (urlValidator.isValid(url)) {\n            this.expandBaseUrl = url + \"/ValueSet/$expand\";\n        } else {\n            throw new IllegalArgumentException(\"Invalid URL format\");\n        }\n    }\n\n    public Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid value set URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + \"?url=\" + valueSetUri)\n                .build();\n\n        try {\n            return client.newCall(request).execute();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error expanding value set\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\n\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class ApiClient {\n    private OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .writeTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) {\n        String url = \"https://api.github.com/copilot/token\";\n        String method = \"POST\";\n        String body = \"{\\\"apiKey\\\": \\\"\" + apiKey + \"\\\"}\";\n        Map<String, String> headers = createHeaders(null);\n        Response response = executeRequest(url, method, body, headers);\n        return response.body().string();\n    }\n\n    public String getCoCoToken(String apiKey) {\n        String url = \"https://api.cocopilot.com/token\";\n        String method = \"POST\";\n        String body = \"{\\\"apiKey\\\": \\\"\" + apiKey + \"\\\"}\";\n        Map<String, String> headers = createHeaders(null);\n        Response response = executeRequest(url, method, body, headers);\n        return response.body().string();\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, RequestBody.create(body, MediaType.parse(\"application/json\")));\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        try {\n            return client.newCall(request).execute();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"User-Agent\", \"CoCoPilot/1.0\");\n        headers.put(\"X-Machine-Id\", machineId);\n        if (chatToken != null) {\n            headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        }\n        return headers;\n    }\n}\n```"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
    "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport okhttp3.Headers;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class HttpDownloader extends InputStream {\n\n    private String contentType;\n    private long contentLength;\n    private long contentEnd;\n    private Headers header;\n    private int statusCode;\n    private String directUrl;\n    private volatile static int curConnId = 0;\n    private volatile boolean closed = false;\n    private int connId;\n    private InputStream is;\n    private Queue<Callable<InputStream>> callableQueue;\n    private Queue<Future<InputStream>> futureQueue;\n    private static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    private ExecutorService executorService;\n    private boolean supportRange;\n    private int blockSize = 10 * 1024 * 1024;\n    private int threadNum = 2;\n    private String cookie;\n    private String referer;\n    private int blockCounter = 0;\n    private OkHttpClient downloadClient;\n    private OkHttpClient defaultClient;\n\n    public HttpDownloader(Map<String, String> params) {\n        // Initialization code\n    }\n\n    public void createDownloadTask(String url, Map<String, String> headers) {\n        // Task creation code\n    }\n\n    public InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        // Download task code\n        return null;\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        // Internal download code\n        return null;\n    }\n\n    @Override\n    public int read(byte[] buffer, int off, int len) throws IOException {\n        // Read data from download stream\n        return 0;\n    }\n\n    @Override\n    public int read() throws IOException {\n        // Throws IOException (not implemented)\n        throw new IOException();\n    }\n\n    public void close() {\n        // Cleanup resources and stop downloads\n    }\n\n    private void runTask(int num) {\n        // Start specified number of download tasks\n    }\n}\n```"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "```java\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ItemStream;\nimport org.springframework.batch.item.ItemStreamException;\nimport org.springframework.batch.item.ParseException;\nimport org.springframework.batch.item.UnexpectedInputException;\nimport org.springframework.batch.item.support.AbstractItemCountingItemStreamItemReader;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class KafkaItemReader<K, V> extends AbstractItemCountingItemStreamItemReader<V> implements ItemStream {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topicPartitionOffsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30000;\n\n    private final List<TopicPartition> topicPartitions;\n    private final Map<TopicPartition, Long> partitionOffsets;\n    private final KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private final Duration pollTimeout;\n    private final boolean saveState;\n\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private AtomicBoolean initialized = new AtomicBoolean(false);\n\n    public KafkaItemReader(Properties consumerProperties, String topic, Integer... partitions) {\n        this(consumerProperties, topic, new ArrayList<>(List.of(partitions)));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<Integer> partitions) {\n        this(consumerProperties, topic, partitions.stream().map(p -> new TopicPartition(topic, p)).toList());\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<TopicPartition> topicPartitions) {\n        this(consumerProperties, topicPartitions, DEFAULT_POLL_TIMEOUT, true);\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, Integer... partitions, long pollTimeout, boolean saveState) {\n        this(consumerProperties, topic, new ArrayList<>(List.of(partitions)), pollTimeout, saveState);\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<Integer> partitions, long pollTimeout, boolean saveState) {\n        this(consumerProperties, topic, partitions.stream().map(p -> new TopicPartition(topic, p)).toList(), pollTimeout, saveState);\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<TopicPartition> topicPartitions, long pollTimeout, boolean saveState) {\n        super();\n        this.consumerProperties = consumerProperties;\n        this.topicPartitions = topicPartitions;\n        this.partitionOffsets = Collections.synchronizedMap(new HashMap<>());\n        this.pollTimeout = Duration.ofMillis(pollTimeout);\n        this.saveState = saveState;\n        this.kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) throws ItemStreamException {\n        Assert.state(!initialized.get(), \"Reader already initialized\");\n        initialized.set(true);\n\n        if (saveState) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n            if (offsets != null) {\n                partitionOffsets.putAll(offsets);\n            }\n        }\n\n        kafkaConsumer.assign(topicPartitions);\n        topicPartitions.forEach(tp -> kafkaConsumer.seek(tp, partitionOffsets.getOrDefault(tp, 0L)));\n\n        consumerRecords = poll().iterator();\n    }\n\n    @Override\n    protected V doRead() throws Exception {\n        if (!consumerRecords.hasNext()) {\n            consumerRecords = poll().iterator();\n            if (!consumerRecords.hasNext()) {\n                return null;\n            }\n        }\n\n        ConsumerRecord<K, V> record = consumerRecords.next();\n        partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset() + 1);\n        return record.value();\n    }\n\n    @Override\n    protected void doUpdate(ExecutionContext executionContext) throws ItemStreamException {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, partitionOffsets);\n        }\n        kafkaConsumer.commitSync();\n    }\n\n    @Override\n    protected void doClose() throws ItemStreamException {\n        kafkaConsumer.close();\n    }\n\n    private ConsumerRecords<K, V> poll() {\n        return kafkaConsumer.poll(pollTimeout);\n    }\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "```java\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\n\nimport java.util.Properties;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends Thread {\n    private final String topic;\n    private final TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock;\n    private final Condition offsetReachedThreshold;\n    private final Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic;\n    private final Properties consumerProps;\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        this.topic = topic;\n        this.topicPartition = new TopicPartition(topic, 0);\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n        this.offsetUpdateLock = new ReentrantLock();\n        this.offsetReachedThreshold = offsetUpdateLock.newCondition();\n        this.consumer = new KafkaConsumer<>(consumerProps);\n        this.offsetInSchemasTopic = 0;\n        this.consumerProps = new Properties();\n        consumerProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        consumerProps.put(\"group.id\", groupId);\n        consumerProps.put(\"key.deserializer\", serializer.getKeyDeserializer());\n        consumerProps.put(\"value.deserializer\", serializer.getValueDeserializer());\n    }\n\n    @Override\n    public void run() {\n        consumer.subscribe(Collections.singletonList(topic));\n        while (!Thread.currentThread().isInterrupted()) {\n            ConsumerRecords<byte[], byte[]> records = consumer.poll(100);\n            for (ConsumerRecord<byte[], byte[]> record : records) {\n                K key = serializer.deserializeKey(record.key());\n                V value = serializer.deserializeValue(record.value());\n                if (storeUpdateHandler.validate(key, value)) {\n                    localStore.update(key, value);\n                    offsetInSchemasTopic = record.offset();\n                }\n            }\n            offsetUpdateLock.lock();\n            try {\n                if (offsetInSchemasTopic >= 1000) {\n                    offsetReachedThreshold.signalAll();\n                }\n            } finally {\n                offsetUpdateLock.unlock();\n            }\n        }\n        consumer.close();\n    }\n\n    public void shutdown() {\n        interrupt();\n    }\n}\n```"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.util.Properties;\n\npublic class KafkaStoreProducer<K, V> {\n    private KafkaProducer<byte[], byte[]> producer;\n    private String topic;\n    private Serializer<K, V> serializer;\n    private int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n        configProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        configProps.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        configProps.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        this.producer = new KafkaProducer<>(configProps);\n    }\n\n    public V put(K key, V value) {\n        try {\n            byte[] keyBytes = serializer.serialize(topic, key);\n            byte[] valueBytes = serializer.serialize(topic, value);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, keyBytes, valueBytes);\n            producer.send(record).get(timeout, java.util.concurrent.TimeUnit.MILLISECONDS);\n            return value;\n        } catch (Exception e) {\n            if (e instanceof java.util.concurrent.TimeoutException) {\n                throw new StoreTimeoutException(\"Timeout while sending message to Kafka topic: \" + topic, e);\n            } else {\n                throw new StoreException(\"Error while sending message to Kafka topic: \" + topic, e);\n            }\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}\n```"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\n\nimport java.util.Properties;\n\npublic class KafkaProducerWrapper {\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson;\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.gson = new Gson();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", kafkaBrokers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.LongSerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        String jsonString = gson.toJson(jsonElement);\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName, jsonString);\n        kafkaProducer.send(record);\n    }\n\n    public void close() {\n        kafkaProducer.close();\n    }\n}\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport org.apache.flink.api.common.functions.RichMapFunction;\nimport org.apache.flink.api.common.serialization.SimpleStringSchema;\nimport org.apache.flink.api.common.typeinfo.TypeInformation;\nimport org.apache.flink.api.java.typeutils.ResultTypeQueryable;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;\nimport org.apache.flink.streaming.connectors.kafka.KafkaSerializationSchema;\nimport org.apache.flink.streaming.connectors.kafka.internals.KeyedSerializationSchemaWrapper;\nimport org.apache.flink.streaming.connectors.kafka.internals.NonKeyedSerializationSchemaWrapper;\nimport org.apache.flink.streaming.connectors.kafka.internals.SerializationSchemaWrapper;\nimport org.apache.flink.streaming.connectors.kafka.internals.StaticKeyedSerializationSchema;\nimport org.apache.flink.streaming.connectors.kafka.internals.StaticNonKeyedSerializationSchema;\nimport org.apache.flink.streaming.connectors.kafka.internals.StaticSerializationSchemaWrapper;\nimport org.apache.flink.streaming.connectors.kafka.internals.TopicPartition;\nimport org.apache.flink.streaming.connectors.kafka.KafkaSerializationSchema;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\nimport org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer.Semantic;\n"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.errors.RetriableException;\nimport org.apache.kafka.common.errors.TimeoutException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.NotLeaderForPartitionException;\nimport org.apache.kafka.common.errors.NetworkException;\nimport org.apache.kafka.common.errors.LeaderNotAvailableException;\nimport org.apache.kafka.common.errors.UnknownServerException;\nimport org.apache.kafka.common.errors.ApiException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.InvalidTopicException;\nimport org.apache.kafka.common.errors.InvalidRecordException;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasException;\nimport org.apache.kafka.common.errors.NotEnoughReplicasAfterAppendException;\nimport org.apache.kafka.common.errors.OffsetOutOfRangeException;\nimport org.apache.kafka.common.errors.CorruptRecordException;\nimport org.apache.kafka.common.errors.AuthorizationException;\nimport org.apache.kafka.common.errors.UnknownTopic"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.kafka.support.TopicPartition;\nimport org.springframework.util.concurrent.ListenableFuture;\nimport org.springframework.util.concurrent.ListenableFutureCallback;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush, boolean transactional) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = transactional;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return send(topic, null, data);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return send(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return send(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Producer<K, V> producer = getTheProducer(record.topic());\n        producer.send(record, new Callback() {\n            @Override\n            public void onCompletion(RecordMetadata metadata, Exception exception) {\n                if (exception != null) {\n                    future.completeExceptionally(exception);\n                } else {\n                    future.complete(new SendResult<>(record, metadata));\n                }\n            }\n        });\n        if (autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    private CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        producer.send(producerRecord, new Callback() {\n            @Override\n            public void onCompletion(RecordMetadata metadata, Exception exception) {\n                if (exception != null) {\n                    future.completeExceptionally(exception);\n                } else {\n                    future.complete(new SendResult<>(producerRecord, metadata));\n                }\n            }\n        });\n        if (autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer(topic);\n        return producer.partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        return producer.metrics();\n    }\n\n    private void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    private Producer<K, V> getTheProducer() {\n        return producerFactory.createProducer();\n    }\n\n    private Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    private boolean inTransaction() {\n        return transactional;\n    }\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private static final String DEFAULT_PREFIX = \"job-\";\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private final FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel, FileLock lock) {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = lock;\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(DEFAULT_PREFIX, directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path file = directory.resolve(prefix + System.currentTimeMillis());\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n        FileLock lock = channel.lock();\n        return new JobPrefixFile(prefix, file, channel, lock);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE);\n        FileLock lock = channel.tryLock();\n        if (lock != null) {\n            String prefix = file.getFileName().toString().replaceFirst(\"\\\\-\\\\d+$\", \"\");\n            return new JobPrefixFile(prefix, file, channel, lock);\n        } else {\n            channel.close();\n            return null;\n        }\n    }\n\n    public void delete() {\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() {\n        try {\n            lock.release();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        close(channel);\n    }\n\n    @Override\n    public void close() {\n        release();\n    }\n\n    private static void deleteIfExists(Path file) {\n        try {\n            Files.deleteIfExists(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\n\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private final Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"com.example.serialization.MaintenancePlanSerializer\");\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, MaintenancePlan> record = new ProducerRecord<>(topic, maintenancePlan.getId(), maintenancePlan);\n        _producer.send(record);\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}\n```"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\n\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}\n```"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, supporting SSL/TLS encryption and providing methods for server startup and shutdown.\n\nClass Description: BaseHttp2Server is an abstract class that serves as a foundation for building HTTP/2 servers using Netty. It handles SSL/TLS configuration, channel management, and provides basic server lifecycle methods. Concrete implementations must define their own request handlers.\n\nAttributes:\n- sslContext: [SslContext] - SSL/TLS context for secure connections\n- hasReleasedSslContext: [AtomicBoolean] - Tracks whether SSL context resources have been released\n- bootstrap: [ServerBootstrap] - Netty server bootstrap configuration\n- shouldShutDownEventLoopGroup: [boolean] - Flag indicating whether to shutdown event loop group\n- allChannels: [ChannelGroup] - Tracks all active server channels\n\nMethods:\n- BaseHttp2Server([SslContext], [EventLoopGroup]) -> [void] - Constructor that initializes the server with SSL context and optional event loop group\n- addHandlersToPipeline([SSLSession], [ChannelPipeline]) -> [void] - Abstract method to be implemented by subclasses for adding custom handlers to the pipeline\n- start([int]) -> [CompletableFuture<Integer>] - Starts the server on specified port and returns future with bound port number\n- shutdown() -> [CompletableFuture<Void>] - Gracefully shuts down the server and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Future;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLSession;\n\nabstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    BaseHttp2Server(final SslContext sslContext, final EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n\n        if (this.sslContext instanceof ReferenceCounted) {\n            ((ReferenceCounted) this.sslContext).retain();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n\n        if (eventLoopGroup != null) {\n            this.bootstrap.group(eventLoopGroup);\n            this.shouldShutDownEventLoopGroup = false;\n        } else {\n            this.bootstrap.group(new NioEventLoopGroup(1));\n            this.shouldShutDownEventLoopGroup = true;\n        }\n\n        this.allChannels = new DefaultChannelGroup(this.bootstrap.config().group().next());\n\n        this.bootstrap.channel(ServerChannelClassUtil.getServerSocketChannelClass(this.bootstrap.config().group()));\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(final SocketChannel channel) {\n                final SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                channel.pipeline().addLast(sslHandler);\n\n                sslHandler.handshakeFuture().addListener(handshakeFuture -> {\n                    if (handshakeFuture.isSuccess()) {\n                        BaseHttp2Server.this.addHandlersToPipeline(sslHandler.engine().getSession(), channel.pipeline());\n                        BaseHttp2Server.this.allChannels.add(channel);\n                    }\n                });\n            }\n        });\n    }\n\n    protected abstract void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception;\n\n    public CompletableFuture<Integer> start(final int port) {\n        final ChannelFuture channelFuture = this.bootstrap.bind(port);\n        this.allChannels.add(channelFuture.channel());\n\n        final CompletableFuture<Integer> startFuture = new CompletableFuture<>();\n\n        channelFuture.addListener((future -> {\n            if (future.isSuccess()) {\n                startFuture.complete(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n            } else {\n                startFuture.completeExceptionally(future.cause());\n            }\n        }));\n\n        return startFuture;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        final Future<Void> channelCloseFuture = this.allChannels.close();\n\n        if (this.shouldShutDownEventLoopGroup) {\n            channelCloseFuture.addListener(future ->\n                    BaseHttp2Server.this.bootstrap.config().group().shutdownGracefully());\n\n            this.bootstrap.config().group().terminationFuture().addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            channelCloseFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        }\n\n        return shutdownFuture.thenRun(() -> {\n            if (BaseHttp2Server.this.sslContext instanceof ReferenceCounted) {\n                if (BaseHttp2Server.this.hasReleasedSslContext.compareAndSet(false, true)) {\n                    ((ReferenceCounted) BaseHttp2Server.this.sslContext).release();\n                }\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http2.Http2CodecUtil;\nimport io.netty.handler.codec.http2.Http2Connection;\nimport io.netty.handler.codec.http2.Http2FrameCodecBuilder;\nimport io.netty.handler.codec.http2.Http2Settings;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic abstract class BaseHttp2Server {\n\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    protected BaseHttp2Server(SslContext sslContext, EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n        this.bootstrap = new ServerBootstrap();\n        this.shouldShutDownEventLoopGroup = eventLoopGroup == null;\n        if (eventLoopGroup == null) {\n            this.bootstrap.group(new NioEventLoopGroup());\n        } else {\n            this.bootstrap.group(eventLoopGroup);\n        }\n        this.bootstrap.channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        addHandlersToPipeline(ch.sslSession(), ch.pipeline());\n                    }\n                })\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    protected abstract void addHandlersToPipeline(SSLSession sslSession, ChannelPipeline pipeline);\n\n    public CompletableFuture<Integer> start(int port) {\n        CompletableFuture<Integer> future = new CompletableFuture<>();\n        bootstrap.bind(port).addListener((ChannelFutureListener) future::complete);\n        return future;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        if (hasReleasedSslContext.get()) {\n            future.complete(null);\n            return future;\n        }\n        ChannelFutureListener listener = future::complete;\n        if (shouldShutDownEventLoopGroup) {\n            bootstrap.group().shutdownGracefully().addListener(listener);\n        } else {\n            listener.operationComplete(ChannelFuture.failingFuture());\n        }\n        allChannels.close().addListener(listener);\n        return future;\n    }\n}\n```"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic abstract class RpcServer implements RemotingServer {\n    protected final Logger logger = LoggerFactory.getLogger(this.getClass());\n    protected final ServerBootstrap bootstrap = new ServerBootstrap();\n    protected final ChannelFuture channelFuture;\n    protected final ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>();\n    protected final EventLoopGroup bossGroup = new DefaultEventExecutorGroup(1);\n    protected final EventLoopGroup workerGroup = new DefaultEventExecutorGroup(8);\n    protected final RemotingAddressParser addressParser;\n    protected final DefaultServerConnectionManager connectionManager;\n    protected final RpcRemoting rpcRemoting;\n    protected final Codec codec;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.addressParser = new DefaultAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager(manageConnection);\n        this.rpcRemoting = new RpcRemoting(this);\n        this.codec = new DefaultCodec();\n        this.channelFuture = this.bootstrap.bind(port);\n    }\n\n    protected abstract void doInit();\n\n    protected abstract boolean doStart();\n\n    protected abstract void doStop();\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        this.userProcessors.put(processor.getType(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, timeoutMillis);\n    }\n}\n```"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class StackTraceDeobfuscator {\n\n    public static String deobfuscateStackTrace(Throwable t) {\n        if (!canDeobfuscate()) {\n            return getStackTrace(t);\n        }\n\n        String retraceScript = System.getProperty(\"os.name\").contains(\"Windows\") ? \"retrace.bat\" : \"retrace.sh\";\n        String mappingFile = System.getenv(\"XPIPE_MAPPING\");\n\n        try {\n            File tempFile = File.createTempFile(\"stacktrace\", \".txt\");\n            tempFile.deleteOnExit();\n            Files.write(Paths.get(tempFile.getAbsolutePath()), getStackTrace(t).getBytes());\n\n            ProcessBuilder processBuilder = new ProcessBuilder(retraceScript, mappingFile, tempFile.getAbsolutePath());\n            Process process = processBuilder.start();\n            process.waitFor();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            return output.toString();\n        } catch (IOException | InterruptedException e) {\n            return getStackTrace(t);\n        }\n    }\n\n    private static String getStackTrace(Throwable t) {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        t.printStackTrace(pw);\n        return sw.toString();\n    }\n\n    private static boolean canDeobfuscate() {\n        // Implement the logic to determine if deobfuscation should be attempted\n        return true;\n    }\n}\n```"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) {\n        pb.directory(processRoot);\n        Process process = null;\n        try {\n            process = pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        if (process != null) {\n            new AsyncPipe(process.getInputStream(), System.out).start();\n            new AsyncPipe(process.getErrorStream(), System.out).start();\n        }\n    }\n\n    private class AsyncPipe extends Thread {\n        private InputStream is;\n        private OutputStream os;\n        private boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, length);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\n\npublic class FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            mStream = new InputStreamReader(new FileInputStream(file));\n        } catch (FileNotFoundException e) {\n            if (shell == null) {\n                throw e;\n            }\n            try {\n                Process process = shell.createProcess(\"su\", \"-c\", \"cat \" + file);\n                mStream = new InputStreamReader(process.getInputStream());\n            } catch (IOException e2) {\n                try {\n                    Process process = shell.createProcess(\"toolbox\", \"cat\", file);\n                    mStream = new InputStreamReader(process.getInputStream());\n                } catch (IOException e3) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}\n```"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        try {\n            mCommandOutputStream.writeBytes(\"exit\\n\");\n            mCommandOutputStream.flush();\n            mProcess.destroy();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        exit();\n        try {\n            mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n\n    public ProcessShell readAll() {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        String line;\n        try {\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        String line;\n        try {\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}\n```"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.util.concurrent.ExecutionException;\n\npublic class NutReaderTest {\n\n    public static void testNutReader() throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n        String input = \"Samples/big_buck_bunny_720p_1mb.mp4\";\n        String output = \"output.nut\";\n\n        FFmpegProcessBuilder builder = new FFmpegProcessBuilder()\n                .input(input)\n                .output(output)\n                .videoCodec(\"rawvideo\")\n                .audioCodec(\"pcm_s32le\");\n\n        Process process = builder.start();\n\n        NutReader nutReader = new NutReader(output);\n        nutReader.setStreamHandler(new NutReader.StreamHandler() {\n            @Override\n            public void onStream(NutStream stream) {\n                // Handle stream event\n            }\n        });\n        nutReader.setFrameHandler(new NutReader.FrameHandler() {\n            @Override\n            public void onFrame(NutFrame frame) {\n                // Handle frame event\n            }\n        });\n\n        nutReader.start();\n\n        int exitCode = process.waitFor();\n        assert exitCode == 0;\n    }\n}\n```"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.charset.*;\nimport java.time.*;\nimport java.util.concurrent.*;\n\npublic class Command {\n    private Process process;\n    private OutputStream stdIn;\n    private File stdOut;\n    private File stdErr;\n    private String nextLine;\n    private String exit;\n    private Charset charset;\n    private LocalDateTime startTime;\n\n    public static Command of(String init) {\n        return new Command(init, System.lineSeparator(), \"exit\", StandardCharsets.UTF_8);\n    }\n\n    public static Command of(String init, Charset charset) {\n        return new Command(init, System.lineSeparator(), \"exit\", charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) {\n        try {\n            stdIn.write(str.getBytes(charset));\n            stdIn.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public Command line() {\n        write(nextLine);\n        return this;\n    }\n\n    public Command exit() {\n        write(exit);\n        return this;\n    }\n\n    public Command exec(String str) {\n        write(str);\n        line();\n        return this;\n    }\n\n    public CommandResult result() {\n        return result(0);\n    }\n\n    public CommandResult result(long millis) {\n        try {\n            if (millis > 0) {\n                if (!process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n                    process.destroyForcibly();\n                    return new CommandResult(false, null, null);\n                }\n            } else {\n                process.waitFor();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return new CommandResult(true, read(stdOut), read(stdErr));\n    }\n\n    public void close() {\n        process.destroy();\n        stdOut.delete();\n        stdErr.delete();\n    }\n\n    private String read(File file) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\n\npublic class FileChannelUtils {\n\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new OutputStream() {\n            @Override\n            public void write(int b) throws IOException {\n                channel.write(ByteBuffer.wrap(new byte[]{(byte) b}));\n            }\n\n            @Override\n            public void flush() throws IOException {\n                channel.force(false);\n            }\n\n            @Override\n            public void close() throws IOException {\n                channel.close();\n                if (forceAtClose) {\n                    channel.force(true);\n                }\n            }\n        };\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n        return newOutputStream(FileChannel.open(p, options), true);\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n        return FileChannel.open(p, options);\n    }\n}\n```"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic Object executeProcess(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    ProcessBuilder pb = new ProcessBuilder();\n    pb.directory(job.executeDir());\n    pb.redirectErrorStream(true);\n    List<String> command = new ArrayList<>();\n    command.add(job.shell());\n    command.add(job.command());\n    for (Map.Entry<String, Object> entry : parameters.entrySet()) {\n        command.add(entry.getKey() + \"=\" + entry.getValue());\n    }\n    pb.command(command);\n    Process process = null;\n    try {\n        process = pb.start();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        StringBuilder output = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(exitCode, output.toString());\n        }\n        return 0;\n    } catch (IOException | InterruptedException e) {\n        throw new HugeException(e);\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class JavaCompilerVersion {\n\n    public static String getJavaCompilerVersion() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String version = reader.readLine();\n            if (version != null) {\n                return version.trim();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"unknown\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getJavaCompilerVersion());\n    }\n}\n```"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter = new Counter();\n    private Object mLock = new Object();\n    private boolean mIsActive = false;\n    private boolean mIsRoot = false;\n    private String mCommandEnd = \"COMMAND_END\";\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mListener = listener;\n        try {\n            mConnection = Runtime.getRuntime().exec(requestRoot ? \"su\" : \"sh\");\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mStdOutputWorker = new Thread(new OutputWorker());\n            mStdOutputWorker.start();\n            mIsActive = true;\n            mIsRoot = requestRoot;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void execute(String command) {\n        new Thread(new CommandWorker(command)).start();\n    }\n\n    public boolean waitFor() {\n        return waitFor(0);\n    }\n\n    public boolean waitFor(int timeout) {\n        return waitFor(timeout, 0);\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        synchronized (mLock) {\n            try {\n                mLock.wait(timeout);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return mCounter.size() == index;\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        mIsActive = false;\n        mConnection.destroy();\n        try {\n            mStdOutputWorker.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class OutputWorker implements Runnable {\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = mStdOutput.readLine()) != null) {\n                    mListener.onStreamInput(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            mListener.onStreamStop(mConnection.exitValue());\n        }\n    }\n\n    private class CommandWorker implements Runnable {\n        private String mCommand;\n\n        public CommandWorker(String command) {\n            mCommand = command;\n        }\n\n        @Override\n        public void run() {\n            try {\n                mListener.onStreamStart();\n                mStdInput.writeBytes(mCommand + \"\\n\");\n                mStdInput.writeBytes(mCommandEnd + \"\\n\");\n                mStdInput.flush();\n                mCounter.increase();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public interface OnStreamListener {\n        void onStreamStart();\n\n        void onStreamInput(String line);\n\n        void onStreamStop(int exitCode);\n\n        void onStreamDied();\n    }\n\n    private class Counter {\n        private AtomicInteger mCounter = new AtomicInteger(0);\n\n        public int size() {\n            return mCounter.get();\n        }\n\n        public int increase() {\n            return mCounter.incrementAndGet();\n        }\n\n        public int decrease() {\n            return mCounter.decrementAndGet();\n        }\n\n        public void reset() {\n            mCounter.set(0);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    private Runtime rt;\n    private String[] command;\n    private String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval = -1;\n\n    public ShellCommand(String[] command) {\n        this.rt = Runtime.getRuntime();\n        this.command = command;\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.rt = Runtime.getRuntime();\n        this.command = command;\n        this.tag = tag;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error starting process: \" + error);\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            exitval = process.waitFor();\n            process.destroy();\n        } catch (InterruptedException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error waiting for process exit: \" + error);\n        }\n    }\n\n    public void finish() {\n        if (process != null) {\n            process.destroy();\n        }\n        if (stdout != null) {\n            try {\n                stdout.close();\n            } catch (IOException e) {\n                error = e.getMessage();\n                Log.e(tag, \"Error closing stdout: \" + error);\n            }\n        }\n    }\n\n    public boolean checkForExit() {\n        return !process.isAlive();\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error checking stdout availability: \" + error);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error reading stdout: \" + error);\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            return readStdoutBlocking();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SystemInfoUtil {\n\n    public static String getHostName() {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        if (os.contains(\"linux\")) {\n            return getUname(\"-n\");\n        } else if (os.contains(\"windows\")) {\n            String computerName = System.getenv(\"COMPUTERNAME\");\n            if (computerName != null && !computerName.isEmpty()) {\n                return computerName;\n            } else {\n                return getUname(\"\");\n            }\n        } else {\n            return \"\";\n        }\n    }\n\n    private static String getUname(String param) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"uname \" + param);\n            process.waitFor();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            return reader.readLine();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TemporaryPorts {\n    private static final Path DEFAULT_LOCK_DIRECTORY = Path.of(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts() {\n        this(DEFAULT_LOCK_DIRECTORY);\n    }\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory;\n        try {\n            Files.createDirectories(this.lockDirectory);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create lock directory\", e);\n        }\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        AllocatedPort allocatedPort = lock(port, name);\n        if (allocatedPort != null) {\n            ports.add(allocatedPort);\n        }\n        return allocatedPort;\n    }\n\n    private AllocatedPort lock(int port, String name) {\n        Path lockFilePath = lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        try (FileChannel fileChannel = FileChannel.open(lockFilePath, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) {\n            FileLock lock = fileChannel.lock();\n            if (lock != null) {\n                return new AllocatedPort(port, lockFilePath, fileChannel, lock);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to lock port \" + port, e);\n        }\n        return null;\n    }\n\n    private static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        private AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                lock.release();\n                file.close();\n                Files.deleteIfExists(path);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to release port \" + port, e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\npublic class CliDockerClient {\n\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Path.of(\"/usr/bin/docker\");\n    private static final long DOCKER_OUTPUT_TIMEOUT = TimeUnit.MINUTES.toMillis(10);\n\n    public CliDockerClient(Path dockerClient, Map<String, String> env) {\n        this(defaultProcessBuilderFactory(dockerClient.toString(), env));\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerClient, Map<String, String> env) {\n        return args -> new ProcessBuilder(List.of(dockerClient, \"--log-opt\", \"max-size=10m\", \"--log-opt\", \"max-file=3\", \"--config\", \"/etc/docker\", \"--context\", \"default\", \"--debug\", \"--host\", \"unix:///var/run/docker.sock\", \"--tls\", \"--tlscacert\", \"/etc/docker/ssl/ca.pem\", \"--tlscert\", \"/etc/docker/ssl/cert.pem\", \"--tlskey\", \"/etc/docker/ssl/key.pem\").addAll(args));\n    }\n\n    private String getStderrOutput(Process process) throws IOException {\n        StringBuilder stderr = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stderr.append(line).append(\"\\n\");\n            }\n        }\n        return stderr.toString();\n    }\n\n    private Process docker(String... args) throws IOException {\n        ProcessBuilder processBuilder = processBuilderFactory.apply(List.of(args));\n        processBuilder.environment().putAll(System.getenv());\n        Process process = processBuilder.start();\n        try {\n            if (!process.waitFor(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS)) {\n                process.destroyForcibly();\n                throw new RuntimeException(\"Docker command timed out\");\n            }\n        } catch (InterruptedException e) {\n            process.destroyForcibly();\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Docker command interrupted\", e);\n        }\n        if (process.exitValue() != 0) {\n            String stderr = getStderrOutput(process);\n            throw new RuntimeException(\"Docker command failed with exit code \" + process.exitValue() + \": \" + stderr);\n        }\n        return process;\n    }\n\n    public DockerInfoDetails info() {\n        return fetchInfoDetails();\n    }\n\n    private DockerInfoDetails fetchInfoDetails() {\n        try {\n            Process process = docker(\"info\");\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                return DockerInfoDetails.parse(reader);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to fetch Docker info\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic static boolean ensureJVMOnFirstThread(String[] args) {\n    if (!System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n        return true;\n    }\n\n    try {\n        ProcessBuilder pb = new ProcessBuilder(System.getProperty(\"java.home\") + \"/bin/java\", \"-XstartOnFirstThread\");\n        pb.inheritIO();\n        pb.command().addAll(Arrays.asList(System.getProperty(\"sun.java.command\").split(\" \")));\n        pb.command().addAll(Arrays.asList(args));\n        Process p = pb.start();\n        p.waitFor();\n        return false;\n    } catch (Exception e) {\n        e.printStackTrace();\n        return true;\n    }\n}\n```"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Implement a utility class for executing external processes synchronously and asynchronously in Java, handling input/output streams properly to prevent deadlocks, and collecting process output.\n\nClass Description: A ProcessExecutor utility class that provides methods to run external processes either synchronously (blocking until completion) or asynchronously (returning immediately), while properly managing process streams and errors.\n\nMethods:\n\nMethod1: runWith(List<String> cmd) -> Collection<String> - Executes a command synchronously and returns its output as a collection of strings. Handles both stdout and stderr streams by draining them concurrently to prevent deadlocks. The method blocks until the process completes.\n\nMethod2: runAsync(String... cmd) -> Process - Executes a command asynchronously and returns the Process object immediately without waiting for completion. The caller is responsible for handling the process streams and termination.\n\nMethod3: InputStreamDrainer(InputStream, OutputStream) -> void - [Internal helper class] A thread class that continuously reads from an input stream and writes to an output stream until EOF is reached. Used internally by runWith() to drain process streams.",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic static Collection<String> runWith(List<String> cmd) {\n    Collection<String> messages = new ArrayList<>();\n    try {\n        Process p = new ProcessBuilder(cmd).start();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        // drain streams, else we might lock up\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), baos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), baos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int err = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        messages.add(baos.toString());\n    } catch (IOException ex) {\n        return Collections.singleton(ex.getMessage());\n    } catch (InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return messages;\n}\n\npublic static Process runAsync(String... cmd) {\n    try {\n        return new ProcessBuilder(cmd).start();\n    } catch (IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.*;\n\npublic class ProcessExecutor {\n\n    private static final ExecutorService executor = Executors.newCachedThreadPool();\n\n    public static Collection<String> runWith(List<String> cmd) throws IOException, InterruptedException {\n        Process process = Runtime.getRuntime().exec(cmd.toArray(new String[0]));\n        InputStream stdout = process.getInputStream();\n        InputStream stderr = process.getErrorStream();\n        OutputStream stdin = process.getOutputStream();\n\n        InputStreamDrainer stdoutDrainer = new InputStreamDrainer(stdout, System.out);\n        InputStreamDrainer stderrDrainer = new InputStreamDrainer(stderr, System.err);\n\n        stdoutDrainer.start();\n        stderrDrainer.start();\n\n        process.waitFor();\n\n        stdoutDrainer.join();\n        stderrDrainer.join();\n\n        return stdoutDrainer.getOutput();\n    }\n\n    public static Process runAsync(String... cmd) throws IOException {\n        return Runtime.getRuntime().exec(cmd);\n    }\n\n    private static class InputStreamDrainer extends Thread {\n        private final InputStream input;\n        private final OutputStream output;\n        private final List<String> outputLines = new ArrayList<>();\n\n        public InputStreamDrainer(InputStream input, OutputStream output) {\n            this.input = input;\n            this.output = output;\n        }\n\n        public List<String> getOutput() {\n            return outputLines;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    outputLines.add(line);\n                    writer.write(line);\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Create a Java function that disassembles a Java class file using the `javap` command-line tool and returns the disassembled output as a string.\n\nFunction Description: The function `disassembleClassFromJava` takes a Java class file as input, executes the `javap -c` command on it to disassemble the bytecode, and returns the disassembled output as a string. It handles the process execution, stream management, and error handling.\n\nInput: \n- `resourceFile` (String): The path or name of the Java class file to be disassembled.\n\nOutput: \n- (String): The disassembled bytecode output from the `javap` command. If an error occurs, returns an error message string.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URL;\n\npublic String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", resourceFile)\n                .redirectErrorStream(true);\n\n        final Process process = pb.start();\n        final StringWriter writer = new StringWriter();\n        new Thread(() -> IOUtils.copyStreamNoException(process.getInputStream(), writer)).start();\n\n        final int ignored = process.waitFor();\n        final String processOutput = writer.toString();\n        return processOutput;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    } catch (IOException e) {\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ClassDisassembler {\n\n    public static String disassembleClassFromJava(String resourceFile) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"javap -c \" + resourceFile);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString();\n        } catch (IOException e) {\n            return \"Error disassembling class: \" + e.getMessage();\n        }\n    }\n\n}\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.*;\n\npublic class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out).start();\n        new AsyncPipe(process.getErrorStream(), System.err).start();\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        for (int i = 0; i < builders.length - 1; i++) {\n            builders[i].directory(processRoot);\n            Process process = builders[i].start();\n            new AsyncPipe(process.getInputStream(), new AsyncPipe(process.getErrorStream(), os).getInputStream()).start();\n            process.waitFor();\n        }\n        builders[builders.length - 1].directory(processRoot);\n        Process process = builders[builders.length - 1].start();\n        new AsyncPipe(is, process.getOutputStream()).start();\n        new AsyncPipe(process.getInputStream(), os).start();\n        new AsyncPipe(process.getErrorStream(), os).start();\n        process.waitFor();\n    }\n\n    private static class AsyncPipe extends Thread {\n        private InputStream is;\n        private OutputStream os;\n        private boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, length);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final Logger LOGGER = Logger.getLogger(DaemonRegistry.class.getName());\n    private static final int MAX_LENGTH = 32 * 1024;\n    private static final long LOCK_TIMEOUT_MS = 20 * 1000;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new ConcurrentHashMap<>();\n\n    public DaemonRegistry(Path registryFile) throws IOException {\n        this.registryFile = registryFile;\n        init();\n    }\n\n    private void init() throws IOException {\n        channel = FileChannel.open(registryFile, CREATE, READ, WRITE);\n        size = channel.size();\n        buffer = channel.map(MapMode.READ_WRITE, 0, size);\n        read();\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    public List<DaemonInfo> getAll() {\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        buffer.position(0);\n        while (buffer.hasRemaining()) {\n            String key = readString();\n            if (key == null) {\n                break;\n            }\n            DaemonInfo info = DaemonInfo.read(buffer);\n            infosMap.put(key, info);\n        }\n    }\n\n    public void doUpdate(Runnable updater) {\n        FileLock lock = null;\n        try {\n            lock = tryLock();\n            if (lock == null) {\n                throw new RuntimeException(\"Failed to acquire lock\");\n            }\n            updater.run();\n        } catch (Exception e) {\n            LOGGER.warning(\"Exception during update: \" + e.getMessage());\n        } finally {\n            if (lock != null) {\n                try {\n                    lock.release();\n                } catch (IOException e) {\n                    LOGGER.warning(\"Failed to release lock: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    private FileLock tryLock() {\n        Object lock = locks.computeIfAbsent(registryFile, k -> new Object());\n        synchronized (lock) {\n            try {\n                return channel.lock(0, Long.MAX_VALUE, true);\n            } catch (IOException e) {\n                LOGGER.warning(\"Failed to acquire lock: \" + e.getMessage());\n            }\n        }\n        return null;\n    }\n\n    private void reset() {\n        infosMap.clear();\n        buffer.position(0);\n        buffer.limit(0);\n    }\n\n    private String readString() {\n        int len = buffer.getInt();\n        if (len == -1) {\n            return null;\n        }\n        byte[] bytes = new byte[len];\n        buffer.get(bytes);\n        return new String(bytes, StandardCharsets.UTF_8);\n    }\n\n    private void writeString(String str) {\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n        int len = bytes.length;\n        if (len > buffer.remaining()) {\n            resizeBuffer(nextPowerOf2(len + 1, MAX_LENGTH));\n        }\n        buffer.putInt(len);\n        buffer.put(bytes);\n    }\n\n    private void resizeBuffer(long newSize) {\n        try {\n            channel.truncate(newSize);\n            buffer = channel.map(MapMode.READ_WRITE, 0, newSize);\n            size = newSize;\n        } catch (IOException e) {\n            LOGGER.warning(\"Failed to resize buffer: \" + e.getMessage());\n        }\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        if (a < min) {\n            a = min;\n        }\n        a--;\n        a |= a >> 1;\n        a |= a >> 2;\n        a |= a >> 4;\n        a |= a >> 8;\n        a |= a >> 16;\n        a++;\n        return a;\n    }\n}\n```"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.List;\n\npublic class Forker {\n\n    public List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        pb.redirectOutput(stdOut);\n        pb.redirectError(stdErr);\n        Process p = null;\n        try {\n            p = pb.start();\n            p.waitFor();\n            int exitCode = p.exitValue();\n            if (exitCode != 0) {\n                throw new BenchmarkException(\"Process failed with exit code \" + exitCode);\n            }\n            List<IterationResult> results = reader.readResults();\n            if (printOut) {\n                System.out.println(\"Standard Output:\");\n                System.out.println(new String(Files.readAllBytes(stdOut.toPath())));\n            }\n            if (printErr) {\n                System.out.println(\"Standard Error:\");\n                System.out.println(new String(Files.readAllBytes(stdErr.toPath())));\n            }\n            return results;\n        } catch (IOException e) {\n            throw new BenchmarkException(\"IOException occurred while executing process\", e);\n        } catch (InterruptedException e) {\n            throw new BenchmarkException(\"Thread interrupted while waiting for process to complete\", e);\n        } finally {\n            if (p != null) {\n                p.destroy();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "```java\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMQProducerService {\n\n    private static final String EXCHANGE_NAME = \"fanout_exchange\";\n\n    public String produceMessage(String message) {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        try (Connection connection = factory.newConnection();\n             Channel channel = connection.createChannel()) {\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"response\";\n    }\n}\n```"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.support.AsyncResultSupport;\n\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class LettuceRedisUtils {\n\n    private static LettuceRedisUtils instance;\n    private RedisClient REDIS_CLIENT;\n\n    private LettuceRedisUtils() {\n        REDIS_CLIENT = RedisClient.create(\"redis://localhost:6379\");\n    }\n\n    public static LettuceRedisUtils getInstance() {\n        if (instance == null) {\n            instance = new LettuceRedisUtils();\n        }\n        return instance;\n    }\n\n    public void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        try (StatefulRedisConnection<String, String> connection = REDIS_CLIENT.connect()) {\n            RedisAsyncCommands<String, String> asyncCommands = connection.async();\n            List<RedisFuture<?>> futures = pipelineCallBack.execute(asyncCommands);\n            CompletableFuture<Void> allFutures = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n            allFutures.get();\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface RedisPipelineCallBack {\n        List<RedisFuture<?>> execute(RedisAsyncCommands<String, String> asyncCommands);\n    }\n}\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport org.xnio.channels.StreamSinkConduit;\nimport org.xnio.channels.WriteReadyHandler;\nimport org.xnio.conduits.ConduitListener;\nimport org.xnio.conduits.ConduitWritableByteChannel;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\nimport org.xnio.conduits.XnioIoThread;\nimport org.xnio.conduits.XnioWorker;\nimport org.xnio.http.HttpServerExchange;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.StreamSourceChannel;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel source, long position, long count) throws IOException {\n        return fileChannel.transferFrom(source, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        return source.transferTo(count, throughBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        // No-op\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n        // No-op\n    }\n\n    @Override\n    public void awaitWritable(long timeout, TimeUnit unit) throws IOException {\n        // No-op\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getConnection().getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}\n```"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n    private ConcurrentHashMap<String, JedisPool> jedisPools;\n    private String clusterName;\n    private boolean replicate;\n    private ConcurrentMap<String, Notifier> notifiers;\n\n    public RedisRegistry(AppContext appContext) {\n        // Initialize the registry with configuration from AppContext\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        // Register a node in Redis\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        // Subscribe to node changes\n    }\n\n    private class NotifySub extends JedisPubSub {\n        @Override\n        public void onMessage(String key, String msg) {\n            // Process incoming messages\n        }\n    }\n\n    private class Notifier extends Thread {\n        @Override\n        public void run() {\n            // Main thread execution for subscription\n        }\n\n        public void shutdown() {\n            // Stops the subscription thread\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.support.ConnectionPoolSupport;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfig;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilder;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilder.PoolConfigBuilderImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImplImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport.PoolConfigBuilderImpl.PoolConfigBuilderImplImpl.PoolConfigBuilderImplImplImpl.PoolConfigBuilderImplImplImplImpl.PoolConfigBuilderImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImplImplImplImplImplImplImplImpl.PoolConfigBuilderImplImpl"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel channel, Path path, TranslogHeader header) {\n        super(channel, path, header);\n        this.checkpoint = checkpoint;\n        this.length = channel.size();\n        this.totalOperations = checkpoint.getOperations();\n    }\n\n    public static TranslogReader open(FileChannel channel, Path path, Checkpoint checkpoint, String translogUUID) {\n        TranslogHeader header = new TranslogHeader(translogUUID, channel.size());\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) {\n        ensureOpen();\n        try {\n            close();\n            return new TranslogReader(new Checkpoint(sequenceNumber, channel.size()), channelFactory.create(path), path, new TranslogHeader(checkpoint.getTranslogUUID(), channel.size()));\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"failed to close translog reader\", e);\n        }\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) {\n        ensureOpen();\n        if (position < 0 || position >= length) {\n            throw new IllegalArgumentException(\"position is outside of the translog file\");\n        }\n        try {\n            channel.position(position);\n            channel.read(buffer);\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"failed to read from translog file\", e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                throw new ElasticsearchException(\"failed to close translog file\", e);\n            }\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(\"translog reader is closed\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a Java class that manages authentication and operations for a Redis cluster using Jedis client library, with support for token-based authentication and connection pooling.\n\nClass Description: RedisClusterAuthManager is a class that handles Redis cluster authentication and operations. It provides methods to execute basic Redis operations and test re-authentication functionality in a multi-threaded environment.\n\nAttributes:\n- idpConfig: [IdentityProviderConfig] - Configuration for the identity provider that generates authentication tokens\n- authXManager: [AuthXManager] - Manager responsible for handling authentication processes\n- config: [JedisClientConfig] - Configuration for the Jedis client\n- poolConfig: [ConnectionPoolConfig] - Configuration for the connection pool\n- hostAndPort: [HostAndPort] - Redis cluster endpoint information\n\nMethods:\n- RedisClusterAuthManager([HostAndPort hostAndPort]) -> [void] - Constructor that initializes the authentication manager with Redis cluster endpoint\n- executeRedisOperations() -> [void] - Executes basic Redis operations (set, get, delete) on the cluster\n- testReAuthentication() -> [void] - Tests re-authentication functionality in a multi-threaded environment, verifying that connections properly re-authenticate",
    "Canonical_solution": "import redis.clients.authentication.core.IdentityProvider;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.SimpleToken;\nimport redis.clients.authentication.core.Token;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPoolConfig;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.EndpointConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisCluster;\n\npublic class RedisClusterAuthManager {\n\n    private final IdentityProviderConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private final HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig() {\n            @Override\n            public IdentityProvider getProvider() {\n                return new IdentityProvider() {\n                    @Override\n                    public Token requestToken() {\n                        return new SimpleToken(\"default\", \"cluster\",\n                                System.currentTimeMillis() + 5 * 1000, System.currentTimeMillis(),\n                                null);\n                    }\n                };\n            }\n        };\n        this.authXManager = new AuthXManager(EntraIDTokenAuthConfigBuilder.builder()\n                .lowerRefreshBoundMillis(1000).identityProviderConfig(idpConfig).build());\n        this.config = DefaultJedisClientConfig.builder().authXManager(authXManager).build();\n        this.poolConfig = new ConnectionPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jc = new JedisCluster(hostAndPort, config, 5, poolConfig)) {\n            jc.set(\"foo\", \"bar\");\n            jc.get(\"foo\");\n            jc.del(\"foo\");\n        }\n    }\n\n    public void testReAuthentication() throws InterruptedException, ExecutionException {\n        AuthXManager spyManager = spy(authXManager);\n        List<Connection> connections = new ArrayList<>();\n        \n        doAnswer(invocation -> {\n            Connection connection = spy((Connection) invocation.getArgument(0));\n            invocation.getArguments()[0] = connection;\n            connections.add(connection);\n            Object result = invocation.callRealMethod();\n            return result;\n        }).when(spyManager).addConnection(any(Connection.class));\n\n        JedisClientConfig spyConfig = DefaultJedisClientConfig.builder().authXManager(spyManager).build();\n        \n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch latch = new CountDownLatch(1);\n        \n        try (JedisCluster jc = new JedisCluster(Collections.singleton(hostAndPort), spyConfig)) {\n            Runnable task = () -> {\n                while (latch.getCount() > 0) {\n                    jc.set(\"foo\", \"bar\");\n                }\n            };\n            Future task1 = executorService.submit(task);\n            Future task2 = executorService.submit(task);\n\n            await().pollInterval(ONE_HUNDRED_MILLISECONDS).atMost(ONE_SECOND)\n                    .until(connections::size, greaterThanOrEqualTo(2));\n\n            connections.forEach(conn -> {\n                verify(conn, atLeast(2)).reAuthenticate();\n            });\n            \n            latch.countDown();\n            task1.get();\n            task2.get();\n        } finally {\n            latch.countDown();\n            executorService.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisClusterAuthManager {\n    private IdentityProviderConfig idpConfig;\n    private AuthXManager authXManager;\n    private JedisClientConfig config;\n    private ConnectionPoolConfig poolConfig;\n    private HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n    }\n\n    public void executeRedisOperations() {\n        JedisPool pool = new JedisPool(poolConfig, hostAndPort.getHost(), hostAndPort.getPort());\n        try (Jedis jedis = pool.getResource()) {\n            jedis.set(\"key\", \"value\");\n            String value = jedis.get(\"key\");\n            jedis.del(\"key\");\n        }\n    }\n\n    public void testReAuthentication() {\n        JedisPool pool = new JedisPool(poolConfig, hostAndPort.getHost(), hostAndPort.getPort());\n        try (Jedis jedis = pool.getResource()) {\n            jedis.auth(authXManager.getAuthToken(idpConfig));\n            // Perform operations\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\npublic class ClusterCommandExecutor<T> {\n\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public T broadcastCommand(CommandObject<T> commandObject) {\n        // Implementation for broadcasting command across all nodes in the cluster\n    }\n\n    public T executeCommand(CommandObject<T> commandObject) {\n        return executeCommandToReplica(commandObject, false);\n    }\n\n    public T executeCommandToReplica(CommandObject<T> commandObject) {\n        return executeCommandToReplica(commandObject, true);\n    }\n\n    private T executeCommandToReplica(CommandObject<T> commandObject, boolean toReplica) {\n        // Implementation for executing command on primary or replica node with retry logic\n    }\n\n    private T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        // Implementation for internal command execution logic with retries and error handling\n    }\n\n    private T execute(Connection connection, CommandObject<T> commandObject) {\n        // Implementation for executing command on a specific connection\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        // Implementation for handling connection issues with backoff and slot cache renewal\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        // Implementation for calculating backoff sleep duration for retries\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.HostAndPortMapper;\nimport redis.clients.jedis.util.PoolingClientConfig;\nimport redis.clients.jedis.util.SSLConnectionHelper;\n\nimport javax.net.ssl.*;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n    private final HostAndPort hostAndPort;\n    private final int connectionTimeout;\n    private final int socketTimeout;\n    private final boolean ssl;\n    private final SSLSocketFactory sslSocketFactory;\n    private final SSLParameters sslParameters;\n    private final HostnameVerifier hostnameVerifier;\n    private final HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this(HostAndPort.DEFAULT_HOST, HostAndPort.DEFAULT_PORT);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this(hostAndPort, new PoolingClientConfig());\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this(HostAndPort.DEFAULT_HOST, HostAndPort.DEFAULT_PORT, config);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSoTimeout();\n        this.ssl = config.isUseSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) {\n        List<HostAndPort> hostAndPorts = new ArrayList<>();\n        hostAndPorts.add(hostAndPort);\n        return connectToFirstSuccessfulHost(hostAndPorts);\n    }\n\n    private Socket connectToFirstSuccessfulHost(List<HostAndPort> hostAndPorts) {\n        for (HostAndPort hostAndPort : hostAndPorts) {\n            try {\n                return createSocket(hostAndPort);\n            } catch (JedisConnectionException e) {\n                // Ignore and try next host\n            }\n        }\n        throw new JedisConnectionException(\"Could not get a connection from any host: \" + hostAndPorts);\n    }\n\n    private Socket createSocket(HostAndPort hostAndPort) {\n        Socket socket = new Socket();\n        SocketAddress socketAddress = new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort());\n        try {\n            socket.connect(socketAddress, connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n            if (ssl) {\n                return SSLConnectionHelper.createSSLSocket(socket, sslSocketFactory, sslParameters, hostnameVerifier, hostAndPort.getHost());\n            }\n        } catch (IOException | NoSuchAlgorithmException | CertificateException e) {\n            throw new JedisConnectionException(e);\n        }\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() {\n        HostAndPort hostAndPort = getSocketHostAndPort();\n        return connectToFirstSuccessfulHost(hostAndPort);\n    }\n\n    private HostAndPort getSocketHostAndPort() {\n        HostAndPort mappedHostAndPort = hostAndPortMapper.map(hostAndPort);\n        return mappedHostAndPort;\n    }\n}\n```"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis Sentinel instances and Redis masters via Sentinel, with support for SSL/TLS connections and custom DNS resolution.\n\nClass Description: The RedisSentinelConnector class facilitates connections to Redis Sentinel servers and Redis master instances through Sentinel, with configurable SSL/TLS options and custom DNS resolution capabilities.\n\nAttributes:\n- clientResources: [ClientResources] - The Lettuce client resources configuration including custom DNS resolver and other client settings\n\nMethods:\n- RedisSentinelConnector([ClientResources clientResources]) -> [RedisSentinelConnector] - Constructor that initializes the connector with custom client resources including DNS resolution configuration\n- connectToSentinelDirectly([String host]) -> [StatefulRedisSentinelConnection<String, String>] - Establishes a direct connection to a Redis Sentinel server with SSL/TLS (peer verification disabled)\n- connectToMasterViaSentinel([String host, String masterId, File truststore]) -> [StatefulRedisConnection<String, String>] - Connects to a Redis master via Sentinel with SSL/TLS using the specified truststore for certificate verification\n- closeConnection([AutoCloseable connection, RedisClient client]) -> [void] - Safely closes the given connection and shuts down the associated Redis client",
    "Canonical_solution": "import io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisSentinelConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisSentinelConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisSentinelConnection<String, String> connectToSentinelDirectly(String host) {\n        RedisURI redisURI = RedisURI.create(\"rediss://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT);\n        redisURI.setVerifyPeer(false);\n\n        RedisClient client = RedisClient.create(clientResources);\n        StatefulRedisSentinelConnection<String, String> connection = client.connectSentinel(redisURI);\n        return connection;\n    }\n\n    public StatefulRedisConnection<String, String> connectToMasterViaSentinel(String host, String masterId, File truststore) {\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT\n                + \"?sentinelMasterId=\" + masterId);\n        SslOptions options = SslOptions.builder().truststore(truststore).build();\n\n        RedisClient client = RedisClient.create(clientResources);\n        client.setOptions(ClientOptions.builder().sslOptions(options).build());\n        StatefulRedisConnection<String, String> connection = client.connect(redisURI);\n        return connection;\n    }\n\n    public void closeConnection(AutoCloseable connection, RedisClient client) {\n        try {\n            if (connection != null) {\n                connection.close();\n            }\n        } finally {\n            if (client != null) {\n                FastShutdown.shutdown(client);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.StatefulRedisSentinelConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisClusterCommands;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterNode;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParser;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserFactory;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactory;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactory;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lettuce.core.cluster.models.partitions.RedisClusterPartitionParser.PartitionParserImplFactoryImpl.PartitionParserImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImplFactoryImpl;\nimport io.lett"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\n@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setDefaultSerializer(new FastJsonRedisSerializer<>(Object.class));\n        template.setKeySerializer(new StringRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            StringBuilder sb = new StringBuilder();\n            sb.append(target.getClass().getName());\n            sb.append(method.getName());\n            for (Object obj : params) {\n                sb.append(obj.toString());\n            }\n            return DigestUtils.sha256Hex(sb.toString());\n        };\n    }\n}\n```"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, with support for read preference configuration.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave deployment, configure read preferences, and properly close connections. It uses Lettuce's MasterReplica API for high availability.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to Redis master-slave setup\n\nMethods:\n- connectToMasterSlave(String sentinelUrl) -> void - Establishes a connection to Redis master-slave setup using the provided sentinel URL and configures read preference to prefer master\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public void connectToMasterSlave(String sentinelUrl) {\n        redisClient = RedisClient.create();\n        connection = MasterReplica.connect(redisClient, StringCodec.UTF8, RedisURI.create(sentinelUrl));\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\nimport io.lettuce.core.masterreplica.SslConnectionBuilder;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopologyProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaConnectionProvider;\nimport io.lettuce.core.masterreplica.MasterReplicaTopology"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.*;\nimport java.util.List;\n\npublic class RedisConnectionFactory {\n\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else {\n            pool = createPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        if (pool != null) {\n            return pool.getResource();\n        } else {\n            return new Jedis(shardInfo);\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (sentinelMaster != null) {\n            return createRedisSentinelPool();\n        } else {\n            return createRedisPool();\n        }\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        return new JedisSentinelPool(sentinelMaster, redisServers, poolConfig, timeout);\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        return new JedisPool(poolConfig, hostName, port, timeout, password, dbIndex);\n    }\n\n    private JedisCluster createCluster() {\n        return new JedisCluster(redisServers, timeout, poolConfig);\n    }\n\n    public Jedis getJedisConnection() {\n        return fetchJedisConnector();\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}\n```"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.Hashing;\nimport redis.clients.jedis.util.Sharded;\n\nimport java.util.List;\n\npublic class JedisSharding implements Sharded<Jedis> {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.get(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command cmd, String... args) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.sendCommand(cmd, args);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public void close() {\n        // No-op as connections are managed per-operation\n    }\n\n    private Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        HostAndPort shard = shards.get(index);\n        return new Jedis(shard.getHost(), shard.getPort(), clientConfig);\n    }\n\n    private int getShardIndex(String key) {\n        return Math.abs(hashing.hash(key)) % shards.size();\n    }\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.util.function.LongSupplier;\n\npublic class WriteablePmtiles implements AutoCloseable {\n    private final SeekableByteChannel out;\n    private final LongSupplier bytesWritten;\n\n    private WriteablePmtiles(SeekableByteChannel out, LongSupplier bytesWritten) {\n        this.out = out;\n        this.bytesWritten = bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) {\n        // Implementation for writing to a file\n        return null;\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        // Implementation for writing to an in-memory buffer\n        return null;\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        // Implementation for finalizing the archive\n    }\n\n    public long bytesWritten() {\n        return bytesWritten.getAsLong();\n    }\n\n    @Override\n    public void close() throws IOException {\n        out.close();\n    }\n\n    private class DeduplicatingTileWriter {\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            // Implementation for writing tile data\n        }\n\n        public void close() {\n            // No cleanup needed in this implementation\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.cluster.api.sync.RedisPubSubCommands;\nimport io."
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message consumer using the push model. The class should handle message consumption from a specified topic, with configurable NameServer address and consumer group settings.\n\nClass Description: The Consumer class is a RocketMQ message consumer implementation that subscribes to a topic and processes incoming messages asynchronously. It uses DefaultMQPushConsumer for push-based consumption and provides methods to start, shutdown, and configure the consumer.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address if none is provided\n- TOPIC: [String] - The topic to subscribe to for messages\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- Consumer() - [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers a message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer gracefully\n- setNamesrvAddr(String namesrvAddr) -> [void] - Sets the NameServer address for the consumer",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n\npublic class Consumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_4\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msg);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n    private static final String CONSUMER_GROUP = \"my_consumer_group\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"my_topic\";\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() {\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        try {\n            consumer.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}\n```"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a RocketMQ push consumer in Java that subscribes to a specific topic, processes incoming messages asynchronously, and manages consumer lifecycle operations.\n\nClass Description: LMQPushConsumer is a Java class that encapsulates the functionality of a RocketMQ push consumer. It handles the initialization, startup, and shutdown of the consumer, as well as message consumption from a specified topic using a concurrent message listener.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The specific LMQ topic to subscribe to\n- CONSUMER_GROUP: [String] - The consumer group identifier\n- NAMESRV_ADDR: [String] - The NameServer address\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initialize(): [void] - Initializes the consumer with configuration settings, subscription, and message listener\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if initialization fails\n- start(): [void] - Starts the consumer and updates topic route information\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if startup fails\n- shutdown(): [void] - Shuts down the consumer gracefully\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\n\npublic class LMQPushConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"123\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_1\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().updateTopicSubscribeInfo(LMQ_TOPIC,\n            new HashSet<>(Arrays.asList(new MessageQueue(LMQ_TOPIC, BROKER_NAME, (int) MixAll.LMQ_QUEUE_ID))));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport com.alibaba.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport com.alibaba.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport com.alibaba.rocketmq.client.exception.MQClientException;\nimport com.alibaba.rocketmq.common.message.MessageExt;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class LMQPushConsumer {\n\n    private static final String CLUSTER_NAME = \"DefaultCluster\";\n    private static final String BROKER_NAME = \"DefaultBroker\";\n    private static final String TOPIC = \"LMQTopic\";\n    private static final String LMQ_TOPIC = \"LMQSubTopic\";\n    private static final String CONSUMER_GROUP = \"LMQConsumerGroup\";\n    private static final String NAMESRV_ADDR = \"localhost:9876\";\n    private static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<>();\n\n    private DefaultMQPushConsumer consumer;\n\n    public LMQPushConsumer() {\n        this.consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n    }\n\n    public void initialize() throws MQClientException {\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.setBrokerName(BROKER_NAME);\n        consumer.subscribe(TOPIC, LMQ_TOPIC);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    // Process the message asynchronously\n                    new Thread(() -> {\n                        // Process the message\n                        System.out.println(\"Received message: \" + new String(msg.getBody()));\n                    }).start();\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        consumer.updateTopicRouteInfoFromNameServer();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.RebalanceAssigner;\nimport org.apache.rocketmq.client.consumer.rebalance.RebalanceListener;\nimport org.apache.rocketmq.client.consumer.rebalance.RebalanceResult;\nimport org.apache.rocketmq.client.consumer.rebalance.RebalanceStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.RebalanceType;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.AverageHashAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.AverageRoundRobinAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.ConsistentHashAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.ConsistentHashRebalanceStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.RoundRobinAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.RoundRobinRebalanceStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.SimpleAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.SimpleRebalanceStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.WeightAverageAllocateMessageQueueStrategy;\nimport org.apache.rocketmq.client.consumer.rebalance.impl.WeightAverageRebalanceStrategy;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\nimport org.apache.rocketmq.common.protocol.heartbeat.RetryType;\nimport org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;\nimport org.apache.rocketmq.common.protocol.heartbeat.SubscriptionGroupConfig;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.remoting.common.RemotingUtil;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\nimport org.apache.rocketmq.remoting.protocol.RemotingSerializable;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumeMessageDirectlyResult;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerSendMsgBackRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.ConsumerSendMsgBackResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetConsumerStatusRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetConsumerStatusResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetConsumerRunningInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetConsumerRunningInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMaxOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetMinOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetSubscriptionInfoRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.GetSubscriptionInfoResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.PullMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.PullMessageResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.PullMessageResultExt;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.QueryConsumerOffsetResponseHeader;\nimport org.apache.rocketmq.remoting.protocol.body.Query"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer capable of subscribing to topics, filtering messages, and processing them asynchronously.\n\nClass Description: The RocketMQConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify consumer setup and message handling. It supports both tag-based and SQL92 filtering, configurable threading, and various RocketMQ features like message tracing and ACL.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n- topic: String - The topic to subscribe to\n- group: String - The consumer group name\n- threadCount: int - Number of threads for message processing\n- filterType: String - Type of message filtering (TAG or SQL92)\n- expression: String - Filter expression (either tag or SQL condition)\n- msgTraceEnable: boolean - Whether to enable message tracing\n- aclEnable: boolean - Whether to enable access control\n- clientRebalanceEnable: boolean - Whether to enable client-side rebalancing\n- rpcHook: RPCHook - Custom RPC hook for authentication\n\nMethods:\n- initialize(): void - Initializes the consumer with configured settings and subscribes to the topic\n- setMessageListener(MessageListenerConcurrently listener): void - Registers a message listener for concurrent message processing\n- start(): void - Starts the consumer to begin receiving messages\n- shutdown(): void - Gracefully shuts down the consumer\n- setNamesrvAddr(String namesrvAddr): void - Sets the NameServer address for broker discovery",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group, int threadCount, String filterType, \n                          String expression, boolean msgTraceEnable, boolean aclEnable, \n                          boolean clientRebalanceEnable, RPCHook rpcHook) {\n        this.topic = topic;\n        this.group = group;\n        this.threadCount = threadCount;\n        this.filterType = filterType;\n        this.expression = expression;\n        this.msgTraceEnable = msgTraceEnable;\n        this.aclEnable = aclEnable;\n        this.clientRebalanceEnable = clientRebalanceEnable;\n        this.rpcHook = rpcHook;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(group, rpcHook, new AllocateMessageQueueAveragely(), msgTraceEnable, null);\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setClientRebalance(clientRebalanceEnable);\n\n        if (filterType == null || expression == null) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            if (ExpressionType.TAG.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.byTag(expr));\n            } else if (ExpressionType.SQL92.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.bySql(expr));\n            } else {\n                throw new IllegalArgumentException(\"Not support filter type! \" + filterType);\n            }\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    try {\n                        // Handle message consumption logic here\n                        // If an exception occurs, throw it to retry the message\n                        // If the message is successfully consumed, return ConsumeConcurrentlyStatus.CONSUME_SUCCESS\n                    } catch (Exception e) {\n                        // Log the exception\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return returnFailedHalf ? ConsumeConcurrentlyStatus.CONSUME_SUCCESS : ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getConsumer().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketmq().getNameServer());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        consumer.subscribe(MqTagConstants.PUSH_TOPIC, MqTagConstants.PUSH_TAGS);\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMin(paascloudProperties.getConsumer().getMinThread());\n        consumer.setConsumeThreadMax(paascloudProperties.getConsumer().getMaxThread());\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                e.printStackTrace();\n            }\n        });\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message producer sink for sending messages to RocketMQ topics, supporting both synchronous and asynchronous message delivery, batch processing, and configurable message delay levels.\n\nClass Description: The RocketMQSink class is a Flink-compatible sink that sends messages to RocketMQ. It handles message serialization, topic selection, and provides configurable message delivery options including synchronous/asynchronous sending, batch processing, and delayed message delivery.\n\nAttributes:\n- LOG: Logger - Logger instance for logging debug and error messages\n- producer: DefaultMQProducer - RocketMQ producer instance for sending messages\n- async: boolean - Flag indicating whether to use asynchronous message sending\n- props: Properties - Configuration properties for the producer\n- topicSelector: TopicSelector<IN> - Selector for determining message topics and tags\n- serializationSchema: KeyValueSerializationSchema<IN> - Schema for serializing input data\n- batchFlushOnCheckpoint: boolean - Flag indicating whether to use batch processing\n- batchSize: int - Maximum batch size for batch processing\n- batchList: List<Message> - Buffer for batch messages\n- messageDeliveryDelayLevel: int - Configuration for delayed message delivery\n\nMethods:\n- RocketMQSink(KeyValueSerializationSchema<IN>, TopicSelector<IN>, Properties) -> void - Constructor that initializes the sink with serialization schema, topic selector, and configuration properties\n- open(Configuration) -> void - Initializes the RocketMQ producer and prepares for message sending\n- invoke(IN) -> void - Processes and sends a single message (either immediately or adds to batch)\n- prepareMessage(IN) -> Message - Creates a RocketMQ Message object from input data\n- close() -> void - Cleans up resources and shuts down the producer\n- flushSync() -> void - Sends all batched messages synchronously (used when batch processing is enabled)",
    "Canonical_solution": "import com.zhisheng.connectors.rocketmq.common.selector.TopicSelector;\nimport com.zhisheng.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> {\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize = 1000;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> schema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = schema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.messageDeliveryDelayLevel = RocketMQUtils.getInteger(this.props, RocketMQConfig.MSG_DELAY_LEVEL,\n                RocketMQConfig.MSG_DELAY_LEVEL00);\n        if (this.messageDeliveryDelayLevel < RocketMQConfig.MSG_DELAY_LEVEL00) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL00;\n        } else if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL18) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL18;\n        }\n    }\n\n    public void open(Configuration parameters) throws Exception {\n        Validate.notEmpty(props, \"Producer properties can not be empty\");\n        Validate.notNull(topicSelector, \"TopicSelector can not be null\");\n        Validate.notNull(serializationSchema, \"KeyValueSerializationSchema can not be null\");\n\n        producer = new DefaultMQProducer();\n        producer.setInstanceName(String.valueOf(getRuntimeContext().getIndexOfThisSubtask()));\n        RocketMQConfig.buildProducerConfigs(props, producer);\n        batchList = new LinkedList<>();\n\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void invoke(IN input) throws Exception {\n        Message msg = prepareMessage(input);\n\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n            return;\n        }\n\n        if (async) {\n            try {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.debug(\"Async send message success! result: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable throwable) {\n                        if (throwable != null) {\n                            LOG.error(\"Async send message failure!\", throwable);\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                LOG.error(\"Async send message failure!\", e);\n            }\n        } else {\n            try {\n                SendResult result = producer.send(msg);\n                LOG.debug(\"Sync send message result: {}\", result);\n            } catch (Exception e) {\n                LOG.error(\"Sync send message failure!\", e);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN input) {\n        String topic = topicSelector.getTopic(input);\n        String tag = topicSelector.getTag(input) != null ? topicSelector.getTag(input) : \"\";\n\n        byte[] k = serializationSchema.serializeKey(input);\n        String key = k != null ? new String(k, StandardCharsets.UTF_8) : \"\";\n        byte[] value = serializationSchema.serializeValue(input);\n\n        Validate.notNull(topic, \"the message topic is null\");\n        Validate.notNull(value, \"the message body is null\");\n\n        Message msg = new Message(topic, tag, key, value);\n        if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL00) {\n            msg.setDelayTimeLevel(this.messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    public void close() throws Exception {\n        if (producer != null) {\n            flushSync();\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() throws Exception {\n        if (batchFlushOnCheckpoint) {\n            synchronized (batchList) {\n                if (batchList.size() > 0) {\n                    producer.send(batchList);\n                    batchList.clear();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.flink.api.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> extends RichSinkFunction<IN> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> serializationSchema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = serializationSchema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n    }\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        producer = new DefaultMQProducer();\n        producer.setNamesrvAddr(props.getProperty(\"rocketmq.namesrvAddr\"));\n        producer.setInstanceName(props.getProperty(\"rocketmq.instanceName\"));\n        producer.setSendMsgTimeout(Integer.parseInt(props.getProperty(\"rocketmq.sendMsgTimeout\")));\n        producer.setRetryTimesWhenSendFailed(Integer.parseInt(props.getProperty(\"rocketmq.retryTimesWhenSendFailed\")));\n        producer.setRetryTimesWhenSendAsyncFailed(Integer.parseInt(props.getProperty(\"rocketmq.retryTimesWhenSendAsyncFailed\")));\n        producer.setCompressMsgBodyOverHowmuch(Integer.parseInt(props.getProperty(\"rocketmq.compressMsgBodyOverHowmuch\")));\n        producer.setMaxMessageSize(Integer.parseInt(props.getProperty(\"rocketmq.maxMessageSize\")));\n        producer.setRetryAnotherBrokerWhenNotStoreOK(Boolean.parseBoolean(props.getProperty(\"rocketmq.retryAnotherBrokerWhenNotStoreOK\")));\n        producer.setSendLatencyFaultEnable(Boolean.parseBoolean(props.getProperty(\"rocketmq.sendLatencyFaultEnable\")));\n        producer.setLatencyMax(Integer.parseInt(props.getProperty(\"rocketmq.latencyMax\")));\n        producer.setVipChannelEnabled(Boolean.parseBoolean(props.getProperty(\"rocketmq.vipChannelEnabled\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n        producer.setUseTLS(Boolean.parseBoolean(props.getProperty(\"rocketmq.useTLS\")));\n"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "```java\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.Logger;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private Logger mLog;\n    private long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Initialize the broadcaster with configuration\n    }\n\n    public boolean connect() {\n        // Attempts to establish a connection to the Icecast server, returns true if successful\n        return false;\n    }\n\n    public void disconnect() {\n        // Closes the current streaming session and cleans up resources\n    }\n\n    public boolean connected() {\n        // Returns true if currently connected to the server\n        return false;\n    }\n\n    public boolean canConnect() {\n        // Returns true if conditions allow for a connection attempt\n        return false;\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        // Returns the current broadcast configuration\n        return null;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        // Updates the current broadcast state\n    }\n\n    public BroadcastState getBroadcastState() {\n        // Returns the current broadcast state\n        return null;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        // Returns HTTP headers for the connection\n        return new HashMap<>();\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        // Returns the configuration object\n        return null;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) {\n            // Sends HTTP PUT request when session opens\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            // Handles session cleanup when closed\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) {\n            // Handles connection exceptions\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) {\n            // Processes server responses\n        }\n\n        @Override\n        public void sessionIdle(IoSession session, IdleStatus status) {\n            // Handles session idle state\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Java class that facilitates HTTP communication using Java's HttpClient, supporting GET requests with configurable options and error handling.\n\nClass Description: The HttpCommunicator class provides functionality to send HTTP GET requests to specified URIs. It includes features like automatic redirect following and optional error suppression for non-critical requests. The class encapsulates the HttpClient instance and provides methods for request execution.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HttpClient instance used for all HTTP communications, configured to always follow redirects.\n\nMethods:\nsendGetRequest: [Name](String uri, Map<String, Object> attributes) -> String - Sends a GET request to the specified URI. The attributes map can contain optional parameters like \"optional-option\" to suppress exceptions for non-critical requests. Returns the response body as a string or empty string for optional failed requests.\n\nreadUri: [Name](URI uri, boolean optional) -> String - Internal method that constructs and executes the HTTP request. If optional is true, returns empty string on failure instead of throwing an exception.\n\nisHttpOrHttps: [Name](String url) -> boolean - Helper method to check if a URL string uses HTTP or HTTPS protocol. Returns true if the URL starts with \"http://\" or \"https://\".",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n\n    private HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean isOptional = attributes.containsKey(\"optional-option\");\n        return readUri(URI.create(uri), isOptional);\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        try {\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url != null && (url.startsWith(\"http://\") || url.startsWith(\"https://\"));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class HttpCommunicator {\n    private CloseableHttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClients.custom().setRedirectStrategy(new LaxRedirectStrategy()).build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean optional = attributes.containsKey(\"optional-option\");\n        try {\n            return readUri(new URI(uri), optional);\n        } catch (URISyntaxException e) {\n            if (!optional) {\n                throw new RuntimeException(e);\n            }\n        }\n        return \"\";\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        HttpGet httpGet = new HttpGet(uri);\n        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {\n            if (response.getStatusLine().getStatusCode() == 200) {\n                return EntityUtils.toString(response.getEntity());\n            } else if (!optional) {\n                throw new RuntimeException(\"Failed to get response from \" + uri);\n            }\n        } catch (Exception e) {\n            if (!optional) {\n                throw new RuntimeException(e);\n            }\n        }\n        return \"\";\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url.startsWith(\"http://\") || url.startsWith(\"https://\");\n    }\n}\n```"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void sendStringToServer(String str) {\n    try (Socket socket = new Socket(\"server_address\", 1234);\n         OutputStream out = socket.getOutputStream()) {\n        out.write(str.getBytes());\n    } catch (IOException e) {\n        System.err.println(\"Error sending string to server: \" + e.getMessage());\n    }\n}\n```"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.exporter.common.TextFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.util.regex.Pattern;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private final Logger logger = LoggerFactory.getLogger(Graphite.class);\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_.-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8)) {\n            TextFormat.write004(writer, registry.metricFamilySamples());\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        PushThread pushThread = new PushThread(registry, intervalSeconds);\n        Thread thread = new Thread(pushThread);\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private class PushThread implements Runnable {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    push(registry);\n                    Thread.sleep(intervalSeconds * 1000);\n                } catch (IOException | InterruptedException e) {\n                    logger.error(\"Error pushing metrics to Graphite\", e);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class RDPConnection {\n\n    private static final String exp = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport org.apache.hc.client5.http.classic.methods.HttpPost;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.entity.mime.MultipartEntityBuilder;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.CompletableFuture;\n\npublic class OpenMHzHttpClient {\n\n    private static final Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n\n    private final CloseableHttpClient mHttpClient;\n\n    public OpenMHzHttpClient() {\n        RequestConfig requestConfig = RequestConfig.custom()\n                .setRedirectsEnabled(true)\n                .setConnectTimeout(5000)\n                .setConnectionRequestTimeout(5000)\n                .setSocketTimeout(5000)\n                .build();\n\n        mHttpClient = HttpClients.custom()\n                .useSystemProperties()\n                .setDefaultRequestConfig(requestConfig)\n                .build();\n    }\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        HttpPost httpPost = new HttpPost(host + \"/authorize\");\n        httpPost.setHeader(\"Content-Type\", \"application/json\");\n        httpPost.setHeader(\"Accept\", \"application/json\");\n        httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n\n        try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n            int statusCode = response.getCode();\n            HttpEntity entity = response.getEntity();\n            String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);\n\n            if (statusCode == 200) {\n                return \"OK\";\n            } else if (statusCode == 401) {\n                return \"Invalid API Key\";\n            } else if (statusCode == 403) {\n                return \"Invalid System Name\";\n            } else {\n                mLog.error(\"Unexpected response code: \" + statusCode + \", response: \" + responseBody);\n                return \"Unknown Exception\";\n            }\n        } catch (IOException | ParseException e) {\n            mLog.error(\"Error testing connection\", e);\n            return \"No Response\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        CompletableFuture.runAsync(() -> {\n            HttpPost httpPost = new HttpPost(uri);\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n\n            MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n            builder.setBoundary(boundary);\n            builder.addBinaryBody(\"audio\", audioBytes, org.apache.hc.core5.http.ContentType.DEFAULT_BINARY, \"audio.wav\");\n            builder.addTextBody(\"frequency\", String.valueOf(frequency), org.apache.hc.core5.http.ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"timestamp\", String.valueOf(timestampSeconds), org.apache.hc.core5.http.ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"duration\", String.valueOf(durationSeconds), org.apache.hc.core5.http.ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"talkgroup\", talkgroup, org.apache.hc.core5.http.ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"radioId\", radioId, org.apache.hc.core5.http.ContentType.TEXT_PLAIN);\n\n            HttpEntity multipart = builder.build();\n            httpPost.setEntity(multipart);\n\n            try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                int statusCode = response.getCode();\n                HttpEntity entity = response.getEntity();\n                String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);\n\n                if (statusCode != 200) {\n                    mLog.error(\"Error sending audio recording: \" + statusCode + \", response: \" + responseBody);\n                }\n            } catch (IOException | ParseException e) {\n                mLog.error(\"Error sending audio recording\", e);\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Create a Java class that handles TCP socket communication for receiving screen data from an Android device via minicap and forwarding it to a data queue for processing.\n\nClass Description: MiniCapInputSocketThread is a thread class that establishes a TCP connection to a local port forwarded from an Android device, continuously reads screen data from the minicap service, and places the data into a blocking queue for further processing by other components. It also manages resource cleanup when the connection is terminated.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and status information\n- iDevice: IDevice - The Android device being monitored\n- dataQueue: BlockingQueue<byte[]> - Queue for storing received screen data\n- miniCapPro: MiniCapLocalThread - The parent minicap process thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - The main Android test task thread\n- session: Session - WebSocket session associated with the screen streaming\n\nMethods:\n- MiniCapInputSocketThread(IDevice, BlockingQueue<byte[]>, MiniCapLocalThread, Session) -> None - Constructor that initializes the thread with device, data queue, minicap process, and session references\n- run() -> None - Main thread execution that establishes the socket connection, reads data continuously, and handles cleanup when finished",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.cloud.sonic.agent.tools.BytesTool.subByteArray;\n\npublic class MiniCapInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n\n    public final static String ANDROID_INPUT_SOCKET_PRE = \"android-minicap-input-socket-task-%s-%s-%s\";\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(ANDROID_INPUT_SOCKET_PRE));\n    }\n\n    @Override\n    public void run() {\n        int finalMiniCapPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, finalMiniCapPort, \"minicap\");\n        Socket capSocket = null;\n        InputStream inputStream = null;\n        try {\n            capSocket = new Socket(\"localhost\", finalMiniCapPort);\n            inputStream = capSocket.getInputStream();\n            int len = 1024;\n            while (miniCapPro.isAlive()) {\n                byte[] buffer = new byte[len];\n                int realLen;\n                realLen = inputStream.read(buffer);\n                if (buffer.length != realLen && realLen >= 0) {\n                    buffer = subByteArray(buffer, 0, realLen);\n                }\n                if (realLen >= 0) {\n                    dataQueue.offer(buffer);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (miniCapPro.isAlive()) {\n                miniCapPro.interrupt();\n                log.info(\"miniCap thread closed.\");\n            }\n            if (capSocket != null && capSocket.isConnected()) {\n                try {\n                    capSocket.close();\n                    log.info(\"miniCap socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"miniCap input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, finalMiniCapPort, \"minicap\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport com.android.ddmlib.IDevice;\nimport com.android.ddmlib.RawImage;\nimport com.android.tradefed.device.DeviceNotAvailableException;\nimport com.android.tradefed.device.ITestDevice;\nimport com.android.tradefed.log.LogUtil.CLog;\nimport com.android.tradefed.util.CommandResult;\nimport com.android.tradefed.util.CommandStatus;\nimport com.android.tradefed.util.RunUtil;\nimport com.android.tradefed.util.StreamUtil;\nimport com.android.tradefed.util.ZipUtil;\nimport com.android.tradefed.util.keystore.DeviceKeyStore;\nimport com.android.tradefed.util.keystore.DeviceKeyStoreException;\nimport com.android.tradefed.util.keystore.DeviceKeyStoreFactory;\nimport com.android.tradefed.util.keystore.KeyStoreException;\nimport com.android.tradefed.util.keystore.KeyStoreFactory;\nimport com.android.tradefed.util.keystore.KeyStoreUtil;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreType;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersion;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com.android.tradefed.util.keystore.KeyStoreUtil.KeyStoreVersionException.KeyStoreVersionExceptionReason;\nimport com"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n\n    private Socket socket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void start(String server, int port) {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n\n    private void doSend(String command, String server, int port) {\n        try {\n            socket = new Socket(server, port);\n            out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(command);\n        } catch (UnknownHostException e) {\n            System.err.println(\"Don't know about host: \" + server);\n        } catch (IOException e) {\n            System.err.println(\"Couldn't get I/O for the connection to: \" + server);\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        String response = \"\";\n        try {\n            socket = new Socket(server, port);\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out.println(command);\n            response = read(in);\n        } catch (UnknownHostException e) {\n            System.err.println(\"Don't know about host: \" + server);\n        } catch (IOException e) {\n            System.err.println(\"Couldn't get I/O for the connection to: \" + server);\n        }\n        return response;\n    }\n\n    private String read(InputStream in) {\n        StringBuilder response = new StringBuilder();\n        try {\n            int c;\n            while ((c = in.read()) != -1) {\n                if (c == '\\r') {\n                    break;\n                }\n                response.append((char) c);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Couldn't read from the input stream\");\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.List;\n\npublic class Minitouch {\n    private static final String REMOTE_PATH = \"/data/local/tmp/\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n    private List<MinitouchListener> listenerList;\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        device.createForward(forward);\n        startInitialThread(\"localhost\", forward.getLocalPort());\n    }\n\n    public void kill() {\n        if (minitouchSocket != null) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        removeForward(forward);\n    }\n\n    public void sendEvent(String str) {\n        try {\n            minitouchOutputStream.write(str.getBytes());\n            minitouchOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        device.removeForward(forward);\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n        minitouchSocket = null;\n        minitouchOutputStream = null;\n    }\n\n    private AdbForward generateForwardInfo() {\n        return new AdbForward(AdbForward.Direction.TCP, 0, REMOTE_PATH + MINITOUCH_BIN, AdbForward.Flags.NONE);\n    }\n}\n```"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.InetSocketAddress;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.hc.client5.http.async.methods.SimpleHttpRequest;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\nimport org.apache.hc.client5.http.async.methods.SimpleRequestBuilder;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\nimport org.apache.hc.client5.http.impl.async.HttpAsyncClients;\nimport org.apache.hc.client5.http.impl.nio.PoolingAsyncClientConnectionManagerBuilder;\nimport org.apache.hc.core5.concurrent.FutureCallback;\nimport org.apache.hc.core5.io.CloseMode;\nimport org.apache.hc.core5.io.CloseMode.GRACEFUL;\nimport org.apache.hc.core5.reactor.IOReactorConfig;\nimport org.apache.hc.core5.util.TimeValue;\n\npublic class HttpCommunicationClient {\n\n    private final InetSocketAddress address;\n    private final CloseableHttpAsyncClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n        this.httpClient = HttpAsyncClients.custom()\n                .setConnectionManager(PoolingAsyncClientConnectionManagerBuilder.create()\n                        .setMaxConnTotal(100)\n                        .setMaxConnPerRoute(10)\n                        .build())\n                .setDefaultRequestConfig(RequestConfig.custom()\n                        .setRedirectsEnabled(true)\n                        .setCircularRedirectsAllowed(true)\n                        .setRedirectsStrategy(new LaxRedirectStrategy())\n                        .build())\n                .build();\n    }\n\n    public void setupHttpClient(ThreadPoolExecutor threadPool) {\n        httpClient.start();\n        httpClient.setIOReactorConfig(IOReactorConfig.custom()\n                .setSoTimeout(TimeValue.ofSeconds(10))\n                .setConnectTimeout(TimeValue.ofSeconds(10))\n                .setSoKeepAlive(true)\n                .setTcpNoDelay(true)\n                .setInterestOpQueued(true)\n                .setSelectInterval(TimeValue.ofMillis(100))\n                .setConnectBlocking(false)\n                .setSoReuseAddress(true)\n                .setSoLinger(0)\n                .setSoRcvBuf(8192)\n                .setSoSndBuf(8192)\n                .setTcpKeepAlive(true)\n                .setTcpNoDelay(true)\n                .setTcpMaxSegSize(0)\n                .setTcpCork(false)\n                .setTcpQuickAck(false)\n                .setTcpKeepIdle(0)\n                .setTcpKeepIntvl(0)\n                .setTcpKeepCnt(0)\n                .setTcpAbortOnClose(false)\n                .setTcpFastOpen(false)\n                .setTcpFastOpenQueueLen(0)\n                .setTcpFastOpenConnQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFastOpenListenQueueLen(0)\n                .setTcpFast"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void sendStringToServer(String str) {\n    try (Socket socket = new Socket(\"localhost\", 8080);\n         OutputStream out = socket.getOutputStream()) {\n        out.write(str.getBytes());\n    } catch (IOException e) {\n        System.err.printf(\"Error sending string to server: %s%n\", e.getMessage());\n    }\n}\n```"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SocketTest {\n\n    private static final int SERVER_SOCKET_PORT = 8080;\n    private static final String HARDWARE_ID = \"1234567890\";\n\n    public static void doSocketTest() {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n             OutputStream os = socket.getOutputStream()) {\n\n            Map<String, Object> measurementData = new HashMap<>();\n            measurementData.put(\"hardwareId\", HARDWARE_ID);\n            measurementData.put(\"temperature\", 25.5);\n            measurementData.put(\"humidity\", 60.2);\n\n            String jsonData = new MeasurementData(measurementData).toJson();\n            os.write(jsonData.getBytes());\n            os.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class MeasurementData {\n        private final Map<String, Object> data;\n\n        public MeasurementData(Map<String, Object> data) {\n            this.data = data;\n        }\n\n        public String toJson() {\n            return new Gson().toJson(data);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TCPConnection extends Connection implements PacketSource {\n    private static final int MTU = 16384;\n    private static final int MAX_PAYLOAD_SIZE = MTU - IPv4Header.HEADER_SIZE - TCPHeader.HEADER_SIZE;\n\n    private final StreamBuffer clientToNetwork;\n    private final Packetizer networkToClient;\n    private final IPv4Packet packetForClient;\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private final AtomicBoolean connected = new AtomicBoolean(false);\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client, ipv4Header, tcpHeader);\n        this.clientToNetwork = new StreamBuffer(MAX_PAYLOAD_SIZE);\n        this.networkToClient = new Packetizer(this, ipv4Header, tcpHeader);\n        this.packetForClient = new IPv4Packet(ipv4Header, tcpHeader);\n        this.channel = createChannel();\n        this.selectionKey = channel.register(selector, 0);\n        this.selectionKey.attach(this);\n        updateInterests();\n    }\n\n    @Override\n    public void disconnect() {\n        if (connected.get()) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            connected.set(false);\n        }\n    }\n\n    @Override\n    public void processReceive() {\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        try {\n            int bytesRead = channel.read(buffer);\n            if (bytesRead == -1) {\n                disconnect();\n                return;\n            }\n            buffer.flip();\n            networkToClient.process(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n            disconnect();\n        }\n    }\n\n    @Override\n    public void processSend() {\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        while (clientToNetwork.hasRemaining()) {\n            int bytesWritten = 0;\n            try {\n                bytesWritten = channel.write(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n                disconnect();\n                return;\n            }\n            if (bytesWritten == 0) {\n                break;\n            }\n        }\n        if (!clientToNetwork.hasRemaining()) {\n            updateInterests();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        channel.connect(new InetSocketAddress(getRemoteAddress(), getRemotePort()));\n        return channel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        clientToNetwork.write(packet.getPayload());\n        updateInterests();\n    }\n\n    private void updateInterests() {\n        int interests = 0;\n        if (mayRead()) {\n            interests |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interests |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interests |= SelectionKey.OP_CONNECT;\n        }\n        selectionKey.interestOps(interests);\n    }\n\n    private boolean mayRead() {\n        return connected.get() && networkToClient.hasRemaining();\n    }\n\n    private boolean mayWrite() {\n        return clientToNetwork.hasRemaining();\n    }\n\n    private boolean mayConnect() {\n        return !connected.get() && channel.isConnectionPending();\n    }\n}\n```"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    private boolean running = true;\n    private LongAdder total_bytes_sent = new LongAdder();\n    private LongAdder total_msgs = new LongAdder();\n    private Sender[] senders;\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(InetAddress host, boolean direct, int num_threads) throws IOException, InterruptedException {\n        sendMessages(host, direct, num_threads);\n        while (running) {\n            String input = System.console().readLine();\n            if (input.equals(\"exit\")) {\n                running = false;\n            }\n        }\n    }\n\n    public void sendMessages(InetAddress host, boolean direct, int num_threads) throws IOException {\n        senders = new Sender[num_threads];\n        CountDownLatch latch = new CountDownLatch(num_threads);\n        for (int i = 0; i < num_threads; i++) {\n            senders[i] = new Sender(host, direct, latch);\n            senders[i].start();\n        }\n        latch.await();\n    }\n\n    private class Sender extends Thread {\n        private SocketChannel ch;\n        private CountDownLatch latch;\n        private InetAddress host;\n        private boolean direct;\n        private ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.host = host;\n            this.direct = direct;\n            this.latch = latch;\n        }\n\n        public void run() {\n            try {\n                ch = SocketChannel.open();\n                ch.configureBlocking(false);\n                ch.connect(new InetSocketAddress(host, 8080));\n                while (!ch.finishConnect()) {\n                    Thread.sleep(10);\n                }\n                latch.countDown();\n                buf = create(1024, direct);\n                while (running) {\n                    buf.clear();\n                    for (int i = 0; i < 1024; i++) {\n                        buf.put((byte) i);\n                    }\n                    buf.flip();\n                    while (buf.hasRemaining()) {\n                        ch.write(buf);\n                    }\n                    total_bytes_sent.add(1024);\n                    total_msgs.increment();\n                }\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class ReadSocketService implements Runnable {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private ByteBuffer byteBufferRead;\n    private AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.selector = Selector.open();\n        this.socketChannel = socketChannel;\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(selector, SelectionKey.OP_READ);\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new HAServerReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                selector.select();\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    keys.remove();\n                    if (!key.isValid()) {\n                        continue;\n                    }\n                    if (key.isReadable()) {\n                        readData();\n                    }\n                }\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n        // Cleanup resources\n    }\n\n    private void readData() throws IOException {\n        int numRead = socketChannel.read(byteBufferRead);\n        if (numRead == -1) {\n            // Handle connection close\n            return;\n        }\n        lastReadTimestamp = System.currentTimeMillis();\n        if (numRead > 0) {\n            byteBufferRead.flip();\n            if (haReader.processReadResult(byteBufferRead)) {\n                byteBufferRead.compact();\n            } else {\n                byteBufferRead.clear();\n            }\n        }\n    }\n\n    public String getServiceName() {\n        // Return service name with broker identifier if in container mode\n        return \"ReadSocketService\";\n    }\n}\n```"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongSupplier;\nimport java.util.function.LongToDoubleFunction;\nimport java.util.function.LongToIntFunction;\nimport java.util.function.ObjDoubleConsumer;\nimport java.util.function.ObjIntConsumer;\nimport java.util.function.ObjLongConsumer;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.BinaryOperator;\nimport java.util.function.DoubleBinaryOperator;\nimport java.util.function.DoubleConsumer;\nimport java.util.function.DoubleFunction;\nimport java.util.function.DoublePredicate;\nimport java.util.function.DoubleSupplier;\nimport java.util.function.DoubleToIntFunction;\nimport java.util.function.DoubleToLongFunction;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntConsumer;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.function.IntToLongFunction;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongFunction;\nimport java.util.function.LongPredicate;\nimport java.util.function.Long"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ConnectionWorker implements Runnable {\n\n    private final Logger logger = LoggerFactory.getLogger(ConnectionWorker.class);\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(Selector selector, BlockingQueue<ConnectTask> connectQueue,\n            BlockingQueue<WriteTask> writeQueue, Semaphore semaphore, List<KeyProcessor> keyProcessors,\n            TimeService timeService, int selectorTimeoutMillis, long cleanupTimeoutMillis,\n            CleanupProcessor cleanupProcessor, NewConnectionAllower newConnectionAllower) {\n        this.selector = selector;\n        this.myConnectQueue = connectQueue;\n        this.myWriteQueue = writeQueue;\n        this.mySemaphore = semaphore;\n        this.myKeyProcessors = keyProcessors;\n        this.myTimeService = timeService;\n        this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n        this.myCleanupProcessor = cleanupProcessor;\n        this.myNewConnectionAllower = newConnectionAllower;\n    }\n\n    @Override\n    public void run() {\n        stop = false;\n        while (!stop) {\n            connectToPeersFromQueue();\n            processSelectedKeys();\n            processWriteTasks();\n            cleanup();\n            try {\n                mySemaphore.acquire();\n            } catch (InterruptedException e) {\n                logger.error(\"ConnectionWorker interrupted\", e);\n            }\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        ConnectTask task;\n        while ((task = myConnectQueue.poll()) != null) {\n            try {\n                task.connect();\n            } catch (IOException e) {\n                logger.error(\"Error connecting to peer\", e);\n            }\n        }\n    }\n\n    private void processSelectedKeys() {\n        try {\n            selector.select(mySelectorTimeoutMillis);\n            for (SelectionKey key : selector.selectedKeys()) {\n                processSelectedKey(key);\n            }\n            selector.selectedKeys().clear();\n        } catch (IOException e) {\n            logger.error(\"Error processing selected keys\", e);\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        for (KeyProcessor processor : myKeyProcessors) {\n            if (processor.canProcess(key)) {\n                processor.process(key);\n                break;\n            }\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            return queue.offer(task, timeout, unit);\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted while adding task to queue\", e);\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        WriteTask task;\n        while ((task = myWriteQueue.poll()) != null) {\n            try {\n                task.write();\n            } catch (IOException e) {\n                logger.error(\"Error writing to channel\", e);\n            }\n        }\n    }\n\n    private void cleanup() {\n        if (needRunCleanup()) {\n            myCleanupProcessor.cleanup();\n            lastCleanupTime = myTimeService.currentTimeMillis();\n        }\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime > myCleanupTimeoutMillis;\n    }\n}\n```"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Apache MINA framework for RTMP (Real-Time Messaging Protocol) transport, with configurable network settings and JMX monitoring capabilities.\n\nClass Description: RTMPMinaTransport is a TCP server implementation using Apache MINA that handles RTMP connections. It provides configurable network parameters, thread pooling options, and JMX monitoring capabilities. The class manages server lifecycle (start/stop), connection handling, and performance statistics.\n\nAttributes:\n\n- log: Logger - Logger instance for the class\n- executor: ThreadPoolExecutor - Thread pool executor for custom acceptor mode\n- acceptor: SocketAcceptor - MINA socket acceptor instance\n- addresses: Set<String> - Set of IP addresses and ports to bind to\n- ioHandler: IoHandlerAdapter - Handler for IO events\n- ioThreads: int - Number of IO threads (default: 2 * available processors)\n- serviceManagerObjectName: ObjectName - JMX MBean object name\n- stats: IoServiceStatistics - MINA service statistics\n- enableMinaLogFilter: boolean - Flag to enable MINA logging filter\n- enableMinaMonitor: boolean - Flag to enable JMX monitoring\n- minaPollInterval: int - JMX poll interval in ms (default: 1000)\n- tcpNoDelay: boolean - TCP_NODELAY flag (default: true)\n- useHeapBuffers: boolean - Use heap buffers flag (default: true)\n- sendBufferSize: int - Socket send buffer size (default: 65536)\n- receiveBufferSize: int - Socket receive buffer size (default: 65536)\n- readerIdleTime: int - Reader idle time in seconds (default: 2)\n- trafficClass: int - IP traffic class (default: 0x08 | 0x10)\n- backlog: int - Connection backlog (default: 32)\n- thoughputCalcInterval: int - Throughput calculation interval (default: 1)\n- executorKeepAliveTime: long - Thread keep-alive time in ms (default: 60000)\n- enableDefaultAcceptor: boolean - Use default acceptor flag (default: true)\n- initialPoolSize: int - Initial thread pool size (default: 0)\n- maxPoolSize: int - Maximum thread pool size (default: processors + 1)\n- maxProcessorPoolSize: int - Maximum processor pool size (default: 16)\n- keepAlive: boolean - Socket keep-alive flag\n\nMethods:\n\n- start() throws Exception -> void - Starts the TCP server with configured settings\n- stop() -> void - Stops the TCP server and cleans up resources\n- setAddress(String address) -> void - Adds a single address to bind to\n- setAddresses(List<String> addrs) -> void - Adds multiple addresses to bind to\n- setIoHandler(IoHandlerAdapter rtmpIOHandler) -> void - Sets the IO handler\n- setIoThreads(int ioThreads) -> void - Sets number of IO threads\n- setSendBufferSize(int sendBufferSize) -> void - Sets send buffer size\n- setReceiveBufferSize(int receiveBufferSize) -> void - Sets receive buffer size\n- setTrafficClass(int trafficClass) -> void - Sets IP traffic class\n- setBacklog(int backlog) -> void - Sets connection backlog\n- setThoughputCalcInterval(int thoughputCalcInterval) -> void - Sets throughput calculation interval\n- setExecutorKeepAliveTime(long executorKeepAliveTime) -> void - Sets thread keep-alive time\n- setEnableDefaultAcceptor(boolean enableDefaultAcceptor) -> void - Sets default acceptor flag\n- setInitialPoolSize(int initialPoolSize) -> void - Sets initial thread pool size\n- setMaxPoolSize(int maxPoolSize) -> void - Sets maximum thread pool size\n- setMaxProcessorPoolSize(int maxProcessorPoolSize) -> void - Sets maximum processor pool size\n- setTcpNoDelay(boolean tcpNoDelay) -> void - Sets TCP_NODELAY flag\n- setKeepAlive(boolean keepAlive) -> void - Sets socket keep-alive flag\n- setUseHeapBuffers(boolean useHeapBuffers) -> void - Sets heap buffers flag\n- setEnableMinaLogFilter(boolean enableMinaLogFilter) -> void - Enables/disables MINA logging filter\n- setEnableMinaMonitor(boolean enableMinaMonitor) -> void - Enables/disables JMX monitoring\n- setMinaPollInterval(int minaPollInterval) -> void - Sets JMX poll interval\n- setReaderIdleTime(int readerIdleTime) -> void - Sets reader idle time\n- isEnableMinaLogFilter() -> boolean - Returns MINA logging filter status\n- getAddress() -> String - Returns bound addresses as string",
    "Canonical_solution": "import java.lang.management.ManagementFactory;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\nimport org.apache.mina.transport.socket.nio.NioProcessor;\nimport org.apache.mina.transport.socket.nio.NioSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.red5.server.jmx.mxbeans.RTMPMinaTransportMXBean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport implements RTMPMinaTransportMXBean {\n\n    private static final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n\n    private ThreadPoolExecutor executor;\n\n    protected SocketAcceptor acceptor;\n\n    protected Set<String> addresses = new HashSet<String>();\n\n    protected IoHandlerAdapter ioHandler;\n\n    protected int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n\n    protected ObjectName serviceManagerObjectName;\n\n    protected IoServiceStatistics stats;\n\n    public void start() throws Exception {\n        IoBuffer.setUseDirectBuffer(!useHeapBuffers);\n        if (useHeapBuffers) {\n            IoBuffer.setAllocator(new SimpleBufferAllocator());\n        }\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            SimpleIoProcessorPool<NioSession> pool = new SimpleIoProcessorPool<NioSession>(NioProcessor.class, maxProcessorPoolSize);\n            executor = new ThreadPoolExecutor(initialPoolSize, maxPoolSize, executorKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(Short.MAX_VALUE));\n            acceptor = new NioSocketAcceptor(executor, pool);\n        }\n        if (enableMinaLogFilter) {\n            DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();\n            LoggingFilter logFilter = new LoggingFilter(RTMPMinaTransport.class);\n            chain.addLast(\"logger\", logFilter);\n        }\n        acceptor.setCloseOnDeactivation(true);\n        acceptor.setHandler(ioHandler);\n        acceptor.setBacklog(backlog);\n        SocketSessionConfig sessionConf = acceptor.getSessionConfig();\n        sessionConf.setReuseAddress(true);\n        sessionConf.setTcpNoDelay(tcpNoDelay);\n        sessionConf.setSendBufferSize(sendBufferSize);\n        sessionConf.setReceiveBufferSize(receiveBufferSize);\n        sessionConf.setMaxReadBufferSize(receiveBufferSize);\n        sessionConf.setThroughputCalculationInterval(thoughputCalcInterval);\n        sessionConf.setReaderIdleTime(readerIdleTime);\n        sessionConf.setKeepAlive(keepAlive);\n        if (trafficClass != -1) {\n            sessionConf.setTrafficClass(trafficClass);\n        }\n        acceptor.setReuseAddress(true);\n        Set<InetSocketAddress> socketAddresses = new HashSet<InetSocketAddress>();\n        for (String addr : addresses) {\n            if (addr.indexOf(':') != -1) {\n                String[] parts = addr.split(\":\");\n                socketAddresses.add(new InetSocketAddress(parts[0], Integer.valueOf(parts[1])));\n            } else {\n                socketAddresses.add(new InetSocketAddress(addr, 1935));\n            }\n        }\n        acceptor.bind(socketAddresses);\n        if (enableMinaMonitor) {\n            stats = new IoServiceStatistics((AbstractIoService) acceptor);\n            stats.setThroughputCalculationInterval(minaPollInterval);\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                serviceManagerObjectName = new ObjectName(\"org.red5.server:type=RTMPMinaTransport\");\n                mbs.registerMBean(new StandardMBean(this, RTMPMinaTransportMXBean.class, true), serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx registration\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        acceptor.unbind();\n        if (!enableDefaultAcceptor) {\n            executor.shutdownNow();\n        }\n        acceptor.dispose(false);\n        if (serviceManagerObjectName != null) {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                mbs.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx unregistration\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        for (String addr : addrs) {\n            addresses.add(addr);\n        }\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    protected boolean enableMinaLogFilter;\n\n    protected boolean enableMinaMonitor;\n\n    protected int minaPollInterval = 1000;\n\n    protected boolean tcpNoDelay = true;\n\n    protected boolean useHeapBuffers = true;\n\n    protected int sendBufferSize = 65536;\n\n    protected int receiveBufferSize = 65536;\n\n    private int readerIdleTime = 2;\n\n    private int trafficClass = 0x08 | 0x10;\n\n    private int backlog = 32;\n\n    private int thoughputCalcInterval = 1;\n\n    private long executorKeepAliveTime = 60000;\n\n    private boolean enableDefaultAcceptor = true;\n\n    private int initialPoolSize = 0;\n\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n\n    private int maxProcessorPoolSize = 16;\n\n    private boolean keepAlive;\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public String getAddress() {\n        return addresses.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "wrong_result": "```java\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.management.ObjectName;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class RTMPMinaTransport {\n    private Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n    private ThreadPoolExecutor executor;\n    private IoAcceptor acceptor;\n    private Set<String> addresses = new HashSet<>();\n    private IoHandlerAdapter ioHandler;\n    private int ioThreads = 2 * Runtime.getRuntime().availableProcessors();\n    private ObjectName serviceManagerObjectName;\n    private IoServiceStatistics stats;\n    private boolean enableMinaLogFilter = false;\n    private boolean enableMinaMonitor = false;\n    private int minaPollInterval = 1000;\n    private boolean tcpNoDelay = true;\n    private boolean useHeapBuffers = true;\n    private int sendBufferSize = 65536;\n    private int receiveBufferSize = 65536;\n    private int readerIdleTime = 2;\n    private int trafficClass = 0x08 | 0x10;\n    private int backlog = 32;\n    private int thoughputCalcInterval = 1;\n    private long executorKeepAliveTime = 60000;\n    private boolean enableDefaultAcceptor = true;\n    private int initialPoolSize = 0;\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n    private int maxProcessorPoolSize = 16;\n    private boolean keepAlive = true;\n\n    public void start() throws Exception {\n        if (executor == null) {\n            executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(maxPoolSize);\n        }\n        if (acceptor == null) {\n            acceptor = new NioSocketAcceptor(ioThreads, executor);\n        }\n        if (ioHandler == null) {\n            throw new IllegalStateException(\"No IoHandler set\");\n        }\n        if (addresses.isEmpty()) {\n            throw new IllegalStateException(\"No addresses set\");\n        }\n        if (enableMinaLogFilter) {\n            acceptor.getFilterChain().addLast(\"logger\", new LoggingFilter());\n        }\n        acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new RTMPProtocolCodecFactory()));\n        acceptor.setHandler(ioHandler);\n        acceptor.getSessionConfig().setTcpNoDelay(tcpNoDelay);\n        acceptor.getSessionConfig().setUseHeapBuffers(useHeapBuffers);\n        acceptor.getSessionConfig().setSendBufferSize(sendBufferSize);\n        acceptor.getSessionConfig().setReceiveBufferSize(receiveBufferSize);\n        acceptor.getSessionConfig().setReaderIdleTime(readerIdleTime);\n        acceptor.getSessionConfig().setTrafficClass(trafficClass);\n        acceptor.getSessionConfig().setBacklog(backlog);\n        acceptor.getSessionConfig().setKeepAlive(keepAlive);\n        acceptor.getSessionConfig().setThroughputCalculationInterval(thoughputCalcInterval);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, 10);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE, 10);\n        acceptor.getSessionConfig().setReuseAddress(true);\n        acceptor.getSessionConfig().setReusePort(true);\n        acceptor.getSessionConfig().setWriteTimeout(10000);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Java class that handles HTTP communication with a hub service, specifically for device registration and key management.\n\nClass Description: The HubHttpClient class provides functionality to register a device with a remote hub service using HTTP requests. It handles JSON serialization, authentication, and response processing, while supporting asynchronous operations.\n\nAttributes:\n- JSON: ObjectMapper - A static instance for JSON serialization/deserialization\n- EXPECTED_RESPONSE_CODES: List<Integer> - List of acceptable HTTP response codes\n- hubConfig: HubConfig - Configuration for the hub service\n- bearerToken: String - Authentication token for API requests\n- deviceId: String - Unique identifier for the device\n- keyPair: P384KeyPair - Cryptographic key pair for the device\n- result: CompletableFuture<ReceivedKey> - Future for asynchronous result handling\n- httpClient: HttpClient - HTTP client for making requests\n\nMethods:\n- HubHttpClient(ExecutorService, HubConfig, String, DeviceKey, CompletableFuture<ReceivedKey>, AtomicReference<String>) -> None - Constructor that initializes the HTTP client with configuration and credentials\n- registerDevice(String) -> None - Registers a device with the hub service using the provided device name\n- toJson(CreateDeviceDto) -> String - Serializes a DTO to JSON string\n- handleResponse(HttpResponse<Void>) -> HttpResponse<Void> - Processes the HTTP response\n- registrationFailed(Throwable) -> None - Handles failed registration attempts\n\nNested Class:\n- CreateDeviceDto - Data transfer object for device registration containing:\n  * id: String - Device identifier\n  * name: String - Device name\n  * type: String - Constant device type (\"DESKTOP\")\n  * publicKey: String - Base64-encoded public key",
    "Canonical_solution": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.cryptomator.common.settings.DeviceKey;\nimport org.cryptomator.cryptolib.common.P384KeyPair;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(201, 409);\n\n\tprivate final HubConfig hubConfig;\n\tprivate final String bearerToken;\n\tprivate final String deviceId;\n\tprivate final P384KeyPair keyPair;\n\tprivate final CompletableFuture<ReceivedKey> result;\n\tprivate final HttpClient httpClient;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.keyPair = Objects.requireNonNull(deviceKey.get());\n\t\tthis.result = result;\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken.get());\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t}\n\n\tpublic void registerDevice(String deviceName) {\n\t\tvar deviceUri = URI.create(hubConfig.devicesResourceUrl + deviceId);\n\t\tvar deviceKey = keyPair.getPublic().getEncoded();\n\t\tvar dto = new CreateDeviceDto();\n\t\tdto.id = deviceId;\n\t\tdto.name = deviceName;\n\t\tdto.publicKey = Base64.getUrlEncoder().withoutPadding().encodeToString(deviceKey);\n\t\tvar json = toJson(dto);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.PUT(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\thttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n\t\t\t\t.thenApply(response -> {\n\t\t\t\t\tif (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Server answered with unexpected status code \" + response.statusCode());\n\t\t\t\t\t}\n\t\t\t\t}).handle((response, throwable) -> {\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treturn handleResponse(response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregistrationFailed(throwable);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate String toJson(CreateDeviceDto dto) {\n\t\ttry {\n\t\t\treturn JSON.writer().writeValueAsString(dto);\n\t\t} catch (JacksonException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to serialize DTO\", e);\n\t\t}\n\t}\n\n\tprivate HttpResponse<Void> handleResponse(HttpResponse<Void> voidHttpResponse) {\n\t\tassert EXPECTED_RESPONSE_CODES.contains(voidHttpResponse.statusCode());\n\t\treturn voidHttpResponse;\n\t}\n\n\tprivate void registrationFailed(Throwable cause) {\n\t\tresult.completeExceptionally(cause);\n\t}\n\n\tprivate static class CreateDeviceDto {\n\t\tpublic String id;\n\t\tpublic String name;\n\t\tpublic final String type = \"DESKTOP\";\n\t\tpublic String publicKey;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.client.api.Request;\nimport org.eclipse.jetty.client.util.StringContentProvider;\nimport org.eclipse.jetty.http.HttpHeader;\nimport org.eclipse.jetty.http.HttpMethod;\nimport org.eclipse.jetty.http.HttpStatus;\nimport org.eclipse.jetty.util.ssl.SslContextFactory;\n\nimport java.net.URI;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n    private static final ObjectMapper JSON = new ObjectMapper();\n    private static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(HttpStatus.OK_200, HttpStatus.CREATED_201);\n\n    private final HubConfig hubConfig;\n    private final String bearerToken;\n    private final String deviceId;\n    private final P384KeyPair keyPair;\n    private final CompletableFuture<ReceivedKey> result;\n    private final HttpClient httpClient;\n\n    public HubHttpClient(ExecutorService executorService, HubConfig hubConfig, String bearerToken, String deviceId, P384KeyPair keyPair, CompletableFuture<ReceivedKey> result, AtomicReference<String> error) {\n        this.hubConfig = hubConfig;\n        this.bearerToken = bearerToken;\n        this.deviceId = deviceId;\n        this.keyPair = keyPair;\n        this.result = result;\n        this.httpClient = new HttpClient(new SslContextFactory.Client());\n        this.httpClient.setExecutor(executorService);\n        this.httpClient.start();\n    }\n\n    public void registerDevice(String deviceName) {\n        CreateDeviceDto createDeviceDto = new CreateDeviceDto(deviceId, deviceName, \"DESKTOP\", Base64.getEncoder().encodeToString(keyPair.getPublicKey().getEncoded()));\n        String json = toJson(createDeviceDto);\n        Request request = httpClient.newRequest(hubConfig.getHubUrl() + \"/devices\")\n                .method(HttpMethod.POST)\n                .header(HttpHeader.AUTHORIZATION, \"Bearer \" + bearerToken)\n                .content(new StringContentProvider(json), \"application/json\");\n        request.send(this::handleResponse);\n    }\n\n    private String toJson(CreateDeviceDto createDeviceDto) {\n        ObjectNode node = JSON.createObjectNode();\n        node.put(\"id\", createDeviceDto.getId());\n        node.put(\"name\", createDeviceDto.getName());\n        node.put(\"type\", createDeviceDto.getType());\n        node.put(\"publicKey\", createDeviceDto.getPublicKey());\n        return JSON.writeValueAsString(node);\n    }\n\n    private HttpResponse<Void> handleResponse(ContentResponse response) {\n        if (EXPECTED_RESPONSE_CODES.contains(response.getStatus())) {\n            result.complete(new ReceivedKey(response.getContentAsString()));\n        } else {\n            result.completeExceptionally(new RuntimeException(\"Registration failed with status code: \" + response.getStatus()));\n        }\n        return response;\n    }\n\n    public void registrationFailed(Throwable throwable) {\n        result.completeExceptionally(throwable);\n    }\n\n    private static class CreateDeviceDto {\n        private final String id;\n        private final String name;\n        private final String type;\n        private final String publicKey;\n\n        public CreateDeviceDto(String id, String name, String type, String publicKey) {\n            this.id = id;\n            this.name = name;\n            this.type = type;\n            this.publicKey = publicKey;\n        }\n\n        public String getId() {\n            return id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public String getPublicKey() {\n            return publicKey;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\n\npublic class Server implements Component {\n    private static final int SERVER_PORT = 8080;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) throws IOException {\n        this.dhts = dhts;\n        conMan = new NIOConnectionManager();\n        acceptor = ServerSocketChannel.open();\n        acceptor.configureBlocking(false);\n        acceptor.socket().bind(new InetSocketAddress(SERVER_PORT));\n        conMan.registerChannel(acceptor, SelectionKey.OP_ACCEPT);\n    }\n\n    public void stop() throws IOException {\n        acceptor.close();\n        conMan.releaseResources();\n    }\n\n    public void accept() throws IOException {\n        SocketChannel client = acceptor.accept();\n        client.configureBlocking(false);\n        conMan.registerChannel(client, SelectionKey.OP_READ);\n    }\n\n    public void read() throws IOException {\n        ByteBuffer buf = ByteBuffer.allocate(4);\n        conMan.read(buf);\n        buf.flip();\n        int len = buf.getInt();\n        buf = ByteBuffer.allocate(len);\n        conMan.read(buf);\n        process(buf);\n    }\n\n    public void process(ByteBuffer buf) {\n        // TODO: Implement command processing\n    }\n\n    public void write() throws IOException {\n        conMan.write();\n    }\n\n    public int calcInterestOps() {\n        return SelectionKey.OP_READ;\n    }\n\n    public void selectionEvent(SelectionKey key) throws IOException {\n        if (key.isReadable()) {\n            read();\n        }\n        if (key.isWritable()) {\n            write();\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {\n        if (key.isAcceptable()) {\n            accept();\n        }\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // TODO: Implement state checks\n    }\n}\n```"
  },
  {
    "Task_id": 441,
    "Instruction": "Task Description: Implement a Unix domain socket-based IPC server using Java NIO that can listen for incoming messages and send responses asynchronously.\n\nClass Description: The Server class implements an IPC communicator that establishes a Unix domain socket server. It handles client connections asynchronously, processes incoming messages through a listener callback, and sends responses. The server manages its socket resources and cleans up the socket file on termination.\n\nAttributes:\n- serverSocketChannel: [ServerSocketChannel] - The NIO channel for accepting client connections on the Unix domain socket\n- socketPath: [Path] - Filesystem path where the Unix domain socket is created\n- LOG: [Logger] - Logger instance for recording server events and errors\n\nMethods:\n- create: [static](Path socketPath) -> [Server] - Factory method that creates and binds a Unix domain socket server at the specified path. Throws IOException if binding fails.\n- isClient: []() -> [boolean] - Returns false indicating this is a server-side communicator (always returns false for Server instances)\n- listen: [](IpcMessageListener listener, Executor executor) -> [void] - Starts listening for incoming messages asynchronously using the provided executor. Each message is delivered to the listener callback.\n- send: [](IpcMessage message, Executor executor) -> [void] - Sends a message to a connected client asynchronously using the provided executor.\n- close: []() -> [void] - Closes the server socket channel and deletes the socket file. Throws IOException if cleanup fails.",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.StandardProtocolFamily;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.channels.AlreadyBoundException;\nimport java.nio.channels.AsynchronousCloseException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\n\nclass Server implements IpcCommunicator {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Server.class);\n\n\tprivate final ServerSocketChannel serverSocketChannel;\n\tprivate final Path socketPath;\n\n\tprivate Server(ServerSocketChannel serverSocketChannel, Path socketPath) {\n\t\tthis.serverSocketChannel = serverSocketChannel;\n\t\tthis.socketPath = socketPath;\n\t}\n\n\tpublic static Server create(Path socketPath) throws IOException {\n\t\tFiles.createDirectories(socketPath.getParent());\n\t\tvar address = UnixDomainSocketAddress.of(socketPath);\n\t\tServerSocketChannel ch = null;\n\t\ttry {\n\t\t\tch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n\t\t\tch.bind(address);\n\t\t\tLOG.info(\"Spawning IPC server listening on socket {}\", socketPath);\n\t\t\treturn new Server(ch, socketPath);\n\t\t} catch (IOException | AlreadyBoundException | UnsupportedAddressTypeException e) {\n\t\t\tif (ch != null) {\n\t\t\t\tch.close();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClient() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void listen(IpcMessageListener listener, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\twhile (serverSocketChannel.isOpen()) {\n\t\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\t\twhile (ch.isConnected()) {\n\t\t\t\t\t\tvar msg = IpcMessage.receive(ch);\n\t\t\t\t\t\tlistener.handleMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t} catch (AsynchronousCloseException e) {\n\t\t\t\t\treturn;\n\t\t\t\t} catch (EOFException | ClosedChannelException e) {\n\t\t\t\t\t// continue with next connected client\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Failed to read IPC message\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void send(IpcMessage message, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\tmessage.send(ch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(\"Failed to send IPC message\", e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tserverSocketChannel.close();\n\t\t} finally {\n\t\t\tFiles.deleteIfExists(socketPath);\n\t\t\tLOG.debug(\"IPC server closed\");\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Logger;\n\npublic class Server implements IpcCommunicator {\n    private final ServerSocketChannel serverSocketChannel;\n    private final Path socketPath;\n    private final Logger LOG;\n\n    private Server(ServerSocketChannel serverSocketChannel, Path socketPath, Logger LOG) {\n        this.serverSocketChannel = serverSocketChannel;\n        this.socketPath = socketPath;\n        this.LOG = LOG;\n    }\n\n    public static Server create(Path socketPath) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(socketPath.toFile());\n        Logger LOG = Logger.getLogger(Server.class.getName());\n        LOG.info(\"Server created at \" + socketPath);\n        return new Server(serverSocketChannel, socketPath, LOG);\n    }\n\n    @Override\n    public boolean isClient() {\n        return false;\n    }\n\n    @Override\n    public void listen(IpcMessageListener listener, Executor executor) {\n        executor.execute(() -> {\n            while (!serverSocketChannel.socket().isClosed()) {\n                try {\n                    SocketChannel clientChannel = serverSocketChannel.accept();\n                    executor.execute(() -> {\n                        try {\n                            IpcCommunicator client = new Client(clientChannel, LOG);\n                            IpcMessage message = client.receive();\n                            listener.onMessage(message, client);\n                        } catch (IOException e) {\n                            LOG.warning(\"Failed to process client message: \" + e.getMessage());\n                        }\n                    });\n                } catch (IOException e) {\n                    LOG.warning(\"Failed to accept client connection: \" + e.getMessage());\n                }\n            }\n        });\n    }\n\n    @Override\n    public void send(IpcMessage message, Executor executor) {\n        // This method is not implemented for the Server class\n    }\n\n    @Override\n    public void close() throws IOException {\n        serverSocketChannel.close();\n        socketPath.toFile().delete();\n        LOG.info(\"Server closed and socket file deleted\");\n    }\n}\n```"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NIOAcceptor implements Runnable {\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private final AtomicLong acceptCount = new AtomicLong(0);\n    private int nextProcessor = 0;\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                selector.select();\n                Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                while (it.hasNext()) {\n                    SelectionKey key = it.next();\n                    it.remove();\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void accept() throws IOException {\n        SocketChannel channel = serverChannel.accept();\n        channel.configureBlocking(false);\n        NIOProcessor processor = nextProcessor();\n        FrontendConnection connection = factory.createConnection(processor, channel);\n        processor.addConnection(connection);\n        acceptCount.incrementAndGet();\n    }\n\n    private NIOProcessor nextProcessor() {\n        return processors[nextProcessor++ % processors.length];\n    }\n\n    private void closeChannel(SocketChannel channel) {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final AtomicLong acceptId = new AtomicLong(0);\n        private static final Object lock = new Object();\n\n        public static long getId() {\n            synchronized (lock) {\n                return acceptId.incrementAndGet();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class MulticastSender {\n\n    private DatagramChannel sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n        this.prot_family = bind_addr instanceof Inet6Address ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n        this.sock = DatagramChannel.open(prot_family);\n        this.sock.configureBlocking(false);\n        this.sock.socket().bind(new InetSocketAddress(bind_addr, local_port));\n        this.sock.socket().setBroadcast(true);\n        this.sock.socket().setReuseAddress(true);\n        this.sock.socket().setTrafficClass(0x10);\n        this.sock.socket().setSoTimeout(0);\n        this.sock.socket().setSendBufferSize(1024 * 1024);\n        this.sock.socket().setReceiveBufferSize(1024 * 1024);\n        this.sock.socket().setTTL(ttl);\n        this.sock.connect(new InetSocketAddress(mcast_addr, mcast_port));\n    }\n\n    public void start() throws IOException {\n        Selector selector = Selector.open();\n        sock.register(selector, SelectionKey.OP_READ);\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n            while (keys.hasNext()) {\n                SelectionKey key = keys.next();\n                keys.remove();\n                if (!key.isValid()) {\n                    continue;\n                }\n                if (key.isReadable()) {\n                    buf.clear();\n                    sock.receive(buf);\n                    buf.flip();\n                    byte[] bytes = new byte[buf.limit()];\n                    buf.get(bytes);\n                    String msg = new String(bytes);\n                    System.out.println(\"Received: \" + msg);\n                }\n            }\n            buf.clear();\n            String input = System.console().readLine();\n            if (input == null) {\n                break;\n            }\n            buf.put(input.getBytes());\n            buf.flip();\n            sock.send(buf, sock.socket().getRemoteSocketAddress());\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        InetAddress bind_addr = InetAddress.getByName(\"0.0.0.0\");\n        int local_port = 12345;\n        InetAddress mcast_addr = InetAddress.getByName(\"224.0.0.1\");\n        int mcast_port = 12345;\n        int ttl = 1;\n        MulticastSender sender = new MulticastSender(bind_addr, local_port, mcast_addr, mcast_port, ttl);\n        sender.start();\n    }\n}\n```"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\n\npublic class HAProxy extends AbstractVerticle {\n    private Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private String HOST = \"localhost\";\n    private int PORT = 11080;\n    private SocketAddress remoteAddress;\n    private Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        server = vertx.createNetServer();\n        client = vertx.createNetClient();\n        server.connectHandler(this::handleConnection);\n        server.listen(PORT, HOST);\n        return this;\n    }\n\n    public void stop() {\n        server.close();\n        client.close();\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n\n    private void handleConnection(NetSocket clientSocket) {\n        clientSocket.handler(data -> {\n            if (connectionRemoteAddress == null) {\n                log.debug(\"Writing header to remote server\");\n                clientSocket.write(header);\n            }\n            clientSocket.write(data);\n        });\n        clientSocket.closeHandler(v -> {\n            if (connectionRemoteAddress != null) {\n                log.debug(\"Closing connection to remote server\");\n                clientSocket.close();\n            }\n        });\n        client.connect(remoteAddress.getPort(), remoteAddress.getHost(), res -> {\n            if (res.succeeded()) {\n                NetSocket serverSocket = res.result();\n                connectionRemoteAddress = serverSocket.remoteAddress();\n                connectionLocalAddress = serverSocket.localAddress();\n                log.debug(\"Connected to remote server: \" + connectionRemoteAddress);\n                serverSocket.handler(data -> {\n                    clientSocket.write(data);\n                });\n                serverSocket.closeHandler(v -> {\n                    log.debug(\"Closing connection to client\");\n                    clientSocket.close();\n                });\n            } else {\n                log.error(\"Failed to connect to remote server: \" + res.cause().getMessage());\n                clientSocket.close();\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with a radio scanner API, supporting both synchronous and asynchronous requests.\n\nClass Description: The RdioScannerHttpClient class provides methods to test API connections and send audio recordings to a radio scanner service using HTTP multipart form data requests. It uses Java's HttpClient for HTTP/2 communication with configurable timeouts and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection]([RdioScannerConfiguration configuration]) -> [String] - Synchronously tests the API connection by sending a test request with the API key and system ID, returns the response body with status code or error message\n- sendAudioRecordingAsync: [sendAudioRecordingAsync]([RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder]) -> [void] - Asynchronously sends an audio recording to the API using multipart form data, handles response completion with success/error callbacks",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class RdioScannerHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        RdioScannerBuilder bodyBuilder = new RdioScannerBuilder();\n        bodyBuilder.addPart(FormField.KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(config.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        // Handle error cases\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\nimport org.apache.hc.client5.http.async.methods.SimpleMultipartEntityBuilder;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\nimport org.apache.hc.client5.http.impl.async.HttpAsyncClients;\nimport org.apache.hc.core5.concurrent.FutureCallback;\nimport org.apache.hc.core5.http.ContentType;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.apache.hc.core5.http.nio.entity.AsyncEntityProducers;\nimport org.apache.hc.core5.http.nio.entity.FileEntityProducer;\nimport org.apache.hc.core5.http.nio.entity.StringEntityProducer;\nimport org.apache.hc.core5.http.nio.support.AsyncRequestBuilder;\nimport org.apache.hc.core5.http.nio.support.BasicRequestProducer;\nimport org.apache.hc.core5.http.nio.support.BasicResponseConsumer;\nimport org.apache.hc.core5.http.protocol.HttpContext;\nimport org.apache.hc.core5.io.CloseMode;\nimport org.apache.hc.core5.reactor.IOReactorConfig;\nimport org.apache.hc.core5.util.Timeout;\n\npublic class RdioScannerHttpClient {\n\n    private final CloseableHttpAsyncClient mHttpClient;\n\n    public RdioScannerHttpClient() {\n        mHttpClient = HttpAsyncClients.custom()\n                .setIOReactorConfig(IOReactorConfig.custom()\n                        .setSoTimeout(Timeout.ofSeconds(20))\n                        .build())\n                .setRedirectStrategy(new DefaultRedirectStrategyImpl())\n                .build();\n        mHttpClient.start();\n    }\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        try {\n            URI uri = new URI(configuration.getApiUrl() + \"/test\");\n            SimpleHttpRequest request = SimpleHttpRequests.get(uri)\n                    .addHeader(\"X-Api-Key\", configuration.getApiKey())\n                    .addHeader(\"X-System-Id\", configuration.getSystemId())\n                    .build();\n            CompletableFuture<SimpleHttpResponse> future = mHttpClient.execute(request, new FutureCallback<SimpleHttpResponse>() {\n                @Override\n                public void completed(SimpleHttpResponse response) {\n                    // Handle response completion\n                }\n\n                @Override\n                public void failed(Exception ex) {\n                    // Handle error\n                }\n\n                @Override\n                public void cancelled() {\n                    // Handle cancellation\n                }\n            });\n            SimpleHttpResponse response = future.get(20, TimeUnit.SECONDS);\n            return EntityUtils.toString(response.getEntity());\n        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException | IOException | ParseException e) {\n            e.printStackTrace();\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        try {\n            URI uri = new URI(config.getApiUrl() + \"/audio\");\n            SimpleMultipartEntityBuilder builder = SimpleMultipartEntityBuilder.create();\n            builder.addPart(\"audio\", new FileEntityProducer(Paths.get(bodyBuilder.getAudioFilePath()), ContentType.DEFAULT_BINARY));\n            builder.addPart(\"metadata\", new StringEntityProducer(bodyBuilder.getMetadata(), ContentType.APPLICATION_JSON));\n            HttpEntity entity = builder.build();\n            SimpleHttpRequest request = AsyncRequestBuilder.post(uri)\n                    .setEntity(entity)\n                    .addHeader(\"X-Api-Key\", config.getApiKey())\n                    .addHeader(\"X-System-Id\", config.getSystemId())\n                    .build();\n            mHttpClient.execute(request, new BasicResponseConsumer<SimpleHttpResponse>(new FutureCallback<SimpleHttpResponse>() {\n                @Override\n                public void completed(SimpleHttpResponse response) {\n                    // Handle response completion\n                }\n\n                @Override\n                public void failed(Exception ex) {\n                    // Handle error\n                }\n\n                @Override\n                public void cancelled() {\n                    // Handle cancellation\n                }\n            }), new HttpContext());\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            mHttpClient.close(CloseMode.GRACEFUL);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\n\npublic class VertxTcpServer extends AbstractVerticle {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        server = vertx.createNetServer();\n        server.connectHandler(this::handleConnection);\n        server.listen(port, host);\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            socket.write(buffer);\n        });\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n        socket.exceptionHandler(t -> {\n            t.printStackTrace();\n        });\n    }\n\n    public void stopServer() {\n        server.close(result -> {\n            if (result.succeeded()) {\n                System.out.println(\"Server stopped successfully\");\n            } else {\n                System.out.println(\"Failed to stop server: \" + result.cause().getMessage());\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.VertxOptions;\nimport io.vertx.core.eventbus.EventBusOptions;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private final NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n    this.server = vertx.createNetServer(getServerOptions());\n  }\n\n  private NetServerOptions getServerOptions() {\n    NetServerOptions serverOptions = new NetServerOptions();\n    serverOptions.setPort(options.getPort());\n    serverOptions.setHost(getClusterHost());\n    return serverOptions;\n  }\n\n  public void start(Promise<Void> promise) {\n    server.connectHandler(getServerHandler());\n    server.listen(ar -> {\n      if (ar.succeeded()) {\n        promise.complete();\n      } else {\n        promise.fail(ar.cause());\n      }\n    });\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      // Handle incoming connections and messages\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    return options.getHost() != null ? options.getHost() : \"localhost\";\n  }\n}\n```"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "```java\nvoid sendUdpPackets(Vertx vertx) {\n    vertx.createDatagramSocket(new DatagramSocketOptions())\n        .exceptionHandler(Throwable::printStackTrace)\n        .send(Buffer.buffer(\"Hello, World!\"), 1234, \"localhost\", ar -> {\n            if (ar.succeeded()) {\n                System.out.println(\"Send succeeded\");\n            } else {\n                System.out.println(\"Send failed\");\n            }\n        });\n\n    vertx.createDatagramSocket(new DatagramSocketOptions())\n        .exceptionHandler(Throwable::printStackTrace)\n        .send(\"Hello, World!\", 1234, \"localhost\", ar -> {\n            if (ar.succeeded()) {\n                System.out.println(\"Send succeeded\");\n            } else {\n                System.out.println(\"Send failed\");\n            }\n        });\n}\n```"
  },
  {
    "Task_id": 454,
    "Instruction": "Task Description: Retrieve the configurations of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: This function connects to a Kafka cluster using the provided bootstrap servers and retrieves the configurations for the specified topic names. It utilizes the Kafka AdminClient to describe the configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\n- topicNames: [String[]] - Array of topic names for which configurations need to be retrieved.\n\nOutput: \n- [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration entries for each topic. The operation will timeout after 3 seconds if the configuration retrieval is not completed.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "wrong_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigResource;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigs"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a Java class that provides administrative operations for Kafka topics, including retrieving configurations for individual topics, multiple topics, and all topics in a Kafka cluster.\n\nClass Description: The KafkaAdminTopicConfigProvider class is designed to interact with Kafka's AdminClient to perform topic configuration operations. It provides methods to fetch topic configurations either for a single topic, a set of topics, or all topics in the cluster. The class handles timeouts and errors gracefully and converts Kafka Config objects into standard Java Properties objects.\n\nAttributes:\n- _clusterConfigs: [Properties] - Stores configuration properties for the Kafka cluster\n- _adminClient: [AdminClient] - The Kafka AdminClient instance used to perform administrative operations\n- DESCRIBE_CLUSTER_CONFIGS_TIMEOUT: [Duration] - Constant defining the timeout duration for describeConfigs operations (90 seconds)\n- LOG: [Logger] - Logger instance for logging debug and warning messages\n\nMethods:\n- topicConfigs: [String topic] -> [Properties] - Retrieves configuration properties for a single specified topic. Returns empty Properties if retrieval fails.\n- topicConfigs: [Set<String> topics] -> [Map<String, Properties>] - Retrieves configurations for multiple topics specified in the input set. Returns a map of topic names to their configurations.\n- allTopicConfigs: [] -> [Map<String, Properties>] - Retrieves configurations for all topics in the Kafka cluster. Returns an empty map if retrieval fails.\n- convertConfigToProperties: [Config config] -> [Properties] - Helper method that converts a Kafka Config object into a Java Properties object, filtering out null entries.",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigEntry;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaAdminTopicConfigProvider {\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n  public static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n  protected Properties _clusterConfigs;\n  protected AdminClient _adminClient;\n\n  public Properties topicConfigs(String topic) {\n    Config topicConfig = null;\n    ConfigResource topicResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n    try {\n      LOG.debug(\"Requesting details for topic '{}'\", topic);\n      topicConfig = _adminClient\n              .describeConfigs(Collections.singletonList(topicResource))\n              .all()\n              .get()\n              .get(topicResource);\n    } catch (ExecutionException ee) {\n      if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n        LOG.warn(\"Failed to retrieve configuration for topic '{}' due to describeConfigs request time out.\", topic);\n      } else {\n        LOG.warn(\"Cannot retrieve configuration for topic '{}'.\", topic, ee);\n      }\n    } catch (InterruptedException ie) {\n      LOG.debug(\"Interrupted while getting configuration for topic '{}'.\", topic, ie);\n    }\n\n    if (topicConfig != null) {\n      return convertConfigToProperties(topicConfig);\n    } else {\n      LOG.warn(\"The configuration for topic '{}' could not be retrieved, returning empty Properties instance.\", topic);\n      return new Properties();\n    }\n  }\n\n  public Map<String, Properties> topicConfigs(Set<String> topics) {\n    Map<ConfigResource, KafkaFuture<Config>> topicConfigs;\n    topicConfigs = _adminClient.describeConfigs(\n            topics.stream().map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name)).collect(Collectors.toList())\n    ).values();\n\n    Map<String, Properties> propsMap = new HashMap<>();\n    if (topicConfigs != null) {\n      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : topicConfigs.entrySet()) {\n        try {\n          Config config = entry.getValue().get();\n          propsMap.put(entry.getKey().name(), convertConfigToProperties(config));\n        } catch (ExecutionException ee) {\n          if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n            LOG.warn(\"Failed to retrieve config for topics due to describeConfigs request timing out.\");\n            break;\n          } else {\n            LOG.debug(\"Cannot retrieve config for topic {}.\", entry.getKey().name(), ee);\n          }\n        } catch (InterruptedException ie) {\n          LOG.debug(\"Interrupted while getting config for topic {}.\", entry.getKey().name(), ie);\n        }\n      }\n    }\n    return propsMap;\n  }\n\n  public Map<String, Properties> allTopicConfigs() {\n    LOG.debug(\"Requesting configurations for all topics\");\n    Set<String> topicNames = null;\n    try {\n      topicNames = _adminClient.listTopics().names().get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOG.warn(\"Unable to obtain list of all topic names from the Kafka Cluster\");\n    }\n\n    if (topicNames == null) {\n      return Collections.emptyMap();\n    } else {\n      return topicConfigs(topicNames);\n    }\n  }\n\n  protected static Properties convertConfigToProperties(Config config) {\n    Properties props = new Properties();\n    for (ConfigEntry entry : config.entries()) {\n      if (entry.name() == null || entry.value() == null) {\n        continue;\n      }\n      props.put(entry.name(), entry.value());\n    }\n    return props;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "wrong_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.DescribeConfigsOptions;\nimport org.apache.kafka.clients"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Arrays;\nimport java.util.List;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport org.apache.hc.client5.http.classic.methods.HttpGet;\nimport org.apache.hc.client5.http.classic.methods.HttpPost;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.apache.hc.core5.http.io.entity.StringEntity;\n\npublic class HttpCommunicationClient {\n\n    private boolean usesSSL;\n    private SSLContext sslContext;\n    private InetSocketAddress address;\n    private URI uri;\n    private CloseableHttpClient httpClient;\n    private TrustManager[] trustAll;\n\n    public HttpCommunicationClient(boolean useSSL) {\n        this.usesSSL = useSSL;\n        this.trustAll = new TrustManager[] { new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            }\n        } };\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.address = address;\n        this.uri = URI.create((usesSSL ? \"https\" : \"http\") + \"://\" + address.getHostName() + \":\" + address.getPort());\n        this.httpClient = HttpClients.custom().setDefaultRequestConfig(RequestConfig.custom().setConnectTimeout(5000).build()).build();\n        if (usesSSL) {\n            try {\n                this.sslContext = SSLContext.getInstance(\"TLS\");\n                this.sslContext.init(null, trustAll, new java.security.SecureRandom());\n                this.httpClient = HttpClients.custom().setSSLSocketFactory(sslContext.getSocketFactory()).build();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public HttpResponse<String> get(String urlPath) {\n        HttpGet request = new HttpGet(uri.resolve(urlPath));\n        try (CloseableHttpResponse response = httpClient.execute(request)) {\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                return new HttpResponse<>(response.getStatusLine().getStatusCode(), EntityUtils.toString(entity));\n            }\n        } catch (ParseException | IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[]... headers) {\n        HttpPost request = new HttpPost(uri.resolve(urlPath));\n        request.setEntity(new StringEntity(body));\n        for (String[] header : headers) {\n            request.setHeader(header[0], header[1]);\n        }\n        try (CloseableHttpResponse response = httpClient.execute(request)) {\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                return new HttpResponse<>(response.getStatusLine().getStatusCode(), EntityUtils.toString(entity));\n            }\n        } catch (ParseException | IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public HttpResponse<String> post(String body, String[]... headers) {\n        HttpPost request = new HttpPost(uri);\n        request.setEntity(new StringEntity(body));\n        for (String[] header : headers) {\n            request.setHeader(header[0], header[1]);\n        }\n        try (CloseableHttpResponse response = httpClient.execute(request)) {\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                return new HttpResponse<>(response.getStatusLine().getStatusCode(), EntityUtils.toString(entity));\n            }\n        } catch (ParseException | IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static class HttpResponse<T> {\n        private int statusCode;\n        private T body;\n\n        public HttpResponse(int statusCode, T body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.logging.Logger;\n\nimport org.apache.hc.client5.http.async.methods.SimpleHttpRequest;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\nimport org.apache.hc.client5.http.async.methods.SimpleRequestBuilder;\nimport org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\nimport org.apache.hc.client5.http.impl.async.HttpAsyncClients;\nimport org.apache.hc.core5.concurrent.FutureCallback;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.apache.hc.core5.http.message.BasicNameValuePair;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n\n    private final Logger mLog;\n    private final HttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        mLog = Logger.getLogger(IcecastBroadcastMetadataUpdater.class.getName());\n        mHttpClient = HttpAsyncClients.createDefault();\n        mIcecastConfiguration = icecastConfiguration;\n        mConnectionLoggingSuppressed = false;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        String url = \"http://\" + mIcecastConfiguration.getHost() + \":\" + mIcecastConfiguration.getPort() + \"/admin/metadata\";\n        String mount = mIcecastConfiguration.getMountPoint();\n        String username = mIcecastConfiguration.getUsername();\n        String password = mIcecastConfiguration.getPassword();\n\n        String metadata = \"mode=updinfo&mount=\" + mount + \"&song=\" + encode(identifierCollection.getSong()) + \"&artist=\" + encode(identifierCollection.getArtist());\n\n        SimpleHttpRequest request = SimpleRequestBuilder.create(\"GET\", url)\n                .addHeader(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString((username + \":\" + password).getBytes(StandardCharsets.UTF_8)))\n                .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .addParameter(new BasicNameValuePair(\"mode\", \"updinfo\"))\n                .addParameter(new BasicNameValuePair(\"mount\", mount))\n                .addParameter(new BasicNameValuePair(\"song\", encode(identifierCollection.getSong())))\n                .addParameter(new BasicNameValuePair(\"artist\", encode(identifierCollection.getArtist())))\n                .build();\n\n        CompletableFuture<SimpleHttpResponse> future = mHttpClient.execute(request, new FutureCallback<SimpleHttpResponse>() {\n            @Override\n            public void completed(SimpleHttpResponse response) {\n                try {\n                    HttpEntity entity = response.getEntity();\n                    if (entity != null) {\n                        String responseBody = EntityUtils.toString(entity);\n                        if (response.getCode() == 200) {\n                            mLog.info(\"Metadata update successful: \" + responseBody);\n                        } else {\n                            mLog.warning(\"Metadata update failed: \" + responseBody);\n                        }\n                    }\n                } catch (ParseException | IOException e) {\n                    mLog.severe(\"Error parsing response: \" + e.getMessage());\n                }\n            }\n\n            @Override\n            public void failed(Exception ex) {\n                if (!mConnectionLoggingSuppressed) {\n                    mLog.severe(\"Failed to connect to Icecast server: \" + ex.getMessage());\n                    mConnectionLoggingSuppressed = true;\n                }\n            }\n\n            @Override\n            public void cancelled() {\n                mLog.warning(\"Metadata update request cancelled\");\n            }\n        });\n\n        try {\n            future.get();\n        } catch (InterruptedException | ExecutionException e) {\n            mLog.severe(\"Error executing metadata update request: \" + e.getMessage());\n        }\n    }\n\n    private String encode(String value) {\n        try {\n            return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());\n        } catch (UnsupportedEncodingException e) {\n            mLog.severe(\"Error encoding metadata value: \" + e.getMessage());\n            return value;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.function.Supplier;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        try {\n            String formattedUrl = String.format(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .GET()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (URISyntaxException | InterruptedException | java.io.IOException e) {\n            throw unchecked(() -> {\n                throw new RuntimeException(e);\n            });\n        }\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        try {\n            String formattedUrl = String.format(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .DELETE()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (URISyntaxException | InterruptedException | java.io.IOException e) {\n            throw unchecked(() -> {\n                throw new RuntimeException(e);\n            });\n        }\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        try {\n            String formattedUrl = String.format(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .POST(HttpRequest.BodyPublishers.noBody())\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (URISyntaxException | InterruptedException | java.io.IOException e) {\n            throw unchecked(() -> {\n                throw new RuntimeException(e);\n            });\n        }\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 498,
    "Instruction": "Task Description: Create a gRPC client class for service discovery that handles connection management, stub creation, and remote method invocation with retry logic.\n\nClass Description: DiscoveryClient is a gRPC client implementation that manages connections to a discovery service, provides thread-safe operations, and includes automatic retry mechanisms for failed requests.\n\nAttributes:\n- requireResetStub: AtomicBoolean - Flag indicating whether the stub needs to be reset\n- channel: ManagedChannel - The gRPC communication channel\n- registerStub: DiscoveryServiceBlockingStub - Blocking stub for registration operations  \n- blockingStub: DiscoveryServiceBlockingStub - Blocking stub for general operations\n- readWriteLock: ReentrantReadWriteLock - Lock for thread-safe operations\n- pdAddresses: List<String> - Server addresses (implied from usage)\n\nMethods:\n- DiscoveryClient(String centerAddress) -> None - Constructor that initializes the client with target server address\n- getNodeInfos(Query query) -> NodeInfos - Retrieves node information from discovery service with retry logic\n- tryWithTimes(Function<V,R> function, V v) -> R - Helper method implementing retry logic for operations\n- resetStub() -> None - Resets the channel and stubs when connection issues occur  \n- resetChannel(String address) -> None - Recreates the channel and stubs with a new address\n- close() -> None - Shuts down the channel and cleans up resources\n\nThe class demonstrates proper gRPC client patterns including:\n1. Channel lifecycle management\n2. Thread-safe stub operations\n3. Connection retry mechanisms\n4. Resource cleanup\n5. Error handling for network operations",
    "Canonical_solution": "import org.apache.hugegraph.pd.grpc.discovery.DiscoveryServiceGrpc;\nimport org.apache.hugegraph.pd.grpc.discovery.NodeInfos;\nimport org.apache.hugegraph.pd.grpc.discovery.Query;\nimport org.apache.hugegraph.pd.grpc.discovery.RegisterInfo;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel = null;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub blockingStub;\n    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public DiscoveryClient(String centerAddress) {\n        resetChannel(centerAddress);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((q) -> {\n            this.readWriteLock.readLock().lock();\n            NodeInfos nodes;\n            try {\n                nodes = this.blockingStub.getNodes(q);\n            } finally {\n                this.readWriteLock.readLock().unlock();\n            }\n            return nodes;\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        R r;\n        Exception ex = null;\n        for (int i = 0; i < 3; i++) {\n            try {\n                r = function.apply(v);\n                return r;\n            } catch (Exception e) {\n                requireResetStub.set(true);\n                resetStub();\n                ex = e;\n            }\n        }\n        if (ex != null) {\n            throw new RuntimeException(\"Discovery method failed\", ex);\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        if (requireResetStub.get()) {\n            try {\n                resetChannel(pdAddresses.get(0));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to reset stub\", e);\n            }\n        }\n    }\n\n    private void resetChannel(String address) {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.get()) {\n                if (channel != null) {\n                    channel.shutdownNow();\n                    channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n                }\n                channel = ManagedChannelBuilder.forTarget(address)\n                        .usePlaintext().build();\n                this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                requireResetStub.set(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n                channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\nimport io.grpc.stub.grpc.ClientCalls;\n"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Map;\nimport javax.net.ssl.*;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy;\n    private static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(timeOut);\n        connection.setReadTimeout(timeOut);\n        connection.setRequestMethod(requestMethod);\n        connection.setRequestProperty(\"Content-Type\", contentType);\n        if (postString != null) {\n            connection.setDoOutput(true);\n            OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), encoding);\n            writer.write(postString);\n            writer.flush();\n            writer.close();\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return readString(connection.getInputStream(), encoding);\n        } else {\n            return readString(connection.getErrorStream(), encoding);\n        }\n    }\n\n    private static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            stringBuilder.append(line);\n        }\n        reader.close();\n        return stringBuilder.toString();\n    }\n\n    private static class X509TrustUtil implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.StreamObserver;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Predicate;\n\npublic abstract class AbstractClient<ReqT, RespT> {\n    private final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    private final AbstractClientStubProxy stubProxy;\n    private final PDConfig config;\n    private ManagedChannel channel;\n    private final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy(this);\n    }\n\n    public AbstractBlockingStub getBlockingStub() {\n        return stubProxy.getBlockingStub();\n    }\n\n    public AbstractStub getStub() {\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    public String resetStub() {\n        closeChannel(channel);\n        channel = chs.computeIfAbsent(config.getHost(), this::createChannel);\n        return config.getHost();\n    }\n\n    public RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, config.getRetry());\n    }\n\n    public RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        return getBlockingStub().withDeadlineAfter(config.getTimeout(), config.getTimeUnit()).blockingUnaryCall(method, req);\n    }\n\n    public KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        return stubProxy.concurrentBlockingUnaryCall(method, req, predicate);\n    }\n\n    public void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        getBlockingStub().withDeadlineAfter(config.getTimeout(), config.getTimeUnit()).streamingCall(method, request, responseObserver);\n    }\n\n    public void close() {\n        chs.values().forEach(this::closeChannel);\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdown();\n        }\n    }\n\n    private ManagedChannel createChannel(String host) {\n        return ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n    }\n}\n```"
  },
  {
    "Task_id": 518,
    "Instruction": "Task Description: Create a Java class that implements a TCP server for unicast communication, handling client connections and data exchange with configurable parameters for testing purposes.\n\nClass Description: UnicastTestTcpRpc is a TCP server implementation that listens for incoming client connections, processes requests, and manages data transmission with configurable buffer sizes and communication modes (synchronous/asynchronous).\n\nAttributes:\n- srv_sock: [ServerSocket] - The server socket listening for incoming connections\n- sock: [Socket] - The active client connection socket\n- sock_in: [DataInputStream] - Input stream for reading data from the client\n- sock_out: [DataOutputStream] - Output stream for writing data to the client\n\nMethods:\n- init(long, boolean, boolean, boolean, boolean, String, int, int) -> [void] - Initializes the server with configuration parameters and starts the acceptor thread\n  Parameters:\n    - sleep_time: [long] - Sleep time between operations\n    - exit_on_end: [boolean] - Whether to exit after processing\n    - busy_sleep: [boolean] - Use busy waiting instead of sleep\n    - sync: [boolean] - Use synchronous communication\n    - oob: [boolean] - Use out-of-band data\n    - addr: [String] - Address to connect to\n    - local_port: [int] - Local port to listen on\n    - dest_port: [int] - Destination port for connections\n\n- createSocket() -> [void] - Creates a new client socket connection if none exists\n- handleRequest(DataInputStream, DataOutputStream) -> [boolean] - Processes incoming client requests\n  Parameters:\n    - in: [DataInputStream] - Input stream from client\n    - out: [DataOutputStream] - Output stream to client\n  Returns: [boolean] - Whether to continue processing requests\n\n- set(Socket) -> [void] - Configures socket parameters (TCP_NODELAY, buffer sizes)\n  Parameters:\n    - socket: [Socket] - Socket to configure\n\n- stop() -> [void] - Closes all open sockets and releases resources\n- startTest(int) -> [void] - Starts the test with given parameters\n  Parameters:\n    - num: [int] - Test parameter\n\n- receiveData(long, byte[]) -> [void] - Handles received data from client\n  Parameters:\n    - val: [long] - Timestamp or identifier\n    - data: [byte[]] - Received data payload",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private volatile Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    static final byte START         =  0;\n    static final byte RECEIVE_ASYNC =  1;\n    static final byte RECEIVE_SYNC  =  2;\n    static final byte ACK           = 10;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob,\n                     String addr, int local_port, int dest_port) throws Exception {\n        this.srv_sock = new ServerSocket(local_port);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        \n        Thread acceptor = new Thread(() -> {\n            while(true) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                DataOutputStream out = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    set(client_sock);\n                    in = new DataInputStream(client_sock.getInputStream());\n                    out = new DataOutputStream(client_sock.getOutputStream());\n                    if(!handleRequest(in, out)) {\n                        Util.close(client_sock);\n                        Util.close(out);\n                        Util.close(in);\n                        break;\n                    }\n                }\n                catch(IOException e) {\n                    Util.close(client_sock);\n                    Util.close(out);\n                    Util.close(in);\n                    break;\n                }\n            }\n        });\n        acceptor.start();\n    }\n\n    void createSocket() throws IOException {\n        if(sock == null) {\n            sock = new Socket(InetAddress.getByName(null), 9000);\n            set(sock);\n            sock_in = new DataInputStream(sock.getInputStream());\n            sock_out = new DataOutputStream(sock.getOutputStream());\n        }\n    }\n\n    boolean handleRequest(DataInputStream in, DataOutputStream out) throws IOException {\n        while(true) {\n            byte type = (byte)in.read();\n            if(type == -1)\n                return false;\n\n            switch(type) {\n                case START:\n                    int num = in.readInt();\n                    startTest(num);\n                    break;\n                case RECEIVE_ASYNC:\n                case RECEIVE_SYNC:\n                    long val = in.readLong();\n                    int len = in.readInt();\n                    byte[] data = new byte[len];\n                    in.readFully(data, 0, data.length);\n                    receiveData(val, data);\n                    if(type == RECEIVE_SYNC) {\n                        out.writeLong(System.currentTimeMillis());\n                        out.flush();\n                    }\n                    break;\n                default:\n                    System.err.println(\"type \" + type + \" not known\");\n            }\n        }\n    }\n\n    static void set(Socket socket) throws SocketException {\n        socket.setTcpNoDelay(true);\n        socket.setReceiveBufferSize(20000000);\n        socket.setSendBufferSize(10000000);\n    }\n\n    void stop() {\n        Util.close(sock);\n        Util.close(srv_sock);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob, String addr, int local_port, int dest_port) {\n        // Implementation goes here\n    }\n\n    public void createSocket() {\n        // Implementation goes here\n    }\n\n    public boolean handleRequest(DataInputStream in, DataOutputStream out) {\n        // Implementation goes here\n        return true;\n    }\n\n    public void set(Socket socket) {\n        // Implementation goes here\n    }\n\n    public void stop() {\n        // Implementation goes here\n    }\n\n    public void startTest(int num) {\n        // Implementation goes here\n    }\n\n    public void receiveData(long val, byte[] data) {\n        // Implementation goes here\n    }\n}\n```"
  },
  {
    "Task_id": 519,
    "Instruction": "Task Description: Create a mock IMAP server implementation in Java that simulates IMAP server behavior for testing purposes, handling client connections and interactions through TCP sockets.\n\nClass Description: MockImapServer is a test utility class that simulates an IMAP server by listening on a local port, accepting client connections, and processing predefined interactions. It manages server lifecycle and provides synchronization mechanisms for test coordination.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of predefined IMAP interactions to simulate\n- waitForConnectionClosed: CountDownLatch - Synchronization primitive for waiting until client connection closes\n- waitForAllExpectedCommands: CountDownLatch - Synchronization primitive for waiting until all expected commands are processed\n- mockServerThread: MockServerThread - The thread running the server operations\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread. Binds to an available port on localhost.\n- shutdown() -> void - Stops the server thread and cleans up resources, with a 500ms timeout for graceful shutdown.\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread implementation\n- run() -> void - Main server thread logic that accepts connections, processes interactions, and handles cleanup\n- handleInteractions() -> void - Processes the next interaction from the queue (internal method)\n- readAdditionalCommands() -> void - Reads additional unexpected commands from client (internal method)\n- shouldStop() -> void - Signals the server thread to stop and closes client socket",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = ((java.net.InetSocketAddress) serverSocket.getLocalSocketAddress()).getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            mockServerThread.join(500L);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                              CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    if (clientSocket != null) {\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(clientSocket.getInputStream())).readLine();\n            if (command == null) {\n                throw new java.io.EOFException();\n            }\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                if (clientSocket != null) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class MockImapServer {\n\n    private final Deque<ImapInteraction> interactions = new LinkedBlockingDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final MockServerThread mockServerThread;\n    private final String host = \"localhost\";\n    private int port;\n\n    public MockImapServer() {\n        this.mockServerThread = new MockServerThread();\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getByName(host));\n        port = serverSocket.getLocalPort();\n        mockServerThread.start(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private class MockServerThread extends Thread {\n\n        private ServerSocket serverSocket;\n        private Deque<ImapInteraction> interactions;\n        private CountDownLatch waitForConnectionClosed;\n        private CountDownLatch waitForAllExpectedCommands;\n\n        public void start(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            start();\n        }\n\n        @Override\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept()) {\n                handleInteractions();\n                readAdditionalCommands();\n            } catch (IOException e) {\n                // Ignore\n            } finally {\n                waitForConnectionClosed.countDown();\n            }\n        }\n\n        private void handleInteractions() {\n            while (!interactions.isEmpty()) {\n                ImapInteraction interaction = interactions.poll();\n                interaction.process();\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readAdditionalCommands() {\n            // Read additional unexpected commands from client\n        }\n\n        public void shouldStop() {\n            // Signal the server thread to stop and close client socket\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\n\npublic class SocketCommunication {\n    private static final String TAG = \"SocketCommunication\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String secret, VirtualCheckCallback callback, ArrayList<Integer> portList) {\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String host, VirtualCheckCallback callback) {\n        new Thread(() -> startServer(host, callback)).start();\n        new Thread(() -> startClient(host)).start();\n    }\n\n    private void startServer(String host, VirtualCheckCallback callback) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            Log.d(TAG, \"Server started on port \" + serverSocket.getLocalPort());\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new Thread(() -> readFromSocket(host, socket, callback)).start();\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"ServerSocket error\", e);\n        }\n    }\n\n    private void startClient(String host) {\n        for (int port : portList) {\n            new Thread(() -> connectToServer(host, port)).start();\n        }\n    }\n\n    private void readFromSocket(String host, Socket socket, VirtualCheckCallback callback) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            String input = in.readLine();\n            if (input != null && input.equals(secret)) {\n                callback.onSuspectFound(host, socket.getLocalPort());\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Socket error\", e);\n        }\n    }\n\n    private void connectToServer(String host, int port) {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n            out.println(secret);\n        } catch (IOException e) {\n            Log.e(TAG, \"Socket error\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport io.kubernetes.client.util.KubeConfig;\nimport io.kubernetes.client.util.Kubectl;\nimport io.kubernetes.client.util.PortForward;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward extends Kubectl.ResourceAndContainerBuilder implements Kubectl.Executable<Boolean> {\n    private List<Integer> localPorts = new ArrayList<>();\n    private List<Integer> targetPorts = new ArrayList<>();\n    private boolean running = false;\n    private Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward(String namespace, String podName) {\n        super(namespace, podName);\n    }\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        localPorts.add(localPort);\n        targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() {\n        running = true;\n        ExecutorService executor = Executors.newFixedThreadPool(localPorts.size());\n        for (int i = 0; i < localPorts.size(); i++) {\n            int localPort = localPorts.get(i);\n            int targetPort = targetPorts.get(i);\n            executor.submit(() -> {\n                try {\n                    executeInternal(localPort, targetPort);\n                } catch (ApiException | KubectlException | IOException | InterruptedException e) {\n                    if (onUnhandledError != null) {\n                        onUnhandledError.accept(e);\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n        return true;\n    }\n\n    private void executeInternal(int localPort, int targetPort) throws ApiException, KubectlException, IOException, InterruptedException {\n        KubeConfig config = KubeConfig.loadKubeConfig();\n        V1Pod pod = getPod(config);\n        ServerSocket server = new ServerSocket(localPort);\n        PortForward pf = new PortForward(config, pod.getMetadata().getName(), pod.getMetadata().getNamespace(), targetPort, server.getLocalPort());\n        pf.execute();\n        portForward(pf, server, targetPort);\n    }\n\n    private void portForward(PortForward pf, ServerSocket server, int targetPort) {\n        Thread thread = new Thread(() -> {\n            try {\n                while (running) {\n                    ServerSocket serverSocket = server.accept();\n                    pf.forward(serverSocket, targetPort);\n                }\n            } catch (IOException e) {\n                if (onUnhandledError != null) {\n                    onUnhandledError.accept(e);\n                }\n            }\n        });\n        thread.start();\n    }\n\n    public void shutdown() {\n        running = false;\n    }\n}\n```"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newCachedThreadPool();\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Config(context));\n    }\n\n    public HttpProxyCacheServer(Config config) {\n        this.config = config;\n        this.port = config.getPort();\n        try {\n            this.serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Can't start server on port \" + port, e);\n        }\n        this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n    }\n\n    public void waitForRequest() {\n        waitConnectionThread.start();\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            HttpProxyCacheServerClients clients = getClients(socket.getInetAddress().getHostAddress());\n            clients.process(socket);\n        } catch (IOException e) {\n            onError(e);\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients();\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            socket.shutdownInput();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            socket.shutdownOutput();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n    }\n\n    private void onError(Throwable e) {\n        // Handle error\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        @Override\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    Socket socket = serverSocket.accept();\n                    socketProcessor.execute(new SocketProcessorRunnable(socket));\n                } catch (IOException e) {\n                    onError(e);\n                }\n            }\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 525,
    "Instruction": "Task Description: Create a Java class that implements a multithreaded TCP echo server capable of handling both plain and SSL/TLS encrypted connections. The server should echo back any data received from clients and support SSL renegotiation.\n\nClass Description: EchoServer is a Thread subclass that creates a TCP server listening on a specified port. It can operate in both plain and SSL/TLS modes, maintains connections in threads, and provides methods for graceful shutdown and connection management.\n\nAttributes:\n- port: int - The port number the server listens on\n- serverSocket: ServerSocket - The server socket accepting client connections\n- threads: List<Thread> - Synchronized list of active client handler threads\n- sockets: List<Socket> - Synchronized list of active client sockets\n- exceptions: List<Exception> - Synchronized list of encountered exceptions\n- renegotiate: AtomicBoolean - Flag to trigger SSL renegotiation\n\nMethods:\n- EchoServer(int port) -> void - Constructor for plain TCP server\n- EchoServer(SSLFactory sslFactory, int port) -> void - Constructor for SSL/TLS server\n- renegotiate() -> void - Triggers SSL renegotiation for all connections\n- run() -> void - Main server thread accepting connections and spawning handlers\n- closeConnections() -> void - Closes all active client connections\n- close() -> void - Shuts down the server gracefully\n- getExceptionCount() -> int - Returns count of encountered exceptions",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\n\npublic class EchoServer extends Thread {\n  public final int port;\n  private final ServerSocket serverSocket;\n  private final List<Thread> threads;\n  private final List<Socket> sockets;\n  private final List<Exception> exceptions;\n  private final AtomicBoolean renegotiate = new AtomicBoolean();\n\n  public EchoServer(int port) throws Exception {\n    this(null, port);\n  }\n\n  public EchoServer(SSLFactory sslFactory, int port) throws Exception {\n    this.port = port;\n    if (sslFactory == null) {\n      this.serverSocket = new ServerSocket(port);\n    } else {\n      SSLContext sslContext = sslFactory.getSSLContext();\n      this.serverSocket = sslContext.getServerSocketFactory().createServerSocket(port);\n      ((SSLServerSocket) this.serverSocket).setNeedClientAuth(true);\n    }\n    this.threads = Collections.synchronizedList(new ArrayList<Thread>());\n    this.sockets = Collections.synchronizedList(new ArrayList<Socket>());\n    this.exceptions = Collections.synchronizedList(new ArrayList<Exception>());\n  }\n\n  public void renegotiate() {\n    renegotiate.set(true);\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        final Socket socket = serverSocket.accept();\n        sockets.add(socket);\n        Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              socket.setSoTimeout(3000);\n              DataInputStream input = new DataInputStream(socket.getInputStream());\n              DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n              while (socket.isConnected() && !socket.isClosed()) {\n                long size = input.readLong();\n                if (renegotiate.compareAndSet(true, false)) {\n                  ((SSLSocket) socket).startHandshake();\n                }\n                byte[] bytes = new byte[(int) size - 8];\n                input.readFully(bytes);\n                output.writeLong(size);\n                output.write(bytes);\n                output.flush();\n              }\n            } catch (IOException e) {\n              // ignore, caused by client closed connection\n            } finally {\n              try {\n                socket.close();\n              } catch (IOException e) {\n                exceptions.add(e);\n              }\n            }\n          }\n        };\n        thread.start();\n        threads.add(thread);\n      }\n    } catch (IOException e) {\n      exceptions.add(e);\n    }\n  }\n\n  public void closeConnections() throws IOException {\n    for (Socket socket : sockets) {\n      socket.close();\n    }\n  }\n\n  public void close() throws IOException, InterruptedException {\n    this.serverSocket.close();\n    closeConnections();\n    for (Thread t : threads) {\n      t.join();\n    }\n    join();\n  }\n\n  public int getExceptionCount() {\n    return exceptions.size();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class EchoServer extends Thread {\n    private int port;\n    private ServerSocket serverSocket;\n    private List<Thread> threads = new ArrayList<>();\n    private List<Socket> sockets = new ArrayList<>();\n    private List<Exception> exceptions = new ArrayList<>();\n    private AtomicBoolean renegotiate = new AtomicBoolean(false);\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public EchoServer(SSLFactory sslFactory, int port) {\n        this.port = port;\n    }\n\n    public void renegotiate() {\n        renegotiate.set(true);\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(port);\n            while (!isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                threads.add(new Thread(new EchoHandler(socket, renegotiate)));\n                sockets.add(socket);\n                threads.get(threads.size() - 1).start();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public void closeConnections() {\n        for (Socket socket : sockets) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                exceptions.add(e);\n            }\n        }\n    }\n\n    public void close() {\n        closeConnections();\n        try {\n            serverSocket.close();\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n        interrupt();\n    }\n\n    public int getExceptionCount() {\n        return exceptions.size();\n    }\n}\n```"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class URLFetcher {\n\n    private static final int MAX_REDIRECTS = 10;\n    private static final String USER_AGENT = \"Mozilla/5.0\";\n\n    public static InputStream fetch(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            Map<String, String> cookies = new HashMap<>();\n            return fetch(url, cookies, 0);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private static InputStream fetch(URL url, Map<String, String> cookies, int redirectCount) throws IOException {\n        if (redirectCount > MAX_REDIRECTS) {\n            throw new IOException(\"Maximum redirect count exceeded\");\n        }\n\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"User-Agent\", USER_AGENT);\n\n        for (Map.Entry<String, String> cookie : cookies.entrySet()) {\n            connection.setRequestProperty(\"Cookie\", cookie.getKey() + \"=\" + cookie.getValue());\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectUrl = connection.getHeaderField(\"Location\");\n            URL newUrl = new URL(url, redirectUrl);\n            cookies.putAll(parseCookies(connection.getHeaderFields()));\n            return fetch(newUrl, cookies, redirectCount + 1);\n        } else if (responseCode >= 200 && responseCode < 300) {\n            return connection.getInputStream();\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    private static Map<String, String> parseCookies(Map<String, List<String>> headerFields) {\n        Map<String, String> cookies = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {\n            if (\"Set-Cookie\".equalsIgnoreCase(entry.getKey())) {\n                for (String cookieStr : entry.getValue()) {\n                    String[] parts = cookieStr.split(\";\");\n                    String[] nameValue = parts[0].split(\"=\");\n                    cookies.put(nameValue[0], nameValue[1]);\n                }\n            }\n        }\n        return cookies;\n    }\n}\n```"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Base64;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            serverThread = new Thread(() -> {\n                while (!Thread.currentThread().isInterrupted()) {\n                    try {\n                        Socket client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            serverThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            serverSocket.close();\n            serverThread.interrupt();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        // Handle WebSocket handshake protocol\n        // ...\n    }\n\n    private String generateFinalKey(String in) {\n        String guid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        String key = in.trim() + guid;\n        byte[] bytes = key.getBytes();\n        byte[] sha1 = new byte[20];\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"SHA-1\");\n            md.update(bytes, 0, bytes.length);\n            sha1 = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return Base64.getEncoder().encodeToString(sha1);\n    }\n}\n```"
  },
  {
    "Task_id": 532,
    "Instruction": "Task Description: Create a WebSocket server class in Java that handles WebSocket connections, performs WebSocket handshake, and sends binary frames to clients.\n\nClass Description: The WebSocketServer class implements a basic WebSocket server that listens for incoming connections, performs the WebSocket handshake protocol, and sends binary data frames to connected clients. It supports configurable masking and frame size.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket used to listen for incoming connections\n- port: int - The port number on which the server listens for connections\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server by creating and binding the server socket\n- handleConnection() -> void - Handles an incoming connection, performs WebSocket handshake, and sends binary frames\n- stop() -> void - Stops the server by closing the server socket\n\nThe class should:\n1. Accept incoming TCP connections\n2. Parse WebSocket handshake headers\n3. Generate proper handshake response\n4. Create and send binary frames with configurable masking and size\n5. Properly close connections and clean up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport org.java_websocket.util.Charsetfunctions;\nimport org.java_websocket.util.KeyUtils;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.framing.BinaryFrame;\nimport java.nio.ByteBuffer;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n    }\n\n    public void handleConnection() throws IOException, InterruptedException {\n        Socket client = serverSocket.accept();\n        Scanner in = new Scanner(client.getInputStream());\n        String input;\n        String seckey = \"\";\n        String testCase;\n        boolean useMask = false;\n        int size = 0;\n        OutputStream os = client.getOutputStream();\n\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                os.write(Charsetfunctions.asciiBytes(\n                    \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\"\n                        + KeyUtils.getSecKey(seckey) + \"\\r\\n\"));\n                os.flush();\n                Thread.sleep(10);\n                Draft_6455 draft_6455 = new Draft_6455();\n                BinaryFrame binaryFrame = new BinaryFrame();\n                binaryFrame.setPayload(ByteBuffer.allocate(size));\n                binaryFrame.setTransferemasked(useMask);\n                ByteBuffer byteBuffer = draft_6455.createBinaryFrame(binaryFrame);\n                byte[] bytes = byteBuffer.array();\n                int first = size / 2;\n                os.write(bytes, 0, first);\n                os.flush();\n                Thread.sleep(5);\n                os.write(bytes, first, bytes.length - first);\n                os.flush();\n                break;\n            }\n            if (input.startsWith(\"GET \")) {\n                testCase = input.split(\" \")[1];\n                String[] strings = testCase.split(\"/\");\n                useMask = Boolean.valueOf(strings[1]);\n                size = Integer.valueOf(strings[2]);\n            }\n        }\n        client.close();\n    }\n\n    public void stop() throws IOException {\n        serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"WebSocket server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"New client connected: \" + clientSocket.getInetAddress().getHostAddress());\n                Thread clientThread = new Thread(() -> handleConnection(clientSocket));\n                clientThread.start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleConnection(Socket clientSocket) {\n        try {\n            // Perform WebSocket handshake\n            // ...\n\n            // Send binary frames\n            List<ByteBuffer> frames = new ArrayList<>();\n            frames.add(ByteBuffer.wrap(\"Hello, client!\".getBytes()));\n            frames.add(ByteBuffer.wrap(\"This is a binary frame.\".getBytes()));\n            for (ByteBuffer frame : frames) {\n                // Send frame with configurable masking and size\n                // ...\n            }\n\n            // Close connection\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            serverSocket.close();\n            System.out.println(\"WebSocket server stopped\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 533,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to handle client connections, process incoming requests, and send responses. The server should integrate with Eureka service discovery and manage its lifecycle through initialization and cleanup.\n\nClass Description: ExampleServiceBase is a singleton class that acts as a TCP server, listening on a specified port for client connections. It processes incoming requests by reading input from clients and sending back responses with a timestamp. The class integrates with Eureka service discovery to register its availability.\n\nAttributes:\n- applicationInfoManager: [ApplicationInfoManager] - Manages the service instance information for Eureka registration\n- eurekaClient: [EurekaClient] - Handles communication with the Eureka service discovery server\n\nMethods:\n- ExampleServiceBase([ApplicationInfoManager, EurekaClient]) -> [void] - Constructor that initializes the Eureka-related dependencies\n- start() -> [void] - Initializes the service by setting its status to UP in Eureka and starts listening for client connections on the registered port\n- processRequest([Socket]) -> [void] - Processes an incoming client connection by reading the request, generating a response with current timestamp, and sending it back to the client",
    "Canonical_solution": "import com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\n@Singleton\npublic class ExampleServiceBase {\n\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n\n    @Inject\n    public ExampleServiceBase(ApplicationInfoManager applicationInfoManager,\n                            EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    @PostConstruct\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        \n        try {\n            int myServingPort = applicationInfoManager.getInfo().getPort();\n            ServerSocket serverSocket = new ServerSocket(myServingPort);\n            final Socket s = serverSocket.accept();\n            processRequest(s);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(final Socket s) {\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n            String line = rd.readLine();\n            if (line != null) {\n                System.out.println(\"Received a request from the example client: \" + line);\n            }\n            String response = \"BAR \" + new Date();\n            System.out.println(\"Sending the response to the client: \" + response);\n\n            PrintStream out = new PrintStream(s.getOutputStream());\n            out.println(response);\n\n        } catch (Throwable e) {\n            System.err.println(\"Error processing requests\");\n        } finally {\n            if (s != null) {\n                try {\n                    s.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ExampleServiceBase {\n    private static ExampleServiceBase instance;\n    private ApplicationInfoManager applicationInfoManager;\n    private EurekaClient eurekaClient;\n\n    private ExampleServiceBase(ApplicationInfoManager applicationInfoManager, EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    public static ExampleServiceBase getInstance(ApplicationInfoManager applicationInfoManager, EurekaClient eurekaClient) {\n        if (instance == null) {\n            instance = new ExampleServiceBase(applicationInfoManager, eurekaClient);\n        }\n        return instance;\n    }\n\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server started on port 8080\");\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                processRequest(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received request: \" + inputLine);\n                String response = \"Response at \" + System.currentTimeMillis();\n                out.println(response);\n                break;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider {\n    private EvdevListener listener;\n    private String libraryPath;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private HandlerThread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n        this.shutdown = false;\n        this.started = false;\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevSock != null) {\n                evdevSock.close();\n            }\n            if (servSock != null) {\n                servSock.close();\n            }\n            if (su != null) {\n                su.destroy();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        Context context = activity.getApplicationContext();\n        CharSequence text = \"Device not rooted\";\n        int duration = Toast.LENGTH_SHORT;\n\n        Toast toast = Toast.makeText(context, text, duration);\n        toast.show();\n    }\n\n    private class SocketThread extends Thread {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0);\n                int port = servSock.getLocalPort();\n                String cmd = \"LD_LIBRARY_PATH=\" + libraryPath + \" ./evdev_reader \" + port;\n                su = Runtime.getRuntime().exec(cmd);\n\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n\n                started = true;\n\n                byte[] buffer = new byte[256];\n                int len;\n                while ((len = evdevIn.read(buffer)) > 0) {\n                    listener.onInput(buffer, len);\n                }\n            } catch (IOException e) {\n                if (!shutdown) {\n                    reportDeviceNotRooted();\n                }\n            }\n        }\n    }\n\n    public void start() {\n        handlerThread = new HandlerThread(\"SocketThread\");\n        handlerThread.start();\n        new Handler(handlerThread.getLooper()).post(new Runnable() {\n            @Override\n            public void run() {\n                new SocketThread().start();\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPSocketTest {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(5678)) {\n                System.out.println(\"Server started on port 5678\");\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"Client connected\");\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        System.out.println(\"Received: \" + inputLine);\n                        out.println(inputLine);\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                fail();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try (Socket socket = new Socket(\"localhost\", 5678);\n                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                out.println(\"Hello, server!\");\n                String response = in.readLine();\n                if (!response.equals(\"Hello, server!\")) {\n                    fail();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                fail();\n            }\n        }).start();\n    }\n\n    private static void fail() {\n        throw new RuntimeException(\"Test failed\");\n    }\n}\n```"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ConnectionManipulationProxyServer {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy;\n    private boolean running;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        proxyThread = new Thread(this::run);\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            running = true;\n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) {\n                        continue;\n                    }\n                }\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n                new Thread(() -> forward(client, server)).start();\n                new Thread(() -> forward(server, client)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    private void forward(Socket from, Socket to) {\n        try {\n            InputStream in = from.getInputStream();\n            OutputStream out = to.getOutputStream();\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) {\n        if (connection != null) {\n            close();\n        }\n        connection = openConnection(offset, 0);\n        try {\n            inputStream = connection.getInputStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (connection != null) {\n            connection.disconnect();\n        }\n    }\n\n    public int read(byte[] buffer) {\n        try {\n            return inputStream.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n\n    public String getMime() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMime();\n    }\n\n    public String getUrl() {\n        return sourceInfo.getUrl();\n    }\n\n    private void fetchContentInfo() {\n        sourceInfo = sourceInfoStorage.get(sourceInfo.getUrl());\n        if (sourceInfo == null) {\n            sourceInfo = new SourceInfo();\n            sourceInfo.setUrl(sourceInfo.getUrl());\n            sourceInfo.setLength(getContentLength(openConnection(0, 0)));\n            sourceInfo.setMime(connection.getContentType());\n            sourceInfoStorage.put(sourceInfo);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(sourceInfo.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            injectCustomHeaders(connection, sourceInfo.getUrl());\n            connection.connect();\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_PARTIAL) {\n                sourceInfo.setLength(readSourceAvailableBytes(connection, offset, connection.getResponseCode()));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        headerInjector.inject(connection, url);\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        long availableBytes = 0;\n        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n            String contentRange = connection.getHeaderField(\"Content-Range\");\n            if (contentRange != null) {\n                String[] range = contentRange.split(\"/\");\n                availableBytes = Long.parseLong(range[1]);\n            }\n        }\n        return availableBytes;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        long contentLength = 0;\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        if (contentLengthHeader != null) {\n            contentLength = Long.parseLong(contentLengthHeader);\n        }\n        return contentLength;\n    }\n}\n```"
  },
  {
    "Task_id": 557,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP proxy cache server using ServerSocket for handling client connections and requests.\n\nClass Description: The HttpProxyCacheServer class acts as a local proxy server that listens for incoming client connections, processes HTTP GET requests, and can respond to ping requests. It manages client connections using a thread pool for concurrent request handling.\n\nAttributes:\n- serverSocket: [ServerSocket] - The main server socket that listens for incoming client connections\n- port: [int] - The port number on which the server is listening\n- waitConnectionThread: [Thread] - Thread that waits for incoming client connections\n- socketProcessor: [ExecutorService] - Thread pool for processing client sockets concurrently\n- pinger: [Pinger] - Helper class for handling ping requests\n\nMethods:\n- HttpProxyCacheServer([Context context]) -> [void] - Constructor that initializes the server socket and starts the connection waiting thread\n- waitForRequest() -> [void] - Continuously accepts incoming client connections and submits them to the thread pool\n- processSocket([Socket socket]) -> [void] - Processes an individual client socket connection and handles the request\n- releaseSocket([Socket socket]) -> [void] - Properly closes and releases socket resources\n- WaitRequestsRunnable([CountDownLatch startSignal]) -> [void] - Runnable implementation that starts the connection waiting process\n- SocketProcessorRunnable([Socket socket]) -> [void] - Runnable implementation that processes an individual client socket",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Pinger pinger;\n\n    public HttpProxyCacheServer(Context context) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n            this.pinger = new Pinger(PROXY_HOST, port);\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            if (pinger.isPingRequest(url)) {\n                pinger.responseToPing(socket);\n            } else {\n                // Process client request\n            }\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (IOException e) {\n            // Handle error\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n    private static final String TAG = \"HttpProxyCacheServer\";\n    private static final int DEFAULT_PORT = 8080;\n    private static final int SOCKET_TIMEOUT = 10000;\n    private static final int THREAD_POOL_SIZE = 4;\n\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final ExecutorService socketProcessor;\n    private final Pinger pinger;\n\n    public HttpProxyCacheServer(Context context) throws IOException {\n        this(context, DEFAULT_PORT);\n    }\n\n    public HttpProxyCacheServer(Context context, int port) throws IOException {\n        this.port = port;\n        serverSocket = new ServerSocket(port);\n        socketProcessor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n        pinger = new Pinger(context);\n        waitConnectionThread = new Thread(new WaitRequestsRunnable(new CountDownLatch(1)));\n        waitConnectionThread.start();\n    }\n\n    public void waitForRequest() {\n        try {\n            waitConnectionThread.join();\n        } catch (InterruptedException e) {\n            Log.e(TAG, \"Error waiting for requests\", e);\n        }\n    }\n\n    public void processSocket(Socket socket) {\n        socketProcessor.submit(new SocketProcessorRunnable(socket));\n    }\n\n    public void releaseSocket(Socket socket) {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            Log.e(TAG, \"Error releasing socket\", e);\n        }\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            try {\n                startSignal.await();\n                while (!Thread.currentThread().isInterrupted()) {\n                    Socket socket = serverSocket.accept();\n                    socket.setSoTimeout(SOCKET_TIMEOUT);\n                    processSocket(socket);\n                }\n            } catch (IOException | InterruptedException e) {\n                Log.e(TAG, \"Error waiting for requests\", e);\n            }\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                // Process the socket\n            } catch (IOException e) {\n                Log.e(TAG, \"Error processing socket\", e);\n            } finally {\n                releaseSocket(socket);\n            }\n        }\n    }\n\n    private static class Pinger {\n        private final ConnectivityManager connectivityManager;\n\n        Pinger(Context context) {\n            connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        }\n\n        boolean isOnline() {\n            NetworkInfo activeNetwork = connectivityManager.getActiveNetworkInfo();\n            return activeNetwork != null && activeNetwork.isConnectedOrConnecting();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 559,
    "Instruction": "Task Description: Create a mock SMTP server implementation in Java that can simulate SMTP interactions, handle TLS upgrades, and manage client connections for testing purposes.\n\nClass Description: MockSmtpServer is a test utility class that simulates an SMTP server with support for plaintext and TLS connections. It maintains a queue of expected interactions and processes them sequentially when clients connect.\n\nAttributes:\n- interactions: Deque<SmtpInteraction> - A thread-safe queue of expected SMTP interactions (commands, responses, TLS upgrades)\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for client disconnection\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- keyStoreProvider: KeyStoreProvider - Provides SSL/TLS keystore information\n- logger: Logger - Logging interface for server activities\n- mockServerThread: MockServerThread - The server thread handling client connections\n- host: String - The server's host address\n- port: int - The server's listening port\n\nMethods:\n- start() -> void - Starts the server on a random available port and begins listening for connections\n- shutdown() -> void - Stops the server and closes all connections\n- MockServerThread(ServerSocket, Deque<SmtpInteraction>, CountDownLatch, CountDownLatch, Logger, KeyStoreProvider) -> void - Inner class constructor for the server thread\n- run() -> void - Main server thread execution handling client connections and SMTP protocol\n- readExpectedCommand(ExpectedCommand) -> void - Reads and verifies an expected command from the client\n- writeCannedResponse(CannedResponse) -> void - Writes a predefined response to the client\n- upgradeToTls(Socket) -> void - Upgrades the connection to TLS using the provided keystore\n- shouldStop() -> void - Signals the server thread to stop processing\n\nNested Classes/Interfaces:\n- SmtpInteraction: Interface - Marker interface for SMTP interaction types\n- ExpectedCommand: Class - Represents an expected SMTP command from the client\n- CannedResponse: Class - Represents a predefined server response\n- UpgradeToTls: Class - Marker for TLS upgrade interaction\n- Logger: Interface - Logging interface for server activities",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n        private BufferedSource input;\n        private BufferedSink output;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger,\n                KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = serverSocket.accept();\n                serverSocket.close();\n                clientSocket = socket;\n\n                input = Okio.buffer(Okio.source(socket));\n                output = Okio.buffer(Okio.sink(socket));\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.pop();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n\n                waitForAllExpectedCommands.countDown();\n                waitForConnectionClosed.countDown();\n            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | \n                    CertificateException | UnrecoverableKeyException | KeyManagementException e) {\n                if (!shouldStop) {\n                    logger.log(\"Exception: %s\", e);\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing socket: %s\", e);\n                }\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand) throws IOException {\n            String command = input.readUtf8Line();\n            logger.log(\"C: %s\", command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse) throws IOException {\n            String response = cannedResponse.getResponse();\n            logger.log(\"S: %s\", response);\n            output.writeUtf8(response);\n            output.writeUtf8(\"\\r\\n\");\n            output.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws KeyStoreException, IOException, NoSuchAlgorithmException,\n                CertificateException, UnrecoverableKeyException, KeyManagementException {\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyStoreProvider.getPassword());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n            SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(\n                    socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n\n            input = Okio.buffer(Okio.source(sslSocket.getInputStream()));\n            output = Okio.buffer(Okio.sink(sslSocket.getOutputStream()));\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(\"Error closing socket: %s\", e);\n            }\n        }\n    }\n\n    private interface SmtpInteraction {}\n    private static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n    }\n    private static class CannedResponse implements SmtpInteraction {\n        private final String response;\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n    }\n    private static class UpgradeToTls implements SmtpInteraction {}\n    public interface Logger {\n        void log(String format, Object... args);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManagerFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MockSmtpServer {\n\n    private final Deque<SmtpInteraction> interactions = new LinkedBlockingDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger = LoggerFactory.getLogger(MockSmtpServer.class);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider) {\n        this.keyStoreProvider = keyStoreProvider;\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0);\n        port = serverSocket.getLocalPort();\n        host = serverSocket.getInetAddress().getHostAddress();\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            waitForConnectionClosed.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private class MockServerThread extends Thread {\n\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger, KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = serverSocket.accept()) {\n                logger.info(\"Client connected\");\n                InputStream inputStream = socket.getInputStream();\n                OutputStream outputStream = socket.getOutputStream();\n                while (!shouldStop()) {\n                    SmtpInteraction interaction = interactions.poll();\n                    if (interaction == null) {\n                        break;\n                    }\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction, inputStream);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction, outputStream);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n                logger.info(\"Client disconnected\");\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                logger.error(\"Error in MockServerThread\", e);\n            } finally {\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand, InputStream inputStream) throws IOException {\n            byte[] buffer = new byte[1024];\n            int bytesRead = inputStream.read(buffer);\n            String command = new String(buffer, 0, bytesRead);\n            logger.info(\"Received command: {}\", command);\n            if (!command.equals(expectedCommand.getCommand())) {\n                throw new IOException(\"Unexpected command: \" + command);\n            }\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse, OutputStream outputStream) throws IOException {\n            outputStream.write(cannedResponse.getResponse().getBytes());\n            outputStream.flush();\n            logger.info(\"Sent response: {}\", cannedResponse.getResponse());\n        }\n\n        private void upgradeToTls(Socket socket) throws IOException {\n            try {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\"SunX509\");\n                keyManagerFactory.init(keyStoreProvider.getKeyStore(), keyStoreProvider.getKeyStorePassword().toCharArray());\n                trustManagerFactory.init(keyStoreProvider.getTrustStore());\n                sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n                SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(socket, host, port, true);\n                sslSocket.startHandshake();\n                socket = sslSocket;\n                logger.info(\"Upgraded to TLS\");\n            } catch (Exception e) {\n                throw new IOException(\"Error upgrading to TLS\", e);\n            }\n        }\n\n        private void shouldStop() {\n            // This method should be implemented to signal the server thread to stop processing\n        }\n    }\n\n    public interface SmtpInteraction {\n    }\n\n    public static class ExpectedCommand implements SmtpInteraction {\n\n        private final String command;\n\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n\n        public String getCommand() {\n            return command;\n        }\n    }\n\n    public static class CannedResponse implements SmtpInteraction {\n\n        private final String response;\n\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n\n        public String getResponse() {\n            return response;\n        }\n    }\n\n    public static class UpgradeToTls implements SmtpInteraction {\n    }\n\n    public interface Logger {\n\n        void info(String message);\n\n        void error(String message, Throwable throwable);\n    }\n\n    public interface KeyStoreProvider {\n\n        javax.net.ssl.KeyStore getKeyStore();\n\n        String getKeyStorePassword();\n\n        javax.net.ssl.KeyStore getTrustStore();\n    }\n}\n```"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.web.client.RestTemplate;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n\n        RestTemplate restTemplate = new RestTemplate();\n        MultiValueMap<String, Object> bodyMap = new LinkedMultiValueMap<>();\n        bodyMap.add(\"media\", new FileSystemResource(new File(mediaFileUrl)));\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(bodyMap, headers);\n        ResponseEntity<String> responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);\n\n        if (responseEntity.getStatusCode() == HttpStatus.OK) {\n            String responseBody = responseEntity.getBody();\n            JSONObject jsonObject = JSON.parseObject(responseBody);\n            return jsonObject.getString(\"media_id\");\n        } else {\n            throw new RuntimeException(\"Failed to upload media file to WeChat servers\");\n        }\n    }\n\n    private String judgeType(String contentType) {\n        switch (contentType) {\n            case \"image/jpeg\":\n                return \".jpg\";\n            case \"image/png\":\n                return \".png\";\n            case \"image/gif\":\n                return \".gif\";\n            case \"video/mp4\":\n                return \".mp4\";\n            default:\n                throw new RuntimeException(\"Unsupported file type\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocketFactory sslSocketFactory = clientSslContext.getSocketFactory();\n        SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(address.getAddress(), address.getPort());\n        sslSocket.startHandshake();\n\n        String request = \"GET / HTTP/1.1\\r\\nHost: \" + address.getHostName() + \"\\r\\n\\r\\n\";\n        sslSocket.getOutputStream().write(request.getBytes());\n\n        readResponse(sslSocket);\n\n        sslSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            } else if (c == '\\n') {\n                break;\n            }\n            line.append((char) c);\n        }\n        return line.toString();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream is = sslSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n\n        String line;\n        while ((line = readLine(is)).length() > 0) {\n            System.out.println(line);\n        }\n\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.security.SecureRandom;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = SSLContext.getInstance(\"TLS\").getSocketFactory();\n        mDelayedRestartHandler = new Handler(context.getMainLooper());\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        return connectSocket(host, port, null);\n    }\n\n    public static Socket connectSocket(String host, int port, Proxy proxy) throws IOException {\n        if (proxy == null) {\n            return connectSocketNoProxy(host, port);\n        } else {\n            return connectSocketViaHttpProxyConnectMethod(host, port, proxy.address());\n        }\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(proxyAddress), HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n        socket.getOutputStream().write((\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\").getBytes());\n        socket.getOutputStream().write((\"Host: \" + host + \":\" + port + \"\\r\\n\").getBytes());\n        socket.getOutputStream().write(\"\\r\\n\".getBytes());\n        socket.getOutputStream().flush();\n        int responseCode = readHttpResponseCode(socket.getInputStream());\n        if (responseCode != 200) {\n            throw new IOException(\"HTTP proxy returned response code \" + responseCode);\n        }\n        return socket;\n    }\n\n    private static int readHttpResponseCode(InputStream inputStream) throws IOException {\n        int responseCode = -1;\n        int b;\n        while ((b = inputStream.read()) != -1) {\n            if (b == '\\r') {\n                continue;\n            } else if (b == '\\n') {\n                break;\n            }\n            responseCode = responseCode * 10 + Character.getNumericValue(b);\n        }\n        return responseCode;\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        try {\n            socket.setEnabledProtocols(new String[]{\"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"});\n            socket.setEnabledCipherSuites(new String[]{\"TLS_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_RSA_WITH_AES_128_CBC_SHA\", \"TLS_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_RSA_WITH_AES_256_CBC_SHA\"});\n            socket.startHandshake();\n            socket.setUseClientMode(true);\n            socket.setNeedClientAuth(false);\n            socket.setWantClientAuth(false);\n            socket.setKeepAlive(true);\n            socket.setSoTimeout(TLS_HANDSHAKE_TIMEOUT_MILLIS);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true, 0);\n            socket.setTcpNoDelay(true);\n            socket.setReuseAddress(true);\n            socket.setReceiveBufferSize(8192);\n            socket.setSendBufferSize(8192);\n            socket.setTrafficClass(0x10);\n            socket.setKeepAlive(true);\n            socket.setSoLinger(true,"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.mail.*;\nimport javax.mail.internet.*;\nimport javax.activation.*;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progress, MainFrame mainFrame, FileSet fileSet, String mailServer, String fromAddress, String recipientString) {\n        this.mailServer = mailServer;\n        this.fromAddress = fromAddress;\n        this.recipientString = recipientString;\n        this.boundary = \"----=_NextPart_\" + System.currentTimeMillis();\n        this.errorDialogTitle = \"Error sending email\";\n        openConnection();\n        sendBody();\n        for (AbstractFile file : fileSet) {\n            sendAttachment(file);\n        }\n        closeConnection();\n    }\n\n    private void openConnection() {\n        try {\n            socket = new Socket(mailServer, 25);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = socket.getOutputStream();\n            out64 = new Base64OutputStream(out);\n            connectedToMailServer = true;\n            readWriteLine(\"HELO \" + InetAddress.getLocalHost().getHostName());\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Unable to connect to mail server\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n            connectedToMailServer = false;\n        }\n    }\n\n    private void sendBody() {\n        try {\n            writeLine(\"MAIL FROM: <\" + fromAddress + \">\");\n            List<String> recipients = new ArrayList<String>();\n            splitRecipientString(recipientString, recipients);\n            for (String recipient : recipients) {\n                writeLine(\"RCPT TO: <\" + recipient + \">\");\n            }\n            writeLine(\"DATA\");\n            writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n            writeLine(\"\");\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Type: text/plain; charset=\\\"us-ascii\\\"\");\n            writeLine(\"Content-Transfer-Encoding: 7bit\");\n            writeLine(\"\");\n            writeLine(mailBody);\n            writeLine(\"\");\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Unable to send email\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    private void sendAttachment(AbstractFile file) {\n        try {\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Type: application/octet-stream; name=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-Transfer-Encoding: base64\");\n            writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"\");\n            FileInputStream fis = new FileInputStream(file.getFile());\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out64.write(buffer, 0, bytesRead);\n            }\n            out64.flush();\n            fis.close();\n            writeLine(\"\");\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Unable to send attachment\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            writeLine(\".\");\n            writeLine(\"QUIT\");\n            in.close();\n            out.close();\n            socket.close();\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Unable to close connection\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    private void readWriteLine(String command) {\n        try {\n            writeLine(command);\n            String response = in.readLine();\n            if (response == null || !response.startsWith(\"250\")) {\n                JOptionPane.showMessageDialog(null, \"Error communicating with mail server\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n                connectedToMailServer = false;\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Error communicating with mail server\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n            connectedToMailServer = false;\n        }\n    }\n\n    private void writeLine(String line) {\n        try {\n            out.write((line + \"\\r\\n\").getBytes());\n            out.flush();\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, \"Error communicating with mail server\", errorDialogTitle, JOptionPane.ERROR_MESSAGE);\n            connectedToMailServer = false;\n        }\n    }\n\n    private void splitRecipientString(String recipientString, List<String> recipients) {\n        StringTokenizer tokenizer = new StringTokenizer(recipientString, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            recipients.add(tokenizer.nextToken().trim());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class ClientTest {\n\n    public static void main(String[] args) throws Exception {\n        final CountDownLatch latch = new CountDownLatch(2);\n        final Socket socket = new Socket(DefaultServer.HOST, DefaultServer.PORT);\n        final InputStream in = socket.getInputStream();\n        final OutputStream out = socket.getOutputStream();\n\n        socket.setSoTimeout(10000);\n\n        socket.setTcpNoDelay(true);\n\n        socket.setKeepAlive(true);\n\n        socket.setReuseAddress(true);\n\n        socket.setSoLinger(true, 0);\n\n        socket.setOOBInline(true);\n\n        socket.setTrafficClass(0x10);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, 1, 0);\n\n        socket.setSendBufferSize(8192);\n\n        socket.setReceiveBufferSize(8192);\n\n        socket.setPerformancePreferences(0, "
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\n@Test\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = null;\n    OutputStream os = null;\n    InputStream is = null;\n    try {\n        socket = new Socket(DefaultServer.getDefaultServerAddress());\n        os = socket.getOutputStream();\n        is = socket.getInputStream();\n\n        String malformedRequest = \"POST / HTTP/1.1\\r\\n\" +\n                \"Host: localhost\\r\\n\" +\n                \"Content-Length: 100\\r\\n\" +\n                \"\\r\\n\" +\n                \"This is a malformed request\";\n        os.write(malformedRequest.getBytes());\n        os.flush();\n\n        socket.shutdownOutput();\n        socket.shutdownInput();\n\n        assertTrue(completionListenerCalledLatch.await(5, TimeUnit.SECONDS));\n        assertTrue(completionListenerCalled);\n    } finally {\n        if (socket != null) {\n            socket.close();\n        }\n        if (os != null) {\n            os.close();\n        }\n        if (is != null) {\n            is.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 565,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP connection to a database server using socket programming, including authentication and basic query functionality.\n\nClass Description: The UrlConnection class provides functionality to connect to a database server, authenticate, execute queries, and manage the connection lifecycle. It handles MySQL protocol communication including handshake, authentication, and basic command execution.\n\nAttributes:\n- host: String - The hostname or IP address of the database server\n- port: int - The port number of the database server\n- user: String - The username for authentication\n- password: String - The password for authentication\n- database: String - The name of the database to connect to\n- socket: Socket - The TCP socket connection to the server\n- in: InputStream - Input stream for reading data from the server\n- out: OutputStream - Output stream for writing data to the server\n- charsetIndex: int - The character set index used for communication\n- isClosed: AtomicBoolean - Flag indicating whether the connection is closed\n\nMethods:\n- UrlConnection(String, int, String, String, String) -> void - Constructor that initializes connection parameters\n- connect(int) -> void - Establishes a connection to the server with specified timeout\n- getServerList() -> List<CobarNode> - Executes a query to retrieve server list information\n- close() -> void - Closes the connection and releases resources\n- getRowList(int) -> List<CobarNode> - Helper method to process query result rows\n- auth411(HandshakePacket) -> BinaryPacket - Handles MySQL 4.1 authentication protocol\n- auth323(byte, byte[]) -> void - Handles MySQL 3.23 authentication protocol\n- getClientFlags() -> long - Returns client capability flags for MySQL protocol",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n\n        BinaryPacket initPacket = new BinaryPacket();\n        initPacket.read(in);\n        HandshakePacket hsp = new HandshakePacket();\n        hsp.read(initPacket);\n\n        this.charsetIndex = hsp.serverCharsetIndex & 0xff;\n\n        BinaryPacket bin = null;\n        try {\n            bin = auth411(hsp);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        case EOFPacket.FIELD_COUNT:\n            auth323(bin.packetId, hsp.seed);\n            break;\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        CommandPacket cmd = new CommandPacket();\n        cmd.packetId = 0;\n        cmd.command = 3;\n        cmd.arg = \"SHOW COBAR_CLUSTER\".getBytes();\n        cmd.write(out);\n        out.flush();\n\n        int fieldCount = 0;\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case ErrorPacket.FIELD_COUNT: {\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        }\n        default:\n            ResultSetHeaderPacket rsh = new ResultSetHeaderPacket();\n            rsh.read(bin);\n            fieldCount = rsh.fieldCount;\n        }\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return getRowList(fieldCount);\n            }\n            default:\n                continue;\n            }\n        }\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                }\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        List<CobarNode> list = new LinkedList<CobarNode>();\n        BinaryPacket bin = null;\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return list;\n            }\n            default:\n                RowDataPacket row = new RowDataPacket(fieldCount);\n                row.read(bin);\n                String host = new String(row.fieldValues.get(0));\n                int weight = Integer.parseInt(new String(row.fieldValues.get(1)));\n                list.add(new CobarNode(host, weight));\n            }\n        }\n    }\n\n    private BinaryPacket auth411(HandshakePacket hsp) throws IOException, NoSuchAlgorithmException {\n        AuthPacket ap = new AuthPacket();\n        ap.packetId = 1;\n        ap.clientFlags = getClientFlags();\n        ap.maxPacketSize = 1024 * 1024 * 16;\n        ap.charsetIndex = charsetIndex;\n        ap.user = user;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            byte[] password = passwd.getBytes();\n            byte[] seed = hsp.seed;\n            byte[] restOfScramble = hsp.restOfScrambleBuff;\n            byte[] authSeed = new byte[seed.length + restOfScramble.length];\n            System.arraycopy(seed, 0, authSeed, 0, seed.length);\n            System.arraycopy(restOfScramble, 0, authSeed, seed.length, restOfScramble.length);\n            ap.password = SecurityUtil.scramble411(password, authSeed);\n        }\n        ap.database = database;\n        ap.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        Reply323Packet r323 = new Reply323Packet();\n        r323.packetId = ++packetId;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            r323.seed = SecurityUtil.scramble323(passwd, new String(seed)).getBytes();\n        }\n        r323.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    private static long getClientFlags() {\n        int flag = 0;\n        flag |= Capabilities.CLIENT_LONG_PASSWORD;\n        flag |= Capabilities.CLIENT_FOUND_ROWS;\n        flag |= Capabilities.CLIENT_LONG_FLAG;\n        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;\n        flag |= Capabilities.CLIENT_ODBC;\n        flag |= Capabilities.CLIENT_IGNORE_SPACE;\n        flag |= Capabilities.CLIENT_PROTOCOL_41;\n        flag |= Capabilities.CLIENT_INTERACTIVE;\n        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;\n        flag |= Capabilities.CLIENT_TRANSACTIONS;\n        flag |= Capabilities.CLIENT_SECURE_CONNECTION;\n        return flag;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws IOException {\n        socket = new Socket(host, port);\n        socket.setSoTimeout(timeout);\n        in = socket.getInputStream();\n        out = socket.getOutputStream();\n        handshake();\n        auth();\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        // Execute query to retrieve server list information\n        return null;\n    }\n\n    public void close() throws IOException {\n        if (isClosed.compareAndSet(false, true)) {\n            in.close();\n            out.close();\n            socket.close();\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        // Helper method to process query result rows\n        return null;\n    }\n\n    private BinaryPacket auth411(HandshakePacket handshake) throws IOException {\n        // Handles MySQL 4.1 authentication protocol\n        return null;\n    }\n\n    private void auth323(byte[] seed, byte[] password) throws IOException {\n        // Handles MySQL 3.23 authentication protocol\n    }\n\n    private long getClientFlags() {\n        // Returns client capability flags for MySQL protocol\n        return 0;\n    }\n\n    private void handshake() throws IOException {\n        // Establishes a connection to the server with specified timeout\n    }\n\n    private void auth() throws IOException {\n        // Authenticates with the server\n    }\n}\n```"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class IRCClientConnection implements Closeable {\n    private static final String TAG = \"IRCClientConnection\";\n    private static final int MSG_NETWORK_EVENT = 1;\n\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n    private final Handler mHandler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(Message msg) {\n            if (msg.what == MSG_NETWORK_EVENT) {\n                mReporter.onNetworkEvent((String) msg.obj);\n            }\n        }\n    };\n\n    private IRCClientConnection(Socket socket, StethoReporter reporter) throws IOException {\n        mSocket = socket;\n        mReporter = reporter;\n        mInput = new BufferedReader(new InputStreamReader(mSocket.getInputStream()));\n        mOutput = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));\n    }\n\n    public static IRCClientConnection connect(String host, int port, StethoReporter reporter) throws IOException {\n        Socket socket = new Socket(host, port);\n        return new IRCClientConnection(socket, reporter);\n    }\n\n    public void send(String message) {\n        try {\n            mOutput.write(message);\n            mOutput.newLine();\n            mOutput.flush();\n            mHandler.obtainMessage(MSG_NETWORK_EVENT, \"SENT: \" + message).sendToTarget();\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to send message\", e);\n        }\n    }\n\n    public String read() throws IOException {\n        String message = mInput.readLine();\n        if (message != null) {\n            mHandler.obtainMessage(MSG_NETWORK_EVENT, \"RECEIVED: \" + message).sendToTarget();\n            if (message.startsWith(\"PING\")) {\n                send(\"PONG \" + message.substring(5));\n            }\n        }\n        return message;\n    }\n\n    @Override\n    public void close() throws IOException {\n        mExecutor.shutdownNow();\n        mInput.close();\n        mOutput.close();\n        mSocket.close();\n    }\n\n    public interface StethoReporter {\n        void onNetworkEvent(String event);\n    }\n\n    public static class StethoReporterImpl implements StethoReporter {\n        @Override\n        public void onNetworkEvent(String event) {\n            Log.d(\"StethoReporter\", event);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 570,
    "Instruction": "Task Description: Implement a POP3 client connection class in Java that handles socket communication with a POP3 server, including connection establishment, data transmission, and resource cleanup.\n\nClass Description: The Pop3Connection class provides functionality to connect to a POP3 server using TCP sockets, send and receive data through input/output streams, and manage the connection lifecycle.\n\nAttributes:\n- socket: Socket - The TCP socket used for communication with the server\n- in: BufferedInputStream - Input stream for reading data from the server\n- out: BufferedOutputStream - Output stream for writing data to the server\n\nMethods:\n- connect() -> Socket - Establishes a connection to the POP3 server by trying all available IP addresses for the host\n- connectToAddress(InetAddress address) -> Socket - Creates and connects a socket to a specific server address\n- open() -> void - Opens the connection by initializing socket and streams, throws MessagingException on failure\n- isOpen() -> boolean - Checks if the connection is currently active and valid\n- close() -> void - Closes all connection resources (socket and streams)\n- writeLine(String s) -> void - Writes a line of text to the server (appends CRLF)\n- readLine() -> String - Reads a line of text from the server (handles CRLF line endings)",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nclass Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    private Socket connect() throws IOException, UnknownHostException {\n        InetAddress[] inetAddresses = InetAddress.getAllByName(settings.getHost());\n        IOException connectException = null;\n        for (InetAddress address : inetAddresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                connectException = e;\n            }\n        }\n        throw connectException != null ? connectException : new UnknownHostException();\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        InetSocketAddress socketAddress = new InetSocketAddress(address, settings.getPort());\n        final Socket socket = new Socket();\n        socket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);\n        return socket;\n    }\n\n    void open() throws MessagingException {\n        try {\n            socket = connect();\n            in = new BufferedInputStream(socket.getInputStream(), 1024);\n            out = new BufferedOutputStream(socket.getOutputStream(), 512);\n            socket.setSoTimeout(SOCKET_READ_TIMEOUT);\n            if (!isOpen()) {\n                throw new MessagingException(\"Unable to connect socket\");\n            }\n        } catch (IOException ioe) {\n            close();\n            throw new MessagingException(\"Unable to open connection to POP server.\", ioe);\n        }\n    }\n\n    boolean isOpen() {\n        return (in != null && out != null && socket != null\n                && socket.isConnected() && !socket.isClosed());\n    }\n\n    void close() {\n        try {\n            in.close();\n        } catch (Exception e) {}\n        try {\n            out.close();\n        } catch (Exception e) {}\n        try {\n            socket.close();\n        } catch (Exception e) {}\n        in = null;\n        out = null;\n        socket = null;\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write(s.getBytes());\n        out.write('\\r');\n        out.write('\\n');\n        out.flush();\n    }\n\n    String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int d = in.read();\n        if (d == -1) {\n            throw new IOException(\"End of stream reached while trying to read line.\");\n        }\n        do {\n            if (((char)d) == '\\r') {\n                continue;\n            } else if (((char)d) == '\\n') {\n                break;\n            } else {\n                sb.append((char)d);\n            }\n        } while ((d = in.read()) != -1);\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    public Socket connect() throws MessagingException {\n        InetAddress[] addresses = InetAddress.getAllByName(\"pop.example.com\");\n        for (InetAddress address : addresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                // Try next address\n            }\n        }\n        throw new MessagingException(\"Unable to connect to server\");\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        socket = new Socket(address, 110);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n        return socket;\n    }\n\n    public void open() throws MessagingException {\n        try {\n            connect();\n        } catch (IOException e) {\n            throw new MessagingException(\"Unable to connect to server\", e);\n        }\n    }\n\n    public boolean isOpen() {\n        return socket != null && socket.isConnected() && !socket.isClosed();\n    }\n\n    public void close() {\n        if (out != null) {\n            try {\n                out.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    public void writeLine(String s) throws IOException {\n        out.write(s.getBytes());\n        out.write(\"\\r\\n\".getBytes());\n        out.flush();\n    }\n\n    public String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            } else if (c == '\\n') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 571,
    "Instruction": "Task Description: Create a TCP client class that establishes a connection to a server, sends requests, receives responses, and manages the connection lifecycle.\n\nClass Description: TcpRequester is a TCP client implementation that handles communication with a server using sockets. It provides methods to start/stop the connection, send requests, and fetch responses. The class manages socket resources and includes error handling for network operations.\n\nAttributes:\n- sock: Socket - The socket instance used for TCP communication  \n- in: InputStream - Input stream for reading server responses  \n- out: OutputStream - Output stream for sending requests to the server  \n- dest: SocketAddress - The server address to connect to  \n- request: String - The initial request string  \n- passcode: String - Authentication passcode  \n- on_rsp: Consumer<ByteArray> - Callback for handling responses  \n\nMethods:\n- start(InetAddress bind_addr, long timeout, int ttl) -> T - Establishes a socket connection to the server with specified timeout and TTL  \n- stop() -> T - Closes the socket and releases all resources  \n- isRunning() -> boolean - Checks if the connection is active  \n- sendRequest(byte[] request) -> T - Sends a byte array request to the server  \n- fetchResponse() -> ByteArray - Reads and returns the server response as a ByteArray",
    "Canonical_solution": "import org.jgroups.util.ByteArray;\nimport org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nprotected class TcpRequester extends Requester {\n    protected Socket       sock;\n    protected InputStream  in;\n    protected OutputStream out;\n\n    protected TcpRequester(SocketAddress dest, String request, String passcode,\n                           Consumer<ByteArray> on_rsp) {\n        super(dest, request, passcode, on_rsp);\n    }\n\n    protected <T extends Requester> T start(InetAddress bind_addr, long timeout, int ttl) throws IOException {\n        sock=new Socket();\n        sock.setSoTimeout((int)timeout);\n        sock.bind(new InetSocketAddress(bind_addr, 0));\n        sock.connect(dest);\n        in=sock.getInputStream();\n        out=sock.getOutputStream();\n        return (T)this;\n    }\n\n    protected <T extends Requester> T stop() {\n        Util.close(sock,in,out);\n        return (T)this;\n    }\n\n    protected boolean isRunning() {\n        return sock != null && !sock.isClosed();\n    }\n\n    protected <T extends Requester> T sendRequest(byte[] request) throws IOException {\n        out.write(request);\n        out.write('\\n');\n        return (T)this;\n    }\n\n    protected ByteArray fetchResponse() {\n        byte[] buf=new byte[1024];\n        int    index=0;\n\n        for(;;) {\n            try {\n                int bytes_read=in.read(buf, index, buf.length - index);\n                if(bytes_read == -1) {\n                    if(index > 0)\n                        break;\n                    return null;\n                }\n                index+=bytes_read;\n                if(index >= buf.length) {\n                    byte[] tmp=new byte[buf.length + 1024];\n                    System.arraycopy(buf, 0, tmp, 0, index);\n                    buf=tmp;\n                }\n            }\n            catch(IOException e) {\n                break;\n            }\n        }\n        return new ByteArray(buf, 0, index);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.function.Consumer;\n\npublic class TcpRequester {\n    private Socket sock;\n    private InputStream in;\n    private OutputStream out;\n    private SocketAddress dest;\n    private String request;\n    private String passcode;\n    private Consumer<ByteArray> on_rsp;\n\n    public <T> T start(InetAddress bind_addr, long timeout, int ttl) {\n        // Implementation code here\n    }\n\n    public <T> T stop() {\n        // Implementation code here\n    }\n\n    public boolean isRunning() {\n        // Implementation code here\n    }\n\n    public <T> T sendRequest(byte[] request) {\n        // Implementation code here\n    }\n\n    public ByteArray fetchResponse() {\n        // Implementation code here\n    }\n}\n```"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\npublic long sendToServer(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n    Socket socket = new Socket(uri.getHost(), uri.getPort());\n    OutputStream outputStream = socket.getOutputStream();\n    long bytes = 0;\n    parser.start();\n    try {\n        byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, len);\n            bytes += len;\n        }\n        outputStream.flush();\n    } finally {\n        parser.stop();\n        outputStream.close();\n        inputStream.close();\n        socket.close();\n    }\n    assert socket.isConnected();\n    assert bytes > 0;\n    assert bytes == parser.getProgress();\n    return bytes;\n}\n```"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            destination.write(buffer, 0, bytesRead);\n            if (buffer[bytesRead - 1] == 0x04) {\n                break;\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Ignore any exceptions during closure\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.List;\nimport com.netflix.discovery.EurekaClient;\nimport com.netflix.discovery.shared.Application;\n\npublic class EurekaClientTCPClient {\n\n    public static void main(String[] args) {\n        EurekaClient eurekaClient = new EurekaClient();\n        String vipAddress = \"sampleservice.mydomain.net\";\n        tcpClient(eurekaClient, vipAddress);\n    }\n\n    public static void tcpClient(EurekaClient eurekaClient, String vipAddress) {\n        Application application = eurekaClient.getApplication(vipAddress);\n        if (application == null) {\n            System.err.println(\"Service not found in Eureka registry\");\n            return;\n        }\n\n        List<InstanceInfo> instances = application.getInstances();\n        if (instances.isEmpty()) {\n            System.err.println(\"No instances available for the service\");\n            return;\n        }\n\n        InstanceInfo instanceInfo = instances.get(0);\n        String hostName = instanceInfo.getHostName();\n        int port = instanceInfo.getPort();\n\n        try (Socket socket = new Socket(hostName, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            String request = \"GET / HTTP/1.1\\r\\nHost: \" + hostName + \"\\r\\n\\r\\n\";\n            out.println(request);\n\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(response);\n            }\n\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + hostName);\n        } catch (IOException e) {\n            System.err.println(\"IO error: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        try (Socket client = new Socket(host, port)) {\n            OutputStream out = client.getOutputStream();\n            out.write(command.getBytes());\n            out.flush();\n            return response(client);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private String response(Socket client) {\n        try {\n            InputStream in = client.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = in.read(buffer);\n            return new String(buffer, 0, len);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private void cleanup(Closeable c) {\n        try {\n            if (c != null) {\n                c.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport com.android.ddmlib.IDevice;\nimport com.android.ddmlib.Log;\nimport com.android.tradefed.device.DeviceNotAvailableException;\nimport com.android.tradefed.device.ITestDevice;\nimport com.android.tradefed.util.CommandResult;\nimport com.android.tradefed.util.CommandStatus;\nimport com.android.tradefed.util.RunUtil;\nimport com.android.tradefed.util.StreamUtil;\nimport com.android.tradefed.util.ZipUtil;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.logging.Logger;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private static final String TAG = \"ScrcpyInputSocketThread\";\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024;\n    private static final int READ_BUFFER_SIZE = 5 * 1024;\n\n    private final Logger log = Logger.getLogger(TAG);\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n\n    private final AtomicBoolean isRunning = new AtomicBoolean(false);\n    private final AtomicBoolean isTerminated = new AtomicBoolean(false);\n    private final AtomicInteger port = new AtomicInteger(0);\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue,\n                                   ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.androidTestTaskBootThread = new AndroidTestTaskBootThread();\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        try {\n            isRunning.set(true);\n            setupPortForwarding();\n            Socket socket = new Socket(\"localhost\", port.get());\n            OutputStream outputStream = socket.getOutputStream();\n            InputStream inputStream = socket.getInputStream();\n            sendDeviceScreenDimensions();\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int bytesRead;\n            while (isRunning.get()) {\n                bytesRead = inputStream.read(buffer);\n                if (bytesRead == -1) {\n                    break;\n                }\n                processData(buffer, bytesRead);\n            }\n        } catch (IOException e) {\n            log.warning(\"IOException: \" + e.getMessage());\n        } finally {\n            cleanup();\n        }\n    }\n\n    private void setupPortForwarding() {\n        try {\n            port.set(iDevice.createForward(\"tcp:0\", \"tcp:27183\"));\n        } catch (DeviceNotAvailableException e) {\n            log.warning(\"Device not available: \" + e.getMessage());\n        }\n    }\n\n    private void sendDeviceScreenDimensions() {\n        try {\n            int width = iDevice.getDisplayWidth();\n            int height = iDevice.getDisplayHeight();\n            session.send(\"{\" +\n                    \"\\\"width\\\":\" + width + \",\" +\n                    \"\\\"height\\\":\" + height +\n                    \"}\");\n        } catch (IOException e) {\n            log.warning(\"IOException: \" + e.getMessage());\n        }\n    }\n\n    private void processData(byte[] buffer, int bytesRead) {\n        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer, 0, bytesRead);\n        while (byteBuffer.hasRemaining()) {\n            if (byteBuffer.get() == 0x00 && byteBuffer.get() == 0x00 && byteBuffer.get() == 0x00 && byteBuffer.get() == 0x01) {\n                int nalType = byteBuffer.get() & 0x1F;\n                if (nalType == 0x07 || nalType == 0x08) {\n                    int nalSize = byteBuffer.getInt();\n                    byte[] nalData = new byte[nalSize];\n                    byteBuffer.get(nalData);\n                    try {\n                        dataQueue.put(nalData);\n                    } catch (InterruptedException e) {\n                        log.warning(\"InterruptedException: \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private void cleanup() {\n        isRunning.set(false);\n        isTerminated.set(true);\n        try {\n            iDevice.removeForward(port.get());\n        } catch (DeviceNotAvailableException e) {\n            log.warning(\"Device not available: \" + e.getMessage());\n        }\n        session.close();\n        scrcpyLocalThread.interrupt();\n        androidTestTaskBootThread.interrupt();\n    }\n}\n```"
  },
  {
    "Task_id": 577,
    "Instruction": "Task Description: Implement a MySQL client channel class in Java that handles TCP socket communication with a MySQL server, including connection management, query execution, and packet handling.\n\nClass Description: MySQLChannel is a final class that provides a TCP-based communication channel to interact with a MySQL server. It manages socket connections, executes SQL queries, and handles MySQL protocol packets. The class includes connection configuration, buffer management, and proper resource cleanup.\n\nAttributes:\n- dsc: [DataSourceConfig] - Configuration object containing host, port and other connection parameters\n- socket: [Socket] - TCP socket connection to the MySQL server\n- in: [InputStream] - Buffered input stream for reading server responses\n- out: [OutputStream] - Buffered output stream for sending commands to server\n- isClosed: [AtomicBoolean] - Thread-safe flag indicating whether the channel is closed\n\nMethods:\n- connect(long timeout) -> [void] - Establishes a TCP connection to the MySQL server with specified timeout and configures socket parameters\n- execute(String statement) -> [BinaryPacket] - Executes a SQL query statement and returns the server response as a binary packet\n- receive() -> [BinaryPacket] - Reads and returns a binary packet from the server\n- close() -> [void] - Closes the connection by sending a QUIT command and releasing resources\n- BinaryPacket: [static class] - Represents a MySQL binary packet with data and packet ID\n- CommandPacket: [static class] - Represents a MySQL command packet with packet ID, command type, and arguments\n- MySQLPacket: [static class] - Contains MySQL protocol constants\n- QuitPacket: [static class] - Contains the QUIT command packet data",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setTrafficClass(0x04 | 0x10);\n        socket.setPerformancePreferences(0, 2, 1);\n        socket.setReceiveBufferSize(16 * 1024);\n        socket.setSendBufferSize(8 * 1024);\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), 10 * 1000);\n\n        in = new BufferedInputStream(socket.getInputStream(), 16 * 1024);\n        out = new BufferedOutputStream(socket.getOutputStream(), 8 * 1024);\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.packetId = 0;\n        packet.command = MySQLPacket.COM_QUERY;\n        packet.arg = statement.getBytes();\n\n        packet.write(out);\n        out.flush();\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n                // Log error if needed\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    // Log error if needed\n                }\n            }\n        }\n    }\n\n    private static class BinaryPacket {\n        public byte[] data;\n        public int packetId;\n\n        public void read(InputStream in) throws IOException {\n            // Implementation of packet reading\n        }\n    }\n\n    private static class CommandPacket {\n        public int packetId;\n        public byte command;\n        public byte[] arg;\n\n        public void write(OutputStream out) throws IOException {\n            // Implementation of packet writing\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 0x03;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] QUIT = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01};\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n    }\n\n    public void connect(long timeout) throws IOException {\n        socket = new Socket(dsc.getHost(), dsc.getPort());\n        socket.setSoTimeout((int) timeout);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.setPacketId(0);\n        packet.setCommand(MySQLPacket.COM_QUERY);\n        packet.setArguments(statement);\n        send(packet);\n        return receive();\n    }\n\n    private BinaryPacket receive() throws IOException {\n        int packetId = readInt();\n        int length = readInt();\n        int sequenceId = readInt();\n        byte[] data = new byte[length - 4];\n        in.read(data);\n        return new BinaryPacket(packetId, data);\n    }\n\n    private void send(CommandPacket packet) throws IOException {\n        byte[] data = packet.toByteArray();\n        out.write(data);\n        out.flush();\n    }\n\n    public void close() throws IOException {\n        if (isClosed.compareAndSet(false, true)) {\n            QuitPacket packet = new QuitPacket();\n            send(packet);\n            socket.close();\n        }\n    }\n\n    private int readInt() throws IOException {\n        int ch1 = in.read();\n        int ch2 = in.read();\n        int ch3 = in.read();\n        int ch4 = in.read();\n        return ((ch1 & 0xff) << 24) | ((ch2 & 0xff) << 16) | ((ch3 & 0xff) << 8) | (ch4 & 0xff);\n    }\n\n    private static class BinaryPacket {\n        private final int packetId;\n        private final byte[] data;\n\n        public BinaryPacket(int packetId, byte[] data) {\n            this.packetId = packetId;\n            this.data = data;\n        }\n\n        public int getPacketId() {\n            return packetId;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n    }\n\n    private static class CommandPacket {\n        private int packetId;\n        private byte command;\n        private byte[] arguments;\n\n        public void setPacketId(int packetId) {\n            this.packetId = packetId;\n        }\n\n        public void setCommand(byte command) {\n            this.command = command;\n        }\n\n        public void setArguments(String arguments) {\n            this.arguments = arguments.getBytes();\n        }\n\n        public byte[] toByteArray() {\n            byte[] packet = new byte[4 + arguments.length];\n            packet[0] = (byte) (packetId >> 24);\n            packet[1] = (byte) (packetId >> 16);\n            packet[2] = (byte) (packetId >> 8);\n            packet[3] = (byte) packetId;\n            System.arraycopy(arguments, 0, packet, 4, arguments.length);\n            return packet;\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 3;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] DATA = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00};\n\n        public byte[] toByteArray() {\n            return DATA;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        OutputStream out = postSocket.getOutputStream();\n        PrintWriter writer = new PrintWriter(out, true);\n        writer.println(formatRequest(host, isKeepAlive));\n        InputStream in = postSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        return parseResponse(reader);\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}\n```"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n            String response;\n            while ((response = mBufferedReader.readLine()) != null) {\n                System.out.println(\"Server: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        mPrintWriter.println(msg);\n    }\n\n    public void closeConnection() {\n        try {\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n            if (mClientSocket != null) {\n                mClientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n    private static Networker sInstance;\n    private static Executor sExecutor = Executors.newCachedThreadPool();\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker() {\n    }\n\n    public static Networker get() {\n        if (sInstance == null) {\n            sInstance = new Networker();\n        }\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private HttpRequest request;\n        private Callback callback;\n\n        public HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            HttpResponse response = doFetch();\n            if (response != null) {\n                callback.onResponse(response);\n            }\n        }\n\n        private HttpResponse doFetch() {\n            HttpURLConnection conn = null;\n            try {\n                conn = configureAndConnectRequest();\n                InputStream in = conn.getInputStream();\n                in = applyDecompressionIfApplicable(conn, in);\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                copy(in, out, new byte[1024]);\n                return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n            } catch (IOException e) {\n                callback.onFailure(e);\n                return null;\n            } finally {\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            }\n        }\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            URL url = new URL(request.getUrl());\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(request.getMethod().toString());\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n            if (request.getBody() != null) {\n                conn.setDoOutput(true);\n                OutputStream out = conn.getOutputStream();\n                out.write(request.getBody());\n                out.close();\n            }\n            return conn;\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            if (\"gzip\".equalsIgnoreCase(conn.getContentEncoding())) {\n                in = new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n        }\n    }\n\n    public static class HttpRequest {\n        private String friendlyName;\n        private HttpMethod method;\n        private String url;\n        private byte[] body;\n\n        public HttpRequest(Builder b) {\n            this.friendlyName = b.friendlyName;\n            this.method = b.method;\n            this.url = b.url;\n            this.body = b.body;\n        }\n\n        public String getFriendlyName() {\n            return friendlyName;\n        }\n\n        public HttpMethod getMethod() {\n            return method;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n\n        public static class Builder {\n            private String friendlyName;\n            private HttpMethod method;\n            private String url;\n            private byte[] body;\n\n            public Builder() {\n            }\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private int statusCode;\n        private byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n\n        void onFailure(IOException e);\n    }\n\n    public enum HttpMethod {\n        GET,\n        POST,\n        PUT,\n        DELETE\n    }\n}\n```"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.List;\n\npublic class TcpClient {\n    public void showText(String ip, int port, List<String> contents) {\n        try {\n            Socket socket = new Socket(ip, port);\n            socket.setSoTimeout(5000);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            PrintWriter writer = new PrintWriter(out, true);\n            byte[] seq = new byte[1024];\n            out.write(seq);\n            String response = reader.readLine();\n            BxResp bxResp = new BxResp(response);\n            System.out.println(bxResp);\n        } catch (SocketTimeoutException e) {\n            System.out.println(\"Connection timed out\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        try {\n            srv_sock = new ServerSocket();\n            srv_sock.bind(local);\n            sock = new Socket();\n            sock.connect(remote);\n            output = new DataOutputStream(sock.getOutputStream());\n            acceptor = new Acceptor();\n            acceptor.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        try {\n            ByteArrayInputStream bis = new ByteArrayInputStream(buf, offset, length);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            return (Message) ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handleRequest(DataInputStream in) {\n            try {\n                byte[] buf = new byte[1024];\n                int len = in.read(buf);\n                Message msg = readMessage(buf, 0, len);\n                receive(msg);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 582,
    "Instruction": "Task Description: Create a TCP client class that establishes and maintains a persistent connection to a server, handles communication, and automatically reconnects on failure.\n\nClass Description: The `tcpConnection` class is an AsyncTask implementation that manages TCP socket communication in Android. It establishes a persistent connection to a specified server, handles bidirectional communication, and implements automatic reconnection logic when the connection is lost.\n\nAttributes:\n- activity: [Activity] - Reference to the calling Android activity for UI thread operations  \n- context: [Context] - Android context for system operations  \n- TAG: [String] - Logging tag identifier  \n- out: [OutputStream] - Static output stream for sending data to the server  \n\nMethods:\n- tcpConnection([Activity activity], [Context context]) -> [void] - Constructor that initializes the activity and context references  \n- doInBackground([String... strings]) -> [Void] - AsyncTask method that handles the socket connection and communication in the background  \n  - strings[0]: Server IP address  \n  - strings[1]: Server port number  \n  - Returns: null (Void)  \n  - Description:  \n    1. Continuously attempts to establish socket connection with timeout  \n    2. Sets up input/output streams upon successful connection  \n    3. Sends device information as initial message  \n    4. Listens for incoming commands in a loop  \n    5. Handles reconnection automatically on failures  \n    6. Closes connection on \"exit\" command",
    "Canonical_solution": "import android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\n\npublic class tcpConnection extends AsyncTask<String,Void,Void> {\n\n    private Activity activity;\n    private Context context;\n    private static String TAG = \"tcpConnectionClass\";\n    public static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        Socket socket = null;\n        try {\n            while(true){\n                Log.d(TAG,\"trying\");\n                socket = new Socket();\n                try{\n                    socket.connect(new InetSocketAddress(strings[0], Integer.parseInt(strings[1])),3000);\n                }catch (SocketTimeoutException | SocketException e){\n                    Log.d(TAG,\"error\");\n                    activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n                }\n                if(socket.isConnected()){\n                    Log.d(TAG,\"done\");\n                    break;\n                }\n            }\n            out = new DataOutputStream(socket.getOutputStream());\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String model = android.os.Build.MODEL+\"\\n\";\n            String welcomeMess = \"Hello there, welcome to reverse shell of \"+model;\n            out.write(welcomeMess.getBytes(\"UTF-8\"));\n            \n            String line;\n            while ((line = in.readLine()) != null) {\n                Log.d(TAG, line);\n                if (line.equals(\"exit\")) {\n                    socket.close();\n                    return null;\n                }\n                out.write(\"Unknown Command \\n\".getBytes(\"UTF-8\"));\n            }\n        } catch (Exception e) {\n            activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class tcpConnection extends AsyncTask<String, Void, Void> {\n\n    private Activity activity;\n    private Context context;\n    private static final String TAG = \"tcpConnection\";\n    private static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        String serverIP = strings[0];\n        int serverPort = Integer.parseInt(strings[1]);\n\n        while (!isCancelled()) {\n            try {\n                InetAddress serverAddr = InetAddress.getByName(serverIP);\n                Socket socket = new Socket(serverAddr, serverPort);\n                Log.d(TAG, \"Connected to server\");\n\n                out = new DataOutputStream(socket.getOutputStream());\n                DataInputStream in = new DataInputStream(socket.getInputStream());\n\n                // Send device information as initial message\n                String deviceInfo = \"Device Info: Android\";\n                out.writeBytes(deviceInfo + \"\\n\");\n\n                // Listen for incoming commands\n                while (!isCancelled()) {\n                    String command = in.readLine();\n                    if (command != null) {\n                        Log.d(TAG, \"Received command: \" + command);\n                        // Handle command here\n                    }\n                }\n\n                // Close connection\n                socket.close();\n                Log.d(TAG, \"Connection closed\");\n\n            } catch (UnknownHostException e) {\n                Log.e(TAG, \"UnknownHostException: \" + e.getMessage());\n            } catch (IOException e) {\n                Log.e(TAG, \"IOException: \" + e.getMessage());\n            }\n        }\n\n        return null;\n    }\n\n    public static void send(String message) {\n        if (out != null) {\n            try {\n                out.writeBytes(message + \"\\n\");\n            } catch (IOException e) {\n                Log.e(TAG, \"IOException: \" + e.getMessage());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class QmpClient {\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{\\\"execute\\\": \\\"qmp_capabilities\\\"}\";\n    private boolean external;\n\n    public void setExternal(boolean value) {\n        external = value;\n    }\n\n    public String sendCommand(String command) {\n        try {\n            Socket socket = null;\n            PrintWriter out = null;\n            BufferedReader in = null;\n            try {\n                if (external) {\n                    socket = new Socket(\"localhost\", 1234);\n                } else {\n                    socket = new Socket(Files.readAllLines(Paths.get(\"/path/to/socket\")).get(0), 1234);\n                }\n                out = new PrintWriter(socket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));\n                sendRequest(out, command);\n                return getResponse(in);\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n                if (socket != null) {\n                    socket.close();\n                }\n            }\n        } catch (SocketException e) {\n            Log.e(TAG, \"SocketException: \" + e.getMessage());\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    private String tryGetResponse(BufferedReader in) {\n        try {\n            return getResponse(in);\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) throws IOException {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        sock = new Socket();\n        output = new DataOutputStream(sock.getOutputStream());\n        output_lock = new ReentrantLock();\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(msg);\n        oos.flush();\n        byte[] data = baos.toByteArray();\n        out.writeInt(data.length);\n        out.write(data);\n    }\n\n    public static Message readMessage(DataInput in) throws Exception {\n        int len = in.readInt();\n        byte[] data = new byte[len];\n        in.readFully(data);\n        ByteArrayInputStream bais = new ByteArrayInputStream(data);\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Message) ois.readObject();\n    }\n\n    public void receive(Message msg) {\n        if (msg.getType() == MessageType.START) {\n            // handle start message\n        } else if (msg.getType() == MessageType.DATA) {\n            // handle data message\n        }\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        return createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(localHost, localPort));\n        socket.connect(new InetSocketAddress(host, port), 0);\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = new Socket();\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n        socket.connect(new InetSocketAddress(address, port), 0);\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Socket socket = new Socket();\n        connectToProxy(socket);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        if (proxyType == Proxy.Type.HTTP) {\n            String authStr = getBasicAuthStr();\n            String request = \"CONNECT \" + socket.getInetAddress().getHostAddress() + \":\" + socket.getPort() + \" HTTP/1.1\\r\\n\" +\n                    \"Host: \" + socket.getInetAddress().getHostAddress() + \":\" + socket.getPort() + \"\\r\\n\" +\n                    (authStr != null ? \"Proxy-Authorization: Basic \" + authStr + \"\\r\\n\" : \"\") +\n                    \"Proxy-Connection: Keep-Alive\\r\\n\" +\n                    \"\\r\\n\";\n            OutputStream out = socket.getOutputStream();\n            out.write(request.getBytes());\n            out.flush();\n            InputStream in = socket.getInputStream();\n            String response = readLine(in);\n            int responseCode = getResponseCode(response);\n            if (responseCode != 200) {\n                throw new IOException(\"Proxy connection failed: \" + response);\n            }\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyPass != null) {\n            String auth = proxyUser + \":\" + proxyPass;\n            return Base64.getEncoder().encodeToString(auth.getBytes());\n        }\n        return null;\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder line = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            } else if (c == '\\n') {\n                break;\n            }\n            line.append((char) c);\n        }\n        return line.toString();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        if (statusLine != null && statusLine.startsWith(\"HTTP/\")) {\n            int spaceIndex = statusLine.indexOf(' ');\n            if (spaceIndex != -1) {\n                return Integer.parseInt(statusLine.substring(spaceIndex + 1, spaceIndex + 4));\n            }\n        }\n        return -1;\n    }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class UrlTemplateResource {\n    private URL url;\n    private String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) {\n        try {\n            this.url = new URL(path);\n            this.characterEncoding = characterEncoding;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() {\n        try {\n            InputStream inputStream = inputStream();\n            if (characterEncoding != null) {\n                return new InputStreamReader(inputStream, characterEncoding);\n            } else {\n                return new InputStreamReader(inputStream);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private InputStream inputStream() {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                httpConnection.connect();\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return url.openStream();\n                } else {\n                    throw new RuntimeException(\"Resource does not exist\");\n                }\n            } else {\n                return url.openStream();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean exists() {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                httpConnection.connect();\n                int responseCode = httpConnection.getResponseCode();\n                return responseCode == HttpURLConnection.HTTP_OK;\n            } else {\n                return true;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\n@Test\npublic void testServletInputStreamEarlyClose() throws Exception {\n    DefaultServer server = new DefaultServer(new EarlyCloseClientServlet());\n    server.start();\n    try {\n        TestHttpClient client = new TestHttpClient();\n        client.setSocketTimeout(1000);\n        client.executePost(server.getUrl(), new StringEntity(\"x\".repeat(1000000)));\n        fail(\"Expected an exception\");\n    } catch (Exception e) {\n        assertTrue(e.getMessage().contains(\"Premature end of Content-Length delimited message body (expected: 1000000, received: 0)\"));\n    } finally {\n        server.stop();\n    }\n}\n```"
  },
  {
    "Task_id": 597,
    "Instruction": "Task Description: Implement a UDP port probing function to check if a specific UDP port on a remote host is reachable and responsive.\n\nFunction Description: The function sends a UDP \"PING\" packet to a specified host and port, then waits for a response. It determines port reachability based on whether a response is received (port is open/reachable) or if specific exceptions occur (port is unreachable or other errors).\n\nInput:\n- host: String - The target hostname or IP address to probe\n- portMapping: PortMapping - An object containing the external port number to probe (accessed via getExternalPort())\n\nOutput:\n- boolean - Returns true if the port is reachable (response received or timeout occurred), false if the port is unreachable or other errors occurred\n\nThe function handles the following cases:\n1. SocketTimeoutException: Returns true (port may be open but no response received)\n2. PortUnreachableException: Returns false (port definitely unreachable)\n3. Other Socket/IO exceptions: Returns false after logging the error\n4. Successful response: Returns false (unexpected response case)",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.PortUnreachableException;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.io.IOException;\n\nprivate boolean probeUdpPort(String host, PortMapping portMapping) {\n    final Integer port = portMapping.getExternalPort();\n\n    try {\n        final byte[] pingData = \"PING\".getBytes(\"UTF-8\");\n        final DatagramSocket serverSocket = new DatagramSocket(0);\n        final SocketAddress socketAddr = new InetSocketAddress(host, port);\n        serverSocket.connect(socketAddr);\n\n        final InetAddress address = InetAddress.getByName(host);\n        final DatagramPacket sendPacket =\n            new DatagramPacket(pingData, pingData.length, address, port);\n        serverSocket.send(sendPacket);\n\n        final byte[] receiveData = new byte[8];\n        final DatagramPacket receivePacket =\n            new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.setSoTimeout(200);\n        serverSocket.receive(receivePacket);\n\n    } catch (SocketTimeoutException e) {\n        return true;\n    } catch (PortUnreachableException e) {\n        return false;\n    } catch (SocketException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    } catch (IOException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```java\npublic boolean isPortReachable(String host, PortMapping portMapping) {\n    try {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(1000);\n        byte[] buf = new byte[256];\n        InetAddress address = InetAddress.getByName(host);\n        DatagramPacket packet = new DatagramPacket(buf, buf.length, address, portMapping.getExternalPort());\n        socket.send(packet);\n        socket.receive(packet);\n        return false; // Unexpected response case\n    } catch (SocketTimeoutException e) {\n        return true; // Port may be open but no response received\n    } catch (PortUnreachableException e) {\n        return false; // Port definitely unreachable\n    } catch (SocketException | IOException e) {\n        e.printStackTrace();\n        return false; // Other errors occurred\n    }\n}\n```"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.UUID;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary = UUID.randomUUID().toString();\n\n    public HttpClient(String url) {\n        this.url = url;\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        String postData = \"imgName=\" + imgName;\n        os = con.getOutputStream();\n        os.write(postData.getBytes(StandardCharsets.UTF_8));\n        os.flush();\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return readBytes(con.getInputStream());\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    public void connectForMultipart() throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write(\"Content-Type: image/jpeg\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.flush();\n    }\n\n    public String getResponse() throws IOException {\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return readString(con.getInputStream());\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write(value.getBytes(StandardCharsets.UTF_8));\n        os.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    private byte[] readBytes(InputStream is) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        return baos.toByteArray();\n    }\n\n    private String readString(InputStream is) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = br.readLine()) != null) {\n            sb.append(line);\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtils {\n\n    private static final int DEFAULT_TIMEOUT = 5000;\n\n    public static class Error {\n        public static int responseCode;\n        public static String output;\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public static String post(String request) {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n            connection.setDoOutput(true);\n\n            try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n                wr.writeBytes(body);\n                wr.flush();\n            }\n\n            return handleResponse(connection, null);\n        } catch (IOException e) {\n            Error.responseCode = -1;\n            Error.output = e.getMessage();\n            return null;\n        }\n    }\n\n    public static String get(String request) {\n        return get(request, null, DEFAULT_TIMEOUT);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n\n            return handleResponse(connection, callback);\n        } catch (IOException e) {\n            Error.responseCode = -1;\n            Error.output = e.getMessage();\n            return null;\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws IOException {\n        StringBuilder response = new StringBuilder();\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                    if (callback != null) {\n                        callback.read(line);\n                    }\n                }\n            }\n        } else {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                    if (callback != null) {\n                        callback.read(line);\n                    }\n                }\n            }\n            Error.responseCode = responseCode;\n            Error.output = response.toString();\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 610,
    "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
    "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.nio.ByteBuffer;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.logging.Logger;\n\npublic class UDPTrackerClient {\n    private static final Logger logger = Logger.getLogger(UDPTrackerClient.class.getName());\n    private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n    private static final int UDP_MAX_TRIES = 5;\n    private static final int UDP_MAX_TRIES_ON_STOPPED = 3;\n    private static final int UDP_PACKET_LENGTH = 4096;\n\n    private final InetSocketAddress address;\n    private final Random random;\n    private final DatagramSocket socket;\n    private Date connectionExpiration;\n    private long connectionId;\n    private int transactionId;\n    private boolean stop;\n\n    public UDPTrackerClient(List<Peer> peers, URI tracker) throws IOException {\n        this.address = new InetSocketAddress(tracker.getHost(), tracker.getPort());\n        this.random = new SecureRandom();\n        this.socket = new DatagramSocket();\n        this.connectionExpiration = new Date();\n        this.connectionId = 0;\n        this.transactionId = 0;\n        this.stop = false;\n    }\n\n    public void announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) {\n        // Implementation of announce method\n    }\n\n    private void handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) {\n        // Implementation of handleTrackerAnnounceResponse method\n    }\n\n    public void close() {\n        // Implementation of close method\n    }\n\n    private UDPAnnounceRequestMessage buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) {\n        // Implementation of buildAnnounceRequest method\n    }\n\n    private void validateTrackerResponse(TrackerMessage message) {\n        // Implementation of validateTrackerResponse method\n    }\n\n    private void handleTrackerConnectResponse(TrackerMessage message) {\n        // Implementation of handleTrackerConnectResponse method\n    }\n\n    private void send(ByteBuffer data) throws IOException {\n        // Implementation of send method\n    }\n\n    private ByteBuffer recv(int attempt) throws IOException {\n        // Implementation of recv method\n    }\n}\n```"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UrlAccessibilityChecker {\n\n    public static boolean isUrlAccessible(String url) {\n        try {\n            HttpURLConnection.setFollowRedirects(false);\n            HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n            con.setRequestMethod(\"HEAD\");\n            return con.getResponseCode() == HttpURLConnection.HTTP_OK;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        String url = \"https://www.example.com\";\n        System.out.println(\"Is URL accessible? \" + isUrlAccessible(url));\n    }\n}\n```"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private volatile boolean mIsCanceled;\n    private volatile boolean mIsExecuted;\n    private static final List<String> blackList = new ArrayList<>();\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer) {\n        mRawUrl = rawUrl;\n        mPosition = position;\n        mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled) {\n            return;\n        }\n        start();\n    }\n\n    private void start() {\n        mIsExecuted = true;\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n        Request request = new Request.Builder()\n                .url(mCacheServer.getProxyUrl(mRawUrl))\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                blackList.add(mRawUrl);\n            }\n        } catch (IOException e) {\n            blackList.add(mRawUrl);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response from the input stream, and return it as a UTF-8 encoded string. Proper error handling and resource cleanup should be implemented.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent.\n\nOutput: \n- String - The response from the HTTP GET request, or null if an error occurs.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetRequest {\n\n    public static String sendGetRequest(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                return response.toString();\n            } else {\n                System.out.println(\"GET request failed. Response Code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String requestUrl = \"https://jsonplaceholder.typicode.com/posts/1\";\n        String response = sendGetRequest(requestUrl);\n        System.out.println(response);\n    }\n}\n```"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n\n    static {\n        XSTS_ERRORS.put(2148916233L, 2148916233);\n        XSTS_ERRORS.put(2148916234L, 2148916234);\n        XSTS_ERRORS.put(2148916235L, 2148916235);\n        XSTS_ERRORS.put(2148916236L, 2148916236);\n        XSTS_ERRORS.put(2148916237L, 2148916237);\n        XSTS_ERRORS.put(2148916238L, 2148916238);\n        XSTS_ERRORS.put(2148916239L, 2148916239);\n        XSTS_ERRORS.put(2148916240L, 2148916240);\n        XSTS_ERRORS.put(2148916241L, 2148916241);\n        XSTS_ERRORS.put(2148916242L, 2148916242);\n        XSTS_ERRORS.put(2148916243L, 2148916243);\n        XSTS_ERRORS.put(2148916244L, 2148916244);\n        XSTS_ERRORS.put(2148916245L, 2148916245);\n        XSTS_ERRORS.put(2148916246L, 2148916246);\n        XSTS_ERRORS.put(2148916247L, 2148916247);\n        XSTS_ERRORS.put(2148916248L, 2148916248);\n        XSTS_ERRORS.put(2148916249L, 2148916249);\n        XSTS_ERRORS.put(2148916250L, 2148916250);\n        XSTS_ERRORS.put(2148916251L, 2148916251);\n        XSTS_ERRORS.put(2148916252L, 2148916252);\n        XSTS_ERRORS.put(2148916253L, 2148916253);\n        XSTS_ERRORS.put(2148916254L, 2148916254);\n        XSTS_ERRORS.put(2148916255L, 2148916255);\n        XSTS_ERRORS.put(2148916256L, 2148916256);\n        XSTS_ERRORS.put(2148916257L, 2148916257);\n        XSTS_ERRORS.put(2148916258L, 2148916258);\n        XSTS_ERRORS.put(2148916259L, 2148916259);\n        XSTS_ERRORS.put(2148916260L, 2148916260);\n        XSTS_ERRORS.put(2148916261L, 2148916261);\n        XSTS_ERRORS.put(2148916262L, 2148916262);\n        XSTS_ERRORS.put(2148916263L, 2148916263);\n        XSTS_ERRORS.put(2148916264L, 2148916264);\n        XSTS_ERRORS.put(2148916265L, 2148916265);\n        XSTS_ERRORS.put(2148916266L, 2148916266);\n        XSTS_ERRORS.put(2148916267L, 2148916267);\n        XSTS_ERRORS.put(2148916268L, 2148916268);\n        XSTS_ERRORS.put(2148916269L, 2148916269);\n        XSTS_ERRORS.put(2148916270L, 2148916270);\n        XSTS_ERRORS.put(2148916271L, 2148916271);\n        XSTS_ERRORS.put(2148916272L, 2148916272);\n        XSTS_ERRORS.put(2148916273L, 2148916273);\n        XSTS_ERRORS.put(2148916274L, 2148916274);\n        XSTS_ERRORS.put(2148916275L, 2148916275);\n        XSTS_ERRORS.put(2148916276L, 2148916276);\n        XSTS_ERRORS.put(2148916277L, 2148916277);\n        XSTS_ERRORS.put(2148916278L, 2148916278);\n        XSTS_ERRORS.put(2148916279L, 2148916279);\n        XSTS_ERRORS.put(2148916280L, 2148916280);\n        XSTS_ERRORS.put(2148916281L, 2148916281);\n        XSTS_ERRORS.put(2148916282L, 2148916282);\n        XSTS_ERRORS.put(2148916283L, 2148916283);\n        XSTS_ERRORS.put(2148916284L, 2148916284);\n        XSTS_ERRORS.put(2148916285L, 2148916285);\n        XSTS_ERRORS.put(2148916286L, 2148916286);\n        XSTS_ERRORS.put(2148916287L, 2148916287);\n        XSTS_ERRORS.put(2148916288L, 2148916288);\n        XSTS_ERRORS.put(2148916289L, 2148916289);\n        XSTS_ERRORS.put(2148916290L, 2148916290);\n        XSTS_ERRORS.put(2148916291L, 2148916291);\n        XSTS_ERRORS.put(2148916292L, 2148916292);\n        XSTS_ERRORS.put(2148916293L, 2148916293);\n        XSTS_ERRORS.put(2148916294L, 2148916294);\n        XSTS_ERRORS.put(2148916295L, 2148916295);\n        XSTS_ERRORS.put(2148916296L, 2148916296);\n        XSTS_ERRORS.put(2148916297L, 2148916297);\n        XSTS_ERRORS.put(2148916298L, 2148916298);\n        XSTS_ERRORS.put(2148916299L, 2148916299);\n        XSTS_ERRORS.put(2148916300L, 2148916300);\n        XSTS_ERRORS.put(2148916301L, 2148916301);\n        XSTS_ERRORS.put(2148916302L, 2148916302);\n        XSTS_ERRORS.put(2148916303L, 2148916303);\n        XSTS_ERRORS.put(2148916304L, 2148916304);\n        XSTS_ERRORS.put(2148916305L, 2148916305);\n        XSTS_ERRORS.put(2148916306L, 2148916306);\n        XSTS_ERRORS.put(2148916307L, 2148916307);\n        XSTS_ERRORS.put(2148916308L, 2148916308);\n        XSTS_ERRORS.put(2148916309L, 2148916309);\n        XSTS_ERRORS.put(2148916310L, 2148916310);\n        XSTS_ERRORS.put(2148916311L, 2148916311);\n        XSTS_ERRORS.put(2148916312L, 2148916312);\n        XSTS_ERRORS.put(2148916313L, 2148916313);\n        XSTS_ERRORS.put(2148916314L, 2148916314);\n        XSTS_ERRORS.put(2148916315L, 2148916315);\n        XSTS_ERRORS.put(2148916316L, 2148916316);\n        XSTS_ERRORS.put(2148916317L, 2148916317);\n        XSTS_ERRORS.put(2148916318L, 2148916318);\n        XSTS_ERRORS.put(2148916319L, 2148916319);\n        XSTS_ERRORS.put(2148916320L, 2148916320);\n        XSTS_ERRORS.put(2148916321L, 2148916321);\n        XSTS_ERRORS.put(2148916322L, 2148916322);\n        XSTS_ERRORS.put(2148916323L, 2148916323);\n        XSTS_ERRORS.put(2148916324L, 2148916324);\n        XSTS_ERRORS.put(2148916325L, 2148916325);\n        XSTS_ERRORS.put(2148916326L, 2148916326);\n        XSTS_ERRORS.put(2148916327L, 2148916327);\n        XSTS_ERRORS.put(2148916328L, 2148916328);\n        XSTS_ERRORS.put(2148916329L, 2148916329);\n        XSTS_ERRORS.put(2148916330L, 2148916330);\n        XSTS_ERRORS.put(2148916331L, 2148916331);\n        XSTS_ERRORS.put(2148916332L, 2148916332);\n        XSTS_ERRORS.put(2148916333L, 2148916333);\n        XSTS_ERRORS.put(2148916334L, 2148916334);\n        XSTS_ERRORS.put(2148916335L, 2148916335);\n        XSTS_ERRORS.put(2148916336L, 2148916336);\n        XSTS_ERRORS.put(2148916337L, 2148916337);\n        XSTS_ERRORS.put(2148916338L, 2148916338);\n        XSTS_ERRORS.put(2148916339L, 2148916339);\n        XSTS_ERRORS.put(2148916340L, 2148916340);\n        XSTS_ERRORS.put(2148916341L, 2148916341);\n        XSTS_ERRORS.put(2148916342L, 2148916342);\n        XSTS_ERRORS.put(2148916343L, 2148916343);\n        XSTS_ERRORS.put(2148916344L, 2148916344);\n        XSTS_ERRORS.put(2148916345L, 2148916345);\n        XSTS_ERRORS.put(2148916346L, 2148916346);\n        XSTS_ERRORS.put(2148916347L, 2148916347);\n        XSTS_ERRORS.put(2148916348L, 2148916348);\n        XSTS_ERRORS.put(2148916349L, 2148916349);\n        XSTS_ERRORS.put(2148916350L, 2148916350);\n        XSTS_ERRORS.put(2148916351L, 2148916351);\n        XSTS_ERRORS.put(2148916352L, 2148916352);\n        XSTS_ERRORS.put(2148916353L, 2148916353);\n        XSTS_ERRORS.put(2148916354L, 2148916354);\n        XSTS_ERRORS.put(2148916355L, 2148916355);\n        XSTS_ERRORS.put(2148916356L, 2148916356);\n        XSTS_ERRORS.put(2148916357L, 2148916357);\n        XSTS_ERRORS.put(2148916358L, 2148916358);\n        XSTS_ERRORS.put(2148916359L, 2148916359);\n        XSTS_ERRORS.put(2148916360L, 2148916360);\n        XSTS_ERRORS.put(2148916361L, 2148916361);\n        XSTS_ERRORS.put(2148916362L, 2148916362);\n        XSTS_ERRORS.put(2148916363L, 2148916363);\n        XSTS_ERRORS.put(2148916364L, 2148916364);\n        XSTS_ERRORS.put(2148916365L, 2148916365);\n        XSTS_ERRORS.put(2148916366L, 2148916366);\n        XSTS_ERRORS.put(2148916367L, 2148916367);\n        XSTS_ERRORS.put(2148916368L, 2148916368);\n        XSTS_ERRORS.put(2148916369L, 2148916369);\n        XSTS_ERRORS.put(2148916370L, 2148916370);\n        XSTS_ERRORS.put(2148916371L, 2148916371);\n        XSTS_ERRORS.put(2148916372L, 2148916372);\n        XSTS_ERRORS.put(2148916373L, 2148916373);\n        XSTS_ERRORS.put(2148916374L, 2148916374);\n        XSTS_ERRORS.put(2148916375L, 2148916375);\n        XSTS_ERRORS.put(2148916376L, 2148916376);\n        XSTS_ERRORS.put(2148916377L, 2148916377);\n        XSTS_ERRORS.put(2148916378L, 2148916378);\n        XSTS_ERRORS.put(2148916379L, 2148916379);\n        XSTS_ERRORS.put(2148916380L, 2148916380);\n        XSTS_ERRORS.put(2148916381L, 2148916381);\n        XSTS_ERRORS.put(2148916382L, 2148916382);\n        XSTS_ERRORS.put(2148916383L, 2148916383);\n        XSTS_ERRORS.put(2148916384L, 2148916384);\n        XSTS_ERRORS.put(2148916385L, 2148916385);\n        XSTS_ERRORS.put(2148916386L, 2148916386);\n        XSTS_ERRORS.put(2148916387L, 2148916387);\n        XSTS_ERRORS.put(2148916388L, 2148916388);\n        XSTS_ERRORS.put(2148916389L, 2148916389);\n        XSTS_ERRORS.put(2148916390L, 2148916390);\n        XSTS_ERRORS.put(2148916391L, 2148916391);\n        XSTS_ERRORS.put(2148916392L, 2148916392);\n        XSTS_ERRORS.put(2148916393L, 2148916393);\n        XSTS_ERRORS.put(2148916394L, 2148916394);\n        XSTS_ERRORS.put(2148916395L, 2148916395);\n        XSTS_ERRORS.put(2148916396L, 2148916396);\n        XSTS_ERRORS.put(2148916397L, 2148916397);\n        XSTS_ERRORS.put(2148916398L, 2148916398);\n        XSTS_ERRORS.put(2148916399L, 2148916399);\n        XSTS_ERRORS.put(2148916400L, 2148916400);\n        XSTS_ERRORS.put(2148916401L, 2148916401);\n        XSTS_ERRORS.put(2148916402L, 2148916402);\n        XSTS_ERRORS.put(2148916403L, 2148916403);\n        XSTS_ERRORS.put(2148916404L, 2148916404);\n        XSTS_ERRORS.put(2148916405L, 2148916405);\n        XSTS_ERRORS.put(2148916406L, 2148916406);\n        XSTS_ERRORS.put(2148916407L, 2148916407);\n        XSTS_ERRORS.put(2148916408L, 2148916408);\n        XSTS_ERRORS.put(2148916409L, 2148916409);\n        XSTS_ERRORS.put(2148916410L, 2148916410);\n        XSTS_ERRORS.put(2148916411L, 2148916411);\n        XSTS_ERRORS.put(2148916412L, 2148916412);\n        XSTS_ERRORS.put(2148916413L, 2148916413);\n        XSTS_ERRORS.put(2148916414L, 2148916414);\n        XSTS_ERRORS.put(2148916415L, 2148916415"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport org.json.JSONObject;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JSONObject jsonObject) {\n        String baseUrl = responseUrl;\n        if (responseUrl.contains(\"?\")) {\n            baseUrl = responseUrl.substring(0, responseUrl.indexOf(\"?\"));\n            String[] params = responseUrl.substring(responseUrl.indexOf(\"?\") + 1).split(\"&\");\n            for (String param : params) {\n                String[] keyValue = param.split(\"=\");\n                jsonObject.put(keyValue[0], keyValue[1]);\n            }\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.setDoOutput(true);\n\n        try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n            wr.writeBytes(content);\n            wr.flush();\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\"))) {\n            return br.lines().collect(Collectors.joining(System.lineSeparator()));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = true;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 10000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 15000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n        connection.setReadTimeout(HTTP_READ_TIMEOUT);\n        connection.setRequestMethod(\"GET\");\n        connection.setDoInput(true);\n        connection.setDoOutput(false);\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setSSLSocketFactory(getSSLSocketFactory());\n        connection.setHostnameVerifier(getHostnameVerifier());\n        return connection;\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        try {\n            HttpsURLConnection connection = setupHttpsRequest(url);\n            connection.connect();\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = new BufferedInputStream(connection.getInputStream());\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                StringBuilder stringBuilder = new StringBuilder();\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    stringBuilder.append(new String(buffer, 0, bytesRead, StandardCharsets.UTF_8));\n                }\n                inputStream.close();\n                return stringBuilder.toString();\n            } else {\n                if (DEBUG) {\n                    System.out.println(TAG + \" downloadUrlMemoryAsString: HTTP error code: \" + connection.getResponseCode());\n                }\n            }\n        } catch (IOException e) {\n            if (DEBUG) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        try {\n            HttpsURLConnection connection = setupHttpsRequest(url);\n            connection.connect();\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = new BufferedInputStream(connection.getInputStream());\n                OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(f));\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                }\n                outputStream.flush();\n                outputStream.close();\n                inputStream.close();\n                return true;\n            } else {\n                if (DEBUG) {\n                    System.out.println(TAG + \" downloadUrlFile: HTTP error code: \" + connection.getResponseCode());\n                }\n            }\n        } catch (IOException e) {\n            if (DEBUG) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    private static SSLContext getSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                }\n            }};\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            return sslContext;\n        } catch (Exception e) {\n            throw new IOException(\"Failed to create SSL context\", e);\n        }\n    }\n\n    private static HostnameVerifier getHostnameVerifier() {\n        return new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        };\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}\n```"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONObject;\n\npublic class TwitterFavoritedPopupData {\n\n    public static JSONObject getFavoritedPopupData(long tweetId) {\n        try {\n            String url = \"https://api.twitter.com/1.1/favorites/list.json?count=1&tweet_id=\" + tweetId;\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Authorization\", \"Bearer YOUR_BEARER_TOKEN\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setDoOutput(true);\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            return new JSONObject(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        long tweetId = 1234567890L;\n        JSONObject response = getFavoritedPopupData(tweetId);\n        if (response != null) {\n            System.out.println(response.toString());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"http://example.com/api\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setDoOutput(true);\n\n            String postData = \"packageName=\" + packageName;\n            OutputStream outputStream = connection.getOutputStream();\n            outputStream.write(postData.getBytes());\n            outputStream.flush();\n            outputStream.close();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode < 400) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String line;\n                StringBuilder response = new StringBuilder();\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                callback.onSuccess(response.toString());\n            } else {\n                callback.onFailure(new Exception(\"Request failed with response code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess(String response);\n        void onFailure(Exception e);\n    }\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void sendPostRequest(String message, String url) throws IOException {\n    String urlStr = \"http://example.com/\" + url;\n    URL obj = new URL(urlStr);\n    HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n    con.setRequestMethod(\"POST\");\n    con.setRequestProperty(\"Content-Type\", \"application/json\");\n    con.setDoOutput(true);\n    DataOutputStream wr = new DataOutputStream(con.getOutputStream());\n    wr.writeBytes(message);\n    wr.flush();\n    wr.close();\n    int responseCode = con.getResponseCode();\n    if (responseCode == HttpURLConnection.HTTP_OK) {\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuffer response = new StringBuffer();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        if (!response.toString().equals(message)) {\n            System.out.println(\"Response does not match the original message. Response: \" + response.toString().replaceAll(\"\\\\p{C}\", \"\"));\n        }\n    } else {\n        System.out.println(\"POST request not worked\");\n    }\n}\n```"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\npublic class RestClient {\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Param... param) throws MalformedURLException {\n        StringBuilder sb = new StringBuilder(protocol.getScheme()).append(\"://\").append(host);\n        if (port != protocol.getDefaultPort()) {\n            sb.append(\":\").append(port);\n        }\n        sb.append(path);\n        if (param.length > 0) {\n            sb.append(\"?\");\n            sb.append(Stream.of(param).map(p -> p.toString()).collect(Collectors.joining(\"&\")));\n        }\n        return new URL(sb.toString());\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpURLConnection conn = (HttpURLConnection) getUrl(path).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setDoOutput(true);\n                if (username != null && password != null) {\n                    String auth = username + \":\" + password;\n                    String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n                }\n                for (Option option : options) {\n                    conn.setRequestProperty(option.getKey(), option.getValue());\n                }\n                if (outStreamConsumer != null) {\n                    try (OutputStream os = conn.getOutputStream()) {\n                        outStreamConsumer.accept(os);\n                    }\n                }\n                int status = getResponseCodeFrom(conn);\n                String responseText = tryGetResponseTextFrom(conn, status);\n                Map<String, List<String>> headers = new HashMap<>();\n                for (Map.Entry<String, List<String>> entry : conn.getHeaderFields().entrySet()) {\n                    headers.put(entry.getKey(), entry.getValue());\n                }\n                return new Response(status, responseText, headers);\n            } catch (IOException e) {\n                throw new RestException(\"Error sending request\", e);\n            }\n        });\n    }\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        if (status == HttpURLConnection.HTTP_NOT_FOUND) {\n            return null;\n        }\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            return br.lines().collect(Collectors.joining(\"\\n\"));\n        }\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        int status = conn.getResponseCode();\n        if (status == HttpURLConnection.HTTP_NOT_FOUND) {\n            return status;\n        }\n        if (status >= 400) {\n            throw new RestException(\"Error response code: \" + status);\n        }\n        return status;\n    }\n}\n```"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            URL url = new URL(\"http://dnslog.cn/getdomain.php\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                String domain = response.toString();\n                config.setDomain(domain);\n                status = 1;\n            } else {\n                status = -1;\n            }\n        } catch (Exception e) {\n            status = -1;\n        }\n        return 1;\n    }\n}\n```"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostRequest {\n\n    public static String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            con.setDoOutput(true);\n\n            String urlParameters = \"name=\" + name;\n\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            try (BufferedReader br = new BufferedReader(\n                    new InputStreamReader(con.getInputStream(), \"utf-8\"))) {\n                StringBuilder response = new StringBuilder();\n                String responseLine;\n                while ((responseLine = br.readLine()) != null) {\n                    response.append(responseLine.trim());\n                }\n                return response.toString();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n}\n```"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.util.Log;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n    private Context context;\n    private String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        HttpURLConnection connection = null;\n        try {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            int responseCode = connection.getResponseCode();\n            String message = getResponseMessage(responseCode);\n            String redirectionUrl = connection.getHeaderField(\"Location\");\n            return new StatusResult(message, redirectionUrl);\n        } catch (IOException e) {\n            Log.e(\"HttpStatusChecker\", \"Error checking status\", e);\n            return new StatusResult(\"Error checking status: \" + e.getMessage(), null);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String getResponseMessage(int responseCode) {\n        switch (responseCode) {\n            case HttpURLConnection.HTTP_OK:\n                return \"OK\";\n            case HttpURLConnection.HTTP_MOVED_TEMP:\n            case HttpURLConnection.HTTP_MOVED_PERM:\n                return \"Redirected\";\n            case HttpURLConnection.HTTP_NOT_FOUND:\n                return \"Not Found\";\n            case HttpURLConnection.HTTP_INTERNAL_ERROR:\n                return \"Internal Server Error\";\n            case HttpURLConnection.HTTP_BAD_GATEWAY:\n                return \"Bad Gateway\";\n            case HttpURLConnection.HTTP_UNAUTHORIZED:\n                return \"Unauthorized\";\n            case HttpURLConnection.HTTP_FORBIDDEN:\n                return \"Forbidden\";\n            default:\n                return \"Unknown Status: \" + responseCode;\n        }\n    }\n\n    public static class StatusResult {\n        private String message;\n        private String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public String getRedirectionUrl() {\n            return redirectionUrl;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.Logger;\n\npublic class SSRFChecker {\n    private Logger logger;\n    private String decimalIp;\n\n    public SSRFChecker(Logger logger) {\n        this.logger = logger;\n    }\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        for (int i = 0; i < checkTimes; i++) {\n            if (isInternalIpByUrl(url)) {\n                logger.info(\"URL is dangerous: \" + url);\n                return false;\n            }\n            url = getRedirectUrl(url);\n        }\n        return true;\n    }\n\n    private boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host == null) {\n            return false;\n        }\n        return isInternalIp(host2ip(host));\n    }\n\n    private boolean isInternalIp(String strIP) {\n        String[] parts = strIP.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n        int first = Integer.parseInt(parts[0]);\n        int second = Integer.parseInt(parts[1]);\n        return (first == 10) || (first == 172 && second >= 16 && second <= 31) || (first == 192 && second == 168);\n    }\n\n    private String host2ip(String host) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            return inetAddress.getHostAddress();\n        } catch (UnknownHostException e) {\n            logger.warning(\"Failed to resolve IP address for host: \" + host);\n            return \"\";\n        }\n    }\n\n    private String url2host(String url) {\n        if (!url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {\n            logger.info(\"URL is not HTTP/HTTPS: \" + url);\n            return \"\";\n        }\n        int index = url.indexOf(\"/\", 7);\n        if (index == -1) {\n            index = url.length();\n        }\n        return url.substring(7, index);\n    }\n\n    private boolean isOctalIP(String host) {\n        return host.matches(\"\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\");\n    }\n\n    private String getRedirectUrl(String url) {\n        // Implementation for following redirects\n        return \"\";\n    }\n}\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.Proxy;\nimport java.net.InetSocketAddress;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection = (HttpURLConnection) (mProxyOn ? url.openConnection(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, (int) mProxyPort))) : url.openConnection());\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                String response = readStringFromStream(connection.getInputStream());\n                callback.onSuccess(response);\n            } else {\n                callback.onFailed();\n            }\n        } catch (IOException e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            stringBuilder.append(line);\n        }\n        reader.close();\n        return stringBuilder.toString();\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}\n```"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpTinyClient {\n\n    private static final String USER_AGENT = \"HttpTinyClient/1.0\";\n\n    private HttpTinyClient() {\n        // Utility class\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws Exception {\n        String encodedParams = encodingParams(paramValues, encoding);\n        String fullUrl = url + \"?\" + encodedParams;\n        HttpURLConnection conn = (HttpURLConnection) new URL(fullUrl).openConnection();\n        conn.setRequestMethod(\"GET\");\n        setHeaders(conn, headers, encoding);\n        conn.setReadTimeout((int) readTimeoutMs);\n        return processResponse(conn);\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws Exception {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        setHeaders(conn, headers, encoding);\n        conn.setDoOutput(true);\n        conn.setReadTimeout((int) readTimeoutMs);\n        String encodedParams = encodingParams(paramValues, encoding);\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(encodedParams);\n            wr.flush();\n        }\n        return processResponse(conn);\n    }\n\n    private static String encodingParams(List<String> paramValues, String encoding) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            String key = paramValues.get(i);\n            String value = paramValues.get(i + 1);\n            sb.append(URLEncoder.encode(key, encoding));\n            sb.append(\"=\");\n            sb.append(URLEncoder.encode(value, encoding));\n            if (i < paramValues.size() - 2) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    private static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"User-Agent\", USER_AGENT);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + encoding);\n        for (String header : headers) {\n            conn.setRequestProperty(header.split(\":\")[0], header.split(\":\")[1]);\n        }\n    }\n\n    private static HttpResult processResponse(HttpURLConnection conn) throws Exception {\n        int code = conn.getResponseCode();\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n        }\n        return new HttpResult(code, content.toString());\n    }\n\n    public static class HttpResult {\n        private final int code;\n        private final String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getContent() {\n            return content;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.logging.Logger;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = Logger.getLogger(HttpPostUploadUtil.class.getName());\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(connectTimeout);\n        connection.setReadTimeout(readTimeout);\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n        try (OutputStream outputStream = connection.getOutputStream()) {\n            if (textMap != null) {\n                for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                    writeText(outputStream, entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (fileMap != null) {\n                for (Map.Entry<String, MultipartFile> entry : fileMap.entrySet()) {\n                    writeFile(outputStream, entry.getKey(), entry.getValue());\n                }\n            }\n\n            outputStream.write((\"--\" + BOUNDARY + \"--\").getBytes(StandardCharsets.UTF_8));\n            outputStream.flush();\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } else {\n            throw new IOException(\"Server returned non-OK status: \" + responseCode);\n        }\n    }\n\n    private static void writeText(OutputStream outputStream, String fieldName, String fieldValue) throws IOException {\n        String textPart = \"--\" + BOUNDARY + \"\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"\\r\\n\" +\n                \"\\r\\n\" +\n                fieldValue + \"\\r\\n\";\n        outputStream.write(textPart.getBytes(StandardCharsets.UTF_8));\n    }\n\n    private static void writeFile(OutputStream outputStream, String fieldName, MultipartFile file) throws IOException {\n        String filePart = \"--\" + BOUNDARY + \"\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"; filename=\\\"\" + file.getOriginalFilename() + \"\\\"\\r\\n\" +\n                \"Content-Type: \" + file.getContentType() + \"\\r\\n\" +\n                \"\\r\\n\";\n        outputStream.write(filePart.getBytes(StandardCharsets.UTF_8));\n        outputStream.write(file.getBytes());\n        outputStream.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    public static void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.warning(\"Error closing stream: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static final String BOUNDARY = \"---------------------------\" + UUID.randomUUID().toString();\n}\n```"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.logging.Logger;\n\npublic class RemoteServiceImpl implements RemoteService {\n\n    private String resporityServerUrl;\n    private Logger log;\n\n    public RemoteServiceImpl(String resporityServerUrl, Logger log) {\n        this.resporityServerUrl = resporityServerUrl;\n        this.log = log;\n    }\n\n    @Override\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        String response = sendRequest(packageId, timestamp);\n        // Process the response and return the knowledge package\n        return null;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        try {\n            String url = resporityServerUrl + \"/knowledge/\" + packageId + \"?timestamp=\" + timestamp;\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) { // success\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                log.warning(\"GET request failed. Response Code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            log.severe(\"Exception occurred while sending GET request: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (!resporityServerUrl.endsWith(\"/\")) {\n            resporityServerUrl += \"/\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}\n```"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.app.DownloadManager;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.webkit.MimeTypeMap;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport rx.Single;\nimport rx.SingleSubscriber;\nimport rx.Subscription;\nimport rx.subscriptions.Subscriptions;\n\nimport java.io.IOException;\n\npublic class FetchUrlMimeType {\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mDownloadManager = downloadManager;\n        mRequest = request;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(new Single.OnSubscribe<Result>() {\n            @Override\n            public void call(SingleSubscriber<? super Result> singleSubscriber) {\n                OkHttpClient client = new OkHttpClient();\n                Request request = new Request.Builder()\n                        .url(mUri)\n                        .addHeader(\"Cookie\", mCookies)\n                        .addHeader(\"User-Agent\", mUserAgent)\n                        .build();\n\n                try {\n                    Response response = client.newCall(request).execute();\n                    if (!response.isSuccessful()) {\n                        singleSubscriber.onError(new IOException(\"Unexpected code \" + response));\n                        return;\n                    }\n\n                    String contentType = response.header(\"Content-Type\");\n                    String contentDisposition = response.header(\"Content-Disposition\");\n                    String fileName = getFileName(contentDisposition, mUri);\n\n                    mRequest.setMimeType(getMimeType(contentType));\n                    mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);\n\n                    long enqueue = mDownloadManager.enqueue(mRequest);\n                    if (enqueue == -1) {\n                        singleSubscriber.onError(new IOException(\"Failed to enqueue download\"));\n                    } else {\n                        singleSubscriber.onSuccess(Result.SUCCESS);\n                    }\n                } catch (IOException e) {\n                    singleSubscriber.onError(e);\n                }\n            }\n        });\n    }\n\n    private String getFileName(String contentDisposition, String uri) {\n        if (contentDisposition != null) {\n            String[] params = contentDisposition.split(\";\");\n            for (String param : params) {\n                if (param.trim().startsWith(\"filename\")) {\n                    String fileName = param.substring(param.indexOf('=') + 1);\n                    return fileName.replaceAll(\"\\\"\", \"\").trim();\n                }\n            }\n        }\n        return Uri.parse(uri).getLastPathSegment();\n    }\n\n    private String getMimeType(String contentType) {\n        if (contentType != null) {\n            String[] params = contentType.split(\";\");\n            return params[0].trim();\n        }\n        return MimeTypeMap.getFileExtensionFromUrl(mUri);\n    }\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}\n```"
  }
]