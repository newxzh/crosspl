[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Implement a Go struct that represents a Docker registry repository client, capable of interacting with Docker registry API v2 to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct serves as a client for interacting with a Docker registry's repository, providing methods to access blob storage, manifests, and tag services. It maintains HTTP client configuration and URL building capabilities.\n\nFields:\n- client: *http.Client - Custom HTTP client configured with transport and redirect handling\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nTask Description: Implement a Go struct that represents a tag service for a Docker registry repository, capable of retrieving tag information from a Docker registry API v2.\n\nStruct Description: The `tags` struct provides tag-related operations for a Docker repository, implementing the distribution.TagService interface. It uses HTTP requests to interact with the registry's tag API endpoints.\n\nFields:\n- client: *http.Client - HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing tag-related API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves the descriptor for a specific tag, making HEAD and GET requests as needed to the registry API",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/distribution/registry/client\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/docker/distribution/registry/api/v2\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn client.NewBlobStore(r.ub, r.client, r.name)\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn client.NewManifestService(r.ub, r.client, r.name, options...)\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\ttagURL, err := t.ub.BuildTagsURL(t.name)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", tagURL, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn distribution.Descriptor{}, client.HandleErrorResponse(resp)\n\t}\n\n\t// Parse response to get the descriptor\n\t// Assuming a function parseDescriptor exists to handle the response parsing\n\tdescriptor, err := parseDescriptor(resp.Body)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\treturn descriptor, nil\n}\n\n// parseDescriptor is a placeholder for actual response parsing logic\nfunc parseDescriptor(body io.Reader) (distribution.Descriptor, error) {\n\t// Implement parsing logic here\n\treturn distribution.Descriptor{}, nil\n}\n```"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Go HTTP client struct that can make authenticated API requests with custom headers and handle responses, including error status codes.\n\nStruct Description: The Client struct represents an HTTP client with authentication credentials and endpoint configuration, capable of making various HTTP requests and processing responses.\n\nFields:\nUser: string - The username for basic authentication\nApiKey: string - The API key or password for basic authentication\nEndpoint: string - The base URL for API endpoints\n\nMethods:\nisOkStatus: [Name](code int) -> bool - Checks if the HTTP status code indicates a successful response (200, 201, 204 return true; 400, 404, 500, 409, 406 return false)\nnewRequest: [Name](method string, uri string, body interface{}) -> ([]byte, error) - Creates and executes an HTTP request with the given method, URI, and optional body. Returns the response body or an error if the request fails or returns a non-success status code. Automatically adds basic authentication headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tcodes := map[int]bool{\n\t\t200: true,\n\t\t201: true,\n\t\t204: true,\n\t\t400: false,\n\t\t404: false,\n\t\t500: false,\n\t\t409: false,\n\t\t406: false,\n\t}\n\n\treturn codes[code]\n}\n\nfunc (c *Client) newRequest(method, uri string, body interface{}) ([]byte, error) {\n\tvar (\n\t\tclient = &http.Client{}\n\t\turl    = fmt.Sprintf(\"%s/%s\", c.Endpoint, uri)\n\t\terr    error\n\t\treq    *http.Request\n\t)\n\n\tif body != nil {\n\t\tbodyJSON, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq, err = http.NewRequest(method, url, bytes.NewBuffer(bodyJSON))\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error with request: %v - %q\", url, err)\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\ttype apiErr struct {\n\t\t\tErr string `json:\"error\"`\n\t\t}\n\t\tvar outErr apiErr\n\t\tjson.Unmarshal(data, &outErr)\n\t\treturn nil, fmt.Errorf(\"Error in response: %s\", outErr.Err)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tswitch code {\n\tcase 200, 201, 204:\n\t\treturn true\n\tcase 400, 404, 500, 409, 406:\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (c *Client) newRequest(method string, uri string, body interface{}) ([]byte, error) {\n\turl := c.Endpoint + uri\n\tvar reqBody []byte\n\tvar err error\n\n\tif body != nil {\n\t\treqBody, err = json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\treturn nil, errors.New(\"received non-success status code\")\n\t}\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn respBody, nil\n}\n```"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server using the Echo framework, which acts as a reverse proxy to route requests to different host servers based on the request's host header.\n\nFunction Description: The function initializes an Echo instance, configures middleware, sets up route handlers, and starts an HTTP server that proxies requests to different Echo instances based on the host header. It maintains a map of hostnames to their corresponding Echo instances for routing purposes.\n\nInput: None (The function takes no parameters but internally uses a map of hostnames to Echo instances)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)\n\n---\n\nTask Description: Create a Go struct that represents a virtual host configuration for an Echo-based HTTP server.\n\nStruct Description: The Host struct represents a virtual host configuration that holds an Echo instance for handling requests to a specific hostname.\n\nFields:\nEcho: *echo.Echo - Pointer to an Echo instance that handles requests for this host\n\nMethods:\nNone (The struct is simple and only holds a reference to an Echo instance)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\thosts := make(map[string]*Host)\n\n\tapi := echo.New()\n\tapi.Use(middleware.Logger())\n\tapi.Use(middleware.Recover())\n\n\thosts[\"api.localhost:1323\"] = &Host{api}\n\n\tapi.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"API\")\n\t})\n\n\te := echo.New()\n\te.Any(\"/*\", func(c echo.Context) (err error) {\n\t\treq := c.Request()\n\t\tres := c.Response()\n\t\thost := hosts[req.Host]\n\n\t\tif host == nil {\n\t\t\terr = echo.ErrNotFound\n\t\t} else {\n\t\t\thost.Echo.ServeHTTP(res, req)\n\t\t}\n\n\t\treturn\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Host struct {\n\tEcho *echo.Echo\n}\n\nfunc startReverseProxyServer() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\thosts := map[string]*Host{\n\t\t\"example.com\": {Echo: echo.New()},\n\t\t\"another.com\": {Echo: echo.New()},\n\t}\n\n\te.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\thost := c.Request().Host\n\t\t\tif h, ok := hosts[host]; ok {\n\t\t\t\treturn h.Echo.ServeHTTP(c.Response(), c.Request())\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Host not found\")\n\t\t}\n\t})\n\n\te.Start(\":8080\")\n}\n\nfunc main() {\n\tstartReverseProxyServer()\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with configurable settings including middleware, routes, and TLS support.\n\nFunction Description: The function serves as the entry point for starting a Gin-based HTTP server. It initializes the Gin engine with default middleware (Logger and Recovery) and additional custom middleware (CORS, Correlation, Auth, etc.). It registers various route handlers for different endpoints including health checks, metrics, and a home route. The server can be started with or without TLS based on configuration.\n\nInput: \n- None (configuration is read from viper and cobra command context)\n\nOutput: \n- None (runs HTTP server as a blocking operation, panics on error)\n\nMethods:\n- The function itself serves as the main execution method for the cobra.Command's Run field\n\nNote: The function uses global configuration via viper and is designed to work as part of a cobra CLI command structure. It handles server startup errors by panicking, which is appropriate for a main application entry point.\n\n(Strictly following the format with no extra characters)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n)\n\nvar towerCmd = &cobra.Command{\n\tUse:   \"api\",\n\tShort: \"Start beaver api server\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tr := gin.Default()\n\n\t\tr.Use(middleware.Cors())\n\t\tr.Use(middleware.Correlation())\n\t\tr.Use(middleware.Logger())\n\t\tr.Use(middleware.Metric())\n\t\tr.Use(middleware.Auth())\n\n\t\tr.GET(\"/favicon.ico\", func(c *gin.Context) {\n\t\t\tc.String(http.StatusNoContent, \"\")\n\t\t})\n\n\t\tr.GET(\"/\", controller.Home)\n\n\t\tr.GET(\"/_health\", controller.Health)\n\n\t\tr.GET(\n\t\t\tviper.GetString(\"app.metrics.prometheus.endpoint\"),\n\t\t\tgin.WrapH(controller.Metrics()),\n\t\t)\n\n\t\tvar runerr error\n\n\t\tif viper.GetBool(\"app.tls.status\") {\n\t\t\trunerr = r.RunTLS(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t\tviper.GetString(\"app.tls.pemPath\"),\n\t\t\t\tviper.GetString(\"app.tls.keyPath\"),\n\t\t\t)\n\t\t} else {\n\t\t\trunerr = r.Run(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t)\n\t\t}\n\n\t\tif runerr != nil {\n\t\t\tpanic(runerr.Error())\n\t\t}\n\t},\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "func runServer(cmd *cobra.Command, args []string) {\n    // Initialize Gin engine\n    r := gin.New()\n    \n    // Default middleware\n    r.Use(gin.Logger())\n    r.Use(gin.Recovery())\n    \n    // Custom middleware\n    r.Use(corsMiddleware())\n    r.Use(correlationMiddleware())\n    r.Use(authMiddleware())\n    \n    // Routes\n    r.GET(\"/health\", healthCheckHandler)\n    r.GET(\"/metrics\", metricsHandler)\n    r.GET(\"/\", homeHandler)\n    \n    // Configuration\n    addr := viper.GetString(\"server.address\")\n    tlsEnabled := viper.GetBool(\"server.tls.enabled\")\n    certFile := viper.GetString(\"server.tls.certFile\")\n    keyFile := viper.GetString(\"server.tls.keyFile\")\n    \n    // Start server\n    if tlsEnabled {\n        if err := r.RunTLS(addr, certFile, keyFile); err != nil {\n            panic(fmt.Sprintf(\"Failed to start TLS server: %v\", err))\n        }\n    } else {\n        if err := r.Run(addr); err != nil {\n            panic(fmt.Sprintf(\"Failed to start server: %v\", err))\n        }\n    }\n}\n\nfunc corsMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Implement CORS logic\n        c.Next()\n    }\n}\n\nfunc correlationMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Implement correlation logic\n        c.Next()\n    }\n}\n\nfunc authMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Implement authentication logic\n        c.Next()\n    }\n}\n\nfunc healthCheckHandler(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\"status\": \"healthy\"})\n}\n\nfunc metricsHandler(c *gin.Context) {\n    // Implement metrics logic\n    c.JSON(http.StatusOK, gin.H{\"metrics\": \"data\"})\n}\n\nfunc homeHandler(c *gin.Context) {\n    c.String(http.StatusOK, \"Welcome to the home page!\")\n}"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using Gin framework with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a simple GET route handler, configures automatic TLS certificate management using autocert, and starts the HTTPS server. The server will automatically obtain and renew TLS certificates from Let's Encrypt for specified domains.\n\nInput: None (The function takes no parameters as all configurations are internally defined)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely. It will log.Fatal if there's an error starting the server.)\n\nNote: The function demonstrates a complete setup for a production-ready HTTPS server with automatic certificate management. The domains and cache directory are hardcoded in this example but could be parameterized in a real implementation.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tlog.Fatal(autotls.RunWithManager(r, m))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, HTTPS world!\")\n\t})\n\n\tdomains := []string{\"example.com\", \"www.example.com\"}\n\tcacheDir := \"./certs\"\n\n\tm := &autocert.Manager{\n\t\tCache:      autocert.DirCache(cacheDir),\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(domains...),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr: \":443\",\n\t\tTLSConfig: &tls.Config{\n\t\t\tGetCertificate: m.GetCertificate,\n\t\t},\n\t\tHandler: r,\n\t}\n\n\tgo func() {\n\t\tlog.Fatal(http.ListenAndServe(\":80\", m.HTTPHandler(nil)))\n\t}()\n\n\tlog.Fatal(server.ListenAndServeTLS(\"\", \"\"))\n}\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a Go struct representing a Docker registry repository client that can interact with a Docker registry API to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct represents a client for interacting with a Docker registry repository. It provides methods to access blob storage, manifests, and tags through the Docker Registry HTTP API V2.\n\nFields:\n- client: *http.Client - Custom HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nAdditional Struct: `tags` - Handles tag operations for a Docker repository\n\nFields:\n- client: *http.Client - HTTP client for making requests\n- ub: *v2.URLBuilder - URL builder for API endpoints\n- name: reference.Named - Named reference to the repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves descriptor information for a specific tag, first trying HEAD request and falling back to GET if needed",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/distribution/registry/client\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/docker/distribution/registry/client/v2\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn client.NewBlobStore(r.ub, r.client, r.name)\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn client.NewManifestService(r.ub, r.client, r.name, options...)\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\turl, err := t.ub.BuildTagsURL(t.name)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodHead, url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\treturn distribution.Descriptor{}, nil // Implement descriptor extraction logic\n\t}\n\n\treq, err = http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err = t.client.Do(req)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn distribution.Descriptor{}, err // Handle error\n\t}\n\n\treturn distribution.Descriptor{}, nil // Implement descriptor extraction logic\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that retrieves metadata from a metadata server using a custom HTTP client, with support for ETag headers and error handling.\n\nFunction Description: The function `getETag` makes an HTTP GET request to a metadata server endpoint, using a custom HTTP client with specific timeout configurations. It handles the response by checking status codes, reading the response body, and extracting both the content and ETag header. The function includes error handling for various scenarios including connection errors, missing resources, and non-200 status codes.\n\nInput:\n- client *http.Client: A custom HTTP client with configured timeouts for the request\n- suffix string: The path suffix to append to the base metadata URL\n\nOutput:\n- value string: The content of the response body as a string\n- etag string: The ETag header value from the response\n- err error: An error object if any step fails, nil on success",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "func getETag(client *http.Client, suffix string) (string, string, error) {\n    const baseURL = \"http://metadata.server/endpoint\"\n    url := baseURL + suffix\n\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return \"\", \"\", fmt.Errorf(\"failed to create request: %w\", err)\n    }\n\n    resp, err := client.Do(req)\n    if err != nil {\n        return \"\", \"\", fmt.Errorf(\"failed to perform request: %w\", err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n    }\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return \"\", \"\", fmt.Errorf(\"failed to read response body: %w\", err)\n    }\n\n    etag := resp.Header.Get(\"ETag\")\n    if etag == \"\" {\n        return \"\", \"\", fmt.Errorf(\"ETag header missing\")\n    }\n\n    return string(body), etag, nil\n}"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Implement a streaming HTTP server endpoint using Gin in Go that sends chunked data responses to clients.\n\nFunction Description: The function sets up a Gin HTTP server with a single endpoint (\"/stream\") that streams data to the client in real-time using chunked transfer encoding. It demonstrates how to implement server-sent events or real-time data streaming in Go.\n\nInput: None (The function takes no direct input parameters as it's the main server setup function)\n\nOutput: None (The function doesn't return anything but sets up a running HTTP server that outputs streaming data to connected clients)\n\n---\n\nFor completeness, here's the alternative struct-level format (though the reference code is function-level):\n\nTask Description: Create a struct that encapsulates a streaming HTTP server using Gin framework in Go.\n\nStruct Description: The StreamServer struct represents a configurable HTTP server capable of streaming data to clients.\n\nFields:\n- router: *gin.Engine - The Gin router instance\n- port: string - The port number to listen on\n- streamData: chan string - Channel for streaming data to clients\n\nMethods:\n- NewStreamServer(port string) *StreamServer - Constructor that initializes a new StreamServer instance\n- SetupRoutes() - Configures all HTTP routes and handlers\n- GenerateStreamData() - Generates sample data for streaming\n- Start() error - Starts the HTTP server\n- Stop() - Gracefully shuts down the server",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/stream\", func(c *gin.Context) {\n\t\tc.Header(\"Content-Type\", \"text/plain\")\n\t\tc.Header(\"Transfer-Encoding\", \"chunked\")\n\n\t\tdataStream := make(chan string)\n\n\t\tgo func() {\n\t\t\tdefer close(dataStream)\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\tdataStream <- fmt.Sprintf(\"Data %d\\n\", i)\n\t\t\t}\n\t\t}()\n\n\t\tfor data := range dataStream {\n\t\t\t_, _ = io.WriteString(c.Writer, data)\n\t\t\tc.Writer.Flush()\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype StreamServer struct {\n\trouter     *gin.Engine\n\tport       string\n\tstreamData chan string\n}\n\nfunc NewStreamServer(port string) *StreamServer {\n\tserver := &StreamServer{\n\t\trouter:     gin.Default(),\n\t\tport:       port,\n\t\tstreamData: make(chan string),\n\t}\n\tserver.SetupRoutes()\n\treturn server\n}\n\nfunc (s *StreamServer) SetupRoutes() {\n\ts.router.GET(\"/stream\", func(c *gin.Context) {\n\t\tc.Writer.Header().Set(\"Content-Type\", \"text/event-stream\")\n\t\tc.Writer.Header().Set(\"Cache-Control\", \"no-cache\")\n\t\tc.Writer.Header().Set(\"Connection\", \"keep-alive\")\n\n\t\tfor data := range s.streamData {\n\t\t\tfmt.Fprintf(c.Writer, \"data: %s\\n\\n\", data)\n\t\t\tc.Writer.Flush()\n\t\t}\n\t})\n}\n\nfunc (s *StreamServer) GenerateStreamData() {\n\tgo func() {\n\t\tfor {\n\t\t\ts.streamData <- fmt.Sprintf(\"Current time: %s\", time.Now().Format(time.RFC3339))\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}()\n}\n\nfunc (s *StreamServer) Start() error {\n\ts.GenerateStreamData()\n\treturn s.router.Run(\":\" + s.port)\n}\n\nfunc (s *StreamServer) Stop() {\n\tclose(s.streamData)\n}\n\nfunc main() {\n\tserver := NewStreamServer(\"8080\")\n\tif err := server.Start(); err != nil {\n\t\tfmt.Printf(\"Failed to start server: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a function to retrieve user information from Facebook's Graph API using an access token, with proper error handling and response validation.\n\nFunction Description: The function GetUserInfo makes an authenticated GET request to Facebook's Graph API to fetch user information (name, email, ID, and picture) using the provided access token. It handles the HTTP request/response cycle, validates the response, and parses the JSON data into a structured format.\n\nInput:\n- token: TokenInfo - A struct containing the Facebook access token (token.AccessToken is used)\n\nOutput:\n- model.UserInfo - A struct containing the user's information (ID, picture URL, name, email, and origin)\n- string - The raw JSON response body from the API\n- error - Any error that occurred during the API request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/tarent/loginsrv/model\"\n)\n\nvar facebookAPI = \"https://graph.facebook.com/v2.12\"\n\nfunc (p Provider) GetUserInfo(token TokenInfo) (model.UserInfo, string, error) {\n\tfu := facebookUser{}\n\n\turl := fmt.Sprintf(\"%v/me?access_token=%v&fields=name,email,id,picture\", facebookAPI, token.AccessToken)\n\n\tclient := &http.Client{}\n\tcontentType := \"application/json\"\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Accept\", contentType)\n\tresp, err := client.Do(req)\n\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif !strings.Contains(resp.Header.Get(\"Content-Type\"), contentType) {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"wrong content-type on facebook get user info: %v\", resp.Header.Get(\"Content-Type\"))\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"got http status %v on facebook get user info\", resp.StatusCode)\n\t}\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error reading facebook get user info: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, &fu)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error parsing facebook get user info: %v\", err)\n\t}\n\n\treturn model.UserInfo{\n\t\tSub:     fu.UserID,\n\t\tPicture: fu.Picture.Data.URL,\n\t\tName:    fu.Name,\n\t\tEmail:   fu.Email,\n\t\tOrigin:  \"facebook\",\n\t}, string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package facebook\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype TokenInfo struct {\n\tAccessToken string\n}\n\ntype UserInfo struct {\n\tID      string\n\tName    string\n\tEmail   string\n\tPicture string\n\tOrigin  string\n}\n\nfunc GetUserInfo(token TokenInfo) (UserInfo, string, error) {\n\turl := fmt.Sprintf(\"https://graph.facebook.com/me?fields=id,name,email,picture&access_token=%s\", token.AccessToken)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn UserInfo{}, string(body), errors.New(\"failed to fetch user info from Facebook\")\n\t}\n\n\tvar data struct {\n\t\tID      string `json:\"id\"`\n\t\tName    string `json:\"name\"`\n\t\tEmail   string `json:\"email\"`\n\t\tPicture struct {\n\t\t\tData struct {\n\t\t\t\tURL string `json:\"url\"`\n\t\t\t} `json:\"data\"`\n\t\t} `json:\"picture\"`\n\t}\n\n\tif err := json.Unmarshal(body, &data); err != nil {\n\t\treturn UserInfo{}, string(body), err\n\t}\n\n\tuserInfo := UserInfo{\n\t\tID:      data.ID,\n\t\tName:    data.Name,\n\t\tEmail:   data.Email,\n\t\tPicture: data.Picture.Data.URL,\n\t\tOrigin:  \"facebook\",\n\t}\n\n\treturn userInfo, string(body), nil\n}"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Implement a JWT-based authentication service using Gin framework in Go, which provides public endpoints for token generation and private endpoints that require valid JWT tokens for access.\n\nFunction Description: The main function sets up a Gin HTTP server with JWT authentication. It creates two route groups: a public group for token generation and a private group that requires JWT authentication. The public endpoint generates JWT tokens, while the private endpoint demonstrates protected access.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests with the following possible inputs:\n- GET request to \"/api/\" for token generation\n- GET request to \"/api/private/\" for accessing protected content)\n\nOutput: HTTP responses with the following possible outputs:\n- For \"/api/\": JSON response containing a JWT token or error message\n- For \"/api/private/\": JSON response with protected content or authentication error\n- The server runs continuously on localhost:8080",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar jwtSecret = []byte(\"your_secret_key\")\n\nfunc generateToken(c *gin.Context) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"exp\": time.Now().Add(time.Hour * 72).Unix(),\n\t})\n\ttokenString, err := token.SignedString(jwtSecret)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Could not generate token\"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"token\": tokenString})\n}\n\nfunc jwtMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Authorization header required\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, jwt.ErrSignatureInvalid\n\t\t\t}\n\t\t\treturn jwtSecret, nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n\nfunc privateEndpoint(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome to the private endpoint!\"})\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\t{\n\t\tpublic.GET(\"/\", generateToken)\n\t}\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwtMiddleware())\n\t{\n\t\tprivate.GET(\"/\", privateEndpoint)\n\t}\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements JWT-based authentication with public and private routes. The server should generate tokens for public access and validate them for private routes.\n\nFunction Description: The main function sets up a Gin server with two route groups: public routes that generate JWT tokens, and private routes that require valid JWT tokens for access. The server runs on localhost:8080.\n\nInput: None (The function takes no direct input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens for requests)\n\nMethods:\n\n1. Public route handler: Handles GET requests to \"/api/\" and generates a JWT token\n   - Input: Gin context object\n   - Output: JSON response containing either the token or an error message\n\n2. Private route handler: Handles GET requests to \"/api/private/\" and requires valid JWT\n   - Input: Gin context object (with validated JWT)\n   - Output: JSON response with a private message\n\n3. Server startup: Starts the Gin server on port 8080\n   - Input: Address string (\"localhost:8080\")\n   - Output: None (blocks and serves requests)",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/golang-jwt/jwt/v4\"\n)\n\nvar jwtKey = []byte(\"my_secret_key\")\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tjwt.RegisteredClaims\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\t{\n\t\tpublic.GET(\"/\", generateToken)\n\t}\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(authMiddleware())\n\t{\n\t\tprivate.GET(\"/\", privateEndpoint)\n\t}\n\n\tr.Run(\"localhost:8080\")\n}\n\nfunc generateToken(c *gin.Context) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &Claims{\n\t\tUsername: \"user\",\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(expirationTime),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtKey)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Could not generate token\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\"token\": tokenString})\n}\n\nfunc authMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Authorization header required\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tclaims := &Claims{}\n\t\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn jwtKey, nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Set(\"username\", claims.Username)\n\t\tc.Next()\n\t}\n}\n\nfunc privateEndpoint(c *gin.Context) {\n\tusername := c.MustGet(\"username\").(string)\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome to the private endpoint, \" + username})\n}\n```"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a default Gin engine with logger and recovery middleware, registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- domains: []string - A slice of domain names for which TLS certificates should be obtained (e.g., [\"example1.com\", \"example2.com\"])\n\nOutput: \n- error - Returns an error if the server fails to start, otherwise runs indefinitely (the function will log.Fatal on error)\n\nNote: The function does not explicitly return but will log.Fatal if the server fails to start. The server runs indefinitely when successful.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "import (\n\t\"log\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"net/http\"\n)\n\nfunc runTLSServer(domains []string) {\n\tgin.SetMode(gin.ReleaseMode)\n\trouter := gin.Default()\n\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(domains...),\n\t\tCache:      autocert.DirCache(\"certs\"),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:      \":443\",\n\t\tHandler:   router,\n\t\tTLSConfig: m.TLSConfig(),\n\t}\n\n\tlog.Fatal(server.ListenAndServeTLS(\"\", \"\"))\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Go struct that handles HTTP requests to a metadata service with configurable endpoints, versioning, and resource paths. The struct should support request building, execution, and response handling with retry logic and mock capabilities for testing.\n\nStruct Description: The MetaData struct provides a client for interacting with a metadata service API. It supports building requests with versioning, resource types, and sub-resources, executing requests with retry logic, and decoding responses. It includes mock functionality for testing.\n\nFields:\n- mock: requestMock - A function type for mocking requests during testing\n- client: *http.Client - The HTTP client used to execute requests\n\nMethods:\n- NewMetaData(*http.Client) *MetaData - Constructor that initializes a new MetaData instance with an optional custom HTTP client\n- New() *MetaDataRequest - Creates a new request builder instance\n\nThe MetaDataRequest nested struct handles individual request configuration and execution:\n\nFields:\n- version: string - API version to use (defaults to \"latest\")\n- resourceType: string - Type of resource being accessed (defaults to \"meta-data\")\n- resource: string - Main resource path (required)\n- subResource: string - Optional sub-resource path\n- client: *http.Client - HTTP client for request execution\n- sendRequest: requestMock - Optional mock function for testing\n\nMethods:\n- Version(string) IMetaDataRequest - Sets the API version for the request\n- ResourceType(string) IMetaDataRequest - Sets the resource type for the request\n- Resource(string) IMetaDataRequest - Sets the main resource path\n- SubResource(string) IMetaDataRequest - Sets an optional sub-resource path\n- Url() (string, error) - Constructs the full request URL from components\n- Do(interface{}) error - Executes the request and decodes the response into the provided interface\n- send() (string, error) - Internal method that performs the actual HTTP request\n- Decode(string, interface{}) error - Handles response decoding (implementation not shown in reference)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"os\"\n)\n\ntype MetaData struct {\n\tmock requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tclient:      m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype requestMock func(resource string) (string, error)\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest requestMock\n}\n\nfunc (vpc *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tvpc.version = version\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) ResourceType(rtype string) IMetaDataRequest {\n\tvpc.resourceType = rtype\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tvpc.resource = resource\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) SubResource(sub string) IMetaDataRequest {\n\tvpc.subResource = sub\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Url() (string, error) {\n\tif vpc.version == \"\" {\n\t\tvpc.version = \"latest\"\n\t}\n\tif vpc.resourceType == \"\" {\n\t\tvpc.resourceType = \"meta-data\"\n\t}\n\tif vpc.resource == \"\" {\n\t\treturn \"\", errors.New(\"the resource you want to visit must not be nil!\")\n\t}\n\tendpoint := os.Getenv(\"METADATA_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = \"http://100.100.100.200\"\n\t}\n\tr := fmt.Sprintf(\"%s/%s/%s/%s\", endpoint, vpc.version, vpc.resourceType, vpc.resource)\n\tif vpc.subResource == \"\" {\n\t\treturn r, nil\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", r, vpc.subResource), nil\n}\n\nfunc (vpc *MetaDataRequest) Do(api interface{}) (err error) {\n\tvar res = \"\"\n\tfor r := retry.Start(); r.Next(); {\n\t\tif vpc.sendRequest != nil {\n\t\t\tres, err = vpc.sendRequest(vpc.resource)\n\t\t} else {\n\t\t\tres, err = vpc.send()\n\t\t}\n\t\tif !shouldRetry(err) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn vpc.Decode(res, api)\n}\n\nfunc (vpc *MetaDataRequest) send() (string, error) {\n\turl, err := vpc.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\trequ, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := vpc.client.Do(requ)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", fmt.Errorf(\"Aliyun Metadata API Error: Status Code: %d\", resp.StatusCode)\n\t}\n\tdefer resp.Body.Close()\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage metadata\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype requestMock func(string) (string, error)\n\ntype MetaData struct {\n\tmock   requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{Timeout: 10 * time.Second}\n\t}\n\treturn &MetaData{client: client}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tversion:     \"latest\",\n\t\tresourceType: \"meta-data\",\n\t\tclient:      m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype IMetaDataRequest interface {\n\tVersion(string) IMetaDataRequest\n\tResourceType(string) IMetaDataRequest\n\tResource(string) IMetaDataRequest\n\tSubResource(string) IMetaDataRequest\n\tUrl() (string, error)\n\tDo(interface{}) error\n}\n\ntype MetaDataRequest struct {\n\tversion     string\n\tresourceType string\n\tresource    string\n\tsubResource string\n\tclient      *http.Client\n\tsendRequest requestMock\n}\n\nfunc (r *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tr.version = version\n\treturn r\n}\n\nfunc (r *MetaDataRequest) ResourceType(resourceType string) IMetaDataRequest {\n\tr.resourceType = resourceType\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tr.resource = resource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) SubResource(subResource string) IMetaDataRequest {\n\tr.subResource = subResource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Url() (string, error) {\n\tif r.resource == \"\" {\n\t\treturn \"\", errors.New(\"resource path is required\")\n\t}\n\turl := fmt.Sprintf(\"http://metadata.service/%s/%s/%s\", r.version, r.resourceType, r.resource)\n\tif r.subResource != \"\" {\n\t\turl = fmt.Sprintf(\"%s/%s\", url, r.subResource)\n\t}\n\treturn url, nil\n}\n\nfunc (r *MetaDataRequest) Do(v interface{}) error {\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse, err := r.send()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn r.Decode(response, v)\n}\n\nfunc (r *MetaDataRequest) send() (string, error) {\n\tif r.sendRequest != nil {\n\t\treturn r.sendRequest(r.resource)\n\t}\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := r.client.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}\n\nfunc (r *MetaDataRequest) Decode(response string, v interface{}) error {\n\t// Implementation for decoding the response into v\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Go function that handles file uploads along with form data using the Gin web framework. The function should process multipart form data, save uploaded files, and return a response indicating success or failure.\n\nFunction Description: The function is a Gin route handler that processes POST requests to the \"/upload\" endpoint. It handles multipart/form-data submissions containing both form fields (name and email) and file uploads. The function saves all uploaded files to the server and returns a success message with the count of uploaded files and the form field values, or an error message if the operation fails.\n\nInput: \n- Gin context object (c *gin.Context) containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - File uploads: \"files\" (multipart.FileHeader array)\n\nOutput:\n- On success: HTTP 200 status with success message (string)\n- On failure: HTTP 400 status with error message (string)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc uploadHandler(c *gin.Context) {\n\tname := c.PostForm(\"name\")\n\temail := c.PostForm(\"email\")\n\n\tform, err := c.MultipartForm()\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to parse multipart form\"})\n\t\treturn\n\t}\n\n\tfiles := form.File[\"files\"]\n\tif len(files) == 0 {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No files uploaded\"})\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfilename := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, \"./uploads/\"+filename); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": fmt.Sprintf(\"Failed to save file: %s\", filename)})\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\": fmt.Sprintf(\"Successfully uploaded %d files\", len(files)),\n\t\t\"name\":    name,\n\t\t\"email\":   email,\n\t})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/upload\", uploadHandler)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- None (The function takes no parameters as it's the main entry point)\n\nOutput: \n- None (The function doesn't return but runs an HTTP server indefinitely or until fatal error)\n\nNote: The function uses autotls.Run() which automatically obtains and renews TLS certificates from Let's Encrypt for the specified domains. The server will listen on both HTTP (port 80) and HTTPS (port 443) ports.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"net/http\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example.com\", \"www.example.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:    \":443\",\n\t\tHandler: router,\n\t\tTLSConfig: m.TLSConfig(),\n\t}\n\n\tgo func() {\n\t\thttp.ListenAndServe(\":80\", m.HTTPHandler(nil))\n\t}()\n\n\tserver.ListenAndServeTLS(\"\", \"\")\n}"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Go function that implements a distributed transaction coordinator using HTTP communication between microservices. The function should handle transaction initiation, propagate transaction context, and coordinate between multiple services.\n\nFunction Description: The function serves as an HTTP handler for initiating a distributed transaction. It receives a transaction ID in the header, prepares transaction data for two different services (Account and Inventory), makes HTTP calls to these services, and handles their responses. The function ensures transaction context (xid) is propagated to all participating services.\n\nInput: \n- Gin context object (gin.Context) containing:\n  - HTTP request headers (including \"x_seata_xid\" for transaction ID)\n  - Request body (not used in this example, but could contain transaction details)\n\nOutput:\n- HTTP responses:\n  - 400 Bad Request with error details if any step fails\n  - Original service response if any service fails (non-200 status)\n  - Success response from the last service if all succeed (200 status)\n- Side effects: Makes HTTP calls to two different services with transaction data",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-a/begin\", func(context *gin.Context) {\n\t\txid := context.Request.Header.Get(\"x_seata_xid\")\n\t\taccount := &Account{\n\t\t\tID:     1000024549,\n\t\t\tAmount: 200,\n\t\t}\n\t\tinv := &Inventory{\n\t\t\tID:  1000000005,\n\t\t\tQty: 2,\n\t\t}\n\n\t\taccountReq, err := json.Marshal(account)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tinvReq, err := json.Marshal(inv)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1, err := http.NewRequest(\"POST\", \"http://localhost:2047/service-b/try\", bytes.NewBuffer(accountReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1.Header.Set(\"x_seata_xid\", xid)\n\n\t\treq2, err := http.NewRequest(\"POST\", \"http://localhost:2048/service-c/try\", bytes.NewBuffer(invReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq2.Header.Set(\"x_seata_xid\", xid)\n\n\t\tclient := &http.Client{}\n\t\tresult1, err := client.Do(req1)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result1.StatusCode != http.StatusOK {\n\t\t\tresult1.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\n\t\tresult2, err := client.Do(req2)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result2.StatusCode == http.StatusOK {\n\t\t\tresult2.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n\t\"io/ioutil\"\n)\n\nfunc initiateDistributedTransaction(c *gin.Context) {\n\txid := c.GetHeader(\"x_seata_xid\")\n\tif xid == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Missing transaction ID\"})\n\t\treturn\n\t}\n\n\taccountServiceURL := \"http://account-service/transaction\"\n\tinventoryServiceURL := \"http://inventory-service/transaction\"\n\n\t// Prepare transaction data\n\ttransactionData := map[string]string{\"x_seata_xid\": xid}\n\n\t// Call Account Service\n\tresp, err := http.Post(accountServiceURL, \"application/json\", nil)\n\tif err != nil || resp.StatusCode != http.StatusOK {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Account service failed\", \"details\": err.Error()})\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read Account Service response\n\taccountResponse, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to read account service response\", \"details\": err.Error()})\n\t\treturn\n\t}\n\n\t// Call Inventory Service\n\tresp, err = http.Post(inventoryServiceURL, \"application/json\", nil)\n\tif err != nil || resp.StatusCode != http.StatusOK {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Inventory service failed\", \"details\": err.Error()})\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read Inventory Service response\n\tinventoryResponse, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to read inventory service response\", \"details\": err.Error()})\n\t\treturn\n\t}\n\n\t// Success response\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"account_response\":  string(accountResponse),\n\t\t\"inventory_response\": string(inventoryResponse),\n\t})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/initiate-transaction\", initiateDistributedTransaction)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a function that demonstrates asynchronous message production to a Kafka topic using the Sarama library in Go. The function should continuously generate and send messages at regular intervals while handling both successful deliveries and errors.\n\nFunction Description: The SaramaProducer function initializes and manages an asynchronous Kafka producer. It configures the producer with specific settings, handles message delivery success/failure notifications in a separate goroutine, and continuously generates and sends messages to a specified Kafka topic. The function runs indefinitely until terminated.\n\nInput: None (The function takes no input parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function doesn't return any value but prints success/error messages to stdout)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc SaramaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tconfig.Producer.Retry.Max = 1000\n\tconfig.Version = sarama.V2_2_0_0\n\n\tproducer, e := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif e != nil {\n\t\tfmt.Println(e)\n\t\treturn\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func(p sarama.AsyncProducer) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase suc := <-p.Successes():\n\t\t\t\tfmt.Println(\"offset: \", suc.Offset, \"timestamp: \", suc.Timestamp.String(), \"partitions: \", suc.Partition)\n\t\t\tcase fail := <-p.Errors():\n\t\t\t\tfmt.Println(\"err: \", fail.Err)\n\t\t\t}\n\t\t}\n\t}(producer)\n\n\tvar value string\n\tfor i := 0; ; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\ttime11 := time.Now()\n\t\tvalue = \"this is a message 0606 \" + time11.Format(\"15:04:05\")\n\t\tmsg := &sarama.ProducerMessage{\n\t\t\tTopic: \"0606_test\",\n\t\t}\n\t\tmsg.Value = sarama.ByteEncoder(value)\n\t\tfmt.Println(value)\n\t\tproducer.Input() <- msg\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc SaramaProducer() {\n\tbrokers := []string{\"localhost:9092\"}\n\ttopic := \"example_topic\"\n\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Retry.Max = 5\n\n\tproducer, err := sarama.NewAsyncProducer(brokers, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start Sarama producer: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := producer.Close(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to close Sarama producer: %v\", err)\n\t\t}\n\t}()\n\n\tsignals := make(chan os.Signal, 1)\n\tsignal.Notify(signals, os.Interrupt)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase success := <-producer.Successes():\n\t\t\t\tfmt.Printf(\"Message sent to partition %d at offset %d\\n\", success.Partition, success.Offset)\n\t\t\tcase err := <-producer.Errors():\n\t\t\t\tfmt.Printf(\"Failed to send message: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tmessageCount := 0\n\tfor {\n\t\tmessage := &sarama.ProducerMessage{\n\t\t\tTopic: topic,\n\t\t\tValue: sarama.StringEncoder(fmt.Sprintf(\"Message #%d\", messageCount)),\n\t\t}\n\t\tselect {\n\t\tcase producer.Input() <- message:\n\t\t\tmessageCount++\n\t\tcase <-signals:\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc main() {\n\tSaramaProducer()\n}\n```"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a function that implements an asynchronous Kafka producer in Go, which continuously sends messages to a specified Kafka topic at regular intervals. The function should handle both success and error cases from the producer and properly clean up resources when done.\n\nFunction Description: The function `runAsyncKafkaProducer` initializes and manages an asynchronous Kafka producer that sends alternating message types (\"login\" and \"msg\" events) to a Kafka topic every 10 seconds. It configures the producer with appropriate settings, handles success/error notifications in a separate goroutine, and ensures proper resource cleanup.\n\nInput: None (The function takes no parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function runs indefinitely until terminated, printing success/error messages to stdout)\n\nReference Code Structure:\n\n```go\nfunc runAsyncKafkaProducer() {\n    // 1. Configure Kafka producer\n    config := sarama.NewConfig()\n    config.Producer.RequiredAcks = sarama.WaitForAll\n    config.Producer.Partitioner = sarama.NewRandomPartitioner\n    config.Producer.Return.Successes = true\n    config.Producer.Return.Errors = true\n    \n    // 2. Initialize async producer\n    producer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n    if err != nil {\n        panic(err)\n    }\n    defer producer.AsyncClose()\n    \n    // 3. Start goroutine to handle producer events\n    go func() {\n        for {\n            select {\n            case success := <-producer.Successes():\n                fmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n                    success.Topic, success.Partition, success.Offset)\n            case err := <-producer.Errors():\n                fmt.Printf(\"Failed to send message: %v\\n\", err)\n            }\n        }\n    }()\n    \n    // 4. Main message sending loop\n    var messageType int = 1\n    for {\n        msg := createMessage(messageType)\n        producer.Input() <- msg\n        \n        messageType = toggleMessageType(messageType)\n        time.Sleep(10 * time.Second)\n    }\n}\n\n// Helper functions would be defined here...\n```",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc main() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tAsyncProducer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer AsyncProducer.AsyncClose()\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase succ := <-AsyncProducer.Successes():\n\t\t\t\tfmt.Println(\"AsyncProducer.Successes()\", succ.Topic, succ.Offset, succ.Timestamp, succ.Partition)\n\t\t\tcase err := <-AsyncProducer.Errors():\n\t\t\t\tfmt.Println(\"AsyncProducer.Errors()\", err.Error())\n\t\t\t}\n\t\t}\n\t}()\n\tvar i = 1\n\tfor {\n\t\tMessage := &sarama.ProducerMessage{\n\t\t\tTopic:     \"msg_event\",\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tvar data []byte\n\t\tdate := time.Now().UnixNano() / 1e6\n\t\tif i == 1 {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"11\",\n\t\t\t\t\"uid\":         1,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"login\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 2\n\t\t} else {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"22\",\n\t\t\t\t\"uid\":         222222,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"msg\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 1\n\t\t}\n\n\t\tMessage.Value = sarama.ByteEncoder(data)\n\t\tAsyncProducer.Input() <- Message\n\t\ttime.Sleep(time.Second * 10)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc runAsyncKafkaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\n\tproducer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase success := <-producer.Successes():\n\t\t\t\tfmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n\t\t\t\t\tsuccess.Topic, success.Partition, success.Offset)\n\t\t\tcase err := <-producer.Errors():\n\t\t\t\tfmt.Printf(\"Failed to send message: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar messageType int = 1\n\tfor {\n\t\tmsg := createMessage(messageType)\n\t\tproducer.Input() <- msg\n\n\t\tmessageType = toggleMessageType(messageType)\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}\n\nfunc createMessage(messageType int) *sarama.ProducerMessage {\n\tvar messageValue string\n\tif messageType == 1 {\n\t\tmessageValue = \"login event\"\n\t} else {\n\t\tmessageValue = \"msg event\"\n\t}\n\treturn &sarama.ProducerMessage{\n\t\tTopic: \"example-topic\",\n\t\tValue: sarama.StringEncoder(messageValue),\n\t}\n}\n\nfunc toggleMessageType(currentType int) int {\n\tif currentType == 1 {\n\t\treturn 2\n\t}\n\treturn 1\n}\n\nfunc main() {\n\trunAsyncKafkaProducer()\n}\n```"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.\n\nTask Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"testing\"\n)\n\nfunc TestKafkaSyncProducer(t *testing.T) {\n\tconf := sarama.NewConfig()\n\tconf.Producer.RequiredAcks = sarama.WaitForAll\n\tconf.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconf.Producer.Return.Successes = true\n\tconf.Producer.Return.Errors = true\n\tconf.Producer.Retry.Max = 1000\n\tconf.Version = sarama.V2_8_0_0\n\tproducer, err := sarama.NewSyncProducer([]string{\"172.12.12.165:9092\"}, conf)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer producer.Close()\n\tfmt.Println(producer.SendMessage(&sarama.ProducerMessage{\n\t\tTopic: \"gs_pay_transaction_topic\",\n\t\tValue: sarama.ByteEncoder(\"123123\"),\n\t}))\n\tselect {}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 123,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"github.com/confluentinc/confluent-kafka-go/kafka\"\n)\n\nfunc sendKafkaMessage() {\n\t// Kafka configuration\n\tconfig := &kafka.ConfigMap{\n\t\t\"bootstrap.servers\": \"localhost:9092\",\n\t}\n\n\t// Create a new producer\n\tproducer, err := kafka.NewProducer(config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create producer: %s\\n\", err)\n\t\treturn\n\t}\n\tdefer producer.Close()\n\n\t// Define the topic and message\n\ttopic := \"test_topic\"\n\tmessage := \"Hello Kafka\"\n\n\t// Delivery report channel\n\tdeliveryChan := make(chan kafka.Event)\n\n\t// Produce the message\n\terr = producer.Produce(&kafka.Message{\n\t\tTopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\n\t\tValue:          []byte(message),\n\t}, deliveryChan)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to produce message: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Wait for delivery report\n\te := <-deliveryChan\n\tm := e.(*kafka.Message)\n\n\tif m.TopicPartition.Error != nil {\n\t\tfmt.Printf(\"Failed to deliver message: %v\\n\", m.TopicPartition.Error)\n\t} else {\n\t\tfmt.Printf(\"Message delivered to topic %s [%d] at offset %v\\n\", *m.TopicPartition.Topic, m.TopicPartition.Partition, m.TopicPartition.Offset)\n\t}\n\n\tclose(deliveryChan)\n}\n\nfunc main() {\n\tsendKafkaMessage()\n}\n```"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Implement a TCP/UDP port scanner with proxy support and configurable source IP addresses.\n\nStruct Description: The Scanner struct provides functionality to check if a specific port is open on a given host, supporting both TCP and UDP protocols. It includes timeout configuration, proxy support, and the ability to specify source IP addresses for the connection.\n\nFields:\n- timeout: time.Duration - Maximum duration to wait for a connection attempt\n- proxyDialer: proxy.Dialer - Optional proxy dialer for making connections through a proxy\n- ListenHandler: *ListenHandler - Configuration for source IP addresses (both IPv4 and IPv6)\n\nMethods:\n- ConnectPort: (host string, p *port.Port, timeout time.Duration) -> (bool, error) - Attempts to connect to the specified port on the given host. Returns true if the port is open/reachable, along with any error that occurred during the connection attempt. The port parameter includes the protocol (TCP/UDP) and port number. The timeout parameter specifies the maximum duration for the connection attempt.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\thostport := net.JoinHostPort(host, fmt.Sprint(p.Port))\n\tvar (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\tif s.proxyDialer != nil {\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t\tproxyDialer, ok := s.proxyDialer.(proxy.ContextDialer)\n\t\tif !ok {\n\t\t\treturn false, errors.New(\"invalid proxy dialer\")\n\t\t}\n\t\tconn, err = proxyDialer.DialContext(ctx, p.Protocol.String(), hostport)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tnetDialer := net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t\tif s.ListenHandler.SourceIp4 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIp4}\n\t\t} else if s.ListenHandler.SourceIP6 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIP6}\n\t\t}\n\t\tconn, err = netDialer.Dial(p.Protocol.String(), hostport)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\tswitch p.Protocol {\n\tcase protocol.UDP:\n\t\tif err := conn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif _, err := conn.Write(nil); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif err := conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tn, err := io.Copy(io.Discard, conn)\n\t\tif err != nil && !os.IsTimeout(err) {\n\t\t\treturn false, err\n\t\t}\n\t\treturn n > 0, nil\n\t}\n\n\treturn true, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Port struct {\n\tProtocol string\n\tNumber   int\n}\n\ntype ListenHandler struct {\n\tSourceIPv4 string\n\tSourceIPv6 string\n}\n\ntype Scanner struct {\n\ttimeout       time.Duration\n\tproxyDialer   proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *Port, timeout time.Duration) (bool, error) {\n\tvar dialer net.Dialer\n\tif s.ListenHandler != nil {\n\t\tif p.Protocol == \"tcp\" {\n\t\t\tdialer = net.Dialer{\n\t\t\t\tTimeout: timeout,\n\t\t\t\tLocalAddr: &net.TCPAddr{\n\t\t\t\t\tIP: net.ParseIP(s.ListenHandler.SourceIPv4),\n\t\t\t\t},\n\t\t\t}\n\t\t} else if p.Protocol == \"udp\" {\n\t\t\tdialer = net.Dialer{\n\t\t\t\tTimeout: timeout,\n\t\t\t\tLocalAddr: &net.UDPAddr{\n\t\t\t\t\tIP: net.ParseIP(s.ListenHandler.SourceIPv4),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.proxyDialer != nil {\n\t\tdialer = net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t}\n\n\taddress := net.JoinHostPort(host, string(p.Number))\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tvar conn net.Conn\n\tvar err error\n\n\tif s.proxyDialer != nil {\n\t\tconn, err = s.proxyDialer.DialContext(ctx, p.Protocol, address)\n\t} else {\n\t\tconn, err = dialer.DialContext(ctx, p.Protocol, address)\n\t}\n\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\treturn true, nil\n}\n\nfunc main() {\n\t// Example usage\n\tscanner := &Scanner{\n\t\ttimeout: 5 * time.Second,\n\t\tListenHandler: &ListenHandler{\n\t\t\tSourceIPv4: \"192.168.1.100\",\n\t\t},\n\t}\n\n\tport := &Port{\n\t\tProtocol: \"tcp\",\n\t\tNumber:   80,\n\t}\n\n\topen, err := scanner.ConnectPort(\"example.com\", port, 5*time.Second)\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else if open {\n\t\tprintln(\"Port is open\")\n\t} else {\n\t\tprintln(\"Port is closed\")\n\t}\n}\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Create a function that uploads a video file to a specified URL using a multipart/form-data POST request with custom headers.\n\nFunction Description: The function uploads a video file to a given URL with specified form fields and authentication headers. It handles file operations, creates a multipart form payload, sets appropriate headers (including content type and access token), executes the HTTP request, and returns the response body.\n\nInput:\n- url (string): The target URL for the video upload\n- method (string): HTTP method (typically \"POST\")\n- advertiserID (string): The advertiser ID for the form field\n- uploadType (string): The upload type for the form field\n- videoSignature (string): The video signature for the form field\n- filePath (string): Path to the video file to upload\n- accessToken (string): Access token for authentication header\n\nOutput:\n- ([]byte, error): Returns the response body as bytes and any error that occurred during execution\n\nNote: The function should follow the same steps as the reference code, including creating a custom http.Client, setting headers, handling multipart form data, and properly managing resources (file handles, response bodies).",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"video_signature\", \"6b12a8bbbe8e69a2ef5929028b0b50c3\")\n\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\")\n\tdefer file.Close()\n\n\tpart4, errFile4 := writer.CreateFormFile(\"video_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadVideo(url, method, advertiserID, uploadType, videoSignature, filePath, accessToken string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tif err := writer.WriteField(\"advertiser_id\", advertiserID); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write advertiser_id field: %w\", err)\n\t}\n\tif err := writer.WriteField(\"upload_type\", uploadType); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write upload_type field: %w\", err)\n\t}\n\tif err := writer.WriteField(\"video_signature\", videoSignature); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write video_signature field: %w\", err)\n\t}\n\n\tpart, err := writer.CreateFormFile(\"video_file\", filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create form file: %w\", err)\n\t}\n\tif _, err := io.Copy(part, file); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to copy file content: %w\", err)\n\t}\n\n\tif err := writer.Close(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to close writer: %w\", err)\n\t}\n\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\treturn respBody, nil\n}\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP client in Go that establishes a connection to a server, handles data transmission, and manages connection lifecycle with proper error handling and resource cleanup.\n\nStruct Description: The `Client` struct represents a TCP client that connects to a server using a round-robin server selection strategy. It manages server connections, handles policy enforcement, and processes data transmission for both TCP and UDP protocols.\n\nFields:\n- serverPicker: [protocol.ServerPicker] - Selects servers in a round-robin fashion from available server list  \n- policyManager: [policy.Manager] - Manages connection policies including timeouts and user levels\n\nMethods:\n- NewClient: [func(ctx context.Context, config *ClientConfig) (*Client, error)] -> (*Client, error) - Creates a new Client instance with server configurations and policy manager\n- Process: [func(ctx context.Context, link *transport.Link, dialer internet.Dialer) error] -> error - Main processing method that establishes connection, handles handshake, and manages data transfer between client and server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/xtls/xray-core/common\"\n\t\"github.com/xtls/xray-core/common/buf\"\n\t\"github.com/xtls/xray-core/common/errors\"\n\t\"github.com/xtls/xray-core/common/net\"\n\t\"github.com/xtls/xray-core/common/protocol\"\n\t\"github.com/xtls/xray-core/common/retry\"\n\t\"github.com/xtls/xray-core/common/session\"\n\t\"github.com/xtls/xray-core/common/signal\"\n\t\"github.com/xtls/xray-core/common/task\"\n\t\"github.com/xtls/xray-core/core\"\n\t\"github.com/xtls/xray-core/features/policy\"\n\t\"github.com/xtls/xray-core/transport\"\n\t\"github.com/xtls/xray-core/transport/internet\"\n\t\"github.com/xtls/xray-core/transport/internet/stat\"\n)\n\ntype Client struct {\n\tserverPicker  protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tserverList := protocol.NewServerList()\n\tfor _, rec := range config.Server {\n\t\ts, err := protocol.NewServerSpecFromPB(rec)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"failed to get server spec\").Base(err)\n\t\t}\n\t\tserverList.AddServer(s)\n\t}\n\tif serverList.Size() == 0 {\n\t\treturn nil, errors.New(\"0 target server\")\n\t}\n\n\tv := core.MustFromContext(ctx)\n\tc := &Client{\n\t\tserverPicker:  protocol.NewRoundRobinServerPicker(serverList),\n\t\tpolicyManager: v.GetFeature(policy.ManagerType()).(policy.Manager),\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\toutbounds := session.OutboundsFromContext(ctx)\n\tob := outbounds[len(outbounds)-1]\n\tif !ob.Target.IsValid() {\n\t\treturn errors.New(\"target not specified.\")\n\t}\n\tob.Name = \"socks\"\n\tob.CanSpliceCopy = 2\n\tdestination := ob.Target\n\n\tvar server *protocol.ServerSpec\n\tvar dest net.Destination\n\tvar conn stat.Connection\n\n\tif err := retry.ExponentialBackoff(5, 100).On(func() error {\n\t\tserver = c.serverPicker.PickServer()\n\t\tdest = server.Destination()\n\t\trawConn, err := dialer.Dial(ctx, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconn = rawConn\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn errors.New(\"failed to find an available destination\").Base(err)\n\t}\n\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\terrors.LogInfoInner(ctx, err, \"failed to closed connection\")\n\t\t}\n\t}()\n\n\tp := c.policyManager.ForLevel(0)\n\n\trequest := &protocol.RequestHeader{\n\t\tVersion: socks5Version,\n\t\tCommand: protocol.RequestCommandTCP,\n\t\tAddress: destination.Address,\n\t\tPort:    destination.Port,\n\t}\n\n\tif destination.Network == net.Network_UDP {\n\t\trequest.Command = protocol.RequestCommandUDP\n\t}\n\n\tuser := server.PickUser()\n\tif user != nil {\n\t\trequest.User = user\n\t\tp = c.policyManager.ForLevel(user.Level)\n\t}\n\n\tif err := conn.SetDeadline(time.Now().Add(p.Timeouts.Handshake)); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to set deadline for handshake\")\n\t}\n\tudpRequest, err := ClientHandshake(request, conn, conn)\n\tif err != nil {\n\t\treturn errors.New(\"failed to establish connection to server\").AtWarning().Base(err)\n\t}\n\tif udpRequest != nil {\n\t\tif udpRequest.Address == net.AnyIP || udpRequest.Address == net.AnyIPv6 {\n\t\t\tudpRequest.Address = dest.Address\n\t\t}\n\t}\n\n\tif err := conn.SetDeadline(time.Time{}); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to clear deadline after handshake\")\n\t}\n\n\tvar newCtx context.Context\n\tvar newCancel context.CancelFunc\n\tif session.TimeoutOnlyFromContext(ctx) {\n\t\tnewCtx, newCancel = context.WithCancel(context.Background())\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\ttimer := signal.CancelAfterInactivity(ctx, func() {\n\t\tcancel()\n\t\tif newCancel != nil {\n\t\t\tnewCancel()\n\t\t}\n\t}, p.Timeouts.ConnectionIdle)\n\n\tvar requestFunc func() error\n\tvar responseFunc func() error\n\tif request.Command == protocol.RequestCommandTCP {\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\treturn buf.Copy(link.Reader, buf.NewWriter(conn), buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treturn buf.Copy(buf.NewReader(conn), link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t} else if request.Command == protocol.RequestCommandUDP {\n\t\tudpConn, err := dialer.Dial(ctx, udpRequest.Destination())\n\t\tif err != nil {\n\t\t\treturn errors.New(\"failed to create UDP connection\").Base(err)\n\t\t}\n\t\tdefer udpConn.Close()\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\twriter := &UDPWriter{Writer: udpConn, Request: request}\n\t\t\treturn buf.Copy(link.Reader, writer, buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treader := &UDPReader{Reader: udpConn}\n\t\t\treturn buf.Copy(reader, link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t}\n\n\tif newCtx != nil {\n\t\tctx = newCtx\n\t}\n\n\tresponseDonePost := task.OnSuccess(responseFunc, task.Close(link.Writer))\n\tif err := task.Run(ctx, requestFunc, responseDonePost); err != nil {\n\t\treturn errors.New(\"connection ends\").Base(err)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype ServerPicker interface {\n\tPickServer() (string, error)\n}\n\ntype PolicyManager interface {\n\tEnforcePolicy(ctx context.Context) error\n}\n\ntype ClientConfig struct {\n\tServers       []string\n\tTimeout       time.Duration\n\tPolicyManager PolicyManager\n}\n\ntype Client struct {\n\tserverPicker  ServerPicker\n\tpolicyManager PolicyManager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tif len(config.Servers) == 0 {\n\t\treturn nil, fmt.Errorf(\"no servers provided\")\n\t}\n\tserverPicker := NewRoundRobinPicker(config.Servers)\n\treturn &Client{\n\t\tserverPicker:  serverPicker,\n\t\tpolicyManager: config.PolicyManager,\n\t}, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\tif err := c.policyManager.EnforcePolicy(ctx); err != nil {\n\t\treturn fmt.Errorf(\"policy enforcement failed: %w\", err)\n\t}\n\n\tserver, err := c.serverPicker.PickServer()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to pick server: %w\", err)\n\t}\n\n\tconn, err := dialer.DialContext(ctx, \"tcp\", server)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to server: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tif err := c.handleHandshake(conn); err != nil {\n\t\treturn fmt.Errorf(\"handshake failed: %w\", err)\n\t}\n\n\tif err := c.transferData(ctx, conn, link); err != nil {\n\t\treturn fmt.Errorf(\"data transfer failed: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (c *Client) handleHandshake(conn net.Conn) error {\n\t// Implement handshake logic here\n\treturn nil\n}\n\nfunc (c *Client) transferData(ctx context.Context, conn net.Conn, link *transport.Link) error {\n\t// Implement data transfer logic here\n\treturn nil\n}\n\ntype RoundRobinPicker struct {\n\tservers []string\n\tindex   int\n}\n\nfunc NewRoundRobinPicker(servers []string) *RoundRobinPicker {\n\treturn &RoundRobinPicker{servers: servers}\n}\n\nfunc (p *RoundRobinPicker) PickServer() (string, error) {\n\tif len(p.servers) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no servers available\")\n\t}\n\tserver := p.servers[p.index]\n\tp.index = (p.index + 1) % len(p.servers)\n\treturn server, nil\n}\n\ntype transport struct{}\n\ntype Link struct{}\n\ntype internet struct{}\n\ntype Dialer interface {\n\tDialContext(ctx context.Context, network, address string) (net.Conn, error)\n}\n```"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Implement a TCP client in Go that periodically sends metrics data to an OpenTSDB server, handling different types of metrics (counters, gauges, histograms, meters, and timers) with appropriate formatting.\n\nStruct Description: The OpenTSDBConfig struct contains configuration parameters for connecting to an OpenTSDB server and sending metrics data at regular intervals.\n\nFields:\nAddr: *net.TCPAddr - The TCP address of the OpenTSDB server\nRegistry: Registry - The metrics registry containing all metrics to be reported\nFlushInterval: time.Duration - The interval at which metrics are sent to the server\nDurationUnit: time.Duration - The time unit for converting timer metrics\nPrefix: string - The prefix to be added to all metric names\n\nMethods:\nOpenTSDBWithConfig: OpenTSDBWithConfig(c OpenTSDBConfig) - Starts a ticker that periodically calls openTSDB with the given configuration at the specified FlushInterval\nopenTSDB: openTSDB(c *OpenTSDBConfig) error - Establishes a TCP connection to the OpenTSDB server, formats and sends all metrics from the registry, and returns any error that occurs during the process",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\ntype OpenTSDBConfig struct {\n\tAddr          *net.TCPAddr\n\tRegistry      Registry\n\tFlushInterval time.Duration\n\tDurationUnit  time.Duration\n\tPrefix        string\n}\n\nfunc OpenTSDBWithConfig(c OpenTSDBConfig) {\n\tfor _ = range time.Tick(c.FlushInterval) {\n\t\tif err := openTSDB(&c); nil != err {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\nfunc openTSDB(c *OpenTSDBConfig) error {\n\tshortHostname := getShortHostname()\n\tnow := time.Now().Unix()\n\tdu := float64(c.DurationUnit)\n\tconn, err := net.DialTCP(\"tcp\", nil, c.Addr)\n\tif nil != err {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tw := bufio.NewWriter(conn)\n\tc.Registry.Each(func(name string, i interface{}) {\n\t\tswitch metric := i.(type) {\n\t\tcase Counter:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, metric.Count(), shortHostname)\n\t\tcase Gauge:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %d host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase GaugeFloat64:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %f host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase Histogram:\n\t\t\th := metric.Snapshot()\n\t\t\tps := h.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, h.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, h.Min(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, h.Max(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, h.Mean(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, h.StdDev(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4], shortHostname)\n\t\tcase Meter:\n\t\t\tm := metric.Snapshot()\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, m.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, m.RateMean(), shortHostname)\n\t\tcase Timer:\n\t\t\tt := metric.Snapshot()\n\t\t\tps := t.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, t.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, t.Min()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, t.Max()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, t.Mean()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, t.StdDev()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean-rate %d %.2f host=%s\\n\", c.Prefix, name, now, t.RateMean(), shortHostname)\n\t\t}\n\t\tw.Flush()\n\t})\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Registry interface {\n\tEach(func(string, interface{}))\n}\n\ntype OpenTSDBConfig struct {\n\tAddr          *net.TCPAddr\n\tRegistry      Registry\n\tFlushInterval time.Duration\n\tDurationUnit  time.Duration\n\tPrefix        string\n}\n\nfunc OpenTSDBWithConfig(c OpenTSDBConfig) {\n\tticker := time.NewTicker(c.FlushInterval)\n\tdefer ticker.Stop()\n\tfor range ticker.C {\n\t\tif err := openTSDB(&c); err != nil {\n\t\t\tfmt.Println(\"Error sending metrics:\", err)\n\t\t}\n\t}\n}\n\nfunc openTSDB(c *OpenTSDBConfig) error {\n\tconn, err := net.DialTCP(\"tcp\", nil, c.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tnow := time.Now().Unix()\n\tc.Registry.Each(func(name string, i interface{}) {\n\t\tvar value float64\n\t\tswitch metric := i.(type) {\n\t\tcase Counter:\n\t\t\tvalue = float64(metric.Count())\n\t\tcase Gauge:\n\t\t\tvalue = metric.Value()\n\t\tcase Histogram:\n\t\t\tvalue = metric.Mean()\n\t\tcase Meter:\n\t\t\tvalue = metric.Rate1()\n\t\tcase Timer:\n\t\t\tvalue = metric.Mean() / float64(c.DurationUnit)\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t\tmetricName := fmt.Sprintf(\"%s%s\", c.Prefix, name)\n\t\tfmt.Fprintf(conn, \"put %s %d %f\\n\", metricName, now, value)\n\t})\n\n\treturn nil\n}\n\ntype Counter interface {\n\tCount() int64\n}\n\ntype Gauge interface {\n\tValue() float64\n}\n\ntype Histogram interface {\n\tMean() float64\n}\n\ntype Meter interface {\n\tRate1() float64\n}\n\ntype Timer interface {\n\tMean() float64\n}\n\nfunc main() {\n\t// Example usage\n\taddr, _ := net.ResolveTCPAddr(\"tcp\", \"localhost:4242\")\n\tconfig := OpenTSDBConfig{\n\t\tAddr:          addr,\n\t\tRegistry:      nil, // Replace with actual registry\n\t\tFlushInterval: 10 * time.Second,\n\t\tDurationUnit:  time.Millisecond,\n\t\tPrefix:        \"myapp.\",\n\t}\n\tgo OpenTSDBWithConfig(config)\n\n\tselect {} // Run indefinitely\n}\n```"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Implement a TCP client in Go that can establish connections to servers, handle TLS if required, and manage timeouts for network operations.\n\nStruct Description: The Client struct represents a configurable TCP client capable of handling both plain TCP and TLS connections, with various timeout controls and DNS message exchange functionality.\n\nFields:\n\nNet: string - Network type (e.g., \"tcp\", \"tcp-tls\", \"udp\")\nUDPSize: uint16 - UDP buffer size for DNS messages\nTLSConfig: *tls.Config - TLS configuration for secure connections\nDialer: *net.Dialer - Custom dialer for connection establishment\nTimeout: time.Duration - Overall operation timeout\nDialTimeout: time.Duration - Timeout specifically for connection establishment\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nTsigSecret: map[string]string - TSIG authentication secrets\nSingleInflight: bool - Whether to use singleflight for duplicate request suppression\ngroup: singleflight - Internal singleflight group for request deduplication\n\nMethods:\n\nDial: (address string) -> (*Conn, error) - Establishes a connection to the specified address, handling TLS if configured\nExchange: (m *Msg, address string) -> (*Msg, time.Duration, error) - Performs a complete DNS message exchange with timeout handling\nexchange: (m *Msg, a string) -> (*Msg, time.Duration, error) - Internal method for performing the actual message exchange\ngetTimeoutForRequest: (timeout time.Duration) -> time.Duration - Calculates the appropriate timeout for a request considering various configuration options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tNet       string\n\tUDPSize   uint16\n\tTLSConfig *tls.Config\n\tDialer    *net.Dialer\n\tTimeout   time.Duration\n\tDialTimeout    time.Duration\n\tReadTimeout    time.Duration\n\tWriteTimeout   time.Duration\n\tTsigSecret     map[string]string\n\tSingleInflight bool\n\tgroup          singleflight\n}\n\nfunc (c *Client) Dial(address string) (conn *Conn, err error) {\n\tvar d net.Dialer\n\tif c.Dialer == nil {\n\t\td = net.Dialer{Timeout: c.getTimeoutForRequest(c.dialTimeout())}\n\t} else {\n\t\td = *c.Dialer\n\t}\n\n\tnetwork := c.Net\n\tif network == \"\" {\n\t\tnetwork = \"udp\"\n\t}\n\n\tuseTLS := strings.HasPrefix(network, \"tcp\") && strings.HasSuffix(network, \"-tls\")\n\n\tconn = new(Conn)\n\tif useTLS {\n\t\tnetwork = strings.TrimSuffix(network, \"-tls\")\n\t\tconn.Conn, err = tls.DialWithDialer(&d, network, address, c.TLSConfig)\n\t} else {\n\t\tconn.Conn, err = d.Dial(network, address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (r *Msg, rtt time.Duration, err error) {\n\tif !c.SingleInflight {\n\t\treturn c.exchange(m, address)\n\t}\n\n\tq := m.Question[0]\n\tkey := fmt.Sprintf(\"%s:%d:%d\", q.Name, q.Qtype, q.Qclass)\n\tr, rtt, err, shared := c.group.Do(key, func() (*Msg, time.Duration, error) {\n\t\treturn c.exchange(m, address)\n\t})\n\tif r != nil && shared {\n\t\tr = r.Copy()\n\t}\n\n\treturn r, rtt, err\n}\n\nfunc (c *Client) exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {\n\tvar co *Conn\n\n\tco, err = c.Dial(a)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer co.Close()\n\n\topt := m.IsEdns0()\n\tif opt != nil && opt.UDPSize() >= MinMsgSize {\n\t\tco.UDPSize = opt.UDPSize()\n\t}\n\tif opt == nil && c.UDPSize >= MinMsgSize {\n\t\tco.UDPSize = c.UDPSize\n\t}\n\n\tco.TsigSecret = c.TsigSecret\n\tt := time.Now()\n\tco.SetWriteDeadline(t.Add(c.getTimeoutForRequest(c.writeTimeout())))\n\tif err = co.WriteMsg(m); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tco.SetReadDeadline(time.Now().Add(c.getTimeoutForRequest(c.readTimeout())))\n\tr, err = co.ReadMsg()\n\tif err == nil && r.Id != m.Id {\n\t\terr = ErrId\n\t}\n\trtt = time.Since(t)\n\treturn r, rtt, err\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tvar requestTimeout time.Duration\n\tif c.Timeout != 0 {\n\t\trequestTimeout = c.Timeout\n\t} else {\n\t\trequestTimeout = timeout\n\t}\n\tif c.Dialer != nil && c.Dialer.Timeout != 0 {\n\t\tif c.Dialer.Timeout < requestTimeout {\n\t\t\trequestTimeout = c.Dialer.Timeout\n\t\t}\n\t}\n\treturn requestTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n\n\t\"golang.org/x/sync/singleflight\"\n)\n\ntype Client struct {\n\tNet            string\n\tUDPSize        uint16\n\tTLSConfig      *tls.Config\n\tDialer         *net.Dialer\n\tTimeout        time.Duration\n\tDialTimeout    time.Duration\n\tReadTimeout    time.Duration\n\tWriteTimeout   time.Duration\n\tTsigSecret     map[string]string\n\tSingleInflight bool\n\tgroup          singleflight.Group\n}\n\ntype Conn struct {\n\tnet.Conn\n}\n\ntype Msg struct {\n\t// DNS message fields\n}\n\nfunc (c *Client) Dial(address string) (*Conn, error) {\n\tvar conn net.Conn\n\tvar err error\n\n\tdialer := c.Dialer\n\tif dialer == nil {\n\t\tdialer = &net.Dialer{Timeout: c.DialTimeout}\n\t}\n\n\tswitch c.Net {\n\tcase \"tcp-tls\":\n\t\tconn, err = tls.DialWithDialer(dialer, \"tcp\", address, c.TLSConfig)\n\tcase \"tcp\":\n\t\tconn, err = dialer.Dial(\"tcp\", address)\n\tcase \"udp\":\n\t\tconn, err = dialer.Dial(\"udp\", address)\n\tdefault:\n\t\treturn nil, err\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Conn{conn}, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (*Msg, time.Duration, error) {\n\tif c.SingleInflight {\n\t\tv, err, _ := c.group.Do(address, func() (interface{}, error) {\n\t\t\treturn c.exchange(m, address)\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\t\tresult := v.(*Msg)\n\t\treturn result, 0, nil\n\t}\n\treturn c.exchange(m, address)\n}\n\nfunc (c *Client) exchange(m *Msg, address string) (*Msg, time.Duration, error) {\n\tconn, err := c.Dial(address)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer conn.Close()\n\n\tstart := time.Now()\n\tconn.SetDeadline(time.Now().Add(c.getTimeoutForRequest(c.Timeout)))\n\n\t// Send and receive DNS message logic here\n\n\tduration := time.Since(start)\n\treturn m, duration, nil\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tif timeout > 0 {\n\t\treturn timeout\n\t}\n\treturn c.Timeout\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a Git daemon in Go that handles TCP connections for Git operations, including upload-pack and upload-archive services, with connection management, timeout handling, and access control.\n\nStruct Description: The GitDaemon struct represents a TCP server that handles Git protocol connections. It manages client connections, enforces limits, and processes Git service requests.\n\nFields:\n\nctx: [context.Context] - Context for cancellation and timeout propagation  \naddr: [string] - TCP address to listen on  \nfinished: [chan struct{}] - Channel to signal server shutdown  \nconns: [connections] - Track active connections (wrapper around map[net.Conn]struct{})  \ncfg: [*config.Config] - Server configuration  \nbe: [*backend.Backend] - Backend for repository access and authentication  \nwg: [sync.WaitGroup] - Wait group for graceful shutdown  \nonce: [sync.Once] - Ensure cleanup happens once  \nlogger: [*log.Logger] - Structured logger  \ndone: [atomic.Bool] - Atomic flag indicating server shutdown status  \n\nMethods:\n\nNewGitDaemon: [func(context.Context) (*GitDaemon, error)] -> Creates a new GitDaemon instance with context-derived configuration  \nListenAndServe: [func() error] -> Starts listening on configured address and serves connections  \nServe: [func(net.Listener) error] -> Handles incoming connections on provided listener (main server loop)  \nhandleClient: [func(net.Conn)] -> Processes individual client connections (private method)  \n\nHelper Types:\n\nserverConn: [struct] - Wraps net.Conn with timeout handling  \nconnections: [struct] - Thread-safe connection tracking with sync.Map  \n\nKey Behaviors:\n1. Implements exponential backoff for temporary connection errors\n2. Enforces maximum connection limits\n3. Handles Git protocol packets (pktline format)\n4. Validates repository paths and access permissions\n5. Processes both git-upload-pack and git-upload-archive services\n6. Implements idle and maximum timeout handling\n7. Provides clean shutdown via context cancellation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/pkg/access\"\n\t\"github.com/charmbracelet/soft-serve/pkg/backend\"\n\t\"github.com/charmbracelet/soft-serve/pkg/config\"\n\t\"github.com/charmbracelet/soft-serve/pkg/git\"\n\t\"github.com/charmbracelet/soft-serve/pkg/utils\"\n\t\"github.com/go-git/go-git/v5/plumbing/format/pktline\"\n)\n\ntype GitDaemon struct {\n\tctx      context.Context\n\taddr     string\n\tfinished chan struct{}\n\tconns    connections\n\tcfg      *config.Config\n\tbe       *backend.Backend\n\twg       sync.WaitGroup\n\tonce     sync.Once\n\tlogger   *log.Logger\n\tdone     atomic.Bool\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg := config.FromContext(ctx)\n\taddr := cfg.Git.ListenAddr\n\td := &GitDaemon{\n\t\tctx:      ctx,\n\t\taddr:     addr,\n\t\tfinished: make(chan struct{}, 1),\n\t\tcfg:      cfg,\n\t\tbe:       backend.FromContext(ctx),\n\t\tconns:    connections{m: make(map[net.Conn]struct{})},\n\t\tlogger:   log.FromContext(ctx).WithPrefix(\"gitdaemon\"),\n\t}\n\treturn d, nil\n}\n\nfunc (d *GitDaemon) ListenAndServe() error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\tlistener, err := net.Listen(\"tcp\", d.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.Serve(listener)\n}\n\nfunc (d *GitDaemon) Serve(listener net.Listener) error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\n\td.wg.Add(1)\n\tdefer d.wg.Done()\n\tdefer listener.Close()\n\n\tvar tempDelay time.Duration\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-d.finished:\n\t\t\t\treturn ErrServerClosed\n\t\t\tdefault:\n\t\t\t\td.logger.Debugf(\"git: error accepting connection: %v\", err)\n\t\t\t}\n\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif d.conns.Size()+1 >= d.cfg.Git.MaxConnections {\n\t\t\td.logger.Debugf(\"git: max connections reached, closing %s\", conn.RemoteAddr())\n\t\t\td.fatal(conn, git.ErrMaxConnections)\n\t\t\tcontinue\n\t\t}\n\n\t\td.wg.Add(1)\n\t\tgo func() {\n\t\t\td.handleClient(conn)\n\t\t\td.wg.Done()\n\t\t}()\n\t}\n}\n\nfunc (d *GitDaemon) handleClient(conn net.Conn) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tidleTimeout := time.Duration(d.cfg.Git.IdleTimeout) * time.Second\n\tc := &serverConn{\n\t\tConn:          conn,\n\t\tidleTimeout:   idleTimeout,\n\t\tcloseCanceler: cancel,\n\t}\n\tif d.cfg.Git.MaxTimeout > 0 {\n\t\tdur := time.Duration(d.cfg.Git.MaxTimeout) * time.Second\n\t\tc.maxDeadline = time.Now().Add(dur)\n\t}\n\td.conns.Add(c)\n\tdefer func() {\n\t\td.conns.Close(c)\n\t}()\n\n\terrc := make(chan error, 1)\n\n\ts := pktline.NewScanner(c)\n\tgo func() {\n\t\tif !s.Scan() {\n\t\t\tif err := s.Err(); err != nil {\n\t\t\t\terrc <- err\n\t\t\t}\n\t\t}\n\t\terrc <- nil\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tif err := ctx.Err(); err != nil {\n\t\t\td.logger.Debugf(\"git: connection context error: %v\", err)\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t}\n\t\treturn\n\tcase err := <-errc:\n\t\tif nerr, ok := err.(net.Error); ok && nerr.Timeout() {\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\td.logger.Debugf(\"git: error scanning pktline: %v\", err)\n\t\t\td.fatal(c, git.ErrSystemMalfunction)\n\t\t\treturn\n\t\t}\n\n\t\tline := s.Bytes()\n\t\tsplit := bytes.SplitN(line, []byte{' '}, 2)\n\t\tif len(split) != 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\tservice := git.Service(split[0])\n\t\tswitch service {\n\t\tcase git.UploadPackService:\n\t\tcase git.UploadArchiveService:\n\t\tdefault:\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\topts := bytes.SplitN(split[1], []byte{0}, 3)\n\t\tif len(opts) < 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\thost := strings.TrimPrefix(string(opts[1]), \"host=\")\n\t\textraParams := map[string]string{}\n\n\t\tif len(opts) > 2 {\n\t\t\tbuf := bytes.TrimPrefix(opts[2], []byte{0})\n\t\t\tfor _, o := range bytes.Split(buf, []byte{0}) {\n\t\t\t\topt := string(o)\n\t\t\t\tif opt == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tkv := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(kv) != 2 {\n\t\t\t\t\td.logger.Errorf(\"git: invalid option %q\", opt)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\textraParams[kv[0]] = kv[1]\n\t\t\t}\n\t\t}\n\n\t\tbe := d.be\n\t\tif !be.AllowKeyless(ctx) {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tname := utils.SanitizeRepo(string(opts[0]))\n\t\td.logger.Debugf(\"git: connect %s %s %s\", c.RemoteAddr(), service, name)\n\t\tdefer d.logger.Debugf(\"git: disconnect %s %s %s\", c.RemoteAddr(), service, name)\n\n\t\trepo := name + \".git\"\n\t\treposDir := filepath.Join(d.cfg.DataPath, \"repos\")\n\t\tif err := git.EnsureWithin(reposDir, repo); err != nil {\n\t\t\td.logger.Debugf(\"git: error ensuring repo path: %v\", err)\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tif _, err := d.be.Repository(ctx, repo); err != nil {\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tauth := be.AccessLevel(ctx, name, \"\")\n\t\tif auth < access.ReadOnlyAccess {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tenvs := []string{\n\t\t\t\"SOFT_SERVE_REPO_NAME=\" + name,\n\t\t\t\"SOFT_SERVE_REPO_PATH=\" + filepath.Join(reposDir, repo),\n\t\t\t\"SOFT_SERVE_HOST=\" + host,\n\t\t\t\"SOFT_SERVE_LOG_PATH=\" + filepath.Join(d.cfg.DataPath, \"log\", \"hooks.log\"),\n\t\t}\n\n\t\tif len(extraParams) > 0 {\n\t\t\tvar gitProto string\n\t\t\tfor k, v := range extraParams {\n\t\t\t\tif len(gitProto) > 0 {\n\t\t\t\t\tgitProto += \":\"\n\t\t\t\t}\n\t\t\t\tgitProto += k + \"=\" + v\n\t\t\t}\n\t\t\tenvs = append(envs, \"GIT_PROTOCOL=\"+gitProto)\n\t\t}\n\n\t\tenvs = append(envs, d.cfg.Environ()...)\n\n\t\tcmd := git.ServiceCommand{\n\t\t\tStdin:  c,\n\t\t\tStdout: c,\n\t\t\tStderr: c,\n\t\t\tEnv:    envs,\n\t\t\tDir:    filepath.Join(reposDir, repo),\n\t\t}\n\n\t\tif err := service.Handler(ctx, cmd); err != nil {\n\t\t\td.logger.Debugf(\"git: error handling request: %v\", err)\n\t\t\td.fatal(c, err)\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype GitDaemon struct {\n\tctx      context.Context\n\taddr     string\n\tfinished chan struct{}\n\tconns    connections\n\tcfg      *config.Config\n\tbe       *backend.Backend\n\twg       sync.WaitGroup\n\tonce     sync.Once\n\tlogger   *log.Logger\n\tdone     atomic.Bool\n}\n\ntype serverConn struct {\n\tnet.Conn\n\tidleTimeout time.Duration\n\tmaxTimeout  time.Duration\n}\n\ntype connections struct {\n\tmu   sync.Mutex\n\tconns map[net.Conn]struct{}\n}\n\nfunc (c *connections) Add(conn net.Conn) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.conns[conn] = struct{}{}\n}\n\nfunc (c *connections) Remove(conn net.Conn) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tdelete(c.conns, conn)\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg, err := config.FromContext(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbe, err := backend.NewBackend(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &GitDaemon{\n\t\tctx:      ctx,\n\t\taddr:     cfg.Address,\n\t\tfinished: make(chan struct{}),\n\t\tconns:    connections{conns: make(map[net.Conn]struct{})},\n\t\tcfg:      cfg,\n\t\tbe:       be,\n\t\tlogger:   log.New(cfg.LogOutput, \"git-daemon: \", log.LstdFlags),\n\t}, nil\n}\n\nfunc (gd *GitDaemon) ListenAndServe() error {\n\tlistener, err := net.Listen(\"tcp\", gd.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn gd.Serve(listener)\n}\n\nfunc (gd *GitDaemon) Serve(listener net.Listener) error {\n\tdefer listener.Close()\n\tgd.logger.Printf(\"Listening on %s\", gd.addr)\n\tfor {\n\t\tselect {\n\t\tcase <-gd.ctx.Done():\n\t\t\treturn gd.ctx.Err()\n\t\tdefault:\n\t\t}\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tgd.wg.Add(1)\n\t\tgo func() {\n\t\t\tdefer gd.wg.Done()\n\t\t\tgd.handleClient(conn)\n\t\t}()\n\t}\n}\n\nfunc (gd *GitDaemon) handleClient(conn net.Conn) {\n\tdefer conn.Close()\n\tgd.conns.Add(conn)\n\tdefer gd.conns.Remove(conn)\n\n\tsc := &serverConn{Conn: conn, idleTimeout: gd.cfg.IdleTimeout, maxTimeout: gd.cfg.MaxTimeout}\n\tif err := sc.SetDeadline(time.Now().Add(sc.idleTimeout)); err != nil {\n\t\tgd.logger.Printf(\"Failed to set deadline: %v\", err)\n\t\treturn\n\t}\n\n\t// Simulate handling git-upload-pack and git-upload-archive\n\tif err := gd.processGitRequest(sc); err != nil {\n\t\tgd.logger.Printf(\"Failed to process request: %v\", err)\n\t\treturn\n\t}\n}\n\nfunc (gd *GitDaemon) processGitRequest(sc *serverConn) error {\n\t// Placeholder for actual Git protocol handling\n\treturn nil\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgd, err := NewGitDaemon(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create GitDaemon: %v\", err)\n\t}\n\n\tif err := gd.ListenAndServe(); err != nil && !errors.Is(err, context.Canceled) {\n\t\tlog.Fatalf(\"Server error: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Go struct that manages multiple TCP and UDP listeners for a proxy server, with methods to register and handle incoming connections.\n\nStruct Description: The Proxy struct manages network listeners for UDP, TCP, and local DNS-over-HTTPS (DoH) connections. It provides methods to create listeners from addresses and handle incoming connections through separate goroutines.\n\nFields:\nudpListeners: []*net.UDPConn - Slice of active UDP listeners\ntcpListeners: []*net.TCPListener - Slice of active TCP listeners\nlocalDoHListeners: []*net.TCPListener - Slice of active local DoH TCP listeners\n\nMethods:\nregisterUDPListener(*net.UDPConn) -> void - Adds a UDP listener to the udpListeners slice\nregisterTCPListener(*net.TCPListener) -> void - Adds a TCP listener to the tcpListeners slice\nregisterLocalDoHListener(*net.TCPListener) -> void - Adds a local DoH listener to the localDoHListeners slice\nudpListenerFromAddr(*net.UDPAddr) -> error - Creates and registers a UDP listener from address\ntcpListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a TCP listener from address\nlocalDoHListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a local DoH listener from address\nudpListener(*net.UDPConn) -> void - Handles incoming UDP connections (runs in goroutine)\ntcpListener(*net.TCPListener) -> void - Handles incoming TCP connections (runs in goroutine)\nstartAcceptingClients() -> void - Starts all registered listeners in separate goroutines",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners    []*net.UDPConn\n\ttcpListeners    []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (proxy *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tproxy.udpListeners = append(proxy.udpListeners, conn)\n}\n\nfunc (proxy *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tproxy.tcpListeners = append(proxy.tcpListeners, listener)\n}\n\nfunc (proxy *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tproxy.localDoHListeners = append(proxy.localDoHListeners, listener)\n}\n\nfunc (proxy *Proxy) udpListenerFromAddr(listenAddr *net.UDPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"udp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"udp4\"\n\t}\n\tclientPc, err := net.ListenUDP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerUDPListener(clientPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) tcpListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerTCPListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) localDoHListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerLocalDoHListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) udpListener(clientPc *net.UDPConn) {\n\tdefer clientPc.Close()\n\tfor {\n\t\tbuffer := make([]byte, MaxDNSPacketSize-1)\n\t\tlength, clientAddr, err := clientPc.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tpacket := buffer[:length]\n\t\tgo proxy.processIncomingQuery(\"udp\", \"udp\", packet, &clientAddr, clientPc, time.Now(), false)\n\t}\n}\n\nfunc (proxy *Proxy) tcpListener(acceptPc *net.TCPListener) {\n\tdefer acceptPc.Close()\n\tfor {\n\t\tclientPc, err := acceptPc.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tdefer clientPc.Close()\n\t\t\tif err := clientPc.SetDeadline(time.Now().Add(proxy.timeout)); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart := time.Now()\n\t\t\tpacket, err := ReadPrefixed(&clientPc)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclientAddr := clientPc.RemoteAddr()\n\t\t\tproxy.processIncomingQuery(\"tcp\", \"tcp\", packet, &clientAddr, clientPc, start, false)\n\t\t}()\n\t}\n}\n\nfunc (proxy *Proxy) startAcceptingClients() {\n\tfor _, clientPc := range proxy.udpListeners {\n\t\tgo proxy.udpListener(clientPc)\n\t}\n\tproxy.udpListeners = nil\n\tfor _, acceptPc := range proxy.tcpListeners {\n\t\tgo proxy.tcpListener(acceptPc)\n\t}\n\tproxy.tcpListeners = nil\n\tfor _, acceptPc := range proxy.localDoHListeners {\n\t\tgo proxy.localDoHListener(acceptPc)\n\t}\n\tproxy.localDoHListeners = nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n)\n\ntype Proxy struct {\n\tudpListeners      []*net.UDPConn\n\ttcpListeners      []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n\tmu                sync.Mutex\n}\n\nfunc (p *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.udpListeners = append(p.udpListeners, conn)\n}\n\nfunc (p *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.tcpListeners = append(p.tcpListeners, listener)\n}\n\nfunc (p *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.localDoHListeners = append(p.localDoHListeners, listener)\n}\n\nfunc (p *Proxy) udpListenerFromAddr(addr *net.UDPAddr) error {\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerUDPListener(conn)\n\treturn nil\n}\n\nfunc (p *Proxy) tcpListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerTCPListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) localDoHListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerLocalDoHListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) udpListener(conn *net.UDPConn) {\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\t_, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo p.handleUDPConnection(conn, addr, buf)\n\t}\n}\n\nfunc (p *Proxy) handleUDPConnection(conn *net.UDPConn, addr *net.UDPAddr, data []byte) {\n\t// Handle UDP connection\n}\n\nfunc (p *Proxy) tcpListener(listener *net.TCPListener) {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo p.handleTCPConnection(conn)\n\t}\n}\n\nfunc (p *Proxy) handleTCPConnection(conn net.Conn) {\n\t// Handle TCP connection\n}\n\nfunc (p *Proxy) startAcceptingClients() {\n\tfor _, udpConn := range p.udpListeners {\n\t\tgo p.udpListener(udpConn)\n\t}\n\tfor _, tcpListener := range p.tcpListeners {\n\t\tgo p.tcpListener(tcpListener)\n\t}\n\tfor _, localDoHListener := range p.localDoHListeners {\n\t\tgo p.tcpListener(localDoHListener)\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tproxy := &Proxy{}\n\t// Add listeners and start accepting clients\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a Go struct that manages HTTP requests to interact with a community persistence service, including authentication and community creation functionality.\n\nStruct Description: The Manager struct provides methods to interact with a community persistence API, handling authentication and request/response processing. It maintains connection details and context for request cancellation.\n\nFields:\nurl: string - Base URL of the community persistence service\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nctx: context.Context - Context for request cancellation and timeouts\n\nMethods:\nNewManager: (url string, username string, password string, ctx context.Context) -> *Manager - Constructor that initializes a new Manager instance with connection details and context\nCreatePersistentCommunity: (community string, password string) -> (*persisters.Community, error) - Creates a new persistent community by making an authenticated POST request to the service, returning the created community or an error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/pojntfx/weron/internal/persisters\"\n)\n\nvar (\n\tjson = jsoniter.ConfigCompatibleWithStandardLibrary\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(\n\turl string,\n\tusername string,\n\tpassword string,\n\tctx context.Context,\n) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\thc := &http.Client{}\n\n\tu, err := url.Parse(m.url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := u.Query()\n\tq.Set(\"community\", community)\n\tq.Set(\"password\", password)\n\tu.RawQuery = q.Encode()\n\n\treq, err := http.NewRequest(http.MethodPost, u.String(), http.NoBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\n\tres, err := hc.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(res.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := persisters.Community{}\n\tif err := json.Unmarshal(body, &c); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &c, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\ntype Community struct {\n\tName string `json:\"name\"`\n}\n\nfunc NewManager(url string, username string, password string, ctx context.Context) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*Community, error) {\n\tcommunityData := map[string]string{\n\t\t\"name\":     community,\n\t\t\"password\": password,\n\t}\n\tdata, err := json.Marshal(communityData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequestWithContext(m.ctx, \"POST\", m.url+\"/communities\", bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusCreated {\n\t\treturn nil, errors.New(\"failed to create community\")\n\t}\n\n\tvar createdCommunity Community\n\tif err := json.NewDecoder(resp.Body).Decode(&createdCommunity); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createdCommunity, nil\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Implement a high-performance TCP server in Go using kqueue for event notification, capable of handling multiple client connections efficiently with non-blocking I/O operations.\n\nStruct Description: The `poller` struct manages a single kqueue instance and handles all I/O operations for its assigned connections. It works as part of an engine (`g *Engine`) to process network events either as a listener (accepting new connections) or as a worker (handling read/write operations).\n\nFields:\n\ng: *Engine - Reference to the parent engine managing all pollers\nmux: sync.Mutex - Mutex for thread-safe access to eventList\nkfd: int - Kqueue file descriptor\nevtfd: int - Event file descriptor (unused in current implementation)\nindex: int - Poller's index in the engine's poller array\nshutdown: bool - Flag to control poller shutdown\nlistener: net.Listener - TCP listener (only for listener pollers)\nisListener: bool - Flag indicating if this is a listener poller\nunixSockAddr: string - Unix socket address (if using UNIX domain sockets)\nReadBuffer: []byte - Buffer for read operations\npollType: string - Type identifier (\"LISTENER\" or \"POLLER\")\neventList: []syscall.Kevent_t - Pending kqueue events to be processed\n\nMethods:\n\naddConn(c *Conn) -> error - Adds a new connection to the poller and registers it for read events\naddDialer(c *Conn) -> error - Adds a dialer connection and registers it for read/write events\ngetConn(fd int) -> *Conn - Retrieves a connection by file descriptor\ndeleteConn(c *Conn) -> - Removes a connection from tracking\ntrigger() -> - Wakes up the kqueue loop\naddRead(fd int) -> - Registers a file descriptor for read events\nresetRead(fd int) -> - Unregisters write events for a file descriptor\nmodWrite(fd int) -> - Registers a file descriptor for write events\naddReadWrite(fd int) -> - Registers a file descriptor for both read and write events\nreadWrite(ev *syscall.Kevent_t) -> - Processes read/write events from kqueue\nstart() -> - Starts the poller's main loop (either acceptorLoop or readWriteLoop)\nacceptorLoop() -> - Listener's main loop that accepts new connections\nreadWriteLoop() -> - Worker's main loop that processes I/O events\nstop() -> - Stops the poller and cleans up resources\nnewPoller(g *Engine, isListener bool, index int) -> (*poller, error) - Constructor that creates either a listener or worker poller",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Engine struct {\n\tpollers []*poller\n}\n\ntype Conn struct {\n\tfd int\n}\n\ntype poller struct {\n\tg           *Engine\n\tmux         sync.Mutex\n\tkfd         int\n\tevtfd       int\n\tindex       int\n\tshutdown    bool\n\tlistener    net.Listener\n\tisListener  bool\n\tunixSockAddr string\n\tReadBuffer  []byte\n\tpollType    string\n\teventList   []syscall.Kevent_t\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tkfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &poller{\n\t\tg:          g,\n\t\tkfd:        kfd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tReadBuffer: make([]byte, 4096),\n\t}, nil\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tp.mux.Lock()\n\tdefer p.mux.Unlock()\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(c.fd),\n\t\tFilter: syscall.EVFILT_READ,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_ENABLE,\n\t}\n\tp.eventList = append(p.eventList, ev)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tp.mux.Lock()\n\tdefer p.mux.Unlock()\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(c.fd),\n\t\tFilter: syscall.EVFILT_READ,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_ENABLE,\n\t}\n\tp.eventList = append(p.eventList, ev)\n\tev.Filter = syscall.EVFILT_WRITE\n\tp.eventList = append(p.eventList, ev)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\t// Implementation to retrieve connection by fd\n\treturn nil\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\t// Implementation to delete connection\n}\n\nfunc (p *poller) trigger() {\n\t// Implementation to wake up kqueue loop\n}\n\nfunc (p *poller) addRead(fd int) {\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(fd),\n\t\tFilter: syscall.EVFILT_READ,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_ENABLE,\n\t}\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, ev)\n\tp.mux.Unlock()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(fd),\n\t\tFilter: syscall.EVFILT_WRITE,\n\t\tFlags:  syscall.EV_DELETE,\n\t}\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, ev)\n\tp.mux.Unlock()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(fd),\n\t\tFilter: syscall.EVFILT_WRITE,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_ENABLE,\n\t}\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, ev)\n\tp.mux.Unlock()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tev := syscall.Kevent_t{\n\t\tIdent:  uint64(fd),\n\t\tFilter: syscall.EVFILT_READ,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_ENABLE,\n\t}\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, ev)\n\tev.Filter = syscall.EVFILT_WRITE\n\tp.eventList = append(p.eventList, ev)\n\tp.mux.Unlock()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\t// Implementation to process read/write events\n}\n\nfunc (p *poller) start() {\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tfor !p.shutdown {\n\t\tfd, _, err := syscall.Accept(p.listener.(*net.TCPListener).Fd())\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tconn := &Conn{fd: fd}\n\t\tp.addConn(conn)\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tfor !p.shutdown {\n\t\tevents := make([]syscall.Kevent_t, len(p.eventList))\n\t\tn, err := syscall.Kevent(p.kfd, p.eventList, events, nil)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tp.readWrite(&events[i])\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tsyscall.Close(p.kfd)\n\tif p.isListener {\n\t\tp.listener.Close()\n\t}\n}\n```"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Implement a TCP server in Go that handles client connections, processes incoming messages, and generates appropriate responses based on the message type. The server should support graceful shutdown and concurrent client handling.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, processes client requests, and maintains server state including messages, errors, and connection information.\n\nFields:\n- Addr: net.Addr - The network address the server is listening on\n- mu: sync.Mutex - Mutex for thread-safe operations\n- wg: sync.WaitGroup - WaitGroup for managing goroutines\n- closed: bool - Flag indicating if the server is closed\n- closing: chan struct{} - Channel for shutdown signaling\n- messages: []Message - Collection of processed messages\n- errors: []error - Collection of encountered errors\n- brokerMessage: []byte - Pre-prepared broker message data\n- nodeID: int32 - Identifier for the server node\n- partitionCount: int32 - Number of partitions for topic handling\n\nMethods:\n- NewServer() -> (*Server, error) - Creates and starts a new Server instance\n- prepareBrokerMsg() - Prepares the broker message with server information\n- Close() - Gracefully shuts down the server\n- run(net.Listener) - Main server loop handling connections\n- handle(net.Conn) -> error - Processes individual client connections\n- readProduceRequest([]byte) -> (string, []Response, error) - Helper for produce requests\n- readStrList([]byte) -> ([]string, int) - Helper for reading string lists",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr net.Addr\n\tmu   sync.Mutex\n\twg   sync.WaitGroup\n\n\tclosed  bool\n\tclosing chan struct{}\n\n\tmessages []Message\n\terrors   []error\n\n\tbrokerMessage []byte\n\tnodeID        int32\n\n\tpartitionCount int32\n}\n\nfunc NewServer() (*Server, error) {\n\ts := &Server{\n\t\tclosing:        make(chan struct{}),\n\t\tnodeID:         1,\n\t\tpartitionCount: 3,\n\t}\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.Addr = l.Addr()\n\n\ts.prepareBrokerMsg()\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\ts.run(l)\n\t}()\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\thost, port, _ := net.SplitHostPort(s.Addr.String())\n\ts.brokerMessage = make([]byte, 0, 4+2+len(host)+4)\n\ts.brokerMessage = writeInt32(s.brokerMessage, s.nodeID)\n\ts.brokerMessage = writeStr(s.brokerMessage, host)\n\tportN, _ := strconv.Atoi(port)\n\ts.brokerMessage = writeInt32(s.brokerMessage, int32(portN))\n\ts.brokerMessage = writeInt16(s.brokerMessage, -1)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(l net.Listener) {\n\tdefer l.Close()\n\n\taccepts := make(chan net.Conn)\n\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tfor {\n\t\t\tc, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase accepts <- c:\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase c := <-accepts:\n\t\t\tgo func() {\n\t\t\t\tdefer c.Close()\n\t\t\t\tfor {\n\t\t\t\t\tif err := s.handle(c); err != nil {\n\t\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.mu.Lock()\n\t\t\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\t\t\ts.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\tcase <-s.closing:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Server) handle(c net.Conn) error {\n\tvar size int32\n\terr := binary.Read(c, binary.BigEndian, &size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, int(size))\n\n\t_, err = io.ReadFull(c, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tapiKey := int16(binary.BigEndian.Uint16(buf[:2]))\n\tversion := int16(binary.BigEndian.Uint16(buf[2:4]))\n\t_, n := readStr(buf[8:])\n\trequest := buf[8+n:]\n\n\tresponse := make([]byte, 8, 1024)\n\tcopy(response[4:], buf[4:8])\n\n\tswitch apiKey {\n\tcase 0:\n\t\ttopic, responses, err := s.readProduceRequest(request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse = writeArrayHeader(response, 1)\n\t\tresponse = writeStr(response, topic)\n\t\tresponse = writeArrayHeader(response, int32(len(responses)))\n\t\tfor _, r := range responses {\n\t\t\tresponse = writeInt32(response, 0)\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeInt64(response, r.offset)\n\t\t\tresponse = writeInt64(response, 0)\n\t\t\tif version >= 5 {\n\t\t\t\tresponse = writeInt64(response, 0)\n\t\t\t}\n\t\t}\n\t\tresponse = writeInt32(response, 0)\n\n\tcase 3:\n\t\ttopics, _ := readStrList(request)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArray(response, [][]byte{s.brokerMessage})\n\t\tresponse = writeInt16(response, -1)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArrayHeader(response, int32(len(topics)))\n\t\tfor _, t := range topics {\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeStr(response, t)\n\t\t\tresponse = writeBool(response, false)\n\t\t\tresponse = writeArrayHeader(response, s.partitionCount)\n\t\t\tfor i := int32(0); i < s.partitionCount; i++ {\n\t\t\t\tresponse = writeInt16(response, 0)\n\t\t\t\tresponse = writeInt32(response, i+1)\n\t\t\t\tresponse = writeInt32(response, s.nodeID)\n\t\t\t\tif version >= 7 {\n\t\t\t\t\tresponse = writeInt32(response, 0)\n\t\t\t\t}\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t}\n\t\t}\n\tcase 18:\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeArrayHeader(response, 2)\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 3)\n\t\tresponse = writeInt16(response, 1)\n\t\tresponse = writeInt16(response, 1)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported apiKey %d\", apiKey)\n\t}\n\n\tresponseSize := len(response) - 4\n\tbinary.BigEndian.PutUint32(response[:4], uint32(responseSize))\n\t_, err = c.Write(response)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Message struct {\n\tContent string\n}\n\ntype Response struct {\n\tStatus string\n}\n\ntype Server struct {\n\tAddr          net.Addr\n\tmu            sync.Mutex\n\twg            sync.WaitGroup\n\tclosed        bool\n\tclosing       chan struct{}\n\tmessages      []Message\n\terrors        []error\n\tbrokerMessage []byte\n\tnodeID        int32\n\tpartitionCount int32\n}\n\nfunc NewServer(addr string, nodeID, partitionCount int32) (*Server, error) {\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserver := &Server{\n\t\tAddr:          listener.Addr(),\n\t\tclosing:       make(chan struct{}),\n\t\tnodeID:        nodeID,\n\t\tpartitionCount: partitionCount,\n\t}\n\n\tserver.prepareBrokerMsg()\n\tserver.wg.Add(1)\n\tgo server.run(listener)\n\n\treturn server, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\ts.brokerMessage = []byte(fmt.Sprintf(\"NodeID: %d, Partitions: %d\", s.nodeID, s.partitionCount))\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tif s.closed {\n\t\ts.mu.Unlock()\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.mu.Unlock()\n\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(listener net.Listener) {\n\tdefer s.wg.Done()\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\ts.wg.Add(1)\n\t\tgo func() {\n\t\t\tdefer s.wg.Done()\n\t\t\tif err := s.handle(conn); err != nil {\n\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (s *Server) handle(conn net.Conn) error {\n\tdefer conn.Close()\n\treader := bufio.NewReader(conn)\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.closing:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tmessage, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tresponse, err := s.processMessage(message)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = conn.Write([]byte(response + \"\\n\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) processMessage(message string) (string, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\ts.messages = append(s.messages, Message{Content: message})\n\treturn \"Message received\", nil\n}\n\nfunc (s *Server) readProduceRequest(data []byte) (string, []Response, error) {\n\ttopic, n := s.readStrList(data)\n\tif n == 0 {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to read topic\")\n\t}\n\treturn topic[0], []Response{{Status: \"OK\"}}, nil\n}\n\nfunc (s *Server) readStrList(data []byte) ([]string, int) {\n\tvar result []string\n\toffset := 0\n\tfor offset < len(data) {\n\t\tlength := int(binary.BigEndian.Uint16(data[offset:]))\n\t\toffset += 2\n\t\tif offset+length > len(data) {\n\t\t\treturn nil, 0\n\t\t}\n\t\tresult = append(result, string(data[offset:offset+length]))\n\t\toffset += length\n\t}\n\treturn result, offset\n}\n\nfunc main() {\n\tserver, err := NewServer(\":8080\", 1, 10)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t\treturn\n\t}\n\tdefer server.Close()\n\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Implement a TCP listener in Go that supports different listening methods (normal, iptables, and socket reuse) for handling incoming client connections, performing protocol negotiation, and managing client tasks.\n\nStruct Description: The Listen struct represents a TCP listener with configurable listening methods and address. It provides methods to start listening using different techniques and handle client connections.\n\nFields:\nmethod: [int] - Specifies the listening method (NORMAL, IPTABLES, or SOREUSE)\naddr: [string] - The address and port to listen on\n\nMethods:\nnewListen: [Name](method int, addr string) -> *Listen - Creates and returns a new Listen instance with the specified method and address\nstart: [Name](mgr *manager.Manager, options *initial.Options) -> void - Starts the listener in a goroutine using the configured method\nnormalListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements standard TCP listening and client handling\nsoReuseListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements socket reuse listening with additional authentication and proxy capabilities",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-reuseport\"\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\tlisten := new(Listen)\n\tlisten.method = method\n\tlisten.addr = addr\n\treturn listen\n}\n\nfunc (listen *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch listen.method {\n\tcase NORMAL:\n\t\tgo listen.normalListen(mgr, options)\n\tcase IPTABLES:\n\t\tgo listen.iptablesListen(mgr, options)\n\tcase SOREUSE:\n\t\tgo listen.soReuseListen(mgr, options)\n\t}\n}\n\nfunc (listen *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", listen.addr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}\n\nfunc (listen *Listen) soReuseListen(mgr *manager.Manager, options *initial.Options) {\n\tlistenAddr := fmt.Sprintf(\"%s:%s\", options.ReuseHost, options.ReusePort)\n\tlistener, err := reuseport.Listen(\"tcp\", listenAddr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\tdefer conn.SetReadDeadline(time.Time{})\n\t\tconn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\n\t\tbuffer := make([]byte, 16)\n\t\tcount, err := io.ReadFull(conn, buffer)\n\n\t\tif err != nil {\n\t\t\tif timeoutErr, ok := err.(net.Error); ok && timeoutErr.Timeout() {\n\t\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif string(buffer[:count]) == share.AuthToken {\n\t\t\tconn.Write([]byte(share.AuthToken))\n\t\t} else {\n\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\tcontinue\n\t\t}\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n)\n\nconst (\n\tNORMAL   = iota\n\tIPTABLES\n\tSOREUSE\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\treturn &Listen{method: method, addr: addr}\n}\n\nfunc (l *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch l.method {\n\tcase NORMAL:\n\t\tgo l.normalListen(mgr, options)\n\tcase SOREUSE:\n\t\tgo l.soReuseListen(mgr, options)\n\tdefault:\n\t\tfmt.Println(\"Unsupported listening method\")\n\t}\n}\n\nfunc (l *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", l.addr)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting normal listener:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn, mgr, options)\n\t}\n}\n\nfunc (l *Listen) soReuseListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", l.addr)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting SO_REUSE listener:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnectionWithReuse(conn, mgr, options)\n\t}\n}\n\nfunc handleConnection(conn net.Conn, mgr *manager.Manager, options *initial.Options) {\n\tdefer conn.Close()\n\t// Implement protocol negotiation and client task management\n}\n\nfunc handleConnectionWithReuse(conn net.Conn, mgr *manager.Manager, options *initial.Options) {\n\tdefer conn.Close()\n\t// Implement socket reuse, authentication, and proxy capabilities\n}\n\n// Placeholder types for manager.Manager and initial.Options\ntype manager struct {\n\tManager struct{}\n}\n\ntype initial struct {\n\tOptions struct{}\n}\n\nfunc main() {\n\tmgr := &manager.Manager{}\n\toptions := &initial.Options{}\n\tlistener := newListen(NORMAL, \"localhost:8080\")\n\tlistener.start(mgr, options)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\twg.Wait()\n}\n```"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle incoming client connections, optionally with TLS encryption, and relay traffic between clients and target servers through a proxy.\n\nStruct Description: The Trojan struct represents a TCP server that listens for incoming connections, handles TLS encryption if configured, and relays traffic between clients and target servers via a proxy.\n\nFields:\n- addr: string - The address on which the server listens for incoming connections\n- withTLS: bool - Flag indicating whether TLS encryption should be used\n- tlsConfig: *tls.Config - TLS configuration for secure connections\n- certFile: string - Path to TLS certificate file\n- keyFile: string - Path to TLS private key file\n- pass: [56]byte - Password for authentication\n- fallback: string - Fallback address if connection fails\n- proxy: proxy.Proxy - Proxy implementation for relaying traffic\n\nMethods:\n- ListenAndServe() - Starts the TCP server, listens for incoming connections, and handles them in separate goroutines\n  Input: None\n  Output: None\n- Serve(c net.Conn) - Handles an individual client connection, performs TLS handshake if needed, and relays traffic\n  Input: c net.Conn - The client connection to handle\n  Output: None\n- readHeader(r io.Reader) - Reads and parses the header from the client connection\n  Input: r io.Reader - Reader to get header data from\n  Output: cmd socks.Cmd, target socks.Addr, err error - Returns command, target address, and any error\n- serveFallback(c net.Conn, fallback string, buf *bytes.Buffer) - Handles fallback connection when main connection fails\n  Input: \n    c net.Conn - The client connection\n    fallback string - Fallback address\n    buf *bytes.Buffer - Buffer containing initial data\n  Output: None\n- ServeUoT(c net.Conn, target socks.Addr) - Handles UDP-over-TCP connections\n  Input:\n    c net.Conn - The client connection\n    target socks.Addr - Target address\n  Output: None",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/pkg/socks\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\ntype Trojan struct {\n\taddr      string\n\twithTLS   bool\n\ttlsConfig *tls.Config\n\tcertFile  string\n\tkeyFile   string\n\tpass      [56]byte\n\tfallback  string\n\tproxy     proxy.Proxy\n}\n\nfunc (s *Trojan) ListenAndServe() {\n\tl, err := net.Listen(\"tcp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[trojan] failed to listen on %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tlog.F(\"[trojan] listening TCP on %s, with TLS: %v\", s.addr, s.withTLS)\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.F(\"[trojan] failed to accept: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.Serve(c)\n\t}\n}\n\nfunc (s *Trojan) Serve(c net.Conn) {\n\tif c, ok := c.(*net.TCPConn); ok {\n\t\tc.SetKeepAlive(true)\n\t}\n\n\tif s.withTLS {\n\t\ttlsConn := tls.Server(c, s.tlsConfig)\n\t\tif err := tlsConn.Handshake(); err != nil {\n\t\t\ttlsConn.Close()\n\t\t\tlog.F(\"[trojan] error in tls handshake: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tc = tlsConn\n\t}\n\tdefer c.Close()\n\n\theadBuf := pool.GetBytesBuffer()\n\tdefer pool.PutBytesBuffer(headBuf)\n\n\tcmd, target, err := s.readHeader(io.TeeReader(c, headBuf))\n\tif err != nil {\n\t\tif s.fallback != \"\" {\n\t\t\ts.serveFallback(c, s.fallback, headBuf)\n\t\t}\n\t\treturn\n\t}\n\n\tnetwork := \"tcp\"\n\tdialer := s.proxy.NextDialer(target.String())\n\n\tif cmd == socks.CmdUDPAssociate {\n\t\tif dialer.Addr() == \"DIRECT\" {\n\t\t\ts.ServeUoT(c, target)\n\t\t\treturn\n\t\t}\n\t\tnetwork = \"udp\"\n\t}\n\n\trc, err := dialer.Dial(network, target.String())\n\tif err != nil {\n\t\tlog.F(\"[trojan] %s <-> %s via %s, error in dial: %v\", c.RemoteAddr(), target, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tlog.F(\"[trojan] %s <-> %s via %s\", c.RemoteAddr(), target, dialer.Addr())\n\n\tif err = proxy.Relay(c, rc); err != nil {\n\t\tlog.F(\"[trojan] %s <-> %s via %s, relay error: %v\", c.RemoteAddr(), target, dialer.Addr(), err)\n\t\tif !strings.Contains(err.Error(), s.addr) {\n\t\t\ts.proxy.Record(dialer, false)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net\"\n\t\"socks\"\n\t\"proxy\"\n)\n\ntype Trojan struct {\n\taddr     string\n\twithTLS  bool\n\ttlsConfig *tls.Config\n\tcertFile string\n\tkeyFile  string\n\tpass     [56]byte\n\tfallback string\n\tproxy    proxy.Proxy\n}\n\nfunc (t *Trojan) ListenAndServe() {\n\tvar listener net.Listener\n\tvar err error\n\n\tif t.withTLS {\n\t\tcert, err := tls.LoadX509KeyPair(t.certFile, t.keyFile)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tt.tlsConfig = &tls.Config{Certificates: []tls.Certificate{cert}}\n\t\tlistener, err = tls.Listen(\"tcp\", t.addr, t.tlsConfig)\n\t} else {\n\t\tlistener, err = net.Listen(\"tcp\", t.addr)\n\t}\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo t.Serve(conn)\n\t}\n}\n\nfunc (t *Trojan) Serve(c net.Conn) {\n\tdefer c.Close()\n\n\tif t.withTLS {\n\t\ttlsConn, ok := c.(*tls.Conn)\n\t\tif ok {\n\t\t\terr := tlsConn.Handshake()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd, target, err := t.readHeader(c)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tswitch cmd {\n\tcase socks.CmdConnect:\n\t\tt.proxy.HandleTCP(c, target)\n\tcase socks.CmdUDPAssociate:\n\t\tt.ServeUoT(c, target)\n\tdefault:\n\t\tt.serveFallback(c, t.fallback, nil)\n\t}\n}\n\nfunc (t *Trojan) readHeader(r io.Reader) (socks.Cmd, socks.Addr, error) {\n\tvar buf [256]byte\n\tn, err := r.Read(buf[:])\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tcmd, target, err := socks.ParseHeader(buf[:n])\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\treturn cmd, target, nil\n}\n\nfunc (t *Trojan) serveFallback(c net.Conn, fallback string, buf *bytes.Buffer) {\n\tfbConn, err := net.Dial(\"tcp\", fallback)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer fbConn.Close()\n\n\tif buf != nil {\n\t\tfbConn.Write(buf.Bytes())\n\t}\n\n\tgo io.Copy(fbConn, c)\n\tio.Copy(c, fbConn)\n}\n\nfunc (t *Trojan) ServeUoT(c net.Conn, target socks.Addr) {\n\t// Implement UDP-over-TCP handling logic here\n}\n\nfunc main() {\n\t// Example usage\n\ttrojan := &Trojan{\n\t\taddr:     \":8080\",\n\t\twithTLS:  false,\n\t\tfallback: \"example.com:80\",\n\t\tproxy:    proxy.NewProxy(),\n\t}\n\ttrojan.ListenAndServe()\n}\n```"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a TCP server in Go that can handle multiple client connections concurrently, manage server lifecycle, and track active connections.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client communication, and provides server management capabilities.\n\nFields:\n- Addr: string - The network address to listen on (e.g., \":8080\")\n- Net: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\n- Handler: Handler - Interface for custom request handling (implementation not shown)\n- Listener: net.Listener - The underlying network listener\n- conns: map[net.Conn]struct{} - Track active connections\n- lock: sync.RWMutex - Protects concurrent access to server state\n- started: bool - Indicates if server is running\n- shutdown: chan struct{} - Channel for shutdown signaling\n\nMethods:\n- ListenAndServe() error - Starts the server and begins accepting connections\n- init() - Initializes server resources (internal use)\n- serveTCP(net.Listener) error - Main server loop that accepts connections (internal use)\n- serveTCPConn(*sync.WaitGroup, net.Conn) - Handles individual client connections (internal use)\n- isStarted() bool - Thread-safe check of server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tl, err := net.Listen(srv.Net, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Listener = l\n\tsrv.started = true\n\tunlock()\n\treturn srv.serveTCP(l)\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer func() {\n\t\tsrv.lock.Lock()\n\t\tdelete(srv.conns, rw)\n\t\tsrv.lock.Unlock()\n\t\trw.Close()\n\t\twg.Done()\n\t}()\n\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := rw.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = rw.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc unlockOnce(l sync.Locker) func() {\n\tvar once sync.Once\n\treturn func() { once.Do(l.Unlock) }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Handler interface {\n\tServeTCP(net.Conn)\n}\n\ntype Server struct {\n\tAddr     string\n\tNet      string\n\tHandler  Handler\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif err := s.init(); err != nil {\n\t\treturn err\n\t}\n\treturn s.serveTCP(s.Listener)\n}\n\nfunc (s *Server) init() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif s.started {\n\t\treturn fmt.Errorf(\"server already started\")\n\t}\n\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Listener = listener\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n\ts.started = true\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tvar wg sync.WaitGroup\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\twg.Wait()\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\n\ts.Handler.ServeTCP(conn)\n\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a TLS server in Go that handles incoming TCP connections, performs TLS handshakes, manages connection timeouts, and processes domain-specific data through channels.\n\nStruct Description: The TLSServer struct represents a TLS-enabled TCP server that handles secure connections, manages connection state, and processes domain-specific data through channels. It includes functionality for accepting connections, handling TLS handshakes, managing timeouts, and shutting down gracefully.\n\nFields:\n- HTTPSServer: *HTTPSServer - Reference to the parent HTTPSServer containing configuration\n- Cache: *cache.Cache - Cache for storing active connections\n- TCPListen: *net.TCPListener - TCP listener for incoming connections\n- Done: chan byte - Channel for signaling server shutdown\n- DomainData: chan DomainData - Channel for sending domain-specific data\n- Error: chan error - Channel for reporting errors\n\nMethods:\n- NewTLSServer(*HTTPSServer) (*TLSServer, error) - Constructor that initializes a new TLSServer instance\n- ListenAndServe() error - Main server loop that handles domain data and errors\n- Shutdown() - Gracefully shuts down the server\n- Accept() - Accepts incoming connections and handles TLS handshakes (spawned as a goroutine)",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/zoro\"\n)\n\ntype DomainData struct {\n\tDomain string\n\tData   []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(s *HTTPSServer) (*TLSServer, error) {\n\tl, err := net.ListenTCP(\"tcp\", s.TLSAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TLSServer{\n\t\tHTTPSServer: s,\n\t\tCache:       cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tTCPListen:   l,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tdefer close(s.Done)\n\tdefer s.TCPListen.Close()\n\tgo s.Accept()\n\tfor {\n\t\tselect {\n\t\tcase d := <-s.DomainData:\n\t\t\ti, ok := s.Cache.Get(\"domain:\" + d.Domain)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc := i.(*net.TCPConn)\n\t\t\tif err := c.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, err := c.Write(d.Data); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tselect {\n\tcase <-s.Done:\n\t\treturn\n\tcase s.Error <- nil:\n\t}\n}\n\nfunc (s *TLSServer) Accept() {\n\tfor {\n\t\tc1, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.Done:\n\t\t\t\treturn\n\t\t\tcase s.Error <- err:\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif s.HTTPSServer.TLSTimeout != 0 {\n\t\t\tif err := c1.SetKeepAlivePeriod(time.Duration(s.HTTPSServer.TLSTimeout) * time.Second); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\tif err := c1.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\ttc := tls.Server(c1, s.HTTPSServer.TLSConfig)\n\t\tif err := tc.Handshake(); err != nil {\n\t\t\tc1.Close()\n\t\t\tcontinue\n\t\t}\n\t\tcs := tc.ConnectionState()\n\t\tif cs.ServerName == \"\" {\n\t\t\tlog.Println(tc.RemoteAddr().String() + \" no SNI\")\n\t\t\ttc.Close()\n\t\t\tcontinue\n\t\t}\n\t\ts.Cache.Set(tc.RemoteAddr().String(), tc, cache.DefaultExpiration)\n\t\tgo func(tc *tls.Conn) {\n\t\t\tdefer func() {\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x02}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t\ts.Cache.Delete(tc.RemoteAddr().String())\n\t\t\t\ttc.Close()\n\t\t\t}()\n\t\t\tvar bf [1024 * 2]byte\n\t\t\tfor {\n\t\t\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\t\t\tif err := tc.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti, err := tc.Read(bf[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t\tData:    bf[0:i],\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x01}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t}\n\t\t}(tc)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n)\n\ntype HTTPSServer struct {\n\tTLSConfig *tls.Config\n}\n\ntype DomainData struct {\n\t// Define domain-specific data fields here\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(httpServer *HTTPSServer) (*TLSServer, error) {\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", \":443\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttcpListener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TLSServer{\n\t\tHTTPSServer: httpServer,\n\t\tCache:       cache.New(5*time.Minute, 10*time.Minute),\n\t\tTCPListen:   tcpListener,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tfor {\n\t\tselect {\n\t\tcase <-s.Done:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tconn, err := s.TCPListen.Accept()\n\t\t\tif err != nil {\n\t\t\t\ts.Error <- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo s.Accept(conn)\n\t\t}\n\t}\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tclose(s.Done)\n\ts.TCPListen.Close()\n}\n\nfunc (s *TLSServer) Accept(conn net.Conn) {\n\tdefer conn.Close()\n\ttlsConn := tls.Server(conn, s.HTTPSServer.TLSConfig)\n\ttlsConn.SetDeadline(time.Now().Add(5 * time.Second))\n\tif err := tlsConn.Handshake(); err != nil {\n\t\ts.Error <- err\n\t\treturn\n\t}\n\t// Process domain-specific data here\n\t// Example: s.DomainData <- DomainData{}\n}\n\nfunc main() {\n\t// Example usage\n\thttpServer := &HTTPSServer{\n\t\tTLSConfig: &tls.Config{\n\t\t\t// Configure TLS settings here\n\t\t},\n\t}\n\ttlsServer, err := NewTLSServer(httpServer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tif err := tlsServer.ListenAndServe(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\t// Shutdown server gracefully\n\t// tlsServer.Shutdown()\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets IP TOS (Type of Service) and TTL (Time To Live) values for IPv4 connections, and sends a greeting message to the client.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For each IPv4 connection, it configures the TOS and TTL values using the ipv4 package. It then sends a greeting message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to \"0.0.0.0:1024\" by default)\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving connections)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {\n\t\t\t\tp := ipv4.NewConn(c)\n\t\t\t\tif err := p.SetTOS(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetTTL(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"golang.org/x/net/ipv4\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\trawConn, err := ipv4.NewConn(conn)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating IPv4 connection:\", err)\n\t\treturn\n\t}\n\n\tif err := rawConn.SetTOS(0x10); err != nil { // Set TOS to 16 (Low Delay)\n\t\tfmt.Println(\"Error setting TOS:\", err)\n\t\treturn\n\t}\n\n\tif err := rawConn.SetTTL(64); err != nil { // Set TTL to 64\n\t\tfmt.Println(\"Error setting TTL:\", err)\n\t\treturn\n\t}\n\n\tmessage := \"HELLO-R-U-THERE-ACK\"\n\tif _, err := conn.Write([]byte(message)); err != nil {\n\t\tfmt.Println(\"Error sending message:\", err)\n\t\treturn\n\t}\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"TCP server listening on 0.0.0.0:1024\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific traffic class and hop limit settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For IPv6 clients, it configures specific network parameters (traffic class and hop limit) before sending an acknowledgment message. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to a fixed port \"[::]:1024\")\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving clients)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv6\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\t_, err := conn.Write([]byte(\"Acknowledgment from server\\n\"))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending acknowledgment:\", err)\n\t}\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\ttcpConn, ok := conn.(*net.TCPConn)\n\t\tif !ok {\n\t\t\tfmt.Println(\"Connection is not a TCP connection\")\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tfile, err := tcpConn.File()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error getting connection file:\", err)\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\t\tfd := int(file.Fd())\n\n\t\terr = syscall.SetsockoptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, 0x20)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error setting traffic class:\", err)\n\t\t}\n\n\t\terr = syscall.SetsockoptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, 64)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error setting hop limit:\", err)\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Create a gRPC client in Go that communicates with a Unix domain socket server for various deployment operations.\n\nStruct Description: The DeployClient struct represents a gRPC client that connects to a deployment agent server via Unix domain socket and provides methods for different deployment operations.\n\nFields:\nsocketPath: string - The filesystem path to the Unix domain socket for connecting to the gRPC server\n\nMethods:\nNewDeployClient: [Name](socketPath string) -> *DeployClient - Creates a new DeployClient instance with the specified socket path\nDeployGuestFs: [Name](ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) -> (*deployapi.DeployGuestFsResponse, error) - Deploys guest filesystem\nResizeFs: [Name](ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Resizes filesystem\nFormatFs: [Name](ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Formats filesystem\nSaveToGlance: [Name](ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) -> (*deployapi.SaveToGlanceResponse, error) - Saves image to Glance\nProbeImageInfo: [Name](ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) -> (*deployapi.ImageInfo, error) - Probes image information\nConnectEsxiDisks: [Name](ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) -> (*deployapi.EsxiDisksConnectionInfo, error) - Connects ESXi disks\nDisconnectEsxiDisks: [Name](ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Disconnects ESXi disks",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdeployapi \"yunion.io/x/onecloud/pkg/hostman/hostdeployer/apis\"\n)\n\ntype DeployClient struct {\n\tsocketPath string\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\treturn &DeployClient{socketPath}\n}\n\nfunc grcpDialWithUnixSocket(ctx context.Context, socketPath string) (*grpc.ClientConn, error) {\n\treturn grpc.DialContext(ctx, socketPath, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(time.Second*3),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\tret, err := client.DeployGuestFs(ctx, in, opts...)\n\treturn ret, err\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(\n\tctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption,\n) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(\n\tctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption,\n) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.DisconnectEsxiDisks(ctx, in, opts...)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tdeployapi \"path/to/deployapi\"\n)\n\ntype DeployClient struct {\n\tsocketPath string\n\tconn       *grpc.ClientConn\n\tclient     deployapi.DeployAgentClient\n}\n\nfunc NewDeployClient(socketPath string) (*DeployClient, error) {\n\tconn, err := grpc.Dial(\n\t\tsocketPath,\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", addr)\n\t\t}),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn &DeployClient{socketPath: socketPath, conn: conn, client: client}, nil\n}\n\nfunc (dc *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\treturn dc.client.DeployGuestFs(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn dc.client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn dc.client.FormatFs(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\treturn dc.client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\treturn dc.client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) ConnectEsxiDisks(ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) (*deployapi.EsxiDisksConnectionInfo, error) {\n\treturn dc.client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (dc *DeployClient) DisconnectEsxiDisks(ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn dc.client.DisconnectEsxiDisks(ctx, in, opts...)\n}\n```"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a function that establishes a secure or insecure gRPC client connection to a server and returns a client instance for making RPC calls.\n\nFunction Description: The function `createGRPCClient` establishes a connection to a gRPC server using the provided server address and security options. It supports both TLS-secured connections (with optional certificate verification) and insecure connections. The function returns a client instance that can be used to make RPC calls to the server.\n\nInput:\n- `serverAddr` (string): The address of the gRPC server in \"host:port\" format\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string, optional): Path to the CA certificate file for TLS verification (required if useTLS is true)\n- `serverHostOverride` (string, optional): Server name used for TLS hostname verification\n\nOutput:\n- `pb.RouteGuideClient`: A gRPC client instance for making RPC calls\n- `*grpc.ClientConn`: The established gRPC connection (should be closed by the caller when done)\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "import (\n    \"context\"\n    \"crypto/tls\"\n    \"crypto/x509\"\n    \"io/ioutil\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials\"\n    pb \"path/to/your/protobuf/package\"\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, *grpc.ClientConn, error) {\n    var opts []grpc.DialOption\n\n    if useTLS {\n        if caFile == \"\" {\n            return nil, nil, fmt.Errorf(\"caFile must be provided when useTLS is true\")\n        }\n\n        caCert, err := ioutil.ReadFile(caFile)\n        if err != nil {\n            return nil, nil, fmt.Errorf(\"failed to read CA file: %v\", err)\n        }\n\n        certPool := x509.NewCertPool()\n        if !certPool.AppendCertsFromPEM(caCert) {\n            return nil, nil, fmt.Errorf(\"failed to append CA certs\")\n        }\n\n        creds := credentials.NewTLS(&tls.Config{\n            ServerName: serverHostOverride,\n            RootCAs:    certPool,\n        })\n        opts = append(opts, grpc.WithTransportCredentials(creds))\n    } else {\n        opts = append(opts, grpc.WithInsecure())\n    }\n\n    conn, err := grpc.DialContext(context.Background(), serverAddr, opts...)\n    if err != nil {\n        return nil, nil, fmt.Errorf(\"failed to dial server: %v\", err)\n    }\n\n    client := pb.NewRouteGuideClient(conn)\n    return client, conn, nil\n}"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a gRPC client in Go that connects to a gRPC server over a Unix domain socket, retrieves configuration information, and manages base virtual machine instances.\n\nStruct Description: The grpccache struct represents a gRPC client cache that maintains a connection to a gRPC server and stores VM configuration information.\n\nFields:\nconn: *grpc.ClientConn - Maintains the active connection to the gRPC server\nconfig: *vc.VMConfig - Stores the virtual machine configuration obtained from the server\n\nMethods:\nNew: [Name](ctx context.Context, endpoint string) -> (base.FactoryBase, error) - Creates a new grpccache instance by establishing a connection to the gRPC server at the specified endpoint and retrieving the VM configuration.\nGetBaseVM: [Name](ctx context.Context, config vc.VMConfig) -> (*vc.VM, error) - Retrieves a base VM instance from the cache server and closes the connection when done. The method converts the gRPC response to a local VM object.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\n\ttypes \"github.com/gogo/protobuf/types\"\n\tpb \"github.com/kata-containers/runtime/protocols/cache\"\n\tvc \"github.com/kata-containers/runtime/virtcontainers\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype grpccache struct {\n\tconn   *grpc.ClientConn\n\tconfig *vc.VMConfig\n}\n\nfunc New(ctx context.Context, endpoint string) (base.FactoryBase, error) {\n\tconn, err := grpc.Dial(fmt.Sprintf(\"unix://%s\", endpoint), grpc.WithInsecure())\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to connect %q\", endpoint)\n\t}\n\n\tjConfig, err := pb.NewCacheServiceClient(conn).Config(ctx, &types.Empty{})\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to Config\")\n\t}\n\n\tconfig, err := vc.GrpcToVMConfig(jConfig)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to convert JSON to VMConfig\")\n\t}\n\n\treturn &grpccache{conn: conn, config: config}, nil\n}\n\nfunc (g *grpccache) GetBaseVM(ctx context.Context, config vc.VMConfig) (*vc.VM, error) {\n\tdefer g.conn.Close()\n\tgVM, err := pb.NewCacheServiceClient(g.conn).GetBaseVM(ctx, &types.Empty{})\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to GetBaseVM\")\n\t}\n\treturn vc.NewVMFromGrpc(ctx, gVM, *g.config)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tvc \"path/to/vmconfig/package\"\n)\n\ntype grpccache struct {\n\tconn   *grpc.ClientConn\n\tconfig *vc.VMConfig\n}\n\nfunc New(ctx context.Context, endpoint string) (base.FactoryBase, error) {\n\tconn, err := grpc.DialContext(ctx, endpoint, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t}))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to gRPC server: %v\", err)\n\t}\n\n\tclient := vc.NewVMConfigClient(conn)\n\tconfig, err := client.GetVMConfig(ctx, &vc.GetVMConfigRequest{})\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, fmt.Errorf(\"failed to retrieve VM configuration: %v\", err)\n\t}\n\n\treturn &grpccache{conn: conn, config: config}, nil\n}\n\nfunc (g *grpccache) GetBaseVM(ctx context.Context, config vc.VMConfig) (*vc.VM, error) {\n\tclient := vc.NewVMClient(g.conn)\n\tvmResponse, err := client.GetBaseVM(ctx, &vc.GetBaseVMRequest{Config: &config})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve base VM: %v\", err)\n\t}\n\n\tvm := &vc.VM{\n\t\tID:     vmResponse.VM.ID,\n\t\tStatus: vmResponse.VM.Status,\n\t}\n\n\tg.conn.Close()\n\treturn vm, nil\n}\n\nfunc main() {\n\t// Example usage\n\tctx := context.Background()\n\tendpoint := \"/path/to/unix/socket\"\n\n\tcache, err := New(ctx, endpoint)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating gRPC cache:\", err)\n\t\treturn\n\t}\n\n\tvmConfig := vc.VMConfig{ /* populate VMConfig fields */ }\n\tvm, err := cache.GetBaseVM(ctx, vmConfig)\n\tif err != nil {\n\t\tfmt.Println(\"Error getting base VM:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Retrieved VM:\", vm)\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a function to send synchronous HTTP requests with custom configurations including headers, authentication, and transport settings.\n\nFunction Description: The function SendWebRequestSync sends an HTTP request with customizable method, headers, body, and authentication. It handles the response, checks for success status codes, and properly manages resources. The function uses a pre-configured HTTP client with custom transport settings for timeout and TLS configuration.\n\nInput:\n- ctx (context.Context): Context for request cancellation and timeouts\n- webhook (*monitor.SendWebhookSync): Pointer to a struct containing request parameters including:\n  - HttpMethod (string): HTTP method (GET, POST, etc.)\n  - Url (string): Target URL\n  - Body (string): Request body content\n  - ContentType (string): Content-Type header value\n  - User (string): Username for basic auth\n  - Password (string): Password for basic auth\n  - HttpHeader (map[string]string): Additional HTTP headers\n\nOutput:\n- error: Returns nil on success (2xx status code), or an error describing the failure (non-2xx status code or transport error)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/context/ctxhttp\"\n\t\"moul.io/http2curl/v2\"\n\n\t\"yunion.io/x/log\"\n\n\t\"yunion.io/x/onecloud/pkg/apis/monitor\"\n)\nvar netTransport = &http.Transport{\n\tTLSClientConfig: &tls.Config{\n\t\tRenegotiation: tls.RenegotiateFreelyAsClient,\n\t},\n\tProxy: http.ProxyFromEnvironment,\n\tDialContext: (&net.Dialer{\n\t\tTimeout: 30 * time.Second,\n\t}).DialContext,\n\tTLSHandshakeTimeout: 5 * time.Second,\n}\nvar netClient = &http.Client{\n\tTimeout:   time.Second * 30,\n\tTransport: netTransport,\n}\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tif webhook.HttpMethod == \"\" {\n\t\twebhook.HttpMethod = http.MethodPost\n\t}\n\n\trequest, err := http.NewRequest(webhook.HttpMethod, webhook.Url, bytes.NewReader([]byte(webhook.Body)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif webhook.ContentType == \"\" {\n\t\twebhook.ContentType = \"application/json\"\n\t}\n\n\trequest.Header.Add(\"Content-Type\", webhook.ContentType)\n\trequest.Header.Add(\"User-Agent\", \"OneCloud Monitor\")\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\trequest.Header.Add(\"Authorization\", GetBasicAuthHeader(webhook.User, webhook.Password))\n\t}\n\n\tfor k, v := range webhook.HttpHeader {\n\t\trequest.Header.Set(k, v)\n\t}\n\n\tcurlCmd, _ := http2curl.GetCurlCommand(request)\n\tlog.Debugf(\"webhook curl: %s\", curlCmd)\n\n\tresp, err := ctxhttp.Do(ctx, netClient, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 == 2 {\n\t\tif _, err := io.Copy(ioutil.Discard, resp.Body); err != nil {\n\t\t\tlog.Errorf(\"Failed to copy resp.Body to ioutil.Discard: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Errorf(\"Webhook failed statuscode: %s, body: %s\", resp.Status, string(body))\n\treturn fmt.Errorf(\"Webhook response status %v\", resp.Status)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype SendWebhookSync struct {\n\tHttpMethod  string\n\tUrl         string\n\tBody        string\n\tContentType string\n\tUser        string\n\tPassword    string\n\tHttpHeader  map[string]string\n}\n\nfunc SendWebRequestSync(ctx context.Context, webhook *SendWebhookSync) error {\n\treq, err := http.NewRequestWithContext(ctx, webhook.HttpMethod, webhook.Url, bytes.NewBufferString(webhook.Body))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", webhook.ContentType)\n\tfor key, value := range webhook.HttpHeader {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\treq.SetBasicAuth(webhook.User, webhook.Password)\n\t}\n\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   10 * time.Second,\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tbodyBytes, _ := ioutil.ReadAll(resp.Body)\n\t\treturn errors.New(string(bodyBytes))\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a server, with optional TLS security, and returns a client instance for a specified service.\n\nFunction Description: The function `createGRPCClient` initializes a gRPC client connection to a specified server address. It supports both secure (TLS) and insecure connections based on input parameters. After establishing the connection, it creates and returns a client instance for the RouteGuide service.\n\nInput: \n- `serverAddr` (string): The address of the gRPC server to connect to\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string): Path to the CA certificate file (required if useTLS is true)\n- `serverHostOverride` (string): Server name used for TLS host verification\n\nOutput:\n- `pb.RouteGuideClient`: The generated gRPC client instance for the RouteGuide service\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/examples/data\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tif *caFile == \"\" {\n\t\t\t*caFile = data.Path(\"x509/ca_cert.pem\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tconn, err := grpc.NewClient(*serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tpb \"path/to/your/protobuf/package\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"os\"\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, error) {\n\tvar opts []grpc.DialOption\n\tif useTLS {\n\t\tif caFile == \"\" {\n\t\t\treturn nil, status.Error(codes.InvalidArgument, \"caFile must be provided when useTLS is true\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(caFile, serverHostOverride)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := pb.NewRouteGuideClient(conn)\n\treturn client, nil\n}\n\nfunc main() {\n\t// Example usage\n\tserverAddr := \"localhost:50051\"\n\tuseTLS := false\n\tcaFile := \"\"\n\tserverHostOverride := \"\"\n\n\tclient, err := createGRPCClient(serverAddr, useTLS, caFile, serverHostOverride)\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\n\t// Use the client...\n\t_ = client\n}\n```"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: The task involves creating a gRPC probe client in Go that can establish connections to gRPC servers, perform various probe operations (echo, read, write), and collect metrics about the probe results.\n\nStruct Description: The Probe struct represents a gRPC probe client that manages connections to multiple targets, performs probe operations, and tracks results.\n\nFields:\n\nname: [string] - The name of the probe instance\nsrc: [string] - The source identifier for the probe\nopts: [*options.Options] - Configuration options for the probe\nc: [*configpb.ProbeConf] - gRPC probe-specific configuration\nl: [*logger.Logger] - Logger for recording probe events\ndialOpts: [[]grpc.DialOption] - Options for gRPC dialing\ntargets: [[]endpoint.Endpoint] - List of target endpoints to probe\ncancelFuncs: [map[string]context.CancelFunc] - Map of cancel functions for target operations\ntargetsMu: [sync.Mutex] - Mutex for synchronizing access to targets\nresults: [map[string]*probeRunResult] - Map of probe results by target\n\nMethods:\n\nconnectWithRetry: [func(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn] -> [*grpc.ClientConn] - Establishes a gRPC connection to the target with retry logic, using the specified context, target address, message pattern, and result tracker. Returns the established connection or nil if failed.\n\noneTargetLoop: [func(ctx context.Context, tgt string, index int, result *probeRunResult)] -> [None] - Main probe loop for a single target that continuously performs probe operations (echo/read/write) at regular intervals, using the specified context, target address, target index, and result tracker. Manages connection lifecycle and records metrics.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/google/cloudprober/logger\"\n\t\"github.com/google/cloudprober/metrics\"\n\tconfigpb \"github.com/google/cloudprober/probes/grpc/proto\"\n\t\"github.com/google/cloudprober/probes/options\"\n\t\"github.com/google/cloudprober/probes/probeutils\"\n\t\"github.com/google/cloudprober/targets/endpoint\"\n\n\tgrpcprobepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\tservicepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\t\"google.golang.org/grpc/credentials/local\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype Probe struct {\n\tname     string\n\tsrc      string\n\topts     *options.Options\n\tc        *configpb.ProbeConf\n\tl        *logger.Logger\n\tdialOpts []grpc.DialOption\n\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\n\tresults map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\tsync.Mutex\n\ttarget        string\n\ttotal         metrics.Int\n\tsuccess       metrics.Int\n\tlatency       metrics.Value\n\tconnectErrors metrics.Int\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tconnectTimeout := p.opts.Timeout\n\tif p.c.GetConnectTimeoutMsec() > 0 {\n\t\tconnectTimeout = time.Duration(p.c.GetConnectTimeoutMsec()) * time.Millisecond\n\t}\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in connect loop.\", msgPattern)\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\t\tconnCtx, cancelFunc := context.WithTimeout(ctx, connectTimeout)\n\n\t\tif uriScheme := p.c.GetUriScheme(); uriScheme != \"\" {\n\t\t\ttgt = uriScheme + tgt\n\t\t}\n\t\tconn, err = grpc.DialContext(connCtx, tgt, p.dialOpts...)\n\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tp.l.Warningf(\"ProbeId(%v) connect error: %v\", msgPattern, err)\n\t\t} else {\n\t\t\tp.l.Infof(\"ProbeId(%v) connection established.\", msgPattern)\n\t\t\tbreak\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.connectErrors.Inc()\n\t\tresult.Unlock()\n\t}\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tmsgPattern := fmt.Sprintf(\"%s,%s%s,%03d\", p.src, p.c.GetUriScheme(), tgt, index)\n\n\tconn := p.connectWithRetry(ctx, tgt, msgPattern, result)\n\tif conn == nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := servicepb.NewProberClient(conn)\n\ttimeout := p.opts.Timeout\n\tmethod := p.c.GetMethod()\n\n\tmsgSize := p.c.GetBlobSize()\n\tmsg := make([]byte, msgSize)\n\tprobeutils.PatternPayload(msg, []byte(msgPattern))\n\tticker := time.NewTicker(p.opts.Interval)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in request loop.\", msgPattern)\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t}\n\n\t\treqCtx, cancelFunc := context.WithTimeout(ctx, timeout)\n\t\tvar success int64\n\t\tvar delta time.Duration\n\t\tstart := time.Now()\n\t\tvar err error\n\t\tvar peer peer.Peer\n\t\topts := []grpc.CallOption{\n\t\t\tgrpc.WaitForReady(true),\n\t\t\tgrpc.Peer(&peer),\n\t\t}\n\t\tswitch method {\n\t\tcase configpb.ProbeConf_ECHO:\n\t\t\treq := &grpcprobepb.EchoMessage{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.Echo(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_READ:\n\t\t\treq := &grpcprobepb.BlobReadRequest{\n\t\t\t\tSize: proto.Int32(msgSize),\n\t\t\t}\n\t\t\t_, err = client.BlobRead(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_WRITE:\n\t\t\treq := &grpcprobepb.BlobWriteRequest{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.BlobWrite(reqCtx, req, opts...)\n\t\tdefault:\n\t\t\tp.l.Criticalf(\"Method %v not implemented\", method)\n\t\t}\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tpeerAddr := \"unknown\"\n\t\t\tif peer.Addr != nil {\n\t\t\t\tpeerAddr = peer.Addr.String()\n\t\t\t}\n\t\t\tp.l.Warningf(\"ProbeId(%s) request failed: %v. ConnState: %v. Peer: %v\", msgPattern, err, conn.GetState(), peerAddr)\n\t\t} else {\n\t\t\tsuccess = 1\n\t\t\tdelta = time.Since(start)\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.success.AddInt64(success)\n\t\tresult.latency.AddFloat64(delta.Seconds() / p.opts.LatencyUnit.Seconds())\n\t\tresult.Unlock()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/connectivity\"\n)\n\ntype Probe struct {\n\tname        string\n\tsrc         string\n\topts        *options.Options\n\tc           *configpb.ProbeConf\n\tl           *logger.Logger\n\tdialOpts    []grpc.DialOption\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\tresults     map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\t// Define fields for tracking probe results\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor {\n\t\tconn, err = grpc.DialContext(ctx, tgt, p.dialOpts...)\n\t\tif err == nil && conn.GetState() == connectivity.Ready {\n\t\t\treturn conn\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-time.After(time.Second): // Retry after 1 second\n\t\t}\n\t}\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tconn := p.connectWithRetry(ctx, tgt, \"\", result)\n\t\t\tif conn == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Perform echo/read/write operations\n\t\t\t// Record metrics in result\n\t\t\tconn.Close()\n\t\t\ttime.Sleep(time.Second) // Interval between operations\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage of Probe struct\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a server, sends multiple requests, and processes the responses using the GoFrame framework.\n\nFunction Description: The function connects to a gRPC server using service discovery, creates a client stub, and makes repeated calls to a SayHello RPC method. It handles connection errors and response processing, with built-in logging and graceful connection closure.\n\nInput: None (uses package-level constants and context)\n\nOutput: None (logs results to console via GoFrame's logging system)\n\nNote: The function includes an internal loop that makes 10 RPC calls with a 1-second delay between calls. Connection is automatically closed when function completes.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/gsvc\"\n\t\"github.com/gogf/gf/v2/os/gctx\"\n\n\t\"github.com/gogf/gf/contrib/rpc/grpcx/v2\"\n\n\tpb \"github.com/gogf/gf/example/rpc/grpcx/rawgrpc/helloworld\"\n)\nfunc main() {\n\tvar (\n\t\tctx     = gctx.GetInitCtx()\n\t\tservice = gsvc.NewServiceWithName(`hello`)\n\t)\n\tconn, err := grpc.Dial(\n\t\tfmt.Sprintf(`%s://%s`, gsvc.Schema, service.GetKey()),\n\t\tgrpcx.Balancer.WithRandom(),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tg.Log().Fatalf(ctx, \"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\tfor i := 0; i < 10; i++ {\n\t\tres, err := client.SayHello(ctx, &pb.HelloRequest{Name: `GoFrame`})\n\t\tif err != nil {\n\t\t\tg.Log().Fatalf(ctx, \"could not greet: %+v\", err)\n\t\t}\n\t\tg.Log().Printf(ctx, \"Greeting: %s\", res.Message)\n\t\ttime.Sleep(time.Second)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/ggrpc\"\n\t\"github.com/gogf/gf/v2/os/glog\"\n\t\"google.golang.org/grpc\"\n)\n\nconst (\n\tserviceName = \"my.grpc.service\"\n\trpcMethod   = \"/my.grpc.service/SayHello\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Create a gRPC client connection using service discovery.\n\tconn, err := ggrpc.NewClientConn(ctx, serviceName)\n\tif err != nil {\n\t\tglog.Fatalf(ctx, \"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := ggrpc.NewClient(conn)\n\n\tfor i := 0; i < 10; i++ {\n\t\t// Prepare the request message.\n\t\trequest := &ggrpc.Request{\n\t\t\tMethod: rpcMethod,\n\t\t\tData:   map[string]interface{}{\"name\": \"GoFrame\"},\n\t\t}\n\n\t\t// Send the request and receive the response.\n\t\tresponse, err := client.Invoke(ctx, request)\n\t\tif err != nil {\n\t\t\tglog.Errorf(ctx, \"Error calling SayHello: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Process the response.\n\t\tglog.Infof(ctx, \"Response from SayHello: %v\", response.Data)\n\n\t\t// Wait for 1 second before the next call.\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC management server for Envoy's xDS (Discovery Service) protocol, supporting dynamic configuration updates and load reporting.\n\nStruct Description: The ManagementServer struct represents a gRPC server that implements Envoy's xDS protocol, including Aggregated Discovery Service (ADS) and optionally Load Reporting Service (LRS). It maintains a snapshot cache of resources and handles gRPC connections.\n\nFields:\n- Address: string - The network address the server is listening on\n- LRSServer: *fakeserver.Server - Optional fake LRS server instance\n- cancel: context.CancelFunc - Function to cancel the server's context\n- xs: v3server.Server - xDS server implementation\n- gs: *grpc.Server - gRPC server instance\n- cache: v3cache.SnapshotCache - Cache for storing configuration snapshots\n- version: int - Current version of the configuration\n- logger: interface{ Logf(format string, args ...any) } - Logger interface for output\n\nMethods:\n- StartManagementServer(*testing.T, ManagementServerOptions) *ManagementServer - Creates and starts a new management server instance. Takes testing context and options, returns initialized server.\n- Update(context.Context, UpdateOptions) error - Updates the server's configuration snapshot with new resources. Takes context and update options, returns error if update fails.\n- Stop() - Stops the server and cleans up resources. No parameters or return values.\n\nThe struct provides dynamic configuration management for Envoy proxies through the xDS protocol, with support for listeners, routes, clusters, and endpoints configuration.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/envoyproxy/go-control-plane/pkg/cache/types\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils/xds/fakeserver\"\n\n\tv3clusterpb \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tv3endpointpb \"github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3\"\n\tv3listenerpb \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tv3routepb \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3cache \"github.com/envoyproxy/go-control-plane/pkg/cache/v3\"\n\tv3resource \"github.com/envoyproxy/go-control-plane/pkg/resource/v3\"\n\tv3server \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n)\n\ntype ManagementServer struct {\n\tAddress   string\n\tLRSServer *fakeserver.Server\n\n\tcancel  context.CancelFunc\n\txs      v3server.Server\n\tgs      *grpc.Server\n\tcache   v3cache.SnapshotCache\n\tversion int\n\n\tlogger interface {\n\t\tLogf(format string, args ...any)\n\t}\n}\n\nfunc StartManagementServer(t *testing.T, opts ManagementServerOptions) *ManagementServer {\n\twait := !opts.AllowResourceSubset\n\tcache := v3cache.NewSnapshotCache(wait, v3cache.IDHash{}, serverLogger{t})\n\n\tlis := opts.Listener\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to listen on localhost:0: %v\", err)\n\t\t}\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcallbacks := v3server.CallbackFuncs{\n\t\tStreamOpenFunc:     opts.OnStreamOpen,\n\t\tStreamClosedFunc:   opts.OnStreamClosed,\n\t\tStreamRequestFunc:  opts.OnStreamRequest,\n\t\tStreamResponseFunc: opts.OnStreamResponse,\n\t}\n\n\txs := v3server.NewServer(ctx, cache, callbacks)\n\tgs := grpc.NewServer()\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(gs, xs)\n\n\tmgmtServer := &ManagementServer{\n\t\tAddress: lis.Addr().String(),\n\t\tcancel:  cancel,\n\t\tversion: 0,\n\t\tgs:      gs,\n\t\txs:      xs,\n\t\tcache:   cache,\n\t\tlogger:  t,\n\t}\n\tif opts.SupportLoadReportingService {\n\t\tlrs := fakeserver.NewServer(lis.Addr().String())\n\t\tv3lrsgrpc.RegisterLoadReportingServiceServer(gs, lrs)\n\t\tmgmtServer.LRSServer = lrs\n\t}\n\n\tgo gs.Serve(lis)\n\tt.Cleanup(mgmtServer.Stop)\n\treturn mgmtServer\n}\n\nfunc (s *ManagementServer) Update(ctx context.Context, opts UpdateOptions) error {\n\ts.version++\n\n\tresources := map[v3resource.Type][]types.Resource{\n\t\tv3resource.ListenerType: resourceSlice(opts.Listeners),\n\t\tv3resource.RouteType:    resourceSlice(opts.Routes),\n\t\tv3resource.ClusterType:  resourceSlice(opts.Clusters),\n\t\tv3resource.EndpointType: resourceSlice(opts.Endpoints),\n\t}\n\tsnapshot, err := v3cache.NewSnapshot(strconv.Itoa(s.version), resources)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create new snapshot cache: %v\", err)\n\t}\n\tif !opts.SkipValidation {\n\t\tif err := snapshot.Consistent(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create new resource snapshot: %v\", err)\n\t\t}\n\t}\n\n\tif err := s.cache.SetSnapshot(ctx, opts.NodeID, snapshot); err != nil {\n\t\treturn fmt.Errorf(\"failed to update resource snapshot in management server: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *ManagementServer) Stop() {\n\tif s.cancel != nil {\n\t\ts.cancel()\n\t}\n\ts.gs.Stop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\tv3cache \"github.com/envoyproxy/go-control-plane/pkg/cache/v3\"\n\tv3server \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n\tfakeserver \"github.com/envoyproxy/go-control-plane/pkg/test/v3\"\n\n\t\"github.com/envoyproxy/go-control-plane/pkg/resource/v3\"\n)\n\ntype ManagementServer struct {\n\tAddress   string\n\tLRSServer *fakeserver.Server\n\tcancel    context.CancelFunc\n\txs        v3server.Server\n\tgs        *grpc.Server\n\tcache     v3cache.SnapshotCache\n\tversion   int\n\tlogger    interface{ Logf(format string, args ...any) }\n}\n\ntype ManagementServerOptions struct {\n\tAddress   string\n\tLRSServer *fakeserver.Server\n\tLogger    interface{ Logf(format string, args ...any) }\n}\n\ntype UpdateOptions struct {\n\tResources map[string][]v3cache.Resource\n}\n\nfunc (ms *ManagementServer) StartManagementServer(t *testing.T, opts ManagementServerOptions) *ManagementServer {\n\tctx, cancel := context.WithCancel(context.Background())\n\tms.cancel = cancel\n\tms.Address = opts.Address\n\tms.LRSServer = opts.LRSServer\n\tms.logger = opts.Logger\n\n\tms.cache = v3cache.NewSnapshotCache(false, v3cache.IDHash{}, ms.logger)\n\tms.xs = v3server.NewServer(ctx, ms.cache, nil)\n\n\tms.gs = grpc.NewServer()\n\tv3server.RegisterServer(ms.gs, ms.xs)\n\n\tlis, err := net.Listen(\"tcp\", ms.Address)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := ms.gs.Serve(lis); err != nil {\n\t\t\tt.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn ms\n}\n\nfunc (ms *ManagementServer) Update(ctx context.Context, opts UpdateOptions) error {\n\tms.version++\n\tsnapshot := v3cache.NewSnapshot(fmt.Sprintf(\"%d\", ms.version), opts.Resources)\n\tif err := ms.cache.SetSnapshot(ctx, \"node\", snapshot); err != nil {\n\t\treturn fmt.Errorf(\"failed to set snapshot: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (ms *ManagementServer) Stop() {\n\tms.cancel()\n\tms.gs.GracefulStop()\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a function that retrieves metadata from a Google Cloud instance using a custom HTTP client with specific headers and returns both the metadata value and its ETag.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the Google Cloud metadata server to fetch instance metadata. It uses a custom HTTP client with timeout configurations and sets required headers (\"Metadata-Flavor\" and \"User-Agent\"). The function handles various response scenarios including errors and not-found statuses, and returns the metadata value along with its ETag if successful.\n\nInput:\n- `client` (*http.Client): A custom HTTP client configured with specific timeout settings\n- `suffix` (string): The metadata path suffix to append to the base metadata URL\n\nOutput:\n- `value` (string): The retrieved metadata value\n- `etag` (string): The ETag header value from the response\n- `err` (error): Any error encountered during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "func getETag(client *http.Client, suffix string) (string, string, error) {\n    const metadataURL = \"http://metadata.google.internal/computeMetadata/v1/\"\n    req, err := http.NewRequest(\"GET\", metadataURL+suffix, nil)\n    if err != nil {\n        return \"\", \"\", err\n    }\n    req.Header.Set(\"Metadata-Flavor\", \"Google\")\n    req.Header.Set(\"User-Agent\", \"custom-client\")\n\n    resp, err := client.Do(req)\n    if err != nil {\n        return \"\", \"\", err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode == http.StatusNotFound {\n        return \"\", \"\", fmt.Errorf(\"metadata not found: %s\", suffix)\n    }\n    if resp.StatusCode != http.StatusOK {\n        return \"\", \"\", fmt.Errorf(\"failed to retrieve metadata: %s\", resp.Status)\n    }\n\n    value, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return \"\", \"\", err\n    }\n\n    etag := resp.Header.Get(\"ETag\")\n    return string(value), etag, nil\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a function that sends a multipart/form-data POST request to a specified URL with file upload capabilities and custom headers.\n\nFunction Description: The function performs an HTTP POST request with multipart form data, including file upload functionality. It constructs the request with custom headers, sends it using a custom HTTP client, and returns the response body as a string. The function handles file operations and request/response lifecycle properly with appropriate error handling.\n\nInput:\n- url (string): The target URL for the POST request\n- method (string): HTTP method (typically \"POST\")\n- filePath (string): Path to the file to be uploaded\n- formFields (map[string]string): Key-value pairs for form fields\n- headers (map[string]string): Custom headers to include in the request\n\nOutput:\n- (string): The response body from the server\n- (error): Any error that occurred during the process (nil if successful)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/image/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"image_signature\", \"1faaf9020e0df18fdf0429e0db211f37\")\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\")\n\tdefer file.Close()\n\tpart4,\n\t\terrFile4 := writer.CreateFormFile(\"image_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\t_ = writer.WriteField(\"filename\", \"auto4_huchao.1faaf9020e0df18fdf0429e0db211f37_test\u73af\u5883slicess_\u5361\u901a_P_HC_HC_en_1X1_0s\")\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc sendMultipartRequest(url, method, filePath string, formFields, headers map[string]string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to open file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tpart, err := writer.CreateFormFile(\"file\", filepath.Base(filePath))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to create form file: %w\", err)\n\t}\n\n\t_, err = io.Copy(part, file)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to copy file content: %w\", err)\n\t}\n\n\tfor key, val := range formFields {\n\t\terr = writer.WriteField(key, val)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to write form field: %w\", err)\n\t\t}\n\t}\n\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to close writer: %w\", err)\n\t}\n\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tfor key, val := range headers {\n\t\treq.Header.Set(key, val)\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to send request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\treturn string(respBody), nil\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles DNS queries and watch functionality, supporting TLS encryption and OpenTracing for distributed tracing.\n\nStruct Description: ServergRPC is a gRPC server implementation that processes DNS queries and provides watch capabilities. It manages server lifecycle, handles TLS configuration, and integrates with tracing systems.\n\nFields:\n\nServer: [*Server] - Embedded DNS server instance that handles core DNS functionality\ngrpcServer: [*grpc.Server] - The gRPC server instance\nlistenAddr: [net.Addr] - Network address the server is listening on\ntlsConfig: [*tls.Config] - TLS configuration for secure connections\nwatch: [watch.Watcher] - Watcher instance for handling watch requests\n\nMethods:\n\nNewServergRPC: [func(addr string, group []*Config) (*ServergRPC, error)] -> Creates a new ServergRPC instance with the given address and configuration group\nServe: [func(l net.Listener) error] -> Starts the gRPC server on the provided listener\nQuery: [func(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error)] -> Handles incoming DNS query requests\nWatch: [func(stream pb.DnsService_WatchServer) error] -> Handles watch stream requests\nStop: [func() error] -> Gracefully stops the server and watcher\nShutdown: [func() error] -> Immediately stops the server without waiting for connections to close",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/coredns/coredns/pb\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/miekg/dns\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype ServergRPC struct {\n\t*Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ts, err := NewServer(addr, group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar tlsConfig *tls.Config\n\tfor _, conf := range s.zones {\n\t\ttlsConfig = conf.TLSConfig\n\t}\n\treturn &ServergRPC{Server: s, tlsConfig: tlsConfig, watch: watch.NewWatcher(watchables(s.zones))}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\ts.m.Lock()\n\ts.listenAddr = l.Addr()\n\ts.m.Unlock()\n\n\tif s.Tracer() != nil {\n\t\tonlyIfParent := func(parentSpanCtx opentracing.SpanContext, method string, req, resp interface{}) bool {\n\t\t\treturn parentSpanCtx != nil\n\t\t}\n\t\tintercept := otgrpc.OpenTracingServerInterceptor(s.Tracer(), otgrpc.IncludingSpans(onlyIfParent))\n\t\ts.grpcServer = grpc.NewServer(grpc.UnaryInterceptor(intercept))\n\t} else {\n\t\ts.grpcServer = grpc.NewServer()\n\t}\n\n\tpb.RegisterDnsServiceServer(s.grpcServer, s)\n\n\tif s.tlsConfig != nil {\n\t\tl = tls.NewListener(l, s.tlsConfig)\n\t}\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tmsg := new(dns.Msg)\n\terr := msg.Unpack(in.Msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, ok := peer.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, errors.New(\"no peer in gRPC context\")\n\t}\n\n\ta, ok := p.Addr.(*net.TCPAddr)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no TCP peer in gRPC context: %v\", p.Addr)\n\t}\n\n\tw := &gRPCresponse{localAddr: s.listenAddr, remoteAddr: a, Msg: msg}\n\n\ts.ServeDNS(ctx, w, msg)\n\n\tpacked, err := w.Msg.Pack()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.DnsPacket{Msg: packed}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\treturn s.watch.Watch(stream)\n}\n\nfunc (s *ServergRPC) Stop() (err error) {\n\ts.m.Lock()\n\tdefer s.m.Unlock()\n\tif s.watch != nil {\n\t\ts.watch.Stop()\n\t}\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.GracefulStop()\n\t}\n\treturn\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.Stop()\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/dns/proto\"\n)\n\ntype ServergRPC struct {\n\tServer     *Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ttlsConfig := &tls.Config{\n\t\t// TLS configuration setup\n\t}\n\tcreds := credentials.NewTLS(tlsConfig)\n\tgrpcServer := grpc.NewServer(grpc.Creds(creds))\n\tserver := &ServergRPC{\n\t\tServer:     NewServer(group),\n\t\tgrpcServer: grpcServer,\n\t\tlistenAddr: &net.TCPAddr{IP: net.ParseIP(addr), Port: 53},\n\t\ttlsConfig:  tlsConfig,\n\t\twatch:      NewWatcher(),\n\t}\n\tpb.RegisterDnsServiceServer(grpcServer, server)\n\treturn server, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"Query\")\n\tdefer span.Finish()\n\n\t// Handle DNS query\n\tresponse, err := s.Server.HandleQuery(in)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\tspan := opentracing.StartSpan(\"Watch\")\n\tdefer span.Finish()\n\n\t// Handle watch stream\n\treturn s.watch.HandleStream(stream)\n}\n\nfunc (s *ServergRPC) Stop() error {\n\ts.grpcServer.GracefulStop()\n\treturn s.watch.Stop()\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\ts.grpcServer.Stop()\n\treturn s.watch.Shutdown()\n}\n\nfunc main() {\n\t// Example usage\n\taddr := \"127.0.0.1\"\n\tconfigGroup := []*Config{}\n\tserver, err := NewServergRPC(addr, configGroup)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tlistener, err := net.Listen(\"tcp\", addr+\":53\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := server.Serve(listener); err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a function to push metrics to a Prometheus push gateway using HTTP requests with custom headers and client configuration.\n\nFunction Description: The function `doPush` sends collected metrics to a Prometheus push gateway. It validates the job name and grouping labels, constructs the appropriate URL, encodes the metrics in Protocol Buffer format, and makes an HTTP request with custom headers. It handles errors during the process and checks the response status.\n\nInput:\n- `job` (string): The job name to associate with the pushed metrics\n- `grouping` (map[string]string): Key-value pairs for metric grouping\n- `pushURL` (string): The base URL of the Prometheus push gateway\n- `g` (prometheus.Gatherer): Interface to gather metrics\n- `method` (string): HTTP method to use for the request (e.g., \"POST\")\n\nOutput:\n- `error`: Returns nil on success, or an error describing any failure during the push operation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/common/model\"\n)\n\nconst contentTypeHeader = \"Content-Type\"\n\nvar (\n\tclient         = &http.Client{}\n\tdefaultTimeout = time.Second * 15\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif !strings.Contains(pushURL, \"://\") {\n\t\tpushURL = \"http://\" + pushURL\n\t}\n\tif strings.HasSuffix(pushURL, \"/\") {\n\t\tpushURL = pushURL[:len(pushURL)-1]\n\t}\n\n\tif strings.Contains(job, \"/\") {\n\t\treturn fmt.Errorf(\"job contains '/': %s\", job)\n\t}\n\turlComponents := []string{url.QueryEscape(job)}\n\tfor ln, lv := range grouping {\n\t\tif !model.LabelName(ln).IsValid() {\n\t\t\treturn fmt.Errorf(\"grouping label has invalid name: %s\", ln)\n\t\t}\n\t\tif strings.Contains(lv, \"/\") {\n\t\t\treturn fmt.Errorf(\"value of grouping label %s contains '/': %s\", ln, lv)\n\t\t}\n\t\turlComponents = append(urlComponents, ln, lv)\n\t}\n\tpushURL = fmt.Sprintf(\"%s/metrics/job/%s\", pushURL, strings.Join(urlComponents, \"/\"))\n\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtProtoDelim)\n\tfor _, mf := range mfs {\n\t\tfor _, m := range mf.GetMetric() {\n\t\t\tfor _, l := range m.GetLabel() {\n\t\t\t\tif l.GetName() == \"job\" {\n\t\t\t\t\treturn fmt.Errorf(\"pushed metric %s (%s) already contains a job label\", mf.GetName(), m)\n\t\t\t\t}\n\t\t\t\tif _, ok := grouping[l.GetName()]; ok {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"pushed metric %s (%s) already contains grouping label %s\",\n\t\t\t\t\t\tmf.GetName(), m, l.GetName(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenc.Encode(mf)\n\t}\n\treq, err := http.NewRequest(method, pushURL, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(contentTypeHeader, string(expfmt.FmtProtoDelim))\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 202 {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code %d while pushing to %s: %s\", resp.StatusCode, pushURL, body)\n\t}\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif job == \"\" {\n\t\treturn errors.New(\"job name cannot be empty\")\n\t}\n\n\tif !isValidMethod(method) {\n\t\treturn fmt.Errorf(\"invalid HTTP method: %s\", method)\n\t}\n\n\tu, err := constructURL(pushURL, job, grouping)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtProtoDelim)\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not gather metrics: %v\", err)\n\t}\n\n\tfor _, mf := range mfs {\n\t\tif err := enc.Encode(mf); err != nil {\n\t\t\treturn fmt.Errorf(\"could not encode metric family: %v\", err)\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u, buf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not create request: %v\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", string(expfmt.FmtProtoDelim))\n\treq.Header.Set(\"X-Custom-Header\", \"CustomValue\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not push metrics: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusAccepted {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code %d: %s\", resp.StatusCode, string(body))\n\t}\n\n\treturn nil\n}\n\nfunc isValidMethod(method string) bool {\n\tswitch strings.ToUpper(method) {\n\tcase \"POST\", \"PUT\", \"DELETE\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc constructURL(baseURL, job string, grouping map[string]string) (string, error) {\n\tu, err := url.Parse(baseURL)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid push URL: %v\", err)\n\t}\n\n\tu.Path = fmt.Sprintf(\"/metrics/job/%s\", url.PathEscape(job))\n\tfor k, v := range grouping {\n\t\tu.Path += fmt.Sprintf(\"/%s/%s\", url.PathEscape(k), url.PathEscape(v))\n\t}\n\n\treturn u.String(), nil\n}\n```"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, supports optional transport security, and can register services with reflection capabilities.\n\nFunction Description: The main function sets up and starts a gRPC server with configurable options including transport security (TLS) and logging interceptors. It registers a test service and optionally enables server reflection. The server listens on either a Unix socket or TCP port based on configuration.\n\nInput:\n- *cert (string pointer): Path to certificate file for TLS (optional)\n- *cacert (string pointer): Path to CA certificate file (optional)\n- *key (string pointer): Path to private key file (optional)\n- *requirecert (bool pointer): Whether client certificates are required (optional)\n- *quiet (bool pointer): Whether to disable logging interceptors (optional)\n- *port (int pointer): TCP port to listen on (default used if not provided)\n- getUnixSocket (func() string): Function that returns Unix socket path if available (optional)\n\nOutput:\n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are printed to stderr and the program exits with code 1 on failure\n- Success message with listening address is printed to stdout",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/fullstorydev/grpcurl\"\n\tgrpcurl_testing \"github.com/fullstorydev/grpcurl/internal/testing\"\n)\nfunc main() {\n\tvar opts []grpc.ServerOption\n\tif *cert != \"\" {\n\t\tcreds, err := grpcurl.ServerTransportCredentials(*cacert, *cert, *key, *requirecert)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to configure transport credentials: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tif !*quiet {\n\t\topts = append(opts, grpc.UnaryInterceptor(unaryLogger), grpc.StreamInterceptor(streamLogger))\n\t}\n\n\tvar network, addr string\n\tif getUnixSocket != nil && getUnixSocket() != \"\" {\n\t\tnetwork = \"unix\"\n\t\taddr = getUnixSocket()\n\t} else {\n\t\tnetwork = \"tcp\"\n\t\taddr = fmt.Sprintf(\"127.0.0.1:%d\", *port)\n\t}\n\tl, err := net.Listen(network, addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to listen on socket: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tfmt.Printf(\"Listening on %v\\n\", l.Addr())\n\n\tsvr := grpc.NewServer(opts...)\n\n\tgrpcurl_testing.RegisterTestServiceServer(svr, grpcurl_testing.TestServer{})\n\tif !*noreflect {\n\t\treflection.Register(svr)\n\t}\n\n\tif err := svr.Serve(l); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"GRPC server returned error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nfunc main() {\n\tvar opts []grpc.ServerOption\n\n\t// TLS configuration\n\tif cert != nil && key != nil {\n\t\tcertificate, err := tls.LoadX509KeyPair(*cert, *key)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to load key pair: %v\", err)\n\t\t}\n\n\t\ttlsConfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{certificate},\n\t\t}\n\n\t\tif cacert != nil {\n\t\t\tcaCert, err := ioutil.ReadFile(*cacert)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"failed to read CA certificate: %v\", err)\n\t\t\t}\n\t\t\tcaCertPool := x509.NewCertPool()\n\t\t\tif !caCertPool.AppendCertsFromPEM(caCert) {\n\t\t\t\tlog.Fatalf(\"failed to append CA certificate\")\n\t\t\t}\n\t\t\ttlsConfig.ClientCAs = caCertPool\n\t\t\tif requirecert != nil && *requirecert {\n\t\t\t\ttlsConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t\t\t}\n\t\t}\n\n\t\tcreds := credentials.NewTLS(tlsConfig)\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\t// Logging interceptor\n\tif quiet == nil || !*quiet {\n\t\topts = append(opts, grpc.UnaryInterceptor(loggingInterceptor))\n\t}\n\n\t// Create gRPC server\n\tgrpcServer := grpc.NewServer(opts...)\n\n\t// Register services\n\tregisterTestService(grpcServer)\n\n\t// Enable reflection\n\treflection.Register(grpcServer)\n\n\t// Determine listening address\n\tvar address string\n\tif getUnixSocket != nil {\n\t\taddress = getUnixSocket()\n\t} else if port != nil {\n\t\taddress = fmt.Sprintf(\":%d\", *port)\n\t} else {\n\t\taddress = \":50051\" // default port\n\t}\n\n\t// Start listening\n\tlistener, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tfmt.Printf(\"gRPC server listening on %s\\n\", address)\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\nfunc loggingInterceptor(\n\tctx context.Context,\n\treq interface{},\n\tinfo *grpc.UnaryServerInfo,\n\thandler grpc.UnaryHandler,\n) (interface{}, error) {\n\tlog.Printf(\"request - method:%s\", info.FullMethod)\n\tresp, err := handler(ctx, req)\n\tif err != nil {\n\t\tlog.Printf(\"error - method:%s error:%v\", info.FullMethod, err)\n\t}\n\treturn resp, err\n}\n\nfunc registerTestService(s *grpc.Server) {\n\t// Register your test service here\n}\n```"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a gRPC service struct in Go that manages a gRPC server for key management operations, including starting the server, graceful shutdown, and immediate termination capabilities.\n\nStruct Description: GRPCService represents a gRPC server wrapper that handles Unix domain socket communication for key management services. It manages server lifecycle and configuration.\n\nFields:\naddr: string - The Unix domain socket address the server will listen on\ntimeout: time.Duration - Connection timeout duration for gRPC connections\nserver: *grpc.Server - The underlying gRPC server instance\nkmsService: Service - The key management service implementation to be registered with gRPC\n\nMethods:\nNewGRPCService(address string, timeout time.Duration, kmsService Service) -> *GRPCService - Constructor that initializes a new GRPCService instance with the given address, timeout and service implementation\nListenAndServe() -> error - Starts the gRPC server on the configured Unix domain socket address and begins serving requests\nShutdown() -> void - Gracefully stops the gRPC server, allowing existing connections to complete\nClose() -> void - Immediately stops the gRPC server without waiting for connections to complete",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tkmsapi \"k8s.io/kms/apis/v2\"\n)\n\ntype GRPCService struct {\n\taddr    string\n\ttimeout time.Duration\n\tserver  *grpc.Server\n\n\tkmsService Service\n}\n\nfunc NewGRPCService(\n\taddress string,\n\ttimeout time.Duration,\n\tkmsService Service,\n) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tln, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\n\tgs := grpc.NewServer(\n\t\tgrpc.ConnectionTimeout(s.timeout),\n\t)\n\ts.server = gs\n\n\tkmsapi.RegisterKeyManagementServiceServer(gs, s)\n\n\treturn gs.Serve(ln)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tif s.server != nil {\n\t\ts.server.GracefulStop()\n\t}\n}\n\nfunc (s *GRPCService) Close() {\n\tif s.server != nil {\n\t\ts.server.Stop()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Service interface {\n\t// Define the methods that the key management service should implement\n}\n\ntype GRPCService struct {\n\taddr       string\n\ttimeout    time.Duration\n\tserver     *grpc.Server\n\tkmsService Service\n}\n\nfunc NewGRPCService(address string, timeout time.Duration, kmsService Service) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tserver:     grpc.NewServer(),\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (g *GRPCService) ListenAndServe() error {\n\tlis, err := net.Listen(\"unix\", g.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Register the key management service with the gRPC server\n\t// RegisterService(g.server, g.kmsService) // Assuming RegisterService is a function to register the service\n\treturn g.server.Serve(lis)\n}\n\nfunc (g *GRPCService) Shutdown() {\n\tctx, cancel := context.WithTimeout(context.Background(), g.timeout)\n\tdefer cancel()\n\tg.server.GracefulStop()\n\t<-ctx.Done()\n}\n\nfunc (g *GRPCService) Close() {\n\tg.server.Stop()\n}\n```"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests using ALTS (Application Layer Transport Security) for authentication.\n\nFunction Description: The main function sets up a gRPC server with ALTS credentials, registers an Echo service implementation, and starts listening on a specified TCP port.\n\nInput:\n- port (int): The TCP port number on which the server should listen (passed via command-line flag)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)\n\nMethods:\n- None (this is a function-level implementation, not a struct)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\taltsTC := alts.NewServerCreds(alts.DefaultServerOptions())\n\n\ts := grpc.NewServer(grpc.Creds(altsTC))\n\n\tpb.RegisterEchoServer(s, &ecServer{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype echoServer struct {\n\tpb.UnimplementedEchoServiceServer\n}\n\nfunc (s *echoServer) Echo(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.GetMessage()}, nil\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"The server port\")\n\tflag.Parse()\n\n\tserverOptions := []grpc.ServerOption{\n\t\tgrpc.Creds(alts.NewServerCreds(alts.DefaultServerOptions())),\n\t}\n\n\tgrpcServer := grpc.NewServer(serverOptions...)\n\tpb.RegisterEchoServiceServer(grpcServer, &echoServer{})\n\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Printf(\"Server listening on port %d\", *port)\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, optionally with TLS security, and registers a test service for handling RPC calls.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, configures TLS if enabled, creates a new gRPC server instance, registers a test service, and starts serving incoming requests.\n\nInput:\n- port (int): The port number on which the server should listen\n- useTLS (bool): Flag indicating whether to use TLS security\n- certFile (string): Path to the TLS certificate file (required if useTLS is true)\n- keyFile (string): Path to the TLS private key file (required if useTLS is true)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"google.golang.org/grpc/interop\"\n\ttestpb \"google.golang.org/grpc/interop/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tp := strconv.Itoa(*port)\n\tlis, err := net.Listen(\"tcp\", \":\"+p)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tvar opts []grpc.ServerOption\n\tif *useTLS {\n\t\tcreds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)\n\t\tif err != nil {\n\t\t\tgrpclog.Fatalf(\"Failed to generate credentials %v\", err)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tserver := grpc.NewServer(opts...)\n\ttestpb.RegisterTestServiceServer(server, interop.NewTestServer())\n\tserver.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"log\"\n\t\"net\"\n\t\"context\"\n)\n\n// Define the test service and its methods\ntype testService struct{}\n\nfunc (s *testService) TestMethod(ctx context.Context, req *TestRequest) (*TestResponse, error) {\n\treturn &TestResponse{Message: \"Hello, \" + req.Name}, nil\n}\n\n// Define the request and response messages\ntype TestRequest struct {\n\tName string\n}\n\ntype TestResponse struct {\n\tMessage string\n}\n\n// Register the test service with the gRPC server\nfunc registerTestService(s *grpc.Server) {\n\t// Assuming RegisterTestServiceServer is a generated function from the .proto file\n\tRegisterTestServiceServer(s, &testService{})\n}\n\nfunc main() {\n\tport := 50051\n\tuseTLS := false\n\tcertFile := \"path/to/cert.pem\"\n\tkeyFile := \"path/to/key.pem\"\n\n\tvar opts []grpc.ServerOption\n\tif useTLS {\n\t\tcreds, err := credentials.NewServerTLSFromFile(certFile, keyFile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to generate credentials %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\tserver := grpc.NewServer(opts...)\n\tregisterTestService(server)\n\n\tlis, err := net.Listen(\"tcp\", \":\"+string(port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Printf(\"Server listening on port %d\", port)\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It includes base URLs, user agent, rate limiting capabilities, and various service clients for different API endpoints.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe rate limiting\nrateLimits: [categories]Rate - Rate limit tracking for different categories\ncommon: service - Shared service implementation\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support and handles response decoding",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Rate struct {\n\tLimit     int\n\tRemaining int\n\tReset     time.Time\n}\n\ntype service struct {\n\tclient *Client\n}\n\ntype Client struct {\n\tclientMu   sync.Mutex\n\tclient     *http.Client\n\tBaseURL    *url.URL\n\tUploadURL  *url.URL\n\tUserAgent  string\n\trateMu     sync.Mutex\n\trateLimits map[string]Rate\n\tcommon     service\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\n\tbaseURL, _ := url.Parse(\"https://api.example.com/\")\n\tuploadURL, _ := url.Parse(\"https://upload.example.com/\")\n\n\tc := &Client{\n\t\tclient:     httpClient,\n\t\tBaseURL:    baseURL,\n\t\tUploadURL:  uploadURL,\n\t\tUserAgent:  \"Go-Client\",\n\t\trateLimits: make(map[string]Rate),\n\t}\n\tc.common.client = c\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\trel, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu := c.BaseURL.ResolveReference(rel)\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = new(bytes.Buffer)\n\t\terr := json.NewEncoder(buf).Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*http.Response, error) {\n\tc.clientMu.Lock()\n\tdefer c.clientMu.Unlock()\n\n\tresp, err := c.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn resp, errors.New(\"request failed with status: \" + resp.Status)\n\t}\n\n\tif v != nil {\n\t\terr = json.NewDecoder(resp.Body).Decode(v)\n\t\tif err != nil {\n\t\t\treturn resp, err\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\nfunc main() {\n\t// Example usage\n\tclient := NewClient(nil)\n\treq, err := client.NewRequest(\"GET\", \"/endpoint\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar result interface{}\n\tresp, err := client.Do(context.Background(), req, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_ = resp\n\t_ = result\n}\n```"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests, supports optional TLS encryption, and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The Start function initializes and runs a gRPC server with configurable network address and TLS settings. It sets up keepalive parameters, registers the service implementation, and handles OS signals for graceful shutdown.\n\nInput:\n- addr: string - The network address (host:port) to listen on\n- enableTLS: bool - Flag to enable/disable TLS encryption\n- certificate: auth.Certificate - Certificate configuration for TLS (when enabled)\n\nOutput: None (the function runs indefinitely until a termination signal is received)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\tpb \"github.com/ouqiang/gocron/internal/modules/rpc/proto\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\nfunc Start(addr string, enableTLS bool, certificate auth.Certificate) {\n\tl, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\topts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(keepAliveParams),\n\t\tgrpc.KeepaliveEnforcementPolicy(keepAlivePolicy),\n\t}\n\tif enableTLS {\n\t\ttlsConfig, err := certificate.GetTLSConfigForServer()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\topt := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\topts = append(opts, opt)\n\t}\n\tserver := grpc.NewServer(opts...)\n\tpb.RegisterTaskServer(server, Server{})\n\tlog.Infof(\"server listen on %s\", addr)\n\n\tgo func() {\n\t\terr = server.Serve(l)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)\n\tfor {\n\t\ts := <-c\n\t\tlog.Infoln(\"\u6536\u5230\u4fe1\u53f7 -- \", s)\n\t\tswitch s {\n\t\tcase syscall.SIGHUP:\n\t\t\tlog.Infoln(\"\u6536\u5230\u7ec8\u7aef\u65ad\u5f00\u4fe1\u53f7, \u5ffd\u7565\")\n\t\tcase syscall.SIGINT, syscall.SIGTERM:\n\t\t\tlog.Info(\"\u5e94\u7528\u51c6\u5907\u9000\u51fa\")\n\t\t\tserver.GracefulStop()\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype Certificate struct {\n\tCertFile string\n\tKeyFile  string\n}\n\nfunc Start(addr string, enableTLS bool, certificate Certificate) {\n\tvar opts []grpc.ServerOption\n\n\t// Configure keepalive parameters\n\tkaParams := keepalive.ServerParameters{\n\t\tTime:    10 * time.Second,\n\t\tTimeout: 20 * time.Second,\n\t}\n\topts = append(opts, grpc.KeepaliveParams(kaParams))\n\n\t// Configure TLS if enabled\n\tif enableTLS {\n\t\tcert, err := tls.LoadX509KeyPair(certificate.CertFile, certificate.KeyFile)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to load TLS certificate: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tcreds := credentials.NewServerTLSFromCert(&cert)\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\t// Create a new gRPC server\n\tgrpcServer := grpc.NewServer(opts...)\n\n\t// Register your service implementation here\n\t// pb.RegisterYourServiceServer(grpcServer, &yourServiceImplementation{})\n\n\t// Listen for incoming connections\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to listen on %s: %v\\n\", addr, err)\n\t\treturn\n\t}\n\n\t// Channel to listen for termination signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Run the server in a goroutine\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tfmt.Printf(\"Failed to serve gRPC server: %v\\n\", err)\n\t\t}\n\t}()\n\n\tfmt.Printf(\"gRPC server listening on %s\\n\", addr)\n\n\t// Block until a termination signal is received\n\tsig := <-sigChan\n\tfmt.Printf(\"Received signal: %v, shutting down gracefully...\\n\", sig)\n\n\t// Graceful shutdown\n\tgrpcServer.GracefulStop()\n\tfmt.Println(\"gRPC server stopped\")\n}\n\nfunc main() {\n\taddr := \"localhost:50051\"\n\tenableTLS := false\n\tcertificate := Certificate{\n\t\tCertFile: \"path/to/cert.pem\",\n\t\tKeyFile:  \"path/to/key.pem\",\n\t}\n\n\tStart(addr, enableTLS, certificate)\n}\n```"
  },
  {
    "Task_id": 284,
    "Instruction": "Task Description: Create a gRPC server for handling OpenTelemetry Protocol (OTLP) trace data, including setup of tracing components and a bounded queue for admission control.\n\nStruct Description: The otlpReceiver struct represents a receiver for OTLP trace data over gRPC, which processes incoming traces and forwards them to the next consumer in the pipeline.\n\nFields:\n- nextConsumer: consumer.Traces - The next trace consumer in the processing pipeline\n- obsrecv: *receiverhelper.ObsReport - Observability reporter for receiver metrics\n- bq: *admission2.BoundedQueue - Bounded queue for admission control of incoming requests\n\nMethods:\n- New: (logger *zap.Logger, nextConsumer consumer.Traces, obsrecv *receiverhelper.ObsReport, bq *admission2.BoundedQueue) -> *otlpReceiver - Constructor function that creates a new otlpReceiver instance\n- otlpReceiverOnGRPCServer: (t *testing.T, tc consumer.Traces) -> (net.Addr, *tracetest.InMemoryExporter, *trace.TracerProvider) - Sets up and starts a gRPC server with OTLP trace receiver capabilities, returning the server address, in-memory exporter, and tracer provider for testing purposes",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"go.opentelemetry.io/collector/consumer\"\n\t\"go.opentelemetry.io/otel/sdk/trace\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracetest\"\n\t\"go.opentelemetry.io/collector/receiver/receivertest\"\n\t\"go.opentelemetry.io/collector/pdata/ptrace/ptraceotlp\"\n)\n\ntype otlpReceiver struct {\n\tnextConsumer consumer.Traces\n\tobsrecv      *receiverhelper.ObsReport\n\tbq           *admission2.BoundedQueue\n}\n\nfunc New(logger *zap.Logger, nextConsumer consumer.Traces, obsrecv *receiverhelper.ObsReport, bq *admission2.BoundedQueue) *otlpReceiver {\n\treturn &otlpReceiver{\n\t\tnextConsumer: nextConsumer,\n\t\tobsrecv:      obsrecv,\n\t\tbq:           bq,\n\t}\n}\n\nfunc otlpReceiverOnGRPCServer(t *testing.T, tc consumer.Traces) (net.Addr, *tracetest.InMemoryExporter, *trace.TracerProvider) {\n\tln, err := net.Listen(\"tcp\", \"localhost:\")\n\trequire.NoError(t, err, \"Failed to find an available address to run the gRPC server: %v\", err)\n\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, ln.Close())\n\t})\n\n\texp := tracetest.NewInMemoryExporter()\n\n\ttp := trace.NewTracerProvider(trace.WithSyncer(exp))\n\ttelset := componenttest.NewNopTelemetrySettings()\n\ttelset.TracerProvider = tp\n\n\tset := receivertest.NewNopSettings()\n\tset.TelemetrySettings = telset\n\n\tset.ID = component.NewIDWithName(component.MustNewType(\"otlp\"), \"trace\")\n\tobsrecv, err := receiverhelper.NewObsReport(receiverhelper.ObsReportSettings{\n\t\tReceiverID:             set.ID,\n\t\tTransport:              \"grpc\",\n\t\tReceiverCreateSettings: set,\n\t})\n\trequire.NoError(t, err)\n\tbq, err := admission2.NewBoundedQueue(set.ID, telset, maxBytes, 0)\n\trequire.NoError(t, err)\n\tr := New(zap.NewNop(), tc, obsrecv, bq)\n\tsrv := grpc.NewServer()\n\tptraceotlp.RegisterGRPCServer(srv, r)\n\tgo func() {\n\t\t_ = srv.Serve(ln)\n\t}()\n\n\treturn ln.Addr(), exp, tp\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"go.opentelemetry.io/otel/sdk/trace\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc/otlptracegrpcserver\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\n\t\"go.opentelemetry.io/otel/sdk/export/trace/tracetest\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracerprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider/traceprovider"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: Implement a gRPC server in Go for a log service that supports append, read, discard, and info operations with concurrent access control and log entry management.\n\nStruct Description: The Server struct represents a gRPC server implementation for a log service that maintains an ordered sequence of log entries with configurable size limits and provides thread-safe operations.\n\nFields:\n- ctx: context.Context - Context for managing server lifecycle\n- options: *Options - Configuration options for the server\n- hardLimit: int - Maximum number of entries before truncation\n- lock: sync.Mutex - Mutex for thread-safe operations\n- locked: struct - Protected data structure containing:\n  - startIndex: Index - First available index in the log\n  - entries: []*logspec.Entry - Slice of log entries\n  - changed: chan struct{} - Channel to notify about log changes\n\nMethods:\n- NewServer: [Name](ctx context.Context, options *Options) -> (*Server, error) - Creates and starts a new Server instance\n- Append: [Name](stream logspec.Log_AppendServer) -> error - Handles append requests via gRPC stream\n- append: [Name](proposals [][]byte) -> []Index - Internal method to append entries to the log\n- lastIndexLocked: [Name]() -> Index - Helper method to get last index (requires lock)\n- Discard: [Name](ctx context.Context, req *logspec.DiscardRequest) -> (*logspec.DiscardReply, error) - Handles discard requests\n- discard: [Name](firstIndex Index) -> - Internal method to discard entries\n- Read: [Name](req *logspec.ReadRequest, stream logspec.Log_ReadServer) -> error - Handles read requests via gRPC stream\n- Info: [Name](ctx context.Context, req *logspec.InfoRequest) -> (*logspec.InfoReply, error) - Returns current log info\n- info: [Name]() -> (*logspec.InfoReply, chan struct{}) - Internal method to get log info\n- InfoStream: [Name](req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) -> error - Streams log info updates",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"github.com/ebay/akutan/logspec\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\ntype Options struct {\n\tAddress string\n\tLimit   int\n}\n\ntype Index = uint64\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\tserver := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.Limit * 3 / 2,\n\t}\n\tserver.locked.startIndex = 1\n\tserver.locked.changed = make(chan struct{})\n\tlistener, err := net.Listen(\"tcp\", options.Address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconst maxMsgSize = 1024 * 1024 * 1024\n\tservice := grpc.NewServer(\n\t\tgrpc.MaxRecvMsgSize(maxMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxMsgSize))\n\tlogspec.RegisterLogServer(service, server)\n\tgo service.Serve(listener)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t\tservice.Stop()\n\t}()\n\treturn server, nil\n}\n\nfunc (server *Server) Append(streams logspec.Log_AppendServer) error {\n\tseq := uint64(0)\n\tfor {\n\t\tseq++\n\t\treq, err := streams.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif req.Sequence != seq {\n\t\t\treturn errors.New(\"out of sequence\")\n\t\t}\n\t\tindexes := server.append(req.Proposals)\n\t\tres := logspec.AppendReply{\n\t\t\tReply: &logspec.AppendReply_Ok{\n\t\t\t\tOk: &logspec.AppendReply_OK{\n\t\t\t\t\tSequence: seq,\n\t\t\t\t\tIndexes:  indexes,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = streams.Send(&res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (server *Server) append(proposals [][]byte) []Index {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tprevLastIndex := server.lastIndexLocked()\n\tnextIndex := prevLastIndex + 1\n\tindexes := make([]Index, len(proposals))\n\tfor i := range proposals {\n\t\tindexes[i] = nextIndex\n\t\tnextIndex++\n\t\tserver.locked.entries = append(server.locked.entries, &logspec.Entry{\n\t\t\tIndex: indexes[i],\n\t\t\tData:  proposals[i],\n\t\t\tSkip:  false,\n\t\t})\n\t}\n\n\tif server.hardLimit > 0 && len(server.locked.entries) >= server.hardLimit {\n\t\tfirstIndex := nextIndex - uint64(server.options.Limit)\n\t\tdiff := firstIndex - server.locked.startIndex\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t\tserver.locked.startIndex = firstIndex\n\t}\n\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n\treturn indexes\n}\n\nfunc (server *Server) lastIndexLocked() Index {\n\treturn server.locked.startIndex + uint64(len(server.locked.entries)) - 1\n}\n\nfunc (server *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\tserver.discard(req.FirstIndex)\n\treturn &logspec.DiscardReply{\n\t\tReply: &logspec.DiscardReply_Ok{\n\t\t\tOk: &logspec.DiscardReply_OK{},\n\t\t},\n\t}, nil\n}\n\nfunc (server *Server) discard(firstIndex Index) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tif firstIndex <= server.locked.startIndex {\n\t\treturn\n\t}\n\tdiff := firstIndex - server.locked.startIndex\n\tif uint64(len(server.locked.entries)) < diff {\n\t\tserver.locked.entries = nil\n\t} else {\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t}\n\tserver.locked.startIndex = firstIndex\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n}\n\nfunc (server *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\tctx := stream.Context()\n\tnextIndex := req.NextIndex\n\tfor {\n\t\tserver.lock.Lock()\n\t\tstartIndex := server.locked.startIndex\n\t\tlastIndex := server.lastIndexLocked()\n\t\tentries := server.locked.entries\n\t\tchangedCh := server.locked.changed\n\t\tserver.lock.Unlock()\n\n\t\tif nextIndex < startIndex {\n\t\t\treturn stream.Send(&logspec.ReadReply{\n\t\t\t\tReply: &logspec.ReadReply_Truncated{\n\t\t\t\t\tTruncated: true,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t\tif nextIndex > lastIndex {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase <-server.ctx.Done():\n\t\t\t\treturn server.ctx.Err()\n\t\t\tcase <-changedCh:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tentries = entries[nextIndex-startIndex:]\n\t\tif len(entries) > 10 {\n\t\t\tentries = entries[:10]\n\t\t}\n\t\terr := stream.Send(&logspec.ReadReply{\n\t\t\tReply: &logspec.ReadReply_Ok{\n\t\t\t\tOk: &logspec.ReadReply_OK{\n\t\t\t\t\tEntries: entries,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnextIndex += uint64(len(entries))\n\t}\n}\n\nfunc (server *Server) Info(context.Context, *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tres, _ := server.info()\n\treturn res, nil\n}\n\nfunc (server *Server) info() (*logspec.InfoReply, chan struct{}) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\treturn &logspec.InfoReply{\n\t\tReply: &logspec.InfoReply_Ok{\n\t\t\tOk: &logspec.InfoReply_OK{\n\t\t\t\tFirstIndex: server.locked.startIndex,\n\t\t\t\tLastIndex:  server.lastIndexLocked(),\n\t\t\t},\n\t\t},\n\t}, server.locked.changed\n}\n\nfunc (server *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tfor {\n\t\tres, changedCh := server.info()\n\t\terr := stream.Send(res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-stream.Context().Done():\n\t\t\treturn stream.Context().Err()\n\t\tcase <-server.ctx.Done():\n\t\t\treturn server.ctx.Err()\n\t\tcase <-changedCh:\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\tlogspec \"path/to/logspec\"\n)\n\ntype Index int\n\ntype Options struct {\n\tHardLimit int\n}\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\ts := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.HardLimit,\n\t}\n\ts.locked.changed = make(chan struct{}, 1)\n\treturn s, nil\n}\n\nfunc (s *Server) Append(stream logspec.Log_AppendServer) error {\n\tvar proposals [][]byte\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tproposals = append(proposals, req.Data)\n\t}\n\tindices := s.append(proposals)\n\tfor _, index := range indices {\n\t\tif err := stream.Send(&logspec.AppendReply{Index: int32(index)}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Server) append(proposals [][]byte) []Index {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tvar indices []Index\n\tfor _, proposal := range proposals {\n\t\tentry := &logspec.Entry{Data: proposal}\n\t\ts.locked.entries = append(s.locked.entries, entry)\n\t\tindices = append(indices, s.lastIndexLocked())\n\t\tif len(s.locked.entries) > s.hardLimit {\n\t\t\ts.discard(s.locked.startIndex + 1)\n\t\t}\n\t}\n\tselect {\n\tcase s.locked.changed <- struct{}{}:\n\tdefault:\n\t}\n\treturn indices\n}\n\nfunc (s *Server) lastIndexLocked() Index {\n\treturn s.locked.startIndex + Index(len(s.locked.entries)) - 1\n}\n\nfunc (s *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\ts.discard(Index(req.FirstIndex))\n\treturn &logspec.DiscardReply{}, nil\n}\n\nfunc (s *Server) discard(firstIndex Index) {\n\tif firstIndex <= s.locked.startIndex {\n\t\treturn\n\t}\n\toffset := firstIndex - s.locked.startIndex\n\tif offset > Index(len(s.locked.entries)) {\n\t\toffset = Index(len(s.locked.entries))\n\t}\n\ts.locked.entries = s.locked.entries[offset:]\n\ts.locked.startIndex = firstIndex\n}\n\nfunc (s *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tstart := Index(req.StartIndex)\n\tif start < s.locked.startIndex {\n\t\treturn status.Errorf(codes.OutOfRange, \"start index out of range\")\n\t}\n\tfor i := start - s.locked.startIndex; i < Index(len(s.locked.entries)); i++ {\n\t\tif err := stream.Send(s.locked.entries[i]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Server) Info(ctx context.Context, req *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tinfo, _ := s.info()\n\treturn info, nil\n}\n\nfunc (s *Server) info() (*logspec.InfoReply, chan struct{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tinfo := &logspec.InfoReply{\n\t\tStartIndex: int32(s.locked.startIndex),\n\t\tEndIndex:   int32(s.lastIndexLocked()),\n\t}\n\treturn info, s.locked.changed\n}\n\nfunc (s *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tinfo, changed := s.info()\n\tif err := stream.Send(info); err != nil {\n\t\treturn err\n\t}\n\tfor {\n\t\tselect {\n\t\tcase <-s.ctx.Done():\n\t\t\treturn s.ctx.Err()\n\t\tcase <-changed:\n\t\t\tinfo, changed = s.info()\n\t\t\tif err := stream.Send(info); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Implementation of server startup and gRPC registration goes here\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Create a Go HTTP client struct for interacting with an Okta API, handling authentication, session management, and user data retrieval.\n\nStruct Description: The Client struct represents an HTTP client configured to communicate with Okta's API. It maintains client configuration, organization details, and authentication state, providing methods for various API operations.\n\nFields:\n- client: *http.Client - The underlying HTTP client used for requests\n- org: string - The Okta organization domain\n- Url: string - The base Okta URL (defaults to \"okta.com\")\n- ApiToken: string - The API token for authenticated requests\n\nMethods:\n- NewClient(org string) -> *Client - Constructor that initializes a new Client with the specified organization\n- Authenticate(username string, password string) -> (*AuthnResponse, error) - Performs user authentication with username/password\n- Session(sessionToken string) -> (*SessionResponse, error) - Creates a session using a session token\n- User(userID string) -> (*User, error) - Retrieves user details by ID\n- Groups(userID string) -> (*Groups, error) - Gets groups associated with a user\n- call(endpoint string, method string, request interface{}, response interface{}) -> error - Internal method handling the HTTP request/response cycle",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\nfunc NewClient(org string) *Client {\n\tclient := Client{\n\t\tclient: &http.Client{},\n\t\torg:    org,\n\t\tUrl:    \"okta.com\",\n\t}\n\n\treturn &client\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\tvar request = &AuthnRequest{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tvar response = &AuthnResponse{}\n\terr := c.call(\"authn\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tvar request = &SessionRequest{\n\t\tSessionToken: sessionToken,\n\t}\n\n\tvar response = &SessionResponse{}\n\terr := c.call(\"sessions\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tvar response = &User{}\n\terr := c.call(\"users/\"+userID, \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tvar response = &Groups{}\n\terr := c.call(\"users/\"+userID+\"/groups\", \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) call(endpoint, method string, request, response interface{}) error {\n\tdata, _ := json.Marshal(request)\n\n\tvar url = \"https://\" + c.org + \".\" + c.Url + \"/api/v1/\" + endpoint\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Add(\"Accept\", `application/json`)\n\treq.Header.Add(\"Content-Type\", `application/json`)\n\tif c.ApiToken != \"\" {\n\t\treq.Header.Add(\"Authorization\", \"SSWS \"+c.ApiToken)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode == http.StatusOK {\n\t\terr := json.Unmarshal(body, &response)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tvar errors ErrorResponse\n\t\terr = json.Unmarshal(body, &errors)\n\n\t\treturn &errorResponse{\n\t\t\tHTTPCode: resp.StatusCode,\n\t\t\tResponse: errors,\n\t\t\tEndpoint: url,\n\t\t}\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage okta\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\ntype AuthnResponse struct {\n\tSessionToken string `json:\"sessionToken\"`\n}\n\ntype SessionResponse struct {\n\tId string `json:\"id\"`\n}\n\ntype User struct {\n\tId    string `json:\"id\"`\n\tEmail string `json:\"email\"`\n}\n\ntype Groups struct {\n\tGroupIds []string `json:\"groupIds\"`\n}\n\nfunc NewClient(org string, apiToken string) *Client {\n\treturn &Client{\n\t\tclient:   &http.Client{},\n\t\torg:      org,\n\t\tUrl:      \"okta.com\",\n\t\tApiToken: apiToken,\n\t}\n}\n\nfunc (c *Client) Authenticate(username string, password string) (*AuthnResponse, error) {\n\tendpoint := fmt.Sprintf(\"https://%s.%s/api/v1/authn\", c.org, c.Url)\n\tpayload := map[string]string{\"username\": username, \"password\": password}\n\tvar authnResponse AuthnResponse\n\terr := c.call(endpoint, \"POST\", payload, &authnResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &authnResponse, nil\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tendpoint := fmt.Sprintf(\"https://%s.%s/api/v1/sessions\", c.org, c.Url)\n\tpayload := map[string]string{\"sessionToken\": sessionToken}\n\tvar sessionResponse SessionResponse\n\terr := c.call(endpoint, \"POST\", payload, &sessionResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &sessionResponse, nil\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tendpoint := fmt.Sprintf(\"https://%s.%s/api/v1/users/%s\", c.org, c.Url, userID)\n\tvar user User\n\terr := c.call(endpoint, \"GET\", nil, &user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tendpoint := fmt.Sprintf(\"https://%s.%s/api/v1/users/%s/groups\", c.org, c.Url, userID)\n\tvar groups Groups\n\terr := c.call(endpoint, \"GET\", nil, &groups)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &groups, nil\n}\n\nfunc (c *Client) call(endpoint string, method string, request interface{}, response interface{}) error {\n\tvar req *http.Request\n\tvar err error\n\n\tif request != nil {\n\t\tbody, err := json.Marshal(request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq, err = http.NewRequest(method, endpoint, bytes.NewBuffer(body))\n\t} else {\n\t\treq, err = http.NewRequest(method, endpoint, nil)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"SSWS \"+c.ApiToken)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\treturn json.NewDecoder(resp.Body).Decode(response)\n\t}\n\n\treturn fmt.Errorf(\"HTTP request failed with status code %d\", resp.StatusCode)\n}\n```"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server for management services, including setting up necessary dependencies and configurations.\n\nFunction Description: The function `startManagement` initializes and starts a gRPC server with management services. It sets up a temporary directory for data storage, configures the server with keepalive policies, initializes various managers and stores, and registers the management service. The server listens on a dynamically assigned port and runs in a goroutine.\n\nInput:\n- `t *testing.T`: Testing context for temporary directory creation and cleanup\n- `signalAddr string`: Address of the signal service\n- `counter *int`: Pointer to a counter for tracking server operations (used in mock implementation)\n\nOutput:\n- `*grpc.Server`: The created gRPC server instance\n- `string`: The address the server is listening on\n- `error`: Any error that occurred during initialization",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tmgmtProto \"github.com/netbirdio/netbird/management/proto\"\n\t\"github.com/netbirdio/netbird/management/server\"\n\t\"github.com/netbirdio/netbird/management/server/activity\"\n\t\"github.com/netbirdio/netbird/management/server/settings\"\n\t\"github.com/netbirdio/netbird/management/server/store\"\n\t\"github.com/netbirdio/netbird/management/server/telemetry\"\n)\n\nvar (\n\tkaep = keepalive.EnforcementPolicy{\n\t\tMinTime:             15 * time.Second,\n\t\tPermitWithoutStream: true,\n\t}\n\n\tkasp = keepalive.ServerParameters{\n\t\tMaxConnectionIdle:     15 * time.Second,\n\t\tMaxConnectionAgeGrace: 5 * time.Second,\n\t\tTime:                  5 * time.Second,\n\t\tTimeout:               2 * time.Second,\n\t}\n)\n\nfunc startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\tt.Helper()\n\tdataDir := t.TempDir()\n\n\tconfig := &server.Config{\n\t\tStuns:      []*server.Host{},\n\t\tTURNConfig: &server.TURNConfig{},\n\t\tSignal: &server.Host{\n\t\t\tProto: \"http\",\n\t\t\tURI:   signalAddr,\n\t\t},\n\t\tDatadir:    dataDir,\n\t\tHttpConfig: nil,\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tstore, cleanUp, err := store.NewTestStoreFromSQL(context.Background(), \"\", config.Datadir)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tt.Cleanup(cleanUp)\n\n\tpeersUpdateManager := server.NewPeersUpdateManager(nil)\n\teventStore := &activity.InMemoryEventStore{}\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tia, _ := integrations.NewIntegratedValidator(context.Background(), eventStore)\n\n\tmetrics, err := telemetry.NewDefaultAppMetrics(context.Background())\n\trequire.NoError(t, err)\n\n\taccountManager, err := server.BuildManager(context.Background(), store, peersUpdateManager, nil, \"\", \"netbird.selfhosted\", eventStore, nil, false, ia, metrics)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tsecretsManager := server.NewTimeBasedAuthSecretsManager(peersUpdateManager, config.TURNConfig, config.Relay)\n\tmgmtServer, err := server.NewServer(context.Background(), config, accountManager, settings.NewManager(store), peersUpdateManager, secretsManager, nil, nil)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tmock := &mockServer{\n\t\tManagementServiceServer: mgmtServer,\n\t\tcounter:                 counter,\n\t}\n\tmgmtProto.RegisterManagementServiceServer(s, mock)\n\tgo func() {\n\t\tif err = s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn s, lis.Addr().String(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "func startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\ttempDir := t.TempDir()\n\n\tkeepaliveParams := keepalive.ServerParameters{\n\t\tTime:    10 * time.Second,\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tserverOptions := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(keepaliveParams),\n\t}\n\n\tgrpcServer := grpc.NewServer(serverOptions...)\n\n\tdataStore, err := NewDataStore(tempDir)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tmanager, err := NewManager(dataStore)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tsignalService, err := NewSignalService(signalAddr)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tRegisterManagementService(grpcServer, manager, signalService, counter)\n\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\tt.Errorf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn grpcServer, listener.Addr().String(), nil\n}"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Implement a Redis-based session management system in Go that allows storing, retrieving, and managing HTTP session data using Redis as the backend storage.\n\nStruct Description: The implementation consists of two main structs - `SessionStore` for handling individual session operations and `Provider` for managing the Redis connection pool and session lifecycle.\n\nFields:\n\nSessionStore:\n- p: *redis.Pool - Redis connection pool\n- sid: string - Session ID\n- lock: sync.RWMutex - Read-write lock for thread safety\n- values: map[interface{}]interface{} - Key-value pairs storing session data\n- maxlifetime: int64 - Session expiration time in seconds\n\nProvider:\n- maxlifetime: int64 - Default session expiration time\n- savePath: string - Redis server address\n- poolsize: int - Connection pool size\n- password: string - Redis authentication password\n- dbNum: int - Redis database number\n- poollist: *redis.Pool - Redis connection pool instance\n\nMethods:\n\nSessionStore:\n- Set(key, value interface{}) error - Stores a key-value pair in the session\n- Get(key interface{}) interface{} - Retrieves a value by key from the session\n- Delete(key interface{}) error - Removes a key-value pair from the session\n- Flush() error - Clears all session data\n- SessionID() string - Returns the session ID\n- SessionRelease(w http.ResponseWriter) - Persists session data to Redis before closing\n\nProvider:\n- SessionInit(maxlifetime int64, savePath string) error - Initializes the Redis connection pool with configuration\n- SessionRead(sid string) (session.Store, error) - Retrieves session data from Redis\n- SessionExist(sid string) bool - Checks if a session exists in Redis\n- SessionRegenerate(oldsid, sid string) (session.Store, error) - Creates a new session ID while preserving data\n- SessionDestroy(sid string) error - Removes session data from Redis",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/astaxie/beego/session\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar redispder = &Provider{}\nvar MaxPoolSize = 100\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (rs *SessionStore) Set(key, value interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values[key] = value\n\treturn nil\n}\n\nfunc (rs *SessionStore) Get(key interface{}) interface{} {\n\trs.lock.RLock()\n\tdefer rs.lock.RUnlock()\n\tif v, ok := rs.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (rs *SessionStore) Delete(key interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\tdelete(rs.values, key)\n\treturn nil\n}\n\nfunc (rs *SessionStore) Flush() error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (rs *SessionStore) SessionID() string {\n\treturn rs.sid\n}\n\nfunc (rs *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tb, err := session.EncodeGob(rs.values)\n\tif err != nil {\n\t\treturn\n\t}\n\tc := rs.p.Get()\n\tdefer c.Close()\n\tc.Do(\"SETEX\", rs.sid, rs.maxlifetime, string(b))\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (rp *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\trp.maxlifetime = maxlifetime\n\tconfigs := strings.Split(savePath, \",\")\n\tif len(configs) > 0 {\n\t\trp.savePath = configs[0]\n\t}\n\tif len(configs) > 1 {\n\t\tpoolsize, err := strconv.Atoi(configs[1])\n\t\tif err != nil || poolsize <= 0 {\n\t\t\trp.poolsize = MaxPoolSize\n\t\t} else {\n\t\t\trp.poolsize = poolsize\n\t\t}\n\t} else {\n\t\trp.poolsize = MaxPoolSize\n\t}\n\tif len(configs) > 2 {\n\t\trp.password = configs[2]\n\t}\n\tif len(configs) > 3 {\n\t\tdbnum, err := strconv.Atoi(configs[3])\n\t\tif err != nil || dbnum < 0 {\n\t\t\trp.dbNum = 0\n\t\t} else {\n\t\t\trp.dbNum = dbnum\n\t\t}\n\t} else {\n\t\trp.dbNum = 0\n\t}\n\trp.poollist = redis.NewPool(func() (redis.Conn, error) {\n\t\tc, err := redis.Dial(\"tcp\", rp.savePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.password != \"\" {\n\t\t\tif _, err := c.Do(\"AUTH\", rp.password); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t_, err = c.Do(\"SELECT\", rp.dbNum)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t}, rp.poolsize)\n\n\treturn rp.poollist.Get().Err()\n}\n\nfunc (rp *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionExist(sid string) bool {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, err := redis.Int(c.Do(\"EXISTS\", sid)); err != nil || existed == 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (rp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, _ := redis.Int(c.Do(\"EXISTS\", oldsid)); existed == 0 {\n\t\tc.Do(\"SET\", sid, \"\", \"EX\", rp.maxlifetime)\n\t} else {\n\t\tc.Do(\"RENAME\", oldsid, sid)\n\t\tc.Do(\"EXPIRE\", sid, rp.maxlifetime)\n\t}\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionDestroy(sid string) error {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tc.Do(\"DEL\", sid)\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\ntype SessionStore struct {\n\tp          *redis.Pool\n\tsid        string\n\tlock       sync.RWMutex\n\tvalues     map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (st *SessionStore) Set(key, value interface{}) error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tst.values[key] = value\n\treturn nil\n}\n\nfunc (st *SessionStore) Get(key interface{}) interface{} {\n\tst.lock.RLock()\n\tdefer st.lock.RUnlock()\n\tif v, ok := st.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (st *SessionStore) Delete(key interface{}) error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tdelete(st.values, key)\n\treturn nil\n}\n\nfunc (st *SessionStore) Flush() error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tst.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (st *SessionStore) SessionID() string {\n\treturn st.sid\n}\n\nfunc (st *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tst.lock.RLock()\n\tdefer st.lock.RUnlock()\n\tdata, _ := json.Marshal(st.values)\n\tconn := st.p.Get()\n\tdefer conn.Close()\n\tconn.Do(\"SETEX\", st.sid, st.maxlifetime, data)\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (pder *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\tpder.maxlifetime = maxlifetime\n\tpder.savePath = savePath\n\tpder.poollist = &redis.Pool{\n\t\tMaxIdle:     pder.poolsize,\n\t\tIdleTimeout: time.Duration(maxlifetime) * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tconn, err := redis.Dial(\"tcp\", pder.savePath,\n\t\t\t\tredis.DialPassword(pder.password),\n\t\t\t\tredis.DialDatabase(pder.dbNum))\n\t\t\treturn conn, err\n\t\t},\n\t}\n\treturn nil\n}\n\nfunc (pder *Provider) SessionRead(sid string) (*SessionStore, error) {\n\tconn := pder.poollist.Get()\n\tdefer conn.Close()\n\tdata, err := redis.Bytes(conn.Do(\"GET\", sid))\n\tif err != nil {\n\t\treturn &SessionStore{p: pder.poollist, sid: sid, values: make(map[interface{}]interface{}), maxlifetime: pder.maxlifetime}, nil\n\t}\n\tvar values map[interface{}]interface{}\n\tjson.Unmarshal(data, &values)\n\treturn &SessionStore{p: pder.poollist, sid: sid, values: values, maxlifetime: pder.maxlifetime}, nil\n}\n\nfunc (pder *Provider) SessionExist(sid string) bool {\n\tconn := pder.poollist.Get()\n\tdefer conn.Close()\n\texists, err := redis.Bool(conn.Do(\"EXISTS\", sid))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn exists\n}\n\nfunc (pder *Provider) SessionRegenerate(oldsid, sid string) (*SessionStore, error) {\n\tconn := pder.poollist.Get()\n\tdefer conn.Close()\n\tif pder.SessionExist(oldsid) {\n\t\tconn.Do(\"RENAME\", oldsid, sid)\n\t}\n\treturn pder.SessionRead(sid)\n}\n\nfunc (pder *Provider) SessionDestroy(sid string) error {\n\tconn := pder.poollist.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"DEL\", sid)\n\treturn err\n}\n```"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool and methods for interacting with Redis, including setting, getting, deleting keys, and flushing the database.\n\nStruct Description: RedisStore is a struct that manages a connection pool to Redis and provides methods for common Redis operations with support for expiration times.\n\nFields:\n- pool: *redis.Pool - A connection pool to Redis for efficient connection reuse\n- defaultExpiration: time.Duration - The default expiration time for keys when not explicitly specified\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method for executing Redis commands with serialization and expiration handling",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\ntype RedisStore struct {\n\tpool             *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\treturn &RedisStore{\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     3,\n\t\t\tIdleTimeout: 240 * time.Second,\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif password != \"\" {\n\t\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn c, err\n\t\t\t},\n\t\t},\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (r *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn r.invoke(func(conn redis.Conn, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tdata, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expires == 0 {\n\t\t\texpires = r.defaultExpiration\n\t\t}\n\t\tif expires > 0 {\n\t\t\t_, err = conn.Do(\"SETEX\", key, int64(expires.Seconds()), data)\n\t\t} else {\n\t\t\t_, err = conn.Do(\"SET\", key, data)\n\t\t}\n\t\treturn nil, err\n\t}, key, value, expires)\n}\n\nfunc (r *RedisStore) Get(key string, ptrValue interface{}) error {\n\treturn r.invoke(func(conn redis.Conn, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tdata, err := redis.Bytes(conn.Do(\"GET\", key))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, json.Unmarshal(data, ptrValue)\n\t}, key, ptrValue, 0)\n}\n\nfunc (r *RedisStore) Delete(key string) error {\n\treturn r.invoke(func(conn redis.Conn, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\t_, err := conn.Do(\"DEL\", key)\n\t\treturn nil, err\n\t}, key, nil, 0)\n}\n\nfunc (r *RedisStore) Flush() error {\n\treturn r.invoke(func(conn redis.Conn, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\t_, err := conn.Do(\"FLUSHDB\")\n\t\treturn nil, err\n\t}, \"\", nil, 0)\n}\n\nfunc (r *RedisStore) invoke(f func(redis.Conn, string, interface{}, time.Duration) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tconn := r.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := f(conn, key, value, expires)\n\treturn err\n}\n\nfunc main() {\n\t// Example usage\n\tstore := NewRedisCache(\"localhost:6379\", \"\", 5*time.Minute)\n\terr := store.Set(\"key\", \"value\", 0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar value string\n\terr = store.Get(\"key\", &value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = store.Delete(\"key\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = store.Flush()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Redis client struct in Go that manages connections to Redis servers and provides common Redis operations. The implementation should use connection pooling and support thread-safe access to multiple Redis instances.\n\nStruct Description: RedisClient is a struct that encapsulates Redis connection pooling and provides methods for common Redis operations. It maintains a thread-safe map of Redis clients for different server addresses.\n\nFields:\n\npool: *redis.Pool - The connection pool for Redis operations\nAddress: string - The Redis server address (URL)\n\nMethods:\n\nGetRedisClient: (address string, maxIdle int, maxActive int) -> *RedisClient - Retrieves or creates a Redis client for the given address with specified pool settings\nGet: (key string) -> (string, error) - Retrieves the value for a given key from Redis\nSet: (key string, val interface{}) -> (interface{}, error) - Sets the value for a given key in Redis\nLPush: (key string, value ...interface{}) -> (int, error) - Pushes values to the left of a Redis list\nLPop: (key string) -> (string, error) - Pops a value from the left of a Redis list\nHSet: (hashID string, field string, val string) -> error - Sets a field in a Redis hash\nHGet: (hashID string, field string) -> (string, error) - Gets a field from a Redis hash",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tredisMap map[string]*RedisClient\n\tmapMutex *sync.RWMutex\n)\n\nconst (\n\tdefaultMaxIdle   = 10\n\tdefaultMaxActive = 50\n)\n\nfunc init() {\n\tredisMap = make(map[string]*RedisClient)\n\tmapMutex = new(sync.RWMutex)\n}\n\nfunc newPool(redisURL string, maxIdle, maxActive int) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxIdle:   maxIdle,\n\t\tMaxActive: maxActive,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(redisURL)\n\t\t\treturn c, err\n\t\t},\n\t}\n}\n\nfunc GetRedisClient(address string, maxIdle, maxActive int) *RedisClient {\n\tif maxIdle <= 0 {\n\t\tmaxIdle = defaultMaxIdle\n\t}\n\tif maxActive <= 0 {\n\t\tmaxActive = defaultMaxActive\n\t}\n\tvar redis *RedisClient\n\tvar mok bool\n\tmapMutex.RLock()\n\tredis, mok = redisMap[address]\n\tmapMutex.RUnlock()\n\tif !mok {\n\t\tredis = &RedisClient{Address: address, pool: newPool(address, maxIdle, maxActive)}\n\t\tmapMutex.Lock()\n\t\tredisMap[address] = redis\n\t\tmapMutex.Unlock()\n\t}\n\treturn redis\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"GET\", key)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"SET\", key, val))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tret, err := redis.Int(conn.Do(\"LPUSH\", key, value))\n\treturn ret, err\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"LPOP\", key))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"HGET\", hashID, field)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "import (\n\t\"github.com/gomodule/redigo/redis\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tclientMap = make(map[string]*RedisClient)\n\tmu        sync.Mutex\n)\n\nfunc GetRedisClient(address string, maxIdle int, maxActive int) *RedisClient {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tif client, exists := clientMap[address]; exists {\n\t\treturn client\n\t}\n\n\tpool := &redis.Pool{\n\t\tMaxIdle:   maxIdle,\n\t\tMaxActive: maxActive,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\treturn redis.Dial(\"tcp\", address)\n\t\t},\n\t}\n\n\tclient := &RedisClient{\n\t\tpool:    pool,\n\t\tAddress: address,\n\t}\n\n\tclientMap[address] = client\n\treturn client\n}\n\nfunc (c *RedisClient) Get(key string) (string, error) {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"GET\", key))\n}\n\nfunc (c *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\treturn conn.Do(\"SET\", key, val)\n}\n\nfunc (c *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\targs := redis.Args{}.Add(key).AddFlat(value)\n\treturn redis.Int(conn.Do(\"LPUSH\", args...))\n}\n\nfunc (c *RedisClient) LPop(key string) (string, error) {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"LPOP\", key))\n}\n\nfunc (c *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (c *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"HGET\", hashID, field))\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function to fetch video materials from an advertising API using HTTP requests with custom headers and process the response.\n\nFunction Description: The function `getVideo` makes a GET request to a specified API endpoint to retrieve video materials for a given advertiser. It handles request creation, header addition, response processing, and error handling. The response is parsed to extract video information and store it in a global map while returning pagination information.\n\nInput:\n- advertiserId: string - The ID of the advertiser whose videos are being requested\n- page: int - The page number for paginated results\n\nOutput:\n- int - Total number of pages available (for pagination)\n- error - Any error encountered during the HTTP request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar videoImageIdMaterialIdMap = map[string]int64{}\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/get/\"\n\tmethod := \"GET\"\n\tpayload := strings.NewReader(fmt.Sprintf(`{\n    \t\t\t\"advertiser_id\": %s,\n   \t\t\t\t \"page\":%d,\n   \t\t\t\t \"page_size\":100}`, advertiserId, page))\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treq.Header.Add(\"Access-Token\", \"c0bfed085c0dbc19bb2e41920ecd6d2a6d398b32\")\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar getVideoMaterialResp GetVideoMaterialResp\n\terr = json.Unmarshal(body, &getVideoMaterialResp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif getVideoMaterialResp.Code != 0 {\n\t\treturn 0, err\n\t}\n\tfor _, s := range getVideoMaterialResp.Data.List {\n\t\tvideoImageIdMaterialIdMap[s.Id] = s.MaterialId\n\t}\n\treturn getVideoMaterialResp.Data.PageInfo.TotalPage, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nvar videoMaterials = make(map[string]interface{})\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := \"https://api.example.com/videos?advertiserId=\" + advertiserId + \"&page=\" + strconv.Itoa(page)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn 0, fmt.Errorf(\"failed to fetch videos: %s\", resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar response struct {\n\t\tData struct {\n\t\t\tVideos []struct {\n\t\t\t\tID    string `json:\"id\"`\n\t\t\t\tTitle string `json:\"title\"`\n\t\t\t} `json:\"videos\"`\n\t\t\tPagination struct {\n\t\t\t\tTotalPages int `json:\"total_pages\"`\n\t\t\t} `json:\"pagination\"`\n\t\t} `json:\"data\"`\n\t}\n\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, video := range response.Data.Videos {\n\t\tvideoMaterials[video.ID] = video.Title\n\t}\n\n\treturn response.Data.Pagination.TotalPages, nil\n}\n\nfunc main() {\n\ttotalPages, err := getVideo(\"12345\", 1)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Total Pages:\", totalPages)\n\tfmt.Println(\"Video Materials:\", videoMaterials)\n}\n```"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool to interact with a Redis server, supporting common operations like Set, Get, Delete, and Flush with configurable expiration times.\n\nStruct Description: RedisStore is a struct that manages a pool of Redis connections and provides methods to interact with Redis, including setting, getting, deleting keys, and flushing the database. It supports configurable expiration times for cached items.\n\nFields:\n- pool: *redis.Pool - A connection pool to manage Redis connections efficiently\n- defaultExpiration: time.Duration - The default expiration time for cached items\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method to handle Redis operations with expiration logic",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/gomodule/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\treturn &RedisStore{\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     3,\n\t\t\tIdleTimeout: 240 * time.Second,\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif password != \"\" {\n\t\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn c, err\n\t\t\t},\n\t\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t\t_, err := c.Do(\"PING\")\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (r *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn r.invoke(func(conn redis.Conn, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tdata, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expires == 0 {\n\t\t\texpires = r.defaultExpiration\n\t\t}\n\t\tif expires > 0 {\n\t\t\treturn conn.Do(\"SETEX\", key, int64(expires.Seconds()), data)\n\t\t}\n\t\treturn conn.Do(\"SET\", key, data)\n\t}, key, value, expires)\n}\n\nfunc (r *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := r.pool.Get()\n\tdefer conn.Close()\n\n\tdata, err := redis.Bytes(conn.Do(\"GET\", key))\n\tif err != nil {\n\t\tif err == redis.ErrNil {\n\t\t\treturn errors.New(\"key not found\")\n\t\t}\n\t\treturn err\n\t}\n\n\treturn json.Unmarshal(data, ptrValue)\n}\n\nfunc (r *RedisStore) Delete(key string) error {\n\tconn := r.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (r *RedisStore) Flush() error {\n\tconn := r.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"FLUSHDB\")\n\treturn err\n}\n\nfunc (r *RedisStore) invoke(f func(redis.Conn, string, interface{}, time.Duration) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tconn := r.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := f(conn, key, value, expires)\n\treturn err\n}\n```"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a stock quote service that retrieves stock information from an external API and processes the response.\n\nStruct Description: The Stock struct represents a service for fetching stock quotes. It contains configuration fields for API access and implements methods to retrieve quote information.\n\nFields:\nApi: [string] - The base URL of the stock API service\nKey: [string] - The API key used for authentication with the stock service\n\nMethods:\nQuote: [Name](ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) -> [error] - Retrieves stock quote information for a given symbol. Validates the input symbol, makes an HTTP GET request to the stock API, processes the response, and populates the response object with the quote data. Returns error if any step fails.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/stock/proto\"\n)\n\ntype Stock struct {\n\tApi   string\n\tKey   string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif len(req.Symbol) <= 0 || len(req.Symbol) > 5 {\n\t\treturn errors.BadRequest(\"stock.quote\", \"invalid symbol\")\n\t}\n\n\turi := fmt.Sprintf(\"%slast/stock/%s?apikey=%s\", s.Api, req.Symbol, s.Key)\n\n\tresp, err := http.Get(uri)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to get quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\tdefer resp.Body.Close()\n\n\tb, _ := ioutil.ReadAll(resp.Body)\n\n\tif resp.StatusCode != 200 {\n\t\tlogger.Errorf(\"Failed to get quote (non 200): %d %v\\n\", resp.StatusCode, string(b))\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\tvar respBody struct {\n\t\tSymbol    string\n\t\tAsk       float64\n\t\tBid       float64\n\t\tAsize     int32\n\t\tBsize     int32\n\t\tTimestamp int64\n\t}\n\n\tif err := json.Unmarshal(b, &respBody); err != nil {\n\t\tlogger.Errorf(\"Failed to unmarshal quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\trsp.Symbol = respBody.Symbol\n\trsp.AskPrice = respBody.Ask\n\trsp.BidPrice = respBody.Bid\n\trsp.AskSize = respBody.Asize\n\trsp.BidSize = respBody.Bsize\n\trsp.Timestamp = respBody.Timestamp\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package stock\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\tpb \"path/to/protobuf/package\"\n)\n\ntype Stock struct {\n\tApi string\n\tKey string\n}\n\ntype apiResponse struct {\n\tSymbol string  `json:\"symbol\"`\n\tPrice  float64 `json:\"price\"`\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif req.Symbol == \"\" {\n\t\treturn errors.New(\"symbol is required\")\n\t}\n\n\turl := fmt.Sprintf(\"%s/quote?symbol=%s&apikey=%s\", s.Api, req.Symbol, s.Key)\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\thttpReq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := client.Do(httpReq)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to fetch quote: %s\", resp.Status)\n\t}\n\n\tvar apiResp apiResponse\n\tif err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {\n\t\treturn err\n\t}\n\n\trsp.Symbol = apiResp.Symbol\n\trsp.Price = apiResp.Price\n\treturn nil\n}"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a function to download a file from a given URL, apply an optional filter to the content, and save it to specified directories.\n\nFunction Description: The function `dl` downloads a file from a provided URL, reads its content, applies an optional filter (if provided), and writes the content to one or more specified directories. It handles errors during the HTTP request, reading the response, and file writing, and provides status feedback via console output.\n\nInput:  \n- `f` (type `dlFile`): A struct containing the following fields:  \n  - `name` (string): The name of the file to be saved.  \n  - `url` (string): The URL from which the file will be downloaded.  \n  - `filt` (func([]byte) []byte): An optional function to filter/modify the downloaded content. Can be `nil` if no filtering is needed.  \n  - `dirs` ([]string): A slice of directory paths where the file will be saved.  \n\nOutput:  \n- None (void): The function does not return any value but prints status messages to the console (e.g., \"Sync [filename]: ok\" on success or error messages on failure).  \n\nNote: The function handles errors for HTTP requests, reading response bodies, and file writing, and ensures the response body is closed properly to prevent resource leaks.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc dl(f dlFile) {\n\tfmt.Printf(\"Sync %s: \", f.name)\n\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\tioutil.WriteFile(filepath.Join(dir, f.name), content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Println(\"ok\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype dlFile struct {\n\tname string\n\turl  string\n\tfilt func([]byte) []byte\n\tdirs []string\n}\n\nfunc dl(f dlFile) {\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Printf(\"Error downloading %s: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading response for %s: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\tfilePath := filepath.Join(dir, f.name)\n\t\terr := os.WriteFile(filePath, content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error writing file %s to %s: %v\\n\", f.name, dir, err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"Sync %s: ok\\n\", filePath)\n\t}\n}\n```"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL with optional custom headers and client configuration, while implementing safety measures like response size limiting and proper resource cleanup.\n\nFunction Description: The function `ReadURL` makes an HTTP GET request to the specified URL using a provided HTTP client and optional headers. It ensures proper resource cleanup, checks for successful response status, limits the maximum readable response size, and returns the response body or an error if any step fails.\n\nInput:\n- `url` [string] - The URL to send the GET request to\n- `client` [*http.Client] - The HTTP client to use for the request (can be nil to use http.DefaultClient)\n- `header` [*http.Header] - Optional headers to include in the request (can be nil)\n\nOutput:\n- `body` [[]byte] - The response body if the request is successful\n- `err` [error] - An error object if any step fails, including:\n  - Request creation failure\n  - Network errors\n  - Non-200 status codes (wrapped in HTTPError)\n  - Read errors\n  - Response size exceeding limit",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tmaxReadLength = 10 * 1 << 20\n)\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) (body []byte, err error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{\n\t\t\tStatusCode: resp.StatusCode,\n\t\t\tURL:        url,\n\t\t}\n\t}\n\n\tlimitedReader := &io.LimitedReader{R: resp.Body, N: maxReadLength}\n\tcontents, err := ioutil.ReadAll(limitedReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif limitedReader.N <= 0 {\n\t\treturn nil, errors.New(\"the read limit is reached\")\n\t}\n\n\treturn contents, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\nconst maxResponseSize = 10 * 1024 * 1024 // 10 MB\n\ntype HTTPError struct {\n\tStatusCode int\n\tStatus     string\n}\n\nfunc (e *HTTPError) Error() string {\n\treturn fmt.Sprintf(\"HTTP request failed with status %d: %s\", e.StatusCode, e.Status)\n}\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) ([]byte, error) {\n\tif client == nil {\n\t\tclient = http.DefaultClient\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{StatusCode: resp.StatusCode, Status: resp.Status}\n\t}\n\n\tlimitedReader := io.LimitReader(resp.Body, maxResponseSize)\n\tbody, err := io.ReadAll(limitedReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(body) == maxResponseSize {\n\t\treturn nil, errors.New(\"response size exceeds limit\")\n\t}\n\n\treturn body, nil\n}\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: The task involves creating a struct and associated method to handle chunked file uploads to a remote server using HTTP PUT requests with proper content range headers.\n\nStruct Description: The UploadSession struct represents an ongoing file upload session, tracking upload state, metadata, and providing methods for chunked upload operations.\n\nFields:\n\nID: string - Unique identifier for the upload session\nOldID: string - Previous session ID (if applicable)\nParentID: string - ID of parent directory\nNodeID: uint64 - Filesystem node identifier\nName: string - Name of the file being uploaded\nExpirationDateTime: time.Time - When the upload session expires\nSize: uint64 - Total size of the file in bytes\nData: []byte - File content data being uploaded\nQuickXORHash: string - File content hash\nModTime: time.Time - File modification time\nretries: int - Number of upload retry attempts\nUploadURL: string - Server endpoint for chunk uploads\nETag: string - Entity tag from server response\nstate: int - Current upload state\nerror: error - Last encountered error\nsync.Mutex: - Mutex for thread-safe operations\n\nMethods:\n\nuploadChunk: (auth *graph.Auth, offset uint64) -> ([]byte, int, error) - Uploads a file chunk starting at specified offset. Returns response body, HTTP status code, and error if any. Handles authentication refresh and proper Content-Range headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/jstaf/onedriver/fs/graph\"\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype UploadSession struct {\n\tID                 string    `json:\"id\"`\n\tOldID              string    `json:\"oldID\"`\n\tParentID           string    `json:\"parentID\"`\n\tNodeID             uint64    `json:\"nodeID\"`\n\tName               string    `json:\"name\"`\n\tExpirationDateTime time.Time `json:\"expirationDateTime\"`\n\tSize               uint64    `json:\"size,omitempty\"`\n\tData               []byte    `json:\"data,omitempty\"`\n\tQuickXORHash       string    `json:\"quickxorhash,omitempty\"`\n\tModTime            time.Time `json:\"modTime,omitempty\"`\n\tretries            int\n\n\tsync.Mutex\n\tUploadURL string `json:\"uploadUrl\"`\n\tETag      string `json:\"eTag,omitempty\"`\n\tstate     int\n\terror\n}\n\nfunc (u *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tu.Lock()\n\turl := u.UploadURL\n\tif url == \"\" {\n\t\tu.Unlock()\n\t\treturn nil, -1, errors.New(\"UploadSession UploadURL cannot be empty\")\n\t}\n\tu.Unlock()\n\n\tend := offset + uploadChunkSize\n\tvar reqChunkSize uint64\n\tif end > u.Size {\n\t\tend = u.Size\n\t\treqChunkSize = end - offset + 1\n\t}\n\tif offset > u.Size {\n\t\treturn nil, -1, errors.New(\"offset cannot be larger than DriveItem size\")\n\t}\n\n\tauth.Refresh()\n\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\n\t\t\"PUT\",\n\t\turl,\n\t\tbytes.NewReader((u.Data)[offset:end]),\n\t)\n\trequest.Header.Add(\"Content-Length\", strconv.Itoa(int(reqChunkSize)))\n\tfrags := fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, u.Size)\n\tlog.Info().Str(\"id\", u.ID).Msg(\"Uploading \" + frags)\n\trequest.Header.Add(\"Content-Range\", frags)\n\n\tresp, err := client.Do(request)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\tdefer resp.Body.Close()\n\tresponse, _ := ioutil.ReadAll(resp.Body)\n\treturn response, resp.StatusCode, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype UploadSession struct {\n\tID                string\n\tOldID             string\n\tParentID          string\n\tNodeID            uint64\n\tName              string\n\tExpirationDateTime time.Time\n\tSize              uint64\n\tData              []byte\n\tQuickXORHash      string\n\tModTime           time.Time\n\tretries           int\n\tUploadURL         string\n\tETag              string\n\tstate             int\n\terror             error\n\tsync.Mutex\n}\n\ntype Auth struct {\n\tToken string\n}\n\nfunc (session *UploadSession) uploadChunk(auth *Auth, offset uint64) ([]byte, int, error) {\n\tsession.Lock()\n\tdefer session.Unlock()\n\n\tif offset >= session.Size {\n\t\treturn nil, 0, errors.New(\"offset exceeds file size\")\n\t}\n\n\tend := offset + 1024*1024 // 1MB chunk size\n\tif end > session.Size {\n\t\tend = session.Size\n\t}\n\n\treq, err := http.NewRequest(\"PUT\", session.UploadURL, bytes.NewReader(session.Data[offset:end]))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+auth.Token)\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, session.Size))\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tif resp.StatusCode == http.StatusUnauthorized {\n\t\t// Handle token refresh logic here if needed\n\t}\n\n\treturn body, resp.StatusCode, nil\n}\n\nfunc main() {\n\t// Example usage\n\tauth := &Auth{Token: \"your_access_token\"}\n\tsession := &UploadSession{\n\t\tID:                \"session_id\",\n\t\tUploadURL:         \"https://example.com/upload\",\n\t\tSize:              5000000, // 5MB\n\t\tData:              make([]byte, 5000000), // Example data\n\t}\n\n\toffset := uint64(0)\n\tfor offset < session.Size {\n\t\tbody, status, err := session.uploadChunk(auth, offset)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error uploading chunk:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Chunk uploaded, status:\", status, \"response:\", string(body))\n\t\toffset += 1024 * 1024 // Move to next chunk\n\t}\n}\n```"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Write a Go function that retrieves the private IPv4 address of an Amazon EC2 instance by querying the instance metadata service.\n\nFunction Description: The function should make an HTTP GET request to the EC2 instance metadata service at the well-known endpoint (169.254.169.254) to fetch the local IPv4 address. It should handle potential errors during the request, response reading, and IP parsing, and return the IPv4 address in net.IP format.\n\nInput: None (the function takes no parameters)\n\nOutput: \n- On success: Returns the private IPv4 address as a net.IP object (IPv4 format)\n- On failure: Returns nil and an error describing what went wrong (failed request, invalid response, or invalid IP address)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc amazonEC2PrivateIPv4() (net.IP, error) {\n\tres, err := http.Get(\"http://169.254.169.254/latest/meta-data/local-ipv4\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tip := net.ParseIP(string(body))\n\tif ip == nil {\n\t\treturn nil, errors.New(\"invalid ip address\")\n\t}\n\treturn ip.To4(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "import (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc GetEC2PrivateIPv4() (net.IP, error) {\n\tconst metadataURL = \"http://169.254.169.254/latest/meta-data/local-ipv4\"\n\tclient := &http.Client{\n\t\tTimeout: 2 * time.Second,\n\t}\n\n\tresp, err := client.Get(metadataURL)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to make request to metadata service: \" + err.Error())\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"received non-OK response from metadata service\")\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to read response body: \" + err.Error())\n\t}\n\n\tip := net.ParseIP(string(body))\n\tif ip == nil {\n\t\treturn nil, errors.New(\"invalid IP address format\")\n\t}\n\n\treturn ip, nil\n}"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string]: The URL of the file to be fetched\n\nOutput: \n- `[]byte`: The contents of the file as a byte slice if successful\n- `error`: An error object if any step fails (network error, HTTP error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nvar cacheDir = \"./cache\"\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tcacheFilePath := filepath.Join(cacheDir, filepath.Base(fileurl))\n\n\tif data, err := readFromCache(cacheFilePath); err == nil {\n\t\tfmt.Println(\"Cache hit:\", cacheFilePath)\n\t\treturn data, nil\n\t}\n\n\tfmt.Println(\"Fetching from URL:\", fileurl)\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch file: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP error: %s\", resp.Status)\n\t}\n\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\tif err := writeToCache(cacheFilePath, data); err != nil {\n\t\tfmt.Println(\"Warning: failed to write to cache:\", err)\n\t}\n\n\treturn data, nil\n}\n\nfunc readFromCache(filePath string) ([]byte, error) {\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn nil, errors.New(\"cache miss\")\n\t}\n\treturn ioutil.ReadFile(filePath)\n}\n\nfunc writeToCache(filePath string, data []byte) error {\n\tif err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(filePath, data, 0644)\n}\n\nfunc main() {\n\turl := \"https://example.com/file.txt\"\n\tdata, err := fetchFile(url)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"File contents:\", string(data))\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: The task involves creating a Go struct that encapsulates functionality for sending push notifications through a push service, handling HTTP communication, and processing responses. The struct should manage HTTP client configuration, request construction, and response handling for push notification delivery.\n\nStruct Description: PushServiceBase is a struct that provides base functionality for push notification services. It manages HTTP client configuration, constructs requests to a push service endpoint, handles authentication, processes responses, and manages delivery results. The struct is designed to be extended by specific push service implementations.\n\nFields:\n\nclient: [*http.Client] - Custom HTTP client configured with TLS settings and timeouts\ninitialism: [string] - Short identifier for the push service\nrawPayloadKey: [string] - Key for raw payload in notification data\nrawNotificationKey: [string] - Key for raw notification in notification data\nserviceURL: [string] - Base URL for the push service endpoint\npushServiceName: [string] - Name of the push service\n\nMethods:\n\nMakePushServiceBase: [func(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase] - Constructor that initializes the PushServiceBase with configuration and creates a custom HTTP client\n\nmulticast: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification)] - Sends push notifications to multiple devices, handles HTTP communication, and processes responses. Takes push service provider, delivery points, result channel, and notification as input, and writes results to the channel\n\nToCMPayload: [func(notif *push.Notification, regIds []string) ([]byte, error)] - Converts notification to payload format (implementation not shown in reference code)\n\nhandleCMMulticastResults: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult)] - Processes multicast results from push service (implementation not shown in reference code)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uniqush/uniqush-push/push\"\n\t\"github.com/uniqush/uniqush-push/util\"\n)\n\ntype PushServiceBase struct {\n\tclient             HTTPClient\n\tinitialism         string\n\trawPayloadKey      string\n\trawNotificationKey string\n\tserviceURL         string\n\tpushServiceName    string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\tconf := &tls.Config{InsecureSkipVerify: false}\n\ttr := &http.Transport{\n\t\tTLSClientConfig:     conf,\n\t\tTLSHandshakeTimeout: time.Second * 5,\n\t\tMaxIdleConnsPerHost: 500,\n\t}\n\tclient := &http.Client{\n\t\tTransport: tr,\n\t\tTimeout:   time.Second * 10,\n\t}\n\treturn PushServiceBase{\n\t\tclient:             client,\n\t\tinitialism:         initialism,\n\t\trawPayloadKey:      rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:         serviceURL,\n\t\tpushServiceName:    pushServiceName,\n\t}\n}\n\nfunc (psb *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tif len(dpList) == 0 {\n\t\treturn\n\t}\n\tregIds := extractRegIds(dpList)\n\n\tjpayload, e0 := psb.ToCMPayload(notif, regIds)\n\n\tif e0 != nil {\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, e0)\n\t\treturn\n\t}\n\n\treq, e1 := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewReader(jpayload))\n\tif req != nil {\n\t\tdefer req.Body.Close()\n\t}\n\tif e1 != nil {\n\t\thttpErr := push.NewErrorf(\"Error constructing HTTP request: %v\", e1)\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, httpErr)\n\t\treturn\n\t}\n\n\tapikey := psp.VolatileData[\"apikey\"]\n\n\treq.Header.Set(\"Authorization\", \"key=\"+apikey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tr, e2 := psb.client.Do(req)\n\tif r != nil {\n\t\tdefer r.Body.Close()\n\t}\n\tif e2 != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\n\t\t\tres.Destination = dp\n\t\t\tif err, ok := e2.(net.Error); ok {\n\t\t\t\tif err.Temporary() {\n\t\t\t\t\tafter := 3 * time.Second\n\t\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t\t}\n\t\t\t} else if err, ok := e2.(*net.DNSError); ok {\n\t\t\t\tafter := 3 * time.Second\n\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t} else {\n\t\t\t\tres.Err = push.NewErrorf(\"Unrecoverable HTTP error sending to %s: %v\", psb.pushServiceName, e2)\n\t\t\t}\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\t}\n\n\tnewAuthToken := r.Header.Get(\"Update-Client-Auth\")\n\tif newAuthToken != \"\" && apikey != newAuthToken {\n\t\tpsp.VolatileData[\"apikey\"] = newAuthToken\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewPushServiceProviderUpdate(psp)\n\t\tresQueue <- res\n\t}\n\n\tswitch r.StatusCode {\n\tcase 500, 503:\n\t\tafter := 0 * time.Second\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\t\t\tres.Destination = dp\n\t\t\terr := push.NewRetryError(psp, dp, notif, after)\n\t\t\tres.Err = err\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\tcase 401:\n\t\terr := push.NewBadPushServiceProviderWithDetails(psp, fmt.Sprintf(\"push service credentials rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\tcase 400:\n\t\terr := push.NewBadNotificationWithDetails(fmt.Sprintf(\"push notification payload rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tcontents, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to read %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tvar result CMResult\n\terr = json.Unmarshal(contents, &result)\n\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to decode %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, result.Results)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage pushservice\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"time\"\n\t\"push\"\n)\n\ntype PushServiceBase struct {\n\tclient            *http.Client\n\tinitialism        string\n\trawPayloadKey     string\n\trawNotificationKey string\n\tserviceURL        string\n\tpushServiceName   string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\treturn PushServiceBase{\n\t\tclient: &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t\t},\n\t\t\tTimeout: 30 * time.Second,\n\t\t},\n\t\tinitialism:        initialism,\n\t\trawPayloadKey:     rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:        serviceURL,\n\t\tpushServiceName:   pushServiceName,\n\t}\n}\n\nfunc (psb *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tpayload, err := psb.ToCMPayload(notif, extractRegIds(dpList))\n\tif err != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tresQueue <- &push.Result{Provider: psp, Destination: dp, MsgID: \"\", Err: err}\n\t\t}\n\t\treturn\n\t}\n\n\treq, err := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewBuffer(payload))\n\tif err != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tresQueue <- &push.Result{Provider: psp, Destination: dp, MsgID: \"\", Err: err}\n\t\t}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresp, err := psb.client.Do(req)\n\tif err != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tresQueue <- &push.Result{Provider: psp, Destination: dp, MsgID: \"\", Err: err}\n\t\t}\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tvar results []CMResult\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tresQueue <- &push.Result{Provider: psp, Destination: dp, MsgID: \"\", Err: err}\n\t\t}\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, results)\n}\n\nfunc (psb *PushServiceBase) ToCMPayload(notif *push.Notification, regIds []string) ([]byte, error) {\n\t// Implementation not shown\n\treturn nil, nil\n}\n\nfunc (psb *PushServiceBase) handleCMMulticastResults(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult) {\n\t// Implementation not shown\n}\n\nfunc extractRegIds(dpList []*push.DeliveryPoint) []string {\n\tvar regIds []string\n\tfor _, dp := range dpList {\n\t\tregIds = append(regIds, dp.RegID())\n\t}\n\treturn regIds\n}\n\ntype CMResult struct {\n\t// Fields not shown\n}\n```"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response validation, and resource cleanup. The function is designed to work with metadata services like Google Cloud's metadata server.\n\nInput:  \n- `key` (string): The metadata key to retrieve from the metadata server. This is appended to the base metadata path.\n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tconst metadataServerURL = \"http://metadata.google.internal/computeMetadata/v1/\"\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", metadataServerURL+key, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\treq.Header.Add(\"Metadata-Flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Implement a function to fetch the contents of a file from a given URL and return it as an io.Reader for further processing.  \n\nFunction Description: The function `fetchFile` takes a URL as input, sends an HTTP GET request to fetch the file, reads the response body, and returns it as an `io.Reader`. It handles errors during the HTTP request and response reading.  \n\nInput:  \n- `URL` (string) - The URL of the file to be fetched.  \n\nOutput:  \n- `io.Reader` - A reader containing the contents of the fetched file.  \n\n(Note: The `checkErr` function is assumed to handle errors by panicking or logging.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n\tresp, err := http.Get(URL)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tcheckErr(err)\n\treturn strings.NewReader(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n\tresp, err := http.Get(URL)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\treturn resp.Body\n}"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Implement a GIF search functionality using the Giphy API in Go, handling HTTP requests, response parsing, and error management.\n\nStruct Description: The Gifs struct represents a service for searching GIFs using the Giphy API. It maintains configuration and provides methods to interact with the API.\n\nFields:\n- conf: [conf] - Configuration containing the Giphy API key\n\nMethods:\n- New: [func() *Gifs] - Initializes a new Gifs instance by loading configuration\n- Search: [func(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error] - Searches for GIFs using the Giphy API with the provided query and parameters\n\nInput:\n- ctx: [context.Context] - Context for request cancellation and timeouts\n- request: [*gifs.SearchRequest] - Contains search parameters (query, limit, offset, rating, language)\n- response: [*gifs.SearchResponse] - Will be populated with search results\n\nOutput:\n- error: Returns nil on success or an appropriate error on failure",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/config\"\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tgifs \"github.com/micro/services/gifs/proto\"\n)\n\ntype conf struct {\n\tAPIKey string `json:\"api_key\"`\n}\n\ntype Gifs struct {\n\tconf conf\n}\n\nfunc New() *Gifs {\n\tv, err := config.Get(\"micro.gifs\")\n\tif err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\tvar c conf\n\tif err := v.Scan(&c); err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\n\treturn &Gifs{conf: c}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error {\n\tif len(request.Query) == 0 {\n\t\treturn errors.BadRequest(\"gifs.Search\", \"Missing query field\")\n\t}\n\tlimit := defaultLimit\n\tif request.Limit > 0 {\n\t\tlimit = request.Limit\n\t}\n\toffset := defaultOffset\n\tif request.Offset > 0 {\n\t\toffset = request.Offset\n\t}\n\n\trating := defaultRating\n\tif len(request.Rating) > 0 {\n\t\trating = request.Rating\n\t}\n\tlan := defaultLang\n\tif len(request.Lang) > 0 {\n\t\tlan = request.Lang\n\t}\n\trsp, err := http.Get(fmt.Sprintf(giphySearch, g.conf.APIKey, request.Query, limit, offset, rating, lan))\n\tif err != nil {\n\t\tlogger.Errorf(\"Error querying giphy %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tdefer rsp.Body.Close()\n\tb, err := ioutil.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tvar gRsp searchResponse\n\tif err := json.Unmarshal(b, &gRsp); err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tresponse.Data = marshalGifs(gRsp.Data)\n\tresponse.Pagination = &gifs.Pagination{\n\t\tOffset:     gRsp.Pagination.Offset,\n\t\tTotalCount: gRsp.Pagination.TotalCount,\n\t\tCount:      gRsp.Pagination.Count,\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package gifs\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype conf struct {\n\tAPIKey string\n}\n\ntype Gifs struct {\n\tconf conf\n}\n\ntype SearchRequest struct {\n\tQuery    string\n\tLimit    int\n\tOffset   int\n\tRating   string\n\tLanguage string\n}\n\ntype SearchResponse struct {\n\tData []GifData `json:\"data\"`\n}\n\ntype GifData struct {\n\tID     string `json:\"id\"`\n\tURL    string `json:\"url\"`\n\tTitle  string `json:\"title\"`\n\tImages struct {\n\t\tOriginal struct {\n\t\t\tURL string `json:\"url\"`\n\t\t} `json:\"original\"`\n\t} `json:\"images\"`\n}\n\nfunc New(apiKey string) *Gifs {\n\treturn &Gifs{\n\t\tconf: conf{APIKey: apiKey},\n\t}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *SearchRequest, response *SearchResponse) error {\n\tif request.Query == \"\" {\n\t\treturn errors.New(\"query cannot be empty\")\n\t}\n\n\turl := fmt.Sprintf(\"https://api.giphy.com/v1/gifs/search?api_key=%s&q=%s&limit=%d&offset=%d&rating=%s&lang=%s\",\n\t\tg.conf.APIKey, request.Query, request.Limit, request.Offset, request.Rating, request.Language)\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to fetch gifs: status code %d\", resp.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(response); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 327,
    "Instruction": "Task Description: Implement a function that sets up a cron job to make periodic HTTP GET requests to a specified callback URL and logs the results.\n\nFunction Description: The function `Setup` initializes a new cron scheduler, adds a job that makes HTTP GET requests to a specified callback URL at a given interval, and logs the success or failure of each request. The function starts the cron scheduler and returns it for further management.\n\nInput: \n- `job` [*pb.Job] - A protobuf message containing the job details, including:\n  - `Id` [string] - Unique identifier for the job\n  - `Interval` [string] - Cron-formatted interval at which the job should run\n  - `Callback` [string] - URL to which the HTTP GET request will be made\n\nOutput: \n- [*cron.Cron] - A pointer to the started cron scheduler instance, which can be used to stop or manage the scheduled job.",
    "Canonical_solution": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/cron/proto\"\n\t\"github.com/robfig/cron/v3\"\n)\nfunc (c *Cron) Setup(job *pb.Job) *cron.Cron {\n\tlogger.Infof(\"Setting up job id: %s\", job.Id)\n\tcr := cron.New()\n\tcr.AddFunc(job.Interval, func() {\n\t\tlogger.Infof(\"Running job id: %s\", job.Id)\n\t\trsp, err := http.Get(job.Callback)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed job id: %s error: %v\", job.Id, err)\n\t\t\treturn\n\t\t}\n\t\tdefer rsp.Body.Close()\n\t\tb, _ := ioutil.ReadAll(rsp.Body)\n\t\tif rsp.StatusCode != 200 {\n\t\t\tlogger.Errorf(\"Non 200 job id: %s error: %s\", job.Id, string(b))\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Successful job id: %s\", job.Id)\n\t})\n\tcr.Start()\n\treturn cr\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n\tpb \"path/to/protobuf/package\"\n)\n\nfunc Setup(job *pb.Job) *cron.Cron {\n\tc := cron.New()\n\n\t_, err := c.AddFunc(job.Interval, func() {\n\t\tresp, err := http.Get(job.Callback)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Job ID %s: Failed to make GET request: %v\", job.Id, err)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\tlog.Printf(\"Job ID %s: Successfully made GET request to %s\", job.Id, job.Callback)\n\t\t} else {\n\t\t\tlog.Printf(\"Job ID %s: Received non-OK response: %d\", job.Id, resp.StatusCode)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to add cron job: %v\", err)\n\t}\n\n\tc.Start()\n\treturn c\n}\n\nfunc main() {\n\t// Example usage\n\tjob := &pb.Job{\n\t\tId:       \"example-job\",\n\t\tInterval: \"@every 1m\",\n\t\tCallback: \"http://example.com/callback\",\n\t}\n\n\tcronScheduler := Setup(job)\n\tdefer cronScheduler.Stop()\n\n\t// Keep the application running\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response processing, and error checking. The function ensures proper resource cleanup by deferring the closing of the response body.\n\nInput:  \n- `key` (string): The metadata key to be appended to the metadata server's base path.  \n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tbaseURL := \"http://metadata.server/path/\"\n\turl := baseURL + key\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\n\treq.Header.Set(\"Custom-Header\", \"HeaderValue\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to perform request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"non-200 response: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn body, nil\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a Proxy struct that manages different types of servers (UDS, mTLS, admin, and health) for handling proxy connections with various protocols (HTTP and gRPC).\n\nStruct Description: The Proxy struct provides methods to run different server types with configurable options, including Unix Domain Socket (UDS) servers, mTLS-secured servers, admin servers for metrics and profiling, and health servers for liveness/readiness checks.\n\nMethods:\n\nMethod1: runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a master server using Unix Domain Socket (UDS) for communication. Supports both gRPC and HTTP modes based on configuration. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod2: runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a mTLS-secured master server listening on a TCP port. Supports both gRPC and HTTP modes. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod3: runAdminServer(o *options.ProxyRunOptions) -> void - Starts an admin server for metrics and optional profiling endpoints. Runs on a localhost port specified in options.\n\nMethod4: runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) -> void - Starts a health server providing liveness (/healthz) and readiness (/ready) endpoints. Runs on a port specified in options.\n\nNote: StopFunc is a function type defined as: type StopFunc func()",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Proxy struct {\n}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tif o.DeleteUDSFile {\n\t\tif err := os.Remove(o.UdsName); err != nil && !os.IsNotExist(err) {\n\t\t\tklog.ErrorS(err, \"failed to delete file\", \"file\", o.UdsName)\n\t\t}\n\t}\n\tvar stop StopFunc\n\tif o.Mode == \"grpc\" {\n\t\tgrpcServer := grpc.NewServer()\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := getUDSListener(ctx, o.UdsName)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get uds listener: %v\", err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\tserver := &http.Server{\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tklog.ErrorS(err, \"error shutting down server\")\n\t\t}\n\t\tgo func() {\n\t\t\tudsListener, err := getUDSListener(ctx, o.UdsName)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to get uds listener\")\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\terr := udsListener.Close()\n\t\t\t\tklog.ErrorS(err, \"failed to close uds listener\")\n\t\t\t}()\n\t\t\terr = server.Serve(udsListener)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to serve uds requests\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tvar stop StopFunc\n\n\tvar tlsConfig *tls.Config\n\tvar err error\n\tif tlsConfig, err = p.getTLSConfig(o.ServerCaCert, o.ServerCert, o.ServerKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", o.ServerPort)\n\n\tif o.Mode == grpcMode {\n\t\tserverOption := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\tgrpcServer := grpc.NewServer(serverOption)\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to listen on %s: %v\", addr, err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\thttpServer := &http.Server{\n\t\t\tAddr: \":8088\",\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr:      addr,\n\t\t\tTLSConfig: tlsConfig,\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t\tTLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),\n\t\t}\n\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown server\")\n\t\t\t}\n\t\t\terr = httpServer.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown httpServer\")\n\t\t\t}\n\t\t}\n\t\tgo func() {\n\t\t\terr := server.ListenAndServeTLS(\"\", \"\")\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on master port\")\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\terr := httpServer.ListenAndServe()\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on http master port\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.Handle(\"/metrics\", promhttp.Handler())\n\tif o.EnableProfiling {\n\t\tmuxHandler.HandleFunc(\"/debug/pprof\", util.RedirectTo(\"/debug/pprof/\"))\n\t\tmuxHandler.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\tif o.EnableContentionProfiling {\n\t\t\truntime.SetBlockProfileRate(1)\n\t\t}\n\t}\n\tadminServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\"127.0.0.1:%d\", o.AdminPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := adminServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"admin server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Admin server stopped listening\")\n\t}()\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\tlivenessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\treadinessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tready, msg := server.Readiness.Ready()\n\t\tif ready {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tfmt.Fprintf(w, \"ok\")\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, msg)\n\t})\n\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.HandleFunc(\"/healthz\", livenessHandler)\n\tmuxHandler.HandleFunc(\"/ready\", readinessHandler)\n\thealthServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\":%d\", o.HealthPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := healthServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"health server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Health server stopped listening\")\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "type StopFunc func()\n\ntype Proxy struct{}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tlistener, err := net.Listen(\"unix\", o.UDSPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar server *http.Server\n\tif o.UseGRPC {\n\t\tserver = &http.Server{\n\t\t\tHandler: grpcHandler(s),\n\t\t}\n\t} else {\n\t\tserver = &http.Server{\n\t\t\tHandler: httpHandler(s),\n\t\t}\n\t}\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"UDS server failed: %v\", err)\n\t\t}\n\t}()\n\n\treturn func() {\n\t\tserver.Shutdown(ctx)\n\t}, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tcert, err := tls.LoadX509KeyPair(o.CertFile, o.KeyFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t}\n\n\tlistener, err := tls.Listen(\"tcp\", o.MTLSPort, tlsConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar server *http.Server\n\tif o.UseGRPC {\n\t\tserver = &http.Server{\n\t\t\tHandler: grpcHandler(s),\n\t\t}\n\t} else {\n\t\tserver = &http.Server{\n\t\t\tHandler: httpHandler(s),\n\t\t}\n\t}\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"mTLS server failed: %v\", err)\n\t\t}\n\t}()\n\n\treturn func() {\n\t\tserver.Shutdown(ctx)\n\t}, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\tif o.EnableProfiling {\n\t\thttp.Handle(\"/debug/pprof/\", http.DefaultServeMux)\n\t}\n\n\tgo func() {\n\t\tif err := http.ListenAndServe(o.AdminPort, nil); err != nil {\n\t\t\tlog.Fatalf(\"Admin server failed: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\thttp.HandleFunc(\"/ready\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif server.IsReady() {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t}\n\t})\n\n\tgo func() {\n\t\tif err := http.ListenAndServe(o.HealthPort, nil); err != nil {\n\t\t\tlog.Fatalf(\"Health server failed: %v\", err)\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a PKCE (Proof Key for Code Exchange) authorization flow in Go that handles OAuth2 token retrieval through a temporary HTTP server.\n\nStruct Description: PKCEAuthorizationFlow represents an OAuth2 authorization flow using PKCE (Proof Key for Code Exchange) mechanism. It manages the state, code verifier, and OAuth configuration needed for the flow, and provides methods to wait for and handle tokens.\n\nFields:\nproviderConfig: [internal.PKCEAuthProviderConfig] - Configuration for the PKCE auth provider\nstate: [string] - CSRF protection state value\ncodeVerifier: [string] - PKCE code verifier string\noAuthConfig: [*oauth2.Config] - OAuth2 configuration including client ID, secret, and endpoints\n\nMethods:\nWaitToken: [Name](ctx context.Context, _ AuthFlowInfo) -> (TokenInfo, error) - Main method that waits for token retrieval by starting a temporary HTTP server and handling the OAuth callback\nstartServer: [Name](server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) - Starts an HTTP server to handle OAuth callback and sends results through channels\nhandleRequest: [Name](req *http.Request) -> (*oauth2.Token, error) - Handles incoming OAuth callback request, validates state, and exchanges code for token",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (p *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\ttokenChan := make(chan *oauth2.Token, 1)\n\terrChan := make(chan error, 1)\n\n\tparsedURL, err := url.Parse(p.oAuthConfig.RedirectURL)\n\tif err != nil {\n\t\treturn TokenInfo{}, fmt.Errorf(\"failed to parse redirect URL: %v\", err)\n\t}\n\n\tserver := &http.Server{Addr: fmt.Sprintf(\":%s\", parsedURL.Port())}\n\tdefer func() {\n\t\tshutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(shutdownCtx); err != nil {\n\t\t\tlog.Errorf(\"failed to close the server: %v\", err)\n\t\t}\n\t}()\n\n\tgo p.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\treturn p.parseOAuthToken(token)\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tcert := p.providerConfig.ClientCertPair\n\t\tif cert != nil {\n\t\t\ttr := &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\tCertificates: []tls.Certificate{*cert},\n\t\t\t\t},\n\t\t\t}\n\t\t\tsslClient := &http.Client{Transport: tr}\n\t\t\tctx := context.WithValue(req.Context(), oauth2.HTTPClient, sslClient)\n\t\t\treq = req.WithContext(ctx)\n\t\t}\n\n\t\ttoken, err := p.handleRequest(req)\n\t\tif err != nil {\n\t\t\trenderPKCEFlowTmpl(w, err)\n\t\t\terrChan <- fmt.Errorf(\"PKCE authorization flow failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\trenderPKCEFlowTmpl(w, nil)\n\t\ttokenChan <- token\n\t})\n\n\tserver.Handler = mux\n\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\terrChan <- err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\n\tif authError := query.Get(queryError); authError != \"\" {\n\t\tauthErrorDesc := query.Get(queryErrorDesc)\n\t\treturn nil, fmt.Errorf(\"%s.%s\", authError, authErrorDesc)\n\t}\n\n\tif state := query.Get(queryState); subtle.ConstantTimeCompare([]byte(p.state), []byte(state)) == 0 {\n\t\treturn nil, fmt.Errorf(\"invalid state\")\n\t}\n\n\tcode := query.Get(queryCode)\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code\")\n\t}\n\n\treturn p.oAuthConfig.Exchange(\n\t\treq.Context(),\n\t\tcode,\n\t\toauth2.SetAuthURLParam(\"code_verifier\", p.codeVerifier),\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc generateCodeVerifier() (string, error) {\n\tverifier := make([]byte, 32)\n\t_, err := rand.Read(verifier)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.RawURLEncoding.EncodeToString(verifier), nil\n}\n\nfunc (flow *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\tflow.state = base64.RawURLEncoding.EncodeToString([]byte(time.Now().String()))\n\tcodeVerifier, err := generateCodeVerifier()\n\tif err != nil {\n\t\treturn TokenInfo{}, err\n\t}\n\tflow.codeVerifier = codeVerifier\n\n\ttokenChan := make(chan *oauth2.Token)\n\terrChan := make(chan error)\n\n\tserver := &http.Server{Addr: \":8080\"}\n\tgo flow.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase token := <-tokenChan:\n\t\treturn TokenInfo{AccessToken: token.AccessToken}, nil\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\t}\n}\n\nfunc (flow *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\thttp.HandleFunc(\"/callback\", func(w http.ResponseWriter, req *http.Request) {\n\t\ttoken, err := flow.handleRequest(req)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\thttp.Error(w, \"Failed to retrieve token\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\ttokenChan <- token\n\t\tfmt.Fprintln(w, \"Authorization successful, you can close this window.\")\n\t\tserver.Shutdown(context.Background())\n\t})\n\n\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\terrChan <- err\n\t}\n}\n\nfunc (flow *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tif req.URL.Query().Get(\"state\") != flow.state {\n\t\treturn nil, errors.New(\"invalid state\")\n\t}\n\n\tcode := req.URL.Query().Get(\"code\")\n\ttoken, err := flow.oAuthConfig.Exchange(context.Background(), code, oauth2.SetAuthURLParam(\"code_verifier\", flow.codeVerifier))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn token, nil\n}\n\ntype internal struct{}\ntype AuthFlowInfo struct{}\ntype TokenInfo struct {\n\tAccessToken string\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a WebSocket client in Go that connects to a server, handles incoming messages, and manages connection lifecycle including reconnection logic and graceful shutdown.\n\nFunction Description: The function establishes a WebSocket connection to a specified server endpoint, listens for incoming messages, and prints them to stdout/stderr based on message content. It handles connection errors by implementing automatic reconnection logic and supports graceful shutdown upon receiving an interrupt signal.\n\nInput: None (uses package-level configuration variables for connection details)\n\nOutput: None (writes directly to stdout/stderr, logs to console)\n\nNote: The function relies on several external configuration variables:\n- config.Config.Tap.Proxy.Host (string) - Server hostname\n- config.Config.Tap.Proxy.Front.Port (int) - Server port\n- config.Config.License (string) - License key for authentication\n- kubernetes.GetHubUrl() (string) - Function to get hub URL for health checks",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/kubeshark/kubeshark/config\"\n\t\"github.com/kubeshark/kubeshark/utils\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc runConsoleWithoutProxy() {\n\tlog.Info().Msg(\"Starting scripting console ...\")\n\ttime.Sleep(5 * time.Second)\n\thubUrl := kubernetes.GetHubUrl()\n\tfor {\n\t\tresponse, err := http.Get(fmt.Sprintf(\"%s/echo\", hubUrl))\n\t\tif err != nil || response.StatusCode != 200 {\n\t\t\tlog.Info().Msg(fmt.Sprintf(utils.Yellow, \"Couldn't connect to Hub.\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tinterrupt := make(chan os.Signal, 1)\n\t\tsignal.Notify(interrupt, os.Interrupt)\n\n\t\tlog.Info().Str(\"host\", config.Config.Tap.Proxy.Host).Str(\"url\", hubUrl).Msg(\"Connecting to:\")\n\t\tu := url.URL{\n\t\t\tScheme: \"ws\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%d\", config.Config.Tap.Proxy.Host, config.Config.Tap.Proxy.Front.Port),\n\t\t\tPath:   \"/api/scripts/logs\",\n\t\t}\n\t\theaders := http.Header{}\n\t\theaders.Set(utils.X_KUBESHARK_CAPTURE_HEADER_KEY, utils.X_KUBESHARK_CAPTURE_HEADER_IGNORE_VALUE)\n\t\theaders.Set(\"License-Key\", config.Config.License)\n\n\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), headers)\n\t\tif err != nil {\n\t\t\tlog.Error().Err(err).Msg(\"Websocket dial error, retrying in 5 seconds...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tdefer c.Close()\n\n\t\tdone := make(chan struct{})\n\n\t\tgo func() {\n\t\t\tdefer close(done)\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error().Err(err).Msg(\"Error reading websocket message, reconnecting...\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tmsg := string(message)\n\t\t\t\tif strings.Contains(msg, \":ERROR]\") {\n\t\t\t\t\tmsg = fmt.Sprintf(utils.Red, msg)\n\t\t\t\t\tfmt.Fprintln(os.Stderr, msg)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintln(os.Stdout, msg)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tticker := time.NewTicker(time.Second)\n\t\tdefer ticker.Stop()\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\tlog.Warn().Msg(fmt.Sprintf(utils.Yellow, \"Connection closed, reconnecting...\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\tcase <-interrupt:\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Error().Err(err).Send()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tserverHost = config.Config.Tap.Proxy.Host\n\tserverPort = config.Config.Tap.Proxy.Front.Port\n\tlicenseKey = config.Config.License\n)\n\nfunc getWebSocketURL() string {\n\treturn fmt.Sprintf(\"ws://%s:%d\", serverHost, serverPort)\n}\n\nfunc connectWebSocket() (*websocket.Conn, error) {\n\tu := url.URL{Scheme: \"ws\", Host: fmt.Sprintf(\"%s:%d\", serverHost, serverPort), Path: \"/\"}\n\tlog.Printf(\"Connecting to %s\", u.String())\n\n\theaders := map[string][]string{\n\t\t\"Authorization\": {fmt.Sprintf(\"Bearer %s\", licenseKey)},\n\t}\n\n\tconn, _, err := websocket.DefaultDialer.Dial(u.String(), headers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\nfunc handleMessages(conn *websocket.Conn) {\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading message: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif string(message) == \"error\" {\n\t\t\tlog.Printf(\"Error message received: %s\", message)\n\t\t} else {\n\t\t\tfmt.Printf(\"Message received: %s\\n\", message)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)\n\n\tvar conn *websocket.Conn\n\tvar err error\n\n\tfor {\n\t\tconn, err = connectWebSocket()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to connect: %v\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\thandleMessages(conn)\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\tlog.Println(\"Connection closed, attempting to reconnect...\")\n\t\t\tconn.Close()\n\t\t\tfor {\n\t\t\t\tconn, err = connectWebSocket()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to reconnect: %v\", err)\n\t\t\t\t\ttime.Sleep(5 * time.Second)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tgo handleMessages(conn)\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"Received interrupt signal, shutting down gracefully...\")\n\t\t\tconn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Implement a WebSocket server for RDP (Remote Desktop Protocol) connections using the Gorilla WebSocket library in Go. The server should handle WebSocket connections, manage RDP sessions through a Guacamole tunnel, and support bidirectional communication between the client and the RDP server.\n\nStruct Description: The RDPServer struct represents an RDP WebSocket server that manages WebSocket connections and RDP sessions via Guacamole tunnels.\n\nFields:\n- Session: *session.SSession - The current user session information\n- Host: string - The RDP server host address\n- Port: int - The RDP server port number\n- Username: string - The username for RDP authentication\n- Password: string - The password for RDP authentication\n- ConnectionId: string - Unique identifier for the RDP connection\n- Width: int - The screen width for the RDP session\n- Height: int - The screen height for the RDP session\n- Dpi: int - The DPI setting for the RDP session\n\nMethods:\n- ServeHTTP: (w http.ResponseWriter, r *http.Request) -> None - Handles HTTP requests by upgrading them to WebSocket connections, establishing a Guacamole tunnel, and managing bidirectional communication between the client and RDP server. This method implements the http.Handler interface.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"yunion.io/x/log\"\n\t\"yunion.io/x/pkg/errors\"\n\n\t\"yunion.io/x/onecloud/pkg/webconsole/guac\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/options\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/session\"\n)\n\ntype RDPServer struct {\n\tSession *session.SSession\n\n\tHost         string\n\tPort         int\n\tUsername     string\n\tPassword     string\n\tConnectionId string\n\n\tWidth  int\n\tHeight int\n\tDpi    int\n}\n\nfunc (s *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar up = websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tws, err := up.Upgrade(w, r, http.Header{\"Sec-Websocket-Protocol\": []string{\n\t\tr.Header.Get(\"Sec-Websocket-Protocol\"),\n\t}})\n\tif err != nil {\n\t\tlog.Errorf(\"upgrade error: %v\", err)\n\t\treturn\n\t}\n\n\tdefer ws.Close()\n\n\ttunnel, err := guac.NewGuacamoleTunnel(\n\t\ts.Host,\n\t\ts.Port,\n\t\ts.Username,\n\t\ts.Password,\n\t\ts.ConnectionId,\n\t\ts.Width,\n\t\ts.Height,\n\t\ts.Dpi,\n\t\ts.Session.GetClientSession().GetUserId(),\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"NewGuacamoleTunnel error: %v\", err)\n\t\treturn\n\t}\n\n\terr = tunnel.Start()\n\tif err != nil {\n\t\tlog.Errorf(\"Start error: %v\", err)\n\t\treturn\n\t}\n\n\tdone := make(chan bool, 4)\n\ttimer := time.NewTimer(time.Microsecond * 100)\n\tsetDone := func() {\n\t\tdone <- true\n\t}\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tins, err := tunnel.ReadOne()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\terr = ws.WriteMessage(websocket.TextMessage, []byte(ins.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd %s: %v\", ins.String(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\t\tdefer tunnel.Stop()\n\n\t\tfor {\n\t\t\t_, p, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Errorf(\"read message error %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\t_, err = tunnel.Write(p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tstop := make(chan bool)\n\tgo func() {\n\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t}\n\t\tdefer timer.Stop()\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tcase <-timer.C:\n\t\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttimer.Reset(time.Microsecond * 100)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\terr = tunnel.Wait()\n\t\tif err != nil && errors.Cause(err) != guac.TunnerClose {\n\t\t\tlog.Errorf(\"wait error: %v\", err)\n\t\t}\n\t}()\n\n\t<-done\n\tstop <- true\n\tlog.Infof(\"rdp %s@%s:%d complete\", s.Username, s.Host, s.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/guacamole-client/guacamole-common-go\"\n\t\"github.com/guacamole-client/guacamole-common-go/protocol\"\n\t\"github.com/guacamole-client/guacamole-common-go/tunnel\"\n\t\"github.com/guacamole-client/guacamole-common-go/websocket\"\n\t\"session\"\n)\n\ntype RDPServer struct {\n\tSession      *session.SSession\n\tHost         string\n\tPort         int\n\tUsername     string\n\tPassword     string\n\tConnectionId string\n\tWidth        int\n\tHeight       int\n\tDpi          int\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc (server *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Could not open websocket connection\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tconfig := protocol.NewConfiguration()\n\tconfig.SetParameter(\"hostname\", server.Host)\n\tconfig.SetParameter(\"port\", string(server.Port))\n\tconfig.SetParameter(\"username\", server.Username)\n\tconfig.SetParameter(\"password\", server.Password)\n\tconfig.SetParameter(\"width\", string(server.Width))\n\tconfig.SetParameter(\"height\", string(server.Height))\n\tconfig.SetParameter(\"dpi\", string(server.Dpi))\n\n\tguacTunnel := tunnel.NewSimpleTunnel(func() (guacamole.GuacamoleSocket, error) {\n\t\treturn guacamole.NewGuacamoleSocket(server.ConnectionId, config)\n\t})\n\n\twsTunnel := websocket.NewWebSocketTunnel(guacTunnel)\n\twsTunnel.HandleConnection(conn)\n}\n\nfunc main() {\n\trdpServer := &RDPServer{\n\t\tHost:     \"rdp.example.com\",\n\t\tPort:     3389,\n\t\tUsername: \"user\",\n\t\tPassword: \"pass\",\n\t\tWidth:    1024,\n\t\tHeight:   768,\n\t\tDpi:      96,\n\t}\n\n\thttp.Handle(\"/rdp\", rdpServer)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Implement a WebSocket server function in Go that handles client connections, manages online users, and periodically sends server statistics to connected clients.\n\nFunction Description: The `serverStream` function establishes a WebSocket connection with a client, registers the user in an online user tracking system, and continuously sends server statistics at regular intervals. It handles connection upgrades, user authentication, and graceful connection closure.\n\nInput:\n- `c *gin.Context`: Gin framework context object containing HTTP request information and writer for response\n\nOutput:\n- `any`: Placeholder return value (always nil in this implementation)\n- `error`: Error object indicating connection termination reason (wrapped in custom WsError type)\n\nThe function performs the following operations:\n1. Generates a unique connection ID\n2. Upgrades HTTP connection to WebSocket\n3. Extracts user IP and authentication info\n4. Registers user in online tracking system\n5. Periodically sends server statistics\n6. Handles connection cleanup on exit",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/url\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/nezhahq/nezha/model\"\n\t\"github.com/nezhahq/nezha/service/singleton\"\n)\n\nvar upgrader *websocket.Upgrader\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnId, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\tdefer conn.Close()\n\n\tuserIp := c.GetString(model.CtxKeyRealIPStr)\n\tif userIp == \"\" {\n\t\tuserIp = c.RemoteIP()\n\t}\n\n\tu, isMember := c.Get(model.CtxKeyAuthorizedUser)\n\tvar userId uint64\n\tif isMember {\n\t\tuserId = u.(*model.User).ID\n\t}\n\n\tsingleton.AddOnlineUser(connId, &model.OnlineUser{\n\t\tUserID:      userId,\n\t\tIP:          userIp,\n\t\tConnectedAt: time.Now(),\n\t\tConn:        conn,\n\t})\n\tdefer singleton.RemoveOnlineUser(connId)\n\n\tcount := 0\n\tfor {\n\t\tstat, err := getServerStat(count == 0, isMember)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.WriteMessage(websocket.TextMessage, stat); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tcount += 1\n\t\tif count%4 == 0 {\n\t\t\terr = conn.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\treturn nil, newWsError(\"\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/google/uuid\"\n)\n\ntype WsError struct {\n\tMessage string\n}\n\nfunc (e *WsError) Error() string {\n\treturn e.Message\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype User struct {\n\tID   string\n\tIP   string\n\tAuth string\n}\n\nvar onlineUsers = make(map[string]*User)\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnID := uuid.New().String()\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, &WsError{Message: \"Failed to upgrade connection\"}\n\t}\n\tdefer conn.Close()\n\n\tuserIP := c.ClientIP()\n\tauthInfo := c.GetHeader(\"Authorization\")\n\n\tuser := &User{\n\t\tID:   connID,\n\t\tIP:   userIP,\n\t\tAuth: authInfo,\n\t}\n\tonlineUsers[connID] = user\n\n\tticker := time.NewTicker(10 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tstats := getServerStats()\n\t\t\tif err := conn.WriteJSON(stats); err != nil {\n\t\t\t\tdelete(onlineUsers, connID)\n\t\t\t\treturn nil, &WsError{Message: \"Failed to send server stats\"}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc getServerStats() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"onlineUsers\": len(onlineUsers),\n\t\t\"timestamp\":   time.Now().Unix(),\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ws\", func(c *gin.Context) {\n\t\tserverStream(c)\n\t})\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Create a WebSocket handler function that establishes an SSH connection through a WebSocket interface, allowing for terminal-like interaction with a remote host.\n\nFunction Description: The function `ConnectSshPmExec` handles WebSocket connections to facilitate SSH terminal sessions. It upgrades an HTTP connection to WebSocket, validates host credentials, establishes an SSH connection, and manages bidirectional communication between the WebSocket client and SSH server. The function includes error handling and resource cleanup.\n\nInput:\n- `c` (gin.Context) - Gin framework context for HTTP request handling\n- `username` (string) - Username for authentication (unused in current implementation)\n- `envName` (string) - Environment name (unused in current implementation)\n- `productName` (string) - Product name (unused in current implementation)\n- `ip` (string) - IP address of the target host\n- `hostId` (string) - Identifier for the host's private key\n- `cols` (int) - Terminal column size\n- `rows` (int) - Terminal row size\n- `log` (*zap.SugaredLogger) - Logger for error reporting\n\nOutput:\n- `error` - Returns nil on success, or an error object if any step fails",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ssh\"\n\n\tcommonrepo \"github.com/koderover/zadig/v2/pkg/microservice/aslan/core/common/repository/mongodb\"\n\t\"github.com/koderover/zadig/v2/pkg/setting\"\n\te \"github.com/koderover/zadig/v2/pkg/tool/errors\"\n\ttoolssh \"github.com/koderover/zadig/v2/pkg/tool/ssh\"\n\t\"github.com/koderover/zadig/v2/pkg/tool/wsconn\"\n\t\"github.com/koderover/zadig/v2/pkg/util\"\n)\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\nfunc ConnectSshPmExec(c *gin.Context, username, envName, productName, ip, hostId string, cols, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"ws upgrade err:%s\", err)\n\t\treturn e.ErrLoginPm.AddErr(err)\n\t}\n\n\tdefer ws.Close()\n\tresp, err := commonrepo.NewPrivateKeyColl().Find(commonrepo.FindPrivateKeyOption{\n\t\tID: hostId,\n\t})\n\tif err != nil {\n\t\tlog.Errorf(\"PrivateKey.Find ip %s id %s error: %s\", ip, hostId, err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrGetPrivateKey.Error()))\n\t\treturn e.ErrGetPrivateKey\n\n\t}\n\tif resp.Status != setting.PMHostStatusNormal {\n\t\tlog.Errorf(\"host %s status %s, is not normal\", ip, resp.Status)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s status %s,is not normal\", ip, resp.Status))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.ScheduleWorkflow {\n\t\tlog.Errorf(\"host %s is not enable login\", ip)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s is not enable ssh\", ip))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.Port == 0 {\n\t\tresp.Port = setting.PMHostDefaultPort\n\t}\n\n\tsDec, err := base64.StdEncoding.DecodeString(resp.PrivateKey)\n\tif err != nil {\n\t\tlog.Errorf(\"base64 decode failed ip:%s, error:%s\", ip, err)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"base64 decode failed ip:%s, error:%s\", ip, err))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\n\tsshCli, err := toolssh.NewSshCli(sDec, resp.UserName, resp.IP, resp.Port)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshCli err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshCli.Close()\n\n\tsshConn, err := wsconn.NewSshConn(cols, rows, sshCli)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshConn err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshConn.Close()\n\n\tstopChan := make(chan bool, 3)\n\tgo sshConn.ReadWsMessage(ws, stopChan)\n\tgo sshConn.SendWsWriteMessage(ws, stopChan)\n\tgo sshConn.SessionWait(stopChan)\n\n\t<-stopChan\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"go.uber.org/zap\"\n\t\"net/http\"\n\t\"os\"\n\t\"io\"\n\t\"time\"\n)\n\nfunc ConnectSshPmExec(c *gin.Context, username, envName, productName, ip, hostId string, cols, rows int, log *zap.SugaredLogger) error {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to upgrade connection\", \"error\", err)\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tprivateKey, err := getPrivateKey(hostId)\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to get private key\", \"error\", err)\n\t\treturn err\n\t}\n\n\tsshConfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(privateKey),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t\tTimeout:         5 * time.Second,\n\t}\n\n\tclient, err := ssh.Dial(\"tcp\", ip+\":22\", sshConfig)\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to dial SSH\", \"error\", err)\n\t\treturn err\n\t}\n\tdefer client.Close()\n\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to create SSH session\", \"error\", err)\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tmodes := ssh.TerminalModes{\n\t\tssh.ECHO:          1,\n\t\tssh.TTY_OP_ISPEED: 14400,\n\t\tssh.TTY_OP_OSPEED: 14400,\n\t}\n\n\tif err := session.RequestPty(\"xterm\", rows, cols, modes); err != nil {\n\t\tlog.Errorw(\"Failed to request PTY\", \"error\", err)\n\t\treturn err\n\t}\n\n\tstdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to get stdin pipe\", \"error\", err)\n\t\treturn err\n\t}\n\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to get stdout pipe\", \"error\", err)\n\t\treturn err\n\t}\n\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tio.Copy(stdin, conn.UnderlyingConn())\n\t}()\n\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tio.Copy(conn.UnderlyingConn(), stdout)\n\t}()\n\n\tif err := session.Shell(); err != nil {\n\t\tlog.Errorw(\"Failed to start shell\", \"error\", err)\n\t\treturn err\n\t}\n\n\tif err := session.Wait(); err != nil {\n\t\tlog.Errorw(\"Session wait error\", \"error\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc getPrivateKey(hostId string) (ssh.Signer, error) {\n\tkeyPath := \"/path/to/private/keys/\" + hostId\n\tkey, err := os.ReadFile(keyPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsigner, err := ssh.ParsePrivateKey(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signer, nil\n}\n```"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Implement a Go struct that tests the health of an NTP (Network Time Protocol) server by checking its stratum level through UDP communication.\n\nStruct Description: The NtpHealthTester struct is responsible for verifying the health of an NTP server by establishing a UDP connection, sending a query, and validating the server's response based on its stratum level. The struct includes methods for testing the server and providing a string representation of the maximum allowed stratum.\n\nFields:\nmaxStratum: int - The maximum acceptable stratum level for the NTP server to be considered healthy.\n\nMethods:\nTest: (ht *HealthTest) -> bool - Tests the health of an NTP server by sending a UDP packet and validating the response. Returns true if the server's stratum is within the acceptable range, false otherwise.\nString: () -> string - Returns a string representation of the maximum allowed stratum level.\nnewNtpHealthTester: (params map[string]interface{}, htp *HealthTestParameters) -> HealthTester - A constructor function that creates a new NtpHealthTester instance with the specified maximum stratum level.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (t *NtpHealthTester) Test(ht *HealthTest) bool {\n\tudpAddress, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(ht.ipAddress.String(), \"123\"))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdata := make([]byte, 48)\n\tdata[0] = 4<<3 | 3\n\n\tconn, err := net.DialUDP(\"udp\", nil, udpAddress)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(ht.timeout))\n\n\t_, err = conn.Read(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := data[1]\n\n\tif stratum == 0 || stratum > byte(t.maxStratum) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (t *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"%d\", t.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := 3\n\tif v, ok := params[\"max_stratum\"]; ok {\n\t\tmaxStratum = typeutil.ToInt(v)\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (ht *NtpHealthTester) Test(server string) bool {\n\tconn, err := net.Dial(\"udp\", server+\":123\")\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer conn.Close()\n\n\trequest := make([]byte, 48)\n\trequest[0] = 0x1B\n\n\t_, err = conn.Write(request)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(5 * time.Second))\n\tresponse := make([]byte, 48)\n\t_, err = conn.Read(response)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := int(response[1])\n\treturn stratum > 0 && stratum <= ht.maxStratum\n}\n\nfunc (ht *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"Max Stratum: %d\", ht.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}) *NtpHealthTester {\n\tmaxStratum, ok := params[\"maxStratum\"].(int)\n\tif !ok {\n\t\tmaxStratum = 15\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}\n\nfunc main() {\n\tparams := map[string]interface{}{\"maxStratum\": 3}\n\tntpTester := newNtpHealthTester(params)\n\tserver := \"pool.ntp.org\"\n\n\tif ntpTester.Test(server) {\n\t\tfmt.Println(\"NTP server is healthy.\")\n\t} else {\n\t\tfmt.Println(\"NTP server is not healthy.\")\n\t}\n\n\tfmt.Println(ntpTester.String())\n}\n```"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Implement a UDP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and connection management.\n\nStruct Description: The Client struct represents a UDP client for communicating with KDC servers. It maintains configuration and provides methods for sending data over UDP.\n\nFields:\n\nConfig: [*Config] - Configuration object containing KDC server information and settings\n\nMethods:\n\nsendKDCUDP: [func(realm string, b []byte) -> ([]byte, error)] - Sends data to a KDC server over UDP for a specific realm. Returns the response or error.\ndialKDCUDP: [func(count int, kdcs map[int]string) -> (*net.UDPConn, error)] - Internal method to establish UDP connection to a KDC server from a list of addresses. Returns the connection or error.\nsendUDP: [func(conn *net.UDPConn, b []byte) -> ([]byte, error)] - Internal method to send data over an established UDP connection and read the response. Returns the response data or error.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\tcount, kdcs, err := cl.Config.GetKDCs(realm, false)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tconn, err := dialKDCUDP(count, kdcs)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = cl.sendUDP(conn, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialKDCUDP(count int, kdcs map[int]string) (conn *net.UDPConn, err error) {\n\ti := 1\n\tfor i <= count {\n\t\tudpAddr, e := net.ResolveUDPAddr(\"udp\", kdcs[i])\n\t\tif e != nil {\n\t\t\terr = fmt.Errorf(\"error resolving KDC address: %v\", e)\n\t\t\treturn\n\t\t}\n\t\tconn, err = net.DialUDP(\"udp\", nil, udpAddr)\n\t\tif err == nil {\n\t\t\terr = conn.SetDeadline(time.Now().Add(5 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti++\n\t}\n\terr = errors.New(\"error in getting a UDP connection to any of the KDCs\")\n\treturn\n}\n\nfunc (cl *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\tvar r []byte\n\tdefer conn.Close()\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\tudpbuf := make([]byte, 4096)\n\tn, _, err := conn.ReadFrom(udpbuf)\n\tr = udpbuf[:n]\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"sending over UDP failed to %s: %v\", conn.RemoteAddr().String(), err)\n\t}\n\tif len(r) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from %s\", conn.RemoteAddr().String())\n\t}\n\treturn r, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "type Config struct {\n\tKDCServers map[string][]string\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tkdcs, ok := c.Config.KDCServers[realm]\n\tif !ok || len(kdcs) == 0 {\n\t\treturn nil, fmt.Errorf(\"no KDC servers found for realm: %s\", realm)\n\t}\n\n\tfor i, kdc := range kdcs {\n\t\tconn, err := c.dialKDCUDP(i, kdcs)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tresponse, err := c.sendUDP(conn, b)\n\t\tif err == nil {\n\t\t\treturn response, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"failed to communicate with any KDC server for realm: %s\", realm)\n}\n\nfunc (c *Client) dialKDCUDP(count int, kdcs []string) (*net.UDPConn, error) {\n\taddr, err := net.ResolveUDPAddr(\"udp\", kdcs[count])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve UDP address: %v\", err)\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dial UDP: %v\", err)\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send data: %v\", err)\n\t}\n\n\tbuffer := make([]byte, 4096)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response: %v\", err)\n\t}\n\n\treturn buffer[:n], nil\n}"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Write a Go function that tests UDP communication between a client and server. The function should create a UDP server, establish a client connection, send a test message, and verify the server's response.\n\nFunction Description: The function `TestUDPTransport` tests UDP transport functionality by creating a UDP server, sending a message from a client to the server, and verifying that the server receives the correct message. It uses goroutines for asynchronous server handling and channels for communication between the server and test function.\n\nInput: \n- `t *testing.T`: A testing context provided by the Go testing framework for assertions and logging.\n\nOutput: \n- None (This is a test function, so it reports failures via the testing framework rather than returning values). \n\nNote: The function relies on an external `NewTUDPServerTransport` function (not shown in the reference) to create the server transport and a `serveOnce` helper function (also not shown) to handle the server-side receive operation.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\nfunc TestUDPTransport(t *testing.T) {\n\tserver, err := NewTUDPServerTransport(\"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer server.Close()\n\n\tassert.NoError(t, server.Open())\n\tassert.True(t, server.IsOpen())\n\tassert.NotNil(t, server.Conn())\n\n\tc := make(chan []byte)\n\tdefer close(c)\n\n\tgo serveOnce(t, server, c)\n\n\tdestAddr, err := net.ResolveUDPAddr(\"udp\", server.Addr().String())\n\trequire.NoError(t, err)\n\n\tconnUDP, err := net.DialUDP(destAddr.Network(), nil, destAddr)\n\trequire.NoError(t, err)\n\tdefer connUDP.Close()\n\n\tn, err := connUDP.Write([]byte(\"test\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, 4, n)\n\n\tselect {\n\tcase data := <-c:\n\t\tassert.Equal(t, \"test\", string(data))\n\tcase <-time.After(time.Second * 1):\n\t\tt.Error(\"Server did not respond in time\")\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "func TestUDPTransport(t *testing.T) {\n    serverAddr := \"localhost:0\"\n    message := []byte(\"test message\")\n    done := make(chan struct{})\n\n    // Start UDP server\n    go func() {\n        conn, err := net.ListenPacket(\"udp\", serverAddr)\n        if err != nil {\n            t.Fatalf(\"Failed to start UDP server: %v\", err)\n        }\n        defer conn.Close()\n\n        buf := make([]byte, 1024)\n        n, addr, err := conn.ReadFrom(buf)\n        if err != nil {\n            t.Fatalf(\"Failed to read from UDP server: %v\", err)\n        }\n\n        if string(buf[:n]) != string(message) {\n            t.Fatalf(\"Received message does not match: got %s, want %s\", buf[:n], message)\n        }\n\n        _, err = conn.WriteTo([]byte(\"ack\"), addr)\n        if err != nil {\n            t.Fatalf(\"Failed to write to UDP server: %v\", err)\n        }\n\n        close(done)\n    }()\n\n    // Get server address\n    conn, err := net.Dial(\"udp\", serverAddr)\n    if err != nil {\n        t.Fatalf(\"Failed to dial UDP server: %v\", err)\n    }\n    defer conn.Close()\n\n    // Send message\n    _, err = conn.Write(message)\n    if err != nil {\n        t.Fatalf(\"Failed to write to UDP server: %v\", err)\n    }\n\n    // Wait for server response\n    buf := make([]byte, 1024)\n    n, err := conn.Read(buf)\n    if err != nil {\n        t.Fatalf(\"Failed to read from UDP server: %v\", err)\n    }\n\n    if string(buf[:n]) != \"ack\" {\n        t.Fatalf(\"Received response does not match: got %s, want %s\", buf[:n], \"ack\")\n    }\n\n    <-done\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a function that establishes UDP connections between two remote endpoints, optionally encrypts the initial handshake packets, and forwards traffic between them.\n\nFunction Description: The function `remote2remoteUDP` creates two UDP connections to specified remote endpoints, handles optional encryption of initialization packets, and sets up bidirectional forwarding between the connections. It uses custom networking and crypto utilities for connection management and encryption.\n\nInput:\n- remoteA: string - First remote endpoint address in \"host:port\" format\n- remoteB: string - Second remote endpoint address in \"host:port\" format\n- raenc: bool - Flag to enable encryption for first remote endpoint\n- rbenc: bool - Flag to enable encryption for second remote endpoint\n\nOutput: None (The function runs indefinitely forwarding traffic or returns on error)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"iox/netio\"\n\t\"iox/crypto\"\n)\n\nfunc remote2remoteUDP(remoteA string, remoteB string, raenc bool, rbenc bool) {\n\tremoteAddrA, err := net.ResolveUDPAddr(\"udp\", remoteA)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnA, err := net.DialUDP(\"udp\", nil, remoteAddrA)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnA.Close()\n\n\tremoteAddrB, err := net.ResolveUDPAddr(\"udp\", remoteB)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnB, err := net.DialUDP(\"udp\", nil, remoteAddrB)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnB.Close()\n\n\tremoteCtxA, err := netio.NewUDPCtx(remoteConnA, raenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteCtxB, err := netio.NewUDPCtx(remoteConnB, rbenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif raenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxA.Write(b)\n\t} else {\n\t\tremoteCtxA.Write(netio.UDP_INIT_PACKET)\n\t}\n\tif rbenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxB.Write(b)\n\t} else {\n\t\tremoteCtxB.Write(netio.UDP_INIT_PACKET)\n\t}\n\n\tnetio.ForwardUDP(remoteCtxA, remoteCtxB)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc encrypt(data []byte, key []byte) ([]byte, error) {\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tciphertext := make([]byte, aes.BlockSize+len(data))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn nil, err\n\t}\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], data)\n\treturn ciphertext, nil\n}\n\nfunc decrypt(data []byte, key []byte) ([]byte, error) {\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(data) < aes.BlockSize {\n\t\treturn nil, fmt.Errorf(\"ciphertext too short\")\n\t}\n\tiv := data[:aes.BlockSize]\n\tdata = data[aes.BlockSize:]\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\tstream.XORKeyStream(data, data)\n\treturn data, nil\n}\n\nfunc forwardTraffic(src, dst *net.UDPConn, encryptFlag bool, key []byte) {\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, addr, err := src.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading from UDP: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdata := buf[:n]\n\t\tif encryptFlag {\n\t\t\tdata, err = encrypt(data, key)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error encrypting data: %v\\n\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t_, err = dst.WriteToUDP(data, addr)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error writing to UDP: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc remote2remoteUDP(remoteA, remoteB string, raenc, rbenc bool) {\n\tconnA, err := net.Dial(\"udp\", remoteA)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error connecting to remoteA: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer connA.Close()\n\n\tconnB, err := net.Dial(\"udp\", remoteB)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error connecting to remoteB: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer connB.Close()\n\n\tkey := []byte(\"examplekey123456\") // Example key, should be securely generated and shared\n\n\tgo forwardTraffic(connA.(*net.UDPConn), connB.(*net.UDPConn), raenc, key)\n\tgo forwardTraffic(connB.(*net.UDPConn), connA.(*net.UDPConn), rbenc, key)\n\n\tselect {} // Run indefinitely\n}\n\nfunc main() {\n\tremote2remoteUDP(\"localhost:12345\", \"localhost:54321\", true, false)\n}\n```"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that serves a health check endpoint and starts listening on a specified host and port.\n\nFunction Description: The function `startHTTPServer` initializes and starts an HTTP server with a single `/healthz` endpoint that returns a 200 OK status and \"ok\" response. The server listens on the IP address and port specified by the input parameters.\n\nInput: \n- `argHealthzIP` (string pointer): The IP address on which the server should listen.\n- `argHealthzPort` (int pointer): The port number on which the server should listen.\n\nOutput: \n- None (the function runs indefinitely or until an error occurs, in which case it logs the error and exits).",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc startHTTPServer() {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"ok\"))\n\t})\n\n\tklog.Info(\"Starting eventer http service\")\n\tklog.Fatal(http.ListenAndServe(net.JoinHostPort(*argHealthzIP, strconv.Itoa(int(*argHealthzPort))), nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc startHTTPServer(argHealthzIP *string, argHealthzPort *int) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"ok\"))\n\t})\n\n\taddress := fmt.Sprintf(\"%s:%d\", *argHealthzIP, *argHealthzPort)\n\tserver := &http.Server{Addr: address}\n\n\tlog.Printf(\"Starting server on %s\", address)\n\tif err := server.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}\n\nfunc main() {\n\tip := \"127.0.0.1\"\n\tport := 8080\n\tstartHTTPServer(&ip, &port)\n}\n```"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Implement a UDP server in Go that listens for incoming packets, manages client sessions, and proxies the traffic to a remote destination using a provided proxy dialer.\n\nStruct Description: The UDP struct represents a UDP server that handles incoming connections, manages sessions, and proxies traffic. It maintains session state and coordinates communication between clients and the proxy server.\n\nFields:\n- addr: string - The local address to listen on\n- uaddr: *net.UDPAddr - The resolved UDP address\n- dialer: proxy.Dialer - The dialer used to establish connections\n- proxy: proxy.Proxy - The proxy implementation for forwarding traffic\n\nMethods:\n- NewUDP: (s string, d proxy.Dialer, p proxy.Proxy) -> (*UDP, error) - Creates a new UDP instance by parsing the URL and resolving the address\n- ListenAndServe: () -> () - Starts listening on the UDP port and handles incoming packets\n- serveSession: (session *session) -> () - Handles an individual client session and proxies its traffic\n- DialUDP: (network string, addr string) -> (net.PacketConn, error) - Creates a new packet connection for outbound traffic\n\nAdditional Structs:\n- session: Represents a client session with its communication channels\n  Fields:\n    - key: string - Session identifier\n    - src: *net.UDPAddr - Client address\n    - PacketConn: net.PacketConn - Underlying connection\n    - msgCh: chan []byte - Channel for incoming messages\n    - finCh: chan struct{} - Channel for session termination\n\n- PktConn: Wraps a net.PacketConn with a predefined destination address\n  Fields:\n    - PacketConn: net.PacketConn - Underlying connection\n    - uaddr: *net.UDPAddr - Destination address\n  Methods:\n    - WriteTo: (b []byte, addr net.Addr) -> (int, error) - Writes data to the predefined address",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\nvar nm sync.Map\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu, err := url.Parse(s)\n\tif err != nil {\n\t\tlog.F(\"[udp] parse url err: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tt := &UDP{\n\t\tdialer: d,\n\t\tproxy:  p,\n\t\taddr:   u.Host,\n\t}\n\n\tt.uaddr, err = net.ResolveUDPAddr(\"udp\", t.addr)\n\treturn t, err\n}\n\nfunc (s *UDP) ListenAndServe() {\n\tc, err := net.ListenPacket(\"udp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[udp] failed to listen on UDP %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\n\tlog.F(\"[udp] listening UDP on %s\", s.addr)\n\n\tfor {\n\t\tbuf := pool.GetBuffer(proxy.UDPBufSize)\n\t\tn, srcAddr, err := c.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.F(\"[udp] read error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar sess *session\n\t\tsessKey := srcAddr.String()\n\n\t\tv, ok := nm.Load(sessKey)\n\t\tif !ok || v == nil {\n\t\t\tsess = newSession(sessKey, srcAddr, c)\n\t\t\tnm.Store(sessKey, sess)\n\t\t\tgo s.serveSession(sess)\n\t\t} else {\n\t\t\tsess = v.(*session)\n\t\t}\n\n\t\tsess.msgCh <- buf[:n]\n\t}\n}\n\nfunc (s *UDP) serveSession(session *session) {\n\tdstPC, dialer, err := s.proxy.DialUDP(\"udp\", session.src.String())\n\tif err != nil {\n\t\tlog.F(\"[udp] remote dial error: %v\", err)\n\t\tnm.Delete(session.key)\n\t\treturn\n\t}\n\tdefer dstPC.Close()\n\n\tgo func() {\n\t\tproxy.CopyUDP(session, session.src, dstPC, 2*time.Minute, 5*time.Second)\n\t\tnm.Delete(session.key)\n\t\tclose(session.finCh)\n\t}()\n\n\tlog.F(\"[udp] %s <-> %s\", session.src, dialer.Addr())\n\n\tfor {\n\t\tselect {\n\t\tcase p := <-session.msgCh:\n\t\t\t_, err = dstPC.WriteTo(p, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.F(\"[udp] writeTo error: %v\", err)\n\t\t\t}\n\t\t\tpool.PutBuffer(p)\n\t\tcase <-session.finCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype session struct {\n\tkey string\n\tsrc *net.UDPAddr\n\tnet.PacketConn\n\tmsgCh chan []byte\n\tfinCh chan struct{}\n}\n\nfunc newSession(key string, src net.Addr, srcPC net.PacketConn) *session {\n\tsrcAddr, _ := net.ResolveUDPAddr(\"udp\", src.String())\n\treturn &session{key, srcAddr, srcPC, make(chan []byte, 32), make(chan struct{})}\n}\n\nfunc (s *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\tpc, err := s.dialer.DialUDP(network, s.addr)\n\treturn &PktConn{pc, s.uaddr}, err\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (pc *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn pc.PacketConn.WriteTo(b, pc.uaddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 111,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"time\"\n\t\"sync\"\n\t\"errors\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\ntype session struct {\n\tkey        string\n\tsrc        *net.UDPAddr\n\tPacketConn net.PacketConn\n\tmsgCh      chan []byte\n\tfinCh      chan struct{}\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (p *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn p.PacketConn.WriteTo(b, p.uaddr)\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UDP{addr: s, uaddr: uaddr, dialer: d, proxy: p}, nil\n}\n\nfunc (u *UDP) ListenAndServe() error {\n\tconn, err := net.ListenUDP(\"udp\", u.uaddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tsessions := make(map[string]*session)\n\tvar mu sync.Mutex\n\n\tfor {\n\t\tbuf := make([]byte, 4096)\n\t\tn, src, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tkey := src.String()\n\t\tmu.Lock()\n\t\tsess, exists := sessions[key]\n\t\tif !exists {\n\t\t\tsess = &session{\n\t\t\t\tkey:        key,\n\t\t\t\tsrc:        src,\n\t\t\t\tmsgCh:      make(chan []byte, 10),\n\t\t\t\tfinCh:      make(chan struct{}),\n\t\t\t}\n\t\t\tsessions[key] = sess\n\t\t\tgo u.serveSession(sess)\n\t\t}\n\t\tmu.Unlock()\n\n\t\tselect {\n\t\tcase sess.msgCh <- buf[:n]:\n\t\tcase <-sess.finCh:\n\t\t\tmu.Lock()\n\t\t\tdelete(sessions, key)\n\t\t\tmu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (u *UDP) serveSession(sess *session) {\n\tdefer close(sess.finCh)\n\n\tconn, err := u.DialUDP(\"udp\", sess.src.String())\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tsess.PacketConn = conn\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-sess.msgCh:\n\t\t\t_, err := conn.WriteTo(msg, sess.src)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-time.After(30 * time.Second):\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (u *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\tconn, err := u.dialer.Dial(network, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpktConn, ok := conn.(net.PacketConn)\n\tif !ok {\n\t\treturn nil, errors.New(\"failed to assert PacketConn\")\n\t}\n\treturn &PktConn{PacketConn: pktConn, uaddr: u.uaddr}, nil\n}\n\nfunc main() {\n\t// Example usage\n\tdialer, _ := proxy.Direct, nil\n\tproxy := proxy.Proxy(nil) // Replace with actual proxy implementation\n\tudpServer, err := NewUDP(\":8080\", dialer, proxy)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = udpServer.ListenAndServe()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a UDP server in Go that handles incoming UDP packets, processes them, and manages connections using a cache system for tracking active connections. The server should support multiple ports with different encryption keys and handle both connection establishment and data packet processing.\n\nStruct Description: The Server struct represents a UDP server instance with TCP and UDP capabilities, including connection caching and encryption support for multiple ports.\n\nFields:\n\nTCPAddr: *net.TCPAddr - TCP address information for the server\nUDPAddr: *net.UDPAddr - UDP address information for the server\nTCPListen: *net.TCPListener - TCP listener instance\nUDPConn: *net.UDPConn - UDP connection instance\nCache: *cache.Cache - Cache for storing active connections\nCkv: *crypto.KV - Default encryption key-value pair\nPortCkv: map[int64]*crypto.KV - Map of port numbers to their respective encryption key-value pairs\n\nMethods:\n\nNewServer: (addr string, password string, portPassword []string) -> (*Server, error) - Creates a new Server instance with the given address, default password, and port-specific passwords\nRunUDPServer: () -> error - Starts the UDP server and begins listening for incoming packets\nUDPHandle: (addr *net.UDPAddr, b []byte) -> error - Handles incoming UDP packets, either establishing new connections or forwarding data to existing connections",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/crypto\"\n)\n\ntype Server struct {\n\tTCPAddr   *net.TCPAddr\n\tUDPAddr   *net.UDPAddr\n\tTCPListen *net.TCPListener\n\tUDPConn   *net.UDPConn\n\tCache     *cache.Cache\n\tCkv       *crypto.KV\n\tPortCkv   map[int64]*crypto.KV\n}\n\nfunc NewServer(addr, password string, portPassword []string) (*Server, error) {\n\tpc := make(map[int64]*crypto.KV)\n\tfor _, v := range portPassword {\n\t\tl := strings.Split(v, \" \")\n\t\tif len(l) != 2 {\n\t\t\treturn nil, errors.New(\"Wrong format: \" + v)\n\t\t}\n\t\tport, err := strconv.ParseInt(l[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tckv := &crypto.KV{\n\t\t\tAESKey: []byte(l[1]),\n\t\t}\n\t\tpc[port] = ckv\n\t}\n\ttaddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tTCPAddr: taddr,\n\t\tUDPAddr: uaddr,\n\t\tCache:   cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tCkv: &crypto.KV{\n\t\t\tAESKey: []byte(password),\n\t\t},\n\t\tPortCkv: pc,\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tvar err error\n\ts.UDPConn, err = net.ListenUDP(\"udp\", s.UDPAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\tn, addr, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func(addr *net.UDPAddr, b []byte) {\n\t\t\tif err := s.UDPHandle(addr, b); err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t}(addr, b[0:n])\n\t}\n\treturn nil\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\tp := &UDPPacket{}\n\tif err := proto.Unmarshal(b, p); err != nil {\n\t\treturn nil\n\t}\n\tif p.Address == \"\" {\n\t\tu, err := NewUDPServer(s, p, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.Cache.Set(\"u:\"+strconv.FormatInt(p.Port, 10), u, cache.DefaultExpiration)\n\t\tdefer s.Cache.Delete(\"u:\" + strconv.FormatInt(p.Port, 10))\n\t\tif err := u.ListenAndServe(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\ti, ok := s.Cache.Get(\"u:\" + strconv.FormatInt(p.Port, 10))\n\tif !ok {\n\t\treturn nil\n\t}\n\tc := i.(*UDPServer)\n\tif err := c.HandlePacket(p); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/patrickmn/go-cache\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n)\n\ntype Server struct {\n\tTCPAddr   *net.TCPAddr\n\tUDPAddr   *net.UDPAddr\n\tTCPListen *net.TCPListener\n\tUDPConn   *net.UDPConn\n\tCache     *cache.Cache\n\tCkv       *crypto.KV\n\tPortCkv   map[int64]*crypto.KV\n}\n\ntype cryptoKV struct {\n\tKey []byte\n\tNonce []byte\n}\n\nfunc NewServer(addr string, password string, portPassword []string) (*Server, error) {\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttcpListen, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefaultKey, err := chacha20poly1305.NewX([]byte(password))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportCkv := make(map[int64]*crypto.KV)\n\tfor _, pp := range portPassword {\n\t\tparts := strings.Split(pp, \":\")\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid port password format\")\n\t\t}\n\t\tport := parts[0]\n\t\tkey, err := chacha20poly1305.NewX([]byte(parts[1]))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tportCkv[int64(port)] = &cryptoKV{Key: key}\n\t}\n\treturn &Server{\n\t\tTCPAddr:   tcpAddr,\n\t\tUDPAddr:   udpAddr,\n\t\tTCPListen: tcpListen,\n\t\tUDPConn:   udpConn,\n\t\tCache:     cache.New(5*time.Minute, 10*time.Minute),\n\t\tCkv:       &cryptoKV{Key: defaultKey},\n\t\tPortCkv:   portCkv,\n\t}, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, addr, err := s.UDPConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo s.UDPHandle(addr, buf[:n])\n\t}\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\tport := addr.Port\n\tkv, exists := s.PortCkv[int64(port)]\n\tif !exists {\n\t\tkv = s.Ckv\n\t}\n\t// Process packet with encryption key\n\t// Example: decrypt, process, and respond\n\t// This is a placeholder for actual packet processing logic\n\tfmt.Printf(\"Received packet from %s: %x\\n\", addr.String(), b)\n\treturn nil\n}\n\nfunc main() {\n\tserver, err := NewServer(\"localhost:8080\", \"defaultpassword\", []string{\"8081:portpassword1\", \"8082:portpassword2\"})\n\tif err != nil {\n\t\tfmt.Println(\"Error creating server:\", err)\n\t\treturn\n\t}\n\terr = server.RunUDPServer()\n\tif err != nil {\n\t\tfmt.Println(\"Error running UDP server:\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Implement a UDP server in Go that handles incoming UDP packets, performs authentication checks, and manages communication with clients through specified ports. The server should include functionality for initialization, packet handling, listening for incoming data, and graceful shutdown.\n\nStruct Description: The UDPServer struct represents a UDP server instance that manages UDP connections, handles authentication, and processes incoming/outgoing packets. It maintains connection state and integrates with a parent Server instance.\n\nFields:\n\nServer: [*Server] - Reference to the parent Server instance containing shared resources\nUDPConn: [*net.UDPConn] - Active UDP connection for the server\nAddr: [*net.UDPAddr] - Address information for the server's UDP endpoint\n\nMethods:\n\nNewUDPServer: [func(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error)] -> [*UDPServer, error] - Initializes a new UDP server instance with authentication checks and port validation. Returns the server instance or error if initialization fails.\n\nListenAndServe: [func(s *UDPServer) error] -> [error] - Starts listening for incoming UDP packets and handles them in a loop until an error occurs or the server is shut down. Automatically closes the connection when finished.\n\nShutdown: [func(s *UDPServer)] -> [void] - Gracefully shuts down the UDP server by closing the active connection.\n\nHandlePacket: [func(s *UDPServer, p *UDPPacket) error] -> [error] - Processes an incoming UDP packet, either forwarding data to the specified address or updating the connection deadline. Returns error if processing fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tbye := func(err error) {\n\t\tp := &UDPPacket{\n\t\t\tAddress: err.Error(),\n\t\t}\n\t\tb, err1 := proto.Marshal(p)\n\t\tif err1 != nil {\n\t\t\tlog.Println(err1)\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\tif p.Port == 0 {\n\t\tbye(errors.New(\"Missed port\"))\n\t\treturn nil, errors.New(addr.String() + \" missed port\")\n\t}\n\tif len(s.PortCkv) == 0 {\n\t\ttmp, err := s.Ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tif len(s.PortCkv) != 0 {\n\t\tckv, ok := s.PortCkv[p.Port]\n\t\tif !ok {\n\t\t\tbye(errors.New(\"Not allowed port\"))\n\t\t\treturn nil, errors.New(addr.String() + \" try to open not allowed UDP port: \" + strconv.FormatInt(p.Port, 10))\n\t\t}\n\t\ttmp, err := ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.FormatInt(p.Port, 10))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc1, err := net.ListenUDP(\"udp\", uaddr)\n\tif err != nil {\n\t\tbye(err)\n\t\treturn nil, err\n\t}\n\tif err := c1.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tp = &UDPPacket{\n\t\tAddress: \"0\",\n\t}\n\tb, err := proto.Marshal(p)\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{\n\t\tServer:  s,\n\t\tUDPConn: c1,\n\t\tAddr:    addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\ti, a, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tp := &UDPPacket{\n\t\t\tAddress: a.String(),\n\t\t\tData:    b[0:i],\n\t\t}\n\t\tb, err = proto.Marshal(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.Server.UDPConn.WriteToUDP(b, s.Addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.UDPConn.Close()\n}\n\nfunc (s *UDPServer) HandlePacket(p *UDPPacket) error {\n\tif p.Address != \"0\" {\n\t\tuaddr, err := net.ResolveUDPAddr(\"udp\", p.Address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(p.Data, uaddr); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := s.UDPConn.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\t// Shared resources and configurations\n}\n\ntype UDPPacket struct {\n\tData []byte\n\tAddr *net.UDPAddr\n}\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n\tmu      sync.Mutex\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tif s == nil || p == nil || addr == nil {\n\t\treturn nil, errors.New(\"invalid parameters\")\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &UDPServer{\n\t\tServer:  s,\n\t\tUDPConn: conn,\n\t\tAddr:    addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, addr, err := s.UDPConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpacket := &UDPPacket{\n\t\t\tData: buf[:n],\n\t\t\tAddr: addr,\n\t\t}\n\n\t\tif err := s.HandlePacket(packet); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.UDPConn != nil {\n\t\ts.UDPConn.Close()\n\t\ts.UDPConn = nil\n\t}\n}\n\nfunc (s *UDPServer) HandlePacket(p *UDPPacket) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.UDPConn == nil {\n\t\treturn errors.New(\"connection is closed\")\n\t}\n\n\t// Example processing: echo back the data\n\t_, err := s.UDPConn.WriteToUDP(p.Data, p.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update connection deadline\n\terr = s.UDPConn.SetDeadline(time.Now().Add(30 * time.Second))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage\n\tserver := &Server{}\n\taddr, _ := net.ResolveUDPAddr(\"udp\", \":8080\")\n\tudpServer, err := NewUDPServer(server, &UDPPacket{}, addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\tif err := udpServer.ListenAndServe(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Simulate shutdown after some time\n\ttime.Sleep(10 * time.Second)\n\tudpServer.Shutdown()\n}\n```"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: The provided code demonstrates a WebSocket client implementation in Go for tracker communication in a peer-to-peer network, handling WebSocket connections, message exchange, and WebRTC offer/answer negotiation.\n\nStruct Description: TrackerClient represents a client for interacting with a WebSocket tracker server, managing WebSocket connections, peer connections, and message handling.\n\nFields:\n\nUrl: string - The WebSocket tracker server URL to connect to\nGetAnnounceRequest: func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error) - Function to generate announce requests\nPeerId: [20]byte - The client's peer identifier\nOnConn: onDataChannelOpen - Callback for when data channels open\nLogger: log.Logger - Logger for client operations\nDialer: *websocket.Dialer - WebSocket dialer configuration\nmu: sync.Mutex - Mutex for thread-safe operations\ncond: sync.Cond - Condition variable for connection state changes\noutboundOffers: map[string]outboundOfferValue - Track outbound WebRTC offers\nwsConn: *websocket.Conn - Active WebSocket connection\nclosed: bool - Connection closed flag\npingTicker: *time.Ticker - Timer for sending ping messages\nWebsocketTrackerHttpHeader: func() http.Header - Function to generate WebSocket headers\nICEServers: []webrtc.ICEServer - List of ICE servers for WebRTC\nrtcPeerConns: map[string]*wrappedPeerConnection - Active WebRTC peer connections\n\nMethods:\n\ndoWebsocket: () -> error - Establishes and maintains WebSocket connection to tracker\ntrackerReadLoop: (*websocket.Conn) -> error - Handles incoming WebSocket messages\nwriteMessage: ([]byte) -> error - Writes message to WebSocket connection\nhandleOffer: (offerContext, string) -> error - Processes incoming WebRTC offers\nhandleAnswer: (string, webrtc.SessionDescription) -> void - Processes incoming WebRTC answers",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/anacrolix/log\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v4\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype TrackerClient struct {\n\tUrl                string\n\tGetAnnounceRequest func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId             [20]byte\n\tOnConn             onDataChannelOpen\n\tLogger             log.Logger\n\tDialer             *websocket.Dialer\n\n\tmu             sync.Mutex\n\tcond           sync.Cond\n\toutboundOffers map[string]outboundOfferValue\n\twsConn         *websocket.Conn\n\tclosed         bool\n\tpingTicker     *time.Ticker\n\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers                 []webrtc.ICEServer\n\n\trtcPeerConns map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\ttc.mu.Unlock()\n\n\tvar header http.Header\n\tif tc.WebsocketTrackerHttpHeader != nil {\n\t\theader = tc.WebsocketTrackerHttpHeader()\n\t}\n\n\tc, _, err := tc.Dialer.Dial(tc.Url, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing tracker: %w\", err)\n\t}\n\tdefer c.Close()\n\ttc.Logger.WithDefaultLevel(log.Info).Printf(\"connected\")\n\ttc.mu.Lock()\n\ttc.wsConn = c\n\ttc.cond.Broadcast()\n\ttc.mu.Unlock()\n\tcloseChan := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tc.pingTicker.C:\n\t\t\t\ttc.mu.Lock()\n\t\t\t\terr := c.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\ttc.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-closeChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\terr = tc.trackerReadLoop(tc.wsConn)\n\tclose(closeChan)\n\ttc.mu.Lock()\n\tc.Close()\n\ttc.mu.Unlock()\n\treturn err\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(tracker *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := tracker.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read message error: %w\", err)\n\t\t}\n\t\ttc.Logger.Levelf(log.Debug, \"received message: %q\", message)\n\n\t\tvar ar AnnounceResponse\n\t\tif err := json.Unmarshal(message, &ar); err != nil {\n\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error unmarshalling announce response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase ar.Offer != nil:\n\t\t\tih, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error decoding info_hash in offer: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = tc.handleOffer(offerContext{\n\t\t\t\tSessDesc: *ar.Offer,\n\t\t\t\tId:       ar.OfferID,\n\t\t\t\tInfoHash: ih,\n\t\t\t}, ar.PeerID)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Error, \"handling offer for infohash %x: %v\", ih, err)\n\t\t\t}\n\t\tcase ar.Answer != nil:\n\t\t\ttc.handleAnswer(ar.OfferID, *ar.Answer)\n\t\tdefault:\n\t\t\t_, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Warning, \"unexpected announce response %q\", message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(data []byte) error {\n\tfor tc.wsConn == nil {\n\t\tif tc.closed {\n\t\t\treturn fmt.Errorf(\"%T closed\", tc)\n\t\t}\n\t\ttc.cond.Wait()\n\t}\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, data)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v3\"\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype TrackerClient struct {\n\tUrl                      string\n\tGetAnnounceRequest       func(tracker.AnnounceEvent, [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId                   [20]byte\n\tOnConn                   onDataChannelOpen\n\tLogger                   *logrus.Logger\n\tDialer                   *websocket.Dialer\n\tmu                       sync.Mutex\n\tcond                     *sync.Cond\n\toutboundOffers           map[string]outboundOfferValue\n\twsConn                   *websocket.Conn\n\tclosed                   bool\n\tpingTicker               *time.Ticker\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers               []webrtc.ICEServer\n\trtcPeerConns             map[string]*wrappedPeerConnection\n}\n\ntype outboundOfferValue struct {\n\t// Define fields for outbound offer value\n}\n\ntype wrappedPeerConnection struct {\n\t// Define fields for wrapped peer connection\n}\n\ntype onDataChannelOpen func(*webrtc.DataChannel)\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\tdefer tc.mu.Unlock()\n\n\theaders := tc.WebsocketTrackerHttpHeader()\n\tconn, _, err := tc.Dialer.Dial(tc.Url, headers)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttc.wsConn = conn\n\ttc.cond.Broadcast()\n\n\ttc.pingTicker = time.NewTicker(30 * time.Second)\n\tgo func() {\n\t\tfor range tc.pingTicker.C {\n\t\t\ttc.writeMessage([]byte(\"ping\"))\n\t\t}\n\t}()\n\n\treturn tc.trackerReadLoop(conn)\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(conn *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttc.handleMessage(message)\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(message []byte) error {\n\ttc.mu.Lock()\n\tdefer tc.mu.Unlock()\n\n\tif tc.closed {\n\t\treturn errors.New(\"connection closed\")\n\t}\n\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, message)\n}\n\nfunc (tc *TrackerClient) handleMessage(message []byte) {\n\t// Handle incoming WebSocket messages\n}\n\nfunc (tc *TrackerClient) handleOffer(ctx offerContext, offer string) error {\n\t// Process incoming WebRTC offers\n\treturn nil\n}\n\nfunc (tc *TrackerClient) handleAnswer(peerID string, answer webrtc.SessionDescription) {\n\t// Process incoming WebRTC answers\n}\n\nfunc main() {\n\t// Example usage of TrackerClient\n}"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Go function that establishes a WebSocket connection to a specified URL, sends a protobuf message as a JSON payload, and returns the WebSocket connection for further communication.\n\nFunction Description: The function `openWebSocket` establishes a secure WebSocket connection (wss://) to a given URL with optional custom headers. It authenticates using admin macaroon if no custom headers are provided, sends a protobuf message as JSON, and returns the active WebSocket connection. The caller is responsible for closing the connection.\n\nInput:\n- `node` [*node.HarnessNode] - Node configuration containing REST address and authentication details\n- `url` [string] - The endpoint path for the WebSocket connection\n- `method` [string] - The method parameter to include in the query string\n- `req` [proto.Message] - The protobuf message to send as initial payload\n- `customHeader` [http.Header] - Optional custom HTTP headers for the request\n\nOutput:\n- [*websocket.Conn] - Established WebSocket connection for bidirectional communication\n- [error] - Error if any step in the connection process fails",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lntest/node\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar (\n\twebSocketDialer = &websocket.Dialer{\n\t\tHandshakeTimeout: time.Second,\n\t\tTLSClientConfig:  insecureTransport.TLSClientConfig,\n\t}\n\tcloseMsg = websocket.FormatCloseMessage(\n\t\twebsocket.CloseNormalClosure, \"done\",\n\t)\n)\n\nfunc openWebSocket(node *node.HarnessNode, url, method string,\n\treq proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\n\theader := customHeader\n\tif header == nil {\n\t\theader = make(http.Header)\n\t\tif err := addAdminMacaroon(node, header); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfullURL := fmt.Sprintf(\n\t\t\"wss://%s%s?method=%s\", node.Cfg.RESTAddr(), url, method,\n\t)\n\tconn, resp, err := webSocketDialer.Dial(fullURL, header)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\treqMsg, err := lnrpc.RESTJsonMarshalOpts.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = conn.WriteMessage(websocket.TextMessage, reqMsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 117,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype HarnessNode struct {\n\tRestAddress string\n\tMacaroon    string\n}\n\nfunc openWebSocket(node *HarnessNode, endpoint, method string, req proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\t// Construct the full URL for the WebSocket connection\n\tu := url.URL{\n\t\tScheme:   \"wss\",\n\t\tHost:     node.RestAddress,\n\t\tPath:     endpoint,\n\t\tRawQuery: fmt.Sprintf(\"method=%s\", method),\n\t}\n\n\t// Prepare the headers\n\theaders := http.Header{}\n\tif customHeader != nil {\n\t\theaders = customHeader\n\t} else {\n\t\theaders.Set(\"Grpc-Metadata-macaroon\", node.Macaroon)\n\t}\n\n\t// Serialize the protobuf message to JSON\n\treqData, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal protobuf message: %v\", err)\n\t}\n\n\t// Establish the WebSocket connection\n\tdialer := websocket.DefaultDialer\n\tconn, _, err := dialer.Dial(u.String(), headers)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to WebSocket: %v\", err)\n\t}\n\n\t// Send the JSON payload\n\terr = conn.WriteMessage(websocket.TextMessage, reqData)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, fmt.Errorf(\"failed to send message: %v\", err)\n\t}\n\n\treturn conn, nil\n}\n\nfunc main() {\n\t// Example usage\n\tnode := &HarnessNode{\n\t\tRestAddress: \"example.com:443\",\n\t\tMacaroon:    \"your-macaroon\",\n\t}\n\n\t// Replace with your actual protobuf message\n\tvar req proto.Message\n\n\tconn, err := openWebSocket(node, \"/ws-endpoint\", \"exampleMethod\", req, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Use the connection...\n}\n```"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that can establish secure connections, handle protocol negotiation, and manage message transmission between client and server. The solution should support TLS configuration, proxy settings, and proper connection cleanup.\n\nStruct Description: The RoundTripper struct implements http.RoundTripper interface to handle WebSocket connections with additional capabilities for Kubernetes API server communication. It manages WebSocket connections with TLS support and proxy configuration.\n\nFields:\n- TLSConfig: *tls.Config - Configuration for TLS/SSL connections\n- Proxier: func(req *http.Request) (*url.URL, error) - Function to determine proxy for requests\n- Conn: *gwebsocket.Conn - Active WebSocket connection\n\nMethods:\n- Connection: () -> *gwebsocket.Conn - Returns the active WebSocket connection\n- DataBufferSize: () -> int - Returns the buffer size for data transmission (32KB by default)\n- TLSClientConfig: () -> *tls.Config - Returns the TLS configuration\n- RoundTrip: (*http.Request) -> (*http.Response, error) - Main method that establishes WebSocket connection, handles protocol negotiation, and returns the HTTP response\n\nAdditional Function:\n- RoundTripperFor: (*restclient.Config) -> (http.RoundTripper, ConnectionHolder, error) - Factory function that creates a configured RoundTripper instance with proper TLS and proxy settings from Kubernetes client configuration",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tgwebsocket \"github.com/gorilla/websocket\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream/wsstream\"\n\tutilnet \"k8s.io/apimachinery/pkg/util/net\"\n\trestclient \"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/transport\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *gwebsocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *gwebsocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(request *http.Request) (retResp *http.Response, retErr error) {\n\tdefer func() {\n\t\tif request.Body != nil {\n\t\t\terr := request.Body.Close()\n\t\t\tif retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}\n\t}()\n\n\tprotocolVersions := request.Header[wsstream.WebSocketProtocolHeader]\n\tdelete(request.Header, wsstream.WebSocketProtocolHeader)\n\n\tdialer := gwebsocket.Dialer{\n\t\tProxy:           rt.Proxier,\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tSubprotocols:    protocolVersions,\n\t\tReadBufferSize:  rt.DataBufferSize() + 1024,\n\t\tWriteBufferSize: rt.DataBufferSize() + 1024,\n\t}\n\tswitch request.URL.Scheme {\n\tcase \"https\":\n\t\trequest.URL.Scheme = \"wss\"\n\tcase \"http\":\n\t\trequest.URL.Scheme = \"ws\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown url scheme: %s\", request.URL.Scheme)\n\t}\n\twsConn, resp, err := dialer.DialContext(request.Context(), request.URL.String(), request.Header)\n\tif err != nil {\n\t\tif errors.Is(err, gwebsocket.ErrBadHandshake) {\n\t\t\tcause := err\n\t\t\tif resp != nil && len(resp.Status) > 0 {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tcause = fmt.Errorf(\"%w (%s)\", err, resp.Status)\n\t\t\t\tresponseErrorBytes, readErr := io.ReadAll(io.LimitReader(resp.Body, 64*1024))\n\t\t\t\tif readErr != nil {\n\t\t\t\t\tcause = fmt.Errorf(\"%w: unable to read error from server response\", cause)\n\t\t\t\t} else {\n\t\t\t\t\tresponseError := strings.TrimSpace(string(responseErrorBytes))\n\t\t\t\t\tif len(responseError) > 0 {\n\t\t\t\t\t\tif obj, _, decodeErr := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); decodeErr == nil {\n\t\t\t\t\t\t\tif status, ok := obj.(*metav1.Status); ok {\n\t\t\t\t\t\t\t\tcause = &apierrors.StatusError{ErrStatus: *status}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcause = fmt.Errorf(\"%w: %s\", cause, responseError)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, &httpstream.UpgradeFailureError{Cause: cause}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tfoundProtocol := false\n\tfor _, protocolVersion := range protocolVersions {\n\t\tif protocolVersion == wsConn.Subprotocol() {\n\t\t\tfoundProtocol = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !foundProtocol {\n\t\twsConn.Close()\n\t\treturn nil, &httpstream.UpgradeFailureError{Cause: fmt.Errorf(\"invalid protocol, expected one of %q, got %q\", protocolVersions, wsConn.Subprotocol())}\n\t}\n\n\trt.Conn = wsConn\n\n\treturn resp, nil\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttransportCfg, err := config.TransportConfig()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttlsConfig, err := transport.TLSConfigFor(transportCfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxy := config.Proxy\n\tif proxy == nil {\n\t\tproxy = utilnet.NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)\n\t}\n\n\tupgradeRoundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxy,\n\t}\n\twrapper, err := transport.HTTPWrappersForConfig(transportCfg, upgradeRoundTripper)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn wrapper, upgradeRoundTripper, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "```go\npackage websocket\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"github.com/gorilla/websocket\"\n\t\"k8s.io/client-go/rest\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *websocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *websocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024 // 32KB\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tproxyURL, err := rt.Proxier(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdialer := websocket.Dialer{\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tProxy:           http.ProxyURL(proxyURL),\n\t}\n\n\tconn, _, err := dialer.Dial(req.URL.String(), req.Header)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trt.Conn = conn\n\n\t// Handle protocol negotiation and message transmission here\n\n\t// Return a dummy response for compatibility\n\treturn &http.Response{\n\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\tHeader:     make(http.Header),\n\t}, nil\n}\n\ntype ConnectionHolder interface {\n\tConnection() *websocket.Conn\n}\n\nfunc RoundTripperFor(config *rest.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttlsConfig, err := rest.TLSConfigFor(config)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tproxier := func(req *http.Request) (*url.URL, error) {\n\t\treturn http.ProxyFromEnvironment(req)\n\t}\n\n\trt := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxier,\n\t}\n\n\treturn rt, rt, nil\n}\n```"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a WebSocket client connection wrapper in Go that provides a simplified interface for reading and writing binary messages over a WebSocket connection, with proper error handling and connection management.\n\nStruct Description: The Conn struct wraps a WebSocket connection and provides io.Reader/io.Writer compatible methods for binary message communication, along with standard net.Conn interface methods.\n\nFields:\nwsConn: *websocket.Conn - The underlying WebSocket connection\nreader: io.Reader - Current message reader for streaming message content\n\nMethods:\nNew: (wsConn *websocket.Conn) -> *Conn - Creates a new Conn wrapper instance\nDial: (ctx context.Context, url string, opts ...DialOption) -> (*Conn, error) - Establishes a new WebSocket connection with optional configuration\nRead: (b []byte) -> (int, error) - Reads binary data from the WebSocket connection (implements io.Reader)\nWrite: (b []byte) -> (int, error) - Writes binary data to the WebSocket connection (implements io.Writer)\nClose: () -> error - Closes the WebSocket connection\nLocalAddr: () -> net.Addr - Returns local network address\nRemoteAddr: () -> net.Addr - Returns remote network address\nSetDeadline: (t time.Time) -> error - Sets both read and write deadlines\nSetReadDeadline: (t time.Time) -> error - Sets read deadline\nSetWriteDeadline: (t time.Time) -> error - Sets write deadline",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: nil,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\toptions := dialOptions{}\n\tfor _, o := range opts {\n\t\to.apply(&options)\n\t}\n\n\tdialer := &websocket.Dialer{\n\t\tHandshakeTimeout: 60 * time.Second,\n\t}\n\n\tif options.tlsConfig != nil {\n\t\tdialer.TLSClientConfig = options.tlsConfig\n\t}\n\n\theader := make(http.Header)\n\tif options.token != \"\" {\n\t\theader.Set(\"Authorization\", \"Bearer \"+options.token)\n\t}\n\n\twsConn, resp, err := dialer.DialContext(\n\t\tctx, url, header,\n\t)\n\tif err == nil {\n\t\treturn New(wsConn), nil\n\t}\n\tif resp == nil {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\tdefer resp.Body.Close()\n\n\terr = fmt.Errorf(\"%d: %w\", resp.StatusCode, err)\n\tif _, ok := retryableStatusCodes[resp.StatusCode]; ok {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\treturn nil, err\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tfor {\n\t\tif c.reader == nil {\n\t\t\tmt, r, err := c.wsConn.NextReader()\n\t\t\tif err != nil {\n\t\t\t\tvar closeErr *websocket.CloseError\n\t\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\t\treturn 0, net.ErrClosed\n\t\t\t\t}\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif mt != websocket.BinaryMessage {\n\t\t\t\treturn 0, fmt.Errorf(\"unexpected message type: %d\", mt)\n\t\t\t}\n\t\t\tc.reader = r\n\t\t}\n\n\t\tn, err := c.reader.Read(b)\n\t\tif n > 0 {\n\t\t\tif err != nil {\n\t\t\t\tc.reader = nil\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err\n\t\t}\n\t\tif err != io.EOF {\n\t\t\tvar closeErr *websocket.CloseError\n\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\treturn 0, net.ErrClosed\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc.reader = nil\n\t}\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tif err := c.wsConn.WriteMessage(websocket.BinaryMessage, b); err != nil {\n\t\tvar closeErr *websocket.CloseError\n\t\tif errors.As(err, &closeErr) {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package websocketwrapper\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{wsConn: wsConn}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\tdialer := websocket.DefaultDialer\n\tfor _, opt := range opts {\n\t\topt(dialer)\n\t}\n\twsConn, _, err := dialer.DialContext(ctx, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn New(wsConn), nil\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tif c.reader == nil {\n\t\t_, r, err := c.wsConn.NextReader()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tc.reader = r\n\t}\n\tn, err := c.reader.Read(b)\n\tif err == io.EOF {\n\t\tc.reader = nil\n\t}\n\treturn n, err\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tw, err := c.wsConn.NextWriter(websocket.BinaryMessage)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn, err := w.Write(b)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\terr = w.Close()\n\treturn n, err\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.wsConn.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.wsConn.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}\n\ntype DialOption func(*websocket.Dialer)\n\nfunc WithDialerTimeout(timeout time.Duration) DialOption {\n\treturn func(d *websocket.Dialer) {\n\t\td.HandshakeTimeout = timeout\n\t}\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Implement a WebSocket server handler for a DERP (Distributed Encrypted Relay for Packets) server using the nhooyr.io/websocket library in Go. The handler should upgrade HTTP connections to WebSocket, enforce protocol requirements, and establish the connection for DERP communication.\n\nStruct Description: The DERPServer struct represents a DERP server instance that handles WebSocket connections for relaying encrypted packets between Tailscale nodes.\n\nFields:\nkey: [key.NodePrivate] - The private key used for node authentication\ntailscaleDERP: [*derp.Server] - The underlying DERP server instance that manages relay connections\n\nMethods:\nserveWebsocket: [Name](writer http.ResponseWriter, req *http.Request) -> [void] - Handles incoming HTTP requests by upgrading them to WebSocket connections. Validates the subprotocol, creates a network connection wrapper around the WebSocket, and passes it to the DERP server for handling.\n\nInput:\n- writer: [http.ResponseWriter] - The HTTP response writer\n- req: [*http.Request] - The incoming HTTP request\n\nOutput:\n- None (handles connection directly, may write error responses to writer)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/coder/websocket\"\n\t\"tailscale.com/derp\"\n\t\"tailscale.com/net/wsconn\"\n)\n\ntype DERPServer struct {\n\tkey           key.NodePrivate\n\ttailscaleDERP *derp.Server\n}\n\nfunc (d *DERPServer) serveWebsocket(writer http.ResponseWriter, req *http.Request) {\n\twebsocketConn, err := websocket.Accept(writer, req, &websocket.AcceptOptions{\n\t\tSubprotocols:   []string{\"derp\"},\n\t\tOriginPatterns: []string{\"*\"},\n\t\tCompressionMode: websocket.CompressionDisabled,\n\t})\n\tif err != nil {\n\t\twriter.Header().Set(\"Content-Type\", \"text/plain\")\n\t\twriter.WriteHeader(http.StatusInternalServerError)\n\t\t_, err = writer.Write([]byte(\"Failed to upgrade websocket request\"))\n\t\treturn\n\t}\n\tdefer websocketConn.Close(websocket.StatusInternalError, \"closing\")\n\tif websocketConn.Subprotocol() != \"derp\" {\n\t\twebsocketConn.Close(websocket.StatusPolicyViolation, \"client must speak the derp subprotocol\")\n\t\treturn\n\t}\n\n\twc := wsconn.NetConn(req.Context(), websocketConn, websocket.MessageBinary, req.RemoteAddr)\n\tbrw := bufio.NewReadWriter(bufio.NewReader(wc), bufio.NewWriter(wc))\n\td.tailscaleDERP.Accept(req.Context(), wc, brw, req.RemoteAddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"nhooyr.io/websocket\"\n\t\"tailscale.com/derp\"\n\t\"tailscale.com/types/key\"\n)\n\ntype DERPServer struct {\n\tkey          key.NodePrivate\n\ttailscaleDERP *derp.Server\n}\n\nfunc (ds *DERPServer) serveWebsocket(writer http.ResponseWriter, req *http.Request) {\n\tc, err := websocket.Accept(writer, req, &websocket.AcceptOptions{\n\t\tSubprotocols: []string{\"derp\"},\n\t})\n\tif err != nil {\n\t\thttp.Error(writer, \"Failed to upgrade to WebSocket\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer c.Close(websocket.StatusInternalError, \"Internal error\")\n\n\tif c.Subprotocol() != \"derp\" {\n\t\tc.Close(websocket.StatusPolicyViolation, \"Invalid subprotocol\")\n\t\treturn\n\t}\n\n\tconn := websocket.NetConn(context.Background(), c, websocket.MessageBinary)\n\tdefer conn.Close()\n\n\terr = ds.tailscaleDERP.Accept(conn)\n\tif err != nil {\n\t\tc.Close(websocket.StatusInternalError, \"Failed to handle DERP connection\")\n\t\treturn\n\t}\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n}\n```"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: The task involves creating a WebSocket handler in Go that upgrades HTTP connections to WebSocket connections, manages the connection lifecycle, and handles message exchange between client and server.\n\nStruct Description: The WsHandler struct is responsible for managing WebSocket connections, including upgrading HTTP connections, handling incoming messages, and managing connection state.\n\nFields:\n- svcCtx: *svc.ServiceContext - A reference to the service context containing dependencies and configuration\n\nMethods:\n- Upgrade: (ginCtx *gin.Context) -> void - Upgrades an HTTP connection to a WebSocket connection and manages the connection lifecycle\n  Input: ginCtx *gin.Context - The Gin context containing HTTP request and response objects\n  Output: None (handles connection directly)\n\n- onReceive: (ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) -> (pb.ResponseCode, error) - Handles incoming WebSocket messages\n  Input: \n    - ctx context.Context - Context for the operation\n    - connection *gatewayservicelogic.Connection - The WebSocket connection object\n    - typ websocket.MessageType - Type of the WebSocket message\n    - msg []byte - The message content\n  Output:\n    - pb.ResponseCode - Response code indicating processing result\n    - error - Any error that occurred during processing",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tgatewayservicelogic \"github.com/cherish-chat/xxim-server/app/gateway/internal/logic/gatewayservice\"\n\t\"github.com/cherish-chat/xxim-server/common/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/zeromicro/go-zero/core/logx\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"io\"\n\t\"math\"\n\t\"nhooyr.io/websocket\"\n\t\"strings\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tr := ginCtx.Request\n\tw := ginCtx.Writer\n\tlogger := logx.WithContext(r.Context())\n\theaders := make(map[string]string)\n\tfor k, v := range r.Header {\n\t\tif len(v) > 0 {\n\t\t\theaders[k] = v[0]\n\t\t}\n\t}\n\theader := &pb.RequestHeader{\n\t\tClientIp: utils.Http.GetClientIP(r),\n\t}\n\tcompressionMode := websocket.CompressionNoContextTakeover\n\tif strings.Contains(r.UserAgent(), \"Safari\") {\n\t\tcompressionMode = websocket.CompressionDisabled\n\t}\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tSubprotocols:         nil,\n\t\tInsecureSkipVerify:   true,\n\t\tOriginPatterns:       nil,\n\t\tCompressionMode:      compressionMode,\n\t\tCompressionThreshold: 0,\n\t})\n\tif err != nil {\n\t\tif r.URL.Path == \"/\" {\n\t\t\treturn\n\t\t}\n\t\tlogger.Errorf(\"failed to accept websocket connection: %v\", err)\n\t\treturn\n\t}\n\tc.SetReadLimit(math.MaxInt32)\n\tbeforeConnectResp, err := h.svcCtx.CallbackService.UserBeforeConnect(r.Context(), &pb.UserBeforeConnectReq{Header: header})\n\tif err != nil {\n\t\tlogger.Errorf(\"beforeConnect error: %v\", err)\n\t\tc.Close(websocket.StatusCode(pb.WebsocketCustomCloseCode_CloseCodeServerInternalError), err.Error())\n\t\treturn\n\t}\n\tif !beforeConnectResp.Success {\n\t\tc.Close(websocket.StatusCode(beforeConnectResp.CloseCode), beforeConnectResp.CloseReason)\n\t\treturn\n\t}\n\n\theader.UserId = beforeConnectResp.UserId\n\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\tctx, cancelFunc := context.WithCancel(r.Context())\n\tconnection := gatewayservicelogic.NewWebsocketConnect(ctx, header, c)\n\tdefer func() {\n\t\tgatewayservicelogic.ConnectionLogic.OnDisconnect(connection)\n\t}()\n\tgo func() {\n\t\tdefer cancelFunc()\n\t\tfor {\n\t\t\tlogger.Debugf(\"start read\")\n\t\t\ttyp, msg, err := c.Read(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t} else if websocket.CloseStatus(err) == websocket.StatusNormalClosure ||\n\t\t\t\t\twebsocket.CloseStatus(err) == websocket.StatusGoingAway {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"connection reset by peer\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"corrupt input\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlogx.Errorf(\"failed to read message: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\t_, _ = h.onReceive(ctx, connection, typ, msg)\n\t\t\t}()\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\tvar aesKey []byte\n\tvar aesIv []byte\n\tvar isEncrypt bool\n\n\tconnection.PublicKeyLock.RLock()\n\t{\n\t\tif len(connection.SharedSecret) == 0 {\n\t\t\tisEncrypt = false\n\t\t} else {\n\t\t\tisEncrypt = true\n\t\t\taesKey = connection.SharedSecret[:]\n\t\t\taesIv = connection.SharedSecret[8:24]\n\t\t}\n\t}\n\tconnection.PublicKeyLock.RUnlock()\n\n\tif isEncrypt {\n\t\tvar err error\n\t\tmsg, err = utils.Aes.Decrypt(aesKey, aesIv, msg)\n\t\tif err != nil {\n\t\t\tlogx.Errorf(\"decrypt message error: %v\", err)\n\t\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t\t}\n\t}\n\n\tapiRequest := &pb.GatewayApiRequest{}\n\terr := proto.Unmarshal(msg, apiRequest)\n\tif err != nil {\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t}\n\tapiRequest.Header = connection.GetHeader()\n\troute, ok := universalRouteMap[apiRequest.Path]\n\ttracer := otel.Tracer(common.TraceName)\n\tpropagator := otel.GetTextMapPropagator()\n\tspanName := apiRequest.Path\n\tcarrier := propagation.MapCarrier{\n\t\t\"appId\":       apiRequest.Header.AppId,\n\t\t\"userId\":      apiRequest.Header.UserId,\n\t\t\"clientIp\":    apiRequest.Header.ClientIp,\n\t\t\"installId\":   apiRequest.Header.InstallId,\n\t\t\"platform\":    apiRequest.Header.Platform.String(),\n\t\t\"deviceModel\": apiRequest.Header.DeviceModel,\n\t\t\"osVersion\":   apiRequest.Header.OsVersion,\n\t\t\"appVersion\":  apiRequest.Header.AppVersion,\n\t\t\"connectTime\": connection.ConnectedTime.Format(\"2006-01-02 15:04:05\"),\n\t\t\"extra\":       apiRequest.Header.Extra,\n\t}\n\tspanCtx := propagator.Extract(ctx, carrier)\n\tspanCtx, span := tracer.Start(spanCtx, spanName,\n\t\toteltrace.WithSpanKind(oteltrace.SpanKindServer),\n\t)\n\tdefer span.End()\n\tpropagator.Inject(spanCtx, carrier)\n\tif !ok {\n\t\tlogx.Errorf(\"path 404 not found: %s\", apiRequest.Path)\n\t\tspan.SetStatus(codes.Error, \"path\"+apiRequest.Path+\"404 not found\")\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", \"path 404 not found\")\n\t}\n\tcode, responseBody, err := route(spanCtx, connection, apiRequest)\n\tif len(responseBody) > 0 {\n\t\terr := connection.SendMessage(ctx, responseBody)\n\t\tif err != nil {\n\t\t\tlogx.Infof(\"failed to write message: %v\", err)\n\t\t}\n\t}\n\tspan.SetAttributes(attribute.Int(\"responseBody.length\", len(responseBody)))\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, err.Error())\n\t} else {\n\t\tspan.SetStatus(codes.Ok, \"\")\n\t}\n\treturn code, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "```go\npackage ws\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"your_project_path/pb\"\n\t\"your_project_path/svc\"\n\t\"your_project_path/gatewayservicelogic\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc NewWsHandler(svcCtx *svc.ServiceContext) *WsHandler {\n\treturn &WsHandler{svcCtx: svcCtx}\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tconn, err := upgrader.Upgrade(ginCtx.Writer, ginCtx.Request, nil)\n\tif err != nil {\n\t\tginCtx.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to upgrade connection\"})\n\t\treturn\n\t}\n\n\tconnection := gatewayservicelogic.NewConnection(conn)\n\tdefer connection.Close()\n\n\tfor {\n\t\ttyp, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\t_, err = h.onReceive(ginCtx, connection, typ, msg)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\t// Implement your message handling logic here\n\t// For example, you might want to parse the message and perform some action based on its content\n\n\t// Return a response code and error if any\n\treturn pb.ResponseCode_SUCCESS, nil\n}\n```"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawnUserNamespaceCat creates a child process in a new user namespace to read a specified file. It establishes two pipes (one for standard output and one for standard error) to communicate between the parent and child processes. The function handles process creation, data transfer through pipes, process waiting, and error handling.\n\nInput:\n- nsPath (string): Path to the user namespace to spawn the process in\n- path (string): Path to the file that should be read by the child process\n\nOutput:\n- ([]byte, error): Returns the file contents as a byte slice if successful, or an error if any step fails. The error contains detailed information about the failure.\n\nNote: The function relies on an external C function spawn_userns_cat which handles the actual process creation in the new namespace. The function manages proper resource cleanup through defer statements and handles both successful and error cases with appropriate return values.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/sirupsen/logrus\"\n)\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\n/*\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <string.h>\n\nint spawn_userns_cat(const char *nsPath, const char *filePath, int outFd, int errFd) {\n    pid_t pid = fork();\n    if (pid < 0) {\n        return -1; // Fork failed\n    }\n    if (pid == 0) {\n        // Child process\n        int nsFd = open(nsPath, O_RDONLY);\n        if (nsFd < 0) {\n            dprintf(errFd, \"Failed to open namespace: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        if (setns(nsFd, CLONE_NEWUSER) < 0) {\n            dprintf(errFd, \"Failed to set namespace: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        close(nsFd);\n\n        int fileFd = open(filePath, O_RDONLY);\n        if (fileFd < 0) {\n            dprintf(errFd, \"Failed to open file: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n\n        if (dup2(fileFd, STDIN_FILENO) < 0) {\n            dprintf(errFd, \"Failed to duplicate file descriptor: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        close(fileFd);\n\n        if (dup2(outFd, STDOUT_FILENO) < 0 || dup2(errFd, STDERR_FILENO) < 0) {\n            dprintf(errFd, \"Failed to duplicate output descriptors: %s\\n\", strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n\n        execlp(\"cat\", \"cat\", NULL);\n        dprintf(errFd, \"Failed to exec cat: %s\\n\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n    return pid;\n}\n*/\nimport \"C\"\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc spawnUserNamespaceCat(nsPath, path string) ([]byte, error) {\n\toutR, outW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stdout pipe: %w\", err)\n\t}\n\tdefer outR.Close()\n\tdefer outW.Close()\n\n\terrR, errW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stderr pipe: %w\", err)\n\t}\n\tdefer errR.Close()\n\tdefer errW.Close()\n\n\tpid := C.spawn_userns_cat(C.CString(nsPath), C.CString(path), C.int(outW.Fd()), C.int(errW.Fd()))\n\tif pid < 0 {\n\t\treturn nil, errors.New(\"failed to spawn user namespace process\")\n\t}\n\n\toutW.Close()\n\terrW.Close()\n\n\tvar stdoutBuf, stderrBuf bytes.Buffer\n\tgo func() {\n\t\tio.Copy(&stdoutBuf, outR)\n\t}()\n\tgo func() {\n\t\tio.Copy(&stderrBuf, errR)\n\t}()\n\n\tvar ws syscall.WaitStatus\n\t_, err = syscall.Wait4(int(pid), &ws, 0, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for child process: %w\", err)\n\t}\n\n\tif ws.ExitStatus() != 0 {\n\t\treturn nil, fmt.Errorf(\"child process exited with status %d: %s\", ws.ExitStatus(), stderrBuf.String())\n\t}\n\n\treturn stdoutBuf.Bytes(), nil\n}\n```"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a child process using Go's pipe mechanism. The handler should start the child process, monitor its initialization status through the pipe, and handle potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct encapsulates a child process command and provides methods to manage its execution and IPC communication.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as a child process.\n\nMethods:\nStart: Start() -> error - Initializes the child process, establishes a pipe for communication, monitors the child's initialization status, and returns any errors encountered during startup or a timeout if the child process fails to initialize within the specified duration.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\t// Create a pipe for communication\n\tstdoutPipe, err := p.cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Start the child process\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set a timeout for initialization\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\t// Channel to capture initialization status\n\tinitDone := make(chan error, 1)\n\n\tgo func() {\n\t\t// Read from the pipe to check initialization status\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err := buf.ReadFrom(stdoutPipe)\n\t\tif err != nil {\n\t\t\tinitDone <- err\n\t\t\treturn\n\t\t}\n\n\t\t// Check for specific initialization message\n\t\tif buf.String() != \"initialized\\n\" {\n\t\t\tinitDone <- errors.New(\"child process failed to initialize\")\n\t\t\treturn\n\t\t}\n\n\t\tinitDone <- nil\n\t}()\n\n\t// Wait for initialization or timeout\n\tselect {\n\tcase err := <-initDone:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn errors.New(\"initialization timeout\")\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tcmd := exec.Command(\"your-child-process\")\n\tproxy := &proxyCommand{cmd: cmd}\n\tif err := proxy.Start(); err != nil {\n\t\t// Handle error\n\t}\n}\n```"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Go function that securely copies a password to the system clipboard using osascript (AppleScript) via a pipe, ensuring the password is handled safely and the clipboard is cleared after use.\n\nFunction Description: The function `copyViaOsascript` uses an inter-process communication mechanism (pipe) to securely pass a password to the AppleScript command `osascript`, which then sets the password in the system clipboard. The function ensures proper resource cleanup and checks for successful execution.\n\nInput:\n- `ctx context.Context`: Context for managing the command's lifecycle and cancellation.\n- `password string`: The password string to be copied to the clipboard.\n\nOutput:\n- `error`: Returns an error if any step fails (pipe creation, command execution, or clipboard setting). Returns nil on success.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\targs := []string{\n\t\t\"-e\", `use framework \"Foundation\"`,\n\t\t\"-e\", \"use scripting additions\",\n\t\t\"-e\", \"set type to current application's NSPasteboardTypeString\",\n\t\t\"-e\", \"set pb to current application's NSPasteboard's generalPasteboard()\",\n\t\t\"-e\", \"pb's clearContents()\",\n\t\t\"-e\", `pb's setString:\"\" forType:\"org.nspasteboard.ConcealedType\"`,\n\t\t\"-e\", `pb's setString:(do shell script \"cat 0<&3\") forType:type`,\n\t}\n\tcmd := exec.CommandContext(ctx, \"osascript\", args...)\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.ExtraFiles = []*os.File{r}\n\tgo func() {\n\t\tdefer w.Close()\n\t\t_, _ = io.WriteString(w, password)\n\t}()\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(out) != \"true\\n\" {\n\t\treturn fmt.Errorf(\"osascript failed to set password: %s\", string(out))\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\t// Create a pipe for inter-process communication\n\tcmd := exec.CommandContext(ctx, \"osascript\", \"-e\", `set the clipboard to \"`+password+`\"`)\n\tvar stderr bytes.Buffer\n\tcmd.Stderr = &stderr\n\n\t// Execute the command\n\tif err := cmd.Run(); err != nil {\n\t\treturn errors.New(stderr.String())\n\t}\n\n\t// Clear the clipboard after a short delay\n\ttime.AfterFunc(5*time.Second, func() {\n\t\tclearCmd := exec.Command(\"osascript\", \"-e\", `set the clipboard to \"\"`)\n\t\tclearCmd.Run()\n\t})\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Go struct that represents a basic HTTP server capable of serving static files from a specified directory, with fallback to a default page when files are not found.\n\nStruct Description: The Site struct represents a simple HTTP server that serves static files from a \"./site\" directory. It handles file requests and falls back to serving \"index.html\" when the requested file is not found.\n\nFields: (This struct has no explicit fields as it's used purely for organizing HTTP server functionality)\n\nMethods:\n\nMethod1: New() -> *Site - A constructor function that creates and returns a new instance of the Site struct.\n\nMethod2: Run() - Starts the HTTP server on the port specified in the configuration. It sets up a file server handler with custom 404 behavior and begins listening for requests.\n\nMethod3: notFound(http.ResponseWriter, *http.Request) - A helper function that serves the \"./site/index.html\" file when a requested resource is not found. Takes standard HTTP handler parameters and returns nothing.\n\nMethod4: server(http.FileSystem) -> http.Handler - A helper function that creates a custom file server handler with fallback behavior. Takes a filesystem interface and returns an HTTP handler.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\ntype Site struct {\n}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\tdata, _ := ioutil.ReadFile(\"./site/index.html\")\n\t_, _ = fmt.Fprintf(w, string(data))\n\treturn\n}\n\nfunc server(fs http.FileSystem) http.Handler {\n\tfileServer := http.FileServer(fs)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfilePath := path.Clean(\"./site\" + r.URL.Path)\n\t\t_, err := os.Stat(filePath)\n\t\tif err != nil {\n\t\t\tnotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfileServer.ServeHTTP(w, r)\n\t})\n}\n\nfunc (s *Site) Run() {\n\tport := config.Conf.Site.SiteBase.ListenPort\n\taddr := fmt.Sprintf(\":%d\", port)\n\thttp.ListenAndServe(addr, server(http.Dir(\"./site\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype Site struct{}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc (s *Site) Run() {\n\tfs := http.Dir(\"./site\")\n\thttp.Handle(\"/\", s.server(fs))\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc (s *Site) notFound(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, filepath.Join(\"./site\", \"index.html\"))\n}\n\nfunc (s *Site) server(fs http.FileSystem) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tf, err := fs.Open(r.URL.Path)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\ts.notFound(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\n\t\tstat, err := f.Stat()\n\t\tif err != nil || stat.IsDir() {\n\t\t\ts.notFound(w, r)\n\t\t\treturn\n\t\t}\n\n\t\thttp.ServeContent(w, r, r.URL.Path, stat.ModTime(), f)\n\t})\n}\n\nfunc main() {\n\tsite := New()\n\tsite.Run()\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It maintains client state, base URLs, user agent, rate limits, and provides access to various API services. The struct includes methods for creating new requests and executing them.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe access to rate limits\nrateLimits: [categories]Rate - Rate limit tracking for different API categories\ncommon: service - Shared service instance used by all API services\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support, rate limiting, and response handling",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Rate struct {\n\tLimit     int\n\tRemaining int\n\tReset     time.Time\n}\n\ntype service struct {\n\tclient *Client\n}\n\ntype Client struct {\n\tclientMu   sync.Mutex\n\tclient     *http.Client\n\tBaseURL    *url.URL\n\tUploadURL  *url.URL\n\tUserAgent  string\n\trateMu     sync.Mutex\n\trateLimits map[string]Rate\n\tcommon     service\n}\n\ntype Response struct {\n\t*http.Response\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(\"https://api.example.com/\")\n\tuploadURL, _ := url.Parse(\"https://upload.example.com/\")\n\tc := &Client{\n\t\tclient:     httpClient,\n\t\tBaseURL:    baseURL,\n\t\tUploadURL:  uploadURL,\n\t\tUserAgent:  \"Custom-Client\",\n\t\trateLimits: make(map[string]Rate),\n\t}\n\tc.common.client = c\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\trel, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu := c.BaseURL.ResolveReference(rel)\n\n\tvar buf bytes.Buffer\n\tif body != nil {\n\t\terr := json.NewEncoder(&buf).Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), &buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tc.clientMu.Lock()\n\tdefer c.clientMu.Unlock()\n\n\tresp, err := c.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := &Response{Response: resp}\n\n\tif resp.StatusCode >= 300 {\n\t\treturn response, errors.New(\"request failed with status code: \" + resp.Status)\n\t}\n\n\tif v != nil {\n\t\terr = json.NewDecoder(resp.Body).Decode(v)\n\t\tif err != nil {\n\t\t\treturn response, err\n\t\t}\n\t}\n\n\treturn response, nil\n}\n\nfunc main() {\n\t// Example usage\n\tclient := NewClient(nil)\n\treq, err := client.NewRequest(\"GET\", \"/path\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar result map[string]interface{}\n\t_, err = client.Do(context.Background(), req, &result)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Process result\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a POST request and serves an HTML form for file submission.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it serves an HTML form (rendered from a template). For POST requests, it processes file uploads by saving the uploaded file to the filesystem.\n\nInput:\n- None (The function takes no direct input parameters, but handles HTTP requests with the following characteristics:\n  - GET requests to \"/\" trigger form rendering\n  - POST requests to \"/\" with a \"file\" form field trigger file upload processing)\n\nOutput:\n- None (The function doesn't return any value, but has the following side effects:\n  - Starts an HTTP server on port 9000\n  - Writes responses to http.ResponseWriter\n  - Creates files on the filesystem for successful uploads)",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\ttpl, err := template.ParseFiles(\"form.gohtml\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tif req.Method == \"POST\" {\n\t\t\tsrc, _, err := req.FormFile(\"file\")\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tdefer src.Close()\n\n\t\t\tdst, err := os.Create(filepath.Join(\"./\", \"file.txt\"))\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dst.Close()\n\n\t\t\tio.Copy(dst, src)\n\t\t}\n\n\t\terr = tpl.Execute(res, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", fileHandler)\n\thttp.ListenAndServe(\":9000\", nil)\n}\n\nfunc fileHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\ttmpl := `<html>\n<head><title>Upload File</title></head>\n<body>\n<form enctype=\"multipart/form-data\" action=\"/\" method=\"post\">\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"Upload\" />\n</form>\n</body>\n</html>`\n\t\tt, _ := template.New(\"upload\").Parse(tmpl)\n\t\tt.Execute(w, nil)\n\t\treturn\n\t}\n\n\tif r.Method == http.MethodPost {\n\t\tr.ParseMultipartForm(10 << 20) // 10 MB\n\t\tfile, handler, err := r.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error retrieving the file\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tdst, err := os.Create(filepath.Join(\"./uploads\", handler.Filename))\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error saving the file\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer dst.Close()\n\n\t\t_, err = io.Copy(dst, file)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error writing the file\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(\"File uploaded successfully\"))\n\t}\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a Go struct that represents a metric sink for sending metrics to a Cortex metrics server using HTTP with advanced configuration options.\n\nStruct Description: The CortexMetricSink struct is responsible for batching and sending metrics to a Cortex server via HTTP with support for custom headers, basic authentication, proxy configuration, and connection pooling.\n\nFields:\n\nURL: string - The endpoint URL of the Cortex server to send metrics to\nRemoteTimeout: time.Duration - Timeout for HTTP requests to Cortex\nProxyURL: string - URL of the proxy server to use (optional)\nClient: *http.Client - Custom HTTP client for making requests\nlogger: *logrus.Entry - Logger for the sink\nname: string - Name identifier for the sink\ntraceClient: *trace.Client - Tracing client for distributed tracing\naddHeaders: map[string]string - Additional headers to include in requests\nbasicAuth: *BasicAuthType - Basic authentication credentials (optional)\nbatchWriteSize: int - Maximum number of metrics to batch before sending\ncounters: map[counterMapKey]float64 - Internal counter storage\nconvertCountersToMonotonic: bool - Flag to convert counters to monotonic values\nexcludedTags: map[string]struct{} - Tags to exclude from metrics\nhost: string - Host identifier for metrics\n\nMethods:\n\nStart: (tc *trace.Client) -> error - Initializes the sink with tracing and HTTP client configuration\nwriteMetrics: (ctx context.Context, metrics []samplers.InterMetric) -> error - Processes and sends a batch of metrics to Cortex\n\nBasicAuthType Struct Description: Nested struct for storing basic authentication credentials\n\nFields:\n\nUsername: util.StringSecret - Basic auth username (secret type)\nPassword: util.StringSecret - Basic auth password (secret type)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/golang/snappy\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/prometheus/prometheus/prompb\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/veneur/v14/samplers\"\n\t\"github.com/stripe/veneur/v14/sinks\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype CortexMetricSink struct {\n\tURL                        string\n\tRemoteTimeout              time.Duration\n\tProxyURL                   string\n\tClient                     *http.Client\n\tlogger                     *logrus.Entry\n\tname                       string\n\ttraceClient                *trace.Client\n\taddHeaders                 map[string]string\n\tbasicAuth                  *BasicAuthType\n\tbatchWriteSize             int\n\tcounters                   map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags               map[string]struct{}\n\thost                       string\n}\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret `yaml:\"username\"`\n\tPassword util.StringSecret `yaml:\"password\"`\n}\n\nfunc (s *CortexMetricSink) Start(tc *trace.Client) error {\n\ts.logger.Infof(\"Starting sink for %s\", s.URL)\n\tt := http.DefaultTransport.(*http.Transport).Clone()\n\tt.MaxIdleConns = MaxConns\n\tt.MaxConnsPerHost = MaxConns\n\tt.MaxIdleConnsPerHost = MaxConns\n\n\tif len(s.ProxyURL) > 0 {\n\t\tp, err := url.Parse(s.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"malformed cortex_proxy_url\")\n\t\t}\n\t\tt.Proxy = http.ProxyURL(p)\n\t}\n\n\ts.Client = &http.Client{\n\t\tTimeout:   s.RemoteTimeout,\n\t\tTransport: t,\n\t}\n\n\ts.traceClient = tc\n\treturn nil\n}\n\nfunc (s *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\tspan, _ := trace.StartSpanFromContext(ctx, \"\")\n\tdefer span.ClientFinish(s.traceClient)\n\n\twr := s.makeWriteRequest(metrics)\n\n\tdata, err := wr.Marshal()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to marshal proto\\\"\")\n\t}\n\n\tvar buf bytes.Buffer\n\tencoded := snappy.Encode(nil, data)\n\tbuf.Write(encoded)\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", s.URL, &buf)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to create http request\\\"\")\n\t}\n\n\treq.Header.Set(\"Content-Encoding\", \"snappy\")\n\treq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\treq.Header.Set(\"User-Agent\", \"veneur/cortex\")\n\treq.Header.Set(\"X-Prometheus-Remote-Write-Version\", \"0.1.0\")\n\tfor key, value := range s.addHeaders {\n\t\treq.Header.Set(key, value)\n\t}\n\tif s.basicAuth != nil {\n\t\treq.SetBasicAuth(s.basicAuth.Username.Value, s.basicAuth.Password.Value)\n\t}\n\n\tts := time.Now()\n\tr, err := s.Client.Do(req)\n\tif err != nil {\n\t\tspan.Error(err)\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: misc http client error\\\" duration_secs=%.2f\", time.Since(ts).Seconds())\n\t}\n\tdefer r.Body.Close()\n\n\tif r.StatusCode >= 300 {\n\t\tb, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: downstream returned error response with unreadable body\\\" response_code=%d\", r.StatusCode)\n\t\t}\n\t\treturn fmt.Errorf(\"cortex_err=\\\"failed to write batch: error response\\\", response_code=%d response_body=\\\"%s\\\"\", r.StatusCode, b)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"go.opencensus.io/trace\"\n\t\"myproject/util\"\n\t\"myproject/samplers\"\n)\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret\n\tPassword util.StringSecret\n}\n\ntype CortexMetricSink struct {\n\tURL                      string\n\tRemoteTimeout            time.Duration\n\tProxyURL                 string\n\tClient                   *http.Client\n\tlogger                   *logrus.Entry\n\tname                     string\n\ttraceClient              *trace.Client\n\taddHeaders               map[string]string\n\tbasicAuth                *BasicAuthType\n\tbatchWriteSize           int\n\tcounters                 map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags             map[string]struct{}\n\thost                     string\n}\n\nfunc (c *CortexMetricSink) Start(tc *trace.Client) error {\n\tc.traceClient = tc\n\ttransport := &http.Transport{}\n\tif c.ProxyURL != \"\" {\n\t\tproxyURL, err := url.Parse(c.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttransport.Proxy = http.ProxyURL(proxyURL)\n\t}\n\tc.Client = &http.Client{\n\t\tTimeout:   c.RemoteTimeout,\n\t\tTransport: transport,\n\t}\n\treturn nil\n}\n\nfunc (c *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\t// Implement batching and sending logic here\n\treturn nil\n}\n\ntype counterMapKey struct {\n\t// Define fields for counter map key\n}\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Go HTTP server that handles Stripe webhook events, specifically processing billing meter error reports and other event types.\n\nFunction Description: The main function sets up an HTTP server with a \"/webhook\" endpoint that receives and processes Stripe webhook events. It validates the webhook signature, retrieves full event details from Stripe, and handles specific event types (particularly \"v1.billing.meter.error_report_triggered\").\n\nInput:\n- HTTP POST requests to \"/webhook\" endpoint containing:\n  - Request body with Stripe event payload (JSON format)\n  - \"Stripe-Signature\" header for webhook validation\n- Environment variables:\n  - apiKey: Stripe API key for authentication\n  - webhookSecret: Secret for validating webhook signatures\n\nOutput:\n- HTTP responses:\n  - 200 OK for successful processing\n  - 500 Internal Server Error for any processing failures\n- Console output:\n  - Success messages with meter IDs for handled events\n  - Error messages for any processing failures\n  - Notifications for unhandled event types\n\nThe function does not explicitly return values but writes to the HTTP response and console.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/stripe/stripe-go/v81\"\n\tbillingMeters \"github.com/stripe/stripe-go/v81/billing/meter\"\n\t\"github.com/stripe/stripe-go/v81/rawrequest\"\n\twebhook \"github.com/stripe/stripe-go/v81/webhook\"\n)\nfunc main() {\n\tb, err := stripe.GetRawRequestBackend(stripe.APIBackend)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tclient := rawrequest.Client{B: b, Key: apiKey}\n\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) {\n\t\tconst MaxBodyBytes = int64(65536)\n\t\treq.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes)\n\t\tpayload, err := ioutil.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\terr = webhook.ValidatePayload(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar thinEvent map[string]interface{}\n\n\t\tif err := json.Unmarshal(payload, &thinEvent); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse thin event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\teventID := thinEvent[\"id\"].(string)\n\n\t\tvar event map[string]interface{}\n\n\t\tresp, err := client.RawRequest(http.MethodGet, \"/v2/core/events/\"+eventID, \"\", nil)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get pull event: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := json.Unmarshal(resp.RawJSON, &event); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse pull event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tswitch t := event[\"type\"].(string); t {\n\t\tcase \"v1.billing.meter.error_report_triggered\":\n\t\t\trelatedObject := event[\"related_object\"].(map[string]interface{})\n\t\t\tmeter, err := billingMeters.Get(relatedObject[\"id\"].(string), nil)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get related meter object: %v\\n\", err.Error())\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmeterID := meter.ID\n\t\t\tfmt.Printf(\"Success! %s\\n\", meterID)\n\t\t\tfmt.Println(fmt.Sprint(event[\"data\"]))\n\t\tdefault:\n\t\t\tfmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", t)\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\terr = http.ListenAndServe(\":4242\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/stripe/stripe-go\"\n\t\"github.com/stripe/stripe-go/webhook\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/webhook\", handleWebhook)\n\tport := \"8080\"\n\tlog.Printf(\"Starting server on port %s\", port)\n\tif err := http.ListenAndServe(\":\"+port, nil); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n\nfunc handleWebhook(w http.ResponseWriter, r *http.Request) {\n\twebhookSecret := os.Getenv(\"webhookSecret\")\n\tapiKey := os.Getenv(\"apiKey\")\n\tstripe.Key = apiKey\n\n\tpayload, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"Error reading request body: %v\", err)\n\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tevent, err := webhook.ConstructEvent(payload, r.Header.Get(\"Stripe-Signature\"), webhookSecret)\n\tif err != nil {\n\t\tlog.Printf(\"Error verifying webhook signature: %v\", err)\n\t\thttp.Error(w, \"Failed to verify webhook signature\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tswitch event.Type {\n\tcase \"v1.billing.meter.error_report_triggered\":\n\t\tvar meterError stripe.Event\n\t\tif err := json.Unmarshal(event.Data.Raw, &meterError); err != nil {\n\t\t\tlog.Printf(\"Error parsing event data: %v\", err)\n\t\t\thttp.Error(w, \"Failed to parse event data\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tmeterID := meterError.ID\n\t\tlog.Printf(\"Processed meter error report for meter ID: %s\", meterID)\n\t\tfmt.Fprintf(w, \"Processed meter error report for meter ID: %s\", meterID)\n\tdefault:\n\t\tlog.Printf(\"Unhandled event type: %s\", event.Type)\n\t\tfmt.Fprintf(w, \"Unhandled event type: %s\", event.Type)\n\t}\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles user authentication through cookies, displaying different HTML content based on login status.\n\nFunction Description: The main function sets up an HTTP server with a single route handler that manages user authentication. It checks for a \"logged-in\" cookie, processes login/logout requests, and serves different HTML content based on the authentication status.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but serves HTTP responses and maintains server state)\n\nNote: The function handles three main scenarios:\n1. Initial visit (no cookie set)\n2. Successful login (POST with correct password)\n3. Logout request (/logout path)\nFor each scenario, it sets appropriate cookies and returns corresponding HTML content.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"logged-in\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"logged-in\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\n\t\tif req.Method == \"POST\" {\n\t\t\tpassword := req.FormValue(\"password\")\n\t\t\tif password == \"secret\" {\n\t\t\t\tcookie = &http.Cookie{\n\t\t\t\t\tName:  \"logged-in\",\n\t\t\t\t\tValue: \"1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif req.URL.Path == \"/logout\" {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:   \"logged-in\",\n\t\t\t\tValue:  \"0\",\n\t\t\t\tMaxAge: -1,\n\t\t\t}\n\t\t}\n\n\t\thttp.SetCookie(res, cookie)\n\t\tvar html string\n\n\t\tif cookie.Value == strconv.Itoa(0) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1>LOG IN</h1>\n\t\t\t<form method=\"post\" action=\"http://localhost:9000/\">\n\t\t\t\t<h3>User name</h3>\n\t\t\t\t<input type=\"text\" name=\"userName\" id=\"userName\">\n\t\t\t\t<h3>Password</h3>\n\t\t\t\t<input type=\"text\" name=\"password\" id=\"password\">\n\t\t\t\t<br>\n\t\t\t\t<input type=\"submit\">\n\t\t\t\t<input type=\"submit\" name=\"logout\" value=\"logout\">\n\t\t\t</form>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tif cookie.Value == strconv.Itoa(1) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1><a href=\"http://localhost:9000/logout\">LOG OUT</a></h1>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tio.WriteString(res, html)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nconst (\n\tloginPage = `<html><body><form method=\"POST\" action=\"/login\"><input type=\"password\" name=\"password\"/><input type=\"submit\" value=\"Login\"/></form></body></html>`\n\thomePage  = `<html><body><h1>Welcome, User!</h1><a href=\"/logout\">Logout</a></body></html>`\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", authHandler)\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/logout\", logoutHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc authHandler(w http.ResponseWriter, r *http.Request) {\n\tcookie, err := r.Cookie(\"logged-in\")\n\tif err != nil || cookie.Value != \"true\" {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\tfmt.Fprint(w, homePage)\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodPost {\n\t\tpassword := r.FormValue(\"password\")\n\t\tif password == \"password123\" {\n\t\t\thttp.SetCookie(w, &http.Cookie{\n\t\t\t\tName:    \"logged-in\",\n\t\t\t\tValue:   \"true\",\n\t\t\t\tExpires: time.Now().Add(24 * time.Hour),\n\t\t\t})\n\t\t\thttp.Redirect(w, r, \"/\", http.StatusFound)\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Fprint(w, loginPage)\n}\n\nfunc logoutHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.SetCookie(w, &http.Cookie{\n\t\tName:    \"logged-in\",\n\t\tValue:   \"\",\n\t\tExpires: time.Now().Add(-1 * time.Hour),\n\t})\n\thttp.Redirect(w, r, \"/login\", http.StatusFound)\n}\n```"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Implement a function to start an HTTP server with configurable parameters including authentication, TLS, and database integration. The function should handle routing, authentication wrapping, and server startup with both HTTP and HTTPS support.\n\nFunction Description: The `Start` function initializes and starts an HTTP server with various endpoints for database operations. It supports optional authentication via a pre-shared token and can be configured to use TLS for secure connections. The server connects to a tiedot database and provides RESTful endpoints for database operations.\n\nInput:\n- `dir` (string): Directory path for the tiedot database\n- `port` (int): Port number to listen on\n- `tlsCrt` (string): Path to TLS certificate file (empty for HTTP)\n- `tlsKey` (string): Path to TLS private key file (empty for HTTP)\n- `jwtPubKey` (string): JWT public key (unused in reference code)\n- `jwtPrivateKey` (string): JWT private key (unused in reference code)\n- `bind` (string): Network interface to bind to (empty for all interfaces)\n- `authToken` (string): Pre-shared token for authentication (empty to disable)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics on error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/HouzuoGuo/tiedot/db\"\n\t\"github.com/HouzuoGuo/tiedot/tdlog\"\n)\n\nvar (\n\tHttpDB *db.DB\n)\n\nfunc Start(dir string, port int, tlsCrt, tlsKey, jwtPubKey, jwtPrivateKey, bind, authToken string) {\n\tvar err error\n\tHttpDB, err = db.OpenDB(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thttp.HandleFunc(\"/\", Welcome)\n\thttp.HandleFunc(\"/version\", Version)\n\thttp.HandleFunc(\"/memstats\", MemStats)\n\n\tvar authWrap func(http.HandlerFunc) http.HandlerFunc\n\tif authToken != \"\" {\n\t\ttdlog.Noticef(\"API endpoints now require the pre-shared token in Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tif \"token \"+authToken != r.Header.Get(\"Authorization\") {\n\t\t\t\t\thttp.Error(w, \"\", http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\toriginalHandler(w, r)\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"API endpoints do not require Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn originalHandler\n\t\t}\n\t}\n\n\thttp.HandleFunc(\"/create\", authWrap(Create))\n\thttp.HandleFunc(\"/rename\", authWrap(Rename))\n\thttp.HandleFunc(\"/drop\", authWrap(Drop))\n\thttp.HandleFunc(\"/all\", authWrap(All))\n\thttp.HandleFunc(\"/scrub\", authWrap(Scrub))\n\thttp.HandleFunc(\"/sync\", authWrap(Sync))\n\thttp.HandleFunc(\"/query\", authWrap(Query))\n\thttp.HandleFunc(\"/count\", authWrap(Count))\n\thttp.HandleFunc(\"/insert\", authWrap(Insert))\n\thttp.HandleFunc(\"/get\", authWrap(Get))\n\thttp.HandleFunc(\"/getpage\", authWrap(GetPage))\n\thttp.HandleFunc(\"/update\", authWrap(Update))\n\thttp.HandleFunc(\"/delete\", authWrap(Delete))\n\thttp.HandleFunc(\"/approxdoccount\", authWrap(ApproxDocCount))\n\thttp.HandleFunc(\"/index\", authWrap(Index))\n\thttp.HandleFunc(\"/indexes\", authWrap(Indexes))\n\thttp.HandleFunc(\"/unindex\", authWrap(Unindex))\n\thttp.HandleFunc(\"/shutdown\", authWrap(Shutdown))\n\thttp.HandleFunc(\"/dump\", authWrap(Dump))\n\n\tiface := \"all interfaces\"\n\tif bind != \"\" {\n\t\tiface = bind\n\t}\n\n\tif tlsCrt != \"\" {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTPS), port %d.\", iface, port)\n\t\tif err := http.ListenAndServeTLS(fmt.Sprintf(\"%s:%d\", bind, port), tlsCrt, tlsKey, nil); err != nil {\n\t\t\ttdlog.Panicf(\"Failed to start HTTPS service - %s\", err)\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTP), port %d.\", iface, port)\n\t\thttp.ListenAndServe(fmt.Sprintf(\"%s:%d\", bind, port), nil)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/HouzuoGuo/tiedot/db\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc Start(dir string, port int, tlsCrt string, tlsKey string, bind string, authToken string) {\n\t// Open tiedot database\n\tmyDB, err := db.OpenDB(dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer myDB.Close()\n\n\t// Create a new router\n\trouter := mux.NewRouter()\n\n\t// Middleware for authentication\n\tif authToken != \"\" {\n\t\trouter.Use(authMiddleware(authToken))\n\t}\n\n\t// Define routes\n\trouter.HandleFunc(\"/db/{col}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Handle database operations\n\t}).Methods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n\n\t// Determine address to bind\n\taddress := fmt.Sprintf(\"%s:%d\", bind, port)\n\n\t// Start server with TLS if certificate and key are provided\n\tif tlsCrt != \"\" && tlsKey != \"\" {\n\t\tcer, err := tls.LoadX509KeyPair(tlsCrt, tlsKey)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load TLS certificate and key: %v\", err)\n\t\t}\n\t\ttlsConfig := &tls.Config{Certificates: []tls.Certificate{cer}}\n\t\tserver := &http.Server{\n\t\t\tAddr:      address,\n\t\t\tHandler:   router,\n\t\t\tTLSConfig: tlsConfig,\n\t\t}\n\t\tlog.Printf(\"Starting HTTPS server on %s\", address)\n\t\tif err := server.ListenAndServeTLS(\"\", \"\"); err != nil {\n\t\t\tlog.Fatalf(\"HTTPS server failed: %v\", err)\n\t\t}\n\t} else {\n\t\t// Start server without TLS\n\t\tlog.Printf(\"Starting HTTP server on %s\", address)\n\t\tif err := http.ListenAndServe(address, router); err != nil {\n\t\t\tlog.Fatalf(\"HTTP server failed: %v\", err)\n\t\t}\n\t}\n}\n\nfunc authMiddleware(token string) mux.MiddlewareFunc {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.Header.Get(\"Authorization\") != fmt.Sprintf(\"Bearer %s\", token) {\n\t\t\t\thttp.Error(w, \"Forbidden\", http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n}\n\nfunc main() {\n\tdir := os.Getenv(\"DB_DIR\")\n\tport := 8080\n\ttlsCrt := os.Getenv(\"TLS_CERT\")\n\ttlsKey := os.Getenv(\"TLS_KEY\")\n\tbind := \"\"\n\tauthToken := os.Getenv(\"AUTH_TOKEN\")\n\n\tStart(dir, port, tlsCrt, tlsKey, bind, authToken)\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a function that checks the health status of a Kubernetes cluster by making an HTTP GET request to the cluster's livez endpoint using a custom HTTP client with TLS configuration.\n\nFunction Description: The function `GetClusterStatusByAPI` verifies the health of a Kubernetes cluster by sending an HTTPS request to the cluster's `/livez` endpoint. It uses a custom `http.Client` with TLS configuration loaded from the cluster's connection settings. The function returns a boolean indicating the cluster's health status and a string containing any error messages or the response body if the check fails.\n\nInput: \n- `addr` [string]: The address of the Kubernetes cluster API server.\n- `cluster` [*model.Cluster]: A pointer to a cluster object containing connection configuration details.\n\nOutput: \n- [bool]: `true` if the cluster is healthy (HTTP status code 200), `false` otherwise.\n- [string]: An empty string if the cluster is healthy, otherwise an error message or the response body.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/client-go/rest\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\treqURL := fmt.Sprintf(\"https://%s/livez\", addr)\n\tconf, err := clusterUtil.LoadConnConf(cluster, addr)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"load cluster config error %s\", err.Error())\n\t}\n\ttls2, err := rest.TransportFor(conf)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"config transport error %s\", err.Error())\n\t}\n\tclient := &http.Client{Timeout: 1 * time.Second, Transport: tls2}\n\trequest, _ := http.NewRequest(\"GET\", reqURL, nil)\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Https get error %s\", err.Error())\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode == 200 {\n\t\treturn true, \"\"\n\t}\n\ts, _ := ioutil.ReadAll(response.Body)\n\treturn false, fmt.Sprintf(\"Api check error %s\", string(s))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "import (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Cluster struct {\n\tCACert     []byte\n\tClientCert []byte\n\tClientKey  []byte\n}\n\nfunc GetClusterStatusByAPI(addr string, cluster *Cluster) (bool, string) {\n\tcaCertPool := x509.NewCertPool()\n\tif !caCertPool.AppendCertsFromPEM(cluster.CACert) {\n\t\treturn false, \"failed to append CA certificate\"\n\t}\n\n\tclientCert, err := tls.X509KeyPair(cluster.ClientCert, cluster.ClientKey)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"failed to load client certificate: %v\", err)\n\t}\n\n\ttlsConfig := &tls.Config{\n\t\tRootCAs:      caCertPool,\n\t\tCertificates: []tls.Certificate{clientCert},\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t},\n\t\tTimeout: 10 * time.Second,\n\t}\n\n\tresp, err := client.Get(fmt.Sprintf(\"https://%s/livez\", addr))\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"failed to perform GET request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\treturn true, \"\"\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn false, string(body)\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that serves Prometheus metrics via an HTTP server, updating custom metrics (uptime and packet count) on each request.\n\nFunction Description: The ServeMetricsAt function starts an HTTP server to expose Prometheus metrics. It registers custom metrics (uptime and packet count), updates them on each request to the metrics endpoint, and serves the metrics using the Prometheus HTTP handler. The function runs the server in a goroutine to avoid blocking the main program.\n\nInput:\n- addr (string): The network address (including port) where the metrics server should listen (e.g., \":8080\")\n- c (*collector.Collector): A pointer to a collector instance used to get the current packet count (can be nil)\n\nOutput: None (the function runs indefinitely in a background goroutine)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n\t\"github.com/dreadl0ck/netcap/collector\"\n)\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tprometheus.MustRegister(upTime)\n\tprometheus.MustRegister(numPackets)\n\n\tfmt.Println(\"starting to serve metrics at:\", addr+metricsRoute)\n\n\tgo func() {\n\t\tmetricsHandler := promhttp.Handler()\n\n\t\thttp.HandleFunc(metricsRoute, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupTime.WithLabelValues().Set(math.RoundToEven(time.Since(startTime).Seconds())\n\n\t\t\tif c != nil {\n\t\t\t\tnumPackets.WithLabelValues().Set(float64(c.GetNumPackets()))\n\t\t\t}\n\n\t\t\tmetricsHandler.ServeHTTP(w, r)\n\t\t})\n\t\tlog.Fatal(\"failed to serve metrics: \", http.ListenAndServe(addr, nil))\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\ntype Collector struct {\n\tpacketCount int\n}\n\nfunc (c *Collector) GetPacketCount() int {\n\treturn c.packetCount\n}\n\nfunc ServeMetricsAt(addr string, c *Collector) {\n\tuptime := prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"uptime_seconds\",\n\t\tHelp: \"Uptime of the server in seconds\",\n\t})\n\tpacketCount := prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"packet_count\",\n\t\tHelp: \"Number of packets processed\",\n\t})\n\n\tprometheus.MustRegister(uptime)\n\tprometheus.MustRegister(packetCount)\n\n\tgo func() {\n\t\tstartTime := time.Now()\n\t\thttp.Handle(\"/metrics\", promhttp.Handler())\n\t\thttp.ListenAndServe(addr, nil)\n\n\t\tfor {\n\t\t\tuptime.Set(time.Since(startTime).Seconds())\n\t\t\tif c != nil {\n\t\t\t\tpacketCount.Set(float64(c.GetPacketCount()))\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}()\n}\n\nfunc main() {\n\tc := &Collector{packetCount: 100}\n\tServeMetricsAt(\":8080\", c)\n\n\tselect {} // Block forever\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Go HTTP server that handles multiple routes with different authentication methods (Basic Auth and Bearer Token) and serves Prometheus metrics on authenticated endpoints.\n\nFunction Description: The main function sets up an HTTP server with three routes:\n1. Root (\"/\") route with a basic handler\n2. \"/metrics\" route protected by Basic Authentication\n3. \"/bearer-metrics\" route protected by Bearer Token authentication\nThe server listens on port 8080 and uses the net/http package for HTTP operations.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The implementation assumes the existence of two helper functions:\n1. checkBasicAuth(w http.ResponseWriter, r *http.Request) bool\n2. checkBearerAuth(w http.ResponseWriter, r *http.Request) bool\nwhich handle the respective authentication methods.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBasicAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\thttp.HandleFunc(\"/bearer-metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBearerAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Bearer realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\taddress := \":8080\"\n\n\t_ = http.ListenAndServe(address, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"log\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", rootHandler)\n\thttp.HandleFunc(\"/metrics\", basicAuthHandler(metricsHandler))\n\thttp.HandleFunc(\"/bearer-metrics\", bearerAuthHandler(metricsHandler))\n\n\tlog.Println(\"Starting server on port 8080\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Welcome to the root!\"))\n}\n\nfunc metricsHandler(w http.ResponseWriter, r *http.Request) {\n\t// Example metric response, replace with actual metrics generation code\n\tw.Write([]byte(\"Metrics data\"))\n}\n\nfunc basicAuthHandler(next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBasicAuth(w, r) {\n\t\t\tnext(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}\n\nfunc bearerAuthHandler(next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBearerAuth(w, r) {\n\t\t\tnext(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t}\n}\n\nfunc checkBasicAuth(w http.ResponseWriter, r *http.Request) bool {\n\tusername, password, ok := r.BasicAuth()\n\tvalidUsername := os.Getenv(\"BASIC_AUTH_USERNAME\")\n\tvalidPassword := os.Getenv(\"BASIC_AUTH_PASSWORD\")\n\treturn ok && username == validUsername && password == validPassword\n}\n\nfunc checkBearerAuth(w http.ResponseWriter, r *http.Request) bool {\n\ttoken := r.Header.Get(\"Authorization\")\n\tvalidToken := \"Bearer \" + os.Getenv(\"BEARER_TOKEN\")\n\treturn token == validToken\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a function that performs an HTTP request with custom headers and handles the response, including error handling and logging for debugging purposes.\n\nFunction Description: The function `realRequest` performs an HTTP request with custom headers, handles authentication, and processes the response. It includes validation of required headers, adds security tokens and user agents, computes signatures for authentication, and handles response errors. Debug logging is available for both requests and responses.\n\nInput:\n- `ctx` (context.Context): Context for the request, allowing cancellation and timeouts.\n- `project` (*LogProject): A struct containing project-specific details like base URL, access keys, and user agent.\n- `method` (string): HTTP method (e.g., \"GET\", \"POST\").\n- `uri` (string): The URI path for the request.\n- `headers` (map[string]string): A map of HTTP headers to include in the request.\n- `body` ([]byte): The request body as a byte slice.\n\nOutput:\n- (*http.Response, error): Returns the HTTP response and an error if any occurred during the request or response handling. The error is wrapped in custom error types for better context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"time\"\n\n\t\"github.com/go-kit/kit/log/level\"\n)\n\nvar (\n\tdefaultRequestTimeout = 60 * time.Second\n\tdefaultRetryTimeout   = 90 * time.Second\n\tdefaultHttpClient     = &http.Client{\n\t\tTimeout: defaultRequestTimeout,\n\t}\n)\n\nfunc realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif _, ok := headers[\"x-log-bodyrawsize\"]; !ok {\n\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'x-log-bodyrawsize' header\"))\n\t}\n\n\tbaseURL := project.getBaseURL()\n\theaders[\"Host\"] = baseURL\n\theaders[\"Date\"] = nowRFC1123()\n\theaders[\"x-log-apiversion\"] = version\n\theaders[\"x-log-signaturemethod\"] = signatureMethod\n\tif len(project.UserAgent) > 0 {\n\t\theaders[\"User-Agent\"] = project.UserAgent\n\t} else {\n\t\theaders[\"User-Agent\"] = DefaultLogUserAgent\n\t}\n\n\tif project.SecurityToken != \"\" {\n\t\theaders[\"x-acs-security-token\"] = project.SecurityToken\n\t}\n\n\tif body != nil {\n\t\tbodyMD5 := fmt.Sprintf(\"%X\", md5.Sum(body))\n\t\theaders[\"Content-MD5\"] = bodyMD5\n\t\tif _, ok := headers[\"Content-Type\"]; !ok {\n\t\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'Content-Type' header\"))\n\t\t}\n\t}\n\n\tdigest, err := signature(project.AccessKeySecret, method, uri, headers)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tauth := fmt.Sprintf(\"SLS %v:%v\", project.AccessKeyID, digest)\n\theaders[\"Authorization\"] = auth\n\n\treader := bytes.NewReader(body)\n\turlStr := fmt.Sprintf(\"%s%s\", baseURL, uri)\n\treq, err := http.NewRequest(method, urlStr, reader)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Add(k, v)\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpRequest(req, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Request:\\n%v\", string(dump))\n\t}\n\n\tresp, err := project.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\terr := &Error{}\n\t\terr.HTTPCode = (int32)(resp.StatusCode)\n\t\tdefer resp.Body.Close()\n\t\tbuf, ioErr := ioutil.ReadAll(resp.Body)\n\t\tif ioErr != nil {\n\t\t\treturn nil, NewBadResponseError(ioErr.Error(), resp.Header, resp.StatusCode)\n\t\t}\n\t\tif jErr := json.Unmarshal(buf, err); jErr != nil {\n\t\t\treturn nil, NewBadResponseError(string(buf), resp.Header, resp.StatusCode)\n\t\t}\n\t\terr.RequestID = resp.Header.Get(RequestIDHeader)\n\t\treturn nil, err\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpResponse(resp, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Response:\\n%v\", string(dump))\n\t}\n\treturn resp, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "func realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n    // Validate required headers\n    if _, ok := headers[\"Content-Type\"]; !ok {\n        return nil, fmt.Errorf(\"missing required header: Content-Type\")\n    }\n\n    // Add security tokens and user agent\n    headers[\"Authorization\"] = fmt.Sprintf(\"Bearer %s\", project.AccessToken)\n    headers[\"User-Agent\"] = project.UserAgent\n\n    // Compute signature for authentication\n    signature, err := computeSignature(project.SecretKey, method, uri, headers, body)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to compute signature: %w\", err)\n    }\n    headers[\"Signature\"] = signature\n\n    // Create HTTP request\n    req, err := http.NewRequestWithContext(ctx, method, project.BaseURL+uri, bytes.NewReader(body))\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create request: %w\", err)\n    }\n\n    // Set headers\n    for key, value := range headers {\n        req.Header.Set(key, value)\n    }\n\n    // Debug logging for request\n    log.Printf(\"Sending request: %s %s\", method, req.URL)\n    for key, value := range headers {\n        log.Printf(\"Header: %s=%s\", key, value)\n    }\n\n    // Perform HTTP request\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"request failed: %w\", err)\n    }\n\n    // Debug logging for response\n    log.Printf(\"Received response: %s\", resp.Status)\n    for key, value := range resp.Header {\n        log.Printf(\"Response Header: %s=%s\", key, value)\n    }\n\n    // Handle response errors\n    if resp.StatusCode < 200 || resp.StatusCode >= 300 {\n        return resp, fmt.Errorf(\"unexpected response status: %d\", resp.StatusCode)\n    }\n\n    return resp, nil\n}\n\nfunc computeSignature(secretKey, method, uri string, headers map[string]string, body []byte) (string, error) {\n    // Example signature computation logic\n    h := hmac.New(sha256.New, []byte(secretKey))\n    h.Write([]byte(method))\n    h.Write([]byte(uri))\n    for key, value := range headers {\n        h.Write([]byte(key + value))\n    }\n    h.Write(body)\n    return hex.EncodeToString(h.Sum(nil)), nil\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests with tracing capabilities using OpenCensus. The server should respond to requests with a simple message, perform tracing operations, and make an external HTTP request while propagating the trace context.\n\nFunction Description: The main function sets up an HTTP server with tracing middleware. It registers a root handler (\"/\") that responds with \"hello world\", creates trace spans, adds annotations/attributes, and makes an external HTTP request to example.com while maintaining trace context.\n\nInput: None (The function takes no direct input parameters. HTTP requests come through the server's routing mechanism.)\n\nOutput: None (The function doesn't return anything directly. It starts an HTTP server that listens indefinitely on port 50030 and handles incoming requests by writing responses to http.ResponseWriter.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/plugin/ochttp\"\n)\n\nfunc main() {\n\tclient := &http.Client{Transport: &ochttp.Transport{}}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\n\t\t_, span := trace.StartSpan(req.Context(), \"child\")\n\t\tdefer span.End()\n\t\tspan.Annotate([]trace.Attribute{trace.StringAttribute(\"key\", \"value\")}, \"something happened\")\n\t\tspan.AddAttributes(trace.StringAttribute(\"hello\", \"world\"))\n\t\ttime.Sleep(time.Millisecond * 125)\n\n\t\tr, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\t\tr = r.WithContext(req.Context())\n\t\tresp, err := client.Do(r)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t} else {\n\t\t\tresp.Body.Close()\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":50030\", &ochttp.Handler{}))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/plugin/ochttp\"\n\t\"go.opencensus.io/trace\"\n)\n\nfunc main() {\n\t// Configure OpenCensus tracing\n\ttrace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})\n\n\t// Create a handler that will respond to requests\n\thttp.Handle(\"/\", ochttp.Handler{Handler: http.HandlerFunc(rootHandler)})\n\n\t// Start the HTTP server\n\tlog.Println(\"Starting server on :50030\")\n\tlog.Fatal(http.ListenAndServe(\":50030\", nil))\n}\n\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tctx, span := trace.StartSpan(r.Context(), \"rootHandler\")\n\tdefer span.End()\n\n\t// Add annotations and attributes to the span\n\tspan.Annotate([]trace.Attribute{\n\t\ttrace.StringAttribute(\"handler\", \"root\"),\n\t}, \"Handling root request\")\n\n\t// Respond to the request\n\tfmt.Fprintln(w, \"hello world\")\n\n\t// Make an external HTTP request while propagating the trace context\n\tmakeExternalRequest(ctx)\n}\n\nfunc makeExternalRequest(ctx context.Context) {\n\tclient := &http.Client{\n\t\tTransport: &ochttp.Transport{},\n\t}\n\n\treq, _ := http.NewRequestWithContext(ctx, \"GET\", \"http://example.com\", nil)\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Printf(\"Error making external request: %v\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tlog.Printf(\"External request response: %s\", body)\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that performs HTTP requests with customizable options including TLS configuration, request method, headers, and payload.\n\nFunction Description: The function DoRequest executes HTTP requests with various configurable options. It handles TLS configuration (including insecure mode), sets request headers, processes different HTTP methods, and manages response reading. The function is designed to be flexible for different API interaction scenarios while maintaining security and error handling.\n\nInput:\n- opt (EtcdRequestOption struct) - Configuration options for the HTTP request containing:\n  - Endpoint (string): Base URL for the request\n  - Api (string): API endpoint path\n  - PostData (string): Request payload data\n  - TlsConfig (*tls.Config): TLS configuration (nil for insecure)\n  - Method (string): HTTP method (GET, POST, etc.)\n  - Silent (bool): Unused in current implementation\n\nOutput:\n- (string) - Response body content as string\n- (error) - Error object if request fails, nil on success",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/cdk-team/CDK/pkg/errors\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\tif opt.TlsConfig == nil || len(opt.TlsConfig.Certificates) == 0 || opt.TlsConfig.RootCAs == nil {\n\t\topt.TlsConfig = &tls.Config{InsecureSkipVerify: true}\n\t}\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t},\n\t\tTimeout: time.Duration(5) * time.Second,\n\t}\n\n\trequest, err := http.NewRequest(opt.Method, opt.Endpoint+opt.Api, bytes.NewBuffer([]byte(opt.PostData)))\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found while generate post request in net.http .\"}\n\t}\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(request)\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t} else if err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\treturn string(content), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\tif opt.Endpoint == \"\" || opt.Api == \"\" || opt.Method == \"\" {\n\t\treturn \"\", errors.New(\"missing required fields: Endpoint, Api, or Method\")\n\t}\n\n\turl := opt.Endpoint + opt.Api\n\tvar req *http.Request\n\tvar err error\n\n\tif opt.Method == http.MethodPost || opt.Method == http.MethodPut {\n\t\treq, err = http.NewRequest(opt.Method, url, bytes.NewBuffer([]byte(opt.PostData)))\n\t} else {\n\t\treq, err = http.NewRequest(opt.Method, url, nil)\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tif opt.TlsConfig != nil {\n\t\tclient.Transport = &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t}\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}\n```"
  }
]