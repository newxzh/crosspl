[
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles JSONP requests, serving dynamic JSON data wrapped in a callback function.\n\nFunction Description: The main function initializes an Echo server, sets up middleware for logging and recovery, serves static files from a \"public\" directory, and defines a route (\"/jsonp\") that responds to GET requests with JSONP-formatted data containing a response message, current timestamp, and random number.\n\nInput: None (The function takes no direct input parameters, but the \"/jsonp\" endpoint accepts an optional query parameter \"callback\" specifying the JSONP callback function name)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and serves responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Static(\"/\", \"public\")\n\n\te.GET(\"/jsonp\", func(c echo.Context) error {\n\t\tcallback := c.QueryParam(\"callback\")\n\t\tvar content struct {\n\t\t\tResponse  string    `json:\"response\"`\n\t\t\tTimestamp time.Time `json:\"timestamp\"`\n\t\t\tRandom    int       `json:\"random\"`\n\t\t}\n\t\tcontent.Response = \"Sent via JSONP\"\n\t\tcontent.Timestamp = time.Now().UTC()\n\t\tcontent.Random = rand.Intn(1000)\n\t\treturn c.JSONP(http.StatusOK, callback, &content)\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Static(\"/\", \"public\")\n\n\te.GET(\"/jsonp\", func(c echo.Context) error {\n\t\tcallback := c.QueryParam(\"callback\")\n\t\tif callback == \"\" {\n\t\t\tcallback = \"callback\"\n\t\t}\n\n\t\tresponse := map[string]interface{}{\n\t\t\t\"message\":   \"Hello, JSONP!\",\n\t\t\t\"timestamp\": time.Now().Unix(),\n\t\t\t\"random\":    rand.Intn(100),\n\t\t}\n\n\t\tjsonpResponse := fmt.Sprintf(\"%s(%v);\", callback, response)\n\t\treturn c.String(http.StatusOK, jsonpResponse)\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic routes and includes middleware for logging and recovery.\n\nFunction Description: The main function initializes a new Echo instance, sets up middleware for logging and panic recovery, defines a route handler for the root path (\"/\"), and starts the HTTP server on port 1323.\n\nInput: None (The function takes no direct input parameters; configuration is done internally)\n\nOutput: None (The function does not return any value; it starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\\n\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles POST requests for two different endpoints (/tenhou and /majsoul) to process incoming data and forward it to respective receivers.\n\nStruct Description: The mjHandler struct is a request handler that processes incoming HTTP requests for the Tenhou and Majsoul game platforms, logging errors and forwarding data to appropriate receivers.\n\nFields:\n- log: echo.Logger - Logger for error and info logging\n- tenhouMessageReceiver: *tenhou.MessageReceiver - Receiver for Tenhou game messages\n- majsoulMessageQueue: chan []byte - Channel for buffering Majsoul game messages\n\nMethods:\n- analysisTenhou: (c echo.Context) -> error - Processes POST requests to /tenhou endpoint, reads request body, forwards data to tenhouMessageReceiver, and returns HTTP response\n- analysisMajsoul: (c echo.Context) -> error - Processes POST requests to /majsoul endpoint, reads request body, sends data to majsoulMessageQueue, and returns HTTP response\n\nFunction Description: The runServer function initializes and starts an HTTP server with configurable port and HTTPS options, setting up routes and middleware for the Echo framework.\n\nInput:\n- isHTTPS: bool - Flag indicating whether to use HTTPS\n- port: int - Port number for the server to listen on\n\nOutput:\n- error - Returns any error that occurs during server startup or operation",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/labstack/gommon/log\"\n\tstdLog \"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype mjHandler struct {\n\tlog echo.Logger\n\n\ttenhouMessageReceiver *tenhou.MessageReceiver\n\tmajsoulMessageQueue   chan []byte\n}\n\nfunc (h *mjHandler) analysisTenhou(c echo.Context) error {\n\tdata, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.logError(err)\n\t\treturn c.String(http.StatusBadRequest, err.Error())\n\t}\n\n\th.tenhouMessageReceiver.Put(data)\n\treturn c.NoContent(http.StatusOK)\n}\n\nfunc (h *mjHandler) analysisMajsoul(c echo.Context) error {\n\tdata, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.logError(err)\n\t\treturn c.String(http.StatusBadRequest, err.Error())\n\t}\n\n\th.majsoulMessageQueue <- data\n\treturn c.NoContent(http.StatusOK)\n}\n\nvar h *mjHandler\n\nfunc runServer(isHTTPS bool, port int) (err error) {\n\te := echo.New()\n\te.HideBanner = true\n\te.HidePort = true\n\te.StdLogger = stdLog.New(ioutil.Discard, \"\", 0)\n\te.Logger.SetLevel(log.INFO)\n\n\th = &mjHandler{\n\t\tlog:                   e.Logger,\n\t\ttenhouMessageReceiver: tenhou.NewMessageReceiver(),\n\t\tmajsoulMessageQueue:   make(chan []byte, 100),\n\t}\n\n\te.Use(middleware.Recover())\n\te.Use(middleware.CORS())\n\te.POST(\"/tenhou\", h.analysisTenhou)\n\te.POST(\"/majsoul\", h.analysisMajsoul)\n\n\taddr := \":\" + strconv.Itoa(port)\n\tif !isHTTPS {\n\t\terr = e.Start(addr)\n\t} else {\n\t\terr = startTLS(e, addr)\n\t}\n\treturn err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"tenhou\"\n)\n\ntype mjHandler struct {\n\tlog                  echo.Logger\n\ttenhouMessageReceiver *tenhou.MessageReceiver\n\tmajsoulMessageQueue  chan []byte\n}\n\nfunc (h *mjHandler) analysisTenhou(c echo.Context) error {\n\tbody, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.log.Error(\"Failed to read request body:\", err)\n\t\treturn c.String(http.StatusInternalServerError, \"Internal Server Error\")\n\t}\n\th.tenhouMessageReceiver.Receive(body)\n\treturn c.String(http.StatusOK, \"Tenhou data processed\")\n}\n\nfunc (h *mjHandler) analysisMajsoul(c echo.Context) error {\n\tbody, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.log.Error(\"Failed to read request body:\", err)\n\t\treturn c.String(http.StatusInternalServerError, \"Internal Server Error\")\n\t}\n\th.majsoulMessageQueue <- body\n\treturn c.String(http.StatusOK, \"Majsoul data processed\")\n}\n\nfunc runServer(isHTTPS bool, port int) error {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\thandler := &mjHandler{\n\t\tlog:                  e.Logger,\n\t\ttenhouMessageReceiver: &tenhou.MessageReceiver{},\n\t\tmajsoulMessageQueue:  make(chan []byte, 100),\n\t}\n\n\te.POST(\"/tenhou\", handler.analysisTenhou)\n\te.POST(\"/majsoul\", handler.analysisMajsoul)\n\n\taddress := fmt.Sprintf(\":%d\", port)\n\tif isHTTPS {\n\t\treturn e.StartTLS(address, \"server.crt\", \"server.key\")\n\t}\n\treturn e.Start(address)\n}\n\nfunc main() {\n\tif err := runServer(false, 8080); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Go struct that represents an HTTP server application using the Echo framework, with configurable options and standard middleware.\n\nStruct Description: The `App` struct represents an HTTP server application built on the Echo framework. It encapsulates the Echo engine instance and provides methods to initialize and run the server with common middleware (recovery, logging) and default routes.\n\nFields:\n- Engine: *echo.Echo - The core Echo framework instance that handles HTTP routing and middleware\n- Conf: *conf.Conf - Configuration object for server settings (port, debug mode, etc.)\n\nMethods:\n- NewApp: func(opts ...AppOptions) *App - Constructor that initializes a new App instance with optional configuration. Applies default middleware (recovery, logging) and sets up basic routes.\n  Input: opts ...AppOptions (variadic parameter for configuration options)\n  Output: *App (new App instance)\n\n- Run: func() - Starts the HTTP server using the configured port from Conf. Panics if server fails to start.\n  Input: None\n  Output: None (runs indefinitely until server stops)\n\n- Must: func(error) - Helper function (not shown in reference) that panics on error, typically used for server startup\n  Input: error\n  Output: None",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\toptions := AppOptions{}\n\tfor _, i := range opts {\n\t\toptions = i\n\t\tbreak\n\t}\n\n\toptions.init()\n\n\tengine := echo.New()\n\n\tengine.Debug = conf.UBool(\"debug\")\n\n\tengine.Use(middleware.Recover())\n\n\tengine.GET(\"/favicon.ico\", func(c echo.Context) error {\n\t\treturn c.Redirect(http.StatusMovedPermanently, \"/static/images/favicon.ico\")\n\t})\n\n\tengine.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `${method} | ${status} | ${uri} -> ${latency_human}` + \"\\n\",\n\t}))\n\n\tapp := &App{\n\t\tEngine: engine,\n\t}\n\n\treturn app\n}\n\nfunc (app *App) Run() {\n\tMust(app.Engine.Start(\":\" + app.Conf.UString(\"port\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "```go\npackage main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype AppOptions func(*App)\n\ntype App struct {\n\tEngine *echo.Echo\n\tConf   *Conf\n}\n\ntype Conf struct {\n\tPort     string\n\tDebug    bool\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\te := echo.New()\n\te.Use(middleware.Recover())\n\te.Use(middleware.Logger())\n\n\tapp := &App{\n\t\tEngine: e,\n\t\tConf:   &Conf{Port: \"8080\", Debug: false},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(app)\n\t}\n\n\tapp.Engine.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\treturn app\n}\n\nfunc (a *App) Run() {\n\ta.Must(a.Engine.Start(\":\" + a.Conf.Port))\n}\n\nfunc (a *App) Must(err error) {\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n\nfunc main() {\n\tapp := NewApp()\n\tapp.Run()\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a Go struct that implements an HTTP server with WebSocket support using the Echo framework, capable of handling messages, health checks, and streaming, with optional authentication.\n\nStruct Description: The API struct represents an HTTP server with WebSocket capabilities, message buffering, and authentication support. It handles incoming HTTP requests and WebSocket connections while managing message broadcasting and logging.\n\nFields:\n\nMessages: [ring.Ring] - A ring buffer for storing messages with configurable capacity\nRWMutex: [sync.RWMutex] - Read-write mutex for thread-safe operations on shared data\nConfig: [*bridge.Config] - Configuration object containing server settings and parameters\nmrouter: [*melody.Melody] - WebSocket router for handling WebSocket connections and messages\n\nMethods:\n\nNew: [func(cfg *bridge.Config) bridge.Bridger] -> [bridge.Bridger] - Constructor that initializes the API instance, sets up routes, and starts the HTTP server\nhandleWebsocketMessage: [func(message config.Message, s *melody.Session)] -> [void] - Handles incoming WebSocket messages, prepares them for broadcasting, and sends to remote channel\nhandleWebsocket: [func(c echo.Context) error] -> [error] - WebSocket handler that manages WebSocket connections using the melody router\nhandleHealthcheck: [func(c echo.Context) error] -> [error] - Health check endpoint handler (implied by route registration)\nhandleMessages: [func(c echo.Context) error] -> [error] - Messages endpoint handler (implied by route registration)\nhandleStream: [func(c echo.Context) error] -> [error] - Stream endpoint handler (implied by route registration)\nhandlePostMessage: [func(c echo.Context) error] -> [error] - Message posting endpoint handler (implied by route registration)",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/olahol/melody\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype API struct {\n\tMessages ring.Ring\n\tsync.RWMutex\n\t*bridge.Config\n\tmrouter *melody.Melody\n}\n\nfunc New(cfg *bridge.Config) bridge.Bridger {\n\tb := &API{Config: cfg}\n\te := echo.New()\n\te.HideBanner = true\n\te.HidePort = true\n\n\tb.mrouter = melody.New()\n\tb.mrouter.HandleMessage(func(s *melody.Session, msg []byte) {\n\t\tmessage := config.Message{}\n\t\terr := json.Unmarshal(msg, &message)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to decode message from byte[] '%s'\", string(msg))\n\t\t\treturn\n\t\t}\n\t\tb.handleWebsocketMessage(message, s)\n\t})\n\tb.mrouter.HandleConnect(func(session *melody.Session) {\n\t\tgreet := b.getGreeting()\n\t\tdata, err := json.Marshal(greet)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to encode message '%v'\", greet)\n\t\t\treturn\n\t\t}\n\t\terr = session.Write(data)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to write message '%s'\", string(data))\n\t\t\treturn\n\t\t}\n\t})\n\n\tb.Messages = ring.Ring{}\n\tif b.GetInt(\"Buffer\") != 0 {\n\t\tb.Messages.SetCapacity(b.GetInt(\"Buffer\"))\n\t}\n\tif b.GetString(\"Token\") != \"\" {\n\t\te.Use(middleware.KeyAuth(func(key string, c echo.Context) (bool, error) {\n\t\t\treturn key == b.GetString(\"Token\"), nil\n\t\t}))\n\t}\n\n\te.GET(\"/api/health\", b.handleHealthcheck)\n\te.GET(\"/api/messages\", b.handleMessages)\n\te.GET(\"/api/stream\", b.handleStream)\n\te.GET(\"/api/websocket\", b.handleWebsocket)\n\te.POST(\"/api/message\", b.handlePostMessage)\n\tgo func() {\n\t\tif b.GetString(\"BindAddress\") == \"\" {\n\t\t\tb.Log.Fatalf(\"No BindAddress configured.\")\n\t\t}\n\t\tb.Log.Infof(\"Listening on %s\", b.GetString(\"BindAddress\"))\n\t\tb.Log.Fatal(e.Start(b.GetString(\"BindAddress\")))\n\t}()\n\treturn b\n}\n\nfunc (b *API) handleWebsocketMessage(message config.Message, s *melody.Session) {\n\tmessage.Channel = \"api\"\n\tmessage.Protocol = \"api\"\n\tmessage.Account = b.Account\n\tmessage.ID = \"\"\n\tmessage.Timestamp = time.Now()\n\n\tdata, err := json.Marshal(message)\n\tif err != nil {\n\t\tb.Log.Errorf(\"failed to encode message for loopback '%v'\", message)\n\t\treturn\n\t}\n\t_ = b.mrouter.BroadcastOthers(data, s)\n\n\tb.Log.Debugf(\"Sending websocket message from %s on %s to gateway\", message.Username, \"api\")\n\tb.Remote <- message\n}\n\nfunc (b *API) handleWebsocket(c echo.Context) error {\n\terr := b.mrouter.HandleRequest(c.Response(), c.Request())\n\tif err != nil {\n\t\tb.Log.Errorf(\"error in websocket handling  '%v'\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/olahol/melody\"\n\t\"container/ring\"\n\t\"bridge\"\n)\n\ntype API struct {\n\tMessages *ring.Ring\n\tRWMutex  sync.RWMutex\n\tConfig   *bridge.Config\n\tmrouter  *melody.Melody\n}\n\nfunc New(cfg *bridge.Config) bridge.Bridger {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\tapi := &API{\n\t\tMessages: ring.New(cfg.MessageBufferSize),\n\t\tConfig:   cfg,\n\t\tmrouter:  melody.New(),\n\t}\n\n\te.GET(\"/ws\", api.handleWebsocket)\n\te.GET(\"/health\", api.handleHealthcheck)\n\te.GET(\"/messages\", api.handleMessages)\n\te.GET(\"/stream\", api.handleStream)\n\te.POST(\"/message\", api.handlePostMessage)\n\n\tgo func() {\n\t\te.Start(cfg.ServerAddress)\n\t}()\n\n\treturn api\n}\n\nfunc (api *API) handleWebsocketMessage(message bridge.Message, s *melody.Session) {\n\tapi.RWMutex.Lock()\n\tdefer api.RWMutex.Unlock()\n\tapi.Messages.Value = message\n\tapi.Messages = api.Messages.Next()\n\tapi.mrouter.Broadcast([]byte(message.Content))\n}\n\nfunc (api *API) handleWebsocket(c echo.Context) error {\n\treturn api.mrouter.HandleRequest(c.Response(), c.Request())\n}\n\nfunc (api *API) handleHealthcheck(c echo.Context) error {\n\treturn c.JSON(http.StatusOK, map[string]string{\"status\": \"healthy\"})\n}\n\nfunc (api *API) handleMessages(c echo.Context) error {\n\tapi.RWMutex.RLock()\n\tdefer api.RWMutex.RUnlock()\n\tvar messages []bridge.Message\n\tapi.Messages.Do(func(x interface{}) {\n\t\tif x != nil {\n\t\t\tmessages = append(messages, x.(bridge.Message))\n\t\t}\n\t})\n\treturn c.JSON(http.StatusOK, messages)\n}\n\nfunc (api *API) handleStream(c echo.Context) error {\n\treturn api.mrouter.HandleRequest(c.Response(), c.Request())\n}\n\nfunc (api *API) handlePostMessage(c echo.Context) error {\n\tvar message bridge.Message\n\tif err := c.Bind(&message); err != nil {\n\t\treturn err\n\t}\n\tapi.handleWebsocketMessage(message, nil)\n\treturn c.JSON(http.StatusOK, map[string]string{\"status\": \"message received\"})\n}\n\nfunc main() {\n\tcfg := &bridge.Config{\n\t\tServerAddress:    \":8080\",\n\t\tMessageBufferSize: 100,\n\t}\n\tNew(cfg)\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Implement an auto-managed HTTP provider in Go using the Echo framework that can dynamically start/stop an HTTP server with health check capabilities.\n\nStruct Description: AutoManagedProvider is a struct that manages an Echo-based HTTP server with automatic startup/shutdown capabilities and provides health check endpoints.\n\nFields:\n- activeProvider: *echo.Echo - The Echo HTTP server instance\n- activeProviderRunning: bool - Flag indicating if the server is currently running\n- activeProviderTesting: bool - Flag indicating if the server is in testing mode\n- httpClient: *http.Client - HTTP client used for internal communications\n- autoManagePort: int - Port number for the managed HTTP server\n\nMethods:\n- NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider - Constructor that creates a new AutoManagedProvider with configuration\n- UpdateTTL() - Manages the server lifecycle (starts if not running, stops if shutdown)\n- isShutdown() bool - Checks if the server should be shutdown (returns bool)\n- getCurrentNode() interface{} - Returns current node information for health checks (returns interface{})",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider        *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient            *http.Client\n\tautoManagePort        int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyFromEnvironment,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   5 * time.Second,\n\t\t\tKeepAlive: 5 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          10,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxConnsPerHost:       10,\n\t}\n\n\thttpClient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   2 * time.Second,\n\t}\n\n\tp := &AutoManagedProvider{\n\t\thttpClient:            httpClient,\n\t\tautoManagePort:        autoManPort,\n\t\tactiveProviderRunning: false,\n\t}\n\n\treturn p\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n\tif p.isShutdown() && p.activeProviderRunning {\n\t\tp.activeProvider.Close()\n\t\treturn\n\t}\n\n\tif p.activeProviderRunning {\n\t\treturn\n\t}\n\n\tif !p.activeProviderTesting {\n\t\tp.activeProvider = echo.New()\n\t\tp.activeProvider.HideBanner = true\n\t\tp.activeProvider.GET(\"/_health\", func(context echo.Context) error {\n\t\t\treturn context.JSON(http.StatusOK, p.getCurrentNode())\n\t\t})\n\t}\n\tgo func() {\n\t\tp.activeProviderRunning = true\n\t\tappURI := fmt.Sprintf(\"0.0.0.0:%d\", p.autoManagePort)\n\t\tp.activeProvider.Start(appURI)\n\t\tp.activeProviderRunning = false\n\t}()\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n\treturn false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider        *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient            *http.Client\n\tautoManagePort        int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\tprovider := &AutoManagedProvider{\n\t\tactiveProvider: echo.New(),\n\t\thttpClient:     &http.Client{},\n\t\tautoManagePort: autoManPort,\n\t}\n\n\tprovider.activeProvider.GET(\"/health\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, provider.getCurrentNode())\n\t})\n\n\tgo func() {\n\t\tticker := time.NewTicker(refreshTTL)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tprovider.UpdateTTL()\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn provider\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n\tif p.isShutdown() {\n\t\tif p.activeProviderRunning {\n\t\t\tp.activeProvider.Shutdown(nil)\n\t\t\tp.activeProviderRunning = false\n\t\t}\n\t} else {\n\t\tif !p.activeProviderRunning {\n\t\t\tgo func() {\n\t\t\t\tp.activeProvider.Start(\":\" + string(p.autoManagePort))\n\t\t\t}()\n\t\t\tp.activeProviderRunning = true\n\t\t}\n\t}\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n\t// Implement logic to determine if the server should be shutdown\n\treturn false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n\t// Implement logic to return current node information\n\treturn map[string]interface{}{\n\t\t\"status\": \"healthy\",\n\t}\n}\n\nfunc main() {\n\tprovider := NewWithConfig(10*time.Second, 8080)\n\t// The provider will manage its lifecycle automatically\n}\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement an HTTP server using the Echo framework in Go that handles workflow-related requests with authentication and specific route handlers.\n\nFunction Description: The function `startWorkflowServer` initializes and starts an HTTP server using the Echo framework. It sets up middleware for authentication, defines route handlers for specific endpoints (`/secrets` and `/trigger`), and starts the server on the specified host and port. The server validates incoming requests using a predefined workflow key and performs specific actions based on the route.\n\nInput:  \n- `host` (string): The host address on which the server will listen.  \n- `port` (uint64): The port number on which the server will listen.  \n\nOutput:  \n- None (The function starts an HTTP server and blocks indefinitely unless an error occurs).  \n\nNote: The function uses global variables (`workflowKey`, `builderKey`, `secretsHit`, `triggerHit`, etc.) and external configurations (`config.Current.File.ServerUrl`), which should be defined elsewhere in the code.  \n\n(Strictly followed the format requirements without inserting irrelevant characters.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/rs/zerolog/log\"\n\t\"github.com/ziflex/lecho/v2\"\n)\n\nfunc startWorkflowServer(host string, port uint64) {\n\te := echo.New()\n\te.HideBanner = true\n\tlogger := lecho.From(log.Logger)\n\te.Logger = logger\n\te.Use(lecho.Middleware(lecho.Config{Logger: logger})\n\n\tkeyAuth := middleware.KeyAuth(func(s string, c echo.Context) (bool, error) {\n\t\treturn s == workflowKey, nil\n\t})\n\n\teg := e.Group(\"\", keyAuth)\n\n\teg.POST(\"/secrets\", func(c echo.Context) error {\n\t\tsecretsHit = true\n\t\tparams, err := c.FormParams()\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tfor key, val := range params {\n\t\t\tswitch key {\n\t\t\tcase \"SECRET_KEY\":\n\t\t\t\tif val[0] != builderKey {\n\t\t\t\t\tlog.Fatal().Msg(\"bad key\")\n\t\t\t\t}\n\t\t\tcase \"SECRET_URL\":\n\t\t\t\tif val[0] != config.Current.File.ServerUrl {\n\t\t\t\t\tlog.Fatal().Msg(\"bad url\")\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tlog.Fatal().Msg(\"unknown secret\")\n\t\t\t}\n\t\t}\n\t\treturn c.NoContent(200)\n\t})\n\n\teg.POST(\"/trigger\", func(c echo.Context) error {\n\t\ttriggerHit = true\n\t\treturn c.NoContent(200)\n\t})\n\n\tlog.Fatal().Err(e.Start(fmt.Sprintf(\"%s:%d\", host, port))).Send()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nvar (\n\tworkflowKey string\n\tbuilderKey  string\n\tsecretsHit  int\n\ttriggerHit  int\n)\n\nfunc startWorkflowServer(host string, port uint64) {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Use(middleware.KeyAuth(func(key string, c echo.Context) (bool, error) {\n\t\treturn key == workflowKey, nil\n\t}))\n\n\te.GET(\"/secrets\", func(c echo.Context) error {\n\t\tsecretsHit++\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Secrets accessed\"})\n\t})\n\n\te.POST(\"/trigger\", func(c echo.Context) error {\n\t\ttriggerHit++\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Workflow triggered\"})\n\t})\n\n\te.Logger.Fatal(e.Start(host + \":\" + string(port)))\n}\n\nfunc main() {\n\tworkflowKey = \"your-workflow-key\"\n\tbuilderKey = \"your-builder-key\"\n\tstartWorkflowServer(\"localhost\", 8080)\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user authentication with JWT tokens. The server should have routes for login, accessible content, and restricted content that requires JWT authentication.\n\nFunction Description: The main function initializes an Echo server, configures middleware for logging and recovery, sets up route handlers for login and accessible content, and creates a restricted route group that requires JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger its handlers)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately but are referenced in this main function. The JWT configuration uses a custom claims structure (jwtCustomClaims) which should also be defined elsewhere.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tconfig := middleware.JWTConfig{\n\t\tClaims:     &jwtCustomClaims{},\n\t\tSigningKey: []byte(\"secret\"),\n\t}\n\tr.Use(middleware.JWTWithConfig(config))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype jwtCustomClaims struct {\n\tName  string `json:\"name\"`\n\tAdmin bool   `json:\"admin\"`\n\tjwt.StandardClaims\n}\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/accessible\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tr.Use(middleware.JWTWithConfig(middleware.JWTConfig{\n\t\tSigningKey: []byte(\"secret\"),\n\t\tClaims:     &jwtCustomClaims{},\n\t}))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc login(c echo.Context) error {\n\tusername := c.FormValue(\"username\")\n\tpassword := c.FormValue(\"password\")\n\n\tif username == \"jon\" && password == \"shhh!\" {\n\t\tclaims := &jwtCustomClaims{\n\t\t\t\"Jon Snow\",\n\t\t\ttrue,\n\t\t\tjwt.StandardClaims{\n\t\t\t\tExpiresAt: time.Now().Add(time.Hour * 72).Unix(),\n\t\t\t},\n\t\t}\n\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\t\tt, err := token.SignedString([]byte(\"secret\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, echo.Map{\n\t\t\t\"token\": t,\n\t\t})\n\t}\n\n\treturn echo.ErrUnauthorized\n}\n\nfunc accessible(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Accessible\")\n}\n\nfunc restricted(c echo.Context) error {\n\tuser := c.Get(\"user\").(*jwt.Token)\n\tclaims := user.Claims.(*jwtCustomClaims)\n\tname := claims.Name\n\treturn c.String(http.StatusOK, \"Welcome \"+name+\"!\")\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various API endpoints for a Vault management system, including authentication, token management, secret management, and more.\n\nFunction Description: The StartListener function initializes and starts an Echo HTTP server with configured routes and middleware. It sets up various API endpoints for Vault operations, applies middleware for logging, recovery, and request handling, and serves static assets if provided. The server can be started with or without TLS based on configuration.\n\nInput:\n- listener: config.ListenerConfig - Configuration for the server listener including address and TLS settings\n- assets: *rice.Box - Optional box containing static assets to be served by the server\n\nOutput: None (the function starts the server which runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\t\"log\"\n\n\t\"github.com/caiyeon/goldfish/config\"\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\te        *echo.Echo\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te = echo.New()\n\te.HideBanner = true\n\te.Server.ReadTimeout = 10 * time.Second\n\te.Server.WriteTimeout = 2 * time.Minute\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.BodyLimit(\"32M\"))\n\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\tLevel: 5,\n\t}))\n\n\te.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\tc.Response().Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\tif assets != nil {\n\t\tassetHandler := http.FileServer(assets.HTTPBox())\n\t\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\t\te.GET(\"/assets/css/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/js/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/fonts/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/img/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t}\n\n\te.GET(\"/v1/health\", handlers.Health())\n\te.GET(\"/v1/vaulthealth\", handlers.VaultHealth())\n\te.POST(\"/v1/bootstrap\", handlers.Bootstrap())\n\n\te.POST(\"/v1/login\", handlers.Login())\n\te.POST(\"/v1/login/renew-self\", handlers.RenewSelf())\n\n\te.GET(\"/v1/token/accessors\", handlers.GetTokenAccessors())\n\te.POST(\"/v1/token/lookup-accessor\", handlers.LookupTokenByAccessor())\n\te.POST(\"/v1/token/revoke-accessor\", handlers.RevokeTokenByAccessor())\n\te.POST(\"/v1/token/revoke-self\", handlers.RevokeSelf())\n\te.POST(\"/v1/token/create\", handlers.CreateToken())\n\te.GET(\"/v1/token/listroles\", handlers.ListRoles())\n\te.GET(\"/v1/token/role\", handlers.GetRole())\n\n\te.GET(\"/v1/userpass/users\", handlers.GetUserpassUsers())\n\te.POST(\"/v1/userpass/delete\", handlers.DeleteUserpassUser())\n\n\te.GET(\"/v1/approle/roles\", handlers.GetApproleRoles())\n\te.POST(\"/v1/approle/delete\", handlers.DeleteApproleRole())\n\n\te.GET(\"/v1/ldap/groups\", handlers.GetLDAPGroups())\n\te.GET(\"/v1/ldap/users\", handlers.GetLDAPUsers())\n\n\te.GET(\"/v1/policy\", handlers.GetPolicy())\n\te.DELETE(\"/v1/policy\", handlers.DeletePolicy())\n\te.GET(\"/v1/policy-capabilities\", handlers.PolicyCapabilities())\n\n\te.GET(\"/v1/request\", handlers.GetRequest())\n\te.POST(\"/v1/request/add\", handlers.AddRequest())\n\te.POST(\"/v1/request/approve\", handlers.ApproveRequest())\n\te.DELETE(\"/v1/request/reject\", handlers.RejectRequest())\n\n\te.GET(\"/v1/transit\", handlers.TransitInfo())\n\te.POST(\"/v1/transit/encrypt\", handlers.EncryptString())\n\te.POST(\"/v1/transit/decrypt\", handlers.DecryptString())\n\n\te.GET(\"/v1/mount\", handlers.GetMount())\n\te.POST(\"/v1/mount\", handlers.ConfigMount())\n\n\te.GET(\"/v1/secrets\", handlers.GetSecrets())\n\te.POST(\"/v1/secrets\", handlers.PostSecrets())\n\te.DELETE(\"/v1/secrets\", handlers.DeleteSecrets())\n\n\te.GET(\"/v1/bulletins\", handlers.GetBulletins())\n\n\te.POST(\"/v1/wrapping/wrap\", handlers.WrapHandler())\n\te.POST(\"/v1/wrapping/unwrap\", handlers.UnwrapHandler())\n\n\tif listener.Tls_disable {\n\t\te.Logger.Fatal(e.Start(listener.Address))\n\t\treturn\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/GeertJohan/go.rice\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype ListenerConfig struct {\n\tAddress  string\n\tTLSCert  string\n\tTLSKey   string\n}\n\nfunc StartListener(listener ListenerConfig, assets *rice.Box) {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/auth\", handleAuth)\n\te.POST(\"/token\", handleToken)\n\te.GET(\"/secret/:id\", handleGetSecret)\n\te.POST(\"/secret\", handleCreateSecret)\n\te.DELETE(\"/secret/:id\", handleDeleteSecret)\n\n\tif assets != nil {\n\t\tassetHandler := http.FileServer(assets.HTTPBox())\n\t\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", assetHandler)))\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:         listener.Address,\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t}\n\n\tif listener.TLSCert != \"\" && listener.TLSKey != \"\" {\n\t\ttlsConfig := &tls.Config{}\n\t\tserver.TLSConfig = tlsConfig\n\t\te.Logger.Fatal(e.StartTLS(listener.Address, listener.TLSCert, listener.TLSKey))\n\t} else {\n\t\te.Logger.Fatal(e.StartServer(server))\n\t}\n}\n\nfunc handleAuth(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Auth endpoint\")\n}\n\nfunc handleToken(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Token endpoint\")\n}\n\nfunc handleGetSecret(c echo.Context) error {\n\tid := c.Param(\"id\")\n\treturn c.String(http.StatusOK, \"Get secret: \"+id)\n}\n\nfunc handleCreateSecret(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Create secret\")\n}\n\nfunc handleDeleteSecret(c echo.Context) error {\n\tid := c.Param(\"id\")\n\treturn c.String(http.StatusOK, \"Delete secret: \"+id)\n}\n\nfunc main() {\n\tlistener := ListenerConfig{\n\t\tAddress: \":8080\",\n\t}\n\tStartListener(listener, nil)\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a function to retrieve metadata and ETag from Google Compute Engine (GCE) metadata server using a custom HTTP client with specific timeout configurations.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the GCE metadata server to fetch metadata value and its associated ETag. It uses a pre-configured HTTP client with custom timeout settings and adds required headers to the request. The function handles various response scenarios including not found errors and non-200 status codes.\n\nInput:\n- suffix [string]: The metadata path suffix to append to the base metadata URL\n\nOutput:\n- value [string]: The retrieved metadata value\n- etag [string]: The ETag header value from the response\n- err [error]: Error object if any error occurs during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/cloud/internal\"\n)\n\nvar metaClient = &http.Client{\n\tTransport: &internal.Transport{\n\t\tBase: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   750 * time.Millisecond,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 750 * time.Millisecond,\n\t\t},\n\t},\n}\n\nfunc getETag(suffix string) (value, etag string, err error) {\n\thost := os.Getenv(\"GCE_METADATA_HOST\")\n\tif host == \"\" {\n\t\thost = \"169.254.169.254\"\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\tres, err := metaClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\nconst (\n\tmetadataURL = \"http://metadata.google.internal/computeMetadata/v1/\"\n)\n\nfunc getETag(suffix string) (string, string, error) {\n\tclient := &http.Client{\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\treq, err := http.NewRequest(\"GET\", metadataURL+suffix, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treq.Header.Add(\"Metadata-Flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", errors.New(\"metadata not found\")\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tetag := resp.Header.Get(\"ETag\")\n\treturn string(body), etag, nil\n}\n\nfunc main() {\n\tvalue, etag, err := getETag(\"instance/hostname\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Value:\", value)\n\tfmt.Println(\"ETag:\", etag)\n}\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user-related requests with CORS support and logging middleware.\n\nFunction Description: The main function initializes an Echo server instance, configures middleware (logger, recovery, and CORS), sets up route handlers, and starts the server on port 1323.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handler function `getUsers` would need to be implemented separately to handle the GET request to \"/api/users\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"https://labstack.com\", \"https://labstack.net\"},\n\t\tAllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"*\"},\n\t\tAllowMethods: []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc getUsers(c echo.Context) error {\n\t// Placeholder for actual user retrieval logic\n\tusers := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\treturn c.JSON(http.StatusOK, users)\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that includes rate limiting middleware using Sentinel, with custom resource extraction and block fallback handlers.\n\nFunction Description: The function sets up a Fiber web server with Sentinel middleware for rate limiting. The middleware extracts the client's real IP from headers as the resource key and provides a custom JSON response when requests are blocked. The server listens on port 8080 and includes a test endpoint.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import \"github.com/gofiber/fiber/v2\"\n\nfunc Example() {\n\tapp := fiber.New()\n\tapp.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx *fiber.Ctx) string {\n\t\t\t\treturn ctx.GetReqHeaders()[\"X-Real-IP\"]\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx *fiber.Ctx) error {\n\t\t\t\treturn ctx.Status(400).JSON(struct {\n\t\t\t\t\tError string `json:\"error\"`\n\t\t\t\t\tCode  int    `json:\"code\"`\n\t\t\t\t}{\n\t\t\t\t\t\"too many request; the quota used up\",\n\t\t\t\t\t10222,\n\t\t\t\t})\n\t\t\t})),\n\t)\n\n\tapp.Get(\"/test\", func(ctx *fiber.Ctx) error { return nil })\n\t_ = app.Listen(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"github.com/gofiber/fiber/v2\"\n\tsentinel \"github.com/alibaba/sentinel-golang/api\"\n\t\"github.com/alibaba/sentinel-golang/core/base\"\n\t\"github.com/alibaba/sentinel-golang/core/flow\"\n\t\"github.com/alibaba/sentinel-golang/core/config\"\n)\n\nfunc main() {\n\t// Initialize Sentinel\n\terr := sentinel.InitDefault()\n\tif err != nil {\n\t\tlog.Fatalf(\"Sentinel initialization failed: %v\", err)\n\t}\n\n\t// Define rate limiting rules\n\t_, err = flow.LoadRules([]*flow.Rule{\n\t\t{\n\t\t\tResource:        \"GET:/test\",\n\t\t\tMetricType:      flow.QPS,\n\t\t\tCount:           5,\n\t\t\tControlBehavior: flow.Reject,\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load rules: %v\", err)\n\t}\n\n\t// Create a new Fiber app\n\tapp := fiber.New()\n\n\t// Middleware for rate limiting\n\tapp.Use(func(c *fiber.Ctx) error {\n\t\tresourceName := c.Method() + \":\" + c.Path()\n\t\tentry, blockErr := sentinel.Entry(resourceName, sentinel.WithTrafficType(base.Inbound))\n\t\tif blockErr != nil {\n\t\t\t// Blocked, return custom response\n\t\t\treturn c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{\n\t\t\t\t\"error\": \"Too many requests\",\n\t\t\t})\n\t\t}\n\t\tdefer entry.Exit()\n\t\treturn c.Next()\n\t})\n\n\t// Test endpoint\n\tapp.Get(\"/test\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Hello, World!\")\n\t})\n\n\t// Start server\n\tlog.Fatal(app.Listen(\":8080\"))\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that handles health checks and image conversion requests.\n\nFunction Description: The main function initializes and configures a Fiber HTTP server, sets up middleware for ETag generation, defines route handlers for health checks and image conversion, and starts the server on a specified host and port.\n\nInput:\n- Configuration parameters (host, port, read buffer size, concurrency, keepalive settings) are read from the config.Config object\n- No direct input parameters to the main function itself\n\nOutput:\n- Running HTTP server that listens on specified address\n- Console output indicating server status\n- Potential fatal error if server fails to start\n\nThe function performs these key operations:\n1. Initializes Fiber app with custom configuration\n2. Adds ETag middleware\n3. Registers route handlers:\n   - /healthz endpoint for health checks\n   - /* catch-all endpoint for image conversion\n4. Starts the server and handles startup errors",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"webp_server_go/config\"\n\t\"webp_server_go/handler\"\n)\n\nvar app = fiber.New(fiber.Config{\n\tServerHeader:          \"WebP Server Go\",\n\tAppName:               \"WebP Server Go\",\n\tDisableStartupMessage: true,\n\tProxyHeader:           \"X-Real-IP\",\n\tReadBufferSize:        config.Config.ReadBufferSize,\n\tConcurrency:           config.Config.Concurrency,\n\tDisableKeepalive:      config.Config.DisableKeepalive,\n})\n\nfunc main() {\n\tapp.Use(etag.New(etag.Config{\n\t\tWeak: true,\n\t}))\n\n\tlistenAddress := config.Config.Host + \":\" + config.Config.Port\n\n\tapp.Get(\"/healthz\", handler.Healthz)\n\tapp.Get(\"/*\", handler.Convert)\n\n\tfmt.Println(\"WebP Server Go is Running on http://\" + listenAddress)\n\n\tbindErr := app.Listen(listenAddress)\n\tif bindErr != nil {\n\t\tlog.Fatal(\"Error starting server: \", bindErr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/etag\"\n\t\"myapp/config\"\n)\n\nfunc main() {\n\t// Load configuration\n\tcfg := config.Load()\n\n\t// Initialize Fiber app with custom configuration\n\tapp := fiber.New(fiber.Config{\n\t\tReadBufferSize: cfg.ReadBufferSize,\n\t\tConcurrency:    cfg.Concurrency,\n\t\tKeepAlive:      cfg.KeepAlive,\n\t})\n\n\t// Add ETag middleware\n\tapp.Use(etag.New())\n\n\t// Register route handlers\n\tapp.Get(\"/healthz\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(fiber.StatusOK)\n\t})\n\n\tapp.All(\"/*\", func(c *fiber.Ctx) error {\n\t\t// Image conversion logic goes here\n\t\treturn c.SendStatus(fiber.StatusNotImplemented)\n\t})\n\n\t// Start the server\n\taddress := cfg.Host + \":\" + cfg.Port\n\tif err := app.Listen(address); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go for a dashboard application that manages queues and tenants, with optional basic authentication and template rendering capabilities.\n\nStruct Description: The Dashboard struct represents a web dashboard that provides queue management functionality through HTTP endpoints. It uses the Fiber framework for routing and middleware, supports HTML template rendering, and can be configured with basic authentication.\n\nFields:\n\nApp: *fiber.App - The Fiber application instance for handling HTTP requests\nqueue: models.Queue - Interface for queue operations\ntenantManager: models.TenantManager - Interface for tenant management operations\ncfg: config.DashboardConfig - Configuration settings for the dashboard\n\nMethods:\n\nNewDashboard: (queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) -> *Dashboard - Initializes a new Dashboard instance with the given dependencies and configuration, sets up template engine, basic auth middleware, and route handlers\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nQueues: (c *fiber.Ctx) -> error - Handler for GET / route\nNewQueue: (c *fiber.Ctx) -> error - Handler for POST /queues route\nQueue: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue route\nQueueSettings: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/settings route\nSaveQueueSettings: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/settings route\nDeleteQueueConfirm: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/delete route\nDeleteQueue: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/delete route\nMessage: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/messages/:message route",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n\t\"github.com/gofiber/template/html/v2\"\n)\n\ntype Dashboard struct {\n\tApp *fiber.App\n\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tvar engine *html.Engine\n\n\tif cfg.Dev {\n\t\tengine = html.New(\"./dashboard/views\", \".html\")\n\t\tengine.Reload(true)\n\t\tengine.Debug(true)\n\t} else {\n\t\thttp.FS(viewsfs)\n\t\tfs2, err := fs.Sub(viewsfs, \"views\")\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tengine = html.NewFileSystem(http.FS(fs2), \".html\")\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tViews:                 engine,\n\t\tDisableStartupMessage: true,\n\t})\n\n\tif cfg.User != \"\" && cfg.Pass != \"\" {\n\t\tapp.Use(basicauth.New(basicauth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.User: cfg.Pass,\n\t\t\t},\n\t\t}))\n\t}\n\n\td := &Dashboard{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Get(\"/\", d.Queues)\n\tapp.Post(\"/queues\", d.NewQueue)\n\tapp.Get(\"/queues/:queue\", d.Queue)\n\tapp.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"Dashboard: http://localhost:%d\\n\", d.cfg.Port)\n\treturn d.App.Listen(fmt.Sprintf(\":%d\", d.cfg.Port))\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Shutdown()\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "right_result": "package dashboard\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/template/html\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicAuth\"\n\t\"models\"\n\t\"config\"\n)\n\ntype Dashboard struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\tcfg           config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tengine := html.New(\"./views\", \".html\")\n\tapp := fiber.New(fiber.Config{\n\t\tViews: engine,\n\t})\n\n\tif cfg.BasicAuthEnabled {\n\t\tapp.Use(basicAuth.New(basicAuth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.Username: cfg.Password,\n\t\t\t},\n\t\t}))\n\t}\n\n\tdashboard := &Dashboard{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Get(\"/\", dashboard.Queues)\n\tapp.Post(\"/queues\", dashboard.NewQueue)\n\tapp.Get(\"/queues/:queue\", dashboard.Queue)\n\tapp.Get(\"/queues/:queue/settings\", dashboard.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", dashboard.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", dashboard.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", dashboard.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", dashboard.Message)\n\n\treturn dashboard\n}\n\nfunc (d *Dashboard) Start() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Listen(d.cfg.Address)\n\t}\n\treturn nil\n}\n\nfunc (d *Dashboard) Stop() error {\n\treturn d.App.Shutdown()\n}\n\nfunc (d *Dashboard) Queues(c *fiber.Ctx) error {\n\tqueues, err := d.queue.ListQueues()\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).SendString(err.Error())\n\t}\n\treturn c.Render(\"queues\", fiber.Map{\"Queues\": queues})\n}\n\nfunc (d *Dashboard) NewQueue(c *fiber.Ctx) error {\n\tname := c.FormValue(\"name\")\n\terr := d.queue.CreateQueue(name)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).SendString(err.Error())\n\t}\n\treturn c.Redirect(\"/\")\n}\n\nfunc (d *Dashboard) Queue(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tqueue, err := d.queue.GetQueue(queueName)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusNotFound).SendString(err.Error())\n\t}\n\treturn c.Render(\"queue\", fiber.Map{\"Queue\": queue})\n}\n\nfunc (d *Dashboard) QueueSettings(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tsettings, err := d.queue.GetQueueSettings(queueName)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusNotFound).SendString(err.Error())\n\t}\n\treturn c.Render(\"queue_settings\", fiber.Map{\"Settings\": settings})\n}\n\nfunc (d *Dashboard) SaveQueueSettings(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tsettings := c.FormValue(\"settings\")\n\terr := d.queue.UpdateQueueSettings(queueName, settings)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).SendString(err.Error())\n\t}\n\treturn c.Redirect(\"/queues/\" + queueName + \"/settings\")\n}\n\nfunc (d *Dashboard) DeleteQueueConfirm(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\treturn c.Render(\"delete_queue\", fiber.Map{\"QueueName\": queueName})\n}\n\nfunc (d *Dashboard) DeleteQueue(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\terr := d.queue.DeleteQueue(queueName)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).SendString(err.Error())\n\t}\n\treturn c.Redirect(\"/\")\n}\n\nfunc (d *Dashboard) Message(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tmessageID := c.Params(\"message\")\n\tmessage, err := d.queue.GetMessage(queueName, messageID)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusNotFound).SendString(err.Error())\n\t}\n\treturn c.Render(\"message\", fiber.Map{\"Message\": message})\n}"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that initializes and runs a Fiber-based HTTP server with specific routes for job management, while also starting a background engine process.\n\nFunction Description: The function `Run` initializes a Fiber web server with disabled startup messages, sets up three routes for job management (creating new jobs, checking job status, and retrieving jobs), starts a background engine process in a goroutine, and finally starts listening on a specified host and port.\n\nInput: None (uses package-level constants Host and Port for server configuration)\n\nOutput: None (runs indefinitely as a web server, but technically returns an error if the server fails to start)\n\nNote: The function uses package-level constants Host and Port for server configuration and assumes the existence of handler functions NewJob, GetStatus, and GetJob, as well as an Engine function for background processing.",
    "Canonical_solution": "import (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc Run() {\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t})\n\n\tapp.Post(\"/jobs/\", NewJob)\n\tapp.Get(\"/jobs/status/:id\", GetStatus)\n\tapp.Get(\"/jobs/:id\", GetJob)\n\n\tgo Engine()\n\n\tapp.Listen(Host + \":\" + Port)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nconst (\n\tHost = \"127.0.0.1\"\n\tPort = \"3000\"\n)\n\nfunc NewJob(c *fiber.Ctx) error {\n\t// Placeholder for job creation logic\n\treturn c.SendString(\"New job created\")\n}\n\nfunc GetStatus(c *fiber.Ctx) error {\n\t// Placeholder for job status logic\n\treturn c.SendString(\"Job status\")\n}\n\nfunc GetJob(c *fiber.Ctx) error {\n\t// Placeholder for retrieving job logic\n\treturn c.SendString(\"Job details\")\n}\n\nfunc Engine() {\n\t// Placeholder for background engine process\n\tfor {\n\t\t// Background processing logic\n\t}\n}\n\nfunc Run() error {\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t})\n\n\tapp.Post(\"/job\", NewJob)\n\tapp.Get(\"/job/:id/status\", GetStatus)\n\tapp.Get(\"/job/:id\", GetJob)\n\n\tgo Engine()\n\n\taddress := Host + \":\" + Port\n\treturn app.Listen(address)\n}\n\nfunc main() {\n\tif err := Run(); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Implement a Fiber-based HTTP server in Go that handles Amazon SQS (Simple Queue Service) API requests, including authentication, routing, and various SQS operations.\n\nStruct Description: The SQS struct represents an HTTP server that processes Amazon SQS API requests. It uses Fiber framework for HTTP handling and includes queue management functionality with tenant isolation.\n\nFields:\n\nApp: *fiber.App - Fiber application instance for HTTP server\nqueue: models.Queue - Queue management interface\ntenantManager: models.TenantManager - Tenant management interface\ncfg: config.SQSConfig - Configuration for the SQS server\n\nMethods:\n\nNewSQS: (queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) -> *SQS - Constructor that initializes the SQS server with dependencies and configuration\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nAction: (c *fiber.Ctx) -> error - Main request handler that routes SQS API requests based on X-Amz-Target header\nSendMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessage SQS operation\nSendMessageBatch: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessageBatch SQS operation\nReceiveMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles ReceiveMessage SQS operation\nDeleteMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles DeleteMessage SQS operation\nListQueues: (c *fiber.Ctx, tenantId int64) -> error - Handles ListQueues SQS operation\nGetQueueURL: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueUrl SQS operation\nCreateQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles CreateQueue SQS operation\nGetQueueAttributes: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueAttributes SQS operation\nPurgeQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles PurgeQueue SQS operation\nChangeMessageVisibility: (c *fiber.Ctx, tenantId int64) -> error - Handles ChangeMessageVisibility SQS operation\nerrorHandler: (ctx *fiber.Ctx, err error) -> error - Custom error handler for the Fiber app\nauthMiddleware: (c *fiber.Ctx) -> error - Authentication middleware for tenant validation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/valyala/fasthttp/fasthttpadaptor\"\n)\n\ntype SQS struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\ts := &SQS{\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t\tErrorHandler:          s.errorHandler,\n\t\tBodyLimit:             cfg.MaxRequestSize,\n\t})\n\n\tapp.Use(s.authMiddleware)\n\tapp.Post(\"/*\", s.Action)\n\n\ts.App = app\n\n\treturn s\n}\n\nfunc (s *SQS) Start() error {\n\tif !s.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"SQS Endpoint: http://localhost:%d\\n\", s.cfg.Port)\n\treturn s.App.Listen(fmt.Sprintf(\":%d\", s.cfg.Port))\n}\n\nfunc (s *SQS) Stop() error {\n\tif s.cfg.Enabled {\n\t\treturn s.App.Shutdown()\n\t}\n\treturn nil\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\tawsMethodHeader, ok := c.GetReqHeaders()[\"X-Amz-Target\"]\n\tif !ok {\n\t\treturn errors.New(\"X-Amz-Target header not found\")\n\t}\n\tawsMethod := awsMethodHeader[0]\n\n\tvar r *http.Request = &http.Request{}\n\tfasthttpadaptor.ConvertRequest(c.Context(), r, false)\n\n\ttenantId := c.Locals(\"tenantId\").(int64)\n\n\tvar rc error\n\tswitch awsMethod {\n\tcase \"AmazonSQS.SendMessage\":\n\t\trc = s.SendMessage(c, tenantId)\n\tcase \"AmazonSQS.SendMessageBatch\":\n\t\trc = s.SendMessageBatch(c, tenantId)\n\tcase \"AmazonSQS.ReceiveMessage\":\n\t\trc = s.ReceiveMessage(c, tenantId)\n\tcase \"AmazonSQS.DeleteMessage\":\n\t\trc = s.DeleteMessage(c, tenantId)\n\tcase \"AmazonSQS.ListQueues\":\n\t\trc = s.ListQueues(c, tenantId)\n\tcase \"AmazonSQS.GetQueueUrl\":\n\t\trc = s.GetQueueURL(c, tenantId)\n\tcase \"AmazonSQS.CreateQueue\":\n\t\trc = s.CreateQueue(c, tenantId)\n\tcase \"AmazonSQS.GetQueueAttributes\":\n\t\trc = s.GetQueueAttributes(c, tenantId)\n\tcase \"AmazonSQS.PurgeQueue\":\n\t\trc = s.PurgeQueue(c, tenantId)\n\tcase \"AmazonSQS.ChangeMessageVisibility\":\n\t\trc = s.ChangeMessageVisibility(c, tenantId)\n\tdefault:\n\t\trc = NewSQSError(400, \"UnsupportedOperation\", fmt.Sprintf(\"SQS method %s not implemented\", awsMethod))\n\t}\n\n\treturn rc\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "right_result": "package sqs\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/logger\"\n\t\"github.com/gofiber/fiber/v2/middleware/recover\"\n\t\"myapp/models\"\n\t\"myapp/config\"\n)\n\ntype SQS struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\tcfg           config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\tapp := fiber.New(fiber.Config{\n\t\tErrorHandler: errorHandler,\n\t})\n\tapp.Use(logger.New())\n\tapp.Use(recover.New())\n\n\tsqs := &SQS{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Use(sqs.authMiddleware)\n\tapp.Post(\"/\", sqs.Action)\n\n\treturn sqs\n}\n\nfunc (s *SQS) Start() error {\n\tif s.cfg.Enabled {\n\t\treturn s.App.Listen(s.cfg.Address)\n\t}\n\treturn nil\n}\n\nfunc (s *SQS) Stop() error {\n\treturn s.App.Shutdown()\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\ttarget := c.Get(\"X-Amz-Target\")\n\ttenantId, err := s.tenantManager.GetTenantId(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch target {\n\tcase \"SendMessage\":\n\t\treturn s.SendMessage(c, tenantId)\n\tcase \"SendMessageBatch\":\n\t\treturn s.SendMessageBatch(c, tenantId)\n\tcase \"ReceiveMessage\":\n\t\treturn s.ReceiveMessage(c, tenantId)\n\tcase \"DeleteMessage\":\n\t\treturn s.DeleteMessage(c, tenantId)\n\tcase \"ListQueues\":\n\t\treturn s.ListQueues(c, tenantId)\n\tcase \"GetQueueUrl\":\n\t\treturn s.GetQueueURL(c, tenantId)\n\tcase \"CreateQueue\":\n\t\treturn s.CreateQueue(c, tenantId)\n\tcase \"GetQueueAttributes\":\n\t\treturn s.GetQueueAttributes(c, tenantId)\n\tcase \"PurgeQueue\":\n\t\treturn s.PurgeQueue(c, tenantId)\n\tcase \"ChangeMessageVisibility\":\n\t\treturn s.ChangeMessageVisibility(c, tenantId)\n\tdefault:\n\t\treturn fiber.ErrNotFound\n\t}\n}\n\nfunc (s *SQS) SendMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for SendMessage\n\treturn nil\n}\n\nfunc (s *SQS) SendMessageBatch(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for SendMessageBatch\n\treturn nil\n}\n\nfunc (s *SQS) ReceiveMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ReceiveMessage\n\treturn nil\n}\n\nfunc (s *SQS) DeleteMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for DeleteMessage\n\treturn nil\n}\n\nfunc (s *SQS) ListQueues(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ListQueues\n\treturn nil\n}\n\nfunc (s *SQS) GetQueueURL(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for GetQueueURL\n\treturn nil\n}\n\nfunc (s *SQS) CreateQueue(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for CreateQueue\n\treturn nil\n}\n\nfunc (s *SQS) GetQueueAttributes(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for GetQueueAttributes\n\treturn nil\n}\n\nfunc (s *SQS) PurgeQueue(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for PurgeQueue\n\treturn nil\n}\n\nfunc (s *SQS) ChangeMessageVisibility(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ChangeMessageVisibility\n\treturn nil\n}\n\nfunc errorHandler(ctx *fiber.Ctx, err error) error {\n\tcode := fiber.StatusInternalServerError\n\tif e, ok := err.(*fiber.Error); ok {\n\t\tcode = e.Code\n\t}\n\tctx.Status(code)\n\treturn ctx.JSON(fiber.Map{\"error\": err.Error()})\n}\n\nfunc (s *SQS) authMiddleware(c *fiber.Ctx) error {\n\ttenantId, err := s.tenantManager.GetTenantId(c)\n\tif err != nil {\n\t\treturn fiber.ErrUnauthorized\n\t}\n\tc.Locals(\"tenantId\", tenantId)\n\treturn c.Next()\n}"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with static file serving capabilities and a simple ping endpoint.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), serves static files from a binary filesystem at the \"/static\" route, and sets up a GET endpoint at \"/ping\" that returns a simple text response. The server listens on port 8080.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\tassetfs \"github.com/elazarl/go-bindata-assetfs\"\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.Use(static.Serve(\"/static\", BinaryFileSystem(\"data\")))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"embed\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n//go:embed static/*\nvar staticFiles embed.FS\n\nfunc runServer() {\n\trouter := gin.Default()\n\n\trouter.StaticFS(\"/static\", http.FS(staticFiles))\n\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\trouter.Run(\":8080\")\n}\n\nfunc main() {\n\trunServer()\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that implements a session-based counter. The server should increment and persist a counter value across requests using Redis as the session store.\n\nFunction Description: The main function initializes a Gin web server with Redis-based session management and implements a GET endpoint (\"/incr\") that increments and returns a counter value stored in the session.\n\nInput: None (The function takes no direct input parameters. Input comes through HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly. Output is sent as HTTP responses. The \"/incr\" endpoint returns JSON with the current count value)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/redis\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tstore, err := redis.NewStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with caching capabilities for specific routes using in-memory storage.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), configures an in-memory cache store, and sets up a GET route (\"/cache_ping\") that returns a cached response. The cached response includes a \"pong\" message with the current Unix timestamp, and the cache is set to expire after one minute.\n\nInput: None (The function takes no parameters as it sets up the server configuration internally)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8080)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/cache\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tstore := cache.NewInMemoryStore(time.Second)\n\tr.GET(\"/cache_ping\", cache.CachePage(store, time.Minute, func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t}))\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/patrickmn/go-cache\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Initialize in-memory cache with a default expiration time of 1 minute\n\tc := cache.New(1*time.Minute, 10*time.Minute)\n\n\t// Define the /cache_ping route\n\tr.GET(\"/cache_ping\", func(ctx *gin.Context) {\n\t\t// Check if the response is already cached\n\t\tif cachedResponse, found := c.Get(\"cache_ping_response\"); found {\n\t\t\tctx.String(http.StatusOK, cachedResponse.(string))\n\t\t\treturn\n\t\t}\n\n\t\t// Generate the response\n\t\tresponse := fmt.Sprintf(\"pong %d\", time.Now().Unix())\n\n\t\t// Cache the response\n\t\tc.Set(\"cache_ping_response\", response, cache.DefaultExpiration)\n\n\t\t// Return the response\n\t\tctx.String(http.StatusOK, response)\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}\n\nfunc main() {\n\tsetupServer()\n}\n```"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint to handle and respond to header data.\n\nFunction Description: The function initializes a Gin router with default middleware, registers a GET handler for the root path (\"/\"), processes incoming request headers, and returns a JSON response containing specific header values. The server listens on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but processes HTTP request headers internally)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\th := testHeader{}\n\n\t\tif err := c.ShouldBindHeader(&h); err != nil {\n\t\t\tc.JSON(http.StatusOK, err)\n\t\t}\n\n\t\tfmt.Printf(\"%#v\\n\", h)\n\t\tc.JSON(http.StatusOK, gin.H{\"Rate\": h.Rate, \"Domain\": h.Domain})\n\t})\n\n\tr.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tuserAgent := c.GetHeader(\"User-Agent\")\n\t\tacceptLanguage := c.GetHeader(\"Accept-Language\")\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"User-Agent\":      userAgent,\n\t\t\t\"Accept-Language\": acceptLanguage,\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a reverse proxy server using Gin framework in Go that forwards incoming HTTP requests to a load-balanced backend server and returns the response to the client.\n\nFunction Description: The main function initializes a Gin HTTP server that acts as a reverse proxy. It handles incoming GET requests, forwards them to a backend server obtained from a load balancer, and returns the backend's response to the client while preserving all headers.\n\nInput:\n- Path parameter: \":path\" (string) - The path component of the URL to be forwarded to the backend server\n- HTTP request headers and body (automatically handled by Gin context)\n\nOutput:\n- HTTP response with:\n  - Status code from backend server (or 500 if proxy fails)\n  - Headers from backend server\n  - Body content from backend server\n- Error logs if any step in the proxying process fails\n\nThe function uses the Gin context (c *gin.Context) to:\n1. Extract the original request\n2. Parse the load-balanced backend address\n3. Modify the request URL to point to the backend\n4. Use HTTP transport to forward the request\n5. Copy backend response headers to client response\n6. Stream the backend response body to the client",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\tproxy, err := url.Parse(getLoadBalanceAddr())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in parse addr: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = proxy.Scheme\n\t\treq.URL.Host = proxy.Host\n\n\t\ttransport := http.DefaultTransport\n\t\tresp, err := transport.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in roundtrip: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\n\t\tfor k, vv := range resp.Header {\n\t\t\tfor _, v := range vv {\n\t\t\t\tc.Header(k, v)\n\t\t\t}\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbufio.NewReader(resp.Body).WriteTo(c.Writer)\n\t\treturn\n\t})\n\n\tif err := r.Run(ReverseServerAddr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync/atomic\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar backends = []string{\n\t\"http://backend1.example.com\",\n\t\"http://backend2.example.com\",\n}\n\nvar currentBackend uint32\n\nfunc getNextBackend() string {\n\tindex := atomic.AddUint32(&currentBackend, 1)\n\treturn backends[index%uint32(len(backends))]\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/*path\", func(c *gin.Context) {\n\t\tbackendURL, err := url.Parse(getNextBackend())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error parsing backend URL: %v\", err)\n\t\t\tc.Status(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tbackendURL.Path = c.Param(\"path\")\n\t\tproxyReq, err := http.NewRequest(c.Request.Method, backendURL.String(), c.Request.Body)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error creating proxy request: %v\", err)\n\t\t\tc.Status(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tproxyReq.Header = c.Request.Header\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(proxyReq)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error forwarding request to backend: %v\", err)\n\t\t\tc.Status(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tfor key, values := range resp.Header {\n\t\t\tfor _, value := range values {\n\t\t\t\tc.Writer.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\tc.Status(resp.StatusCode)\n\t\t_, err = io.Copy(c.Writer, resp.Body)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error copying response body: %v\", err)\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin-based HTTP server with TLS support, serving HTML content and static assets, while also implementing HTTP/2 server push for static resources.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), sets up static file serving, configures HTML templates, implements HTTP/2 server push for static assets, and starts the server with TLS encryption. It handles requests to the root path (\"/\") by returning HTML content and pushing a JavaScript file to the client.\n\nInput:\n- port (string): The port number to listen on (e.g., \":8080\")\n- certFile (string): Path to the TLS certificate file (e.g., \"./testdata/server.pem\")\n- keyFile (string): Path to the TLS private key file (e.g., \"./testdata/server.key\")\n- htmlTemplates (template.Template): HTML templates to be used for rendering\n- staticDir (string): Directory path for static assets (e.g., \"./assets\")\n\nOutput: None (the function runs indefinitely as a web server)",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Static(\"/assets\", \"./assets\")\n\tr.SetHTMLTemplate(html)\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tif pusher := c.Writer.Pusher(); pusher != nil {\n\t\t\tif err := pusher.Push(\"/assets/app.js\", nil); err != nil {\n\t\t\t\tlog.Printf(\"Failed to push: %v\", err)\n\t\t\t}\n\t\t}\n\t\tc.HTML(200, \"https\", gin.H{\n\t\t\t\"status\": \"success\",\n\t\t})\n\t})\n\n\tr.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc runServer(port, certFile, keyFile string, htmlTemplates *template.Template, staticDir string) {\n\trouter := gin.Default()\n\n\t// Set HTML templates\n\trouter.SetHTMLTemplate(htmlTemplates)\n\n\t// Serve static files\n\trouter.Static(\"/static\", staticDir)\n\n\t// Handle root path\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tif pusher := c.Writer.Pusher(); pusher != nil {\n\t\t\t// Use HTTP/2 server push\n\t\t\tif err := pusher.Push(\"/static/app.js\", nil); err != nil {\n\t\t\t\tc.String(http.StatusInternalServerError, \"Failed to push: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.HTML(http.StatusOK, \"index.html\", nil)\n\t})\n\n\t// Start the server with TLS\n\tif err := router.RunTLS(port, certFile, keyFile); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\thtmlTemplates := template.Must(template.ParseFiles(\"templates/index.html\"))\n\trunServer(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\", htmlTemplates, \"./assets\")\n}\n```"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, save the uploaded file to the server, and return a success message with the file details and form fields.\n\nFunction Description: The function initializes a Gin router, configures it to handle multipart form uploads (with a maximum size limit), serves static files from a public directory, and sets up a POST endpoint for file uploads. The endpoint binds the incoming request to a struct containing the file and form fields, saves the file to the server, and returns a success message with the file name and form field values.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it sends HTTP responses through the Gin context)\n\nNote: The function assumes the existence of a `BindFile` struct type which should contain at least these fields:\n- File: *multipart.FileHeader - The uploaded file\n- Name: string - A form field value\n- Email: string - A form field value",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\n\t\tif err := c.ShouldBind(&bindFile); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfile := bindFile.File\n\t\tdst := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"upload file err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, bindFile.Name, bindFile.Email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype BindFile struct {\n\tFile  *multipart.FileHeader `form:\"file\" binding:\"required\"`\n\tName  string                `form:\"name\" binding:\"required\"`\n\tEmail string                `form:\"email\" binding:\"required\"`\n}\n\nfunc setupRouter() *gin.Engine {\n\trouter := gin.Default()\n\n\t// Set a lower memory limit for multipart forms (default is 32 MiB)\n\trouter.MaxMultipartMemory = 8 << 20 // 8 MiB\n\n\t// Serve static files from the \"public\" directory\n\trouter.Static(\"/public\", \"./public\")\n\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\n\t\t// Bind the request to the BindFile struct\n\t\tif err := c.ShouldBind(&bindFile); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\t// Save the uploaded file to the server\n\t\tfilePath := filepath.Join(\"uploads\", bindFile.File.Filename)\n\t\tif err := c.SaveUploadedFile(bindFile.File, filePath); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\t// Return a success message with file details and form fields\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"file\":    bindFile.File.Filename,\n\t\t\t\"name\":    bindFile.Name,\n\t\t\t\"email\":   bindFile.Email,\n\t\t})\n\t})\n\n\treturn router\n}\n\nfunc main() {\n\trouter := setupRouter()\n\tif err := router.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"Failed to run server: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests for inventory operations, specifically for trying inventory items. The server should parse JSON input, process the inventory try operation, and return appropriate JSON responses.\n\nFunction Description: The main function sets up a Gin HTTP server with a single POST endpoint \"/service-c/try\" that accepts JSON inventory data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- HTTP POST request with JSON body containing inventory data (structure not shown in reference code but implied to have an ID field)\n- Gin context object providing request/response capabilities\n\nOutput:\n- Success case (200 status):\n  ```json\n  {\n    \"success\": true,\n    \"message\": \"inventory [ID] tried!\"\n  }\n  ```\n- Error case (400 status):\n  ```json\n  {\n    \"success\": false,\n    \"message\": \"[error description]\"\n  }\n  ```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-c/try\", func(context *gin.Context) {\n\t\tinv := &Inventory{}\n\t\terr := context.BindJSON(inv)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"inventory %d tried!\", inv.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"inventory %d tried!\", inv.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8082\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype InventoryRequest struct {\n\tID string `json:\"id\" binding:\"required\"`\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-c/try\", func(c *gin.Context) {\n\t\tvar req InventoryRequest\n\t\tif err := c.ShouldBindJSON(&req); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"success\": false,\n\t\t\t\t\"message\": \"Invalid request data\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Simulate inventory try operation\n\t\t// Here you would typically interact with your inventory system\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"success\": true,\n\t\t\t\"message\": \"inventory \" + req.ID + \" tried!\",\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, and serves static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling multipart form uploads. It processes uploaded files along with name and email form fields, saves the files to the server, and returns a success message.\n\nInput: None (The function takes no direct input parameters but handles HTTP requests with the following expected inputs:\n- POST /upload requests containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - Multipart files: \"files\" (array of files)\n- GET requests for static files from the \"./public\" directory)\n\nOutput: None (The function doesn't return any value but produces the following outputs:\n- For successful uploads: HTTP 200 response with success message\n- For errors: HTTP 400 responses with error messages\n- Static file serving for requests to the root path)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\t// Serve static files from the \"./public\" directory\n\trouter.Static(\"/public\", \"./public\")\n\n\t// Handle file uploads\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid form data\"})\n\t\t\treturn\n\t\t}\n\n\t\tfiles := form.File[\"files\"]\n\t\tif len(files) == 0 {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No files uploaded\"})\n\t\t\treturn\n\t\t}\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, \"./uploads/\"+filename); err != nil {\n\t\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to save file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": fmt.Sprintf(\"Successfully uploaded files for %s (%s)\", name, email)})\n\t})\n\n\trouter.Run(\":8080\")\n}\n\nfunc main() {\n\tsetupServer()\n}\n```"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but the server configuration is hardcoded in the function)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The static file directory (\"/tmp\") and server port (\":8080\") are hardcoded in this implementation but could be made configurable through parameters in a more flexible version.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\n\t// Serve static files from the /tmp directory\n\trouter.Static(\"/static\", \"/tmp\")\n\n\t// Handle GET request at the root path\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"Hello, World!\",\n\t\t})\n\t})\n\n\t// Start the server on port 8080\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle GET requests, extract request information, and return a JSON response containing the request path and IP details.\n\nFunction Description: The function initializes a Gin router with default middleware, registers a GET route handler that captures the request path and IP information (including RemoteAddr, X-Forwarded-For, and X-Real-Ip headers), and returns this information as a JSON response. The server runs on a specified address.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return any value directly, but sends JSON responses to HTTP clients and may log errors during server startup)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nconst (\n\tAddr = \"127.0.0.1:2003\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\turlPath := fmt.Sprintf(\"http://%s%s\", Addr, req.URL.Path)\n\t\trealIP := fmt.Sprintf(\"RemoteAddr=%s,X-Forwarded-For=%v,X-Real-Ip=%v\", req.RemoteAddr, req.Header.Get(\"X-Forwarded-For\"), req.Header.Get(\"X-Real-Ip\"))\n\t\tc.JSON(200, gin.H{\n\t\t\t\"path\": urlPath,\n\t\t\t\"ip\":   realIP,\n\t\t})\n\t})\n\n\tif err := r.Run(Addr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/info\", func(c *gin.Context) {\n\t\tclientIP := c.ClientIP()\n\t\trequestPath := c.Request.URL.Path\n\t\tremoteAddr := c.Request.RemoteAddr\n\t\txForwardedFor := c.GetHeader(\"X-Forwarded-For\")\n\t\txRealIP := c.GetHeader(\"X-Real-Ip\")\n\n\t\tresponse := gin.H{\n\t\t\t\"path\":            requestPath,\n\t\t\t\"client_ip\":       clientIP,\n\t\t\t\"remote_addr\":     remoteAddr,\n\t\t\t\"x_forwarded_for\": xForwardedFor,\n\t\t\t\"x_real_ip\":       xRealIP,\n\t\t}\n\n\t\tc.JSON(http.StatusOK, response)\n\t})\n\n\trouter.Run(\":8080\")\n}\n\nfunc main() {\n\tsetupServer()\n}"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic string response.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler for the \"/ping\" endpoint, and starts the server on the default port (8080). When a GET request is made to \"/ping\", it responds with the string \"pong\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything; it starts an HTTP server that runs until interrupted)",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, which includes session management using Redis for storing and incrementing a counter value.\n\nFunction Description: The function sets up a Gin web server with Redis-based session management. It provides a single endpoint \"/incr\" that increments a counter stored in the session and returns the current count in JSON format. The server runs on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly, but sends JSON responses to HTTP requests and runs the web server indefinitely)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/redis\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tstore, err := redis.NewStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles multiple API routes with different authentication requirements and groups related endpoints together.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), organizes routes into logical groups with different authentication requirements, and starts the server. It demonstrates route grouping, middleware chaining, and modular route registration.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens for incoming requests)\n\nNote: The actual route handlers are expected to be implemented in separate packages (users, articles) and registered through their respective Register functions. The server runs indefinitely until interrupted.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tv1 := r.Group(\"/api\")\n\tusers.UsersRegister(v1.Group(\"/users\"))\n\tv1.Use(users.AuthMiddleware(false))\n\tarticles.ArticlesAnonymousRegister(v1.Group(\"/articles\"))\n\tarticles.TagsAnonymousRegister(v1.Group(\"/tags\"))\n\n\tv1.Use(users.AuthMiddleware(true))\n\tusers.UserRegister(v1.Group(\"/user\"))\n\tusers.ProfileRegister(v1.Group(\"/profiles\"))\n\n\tarticles.ArticlesRegister(v1.Group(\"/articles\"))\n\n\ttestAuth := r.Group(\"/api/ping\")\n\n\ttestAuth.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\n\tr.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Middleware for authentication\n\tauthMiddleware := func(c *gin.Context) {\n\t\t// Example authentication logic\n\t\ttoken := c.GetHeader(\"Authorization\")\n\t\tif token != \"valid-token\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"unauthorized\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n\n\t// Public routes\n\tpublic := r.Group(\"/public\")\n\t{\n\t\tpublic.GET(\"/info\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Public Information\"})\n\t\t})\n\t}\n\n\t// User routes with authentication\n\tusers := r.Group(\"/users\")\n\tusers.Use(authMiddleware)\n\t{\n\t\tusers.GET(\"/profile\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"User Profile\"})\n\t\t})\n\t\tusers.POST(\"/update\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"User Update\"})\n\t\t})\n\t}\n\n\t// Article routes with authentication\n\tarticles := r.Group(\"/articles\")\n\tarticles.Use(authMiddleware)\n\t{\n\t\tarticles.GET(\"/list\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Article List\"})\n\t\t})\n\t\tarticles.POST(\"/create\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Article Created\"})\n\t\t})\n\t}\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses to clients and runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong %d\", time.Now().Unix())\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a Go function that sets up a Gin-based HTTP server with specific API endpoints for handling web information requests. The function should initialize the server, define route handlers, and process incoming requests to return appropriate JSON responses.\n\nFunction Description: The `api` function initializes a Gin HTTP server with default middleware (Logger and Recovery). It defines two main routes: a root endpoint (\"/\") that returns a simple status message, and an API group (\"/api\") with endpoints for handling web information requests (\"/info\" for both GET and POST methods). The function processes incoming requests, validates input, executes business logic through `RunJob`, and returns structured JSON responses.\n\nInput:\n- `options` (*common.ENOptions): A pointer to an options structure containing configuration parameters for the application. This parameter is used to pass various settings to the business logic processing.\n\nOutput:\n- None (direct output via HTTP responses)\n- The function starts an HTTP server that listens on port 31000 and handles incoming requests\n- Returns error if server fails to start (logged via gologger)\n\nThe function does not explicitly return any values but sends HTTP responses in JSON format with the following possible structures:\n1. Success response (200 status code):\n```json\n{\n  \"code\": 200,\n  \"message\": \"ok\",\n  \"data\": [result_data]\n}\n```\n2. Error responses (400/500 status codes):\n```json\n{\n  \"code\": [error_code],\n  \"message\": \"[error_message]\"\n}\n```",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/wgpsec/ENScan/common\"\n\t\"github.com/wgpsec/ENScan/common/gologger\"\n)\nfunc api(options *common.ENOptions) {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"code\":    200,\n\t\t\t\"message\": \"OK\",\n\t\t})\n\t})\n\twebInfo := func(c *gin.Context) {\n\t\tvar w webOp\n\t\terr := c.ShouldBind(&w)\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\n\t\t\t\t\"code\":    500,\n\t\t\t\t\"message\": \"\u6570\u636e\u7ed1\u5b9a\u5f02\u5e38\uff01\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif w.OrgName == \"\" {\n\t\t\tc.JSON(400, gin.H{\n\t\t\t\t\"code\":    400,\n\t\t\t\t\"message\": \"\u8bf7\u8f93\u5165\u67e5\u8be2\u6761\u4ef6\uff01\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif w.Branch {\n\t\t\toptions.IsGetBranch = true\n\t\t}\n\t\toptions.KeyWord = w.OrgName\n\t\toptions.GetFlags = w.Filed\n\t\toptions.ScanType = w.ScanType\n\t\toptions.InvestNum = w.Invest\n\t\toptions.IsSupplier = w.Supplier\n\t\toptions.IsHold = w.Holds\n\t\toptions.Deep = w.Depth\n\t\toptions.IsMergeOut = true\n\t\tcommon.Parse(options)\n\t\tdata := RunJob(options)\n\t\tc.JSON(200, gin.H{\n\t\t\t\"code\":    200,\n\t\t\t\"message\": \"ok\",\n\t\t\t\"data\":    data,\n\t\t})\n\t}\n\ta := r.Group(\"/api\")\n\t{\n\t\ta.GET(\"/info\", webInfo)\n\t\ta.POST(\"/info\", webInfo)\n\t}\n\terr := r.Run(\":31000\")\n\tif err != nil {\n\t\tgologger.Error().Msgf(\"API\u670d\u52a1\u542f\u52a8\u5931\u8d25\uff01\")\n\t\tgologger.Fatal().Msgf(err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/projectdiscovery/gologger\"\n\t\"your_project/common\"\n)\n\nfunc api(options *common.ENOptions) {\n\trouter := gin.Default()\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"code\":    200,\n\t\t\t\"message\": \"ok\",\n\t\t})\n\t})\n\n\tapiGroup := router.Group(\"/api\")\n\t{\n\t\tapiGroup.GET(\"/info\", func(c *gin.Context) {\n\t\t\tresult, err := RunJob(options)\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\t\"code\":    500,\n\t\t\t\t\t\"message\": err.Error(),\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":    200,\n\t\t\t\t\"message\": \"ok\",\n\t\t\t\t\"data\":    result,\n\t\t\t})\n\t\t})\n\n\t\tapiGroup.POST(\"/info\", func(c *gin.Context) {\n\t\t\tvar inputData map[string]interface{}\n\t\t\tif err := c.ShouldBindJSON(&inputData); err != nil {\n\t\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\t\"code\":    400,\n\t\t\t\t\t\"message\": \"Invalid input\",\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult, err := RunJobWithInput(options, inputData)\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\t\"code\":    500,\n\t\t\t\t\t\"message\": err.Error(),\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":    200,\n\t\t\t\t\"message\": \"ok\",\n\t\t\t\t\"data\":    result,\n\t\t\t})\n\t\t})\n\t}\n\n\tif err := router.Run(\":31000\"); err != nil {\n\t\tgologger.Error().Msgf(\"Failed to start server: %s\", err)\n\t}\n}\n\nfunc RunJob(options *common.ENOptions) ([]interface{}, error) {\n\t// Business logic implementation\n\treturn []interface{}{\"sample data\"}, nil\n}\n\nfunc RunJobWithInput(options *common.ENOptions, inputData map[string]interface{}) ([]interface{}, error) {\n\t// Business logic implementation with input data\n\treturn []interface{}{\"processed data\"}, nil\n}"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a Go function that sets up a basic HTTP server using the Gin framework, with routes for login and home pages, including cookie handling for authentication.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), defines two routes (/login and /home), and starts the server on port 8080. The /login route sets a cookie, while the /home route requires cookie authentication through middleware and returns JSON data.\n\nInput: None (The function takes no input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens indefinitely)\n\nNote: The CookieTool() middleware referenced in the home route would need to be defined separately to verify the cookie set by the login route.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\troute := gin.Default()\n\n\troute.GET(\"/login\", func(c *gin.Context) {\n\t\tc.SetCookie(\"label\", \"ok\", 30, \"/\", \"localhost\", false, true)\n\t\tc.String(200, \"Login success!\")\n\t})\n\n\troute.GET(\"/home\", CookieTool(), func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"data\": \"Your home page\"})\n\t})\n\n\troute.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/login\", func(c *gin.Context) {\n\t\tc.SetCookie(\"auth\", \"authenticated\", 3600, \"/\", \"localhost\", false, true)\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Logged in successfully\"})\n\t})\n\n\tr.GET(\"/home\", CookieTool(), func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome to the home page\"})\n\t})\n\n\tr.Run(\":8080\")\n}\n\nfunc CookieTool() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tcookie, err := c.Cookie(\"auth\")\n\t\tif err != nil || cookie != \"authenticated\" {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint. The endpoint should accept a name parameter, make a gRPC call to a Greeter service, and return the response as JSON. The function should handle both successful responses and errors from the gRPC call.\n\nFunction Description: The function initializes a Gin router with default middleware, establishes a gRPC connection to a Greeter service, and defines a GET endpoint at \"/rest/n/:name\". When called, the endpoint extracts the name parameter, makes a gRPC call to the Greeter service, and returns either the greeting message or an error in JSON format. The server listens on port 8080.\n\nInput: None (The function takes no direct input parameters but relies on incoming HTTP requests to the defined endpoint)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/gin-gonic/examples/grpc/example1/gen/helloworld/v1\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := v1.NewGreeterClient(conn)\n\n\tr := gin.Default()\n\tr.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\n\t\treq := &v1.HelloRequest{Name: name}\n\t\tres, err := client.SayHello(c, req)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"error\": err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"result\": fmt.Sprint(res.Message),\n\t\t})\n\t})\n\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"could not run server: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\n\trouter.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\n\t\treq := &pb.GreetRequest{Name: name}\n\t\tres, err := client.Greet(context.Background(), req)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": res.Message})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles user management with versioned API endpoints and authentication middleware.\n\nFunction Description: The main function initializes a Gin router with versioned API endpoints (/v1 and /v2) for user management. Each version has public GET endpoints and protected POST endpoints that require authentication through middleware.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8081)\n\nMethods:\n\nAuthMiddleWare: () -> gin.HandlerFunc - Returns a Gin middleware function that handles authentication for protected routes\nAddV1User: (*gin.Context) -> None - Handles POST requests to add users for API version 1\nAddV2User: (*gin.Context) -> None - Handles POST requests to add users for API version 2",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tapiV1 := router.Group(\"/v1\")\n\n\tapiV1.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V1 Users\")\n\t})\n\n\tauthV1 := apiV1.Group(\"/\", AuthMiddleWare())\n\n\tauthV1.POST(\"users/add\", AddV1User)\n\n\tapiV2 := router.Group(\"/v2\")\n\n\tapiV2.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V2 Users\")\n\t})\n\n\tauthV2 := apiV2.Group(\"/\", AuthMiddleWare())\n\n\tauthV2.POST(\"users/add\", AddV2User)\n\n\t_ = router.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\n\tv1 := router.Group(\"/v1\")\n\t{\n\t\tv1.GET(\"/users\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"List of users v1\"})\n\t\t})\n\t\tv1.POST(\"/users\", AuthMiddleware(), AddV1User)\n\t}\n\n\tv2 := router.Group(\"/v2\")\n\t{\n\t\tv2.GET(\"/users\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"List of users v2\"})\n\t\t})\n\t\tv2.POST(\"/users\", AuthMiddleware(), AddV2User)\n\t}\n\n\trouter.Run(\":8081\")\n}\n\nfunc AuthMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttoken := c.GetHeader(\"Authorization\")\n\t\tif token != \"Bearer valid-token\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc AddV1User(c *gin.Context) {\n\tvar user map[string]interface{}\n\tif err := c.ShouldBindJSON(&user); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"User added v1\", \"user\": user})\n}\n\nfunc AddV2User(c *gin.Context) {\n\tvar user map[string]interface{}\n\tif err := c.ShouldBindJSON(&user); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"User added v2\", \"user\": user})\n}\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, with endpoints for basic operations including ping, info retrieval, and counter manipulation with thread-safe increment/reset functionality.\n\nFunction Description: The Run function initializes a Gin HTTP server with four API endpoints under the \"/api/v1\" route group. It handles concurrent counter operations safely using mutex locks and logs requests using klog. The server runs on the specified address from the Options parameter.\n\nInput: \n- op *Options: A pointer to an Options struct containing the ListenAddr field specifying the server's listening address (e.g., \":8080\")\n\nOutput:\n- error: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nStruct Description: (Not applicable as the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\nvar (\n\tCount int\n\tMutex sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.Default()\n\n\tapiv1 := r.Group(\"/api/v1\")\n\t{\n\t\tapiv1.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\")\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"pong\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"app3\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.PUT(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount += 1\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app3: %d\", Count),\n\t\t\t})\n\t\t})\n\n\t\tapiv1.DELETE(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount = 0\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app1: %d\", Count),\n\t\t\t})\n\t\t})\n\t}\n\n\treturn r.Run(op.ListenAddr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\ntype Options struct {\n\tListenAddr string\n}\n\nvar (\n\tcounter int\n\tmu      sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.Default()\n\n\tapi := r.Group(\"/api/v1\")\n\t{\n\t\tapi.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Ping request received\")\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t\t})\n\n\t\tapi.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Info request received\")\n\t\t\tc.JSON(http.StatusOK, gin.H{\"info\": \"This is a sample server\"})\n\t\t})\n\n\t\tapi.POST(\"/counter/increment\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Increment request received\")\n\t\t\tmu.Lock()\n\t\t\tcounter++\n\t\t\tmu.Unlock()\n\t\t\tc.JSON(http.StatusOK, gin.H{\"counter\": counter})\n\t\t})\n\n\t\tapi.POST(\"/counter/reset\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Reset request received\")\n\t\t\tmu.Lock()\n\t\t\tcounter = 0\n\t\t\tmu.Unlock()\n\t\t\tc.JSON(http.StatusOK, gin.H{\"counter\": counter})\n\t\t})\n\t}\n\n\tklog.Infof(\"Starting server on %s\", op.ListenAddr)\n\treturn r.Run(op.ListenAddr)\n}\n\nfunc main() {\n\top := &Options{ListenAddr: \":8080\"}\n\tif err := Run(op); err != nil {\n\t\tklog.Fatalf(\"Failed to run server: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that returns a \"pong\" message with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tcurrentTime := time.Now().Unix()\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\":   \"pong\",\n\t\t\t\"timestamp\": currentTime,\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a JSON message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at \"/api/hello\" that returns a JSON response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/api/hello\" endpoint)\n\nOutput: \n- When successful: The server runs indefinitely, listening on port 8080\n- When failing: An error message is printed if the server fails to start\n- HTTP Response: For GET requests to \"/api/hello\", returns a JSON response with status 200 OK: {\"message\": \"Hello, HTTP!\"}",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\n\terr := router.Run(\":8080\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\n\tif err := router.Run(\":8080\"); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a Go struct that provides HTTP client functionality for making GET and POST requests with custom headers and query parameters.\n\nStruct Description: The `request` struct encapsulates HTTP client operations, providing methods to perform GET and POST requests with support for custom headers and query parameters. It handles URL construction, request execution, and response processing.\n\nFields:\n[Note: The reference implementation doesn't show any struct fields, as it's a stateless utility struct]\n\nMethods:\n\nMethod1: HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) -> ([]byte, int, error) - Performs an HTTP GET request to the specified URL with the given query parameters and headers. Returns the response body as bytes, status code, and any error.\n\nMethod2: HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) -> ([]byte, int, error) - Performs an HTTP POST request to the specified URL with the given form data (as query parameters) and headers. Returns the response body as bytes, status code, and any error.\n\nMethod3: QueryBuilder(queryUrl string, queryValues map[string]string) -> string - Helper method that constructs a URL with query parameters from the given base URL and parameter map. Handles URL encoding of parameters.",
    "Canonical_solution": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nvar Request = NewRequest()\n\ntype request struct {\n}\n\nfunc NewRequest() *request {\n\treturn &request{}\n}\n\nfunc (r *request) HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) (body []byte, code int, err error) {\n\treq, err := http.NewRequest(\"GET\", r.QueryBuilder(queryUrl, queryValues), nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tif (headerValues != nil) && (len(headerValues) > 0) {\n\t\tfor key, value := range headerValues {\n\t\t\treq.Header.Set(key, value)\n\t\t}\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn\n\t}\n\tcode = resp.StatusCode\n\tdefer resp.Body.Close()\n\n\tbodyByte, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn bodyByte, code, nil\n}\n\nfunc (r *request) HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) (body []byte, code int, err error) {\n\tif !strings.Contains(queryUrl, \"?\") {\n\t\tqueryUrl += \"?\"\n\t}\n\tqueryString := \"\"\n\tfor queryKey, queryValue := range queryValues {\n\t\tqueryString = queryString + \"&\" + queryKey + \"=\" + url.QueryEscape(queryValue)\n\t}\n\tqueryString = strings.Replace(queryString, \"&\", \"\", 1)\n\n\treq, err := http.NewRequest(\"POST\", queryUrl, strings.NewReader(queryString))\n\tif err != nil {\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tif (headerValues != nil) && (len(headerValues) > 0) {\n\t\tfor key, value := range headerValues {\n\t\t\treq.Header.Set(key, value)\n\t\t}\n\t}\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn\n\t}\n\tcode = resp.StatusCode\n\tdefer resp.Body.Close()\n\n\tbodyByte, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn bodyByte, code, nil\n}\n\nfunc (r *request) QueryBuilder(queryUrl string, queryValues map[string]string) string {\n\tif !strings.Contains(queryUrl, \"?\") {\n\t\tqueryUrl += \"?\"\n\t}\n\n\tqueryString := \"\"\n\tfor queryKey, queryValue := range queryValues {\n\t\tqueryString = queryString + \"&\" + queryKey + \"=\" + url.QueryEscape(queryValue)\n\t}\n\tqueryString = strings.Replace(queryString, \"&\", \"\", 1)\n\tqueryUrl += queryString\n\n\treturn queryUrl\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype request struct{}\n\nfunc (r *request) HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) ([]byte, int, error) {\n\tfullUrl := r.QueryBuilder(queryUrl, queryValues)\n\treq, err := http.NewRequest(\"GET\", fullUrl, nil)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tfor key, value := range headerValues {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, resp.StatusCode, err\n\t}\n\n\treturn body, resp.StatusCode, nil\n}\n\nfunc (r *request) HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) ([]byte, int, error) {\n\tformData := url.Values{}\n\tfor key, value := range queryValues {\n\t\tformData.Set(key, value)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", queryUrl, bytes.NewBufferString(formData.Encode()))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tfor key, value := range headerValues {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, resp.StatusCode, err\n\t}\n\n\treturn body, resp.StatusCode, nil\n}\n\nfunc (r *request) QueryBuilder(queryUrl string, queryValues map[string]string) string {\n\tu, err := url.Parse(queryUrl)\n\tif err != nil {\n\t\treturn queryUrl\n\t}\n\n\tq := u.Query()\n\tfor key, value := range queryValues {\n\t\tq.Set(key, value)\n\t}\n\tu.RawQuery = q.Encode()\n\n\treturn u.String()\n}\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and the message \"pong [current_unix_timestamp]\" when the \"/ping\" endpoint is accessed)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\ttimestamp := time.Now().Unix()\n\t\tmessage := \"pong \" + string(timestamp)\n\t\tc.String(http.StatusOK, message)\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with static file serving capabilities and a simple ping endpoint.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), serves static files from a binary filesystem at the \"/static\" route, and sets up a GET endpoint at \"/ping\" that returns a simple text response. The server listens on port 8080.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\tassetfs \"github.com/elazarl/go-bindata-assetfs\"\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.Use(static.Serve(\"/static\", BinaryFileSystem(\"data\")))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t}\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"embed\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n//go:embed static/*\nvar staticFiles embed.FS\n\nfunc runServer() {\n\tr := gin.Default()\n\n\tr.StaticFS(\"/static\", http.FS(staticFiles))\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tr.Run(\":8080\")\n}\n\nfunc main() {\n\trunServer()\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Go struct that represents a main server application using the Gin web framework, with capabilities for logging configuration, route grouping, and JWT authentication middleware integration.\n\nStruct Description: The Main struct represents a web server application that uses Gin as its web framework. It handles server initialization, route configuration with JWT authentication for protected routes, and serves as the entry point for the application.\n\nFields:\nrouter: *gin.Engine - The Gin engine instance that handles all HTTP routing and middleware\n\nMethods:\ninitServer: () -> error - Initializes the Gin server with configured logging settings (file and console logging based on configuration). Returns error if initialization fails.\nmain: () - Entry point of the application that creates the Main instance, initializes the server, sets up route handlers with JWT authentication for protected routes, and starts the server on the configured port.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/jwt\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\tvar err error\n\n\tif common.Config.EnableGinFileLog {\n\t\tf, _ := os.Create(\"logs/gin.log\")\n\t\tif common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter(os.Stdout, f)\n\t\t} else {\n\t\t\tgin.DefaultWriter = io.MultiWriter(f)\n\t\t}\n\t} else {\n\t\tif !common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter()\n\t\t}\n\t}\n\n\tm.router = gin.Default()\n\n\treturn nil\n}\n\nfunc main() {\n\tm := Main{}\n\n\tif m.initServer() != nil {\n\t\treturn\n\t}\n\n\tc := controllers.User{}\n\tv1 := m.router.Group(\"/api/v1\")\n\t{\n\t\tadmin := v1.Group(\"/admin\")\n\t\t{\n\t\t\tadmin.POST(\"/auth\", c.Authenticate)\n\t\t}\n\n\t\tuser := v1.Group(\"/users\")\n\n\t\tuser.Use(jwt.Auth(common.Config.JwtSecretPassword))\n\t\t{\n\t\t\tuser.POST(\"\", c.AddUser)\n\t\t\tuser.GET(\"/list\", c.ListUsers)\n\t\t\tuser.GET(\"detail/:id\", c.GetUserByID)\n\t\t\tuser.GET(\"/\", c.GetUserByParams)\n\t\t\tuser.DELETE(\":id\", c.DeleteUserByID)\n\t\t\tuser.PATCH(\"\", c.UpdateUser)\n\t\t}\n\t}\n\n\tm.router.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tm.router.Run(common.Config.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/golang-jwt/jwt/v4\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\t// Set Gin to release mode\n\tgin.SetMode(gin.ReleaseMode)\n\n\t// Create a new Gin router\n\tm.router = gin.New()\n\n\t// Set up logging\n\tlogFile, err := os.Create(\"server.log\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tgin.DefaultWriter = logFile\n\tm.router.Use(gin.Logger(), gin.Recovery())\n\n\treturn nil\n}\n\nfunc (m *Main) jwtAuthMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Authorization header required\"})\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\t// Validate the algorithm\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, jwt.NewValidationError(\"unexpected signing method\", jwt.ValidationErrorSignatureInvalid)\n\t\t\t}\n\t\t\t// Return the secret key\n\t\t\treturn []byte(\"your-256-bit-secret\"), nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n\nfunc (m *Main) setupRoutes() {\n\t// Public routes\n\tpublic := m.router.Group(\"/api\")\n\t{\n\t\tpublic.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t\t})\n\t}\n\n\t// Protected routes\n\tprotected := m.router.Group(\"/api\")\n\tprotected.Use(m.jwtAuthMiddleware())\n\t{\n\t\tprotected.GET(\"/secure\", func(c *gin.Context) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"secure data\"})\n\t\t})\n\t}\n}\n\nfunc (m *Main) main() {\n\tif err := m.initServer(); err != nil {\n\t\tlog.Fatalf(\"Failed to initialize server: %v\", err)\n\t}\n\n\tm.setupRoutes()\n\n\tif err := m.router.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"Failed to run server: %v\", err)\n\t}\n}\n\nfunc main() {\n\tapp := &Main{}\n\tapp.main()\n}\n```"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, saving the uploaded file to the local filesystem and returning a success message.\n\nFunction Description: The function initializes a Gin router with default middleware, sets up a static file server, and defines a POST endpoint for file uploads. It handles multipart form data containing a file and additional fields (name and email), saves the file to disk, and returns a confirmation message.\n\nInput: \n- None (the function takes no direct input parameters; inputs come via HTTP requests)\n\nOutput:\n- None (the function doesn't return anything; it starts an HTTP server that runs indefinitely)\n\nNote: The function expects HTTP POST requests to the \"/upload\" endpoint with multipart form data containing:\n1. A file (form field name \"file\")\n2. Text fields \"name\" and \"email\"",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, _ := c.FormFile(\"file\")\n\t\tsrc, _ := file.Open()\n\t\tdefer src.Close()\n\n\t\tdst, _ := os.Create(file.Filename)\n\t\tdefer dst.Close()\n\n\t\tio.Copy(dst, src)\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, name, email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc setupRouter() *gin.Engine {\n\trouter := gin.Default()\n\n\t// Serve static files from the \"uploads\" directory\n\trouter.Static(\"/uploads\", \"./uploads\")\n\n\t// Handle file uploads\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"File upload error: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Create uploads directory if it doesn't exist\n\t\tif _, err := os.Stat(\"./uploads\"); os.IsNotExist(err) {\n\t\t\tos.Mkdir(\"./uploads\", os.ModePerm)\n\t\t}\n\n\t\t// Save the file to the uploads directory\n\t\tfilePath := filepath.Join(\"./uploads\", filepath.Base(file.Filename))\n\t\tif err := c.SaveUploadedFile(file, filePath); err != nil {\n\t\t\tc.String(http.StatusInternalServerError, \"Failed to save file: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File uploaded successfully: %s\\nName: %s\\nEmail: %s\", file.Filename, name, email))\n\t})\n\n\treturn router\n}\n\nfunc main() {\n\trouter := setupRouter()\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server that sends responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\ttimestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\t\tc.String(200, \"pong \"+timestamp)\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with a single route handler that responds to GET requests.\n\nFunction Description: The function initializes a default Gin engine with built-in middleware (Logger and Recovery), registers a GET route handler at the path \"/hello\" that responds with a plain text message, and starts the server on port 80. The function is designed to be the main entry point of a Go application using the Gin web framework.\n\nInput: \n- ctx *app.Context: A context object from the eggos framework (used for logging in this example)\n\nOutput: \n- error: Returns any error that occurs during server execution, otherwise nil when the server is properly shut down",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/icexin/eggos/app\"\n)\nfunc main(ctx *app.Context) error {\n\tr := gin.Default()\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"hello from eggos\")\n\t})\n\tctx.Printf(\"run gin server on :80\")\n\treturn r.Run(\":80\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/eggos-framework/app\"\n\t\"net/http\"\n)\n\nfunc runServer(ctx *app.Context) error {\n\tr := gin.Default()\n\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tctx.Log(\"Received request at /hello\")\n\t\tc.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\tif err := r.Run(\":80\"); err != nil {\n\t\tctx.Log(\"Server error: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tctx := app.NewContext()\n\tif err := runServer(ctx); err != nil {\n\t\tctx.Log(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements a simple session-based counter. The server should increment and return a counter value with each request, storing the count in a session cookie.\n\nFunction Description: The main function initializes a Gin server with session middleware, sets up a route handler for GET requests at \"/incr\" that increments and returns a session-based counter, and starts the server on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value, but starts an HTTP server that responds to requests with JSON containing the current count, e.g., {\"count\": 5})",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/cookie\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tstore := cookie.NewStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Implement a rate-limited HTTP server using the Gin framework in Go, which includes middleware for request rate limiting and a simple endpoint to test the rate limiting functionality.\n\nFunction Description: The `ginRun` function initializes and starts a Gin HTTP server with rate limiting capabilities. It sets up a leaky bucket rate limiter middleware and provides a single endpoint (\"/rate\") for testing the rate limiting. The server runs on port 8080.\n\nInput: \n- `rps` (int): The maximum number of requests per second that the server will allow (rate limit value)\n\nOutput: \n- None (The function starts an HTTP server that runs indefinitely until interrupted)\n- Logs the current rate limit setting to stdout\n- Responds to HTTP requests on the \"/rate\" endpoint with a JSON message",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc ginRun(rps int) {\n\tlimit = ratelimit.New(rps)\n\n\tapp := gin.Default()\n\tapp.Use(leakBucket())\n\n\tapp.GET(\"/rate\", func(ctx *gin.Context) {\n\t\tctx.JSON(200, \"rate limiting test\")\n\t})\n\n\tlog.Printf(color.CyanString(\"Current Rate Limit: %v requests/s\", rps))\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype RateLimiter struct {\n\trps       int\n\ttokens    int\n\tlastCheck time.Time\n\tmu        sync.Mutex\n}\n\nfunc NewRateLimiter(rps int) *RateLimiter {\n\treturn &RateLimiter{\n\t\trps:       rps,\n\t\ttokens:    rps,\n\t\tlastCheck: time.Now(),\n\t}\n}\n\nfunc (rl *RateLimiter) Allow() bool {\n\trl.mu.Lock()\n\tdefer rl.mu.Unlock()\n\n\tnow := time.Now()\n\telapsed := now.Sub(rl.lastCheck).Seconds()\n\trl.tokens += int(elapsed * float64(rl.rps))\n\tif rl.tokens > rl.rps {\n\t\trl.tokens = rl.rps\n\t}\n\trl.lastCheck = now\n\n\tif rl.tokens > 0 {\n\t\trl.tokens--\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc rateLimitMiddleware(rl *RateLimiter) gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tif !rl.Allow() {\n\t\t\tc.JSON(http.StatusTooManyRequests, gin.H{\"error\": \"rate limit exceeded\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc ginRun(rps int) {\n\tr := gin.Default()\n\trl := NewRateLimiter(rps)\n\n\tr.Use(rateLimitMiddleware(rl))\n\n\tr.GET(\"/rate\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"request allowed\"})\n\t})\n\n\tfmt.Printf(\"Starting server with rate limit: %d requests per second\\n\", rps)\n\tr.Run(\":8080\")\n}\n\nfunc main() {\n\tginRun(5) // Example: 5 requests per second\n}\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements a simple session-based counter. The server should increment and return a counter value with each request, storing the count in a session.\n\nFunction Description: The main function initializes a Gin server with session middleware, sets up a route handler for GET requests at \"/incr\" that increments and returns a session-based counter, and starts the server on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value, but starts an HTTP server that responds to requests with JSON containing the current count, e.g., {\"count\": 5})",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/cookie\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tstore := cookie.NewStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a Go function that sets up a simple HTTP server using the Gin framework to retrieve and return the client's IP address.\n\nFunction Description: The function initializes a Gin HTTP server with default middleware (Logger and Recovery), registers a GET endpoint \"/getip\" that retrieves the client's IP address from the request context, and returns it as a JSON response. The server listens on port 8080.\n\nInput: None (The function takes no input parameters)\n\nOutput: None (The function does not return any value but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/getip\", func(c *gin.Context) {\n\t\tip := c.ClientIP()\n\t\tc.JSON(http.StatusOK, gin.H{\"ip\": ip})\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/getip\", func(c *gin.Context) {\n\t\tclientIP := c.ClientIP()\n\t\tc.JSON(http.StatusOK, gin.H{\"client_ip\": clientIP})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS web server using the Gin framework, serving a welcome page at the \"/welcome\" endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), sets up HTML templates, registers a GET handler for the \"/welcome\" endpoint that returns an HTML response, and starts the HTTPS server using the provided TLS certificate and key files.\n\nInput:\n- port (string): The port number to listen on, e.g., \":8080\"\n- certFile (string): Path to the TLS certificate file, e.g., \"./testdata/server.pem\"\n- keyFile (string): Path to the TLS private key file, e.g., \"./testdata/server.key\"\n- html (template.Template): HTML template to be used for responses\n\nOutput: None (the function runs indefinitely as a web server)\n\nNote: The function includes a warning about not using embedded certificates in production environments.",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tlogger := log.New(os.Stderr, \"\", 0)\n\tlogger.Println(\"[WARNING] DON'T USE THE EMBED CERTS FROM THIS EXAMPLE IN PRODUCTION ENVIRONMENT, GENERATE YOUR OWN!\")\n\n\tr := gin.Default()\n\tr.SetHTMLTemplate(html)\n\n\tr.GET(\"/welcome\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"https\", gin.H{\n\t\t\t\"status\": \"success\",\n\t\t})\n\t})\n\n\tr.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc runSecureServer(port, certFile, keyFile string, html *template.Template) {\n\trouter := gin.Default()\n\trouter.SetHTMLTemplate(html)\n\n\trouter.GET(\"/welcome\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"welcome.html\", gin.H{\n\t\t\t\"title\": \"Welcome Page\",\n\t\t})\n\t})\n\n\tlog.Printf(\"Starting HTTPS server on port %s\", port)\n\tif err := router.RunTLS(port, certFile, keyFile); err != nil {\n\t\tlog.Fatalf(\"Failed to run server: %v\", err)\n\t}\n}\n\nfunc main() {\n\thtml := template.Must(template.New(\"welcome.html\").Parse(`\n\t\t<!DOCTYPE html>\n\t\t<html>\n\t\t<head>\n\t\t\t<title>{{ .title }}</title>\n\t\t</head>\n\t\t<body>\n\t\t\t<h1>Welcome to the secure server!</h1>\n\t\t</body>\n\t\t</html>\n\t`))\n\n\trunSecureServer(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\", html)\n}\n```"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests to a specific endpoint, processes JSON input, and returns appropriate JSON responses.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint \"/service-b/try\" that receives JSON account data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- None (the function takes no direct input parameters, but receives HTTP requests with JSON payloads matching the Account struct format)\n\nOutput:\n- None (the function doesn't return any value directly, but sends HTTP responses with JSON bodies containing either success or error messages)\n\nNote: The Account struct (not shown in reference code) would typically contain at least an ID field to be properly processed by this endpoint.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-b/try\", func(context *gin.Context) {\n\t\taccount := &Account{}\n\t\terr := context.BindJSON(account)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"account %d tried!\", account.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"account %d tried!\", account.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\ntype Account struct {\n\tID   string `json:\"id\" binding:\"required\"`\n\tName string `json:\"name\"`\n}\n\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.POST(\"/service-b/try\", func(c *gin.Context) {\n\t\tvar account Account\n\t\tif err := c.ShouldBindJSON(&account); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid JSON input\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Process the account data here (e.g., save to database, perform operations)\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Account processed successfully\", \"account_id\": account.ID})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles file uploads, saves them to a specified directory, and returns the file URL.\n\nFunction Description: The main function initializes a Gin HTTP server with file upload capabilities. It sets up a static file server for serving uploaded files and implements a POST endpoint for uploading files. The server saves uploaded files with unique names and returns their access URLs.\n\nInput: \n- HTTP POST request with multipart/form-data containing a file field named \"file\"\n- File content in the request body\n\nOutput:\n- JSON response containing:\n  - Status code (0 for success, non-zero for errors)\n  - Message describing the operation result\n  - Data object containing the URL to access the uploaded file (on success)\n  OR\n  - Error message (on failure)\n\nThe server runs on port 8085 and serves static files from \"/root/file/\" directory. Uploaded files are saved with names formatted as \"timestamp-randomstring.extension\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"gim/pkg/util\"\n)\n\nconst baseUrl = \"http://111.229.238.28:8085/file/\"\n\ntype Response struct {\n\tCode    int         `json:\"code\"`\n\tMessage string      `json:\"message\"`\n\tData    interface{} `json:\"data\"`\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/file\", \"/root/file\")\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfilenames := strings.Split(file.Filename, \".\")\n\t\tname := strconv.FormatInt(time.Now().UnixNano(), 10) + \"-\" + util.RandString(30) + \".\" + filenames[len(filenames)-1]\n\t\tfilePath := \"/root/file/\" + name\n\t\terr = c.SaveUploadedFile(file, filePath)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, Response{\n\t\t\tCode:    0,\n\t\t\tMessage: \"success\",\n\t\t\tData:    map[string]string{\"url\": baseUrl + name},\n\t\t})\n\t})\n\terr := router.Run(\":8085\")\n\tif err != nil {\n\t\tlogger.Logger.Error(\"Run error\", zap.Error(err))\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Serve static files from the /root/file/ directory\n\tr.Static(\"/files\", \"/root/file/\")\n\n\t// POST endpoint for file upload\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"status\":  1,\n\t\t\t\t\"message\": \"File not found in request\",\n\t\t\t\t\"error\":   err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Generate a unique file name\n\t\text := filepath.Ext(file.Filename)\n\t\tnewFileName := fmt.Sprintf(\"%d-%s%s\", time.Now().Unix(), randomString(8), ext)\n\t\tfilePath := filepath.Join(\"/root/file/\", newFileName)\n\n\t\t// Save the file to the specified directory\n\t\tif err := c.SaveUploadedFile(file, filePath); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"status\":  1,\n\t\t\t\t\"message\": \"Failed to save file\",\n\t\t\t\t\"error\":   err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Return the file URL\n\t\tfileURL := fmt.Sprintf(\"/files/%s\", newFileName)\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"status\":  0,\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"data\": gin.H{\n\t\t\t\t\"url\": fileURL,\n\t\t\t},\n\t\t})\n\t})\n\n\t// Run the server on port 8085\n\tr.Run(\":8085\")\n}\n\n// randomString generates a random string of a given length\nfunc randomString(n int) string {\n\tconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\trand.Seed(time.Now().UnixNano())\n\tsb := strings.Builder{}\n\tfor i := 0; i < n; i++ {\n\t\tsb.WriteByte(letters[rand.Intn(len(letters))])\n\t}\n\treturn sb.String()\n}"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with custom template delimiters and a date formatting function, serving HTML content from a template file.\n\nFunction Description: The function initializes a Gin router with custom template delimiters \"{[{\" and \"}]}\", registers a template formatting function \"formatAsDate\", loads an HTML template file, and sets up a GET route handler that renders the template with a predefined date value. The server listens on port 8080.\n\nInput: None (The function takes no input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Delims(\"{[{\", \"}]}\")\n\trouter.SetFuncMap(template.FuncMap{\n\t\t\"formatAsDate\": formatAsDate,\n\t})\n\trouter.LoadHTMLFiles(\"./testdata/raw.tmpl\")\n\n\trouter.GET(\"/raw\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"raw.tmpl\", gin.H{\n\t\t\t\"now\": time.Date(2017, 0o7, 0o1, 0, 0, 0, 0, time.UTC),\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc formatAsDate(t time.Time) string {\n\treturn t.Format(\"2006-01-02\")\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.SetFuncMap(template.FuncMap{\n\t\t\"formatAsDate\": formatAsDate,\n\t})\n\trouter.Delims(\"{[{\", \"}]}\")\n\trouter.LoadHTMLFiles(\"template.html\")\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"template.html\", gin.H{\n\t\t\t\"date\": time.Now(),\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that serves HTML templates, static files, and a favicon, with routes for the main page and a foo page.\n\nFunction Description: The main function initializes a Gin router, sets up HTML templates from embedded files, serves static files, defines route handlers for the root path (\"/\"), \"/foo\" path, and favicon, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but relies on embedded filesystem content for templates and assets)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)\n\nNote: The implementation assumes the existence of an embedded filesystem (variable 'f' of type embed.FS) containing template files in \"templates/\" and \"templates/foo/\" directories, and assets in an \"assets/\" directory.",
    "Canonical_solution": "import (\n\t\"embed\"\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\ttempl := template.Must(template.New(\"\").ParseFS(f, \"templates/*.tmpl\", \"templates/foo/*.tmpl\"))\n\trouter.SetHTMLTemplate(templ)\n\n\trouter.StaticFS(\"/public\", http.FS(f))\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n\t\t\t\"title\": \"Main website\",\n\t\t})\n\t})\n\n\trouter.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"bar.tmpl\", gin.H{\n\t\t\t\"title\": \"Foo website\",\n\t\t})\n\t})\n\n\trouter.GET(\"favicon.ico\", func(c *gin.Context) {\n\t\tfile, _ := f.ReadFile(\"assets/favicon.ico\")\n\t\tc.Data(\n\t\t\thttp.StatusOK,\n\t\t\t\"image/x-icon\",\n\t\t\tfile,\n\t\t)\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"embed\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n//go:embed templates/* templates/foo/* assets/*\nvar f embed.FS\n\nfunc main() {\n\trouter := gin.Default()\n\n\t// Load HTML templates\n\trouter.SetHTMLTemplate(template.Must(template.ParseFS(f, \"templates/*.html\", \"templates/foo/*.html\")))\n\n\t// Serve static files\n\trouter.StaticFS(\"/assets\", http.FS(f))\n\n\t// Favicon route\n\trouter.GET(\"/favicon.ico\", func(c *gin.Context) {\n\t\tc.FileFromFS(\"assets/favicon.ico\", http.FS(f))\n\t})\n\n\t// Main page route\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.html\", nil)\n\t})\n\n\t// Foo page route\n\trouter.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"foo.html\", nil)\n\t})\n\n\t// Start the server\n\trouter.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, and serves static files from a specified directory.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), serves static files from a \"./public\" directory, and handles POST requests to \"/upload\" endpoint for file uploads with additional form fields (name and email). It processes the uploaded files and form data, saves the files to the server, and returns a success message.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it starts an HTTP server on port 8080 and handles incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, _ := c.MultipartForm()\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tsrc, _ := file.Open()\n\t\t\tdefer src.Close()\n\n\t\t\tdst, _ := os.Create(file.Filename)\n\t\t\tdefer dst.Close()\n\n\t\t\tio.Copy(dst, src)\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\t// Serve static files from the \"./public\" directory\n\trouter.Static(\"/public\", \"./public\")\n\n\t// Handle file uploads\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"File upload error: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Save the uploaded file to the server\n\t\tfilePath := filepath.Join(\"./uploads\", filepath.Base(file.Filename))\n\t\tif err := c.SaveUploadedFile(file, filePath); err != nil {\n\t\t\tc.String(http.StatusInternalServerError, \"File save error: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with name: %s and email: %s\", file.Filename, name, email))\n\t})\n\n\t// Start the server on port 8080\n\trouter.Run(\":8080\")\n}\n\nfunc main() {\n\tsetupServer()\n}\n```"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, serving static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling file uploads with additional form fields. It validates the upload, saves the file, and returns a success message with the form data.\n\nInput: None (The function takes no direct input parameters but processes HTTP requests with the following expected form data:\n- \"name\": string - Name field from the form\n- \"email\": string - Email field from the form\n- \"file\": file - File to be uploaded)\n\nOutput: None (The function doesn't return any value but sends HTTP responses:\n- Success: HTTP 200 with upload confirmation message\n- Error: HTTP 400 with error message for invalid requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfilename := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, \"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc setupServer() {\n\trouter := gin.Default()\n\n\t// Serve static files from the \"public\" directory\n\trouter.Static(\"/public\", \"./public\")\n\n\t// Handle file uploads\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"File is required\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Save the uploaded file to a specific directory\n\t\tfilePath := filepath.Join(\"uploads\", filepath.Base(file.Filename))\n\t\tif err := c.SaveUploadedFile(file, filePath); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to save file\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"name\":    name,\n\t\t\t\"email\":   email,\n\t\t\t\"file\":    filePath,\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}\n\nfunc main() {\n\tsetupServer()\n}\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves a static favicon file and responds to a GET request with a text message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), serves a static favicon file, registers a GET route handler, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but sends responses to HTTP requests and runs the server indefinitely)\n\nNote: The instruction is for function-level code as the reference code shows a main function implementation rather than a struct/class implementation.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tapp := gin.Default()\n\n\tapp.StaticFile(\"/favicon.ico\", \"./favicon.ico\")\n\n\tapp.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello favicon.\")\n\t})\n\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Serve static favicon\n\tr.StaticFile(\"/favicon.ico\", \"./path/to/favicon.ico\")\n\n\t// Handle GET request\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using the Gin web framework, which responds to GET requests at the root path with a JSON message.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a GET route handler for the root path (\"/\") that returns a JSON response, and starts the HTTPS server using the provided TLS certificate and key files.\n\nInput: \n- port (string): The port number on which the server should listen, prefixed with \":\" (e.g., \":5002\")\n- certFile (string): Path to the TLS certificate file (e.g., \"manager.crt\")\n- keyFile (string): Path to the TLS private key file (e.g., \"manager.key\")\n\nOutput: None (The function runs an infinite loop to serve HTTP requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\ts := gin.Default()\n\ts.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"msg\": \"passed\"})\n\t})\n\ts.RunTLS(\":5002\", \"manager.crt\", \"manager.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc runSecureServer(port, certFile, keyFile string) {\n\trouter := gin.Default()\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, World!\"})\n\t})\n\n\trouter.RunTLS(port, certFile, keyFile)\n}"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Go function that initializes and configures a Gin HTTP server with New Relic monitoring middleware, and defines a simple route handler.\n\nFunction Description: The function sets up a basic Gin web server with default middleware (Logger and Recovery), configures New Relic monitoring if environment variables are present, and registers a root route handler that returns \"Hello World!\". The server runs on the default port (8080).\n\nInput: None (uses environment variables APP_NAME and NEW_RELIC_API_KEY for optional New Relic configuration)\n\nOutput: None (starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/newrelic/go-agent\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tcfg := newrelic.NewConfig(os.Getenv(\"APP_NAME\"), os.Getenv(\"NEW_RELIC_API_KEY\"))\n\tapp, err := newrelic.NewApplication(cfg)\n\tif err != nil {\n\t\tlog.Printf(\"failed to make new_relic app: %v\", err)\n\t} else {\n\t\trouter.Use(NewRelicMonitoring(app))\n\t}\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello World!\\n\")\n\t})\n\trouter.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/newrelic/go-agent/v3/integrations/nrgin\"\n\t\"github.com/newrelic/go-agent/v3/newrelic\"\n)\n\nfunc main() {\n\tappName := os.Getenv(\"APP_NAME\")\n\tnewRelicAPIKey := os.Getenv(\"NEW_RELIC_API_KEY\")\n\n\tvar nrApp *newrelic.Application\n\tvar err error\n\n\tif appName != \"\" && newRelicAPIKey != \"\" {\n\t\tnrApp, err = newrelic.NewApplication(\n\t\t\tnewrelic.ConfigAppName(appName),\n\t\t\tnewrelic.ConfigLicense(newRelicAPIKey),\n\t\t\tnewrelic.ConfigDistributedTracerEnabled(true),\n\t\t)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error initializing New Relic:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tr := gin.Default()\n\n\tif nrApp != nil {\n\t\tr.Use(nrgin.Middleware(nrApp))\n\t}\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello World!\")\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at the \"/ping\" endpoint that responds with \"pong\", and starts the server on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends \"pong\" as a response to GET requests at \"/ping\" and runs the HTTP server continuously until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that provides translation services through the DeepLX API. The server should handle GET and POST requests, implement authentication middleware, and support proxy configuration.\n\nFunction Description: The main function initializes a Gin HTTP server with CORS support, sets up routes for translation services, and starts the server on a specified port. It includes:\n1. Configuration initialization\n2. Proxy setup (if configured)\n3. Route handlers for root (/) and translation (/translate) endpoints\n4. Authentication middleware for protected routes\n5. Translation request processing and response handling\n\nInput:\n- Configuration parameters (IP, Port, Proxy, Token) from initConfig()\n- Environment variable PROXY (optional)\n- HTTP requests:\n  * GET / - Returns server information\n  * POST /translate - Accepts JSON payload with translation parameters\n\nOutput:\n- HTTP responses:\n  * For GET /: JSON response with server information\n  * For POST /translate: JSON response with translation results or error message\n- Console output: Server startup message and configuration status\n\nStruct Description: (Not applicable - the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\n\ttranslate \"github.com/OwO-Network/DeepLX/translate\"\n\t\"github.com/gin-contrib/cors\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tcfg := initConfig()\n\n\tfmt.Printf(\"DeepL X has been successfully launched! Listening on %v:%v\\n\", cfg.IP, cfg.Port)\n\tfmt.Println(\"Developed by sjlleo <i@leo.moe> and missuo <me@missuo.me>.\")\n\n\tproxyURL := os.Getenv(\"PROXY\")\n\tif proxyURL == \"\" {\n\t\tproxyURL = cfg.Proxy\n\t}\n\tif proxyURL != \"\" {\n\t\tproxy, err := url.Parse(proxyURL)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to parse proxy URL: %v\", err)\n\t\t}\n\t\thttp.DefaultTransport = &http.Transport{\n\t\t\tProxy: http.ProxyURL(proxy),\n\t\t}\n\t}\n\n\tif cfg.Token != \"\" {\n\t\tfmt.Println(\"Access token is set.\")\n\t}\n\n\tgin.SetMode(gin.ReleaseMode)\n\tr := gin.Default()\n\tr.Use(cors.Default())\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"code\":    http.StatusOK,\n\t\t\t\"message\": \"DeepL Free API, Developed by sjlleo and missuo. Go to /translate with POST. http://github.com/OwO-Network/DeepLX\",\n\t\t})\n\t})\n\n\tr.POST(\"/translate\", authMiddleware(cfg), func(c *gin.Context) {\n\t\treq := PayloadFree{}\n\t\tc.BindJSON(&req)\n\n\t\tsourceLang := req.SourceLang\n\t\ttargetLang := req.TargetLang\n\t\ttranslateText := req.TransText\n\t\ttagHandling := req.TagHandling\n\n\t\tproxyURL := cfg.Proxy\n\n\t\tif tagHandling != \"\" && tagHandling != \"html\" && tagHandling != \"xml\" {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"code\":    http.StatusBadRequest,\n\t\t\t\t\"message\": \"Invalid tag_handling value. Allowed values are 'html' and 'xml'.\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tresult, err := translate.TranslateByDeepLX(sourceLang, targetLang, translateText, tagHandling, proxyURL, \"\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Translation failed: %s\", err)\n\t\t}\n\n\t\tif result.Code == http.StatusOK {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":         http.StatusOK,\n\t\t\t\t\"id\":           result.ID,\n\t\t\t\t\"data\":         result.Data,\n\t\t\t\t\"alternatives\": result.Alternatives,\n\t\t\t\t\"source_lang\":  result.SourceLang,\n\t\t\t\t\"target_lang\":  result.TargetLang,\n\t\t\t\t\"method\":       result.Method,\n\t\t\t})\n\t\t} else {\n\t\t\tc.JSON(result.Code, gin.H{\n\t\t\t\t\"code\":    result.Code,\n\t\t\t\t\"message\": result.Message,\n\t\t\t})\n\t\t}\n\t})\n\n\tr.Run(fmt.Sprintf(\"%v:%v\", cfg.IP, cfg.Port))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gin-contrib/cors\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Config struct {\n\tIP    string\n\tPort  string\n\tProxy string\n\tToken string\n}\n\ntype TranslationRequest struct {\n\tText   string `json:\"text\"`\n\tSource string `json:\"source\"`\n\tTarget string `json:\"target\"`\n}\n\ntype TranslationResponse struct {\n\tTranslatedText string `json:\"translated_text\"`\n\tError          string `json:\"error,omitempty\"`\n}\n\nfunc initConfig() Config {\n\treturn Config{\n\t\tIP:    \"127.0.0.1\",\n\t\tPort:  \"8080\",\n\t\tProxy: os.Getenv(\"PROXY\"),\n\t\tToken: \"your-auth-token\",\n\t}\n}\n\nfunc main() {\n\tconfig := initConfig()\n\tr := gin.Default()\n\tr.Use(cors.Default())\n\n\tif config.Proxy != \"\" {\n\t\tproxyURL, err := url.Parse(config.Proxy)\n\t\tif err == nil {\n\t\t\thttp.DefaultTransport = &http.Transport{Proxy: http.ProxyURL(proxyURL)}\n\t\t}\n\t}\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Translation Service\", \"status\": \"running\"})\n\t})\n\n\tr.POST(\"/translate\", authMiddleware(config.Token), func(c *gin.Context) {\n\t\tvar req TranslationRequest\n\t\tif err := c.ShouldBindJSON(&req); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, TranslationResponse{Error: \"Invalid request\"})\n\t\t\treturn\n\t\t}\n\n\t\ttranslatedText, err := translateText(req.Text, req.Source, req.Target)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, TranslationResponse{Error: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, TranslationResponse{TranslatedText: translatedText})\n\t})\n\n\tserverAddress := fmt.Sprintf(\"%s:%s\", config.IP, config.Port)\n\tfmt.Printf(\"Starting server at %s\\n\", serverAddress)\n\tr.Run(serverAddress)\n}\n\nfunc authMiddleware(token string) gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tauthHeader := c.GetHeader(\"Authorization\")\n\t\tif authHeader != fmt.Sprintf(\"Bearer %s\", token) {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc translateText(text, source, target string) (string, error) {\n\tapiURL := \"https://api.deeplx.com/translate\"\n\tdata := url.Values{}\n\tdata.Set(\"text\", text)\n\tdata.Set(\"source_lang\", source)\n\tdata.Set(\"target_lang\", target)\n\n\treq, err := http.NewRequest(\"POST\", apiURL, strings.NewReader(data.Encode()))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif translatedText, ok := result[\"translated_text\"].(string); ok {\n\t\treturn translatedText, nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"translation failed\")\n}"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles various routes including a ping endpoint, user lookup, and authenticated admin updates.\n\nFunction Description: The main function initializes a Gin web server with default middleware (Logger and Recovery), sets up route handlers for different HTTP methods, and starts the server on port 8080. It includes:\n1. A simple ping/pong endpoint\n2. A user lookup endpoint with path parameters\n3. An authenticated admin endpoint for updating values\n4. Basic authentication middleware for protected routes\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything, but sends HTTP responses to clients)\n\nNote: The code assumes the existence of a global DB map variable (not shown in the reference) for storing user values. The actual implementation would need to include this or an alternative storage mechanism.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tr.GET(\"/user/:name\", func(c *gin.Context) {\n\t\tuser := c.Params.ByName(\"name\")\n\t\tvalue, ok := DB[user]\n\t\tif ok {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"value\": value})\n\t\t} else {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"status\": \"no value\"})\n\t\t}\n\t})\n\n\tauthorized := r.Group(\"/\", gin.BasicAuth(gin.Accounts{\n\t\t\"foo\":  \"bar\",\n\t\t\"manu\": \"123\",\n\t}))\n\n\tauthorized.POST(\"admin\", func(c *gin.Context) {\n\t\tuser := c.MustGet(gin.AuthUserKey).(string)\n\n\t\tvar json struct {\n\t\t\tValue string `json:\"value\" binding:\"required\"`\n\t\t}\n\n\t\tif c.Bind(&json) == nil {\n\t\t\tDB[user] = json.Value\n\t\t\tc.JSON(200, gin.H{\"status\": \"ok\"})\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar DB = map[string]string{\n\t\"user1\": \"value1\",\n\t\"user2\": \"value2\",\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t})\n\n\tr.GET(\"/user/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\t\tif value, exists := DB[name]; exists {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"name\": name, \"value\": value})\n\t\t} else {\n\t\t\tc.JSON(http.StatusNotFound, gin.H{\"message\": \"user not found\"})\n\t\t}\n\t})\n\n\tadminGroup := r.Group(\"/admin\", gin.BasicAuth(gin.Accounts{\n\t\t\"admin\": \"password\",\n\t}))\n\n\tadminGroup.PUT(\"/update/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\t\tvar json struct {\n\t\t\tValue string `json:\"value\" binding:\"required\"`\n\t\t}\n\t\tif err := c.ShouldBindJSON(&json); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tDB[name] = json.Value\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"user updated\", \"name\": name, \"value\": json.Value})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Create a simple HTTP server in Go using the Gin framework that handles file uploads via POST requests.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint (\"/upload\") that receives and discards uploaded file data, then responds with \"ok\". The server runs on port 8888.\n\nInput: None (The function takes no direct input parameters, but receives HTTP POST requests with file data in the request body)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and body \"ok\" for successful uploads)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tbody := c.Request.Body\n\t\tio.Copy(io.Discard, body)\n\t\tc.String(http.StatusOK, \"ok\")\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, _, err := c.Request.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"Bad request\")\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tc.String(http.StatusOK, \"ok\")\n\t})\n\n\trouter.Run(\":8888\")\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a Go HTTP client struct that can handle both HTTP and HTTPS requests with custom configurations, including authentication and request headers.\n\nStruct Description: The Client struct represents an HTTP client with configurable protocol, address, authentication, and transport settings. It provides methods to execute HTTP requests and handle responses.\n\nFields:\nProtocol: string - The protocol to use (http or https)\nAddr: string - The server address to connect to\nUser: string - The username for basic authentication\nPassword: string - The password for basic authentication\nc: *http.Client - The underlying HTTP client instance\n\nMethods:\nNewClient: (conf *ClientConfig) -> *Client - Creates a new Client instance with the given configuration, setting up either HTTP or HTTPS transport\nDoRequest: (method string, url string, body *bytes.Buffer) -> (*http.Response, error) - Executes an HTTP request with the given method, URL and body, adding basic auth if configured\nDo: (method string, url string, body map[string]interface{}) -> (*Response, error) - Executes a request with JSON body, parses the response and returns a structured Response object",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/juju/errors\"\n)\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\n\tc *http.Client\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\tc := new(Client)\n\n\tc.Addr = conf.Addr\n\tc.User = conf.User\n\tc.Password = conf.Password\n\n\tif conf.HTTPS {\n\t\tc.Protocol = \"https\"\n\t\ttr := &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t\tc.c = &http.Client{Transport: tr}\n\t} else {\n\t\tc.Protocol = \"http\"\n\t\tc.c = &http.Client{}\n\t}\n\n\treturn c\n}\n\nfunc (c *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif len(c.User) > 0 && len(c.Password) > 0 {\n\t\treq.SetBasicAuth(c.User, c.Password)\n\t}\n\tresp, err := c.c.Do(req)\n\n\treturn resp, err\n}\n\nfunc (c *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tbodyData, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tbuf := bytes.NewBuffer(bodyData)\n\tif body == nil {\n\t\tbuf = bytes.NewBuffer(nil)\n\t}\n\n\tresp, err := c.DoRequest(method, url, buf)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tret := new(Response)\n\tret.Code = resp.StatusCode\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tif len(data) > 0 {\n\t\terr = json.Unmarshal(data, &ret.ResponseItem)\n\t}\n\n\treturn ret, errors.Trace(err)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\tc        *http.Client\n}\n\ntype ClientConfig struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\tTimeout  time.Duration\n}\n\ntype Response struct {\n\tStatusCode int\n\tBody       []byte\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\ttransport := &http.Transport{}\n\tif conf.Protocol == \"https\" {\n\t\ttransport.TLSHandshakeTimeout = 10 * time.Second\n\t}\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   conf.Timeout,\n\t}\n\treturn &Client{\n\t\tProtocol: conf.Protocol,\n\t\tAddr:     conf.Addr,\n\t\tUser:     conf.User,\n\t\tPassword: conf.Password,\n\t\tc:        client,\n\t}\n}\n\nfunc (cl *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, cl.Protocol+\"://\"+cl.Addr+url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif cl.User != \"\" && cl.Password != \"\" {\n\t\treq.SetBasicAuth(cl.User, cl.Password)\n\t}\n\treturn cl.c.Do(req)\n}\n\nfunc (cl *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tjsonBody, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := cl.DoRequest(method, url, bytes.NewBuffer(jsonBody))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, errors.New(\"request failed with status: \" + resp.Status)\n\t}\n\n\treturn &Response{\n\t\tStatusCode: resp.StatusCode,\n\t\tBody:       respBody,\n\t}, nil\n}\n```"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but configuration is hardcoded: static files are served from \"/tmp\" and the server listens on port 8080)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\n\t// Serve static files from the /tmp directory\n\trouter.Static(\"/static\", \"/tmp\")\n\n\t// Handle GET request at the /ping endpoint\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\n\t// Start the server on port 8080\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters. HTTP requests to the \"/ping\" endpoint serve as indirect input.)\n\nOutput: None (The function doesn't return any value directly. It sends HTTP responses to clients as output.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gin-contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tcurrentTime := time.Now().Unix()\n\t\tc.String(200, fmt.Sprintf(\"pong %d\", currentTime))\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Create a TCP client in Go that establishes a connection to a server, sends a message, and handles the connection lifecycle properly.\n\nFunction Description: The function establishes a TCP connection to a specified server address, sends a predefined message (\"hello\"), and prints the number of bytes written or any error encountered. It ensures the connection is properly closed after use.\n\nInput: None (The server address is hardcoded as \"127.0.0.1:49153\" in this example)\n\nOutput: \n- On success: Prints the number of bytes written to the connection (integer)\n- On failure: Prints the error encountered during connection or writing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n)\n\nfunc main() {\n\tdialer := &net.Dialer{\n\t\tLocalAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\t\tPort: 0,\n\t\t},\n\t}\n\n\tconn, err := dialer.Dial(\"tcp\", \"127.0.0.1:49153\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tt := &wrappedConn{conn}\n\tvar w io.Writer = t\n\tif n, err := w.Write([]byte(\"hello\")); err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(n)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc main() {\n\tserverAddress := \"127.0.0.1:49153\"\n\tmessage := \"hello\"\n\n\tconn, err := net.Dial(\"tcp\", serverAddress)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tbytesWritten, err := conn.Write([]byte(message))\n\tif err != nil {\n\t\tfmt.Println(\"Error writing to connection:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Bytes written:\", bytesWritten)\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Implement a TCP client function in Go that establishes a connection to a server, sends data, and receives a response.\n\nFunction Description: The function `Tcp` handles TCP communication with a remote server. It establishes a connection, sends optional data, and reads the server's response. Errors are captured and returned in the response structure. The connection is automatically closed when the function completes.\n\nInput: \n- `ctx context.Context`: Context for managing deadlines and cancellation signals\n- `req *pb.TcpRequest`: Request object containing:\n  - `Address string`: The server address to connect to (format \"host:port\")\n  - `Data string`: Optional data to send to the server\n- `rsp *pb.TcpResponse`: Response object to populate with results\n\nOutput:\n- `error`: Returns an error if address validation fails, otherwise nil (errors during TCP operations are stored in the response)\n- Modifies `rsp` with:\n  - `Status string`: \"OK\" on success or error message\n  - `Data string`: Received data from server (if any)",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\tpb \"github.com/micro/services/ping/proto\"\n)\n\nfunc (p *Ping) Tcp(ctx context.Context, req *pb.TcpRequest, rsp *pb.TcpResponse) error {\n\tif len(req.Address) == 0 {\n\t\treturn errors.BadRequest(\"ping.tcp\", \"missing address\")\n\t}\n\n\tc, err := net.Dial(\"tcp\", req.Address)\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\tdefer c.Close()\n\n\tif len(req.Data) == 0 {\n\t\trsp.Status = \"OK\"\n\t\treturn nil\n\t}\n\n\tfmt.Fprint(c, req.Data)\n\n\tdata, err := bufio.NewReader(c).ReadString('\\n')\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\n\trsp.Status = \"OK\"\n\trsp.Data = data\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\tpb \"path/to/protobuf/package\"\n)\n\nfunc Tcp(ctx context.Context, req *pb.TcpRequest, rsp *pb.TcpResponse) error {\n\tdialer := &net.Dialer{}\n\tconn, err := dialer.DialContext(ctx, \"tcp\", req.Address)\n\tif err != nil {\n\t\trsp.Status = fmt.Sprintf(\"Error connecting: %v\", err)\n\t\treturn nil\n\t}\n\tdefer conn.Close()\n\n\tif req.Data != \"\" {\n\t\t_, err = conn.Write([]byte(req.Data))\n\t\tif err != nil {\n\t\t\trsp.Status = fmt.Sprintf(\"Error sending data: %v\", err)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tconn.SetReadDeadline(time.Now().Add(5 * time.Second))\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil && err != io.EOF {\n\t\trsp.Status = fmt.Sprintf(\"Error reading response: %v\", err)\n\t\treturn nil\n\t}\n\n\trsp.Status = \"OK\"\n\trsp.Data = string(buf[:n])\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, reads all data from the connection, and returns the data as a string.\n\nFunction Description: The function connects to a TCP server at the specified address, reads all available data from the connection, closes the connection, and returns the received data as a string. If the connection fails, it should panic with the error.\n\nInput: \n- address (string): The server address in the format \"host:port\" (e.g., \"localhost:9000\")\n\nOutput: \n- string: The data received from the server\n- error: Returns an error if the connection or read operation fails (though in the reference code it panics on connection error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tbs, _ := ioutil.ReadAll(conn)\n\tfmt.Println(string(bs))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "import (\n\t\"net\"\n\t\"io/ioutil\"\n)\n\nfunc readFromTCPServer(address string) (string, error) {\n\tconn, err := net.Dial(\"tcp\", address)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tdata, err := ioutil.ReadAll(conn)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(data), nil\n}"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It holds configuration information and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Pointer to configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC server for the specified realm using TCP. Returns the response or error.\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful. Returns the response or accumulated errors.\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a KDC server, including sending data and reading response. Ensures connection is closed when done.",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Config struct {\n\tKDCAddresses map[int]string\n\tTimeout      time.Duration\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tkdcs := c.Config.KDCAddresses\n\tresponse, err := c.dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send data to KDC for realm %s: %w\", realm, err)\n\t}\n\treturn response, nil\n}\n\nfunc (c *Client) dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar lastErr error\n\tfor _, address := range kdcs {\n\t\tconn, err := net.DialTimeout(\"tcp\", address, c.Config.Timeout)\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tresponse, err := c.sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\t\treturn response, nil\n\t}\n\treturn nil, fmt.Errorf(\"all KDC addresses failed: %w\", lastErr)\n}\n\nfunc (c *Client) sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write to TCP connection: %w\", err)\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read from TCP connection: %w\", err)\n\t}\n\n\treturn buffer[:n], nil\n}\n\nfunc main() {\n\tconfig := &Config{\n\t\tKDCAddresses: map[int]string{\n\t\t\t0: \"kdc1.example.com:88\",\n\t\t\t1: \"kdc2.example.com:88\",\n\t\t},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tclient := &Client{Config: config}\n\tdata := []byte(\"some data to send\")\n\tresponse, err := client.sendKDCTCP(\"example.com\", data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Response:\", string(response))\n\t}\n}\n```"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Implement a Go struct that handles DNS queries over UDP with context support and deadline management.\n\nStruct Description: DNSEndpoint represents a DNS server endpoint capable of performing DNS queries with context support, deadline management, and transaction ID matching.\n\nFields:\nAddr: string - The address of the DNS server in \"host:port\" format\n\nMethods:\nExchange: (ctx context.Context, payload, buf []byte) -> (n int, err error) - Performs a DNS query exchange:\n  - Establishes a UDP connection to the server\n  - Sets deadline from context if available\n  - Generates random transaction ID\n  - Sends DNS query payload\n  - Reads response and validates transaction ID\n  - Returns number of bytes read or any error\n  - Automatically closes connection when done",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n)\n\ntype DNSEndpoint struct {\n\tAddr string\n}\n\nfunc (e *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (n int, err error) {\n\td := &net.Dialer{}\n\tc, err := d.DialContext(ctx, \"udp\", e.Addr)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"dial: %v\", err)\n\t}\n\tdefer c.Close()\n\tif t, ok := ctx.Deadline(); ok {\n\t\t_ = c.SetDeadline(t)\n\t}\n\tif _, err := rand.Read(payload[:2]); err != nil {\n\t\treturn 0, err\n\t}\n\t_, err = c.Write(payload)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"write: %v\", err)\n\t}\n\tid := uint16(payload[0])<<8 | uint16(buf[1])\n\tfor {\n\t\tif n, err = c.Read(buf[:514]); err != nil {\n\t\t\treturn n, fmt.Errorf(\"read: %v\", err)\n\t\t}\n\t\tif n < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif id != uint16(buf[0])<<8|uint16(buf[1]) {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math/rand\"\n\t\"net\"\n\t\"time\"\n)\n\ntype DNSEndpoint struct {\n\tAddr string\n}\n\nfunc (d *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (int, error) {\n\tconn, err := net.Dial(\"udp\", d.Addr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer conn.Close()\n\n\tdeadline, ok := ctx.Deadline()\n\tif ok {\n\t\tconn.SetDeadline(deadline)\n\t}\n\n\ttransactionID := rand.Uint16()\n\tpayload[0] = byte(transactionID >> 8)\n\tpayload[1] = byte(transactionID & 0xff)\n\n\t_, err = conn.Write(payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif n < 2 || buf[0] != byte(transactionID>>8) || buf[1] != byte(transactionID&0xff) {\n\t\treturn 0, errors.New(\"transaction ID mismatch\")\n\t}\n\n\treturn n, nil\n}\n\nfunc main() {\n\t// Example usage\n\tdnsEndpoint := DNSEndpoint{Addr: \"8.8.8.8:53\"}\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\n\tpayload := make([]byte, 512) // Example DNS query payload\n\tbuf := make([]byte, 512)\n\n\tn, err := dnsEndpoint.Exchange(ctx, payload, buf)\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else {\n\t\tprintln(\"Bytes read:\", n)\n\t}\n}\n```"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It maintains configuration and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC for the specified realm, handling multiple KDC addresses and error cases\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a single KDC connection",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Config struct {\n\tKDCAddresses map[int]string\n\tTimeout      time.Duration\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tkdcs, ok := c.Config.KDCAddresses[realm]\n\tif !ok {\n\t\treturn nil, errors.New(\"no KDC addresses found for realm\")\n\t}\n\treturn c.dialSendTCP(kdcs, b)\n}\n\nfunc (c *Client) dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar lastErr error\n\tfor _, address := range kdcs {\n\t\tconn, err := net.DialTimeout(\"tcp\", address, c.Config.Timeout)\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tresponse, err := c.sendTCP(conn.(*net.TCPConn), b)\n\t\tif err == nil {\n\t\t\treturn response, nil\n\t\t}\n\t\tlastErr = err\n\t}\n\treturn nil, fmt.Errorf(\"failed to connect to any KDC: %v\", lastErr)\n}\n\nfunc (c *Client) sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buffer[:n], nil\n}\n\nfunc main() {\n\tconfig := &Config{\n\t\tKDCAddresses: map[int]string{\n\t\t\t0: \"kdc1.example.com:88\",\n\t\t\t1: \"kdc2.example.com:88\",\n\t\t},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tclient := &Client{Config: config}\n\tdata := []byte(\"request data\")\n\tresponse, err := client.sendKDCTCP(\"example.com\", data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Response:\", string(response))\n\t}\n}\n```"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and applies specific traffic class and hop limit settings if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely until terminated.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"[::1]:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"TCP server listening on [::1]:1024\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\ttcpConn, ok := conn.(*net.TCPConn)\n\tif !ok {\n\t\tfmt.Println(\"Connection is not a TCP connection\")\n\t\treturn\n\t}\n\n\tfile, err := tcpConn.File()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting file descriptor:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfd := int(file.Fd())\n\n\t// Set IPv6 traffic class and hop limit\n\tif err := syscall.SetsockoptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, 0x10); err != nil {\n\t\tfmt.Println(\"Error setting traffic class:\", err)\n\t}\n\tif err := syscall.SetsockoptInt(fd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, 64); err != nil {\n\t\tfmt.Println(\"Error setting hop limit:\", err)\n\t}\n\n\tackMessage := \"HELLO-R-U-THERE-ACK\"\n\t_, err = conn.Write([]byte(ackMessage))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending acknowledgment:\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management. The server should be able to start, accept connections, read data from clients, and properly shut down while cleaning up resources.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management capabilities. It maintains state about active connections and provides methods to start, serve, and manage the server lifecycle.\n\nFields:\n\nAddr: [string] - The network address to listen on (e.g., \":8080\")\nNet: [string] - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: [Handler] - The handler for processing incoming requests\nReadTimeout: [time.Duration] - Maximum duration for reading a request\nWriteTimeout: [time.Duration] - Maximum duration for writing a response\nIdleTimeout: [func() time.Duration] - Function returning idle connection timeout\nlock: [sync.RWMutex] - Protects concurrent access to server state\nstarted: [bool] - Indicates if server is running\nshutdown: [chan struct{}] - Channel for shutdown signaling\nconns: [map[net.Conn]struct{}] - Map of active connections\n\nMethods:\n\nListenAndServe: [Name]() -> [error] - Starts the server and begins accepting connections\nserveTCP: [Name](net.Listener) -> [error] - Main TCP serving loop that accepts connections\nserveTCPConn: [Name](*sync.WaitGroup, net.Conn) -> [] - Handles an individual TCP connection\nreadTCP: [Name](net.Conn, time.Duration) -> ([]byte, error) - Reads data from a TCP connection\ninit: [Name]() -> [] - Initializes server resources\nisStarted: [Name]() -> [bool] - Checks if server is running\ngetIdleTimeout: [Name]() -> [time.Duration] - Returns idle timeout duration\ngetReadTimeout: [Name]() -> [time.Duration] - Returns read timeout duration",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := net.Listen(srv.Net, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer wg.Done()\n\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := srv.getIdleTimeout()\n\n\tfor srv.isStarted() {\n\t\tm, err := srv.readTCP(rw, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n}\n\nfunc (srv *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\n\tvar length uint16\n\tif err := binary.Read(conn, binary.BigEndian, &length); err != nil {\n\t\treturn nil, err\n\t}\n\n\tm := make([]byte, length)\n\tif _, err := io.ReadFull(conn, m); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn m, nil\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getIdleTimeout() time.Duration {\n\tif srv.IdleTimeout != nil {\n\t\treturn srv.IdleTimeout()\n\t}\n\treturn tcpIdleTimeout\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeTCP(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\treturn s.serveTCP(listener)\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tselect {\n\t\tcase <-s.shutdown:\n\t\t\twg.Wait()\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.lock.Lock()\n\t\t\ts.conns[conn] = struct{}{}\n\t\t\ts.lock.Unlock()\n\t\t\twg.Add(1)\n\t\t\tgo s.serveTCPConn(&wg, conn)\n\t\t}\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.shutdown:\n\t\t\treturn\n\t\tdefault:\n\t\t\tdata, err := s.readTCP(conn, s.getReadTimeout())\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\tfmt.Println(\"Error reading:\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.Handler.ServeTCP(conn)\n\t\t\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t\t\t_, err = conn.Write(data)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error writing:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf[:n], nil\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn\n\t}\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getIdleTimeout() time.Duration {\n\tif s.IdleTimeout != nil {\n\t\treturn s.IdleTimeout()\n\t}\n\treturn 0\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}\n\nfunc (s *Server) Shutdown() {\n\ts.lock.Lock()\n\tif !s.started {\n\t\ts.lock.Unlock()\n\t\treturn\n\t}\n\tclose(s.shutdown)\n\tfor conn := range s.conns {\n\t\tconn.Close()\n\t}\n\ts.started = false\n\ts.lock.Unlock()\n}\n```"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client requests, and manages connection lifecycle with configurable timeouts.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - The request handler interface\nReadTimeout: time.Duration - Maximum duration for reading the entire request\nWriteTimeout: time.Duration - Maximum duration for writing the response\nIdleTimeout: func() time.Duration - Function returning the maximum idle connection duration\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Main server loop that accepts and handles connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual client connection\ninit() - Initializes server resources\nisStarted() bool - Returns server running status\ngetReadTimeout() time.Duration - Returns configured read timeout or default",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, false, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\tlimit := maxTCPQueries\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n\tif srv.Handler == nil {\n\t\tsrv.Handler = DefaultServeMux\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeTCP(net.Conn)\n}\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\treturn s.serveTCP(listener)\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tselect {\n\t\tcase <-s.shutdown:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.lock.Lock()\n\t\t\ts.conns[conn] = struct{}{}\n\t\t\ts.lock.Unlock()\n\t\t\twg.Add(1)\n\t\t\tgo s.serveTCPConn(&wg, conn)\n\t\t}\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n\n\tconn.SetReadDeadline(time.Now().Add(s.getReadTimeout()))\n\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\tidleTimeout := s.IdleTimeout()\n\tif idleTimeout > 0 {\n\t\tconn.SetDeadline(time.Now().Add(idleTimeout))\n\t}\n\n\ts.Handler.ServeTCP(conn)\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn\n\t}\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\tif s.ReadTimeout > 0 {\n\t\treturn s.ReadTimeout\n\t}\n\treturn 5 * time.Second // default read timeout\n}\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle multiple client connections concurrently, with support for both plain TCP and TLS-secured connections. The server should manage connection lifecycles, timeouts, and provide hooks for customizing reader/writer behavior.\n\nStruct Description: The Server struct represents a configurable TCP server that can handle DNS queries (though this could be adapted for other protocols). It manages listener lifecycle, connection pooling, and provides various timeout and security configurations.\n\nFields:\n\nAddr: string - The address to listen on (e.g., \":domain\")\nNet: string - Network type (\"tcp\", \"tcp4\", \"tcp6\", or their TLS variants)\nListener: net.Listener - The active TCP listener\nTLSConfig: *tls.Config - Configuration for TLS connections\nPacketConn: net.PacketConn - UDP connection (not used in TCP mode)\nHandler: Handler - Handler for incoming requests\nUDPSize: int - UDP buffer size\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nIdleTimeout: func() time.Duration - Function returning idle timeout duration\nTsigProvider: TsigProvider - TSIG provider for DNS\nTsigSecret: map[string]string - TSIG secrets\nNotifyStartedFunc: func() - Callback when server starts\nDecorateReader: DecorateReader - Function to decorate the reader\nDecorateWriter: DecorateWriter - Function to decorate the writer\nMaxTCPQueries: int - Maximum queries per connection\nReusePort: bool - Enable SO_REUSEPORT\nReuseAddr: bool - Enable SO_REUSEADDR\nMsgAcceptFunc: MsgAcceptFunc - Function to filter incoming messages\nlock: sync.RWMutex - Mutex for concurrent access protection\nstarted: bool - Server running state\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\nudpPool: sync.Pool - Pool for UDP buffers\n\nMethods:\n\nListenAndServe: () -> error - Starts the server and begins accepting connections\nserveTCP: (net.Listener) -> error - Internal method to serve TCP connections\nserveTCPConn: (*sync.WaitGroup, net.Conn) -> () - Handles an individual TCP connection\nisStarted: () -> bool - Checks if server is running (internal)\ninit: () -> () - Initializes server state (internal)\ngetReadTimeout: () -> time.Duration - Gets current read timeout (internal)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr     string\n\tNet      string\n\tListener net.Listener\n\tTLSConfig *tls.Config\n\tPacketConn net.PacketConn\n\tHandler   Handler\n\tUDPSize int\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tTsigProvider TsigProvider\n\tTsigSecret map[string]string\n\tNotifyStartedFunc func()\n\tDecorateReader DecorateReader\n\tDecorateWriter DecorateWriter\n\tMaxTCPQueries int\n\tReusePort bool\n\tReuseAddr bool\n\tMsgAcceptFunc MsgAcceptFunc\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n\tudpPool sync.Pool\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\tcase \"tcp-tls\", \"tcp4-tls\", \"tcp6-tls\":\n\t\tif srv.TLSConfig == nil || (len(srv.TLSConfig.Certificates) == 0 && srv.TLSConfig.GetCertificate == nil) {\n\t\t\treturn errors.New(\"dns: neither Certificates nor GetCertificate set in Config\")\n\t\t}\n\t\tnetwork := strings.TrimSuffix(srv.Net, \"-tls\")\n\t\tl, err := listenTCP(network, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = tls.NewListener(l, srv.TLSConfig)\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tif srv.NotifyStartedFunc != nil {\n\t\tsrv.NotifyStartedFunc()\n\t}\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tsigProvider: srv.tsigProvider(), tcp: rw}\n\tif srv.DecorateWriter != nil {\n\t\tw.writer = srv.DecorateWriter(w)\n\t} else {\n\t\tw.writer = w\n\t}\n\n\treader := Reader(defaultReader{srv})\n\tif srv.DecorateReader != nil {\n\t\treader = srv.DecorateReader(reader)\n\t}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface{}\ntype TsigProvider interface{}\ntype DecorateReader func(net.Conn) net.Conn\ntype DecorateWriter func(net.Conn) net.Conn\ntype MsgAcceptFunc func() bool\n\ntype Server struct {\n\tAddr             string\n\tNet              string\n\tListener         net.Listener\n\tTLSConfig        *tls.Config\n\tPacketConn       net.PacketConn\n\tHandler          Handler\n\tUDPSize          int\n\tReadTimeout      time.Duration\n\tWriteTimeout     time.Duration\n\tIdleTimeout      func() time.Duration\n\tTsigProvider     TsigProvider\n\tTsigSecret       map[string]string\n\tNotifyStartedFunc func()\n\tDecorateReader   DecorateReader\n\tDecorateWriter   DecorateWriter\n\tMaxTCPQueries    int\n\tReusePort        bool\n\tReuseAddr        bool\n\tMsgAcceptFunc    MsgAcceptFunc\n\tlock             sync.RWMutex\n\tstarted          bool\n\tshutdown         chan struct{}\n\tconns            map[net.Conn]struct{}\n\tudpPool          sync.Pool\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tvar err error\n\ts.Listener, err = net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif s.NotifyStartedFunc != nil {\n\t\ts.NotifyStartedFunc()\n\t}\n\treturn s.serveTCP(s.Listener)\n}\n\nfunc (s *Server) serveTCP(l net.Listener) error {\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\n\tif s.DecorateReader != nil {\n\t\tconn = s.DecorateReader(conn)\n\t}\n\tif s.DecorateWriter != nil {\n\t\tconn = s.DecorateWriter(conn)\n\t}\n\n\ts.lock.Lock()\n\ts.conns[conn] = struct{}{}\n\ts.lock.Unlock()\n\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t}()\n\n\tfor {\n\t\tif s.ReadTimeout > 0 {\n\t\t\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\t\t}\n\t\tif s.WriteTimeout > 0 {\n\t\t\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t\t}\n\n\t\t// Placeholder for actual request handling\n\t\tif s.MsgAcceptFunc != nil && !s.MsgAcceptFunc() {\n\t\t\treturn\n\t\t}\n\n\t\t// Simulate handling a request\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\tif s.MaxTCPQueries > 0 {\n\t\t\ts.MaxTCPQueries--\n\t\t\tif s.MaxTCPQueries == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn\n\t}\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\tif s.IdleTimeout != nil {\n\t\treturn s.IdleTimeout()\n\t}\n\treturn s.ReadTimeout\n}\n\nfunc main() {\n\t// Example usage\n\tserver := &Server{\n\t\tAddr:        \":8080\",\n\t\tNet:         \"tcp\",\n\t\tReadTimeout: 5 * time.Second,\n\t}\n\tserver.ListenAndServe()\n}\n```"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a TCP echo server in Go that listens for incoming connections on a specified port, reads data from clients, and echoes the same data back to them.\n\nFunction Description: The function implements a simple TCP server that continuously accepts client connections, reads data from each connection, and writes the same data back (echo). It handles network errors appropriately and ensures resources are cleaned up.\n\nInput: None (The port number is hardcoded as \":9000\" in the implementation)\n\nOutput: None (The function runs indefinitely until interrupted, with all output being network communication with clients)",
    "Canonical_solution": "import \"net\"\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfor {\n\t\t\tbs := make([]byte, 1024)\n\t\t\tn, err := conn.Read(bs)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t_, err = conn.Write(bs[:n])\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tfmt.Println(\"Server listening on port 9000\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tmessage, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\t\treturn\n\t\t}\n\t\t_, err = conn.Write([]byte(message))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to connection:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Implement a TCP-based HTTP proxy server in Go that handles both HTTP and HTTPS requests, supports basic authentication, and can optionally pretend to be a web server.\n\nStruct Description: The HTTP struct represents an HTTP proxy server with configurable authentication and behavior settings.\n\nFields:\naddr: string - The address and port on which the server listens\nuser: string - Username for basic authentication (empty if no auth required)\npassword: string - Password for basic authentication (empty if no auth required)\npretend: bool - Whether to pretend to be a web server (return 404 responses)\nproxy: proxy.Proxy - The underlying proxy implementation for forwarding requests\n\nMethods:\nListenAndServe: () -> () - Starts the TCP listener on the configured address and begins accepting connections\nServe: (net.Conn) -> () - Handles an individual client connection (sets keepalive, parses requests)\nservRequest: (*request, *proxy.Conn) -> () - Processes authenticated requests and routes to HTTP/HTTPS handlers\nservHTTPS: (*request, net.Conn) -> () - Handles HTTPS CONNECT requests by establishing tunnel\nservHTTP: (*request, *proxy.Conn) -> () - Handles regular HTTP requests by forwarding and modifying headers",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/textproto\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\ntype HTTP struct {\n\taddr     string\n\tuser     string\n\tpassword string\n\tpretend  bool\n\tproxy    proxy.Proxy\n}\n\nfunc (s *HTTP) ListenAndServe() {\n\tl, err := net.Listen(\"tcp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[http] failed to listen on %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tlog.F(\"[http] listening TCP on %s\", s.addr)\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.F(\"[http] failed to accept: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.Serve(c)\n\t}\n}\n\nfunc (s *HTTP) Serve(cc net.Conn) {\n\tif c, ok := cc.(*net.TCPConn); ok {\n\t\tc.SetKeepAlive(true)\n\t}\n\n\tc := proxy.NewConn(cc)\n\tdefer c.Close()\n\n\treq, err := parseRequest(c.Reader())\n\tif err != nil {\n\t\tlog.F(\"[http] can not parse request from %s, error: %v\", c.RemoteAddr(), err)\n\t\treturn\n\t}\n\n\tif s.pretend {\n\t\tfmt.Fprintf(c, \"%s 404 Not Found\\r\\nServer: nginx\\r\\n\\r\\n404 Not Found\\r\\n\", req.proto)\n\t\tlog.F(\"[http] %s <-> %s, pretend as web server\", c.RemoteAddr().String(), s.Addr())\n\t\treturn\n\t}\n\n\ts.servRequest(req, c)\n}\n\nfunc (s *HTTP) servRequest(req *request, c *proxy.Conn) {\n\tif s.user != \"\" && s.password != \"\" {\n\t\tif user, pass, ok := extractUserPass(req.auth); !ok || user != s.user || pass != s.password {\n\t\t\tio.WriteString(c, \"HTTP/1.1 407 Proxy Authentication Required\\r\\nProxy-Authenticate: Basic\\r\\n\\r\\n\")\n\t\t\tlog.F(\"[http] auth failed from %s, auth info: %s:%s\", c.RemoteAddr(), user, pass)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif req.method == \"CONNECT\" {\n\t\ts.servHTTPS(req, c)\n\t\treturn\n\t}\n\n\ts.servHTTP(req, c)\n}\n\nfunc (s *HTTP) servHTTPS(r *request, c net.Conn) {\n\trc, dialer, err := s.proxy.Dial(\"tcp\", r.uri)\n\tif err != nil {\n\t\tio.WriteString(c, r.proto+\" 502 ERROR\\r\\n\\r\\n\")\n\t\tlog.F(\"[http] %s <-> %s [c] via %s, error in dial: %v\", c.RemoteAddr(), r.uri, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tio.WriteString(c, \"HTTP/1.1 200 Connection established\\r\\n\\r\\n\")\n\n\tlog.F(\"[http] %s <-> %s [c] via %s\", c.RemoteAddr(), r.uri, dialer.Addr())\n\n\tif err = proxy.Relay(c, rc); err != nil {\n\t\tlog.F(\"[http] %s <-> %s via %s, relay error: %v\", c.RemoteAddr(), r.uri, dialer.Addr(), err)\n\t\tif !strings.Contains(err.Error(), s.addr) {\n\t\t\ts.proxy.Record(dialer, false)\n\t\t}\n\t}\n}\n\nfunc (s *HTTP) servHTTP(req *request, c *proxy.Conn) {\n\trc, dialer, err := s.proxy.Dial(\"tcp\", req.target)\n\tif err != nil {\n\t\tfmt.Fprintf(c, \"%s 502 ERROR\\r\\n\\r\\n\", req.proto)\n\t\tlog.F(\"[http] %s <-> %s via %s, error in dial: %v\", c.RemoteAddr(), req.target, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.PutBytesBuffer(buf)\n\n\treq.WriteBuf(buf)\n\t_, err = rc.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tgo func() {\n\t\tif _, err := c.Reader().Peek(1); err == nil {\n\t\t\tproxy.Copy(rc, c)\n\t\t\trc.SetDeadline(time.Now())\n\t\t\tc.SetDeadline(time.Now())\n\t\t}\n\t}()\n\n\tr := pool.GetBufReader(rc)\n\tdefer pool.PutBufReader(r)\n\n\ttpr := textproto.NewReader(r)\n\tline, err := tpr.ReadLine()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tproto, code, status, ok := parseStartLine(line)\n\tif !ok {\n\t\treturn\n\t}\n\n\theader, err := tpr.ReadMIMEHeader()\n\tif err != nil {\n\t\tlog.F(\"[http] read header error:%s\", err)\n\t\treturn\n\t}\n\n\theader.Set(\"Proxy-Connection\", \"close\")\n\theader.Set(\"Connection\", \"close\")\n\n\tbuf.Reset()\n\twriteStartLine(buf, proto, code, status)\n\twriteHeaders(buf, header)\n\n\tlog.F(\"[http] %s <-> %s via %s\", c.RemoteAddr(), req.target, dialer.Addr())\n\tc.Write(buf.Bytes())\n\n\tproxy.Copy(c, r)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype HTTP struct {\n\taddr     string\n\tuser     string\n\tpassword string\n\tpretend  bool\n\tproxy    proxy.Proxy\n}\n\nfunc (h *HTTP) ListenAndServe() {\n\tlistener, err := net.Listen(\"tcp\", h.addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo h.Serve(conn)\n\t}\n}\n\nfunc (h *HTTP) Serve(conn net.Conn) {\n\tdefer conn.Close()\n\tconn.SetDeadline(time.Now().Add(5 * time.Minute))\n\treader := bufio.NewReader(conn)\n\n\treq, err := http.ReadRequest(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif h.user != \"\" && h.password != \"\" {\n\t\tauth := req.Header.Get(\"Proxy-Authorization\")\n\t\tif !h.authenticate(auth) {\n\t\t\th.sendProxyAuthRequired(conn)\n\t\t\treturn\n\t\t}\n\t}\n\n\tproxyConn, err := h.proxy.Connect(req.URL.Host)\n\tif err != nil {\n\t\th.sendBadGateway(conn)\n\t\treturn\n\t}\n\tdefer proxyConn.Close()\n\n\th.servRequest(req, proxyConn)\n}\n\nfunc (h *HTTP) servRequest(req *http.Request, proxyConn *proxy.Conn) {\n\tif req.Method == http.MethodConnect {\n\t\th.servHTTPS(req, proxyConn)\n\t} else {\n\t\th.servHTTP(req, proxyConn)\n\t}\n}\n\nfunc (h *HTTP) servHTTPS(req *http.Request, conn net.Conn) {\n\tfmt.Fprintf(conn, \"HTTP/1.1 200 Connection Established\\r\\n\\r\\n\")\n\th.proxy.Tunnel(conn, req.URL.Host)\n}\n\nfunc (h *HTTP) servHTTP(req *http.Request, proxyConn *proxy.Conn) {\n\tif h.pretend {\n\t\th.sendNotFound(proxyConn)\n\t\treturn\n\t}\n\n\treq.RequestURI = \"\"\n\treq.Header.Del(\"Proxy-Authorization\")\n\treq.Write(proxyConn)\n\n\tresp, err := http.ReadResponse(bufio.NewReader(proxyConn), req)\n\tif err != nil {\n\t\th.sendBadGateway(proxyConn)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tresp.Write(proxyConn)\n}\n\nfunc (h *HTTP) authenticate(auth string) bool {\n\tif !strings.HasPrefix(auth, \"Basic \") {\n\t\treturn false\n\t}\n\tpayload, err := base64.StdEncoding.DecodeString(auth[6:])\n\tif err != nil {\n\t\treturn false\n\t}\n\tparts := strings.SplitN(string(payload), \":\", 2)\n\tif len(parts) != 2 {\n\t\treturn false\n\t}\n\treturn parts[0] == h.user && parts[1] == h.password\n}\n\nfunc (h *HTTP) sendProxyAuthRequired(conn net.Conn) {\n\tfmt.Fprintf(conn, \"HTTP/1.1 407 Proxy Authentication Required\\r\\nProxy-Authenticate: Basic realm=\\\"Proxy\\\"\\r\\n\\r\\n\")\n}\n\nfunc (h *HTTP) sendBadGateway(conn net.Conn) {\n\tfmt.Fprintf(conn, \"HTTP/1.1 502 Bad Gateway\\r\\n\\r\\n\")\n}\n\nfunc (h *HTTP) sendNotFound(conn net.Conn) {\n\tfmt.Fprintf(conn, \"HTTP/1.1 404 Not Found\\r\\n\\r\\n\")\n}\n\ntype proxy struct{}\n\nfunc (p *proxy) Connect(host string) (*proxy.Conn, error) {\n\treturn nil, nil\n}\n\nfunc (p *proxy) Tunnel(conn net.Conn, host string) {}\n\ntype proxyConn struct{}\n\nfunc (pc *proxyConn) Close() error {\n\treturn nil\n}\n\nfunc main() {\n\thttpProxy := &HTTP{\n\t\taddr:     \":8080\",\n\t\tuser:     \"user\",\n\t\tpassword: \"pass\",\n\t\tpretend:  false,\n\t\tproxy:    &proxy{},\n\t}\n\thttpProxy.ListenAndServe()\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement an HTTP transport struct for sending tracing spans to a collector using Thrift serialization and HTTP protocol.\n\nStruct Description: HTTPTransport is a struct that handles batching and sending tracing spans to a remote collector via HTTP. It supports basic authentication and custom HTTP client configuration.\n\nFields:\n- logger: jaeger.Logger - Logger for reporting errors and debug information\n- url: string - The collector endpoint URL\n- client: *http.Client - Custom HTTP client for making requests\n- batchSize: int - Maximum number of spans to batch before flushing\n- batch: []*zipkincore.Span - Current batch of spans waiting to be sent\n- httpCredentials: *HTTPBasicAuthCredentials - Optional basic auth credentials\n\nMethods:\n- NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) - Constructor that creates a new HTTPTransport with default values and applies options\n- Append(span *jaeger.Span) (int, error) - Adds a span to the current batch, flushes if batch size is reached\n- Flush() (int, error) - Sends all batched spans to the collector and resets the batch\n- Close() error - Cleanup method (currently no-op)\n- send(spans []*zipkincore.Span) error - Internal method that serializes and sends spans via HTTP POST\n- httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) - Helper method that serializes spans using Thrift protocol\n\nAdditional Struct:\n- HTTPBasicAuthCredentials: struct - Holds basic authentication credentials\n  Fields:\n  - username: string - Basic auth username\n  - password: string - Basic auth password",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tc := &HTTPTransport{\n\t\tlogger:    log.NullLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{Timeout: defaultHTTPTimeout},\n\t\tbatchSize: 100,\n\t\tbatch:     []*zipkincore.Span{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(c)\n\t}\n\treturn c, nil\n}\n\nfunc (c *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzSpan := jaeger.BuildZipkinThrift(span)\n\tc.batch = append(c.batch, zSpan)\n\tif len(c.batch) >= c.batchSize {\n\t\treturn c.Flush()\n\t}\n\treturn 0, nil\n}\n\nfunc (c *HTTPTransport) Flush() (int, error) {\n\tcount := len(c.batch)\n\tif count == 0 {\n\t\treturn 0, nil\n\t}\n\terr := c.send(c.batch)\n\tc.batch = c.batch[:0]\n\treturn count, err\n}\n\nfunc (c *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (c *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", c.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif c.httpCredentials != nil {\n\t\treq.SetBasicAuth(c.httpCredentials.username, c.httpCredentials.password)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read response from collector: %s\", err)\n\t}\n\n\tif resp.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"error from collector: code=%d body=%q\", resp.StatusCode, string(respBytes))\n\t}\n\n\treturn nil\n}\n\nfunc httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tt := thrift.NewTMemoryBuffer()\n\tp := thrift.NewTBinaryProtocolTransport(t)\n\tctx := context.Background()\n\tif err := p.WriteListBegin(ctx, thrift.STRUCT, len(spans)); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range spans {\n\t\tif err := s.Write(ctx, p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif err := p.WriteListEnd(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn t.Buffer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n\tmu              sync.Mutex\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\ntype HTTPOption func(*HTTPTransport)\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\ttransport := &HTTPTransport{\n\t\tlogger:    log.StdLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{},\n\t\tbatchSize: 100,\n\t\tbatch:     make([]*zipkincore.Span, 0),\n\t}\n\n\tfor _, option := range options {\n\t\toption(transport)\n\t}\n\n\treturn transport, nil\n}\n\nfunc WithHTTPClient(client *http.Client) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.client = client\n\t}\n}\n\nfunc WithBatchSize(size int) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.batchSize = size\n\t}\n}\n\nfunc WithBasicAuth(username, password string) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.httpCredentials = &HTTPBasicAuthCredentials{username: username, password: password}\n\t}\n}\n\nfunc (t *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tzipkinSpan := jaeger.BuildZipkinThrift(span)\n\tt.batch = append(t.batch, zipkinSpan)\n\n\tif len(t.batch) >= t.batchSize {\n\t\treturn t.Flush()\n\t}\n\n\treturn 0, nil\n}\n\nfunc (t *HTTPTransport) Flush() (int, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tif len(t.batch) == 0 {\n\t\treturn 0, nil\n\t}\n\n\terr := t.send(t.batch)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tcount := len(t.batch)\n\tt.batch = t.batch[:0]\n\treturn count, nil\n}\n\nfunc (t *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (t *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := t.httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", t.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif t.httpCredentials != nil {\n\t\tauth := t.httpCredentials.username + \":\" + t.httpCredentials.password\n\t\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(auth)))\n\t}\n\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to send spans, status code: \" + resp.Status)\n\t}\n\n\t_, err = ioutil.ReadAll(resp.Body)\n\treturn err\n}\n\nfunc (t *HTTPTransport) httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tbuffer := thrift.NewTMemoryBuffer()\n\tprotocol := thrift.NewTBinaryProtocolTransport(buffer)\n\n\tfor _, span := range spans {\n\t\tif err := span.Write(protocol); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn buffer.Buffer, nil\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both query and write operations with configurable connection settings, authentication, and request parameters.\n\nStruct Description: The Client struct represents an InfluxDB client with configurable connection settings and methods for executing queries and writing data points.\n\nFields:\n\nurl: url.URL - Base URL of the InfluxDB server\nunixSocket: string - Path to Unix domain socket for connection (alternative to TCP)\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nhttpClient: *http.Client - Custom HTTP client with configured transport and timeout\nuserAgent: string - User agent string for HTTP requests\nprecision: string - Default precision for timestamps in queries/writes\n\nMethods:\n\nNewClient: [Name](Config) -> (*Client, error) - Creates a new Client instance with the provided configuration, setting up TLS, proxy, and Unix socket options as needed.\n\nQueryContext: [Name](context.Context, Query) -> (*Response, error) - Executes a query against the InfluxDB server with context support, handling both regular and chunked responses.\n\nWrite: [Name](BatchPoints) -> (*Response, error) - Writes a batch of points to the InfluxDB server, handling serialization and request configuration.\n\nThe Client provides methods for both querying and writing data to InfluxDB with support for:\n- Custom HTTP client configuration (timeouts, TLS, proxies)\n- Unix socket connections\n- Basic authentication\n- Chunked query responses\n- Custom precision for timestamps\n- Context-aware operations\n- Error handling for HTTP and InfluxDB-specific errors",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := new(tls.Config)\n\tif c.TLS != nil {\n\t\ttlsConfig = c.TLS.Clone()\n\t}\n\ttlsConfig.InsecureSkipVerify = c.UnsafeSsl\n\n\ttr := &http.Transport{\n\t\tProxy:           c.Proxy,\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tif c.UnixSocket != \"\" {\n\t\ttr.DisableCompression = true\n\t\ttr.DialContext = func(_ context.Context, _, _ string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", c.UnixSocket)\n\t\t}\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tunixSocket: c.UnixSocket,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"query\")\n\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", q.RetentionPolicy)\n\t}\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif q.NodeID > 0 {\n\t\tvalues.Set(\"node_id\", strconv.Itoa(q.NodeID))\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"POST\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"write\")\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage influxdb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\ntype Config struct {\n\tURL        string\n\tUnixSocket string\n\tUsername   string\n\tPassword   string\n\tTimeout    time.Duration\n\tUserAgent  string\n\tPrecision  string\n\tTLSConfig  *tls.Config\n\tProxyURL   string\n}\n\ntype Query struct {\n\tCommand  string\n\tDatabase string\n}\n\ntype BatchPoints struct {\n\tPoints   []Point\n\tDatabase string\n}\n\ntype Point struct {\n\tMeasurement string\n\tTags        map[string]string\n\tFields      map[string]interface{}\n\tTimestamp   time.Time\n}\n\ntype Response struct {\n\tResults []Result\n\tErr     error\n}\n\ntype Result struct {\n\tSeries []Series\n\tErr    error\n}\n\ntype Series struct {\n\tName    string\n\tColumns []string\n\tValues  [][]interface{}\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tparsedURL, err := url.Parse(config.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: config.TLSConfig,\n\t}\n\n\tif config.UnixSocket != \"\" {\n\t\ttransport.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", config.UnixSocket)\n\t\t}\n\t}\n\n\tif config.ProxyURL != \"\" {\n\t\tproxyURL, err := url.Parse(config.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttransport.Proxy = http.ProxyURL(proxyURL)\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   config.Timeout,\n\t}\n\n\treturn &Client{\n\t\turl:        *parsedURL,\n\t\tunixSocket: config.UnixSocket,\n\t\tusername:   config.Username,\n\t\tpassword:   config.Password,\n\t\thttpClient: client,\n\t\tuserAgent:  config.UserAgent,\n\t\tprecision:  config.Precision,\n\t}, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, query Query) (*Response, error) {\n\treqURL := c.url\n\treqURL.Path = \"/query\"\n\tparams := url.Values{}\n\tparams.Set(\"q\", query.Command)\n\tparams.Set(\"db\", query.Database)\n\treqURL.RawQuery = params.Encode()\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", reqURL.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.username, c.password)\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to execute query\")\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(batch BatchPoints) (*Response, error) {\n\treqURL := c.url\n\treqURL.Path = \"/write\"\n\tparams := url.Values{}\n\tparams.Set(\"db\", batch.Database)\n\tparams.Set(\"precision\", c.precision)\n\treqURL.RawQuery = params.Encode()\n\n\tvar buf bytes.Buffer\n\tfor _, point := range batch.Points {\n\t\tline := fmt.Sprintf(\"%s,%s %s %d\\n\", point.Measurement, formatTags(point.Tags), formatFields(point.Fields), point.Timestamp.UnixNano())\n\t\tbuf.WriteString(line)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", reqURL.String(), &buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.username, c.password)\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Content-Type\", \"text/plain\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusNoContent {\n\t\treturn nil, errors.New(\"failed to write data\")\n\t}\n\n\treturn &Response{}, nil\n}\n\nfunc formatTags(tags map[string]string) string {\n\tvar buf bytes.Buffer\n\tfor k, v := range tags {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s=%s,\", k, v))\n\t}\n\treturn buf.String()\n}\n\nfunc formatFields(fields map[string]interface{}) string {\n\tvar buf bytes.Buffer\n\tfor k, v := range fields {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s=%v,\", k, v))\n\t}\n\treturn buf.String()\n}\n```"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and graceful shutdown capabilities.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - Interface for handling incoming requests\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nShutdownContext(context.Context) error - Gracefully shuts down the server with context support\nisStarted() bool - Helper method to check server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw, writer: w}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) ShutdownContext(ctx context.Context) error {\n\tsrv.lock.Lock()\n\tif !srv.started {\n\t\tsrv.lock.Unlock()\n\t\treturn &Error{err: \"server not started\"}\n\t}\n\n\tsrv.started = false\n\n\tif srv.Listener != nil {\n\t\tsrv.Listener.Close()\n\t}\n\n\tfor rw := range srv.conns {\n\t\trw.SetReadDeadline(aLongTimeAgo)\n\t}\n\n\tsrv.lock.Unlock()\n\n\tvar ctxErr error\n\tselect {\n\tcase <-srv.shutdown:\n\tcase <-ctx.Done():\n\t\tctxErr = ctx.Err()\n\t}\n\n\treturn ctxErr\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeTCP(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tif s.started {\n\t\ts.lock.Unlock()\n\t\treturn fmt.Errorf(\"server already started\")\n\t}\n\ts.started = true\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.lock.Unlock()\n\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\n\treturn s.serveTCP(listener)\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\twg.Wait()\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n\n\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\n\tif s.IdleTimeout != nil {\n\t\tconn.SetDeadline(time.Now().Add(s.IdleTimeout()))\n\t}\n\n\ts.Handler.ServeTCP(conn)\n}\n\nfunc (s *Server) ShutdownContext(ctx context.Context) error {\n\ts.lock.Lock()\n\tif !s.started {\n\t\ts.lock.Unlock()\n\t\treturn fmt.Errorf(\"server not started\")\n\t}\n\ts.started = false\n\tclose(s.shutdown)\n\ts.lock.Unlock()\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\ts.lock.Lock()\n\t\tfor conn := range s.conns {\n\t\t\tconn.Close()\n\t\t}\n\t\ts.lock.Unlock()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase <-done:\n\t\treturn nil\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\ntype EchoHandler struct{}\n\nfunc (h *EchoHandler) ServeTCP(conn net.Conn) {\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tconn.Write(buf[:n])\n\t}\n}\n\nfunc main() {\n\tserver := &Server{\n\t\tAddr:        \":8080\",\n\t\tNet:         \"tcp\",\n\t\tHandler:     &EchoHandler{},\n\t\tReadTimeout: 10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t\tIdleTimeout: func() time.Duration { return 30 * time.Second },\n\t}\n\n\tgo func() {\n\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\tfmt.Println(\"Server error:\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(1 * time.Minute)\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tserver.ShutdownContext(ctx)\n}\n```"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Create a Unix domain socket server in Go that listens for incoming connections, handles client communication, and processes received data through a product function. The server should manage connection limits, timeouts, and proper resource cleanup.\n\nStruct Description: The `unix` struct represents a Unix domain socket server with configuration options for path, permissions, and connection handling. It manages the socket lifecycle and processes incoming data.\n\nFields:\n- name: string - Identifier for the server instance\n- config: *Config - Pointer to configuration containing path, mode, timeout, max connections, and max bytes\n- done: chan struct{} - Channel to signal server shutdown\n- eventPool: *event.Pool - Pool for managing event objects\n\nMethods:\n- ProductLoop(productFunc api.ProductFunc) -> void - Main server loop that listens for connections and delegates handling to worker goroutines. Takes a product function for processing events.\n- handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) -> void - Handles individual client connections, reads data, and passes it to the product function. Manages connection timeouts and cleanup.\n- checkBind(path string) -> error - Validates and prepares the socket path by removing existing files if necessary\n- chmod(path string, mode string) -> error - Sets filesystem permissions on the socket file",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/netutil\"\n)\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (k *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", k.String())\n\n\tif err := checkBind(k.config.Path); err != nil {\n\t\tlog.Error(\"check unix sock path error: %+v\", err)\n\t\treturn\n\t}\n\n\tlistener, err := net.Listen(\"unix\", k.config.Path)\n\tif err != nil {\n\t\tlog.Error(\"setup unix listener failed: %v\", err)\n\t\treturn\n\t}\n\n\tif err := chmod(k.config.Path, k.config.Mode); err != nil {\n\t\tlog.Error(\"chmod unix path %s with %s failed: %v\", k.config.Path, k.config.Mode, err)\n\t\treturn\n\t}\n\n\tif k.config.MaxConnections > 0 {\n\t\tlistener = netutil.LimitListener(listener, k.config.MaxConnections)\n\t}\n\n\tdefer listener.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfor {\n\t\tselect {\n\t\tcase <-k.done:\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"unix sock listener accept connection failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo k.handleConn(ctx, conn, productFunc)\n\t}\n}\n\nfunc (k *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuf := bufio.NewReader(conn)\n\tscan := bufio.NewScanner(buf)\n\n\tinitBuffer := make([]byte, k.config.MaxBytes/4)\n\tscan.Buffer(initBuffer, k.config.MaxBytes)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tif err := conn.SetDeadline(time.Now().Add(k.config.Timeout)); err != nil {\n\t\t\tlog.Warn(\"set connection timeout error: %v\", err)\n\t\t}\n\n\t\tif !scan.Scan() {\n\t\t\tif scan.Err() != nil {\n\t\t\t\tlog.Warn(\"scan connection error: %v\", scan.Err())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tbody := scan.Bytes()\n\t\tcopyBody := make([]byte, len(body))\n\t\tcopy(copyBody, body)\n\t\te := k.eventPool.Get()\n\t\te.Fill(e.Meta(), e.Header(), copyBody)\n\n\t\tproductFunc(e)\n\t}\n}\n\nfunc checkBind(path string) error {\n\t_, err := os.Lstat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errors.WithMessagef(err, \"stat path %s failed\", path)\n\t}\n\n\tif err := os.Remove(path); err != nil {\n\t\treturn errors.WithMessagef(err, \"remove path %s failed\", path)\n\t}\n\n\treturn nil\n}\n\nfunc chmod(path string, mode string) error {\n\tparsed, err := strconv.ParseUint(mode, 8, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(path, os.FileMode(parsed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype Config struct {\n\tPath          string\n\tMode          os.FileMode\n\tTimeout       time.Duration\n\tMaxConnections int\n\tMaxBytes      int\n}\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *sync.Pool\n}\n\nfunc (u *unix) ProductLoop(productFunc func([]byte) error) {\n\tlistener, err := net.Listen(\"unix\", u.config.Path)\n\tif err != nil {\n\t\tfmt.Println(\"Error listening:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tif err := u.chmod(u.config.Path, u.config.Mode); err != nil {\n\t\tfmt.Println(\"Error setting permissions:\", err)\n\t\treturn\n\t}\n\n\tvar wg sync.WaitGroup\n\tconnChan := make(chan net.Conn, u.config.MaxConnections)\n\n\tfor {\n\t\tselect {\n\t\tcase <-u.done:\n\t\t\tclose(connChan)\n\t\t\twg.Wait()\n\t\t\treturn\n\t\tdefault:\n\t\t\tlistener.(*net.UnixListener).SetDeadline(time.Now().Add(u.config.Timeout))\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif ne, ok := err.(net.Error); ok && ne.Timeout() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tu.handleConn(context.Background(), conn, productFunc)\n\t\t\t}()\n\t\t}\n\t}\n}\n\nfunc (u *unix) handleConn(ctx context.Context, conn net.Conn, productFunc func([]byte) error) {\n\tdefer conn.Close()\n\n\tbuf := make([]byte, u.config.MaxBytes)\n\tconn.SetDeadline(time.Now().Add(u.config.Timeout))\n\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\treturn\n\t}\n\n\tif err := productFunc(buf[:n]); err != nil {\n\t\tfmt.Println(\"Error processing data:\", err)\n\t}\n}\n\nfunc (u *unix) checkBind(path string) error {\n\tif err := os.RemoveAll(path); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove existing socket file: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (u *unix) chmod(path string, mode os.FileMode) error {\n\tif err := os.Chmod(path, mode); err != nil {\n\t\treturn fmt.Errorf(\"failed to set permissions: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tconfig := &Config{\n\t\tPath:          \"/tmp/unix.sock\",\n\t\tMode:          0666,\n\t\tTimeout:       5 * time.Second,\n\t\tMaxConnections: 10,\n\t\tMaxBytes:      1024,\n\t}\n\n\tserver := &unix{\n\t\tname:      \"UnixSocketServer\",\n\t\tconfig:    config,\n\t\tdone:      make(chan struct{}),\n\t\teventPool: &sync.Pool{},\n\t}\n\n\tproductFunc := func(data []byte) error {\n\t\tfmt.Println(\"Received data:\", string(data))\n\t\treturn nil\n\t}\n\n\tif err := server.checkBind(config.Path); err != nil {\n\t\tfmt.Println(\"Error preparing socket path:\", err)\n\t\treturn\n\t}\n\n\tserver.ProductLoop(productFunc)\n}\n```"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle multiple client connections concurrently, with support for both plain TCP and TLS-secured connections. The server should manage connection timeouts, track active connections, and provide hooks for custom message handling.\n\nStruct Description: The Server struct represents a TCP server that can listen for incoming connections, handle them concurrently, and manage server lifecycle operations. It supports both plain TCP and TLS configurations.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (tcp, tcp4, tcp6, or their TLS variants)\nListener: net.Listener - The active network listener\nTLSConfig: *tls.Config - Configuration for TLS connections\nPacketConn: net.PacketConn - UDP connection handler (unused in TCP implementation)\nHandler: Handler - Interface for handling incoming messages\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nMsgAcceptFunc: MsgAcceptFunc - Function to filter acceptable messages\nlock: sync.RWMutex - Mutex for protecting concurrent access to server state\nstarted: bool - Flag indicating if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Map of active connections\nudpPool: sync.Pool - Pool for UDP resources (unused in TCP implementation)\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nisStarted() bool - Helper method to check server running state\ninit() - Initializes server internal structures\ngetReadTimeout() time.Duration - Gets the current read timeout value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr         string\n\tNet          string\n\tListener     net.Listener\n\tTLSConfig    *tls.Config\n\tPacketConn   net.PacketConn\n\tHandler      Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tMsgAcceptFunc MsgAcceptFunc\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n\tudpPool  sync.Pool\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\tcase \"tcp-tls\", \"tcp4-tls\", \"tcp6-tls\":\n\t\tif srv.TLSConfig == nil || (len(srv.TLSConfig.Certificates) == 0 && srv.TLSConfig.GetCertificate == nil) {\n\t\t\treturn errors.New(\"dns: neither Certificates nor GetCertificate set in Config\")\n\t\t}\n\t\tnetwork := strings.TrimSuffix(srv.Net, \"-tls\")\n\t\tl, err := listenTCP(network, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = tls.NewListener(l, srv.TLSConfig)\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tif srv.NotifyStartedFunc != nil {\n\t\tsrv.NotifyStartedFunc()\n\t}\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tsigSecret: srv.TsigSecret, tcp: rw}\n\tif srv.DecorateWriter != nil {\n\t\tw.writer = srv.DecorateWriter(w)\n\t} else {\n\t\tw.writer = w\n\t}\n\n\treader := Reader(defaultReader{srv})\n\tif srv.DecorateReader != nil {\n\t\treader = srv.DecorateReader(reader)\n\t}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tHandle(conn net.Conn)\n}\n\ntype MsgAcceptFunc func(msg []byte) bool\n\ntype Server struct {\n\tAddr         string\n\tNet          string\n\tListener     net.Listener\n\tTLSConfig    *tls.Config\n\tPacketConn   net.PacketConn\n\tHandler      Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tMsgAcceptFunc MsgAcceptFunc\n\tlock         sync.RWMutex\n\tstarted      bool\n\tshutdown     chan struct{}\n\tconns        map[net.Conn]struct{}\n\tudpPool      sync.Pool\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tvar err error\n\tif s.Net == \"tcp\" || s.Net == \"tcp4\" || s.Net == \"tcp6\" {\n\t\ts.Listener, err = net.Listen(s.Net, s.Addr)\n\t} else if s.Net == \"tls\" {\n\t\ts.Listener, err = tls.Listen(\"tcp\", s.Addr, s.TLSConfig)\n\t} else {\n\t\treturn fmt.Errorf(\"unsupported network type: %s\", s.Net)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Listener.Close()\n\treturn s.serveTCP(s.Listener)\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n\n\tif s.ReadTimeout > 0 {\n\t\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\t}\n\tif s.WriteTimeout > 0 {\n\t\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t}\n\n\ts.Handler.Handle(conn)\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn\n\t}\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\tif s.IdleTimeout != nil {\n\t\treturn s.IdleTimeout()\n\t}\n\treturn s.ReadTimeout\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets specific IPv6 traffic class and hop limit for IPv6 connections, and sends an acknowledgment message to each client.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and configures specific network parameters (traffic class and hop limit) if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. Each client connection is handled in a separate goroutine.\n\nInput: None (The function takes no explicit parameters but binds to port 1024 by default)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations and may log fatal errors)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting TCP server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tif addr, ok := conn.RemoteAddr().(*net.TCPAddr); ok && addr.IP.To16() != nil {\n\t\tfd, err := conn.(*net.TCPConn).File()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error getting file descriptor:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer fd.Close()\n\n\t\tif err := syscall.SetsockoptInt(int(fd.Fd()), syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, 0x20); err != nil {\n\t\t\tfmt.Println(\"Error setting IPv6 traffic class:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := syscall.SetsockoptInt(int(fd.Fd()), syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, 64); err != nil {\n\t\t\tfmt.Println(\"Error setting IPv6 hop limit:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t_, err := conn.Write([]byte(\"HELLO-R-U-THERE-ACK\"))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending acknowledgment:\", err)\n\t}\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Implement a gRPC client in Go that establishes a secure connection to a gRPC server with authentication, sends a request, and processes the response.\n\nFunction Description: The function `doClientWork` demonstrates how to create a gRPC client that connects to a server, authenticates using provided credentials, sends a \"Hello\" request, and logs the response. It handles connection setup, authentication, RPC call execution, and connection cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes, but these could be parameterized in a real implementation)\n\nOutput: None (The function logs results to stdout but doesn't return any values)\n\n---\n\nTask Description: Implement an authentication struct for gRPC credentials in Go that provides request metadata and specifies transport security requirements.\n\nStruct Description: The `Authentication` struct implements gRPC's `credentials.PerRPCCredentials` interface to provide per-RPC credentials (login/password) for gRPC requests.\n\nFields:\nLogin: string - The username for authentication\nPassword: string - The password for authentication\n\nMethods:\nGetRequestMetadata: (context.Context, ...string) -> (map[string]string, error) - Returns the authentication metadata (login/password) to be included in RPC requests\nRequireTransportSecurity: () -> bool - Indicates whether transport security is required (returns false in this implementation)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Authentication struct {\n\tLogin    string\n\tPassword string\n}\n\nfunc (a *Authentication) GetRequestMetadata(context.Context, ...string) (map[string]string, error) {\n\treturn map[string]string{\"login\": a.Login, \"password\": a.Password}, nil\n}\nfunc (a *Authentication) RequireTransportSecurity() bool {\n\treturn false\n}\n\nfunc doClientWork() {\n\tauth := Authentication{\n\t\tLogin:    \"gopher\",\n\t\tPassword: \"password\",\n\t}\n\n\tconn, err := grpc.Dial(\"localhost\"+port, grpc.WithInsecure(), grpc.WithPerRPCCredentials(&auth))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tc := NewGreeterClient(conn)\n\n\tr, err := c.SayHello(context.Background(), &HelloRequest{Name: \"gopher\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"doClientWork: %s\", r.Message)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype Authentication struct {\n\tLogin    string\n\tPassword string\n}\n\nfunc (a *Authentication) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {\n\treturn map[string]string{\n\t\t\"login\":    a.Login,\n\t\t\"password\": a.Password,\n\t}, nil\n}\n\nfunc (a *Authentication) RequireTransportSecurity() bool {\n\treturn false\n}\n\nfunc doClientWork() {\n\tauth := &Authentication{\n\t\tLogin:    \"user\",\n\t\tPassword: \"password\",\n\t}\n\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure(), grpc.WithPerRPCCredentials(auth))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewHelloServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tmd := metadata.Pairs(\"timestamp\", time.Now().Format(time.Stamp))\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\tresponse, err := client.SayHello(ctx, &HelloRequest{Message: \"Hello\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"Error calling SayHello: %v\", err)\n\t}\n\n\tlog.Printf(\"Response from server: %s\", response.GetReply())\n}\n\nfunc main() {\n\tdoClientWork()\n}\n```"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Implement a gRPC client function in Go that establishes a bidirectional streaming connection with a gRPC server, sends a chat message, and continuously receives responses from the server until the connection is closed.\n\nFunction Description: The function `Test` is a test function that demonstrates bidirectional streaming gRPC communication. It connects to a gRPC server, sends a chat message, and asynchronously receives responses from the server. The function handles connection errors, stream creation errors, and different types of response errors (including EOF when the server closes the connection).\n\nInput: None (The function is a test function with no explicit input parameters, but it connects to a predefined server address \"127.0.0.1:8089\")\n\nOutput: None (The function doesn't return any value but prints received messages and errors to stdout)\n\nNote: The function uses a deferred connection closure and runs the send operation in a separate goroutine to allow simultaneous sending and receiving. The main loop continues receiving until an EOF error or other fatal error occurs.",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"io\"\n\t\"log\"\n\t\"testing\"\n\n\t\"learning_tools/grpc/bidirectional_streaming_rpc/proto\"\n)\nfunc Test(t *testing.T) {\n\tconn, err := grpc.Dial(\"127.0.0.1:8089\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tdefer conn.Close()\n\tclient := proto.NewChatServiceClient(conn)\n\tctx := context.Background()\n\tstream, err := client.Chat(ctx)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tgo func() {\n\t\tif err := stream.Send(&proto.Request{Input: \"\u804a\u5929\"}); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\n\tfor {\n\t\tresponse, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tfmt.Println(\"\u670d\u52a1\u7aef\u7ed3\u675f\u901a\u77e5:\", err.Error())\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tfmt.Println(\"\u63a5\u53d7\u6570\u636e\u9519\u8bef:\", err.Error())\n\t\t}\n\t\tfmt.Println(\"\u670d\u52a1\u7aef\u8fd4\u56de:\", response.Output)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc Test() {\n\tconn, err := grpc.Dial(\"127.0.0.1:8089\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewChatServiceClient(conn)\n\tstream, err := client.Chat(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating stream: %v\", err)\n\t}\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tfor {\n\t\t\tin, err := stream.Recv()\n\t\t\tif err == io.EOF {\n\t\t\t\tclose(done)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to receive a message: %v\", err)\n\t\t\t}\n\t\t\tfmt.Printf(\"Received message: %s\\n\", in.GetMessage())\n\t\t}\n\t}()\n\n\tmessage := &pb.ChatMessage{Message: \"Hello, server!\"}\n\tif err := stream.Send(message); err != nil {\n\t\tlog.Fatalf(\"Failed to send a message: %v\", err)\n\t}\n\n\t<-done\n}\n```"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Create a Go function that establishes a secure gRPC client connection to a server, performs a math operation (addition) using the gRPC service, and returns the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:8092 using TLS credentials from a specified certificate file. It creates a client for the MathService, sends a request with two integer arguments, and returns the server's response containing the result of the addition operation.\n\nInput: \n- None (all configuration is hardcoded in the function)\n\nOutput:\n- Prints the response code and message from the gRPC server to stdout\n- Returns nothing (void function)\n\nNote: The function handles connection establishment, service client creation, request sending, and connection cleanup automatically. Error conditions will cause the function to panic.",
    "Canonical_solution": "import (\n\t\"google.golang.org/grpc\"\n\t\"grpcSSLCode/message\"\n\t\"context\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"fmt\"\n\t\"google.golang.org/grpc/credentials\"\n)\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile(\"./keys/server.pem\", \"go-grpc-example\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tgrpc.WithInsecure()\n\n\tconn, err := grpc.Dial(\"localhost:8092\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer conn.Close()\n\n\tserviceClient := message.NewMathServiceClient(conn)\n\n\taddArgs := message.RequestArgs{Args1: 3, Args2: 5}\n\n\tresponse, err := serviceClient.AddMethod(context.Background(), &addArgs)\n\tif err != nil {\n\t\tgrpclog.Fatal(err.Error())\n\t}\n\n\tfmt.Println(response.GetCode(), response.GetMessage())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/status\"\n\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc connectAndAdd() {\n\tcertFile := \"path/to/your/certificate.pem\"\n\tserverAddress := \"localhost:8092\"\n\n\t// Load the certificate from file\n\tcert, err := ioutil.ReadFile(certFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read certificate file: %v\", err)\n\t}\n\n\t// Create a certificate pool from the certificate authority\n\tcertPool := x509.NewCertPool()\n\tif !certPool.AppendCertsFromPEM(cert) {\n\t\tlog.Fatalf(\"Failed to append certificate to pool\")\n\t}\n\n\t// Create the TLS credentials\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tRootCAs: certPool,\n\t})\n\n\t// Establish a connection to the gRPC server\n\tconn, err := grpc.Dial(serverAddress, grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client for the MathService\n\tclient := pb.NewMathServiceClient(conn)\n\n\t// Prepare the request\n\treq := &pb.AddRequest{\n\t\tA: 5,\n\t\tB: 3,\n\t}\n\n\t// Send the request and receive the response\n\tresp, err := client.Add(context.Background(), req)\n\tif err != nil {\n\t\tst, ok := status.FromError(err)\n\t\tif ok {\n\t\t\tlog.Fatalf(\"gRPC error: %v, %v\", st.Code(), st.Message())\n\t\t} else {\n\t\t\tlog.Fatalf(\"Failed to call Add method: %v\", err)\n\t\t}\n\t}\n\n\t// Print the response\n\tfmt.Printf(\"Response: %v\\n\", resp.Result)\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a Go client for interacting with Rancher metadata service, capable of making HTTP requests with custom headers and handling connection testing with exponential backoff.\n\nStruct Description: The Client struct represents a Rancher metadata client that manages HTTP connections to Rancher metadata service endpoints.\n\nFields:\nurl: string - The base URL for Rancher metadata service (default: \"http://rancher-metadata\")\nhttpClient: *http.Client - The HTTP client used for making requests\n\nMethods:\nNewRancherClient: (backendNodes []string) -> (*Client, error) - Creates a new Rancher client instance, optionally using the first backend node if provided, and tests the connection\nmakeMetaDataRequest: (path string) -> ([]byte, error) - Makes a GET request to the specified path with JSON accept header, returns response body\ntestConnection: () -> error - Tests the connection to the metadata service with exponential backoff retry logic (up to 20 seconds)",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        string\n\thttpClient *http.Client\n}\n\nfunc NewRancherClient(backendNodes []string) (*Client, error) {\n\turl := \"http://rancher-metadata\"\n\n\tif len(backendNodes) > 0 {\n\t\turl = \"http://\" + backendNodes[0]\n\t}\n\n\tclient := &Client{\n\t\turl:        url,\n\t\thttpClient: &http.Client{},\n\t}\n\n\terr := client.testConnection()\n\treturn client, err\n}\n\nfunc (c *Client) makeMetaDataRequest(path string) ([]byte, error) {\n\treq, _ := http.NewRequest(\"GET\", strings.Join([]string{c.url, path}, \"\"), nil)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn ioutil.ReadAll(resp.Body)\n}\n\nfunc (c *Client) testConnection() error {\n\tvar err error\n\tmaxTime := 20 * time.Second\n\n\tfor i := 1 * time.Second; i < maxTime; i *= time.Duration(2) {\n\t\tif _, err = c.makeMetaDataRequest(\"/\"); err != nil {\n\t\t\ttime.Sleep(i)\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        string\n\thttpClient *http.Client\n}\n\nfunc NewRancherClient(backendNodes []string) (*Client, error) {\n\turl := \"http://rancher-metadata\"\n\tif len(backendNodes) > 0 {\n\t\turl = backendNodes[0]\n\t}\n\n\tclient := &Client{\n\t\turl:        url,\n\t\thttpClient: &http.Client{},\n\t}\n\n\tif err := client.testConnection(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn client, nil\n}\n\nfunc (c *Client) makeMetaDataRequest(path string) ([]byte, error) {\n\treq, err := http.NewRequest(\"GET\", c.url+path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch metadata\")\n\t}\n\n\treturn ioutil.ReadAll(resp.Body)\n}\n\nfunc (c *Client) testConnection() error {\n\tvar err error\n\tfor i := 0; i < 5; i++ {\n\t\t_, err = c.makeMetaDataRequest(\"/version\")\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\ttime.Sleep(time.Duration(1<<i) * time.Second)\n\t}\n\treturn errors.New(\"unable to connect to Rancher metadata service\")\n}\n\nfunc main() {\n\t// Example usage\n\tclient, err := NewRancherClient([]string{\"http://custom-metadata-url\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdata, err := client.makeMetaDataRequest(\"/self/host\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tprintln(string(data))\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a Go function that makes a gRPC call to a test service's EmptyCall method, handling connection establishment and cleanup.\n\nFunction Description: The function invokes the EmptyCall RPC method on a gRPC test service. It establishes a connection to the server with timeout and blocking options, makes the RPC call, and properly closes the connection. The function handles both connection errors and RPC call errors.\n\nInput:\n- address: string - The server address to connect to\n- dialOptions: []grpc.DialOption - List of gRPC dial options for connection configuration\n\nOutput:\n- *testpb.Empty - The response from the EmptyCall RPC\n- error - Any error that occurred during connection or RPC call",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions []grpc.DialOption) (*testpb.Empty, error) {\n\tdialOptions = append(dialOptions, grpc.WithBlock())\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tclientConn, err := grpc.DialContext(ctx, address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer clientConn.Close()\n\n\tclient := testpb.NewTestServiceClient(clientConn)\n\n\tempty, err := client.EmptyCall(context.Background(), new(testpb.Empty))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn empty, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\ttestpb \"path/to/testpb\"\n)\n\nfunc callEmptyCall(address string, dialOptions []grpc.DialOption) (*testpb.Empty, error) {\n\tconn, err := grpc.Dial(address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := testpb.NewTestServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\tresponse, err := client.EmptyCall(ctx, &testpb.Empty{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n```"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a function to register a mapper with a gRPC server using the Device Management Interface (DMI) API. The function should establish a connection to the server, send a registration request, and return the list of devices and device models provided by the server.\n\nFunction Description: The `RegisterMapper` function connects to a gRPC server using Unix domain socket, sends a mapper registration request with the provided configuration, and returns the device and device model lists from the server response. It handles connection establishment, timeout context, and proper cleanup of resources.\n\nInput: \n- `withData` [bool]: A flag indicating whether to include data in the registration request.\n\nOutput:\n- `[]*dmiapi.Device`: A slice of pointers to Device objects returned by the server.\n- `[]*dmiapi.DeviceModel`: A slice of pointers to DeviceModel objects returned by the server.\n- `error`: An error object if any step fails, nil otherwise.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdmiapi \"github.com/kubeedge/api/apis/dmi/v1beta1\"\n\t\"github.com/kubeedge/mapper-framework/pkg/common\"\n\t\"github.com/kubeedge/mapper-framework/pkg/config\"\n)\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n\tcfg := config.Cfg()\n\n\tconn, err := grpc.Dial(cfg.Common.EdgeCoreSock,\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithContextDialer(\n\t\t\tfunc(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\tunixAddress, err := net.ResolveUnixAddr(\"unix\", cfg.Common.EdgeCoreSock)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn net.DialUnix(\"unix\", nil, unixAddress)\n\t\t\t},\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := dmiapi.NewDeviceManagerServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tresp, err := c.MapperRegister(ctx, &dmiapi.MapperRegisterRequest{\n\t\tWithData: withData,\n\t\tMapper: &dmiapi.MapperInfo{\n\t\t\tName:       cfg.Common.Name,\n\t\t\tVersion:    cfg.Common.Version,\n\t\t\tApiVersion: cfg.Common.APIVersion,\n\t\t\tProtocol:   cfg.Common.Protocol,\n\t\t\tAddress:    []byte(cfg.GrpcServer.SocketPath),\n\t\t\tState:      common.DeviceStatusOK,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn resp.DeviceList, resp.ModelList, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/status\"\n\n\tdmiapi \"path/to/dmiapi\"\n)\n\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n\tconst socketPath = \"/var/run/dmi.sock\"\n\tconst timeout = 5 * time.Second\n\n\tconn, err := grpc.Dial(socketPath, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {\n\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t}))\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to connect to gRPC server: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := dmiapi.NewDeviceManagementClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\treq := &dmiapi.RegisterMapperRequest{\n\t\tWithData: withData,\n\t}\n\n\tresp, err := client.RegisterMapper(ctx, req)\n\tif err != nil {\n\t\tst, ok := status.FromError(err)\n\t\tif ok {\n\t\t\treturn nil, nil, fmt.Errorf(\"gRPC error: %s\", st.Message())\n\t\t}\n\t\treturn nil, nil, fmt.Errorf(\"failed to register mapper: %w\", err)\n\t}\n\n\treturn resp.Devices, resp.DeviceModels, nil\n}\n```"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC connection to a remote server, performs profiling operations based on input flags, and handles connection cleanup.\n\nFunction Description: The function `remoteCommand` establishes an insecure gRPC connection to a specified address, creates a profiling client, and executes either profiling enable/disable operations or retrieves a snapshot based on command-line flags. It handles connection timeouts and ensures proper connection closure.\n\nInput:\n- Context (implicit through package variables)\n- Command-line flags (implicit through package variables):\n  - `flagAddress`: string - gRPC server address to connect to\n  - `flagTimeout`: int - connection timeout in seconds (0 for no timeout)\n  - `flagEnableProfiling`: bool - whether to enable profiling\n  - `flagDisableProfiling`: bool - whether to disable profiling\n  - `flagRetrieveSnapshot`: bool - whether to retrieve a snapshot\n  - `flagSnapshot`: string - snapshot identifier (when retrieving)\n\nOutput:\n- error - returns nil on success, or an error describing what went wrong during execution",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tppb \"google.golang.org/grpc/profiling/proto\"\n)\nfunc remoteCommand() error {\n\tctx := context.Background()\n\tif *flagTimeout > 0 {\n\t\tvar cancel func()\n\t\tctx, cancel = context.WithTimeout(context.Background(), time.Duration(*flagTimeout)*time.Second)\n\t\tdefer cancel()\n\t}\n\n\tlogger.Infof(\"dialing %s\", *flagAddress)\n\tcc, err := grpc.Dial(*flagAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Errorf(\"cannot dial %s: %v\", *flagAddress, err)\n\t\treturn err\n\t}\n\tdefer cc.Close()\n\n\tc := ppb.NewProfilingClient(cc)\n\n\tif *flagEnableProfiling || *flagDisableProfiling {\n\t\treturn setEnabled(ctx, c, *flagEnableProfiling)\n\t}\n\tif *flagRetrieveSnapshot {\n\t\treturn retrieveSnapshot(ctx, c, *flagSnapshot)\n\t}\n\treturn fmt.Errorf(\"what should I do with the remote target?\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nvar (\n\tflagAddress          = flag.String(\"address\", \"\", \"gRPC server address\")\n\tflagTimeout          = flag.Int(\"timeout\", 0, \"Connection timeout in seconds\")\n\tflagEnableProfiling  = flag.Bool(\"enableProfiling\", false, \"Enable profiling\")\n\tflagDisableProfiling = flag.Bool(\"disableProfiling\", false, \"Disable profiling\")\n\tflagRetrieveSnapshot = flag.Bool(\"retrieveSnapshot\", false, \"Retrieve snapshot\")\n\tflagSnapshot         = flag.String(\"snapshot\", \"\", \"Snapshot identifier\")\n)\n\ntype ProfilingClient interface {\n\tEnableProfiling(ctx context.Context) error\n\tDisableProfiling(ctx context.Context) error\n\tRetrieveSnapshot(ctx context.Context, snapshotID string) error\n}\n\nfunc remoteCommand() error {\n\tif *flagAddress == \"\" {\n\t\treturn errors.New(\"address flag is required\")\n\t}\n\n\tvar ctx context.Context\n\tif *flagTimeout > 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(context.Background(), time.Duration(*flagTimeout)*time.Second)\n\t\tdefer cancel()\n\t} else {\n\t\tctx = context.Background()\n\t}\n\n\tconn, err := grpc.DialContext(ctx, *flagAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := NewProfilingClient(conn)\n\n\tif *flagEnableProfiling {\n\t\tif err := client.EnableProfiling(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif *flagDisableProfiling {\n\t\tif err := client.DisableProfiling(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif *flagRetrieveSnapshot {\n\t\tif *flagSnapshot == \"\" {\n\t\t\treturn errors.New(\"snapshot flag is required when retrieving a snapshot\")\n\t\t}\n\t\tif err := client.RetrieveSnapshot(ctx, *flagSnapshot); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc NewProfilingClient(conn *grpc.ClientConn) ProfilingClient {\n\t// Implementation of ProfilingClient creation goes here\n\treturn nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tif err := remoteCommand(); err != nil {\n\t\t// Handle error\n\t}\n}\n```"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a PubSub service, publishes messages, and handles connection cleanup.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 1234, creates a PubSub service client, publishes two predefined messages, and ensures proper connection closure. It demonstrates basic gRPC client operations including connection establishment, RPC calls, and resource cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function publishes messages to the server and logs errors if any occur)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"gobook.examples/ch4-04-grpc/grpc-pubsub/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc publishMessages() {\n\t// Establish a connection to the gRPC server\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a PubSub client\n\tclient := pb.NewPubSubServiceClient(conn)\n\n\t// Define messages to be published\n\tmessages := []string{\"Hello, World!\", \"gRPC is awesome!\"}\n\n\t// Publish messages\n\tfor _, msg := range messages {\n\t\t_, err := client.Publish(context.Background(), &pb.PublishRequest{Message: msg})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"Published message: %s\", msg)\n\t\t}\n\t}\n\n\t// Ensure proper cleanup\n\ttime.Sleep(1 * time.Second) // Simulate some processing time\n}"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC server for Google Pub/Sub emulator and initializes a Pub/Sub client using that connection.\n\nFunction Description: The function demonstrates how to set up a connection to a local gRPC server (Pub/Sub emulator) using insecure credentials, then creates a Pub/Sub client with the established connection. The client should be properly closed when no longer needed.\n\nInput: None (uses hardcoded values for demonstration purposes)\n\nOutput: None (function demonstrates setup pattern, actual Pub/Sub client is created but not used)\n\nNote: The function uses context.Background() for simplicity in the example, and hardcodes \"project\" as the Google Cloud project ID for demonstration purposes. In production code, these would typically be parameters.",
    "Canonical_solution": "import (\n\t\"cloud.google.com/go/pubsub\"\n\t\"cloud.google.com/go/pubsub/pstest\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n)\nfunc ExampleNewServer() {\n\tctx := context.Background()\n\tsrv := pstest.NewServer()\n\tconn, err := grpc.Dial(srv.Addr, grpc.WithInsecure())\n\tif err != nil {\n\t}\n\tclient, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t}\n\tdefer client.Close()\n\t_ = client\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n    \"context\"\n    \"log\"\n\n    \"google.golang.org/api/option\"\n    \"cloud.google.com/go/pubsub\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc setupPubSubClient() {\n    ctx := context.Background()\n    conn, err := grpc.Dial(\"localhost:8085\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf(\"Failed to connect to Pub/Sub emulator: %v\", err)\n    }\n    defer conn.Close()\n\n    client, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n    if err != nil {\n        log.Fatalf(\"Failed to create Pub/Sub client: %v\", err)\n    }\n    defer client.Close()\n\n    // Client is ready to use\n}"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a Dragonfly daemon server over a Unix domain socket to download files from a specified URL to a local output path, with various download configuration options.\n\nFunction Description: The function establishes a gRPC connection to a Dragonfly daemon server running on a Unix domain socket, initiates a file download operation with specified parameters including authentication headers for S3 storage, and streams the download results until completion.\n\nInput:\n- ctx context.Context - Context for controlling the gRPC call lifecycle\n- unixSocketPath string - Path to the Unix domain socket (e.g., \"/run/dfdaemon.sock\")\n- downloadRequest *dfdaemonv1.DownRequest - Download request containing:\n  * Uuid: string - Unique identifier for the download\n  * Url: string - Source URL to download from\n  * Output: string - Local output path\n  * Recursive: bool - Whether to download recursively\n  * UrlMeta: *commonv1.UrlMeta - Metadata including S3 authentication headers\n  * Other download configuration parameters\n\nOutput:\n- map[string]*dfdaemonv1.DownResult - Map of download results keyed by output path\n- error - Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\tdfdaemonv1 \"d7y.io/api/v2/pkg/apis/dfdaemon/v1\"\n)\nfunc main() {\n\tdialer := func(ctx context.Context, addr string) (net.Conn, error) {\n\t\treturn net.Dial(\"unix\", addr)\n\t}\n\n\tunixAddr := \"/run/dfdaemon.sock\"\n\n\tconn, err := grpc.DialContext(\n\t\tcontext.Background(),\n\t\tunixAddr,\n\t\tgrpc.WithContextDialer(dialer),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tvar (\n\t\tclient = dfdaemonv1.NewDaemonClient(conn)\n\t\tctx    = context.Background()\n\t)\n\n\tdownloadClient, err := client.Download(ctx, &dfdaemonv1.DownRequest{\n\t\tUuid:              \"95305fa2-138b-4466-acec-62865ab6403c\",\n\t\tUrl:               \"s3://minio-test-bucket/dragonfly-test/usr/\" + *subDir,\n\t\tOutput:            \"/var/lib/dragonfly-grpc-test/usr/\" + *subDir,\n\t\tRecursive:         true,\n\t\tTimeout:           0,\n\t\tLimit:             0,\n\t\tDisableBackSource: false,\n\t\tUrlMeta: &commonv1.UrlMeta{\n\t\t\tDigest: \"\",\n\t\t\tTag:    \"\",\n\t\t\tRange:  \"\",\n\t\t\tFilter: \"Expires&Signature\",\n\t\t\tHeader: map[string]string{\n\t\t\t\t\"awsEndpoint\":         \"http://minio.dragonfly-e2e.svc:9000\",\n\t\t\t\t\"awsRegion\":           \"us-west-1\",\n\t\t\t\t\"awsAccessKeyID\":      \"root\",\n\t\t\t\t\"awsSecretAccessKey\":  \"password\",\n\t\t\t\t\"awsS3ForcePathStyle\": \"true\",\n\t\t\t},\n\t\t},\n\t\tUid:                1000,\n\t\tGid:                1000,\n\t\tKeepOriginalOffset: false,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresults := map[string]*dfdaemonv1.DownResult{}\n\tfor {\n\t\tresp, err := downloadClient.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tresults[resp.Output] = resp\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\tdfdaemonv1 \"github.com/dragonflyoss/Dragonfly/apis/dfdaemon/v1\"\n\tcommonv1 \"github.com/dragonflyoss/Dragonfly/apis/common/v1\"\n)\n\nfunc downloadFiles(ctx context.Context, unixSocketPath string, downloadRequest *dfdaemonv1.DownRequest) (map[string]*dfdaemonv1.DownResult, error) {\n\tconn, err := grpc.DialContext(ctx, \"unix:\"+unixSocketPath, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock(), grpc.WithTimeout(5*time.Second))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to Dragonfly daemon: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := dfdaemonv1.NewDfdaemonClient(conn)\n\tstream, err := client.Download(ctx, downloadRequest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initiate download: %w\", err)\n\t}\n\n\tresults := make(map[string]*dfdaemonv1.DownResult)\n\tfor {\n\t\tresult, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"error receiving download result: %w\", err)\n\t\t}\n\t\tresults[result.Output] = result\n\t}\n\n\treturn results, nil\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a function that connects to a gRPC server, retrieves pod information using the HyperD Public API, and returns the response.\n\nFunction Description: The function establishes an insecure connection to a gRPC server at the specified address, creates a Public API client, sends a PodInfoRequest for a specific pod ID, and returns the pod information response. The connection is automatically closed when the function completes.\n\nInput: \n- server string: The address of the gRPC server (e.g., \"localhost:50051\")\n- podID string: The ID of the pod to query (e.g., \"pod-zpIOTSAjmM\")\n\nOutput:\n- *types.PodInfoResponse: The response containing pod information\n- error: Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/hyperhq/hyperd/types\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(server, grpc.WithInsecure())\n\tif err != nil {\n\t\tfmt.Printf(\"Connect server error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tclient := types.NewPublicAPIClient(conn)\n\trequest := types.PodInfoRequest{\n\t\tPodID: \"pod-zpIOTSAjmM\",\n\t}\n\tresponse, err := client.PodInfo(context.Background(), &request)\n\tif err != nil {\n\t\tfmt.Printf(\"Get PodInfo error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Got response: %v\", response)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n    \"context\"\n    \"google.golang.org/grpc\"\n    \"github.com/hyperhq/hyperd/api\"\n    \"github.com/hyperhq/hyperd/types\"\n)\n\nfunc GetPodInfo(server string, podID string) (*types.PodInfoResponse, error) {\n    conn, err := grpc.Dial(server, grpc.WithInsecure())\n    if err != nil {\n        return nil, err\n    }\n    defer conn.Close()\n\n    client := api.NewPublicAPIClient(conn)\n    request := &types.PodInfoRequest{PodID: podID}\n\n    response, err := client.PodInfo(context.Background(), request)\n    if err != nil {\n        return nil, err\n    }\n\n    return response, nil\n}"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Implement a gRPC client function in Go that reports device status to a gRPC server using a Unix domain socket connection.\n\nFunction Description: The function `ReportDeviceStatus` establishes a connection to a gRPC server through a Unix domain socket, sends a device status report request, and handles the response. It manages connection lifecycle including setup, error handling, and cleanup.\n\nInput: \n- request *dmiapi.ReportDeviceStatusRequest: A pointer to the gRPC request message containing device status information to be reported.\n\nOutput:\n- error: Returns an error if any step fails (connection establishment, RPC call, etc.), or nil if successful.\n\nNote: The function uses configuration from `config.Cfg()` to determine the Unix socket path and includes proper connection timeout handling.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdmiapi \"github.com/kubeedge/api/apis/dmi/v1beta1\"\n\t\"github.com/kubeedge/mapper-framework/pkg/config\"\n)\nfunc ReportDeviceStatus(request *dmiapi.ReportDeviceStatusRequest) error {\n\tcfg := config.Cfg()\n\n\tconn, err := grpc.Dial(cfg.Common.EdgeCoreSock,\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithContextDialer(\n\t\t\tfunc(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\tunixAddress, err := net.ResolveUnixAddr(\"unix\", cfg.Common.EdgeCoreSock)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn net.DialUnix(\"unix\", nil, unixAddress)\n\t\t\t},\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := dmiapi.NewDeviceManagerServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\t_, err = c.ReportDeviceStatus(ctx, request)\n\treturn err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"dmiapi\"\n\t\"config\"\n)\n\nfunc ReportDeviceStatus(request *dmiapi.ReportDeviceStatusRequest) error {\n\tsocketPath := config.Cfg().UnixSocketPath\n\tif socketPath == \"\" {\n\t\treturn fmt.Errorf(\"Unix socket path is not configured\")\n\t}\n\n\tconn, err := grpc.Dial(\n\t\tsocketPath,\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, 5*time.Second)\n\t\t}),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to dial gRPC server: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := dmiapi.NewDeviceManagementClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tresponse, err := client.ReportDeviceStatus(ctx, request)\n\tif err != nil {\n\t\tst, ok := status.FromError(err)\n\t\tif ok {\n\t\t\treturn fmt.Errorf(\"gRPC error: %s\", st.Message())\n\t\t}\n\t\treturn fmt.Errorf(\"failed to report device status: %w\", err)\n\t}\n\n\tif response.GetSuccess() {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"device status report failed: %s\", response.GetErrorMessage())\n}"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC metrics server, creates a client for the MetricsService, and prints the metrics retrieved from the server.\n\nFunction Description: The function connects to a gRPC server specified by the metricsServerAddress, initializes a MetricsService client, and prints the metrics. If the connection fails, it logs a fatal error. The connection is automatically closed when the function completes.\n\nInput: \n- metricsServerAddress: string - The address of the gRPC metrics server to connect to.\n- totalOnly: bool - A flag indicating whether to print only the total metrics or all metrics.\n\nOutput: None (prints metrics to the console or logs errors).",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/grpclog\"\n\tmetricspb \"google.golang.org/grpc/stress/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *metricsServerAddress == \"\" {\n\t\tgrpclog.Fatalf(\"Metrics server address is empty.\")\n\t}\n\n\tconn, err := grpc.Dial(*metricsServerAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"cannot connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := metricspb.NewMetricsServiceClient(conn)\n\tprintMetrics(c, *totalOnly)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/metrics/proto\"\n)\n\nfunc printMetrics(metricsServerAddress string, totalOnly bool) {\n\tconn, err := grpc.Dial(metricsServerAddress, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(5*time.Second))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewMetricsServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\treq := &pb.GetMetricsRequest{TotalOnly: totalOnly}\n\tresp, err := client.GetMetrics(ctx, req)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve metrics: %v\", err)\n\t}\n\n\tif totalOnly {\n\t\tlog.Printf(\"Total Metrics: %v\", resp.TotalMetrics)\n\t} else {\n\t\tlog.Printf(\"All Metrics: %v\", resp.AllMetrics)\n\t}\n}\n\nfunc main() {\n\tmetricsServerAddress := \"localhost:50051\"\n\ttotalOnly := false\n\tprintMetrics(metricsServerAddress, totalOnly)\n}\n```"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and processes the response.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client instance for the Greeter service, sends a HelloRequest with a name parameter, and logs the server's response or any errors encountered during the process.\n\nInput: \n- address: string - The server address in format \"host:port\" (default: \"localhost:50051\")\n- name: string - The name to send in the greeting request (default: \"world\")\n\nOutput:\n- None (directly logs results to console)\n- Side effect: Sends gRPC request and receives response",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"go.opencensus.io/examples/grpc/proto\"\n\t\"go.opencensus.io/plugin/ocgrpc\"\n)\n\nconst (\n\taddress     = \"localhost:50051\"\n\tdefaultName = \"world\"\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithStatsHandler(&ocgrpc.ClientHandler{}), grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Cannot connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Printf(\"Could not greet: %v\", err)\n\t} else {\n\t\tlog.Printf(\"Greeting: %s\", r.Message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc greet(address string, name string) {\n\tif address == \"\" {\n\t\taddress = \"localhost:50051\"\n\t}\n\tif name == \"\" {\n\t\tname = \"world\"\n\t}\n\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\treq := &pb.HelloRequest{Name: name}\n\tres, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\n\tlog.Printf(\"Greeting: %s\", res.GetMessage())\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Create a gRPC client in Go that connects to a RouteGuide service, performs various operations (getting features, listing features within a rectangle, recording a route, and conducting route chat), and handles secure/insecure connections.\n\nFunction Description: The main function establishes a connection to a gRPC server, creates a RouteGuide client, and demonstrates various service operations. It handles both secure (TLS) and insecure connections based on input flags.\n\nInput:\n- Command line flags (implicit):\n  - tls (bool): Whether to use TLS encryption\n  - serverHostOverride (string): Server name for certificate validation\n  - caFile (string): Path to CA certificate file\n  - serverAddr (string): Server address in format host:port\n\nOutput:\n- None (direct output to console/logger)\n- Side effects: Makes gRPC calls to server and prints results\n\nMethods called (from RouteGuideClient):\n1. printFeature(client, point) - Gets and prints a feature at given point\n2. printFeatures(client, rectangle) - Lists features within given rectangle\n3. runRecordRoute(client) - Records a route and prints statistics\n4. runRouteChat(client) - Conducts bidirectional route chat",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &pb.Point{409146138, -746188906})\n\tprintFeature(client, &pb.Point{0, 0})\n\tprintFeatures(client, &pb.Rectangle{&pb.Point{400000000, -750000000}, &pb.Point{420000000, -730000000}})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/routeguide\"\n)\n\nvar (\n\ttls                = flag.Bool(\"tls\", false, \"Connection uses TLS if true, else plain TCP\")\n\tcaFile             = flag.String(\"ca_file\", \"\", \"CA root cert file\")\n\tserverHostOverride = flag.String(\"server_host_override\", \"\", \"Server name for certificate validation\")\n\tserverAddr         = flag.String(\"server_addr\", \"localhost:50051\", \"The server address in the format of host:port\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tif *caFile == \"\" {\n\t\t\tlog.Fatal(\"ca_file must be provided when tls is enabled\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &pb.Point{Latitude: 409146138, Longitude: -746188906})\n\tprintFeatures(client, &pb.Rectangle{\n\t\tLo: &pb.Point{Latitude: 400000000, Longitude: -750000000},\n\t\tHi: &pb.Point{Latitude: 420000000, Longitude: -730000000},\n\t})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}\n\nfunc printFeature(client pb.RouteGuideClient, point *pb.Point) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tfeature, err := client.GetFeature(ctx, point)\n\tif err != nil {\n\t\tlog.Fatalf(\"GetFeature failed: %v\", err)\n\t}\n\tlog.Printf(\"Feature: %v\", feature)\n}\n\nfunc printFeatures(client pb.RouteGuideClient, rect *pb.Rectangle) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tstream, err := client.ListFeatures(ctx, rect)\n\tif err != nil {\n\t\tlog.Fatalf(\"ListFeatures failed: %v\", err)\n\t}\n\tfor {\n\t\tfeature, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Feature: %v\", feature)\n\t}\n}\n\nfunc runRecordRoute(client pb.RouteGuideClient) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tstream, err := client.RecordRoute(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"RecordRoute failed: %v\", err)\n\t}\n\tpoints := []*pb.Point{\n\t\t{Latitude: 409146138, Longitude: -746188906},\n\t\t{Latitude: 411146138, Longitude: -746188906},\n\t\t{Latitude: 413146138, Longitude: -746188906},\n\t}\n\tfor _, point := range points {\n\t\tif err := stream.Send(point); err != nil {\n\t\t\tlog.Fatalf(\"Failed to send point: %v\", err)\n\t\t}\n\t}\n\treply, err := stream.CloseAndRecv()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to receive route summary: %v\", err)\n\t}\n\tlog.Printf(\"Route summary: %v\", reply)\n}\n\nfunc runRouteChat(client pb.RouteGuideClient) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tstream, err := client.RouteChat(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"RouteChat failed: %v\", err)\n\t}\n\tnotes := []*pb.RouteNote{\n\t\t{Location: &pb.Point{Latitude: 409146138, Longitude: -746188906}, Message: \"First message\"},\n\t\t{Location: &pb.Point{Latitude: 411146138, Longitude: -746188906}, Message: \"Second message\"},\n\t}\n\twaitc := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tin, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tclose(waitc)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Got message: %s at point(%d, %d)\", in.Message, in.Location.Latitude, in.Location.Longitude)\n\t\t}\n\t}()\n\tfor _, note := range notes {\n\t\tif err := stream.Send(note); err != nil {\n\t\t\tlog.Fatalf(\"Failed to send note: %v\", err)\n\t\t}\n\t}\n\tstream.CloseSend()\n\t<-waitc\n}\n```"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC connection to a server, invokes an empty call RPC method, and returns the response.\n\nFunction Description: The function `invokeEmptyCall` connects to a gRPC server at the specified address, creates a client for the EmptyService, makes an empty call RPC, and returns the response. It handles connection establishment and cleanup, including context timeout and connection closure.\n\nInput: \n- address: string - The address of the gRPC server to connect to\n- dialOptions: variadic grpc.DialOption - Optional gRPC dial options for connection configuration\n\nOutput:\n- *testpb.Empty - The response from the EmptyCall RPC\n- error - Any error that occurred during the connection or RPC call",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"testpb\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions ...grpc.DialOption) (*testpb.Empty, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), testTimeout)\n\tdefer cancel()\n\tclientConn, err := grpc.DialContext(ctx, address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer clientConn.Close()\n\n\tclient := testpb.NewEmptyServiceClient(clientConn)\n\tempty, err := client.EmptyCall(context.Background(), new(testpb.Empty))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn empty, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/status\"\n\n\ttestpb \"path/to/your/protobuf/package\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions ...grpc.DialOption) (*testpb.Empty, error) {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, status.Errorf(status.Code(err), \"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client for the EmptyService.\n\tclient := testpb.NewEmptyServiceClient(conn)\n\n\t// Set a timeout for the context.\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t// Make the EmptyCall RPC.\n\tresponse, err := client.EmptyCall(ctx, &testpb.Empty{})\n\tif err != nil {\n\t\treturn nil, status.Errorf(status.Code(err), \"failed to call EmptyCall: %v\", err)\n\t}\n\n\treturn response, nil\n}\n```"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and receives a response.\n\nFunction Description: The function establishes a connection to a gRPC server using the provided address, creates a client for the HelloService, sends a HelloRequest with the specified name, and returns the server's response. It handles connection errors and timeout contexts.\n\nInput:\n- addr: string - The address of the gRPC server to connect to (e.g., \"127.0.0.1:8972\")\n- name: string - The name to include in the greeting request\n\nOutput:\n- string - The greeting response from the server\n- error - Any error that occurred during the process\n\nNote: The function should properly close the connection when done and handle context timeouts.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"hello_grpc_client/proto\"\n\t\"log\"\n\t\"time\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:8972\", \"the address to connect to\")\n\tname = flag.String(\"name\", defaultName, \"Name to greet\")\n)\n\nfunc main() {\n\tflag.Parse()\n\tconn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := proto.NewHelloServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.SayHello(ctx, &proto.HelloRequest{\n\t\tName: *name,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\n\tlog.Printf(\"Greeting: %s\", r.GetReply())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"time\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc sendGreeting(addr string, name string) (string, error) {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer conn.Close()\n\n\t// Create a new client for the HelloService.\n\tclient := pb.NewHelloServiceClient(conn)\n\n\t// Set a timeout context for the request.\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t// Create a HelloRequest with the specified name.\n\treq := &pb.HelloRequest{Name: name}\n\n\t// Send the request and receive the response.\n\tresp, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Return the greeting response from the server.\n\treturn resp.Message, nil\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and properly handle the connection lifecycle.\n\nFunction Description: The function tests gRPC client functionality by connecting to a user authentication service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper gRPC connection management and metadata handling.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None directly returned, but prints authentication tokens to stdout\n- Returns error if connection or RPC calls fail\n\nNote: The function includes error handling and connection cleanup via defer. It uses metadata to pass a UUID for request tracking and demonstrates multiple RPC calls in a loop.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/src\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc TestGRPCClient(serviceAddress, account, password string, testCount int) error {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewAuthServiceClient(conn)\n\n\tfor i := 0; i < testCount; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tmd := metadata.Pairs(\"uuid\", uuid.New().String())\n\t\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t\treq := &pb.LoginRequest{\n\t\t\tUsername: account,\n\t\t\tPassword: password,\n\t\t}\n\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Login failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Received token: %s\\n\", resp.Token)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, publishes messages, and handles connection cleanup.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client for the PubsubService, publishes two predefined messages, and ensures proper connection closure. The function handles potential connection errors and publishing failures.\n\nInput: None (The target server address is hardcoded as \"localhost:1234\" and messages are predefined)\n\nOutput: None (The function performs side effects by publishing messages to the gRPC server and may terminate the program on errors)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"ch4.4-3/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc publishMessages() {\n\tconst address = \"localhost:1234\"\n\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tmessages := []string{\"Hello, World!\", \"Another message\"}\n\n\tfor _, msg := range messages {\n\t\t_, err := client.Publish(ctx, &pb.PublishRequest{Message: msg})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to publish message: %v\", err)\n\t\t}\n\t}\n\n\tlog.Println(\"Messages published successfully\")\n}\n\nfunc main() {\n\tpublishMessages()\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and handle the responses.\n\nFunction Description: The function tests a gRPC client implementation by connecting to a user service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper connection handling, metadata usage, and error handling in gRPC communications.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None (prints tokens to stdout)\n- Returns error if connection or RPC fails\n\nNote: The function includes proper connection cleanup using defer and demonstrates metadata handling for request tracing.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/utils\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/user_agent/pb\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\tpb \"path/to/your/protobuf/package\" // Replace with the actual path to your protobuf package\n)\n\nfunc testGRPCClient(serviceAddress, account, password string, testCount int) error {\n\t// Establish a connection to the gRPC server\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserServiceClient(conn)\n\n\tfor i := 0; i < testCount; i++ {\n\t\t// Generate a new UUID for each request\n\t\trequestID := uuid.New().String()\n\n\t\t// Create metadata with the UUID\n\t\tmd := metadata.Pairs(\"request-id\", requestID)\n\t\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\n\t\t// Create the login request\n\t\treq := &pb.LoginRequest{\n\t\t\tUsername: account,\n\t\t\tPassword: password,\n\t\t}\n\n\t\t// Make the RPC call\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"failed to login: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Print the received authentication token\n\t\tfmt.Printf(\"Received token for request %s: %s\\n\", requestID, resp.Token)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tserviceAddress := \"localhost:50051\" // Example address\n\taccount := \"testuser\"\n\tpassword := \"testpassword\"\n\ttestCount := 5\n\n\tif err := testGRPCClient(serviceAddress, account, password, testCount); err != nil {\n\t\tlog.Fatalf(\"Error testing gRPC client: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a function that tests a gRPC client connection to a user authentication service, sends multiple login requests, and prints the received authentication tokens.\n\nFunction Description: The function establishes an insecure gRPC connection to a specified server address, creates a user client, and sends 20 consecutive login requests with metadata containing a UUID. Each successful response's token is printed, while errors cause immediate termination.\n\nInput: None (The service address is hardcoded as \"127.0.0.1:8881\" and login credentials are fixed as account \"hwholiday\" and password \"123456\")\n\nOutput: None (The function prints tokens to stdout and may return early on error through testing.T's Error method)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\n\tpb \"path/to/your/protobuf/package\" // Replace with the actual path to your protobuf package\n)\n\nfunc testGRPCClientConnection() {\n\tconst (\n\t\taddress  = \"127.0.0.1:8881\"\n\t\taccount  = \"hwholiday\"\n\t\tpassword = \"123456\"\n\t)\n\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserClient(conn)\n\n\tfor i := 0; i < 20; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tmd := metadata.Pairs(\"uuid\", uuid.New().String())\n\t\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t\treq := &pb.LoginRequest{\n\t\t\tAccount:  account,\n\t\t\tPassword: password,\n\t\t}\n\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"could not login: %v\", err)\n\t\t}\n\n\t\tfmt.Println(\"Received token:\", resp.Token)\n\t}\n}\n\nfunc main() {\n\ttestGRPCClientConnection()\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Implement a Go struct that interacts with the Pinecone vector database to upsert embeddings and retrieve similar vectors using HTTP requests with custom headers.\n\nStruct Description: The Pinecone struct represents a client for interacting with the Pinecone vector database API. It handles authentication, request construction, and response processing for vector operations.\n\nFields:\nEndpoint: string - The base URL of the Pinecone API endpoint\nApiKey: string - The API key used for authentication with Pinecone\n\nMethods:\nNew: [endpoint string, apiKey string] -> [*Pinecone, error] - Creates a new Pinecone client instance with the given endpoint and API key\n\nUpsertEmbeddings: [embeddings [][]float32, chunks []chunk.Chunk, uuid string] -> [error] - Upserts multiple embeddings into Pinecone in batches, with associated metadata from chunks, under the specified namespace UUID\n\nRetrieve: [questionEmbedding []float32, topK int, uuid string] -> [[]vectordb.QueryMatch, error] - Retrieves the topK most similar vectors to the questionEmbedding from the specified namespace UUID",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/pashpashpash/vault/chunk\"\n\t\"github.com/pashpashpash/vault/vectordb\"\n)\n\ntype Pinecone struct {\n\tEndpoint string\n\tApiKey   string\n}\n\nfunc New(endpoint string, apiKey string) (*Pinecone, error) {\n\treturn &Pinecone{\n\t\tEndpoint: endpoint,\n\t\tApiKey:   apiKey,\n\t}, nil\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []chunk.Chunk, uuid string) error {\n\turl := p.Endpoint + \"/vectors/upsert\"\n\n\tvectors := make([]PineconeVector, len(embeddings))\n\tfor i, embedding := range embeddings {\n\t\tchunk := chunks[i]\n\t\tvectors[i] = PineconeVector{\n\t\t\tID:     fmt.Sprintf(\"id-%d\", i),\n\t\t\tValues: embedding,\n\t\t\tMetadata: map[string]string{\n\t\t\t\t\"file_name\": chunk.Title,\n\t\t\t\t\"start\":     strconv.Itoa(chunk.Start),\n\t\t\t\t\"end\":       strconv.Itoa(chunk.End),\n\t\t\t\t\"title\":     chunk.Title,\n\t\t\t\t\"text\":      chunk.Text,\n\t\t\t},\n\t\t}\n\t}\n\n\tmaxVectorsPerRequest := 100\n\n\tfor i := 0; i < len(vectors); i += maxVectorsPerRequest {\n\t\tend := i + maxVectorsPerRequest\n\t\tif end > len(vectors) {\n\t\t\tend = len(vectors)\n\t\t}\n\n\t\trequestBody, err := json.Marshal(struct {\n\t\t\tVectors   []PineconeVector `json:\"vectors\"`\n\t\t\tNamespace string           `json:\"namespace\"`\n\t\t}{\n\t\t\tVectors:   vectors[i:end],\n\t\t\tNamespace: uuid,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(requestBody))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn errors.New(string(body))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([]vectordb.QueryMatch, error) {\n\trequestBody, _ := json.Marshal(PineconeQueryRequest{\n\t\tTopK:            topK,\n\t\tIncludeMetadata: true,\n\t\tNamespace:       uuid,\n\t\tQueries: []PineconeQueryItem{\n\t\t\t{\n\t\t\t\tValues: questionEmbedding,\n\t\t\t},\n\t\t},\n\t})\n\n\tpineconeIndexURL := p.Endpoint + \"/query\"\n\treq, _ := http.NewRequest(\"POST\", pineconeIndexURL, bytes.NewBuffer(requestBody))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tvar pineconeQueryResponse PineconeQueryResponse\n\tjson.Unmarshal(body, &pineconeQueryResponse)\n\n\tif len(pineconeQueryResponse.Results) > 0 {\n\t\treturn pineconeQueryResponse.Results[0].Matches, nil\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "package pinecone\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/yourusername/chunk\"\n\t\"github.com/yourusername/vectordb\"\n)\n\ntype Pinecone struct {\n\tEndpoint string\n\tApiKey   string\n}\n\nfunc New(endpoint, apiKey string) (*Pinecone, error) {\n\tif endpoint == \"\" || apiKey == \"\" {\n\t\treturn nil, errors.New(\"endpoint and apiKey must be provided\")\n\t}\n\treturn &Pinecone{Endpoint: endpoint, ApiKey: apiKey}, nil\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []chunk.Chunk, uuid string) error {\n\turl := fmt.Sprintf(\"%s/vectors/upsert\", p.Endpoint)\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\n\tfor i, embedding := range embeddings {\n\t\tdata := map[string]interface{}{\n\t\t\t\"namespace\": uuid,\n\t\t\t\"vectors\": []map[string]interface{}{\n\t\t\t\t{\n\t\t\t\t\t\"id\":     chunks[i].ID,\n\t\t\t\t\t\"values\": embedding,\n\t\t\t\t\t\"metadata\": map[string]interface{}{\n\t\t\t\t\t\t\"chunk\": chunks[i],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tbody, err := json.Marshal(data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(body))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", p.ApiKey))\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\trespBody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn fmt.Errorf(\"failed to upsert embeddings: %s\", string(respBody))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([]vectordb.QueryMatch, error) {\n\turl := fmt.Sprintf(\"%s/vectors/query\", p.Endpoint)\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\n\tdata := map[string]interface{}{\n\t\t\"namespace\": uuid,\n\t\t\"query\": map[string]interface{}{\n\t\t\t\"values\": questionEmbedding,\n\t\t},\n\t\t\"topK\": topK,\n\t}\n\n\tbody, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", p.ApiKey))\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\trespBody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"failed to retrieve vectors: %s\", string(respBody))\n\t}\n\n\tvar result struct {\n\t\tMatches []vectordb.QueryMatch `json:\"matches\"`\n\t}\n\n\terr = json.NewDecoder(resp.Body).Decode(&result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result.Matches, nil\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Write a Go function that tests the version retrieval functionality of a gRPC service using the Stripe CLI client. The function should establish a connection to the gRPC server, call the Version method, and verify the response matches the expected version.\n\nFunction Description: The function `TestVersionReturnsCLIVersion` is a test function that verifies the version information returned by a gRPC service. It establishes an authenticated connection to a gRPC server, calls the Version RPC method, and checks that the returned version matches the expected value (\"master\"). The connection is properly closed after the test completes.\n\nInput: \n- `t *testing.T`: The testing context provided by Go's testing framework for reporting test failures and logging.\n- Implicit context from `withAuth(context.Background())`: An authenticated context for the gRPC call.\n\nOutput: \n- The function does not return any value but will fail the test if any of the following occur:\n  - The gRPC connection cannot be established\n  - The Version RPC call fails\n  - The returned version does not match the expected value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Version(ctx, &rpc.VersionRequest{})\n\tif err != nil {\n\t\tt.Fatalf(\"Version failed: %v\", err)\n\t}\n\n\texpected := rpc.VersionResponse{\n\t\tVersion: \"master\",\n\t}\n\n\tassert.Equal(t, expected.Version, resp.Version)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/stretchr/testify/require\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure(), grpc.WithBlock())\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\n\tclient := pb.NewYourServiceClient(conn)\n\tctx := withAuth(context.Background())\n\n\tresp, err := client.Version(ctx, &pb.VersionRequest{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"master\", resp.Version)\n}\n\nfunc withAuth(ctx context.Context) context.Context {\n\t// Implement your authentication logic here\n\treturn ctx\n}"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: The task involves creating a gRPC client in Go that connects to a CloudSlack service, establishes a bidirectional stream, and handles incoming events while managing connection lifecycle and errors.\n\nFunction Description: The `start` function initializes a gRPC connection to a CloudSlack server, establishes a bidirectional stream for communication, sends a connection request, and continuously listens for incoming events. It handles connection errors, server closures, and context cancellations appropriately.\n\nInput: \n- `ctx context.Context`: The context for managing the lifecycle of the gRPC connection and handling cancellations.\n- The function also relies on the struct's fields (`log`, `cfg`, `client`, `commGroupMetadata`, `clusterName`, and `botID`) for configuration and logging.\n\nOutput: \n- `error`: Returns an error if any step in the connection or communication process fails, including gRPC connection errors, credential errors, or stream errors. Returns nil if the context is canceled gracefully.\n\nNote: The function uses deferred calls to ensure proper cleanup of resources (closing the gRPC connection and stream) and includes detailed error handling for various gRPC-specific scenarios.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tpb \"github.com/kubeshop/botkube/pkg/api/cloudslack\"\n\t\"github.com/kubeshop/botkube/pkg/grpcx\"\n\t\"github.com/kubeshop/botkube/pkg/config\"\n\t\"github.com/kubeshop/botkube/pkg/api/cloudplatform\"\n\t\"github.com/kubeshop/botkube/internal/config/remote\"\n)\n\ntype CloudSlack struct {\n\tlog               logrus.FieldLogger\n\tcfg               config.CloudSlack\n\tclient            *slack.Client\n\tcommGroupMetadata CommGroupMetadata\n\tclusterName       string\n}\n\nfunc (b *CloudSlack) start(ctx context.Context) error {\n\tremoteConfig, ok := remote.GetConfig()\n\tif !ok {\n\t\treturn fmt.Errorf(\"while getting remote config for %s\", config.CloudSlackCommPlatformIntegration)\n\t}\n\n\tcreds, err := grpcx.ClientTransportCredentials(b.log, b.cfg.Server)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC credentials: %w\", err)\n\t}\n\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithStreamInterceptor(cloudplatform.AddStreamingClientCredentials(remoteConfig)),\n\t\tgrpc.WithUnaryInterceptor(cloudplatform.AddUnaryClientCredentials(remoteConfig)),\n\t}\n\n\tconn, err := grpc.Dial(b.cfg.Server.URL, opts...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC connection: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\treq := &pb.ConnectRequest{\n\t\tInstanceId: remoteConfig.Identifier,\n\t\tBotId:      b.botID,\n\t}\n\tc, err := pb.NewCloudSlackClient(conn).Connect(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while initializing gRPC cloud client: %w\", err)\n\t}\n\tdefer func(c pb.CloudSlack_ConnectClient) {\n\t\terr := c.CloseSend()\n\t\tif err != nil {\n\t\t\tb.log.Errorf(\"while closing connection: %s\", err.Error())\n\t\t}\n\t}(c)\n\n\terr = c.Send(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while sending gRPC connection request. %w\", err)\n\t}\n\n\tfor {\n\t\tdata, err := c.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tb.log.Warn(\"gRPC connection was closed by server\")\n\t\t\t\treturn errors.New(\"gRPC connection closed\")\n\t\t\t}\n\t\t\terrStatus, ok := status.FromError(err)\n\t\t\tif ok && errStatus.Code() == codes.Canceled && errStatus.Message() == context.Canceled.Error() {\n\t\t\t\tb.log.Debugf(\"Context was cancelled. Skipping returning error...\")\n\t\t\t\treturn fmt.Errorf(\"while resolving error from gRPC response %s\", errStatus.Err())\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"while receiving cloud slack events: %w\", err)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype CloudSlackClient struct {\n\tlog               *log.Logger\n\tcfg               *Config\n\tclient            CloudSlackServiceClient\n\tcommGroupMetadata string\n\tclusterName       string\n\tbotID             string\n}\n\ntype Config struct {\n\tServerAddress string\n}\n\ntype CloudSlackServiceClient interface {\n\tConnect(ctx context.Context, opts ...grpc.CallOption) (CloudSlack_ConnectClient, error)\n}\n\ntype CloudSlack_ConnectClient interface {\n\tSend(*ConnectionRequest) error\n\tRecv() (*Event, error)\n\tgrpc.ClientStream\n}\n\ntype ConnectionRequest struct {\n\tClusterName string\n\tBotID       string\n}\n\ntype Event struct {\n\tMessage string\n}\n\nfunc (c *CloudSlackClient) start(ctx context.Context) error {\n\tconn, err := grpc.Dial(c.cfg.ServerAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tc.log.Printf(\"Failed to dial server: %v\", err)\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := NewCloudSlackServiceClient(conn)\n\tstream, err := client.Connect(ctx)\n\tif err != nil {\n\t\tc.log.Printf(\"Failed to establish stream: %v\", err)\n\t\treturn err\n\t}\n\tdefer stream.CloseSend()\n\n\tmd := metadata.Pairs(\"comm-group\", c.commGroupMetadata)\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\treq := &ConnectionRequest{\n\t\tClusterName: c.clusterName,\n\t\tBotID:       c.botID,\n\t}\n\n\tif err := stream.Send(req); err != nil {\n\t\tc.log.Printf(\"Failed to send connection request: %v\", err)\n\t\treturn err\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tc.log.Println(\"Context canceled, closing connection\")\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tevent, err := stream.Recv()\n\t\t\tif err == io.EOF {\n\t\t\t\tc.log.Println(\"Server closed the stream\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tc.log.Printf(\"Error receiving event: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.handleEvent(event)\n\t\t}\n\t}\n}\n\nfunc (c *CloudSlackClient) handleEvent(event *Event) {\n\tc.log.Printf(\"Received event: %s\", event.Message)\n}\n\nfunc NewCloudSlackServiceClient(conn *grpc.ClientConn) CloudSlackServiceClient {\n\t// Implementation of client creation\n\treturn nil\n}\n\nfunc main() {\n\tlogger := log.New(io.Discard, \"\", log.LstdFlags)\n\tcfg := &Config{ServerAddress: \"localhost:50051\"}\n\tclient := &CloudSlackClient{\n\t\tlog:               logger,\n\t\tcfg:               cfg,\n\t\tcommGroupMetadata: \"example-metadata\",\n\t\tclusterName:       \"example-cluster\",\n\t\tbotID:             \"example-bot\",\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tif err := client.start(ctx); err != nil {\n\t\tfmt.Printf(\"Error starting client: %v\\n\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a PubSub service, subscribes to a specific topic, and continuously receives messages from the subscribed topic until the stream ends or an error occurs.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 1234, creates a PubSub service client, and subscribes to a topic specified by the input string. It then enters a loop to receive messages from the subscribed topic, printing each message until the stream is closed or an error occurs. The connection is automatically closed when the function completes.\n\nInput: \n- topic string: The topic to subscribe to (e.g., \"golang:\")\n\nOutput: \n- None (messages are printed to stdout)\n- Errors: Any connection or stream errors will cause the function to terminate and log the error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"gobook.examples/ch4-04-grpc/grpc-pubsub/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\tstream, err := client.Subscribe(context.Background(), &pb.String{Value: \"golang:\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\treply, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(reply.GetValue())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc subscribeToTopic(topic string) {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubSubServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tstream, err := client.Subscribe(ctx, &pb.SubscribeRequest{Topic: topic})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to subscribe: %v\", err)\n\t}\n\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error receiving message: %v\", err)\n\t\t}\n\t\tfmt.Println(\"Received message:\", msg.GetContent())\n\t}\n}\n\nfunc main() {\n\tsubscribeToTopic(\"golang:\")\n}\n```"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC server for Google Pub/Sub emulator testing, creates a Pub/Sub client, and properly handles resource cleanup.\n\nFunction Description: The function demonstrates how to set up a testing environment for Google Pub/Sub using the pstest server (in-memory emulator). It creates a gRPC connection to the emulator server, initializes a Pub/Sub client with this connection, and ensures all resources are properly closed when done. This is typically used for local testing and development.\n\nInput: None (The function takes no parameters as it's a self-contained example)\n\nOutput: None (The function doesn't return anything as it's a demonstration, though it creates and manages a Pub/Sub client instance)",
    "Canonical_solution": "import (\n\t\"context\"\n\n\t\"cloud.google.com/go/pubsub\"\n\t\"cloud.google.com/go/pubsub/pstest\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n)\nfunc ExampleNewServer() {\n\tctx := context.Background()\n\tsrv := pstest.NewServer()\n\tdefer srv.Close()\n\tconn, err := grpc.Dial(srv.Addr, grpc.WithInsecure())\n\tif err != nil {\n\t}\n\tdefer conn.Close()\n\tclient, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t}\n\tdefer client.Close()\n\t_ = client\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"cloud.google.com/go/pubsub\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\t\"google.golang.org/grpc/test/bufconn/pstest\"\n)\n\nfunc setupPubSubTestEnvironment() {\n\t// Create an in-memory gRPC server using pstest\n\tlis := bufconn.Listen(1024 * 1024)\n\tsrv := pstest.NewServer()\n\tgo func() {\n\t\tif err := srv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Server exited with error: %v\", err)\n\t\t}\n\t}()\n\tdefer srv.Close()\n\n\t// Create a gRPC client connection to the in-memory server\n\tctx := context.Background()\n\tconn, err := grpc.DialContext(ctx, \"bufnet\",\n\t\tgrpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {\n\t\t\treturn lis.Dial()\n\t\t}),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a Pub/Sub client using the gRPC connection\n\tclient, err := pubsub.NewClient(ctx, \"test-project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create Pub/Sub client: %v\", err)\n\t}\n\tdefer client.Close()\n\n\t// Example usage of the client\n\t// Create a topic\n\ttopic, err := client.CreateTopic(ctx, \"test-topic\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create topic: %v\", err)\n\t}\n\tdefer topic.Stop()\n\n\t// Create a subscription\n\tsub, err := client.CreateSubscription(ctx, \"test-subscription\", pubsub.SubscriptionConfig{\n\t\tTopic: topic,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create subscription: %v\", err)\n\t}\n\tdefer sub.Delete(ctx)\n\n\t// The client, topic, and subscription are now ready for testing\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Implement a gRPC client function in Go that connects to a gRPC server, performs unary and streaming RPCs, and handles communication with the server.\n\nFunction Description: The function `doClientWork` establishes a connection to a gRPC server, performs a unary RPC call (`Hello`), and then sets up bidirectional streaming (`Channel`). It sends messages periodically in one goroutine while receiving messages in the main goroutine.\n\nInput: None (The server address is hardcoded as \"localhost:1234\")\n\nOutput: None (The function prints received messages to stdout and logs errors to stderr)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc doClientWork() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(reply.GetValue())\n\n\tstream, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\tif err := stream.Send(&String{Value: \"hi\"}); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tfor {\n\t\tlog.Println(222)\n\n\t\treply, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(reply.GetValue())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc doClientWork() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewYourServiceClient(conn)\n\n\t// Unary RPC\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tresp, err := client.Hello(ctx, &pb.HelloRequest{Message: \"Hello, Server!\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to call Hello: %v\", err)\n\t}\n\tfmt.Printf(\"Unary Response: %s\\n\", resp.GetReply())\n\n\t// Bidirectional Streaming RPC\n\tstream, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create stream: %v\", err)\n\t}\n\n\t// Goroutine to send messages\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tif err := stream.Send(&pb.ChannelRequest{Message: fmt.Sprintf(\"Message %d\", i)}); err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to send message: %v\", err)\n\t\t\t}\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t\tstream.CloseSend()\n\t}()\n\n\t// Receiving messages\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to receive message: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Stream Response: %s\\n\", resp.GetReply())\n\t}\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a function that demonstrates how to establish a gRPC client connection, make a login request to a user service, and handle the response.\n\nFunction Description: The function connects to a gRPC server at a specified address, creates a client for the User service, sends a login request with account credentials, and returns the authentication token. It includes error handling and connection cleanup.\n\nInput: \n- serviceAddress (string): The address of the gRPC server in \"host:port\" format\n- account (string): The user's account name for login\n- password (string): The user's password for login\n\nOutput:\n- token (string): The authentication token returned by the server upon successful login\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function assumes the existence of generated gRPC client code from a protobuf definition that includes a User service with RpcUserLogin method.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v5/v5_user/pb\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(v5_service.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/generated/protobuf/package\"\n)\n\nfunc login(serviceAddress, account, password string) (string, error) {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\treq := &pb.LoginRequest{\n\t\tAccount:  account,\n\t\tPassword: password,\n\t}\n\n\tresp, err := client.RpcUserLogin(ctx, req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"login failed: %v\", err)\n\t}\n\n\treturn resp.Token, nil\n}\n```"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a function to test gRPC client functionality for user login using Go's gRPC package. The function should establish a connection to a gRPC server, send multiple login requests with metadata, and handle responses.\n\nFunction Description: The function tests the gRPC client's ability to communicate with a user service. It establishes an insecure connection to the specified server address, creates a client instance, and sends 20 consecutive login requests with generated UUID metadata. Each request uses the same account credentials and prints the received authentication token.\n\nInput: None (The function is a test function with hardcoded values)\n\nOutput: None (The function prints tokens to stdout and may return errors through the testing framework)\n\nNote: The function uses package-level variables and imports from external packages as shown in the reference code. The connection is automatically closed when the function completes.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/utils\"\n\tuuid \"github.com/satori/go.uuid\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\n\tpb \"path/to/your/protobuf/package\"\n)\n\nconst (\n\tserverAddress = \"localhost:50051\"\n\tusername      = \"testuser\"\n\tpassword      = \"testpassword\"\n)\n\nfunc testLogin() {\n\tconn, err := grpc.Dial(serverAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserServiceClient(conn)\n\n\tfor i := 0; i < 20; i++ {\n\t\tctx := context.Background()\n\t\tmd := metadata.Pairs(\"request-id\", uuid.New().String())\n\t\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t\treq := &pb.LoginRequest{\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t}\n\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Login failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Received token: %s\\n\", resp.Token)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a login request, and retrieves an authentication token.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a gRPC client for the User service, sends a login request with account credentials, and returns the authentication token received from the server. The function includes error handling and connection cleanup.\n\nInput:\n- serviceAddress (string): The address of the gRPC server in format \"host:port\"\n- account (string): The user account name for login\n- password (string): The user password for login\n\nOutput:\n- token (string): The authentication token returned by the server\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function generates a unique request UUID for tracking purposes and uses insecure connection (for testing purposes only). In production, you should use proper TLS credentials.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc login(serviceAddress, account, password string) (string, error) {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\trequestID := uuid.New().String()\n\tmd := metadata.Pairs(\"request-id\", requestID)\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\treq := &pb.LoginRequest{\n\t\tAccount:  account,\n\t\tPassword: password,\n\t}\n\n\tresp, err := client.Login(ctx, req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to login: %v\", err)\n\t}\n\n\treturn resp.Token, nil\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a HelloService server, sends a greeting, and handles the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:1234, creates a client for the HelloService, sends a \"hello\" message, and processes the server's reply. It handles connection errors and RPC call errors appropriately.\n\nInput: None (The server address and message are hardcoded in this example)\n\nOutput: None (The function logs errors and doesn't return any value, though in a real implementation you might want to return the reply or error)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\ths \"ch4.4-1/helloservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := hs.NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &hs.String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc sendGreeting() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewHelloServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\treq := &pb.HelloRequest{Message: \"hello\"}\n\tres, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send greeting: %v\", err)\n\t}\n\n\tlog.Printf(\"Greeting response: %s\", res.Reply)\n}\n\nfunc main() {\n\tsendGreeting()\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Implement an HTTP probe function that checks the availability and correctness of a remote HTTP service by making a GET request with custom headers and verifying the response.\n\nFunction Description: The function performs an HTTP probe to a specified URL with custom configuration including timeout, headers, and TLS settings. It verifies the response status code and optionally checks for a success flag in the response body. The function logs the probe results and returns a success/failure status.\n\nInput:\n- protocol: string - The protocol to use (http/https)\n- address: string - The target server address\n- path: string - The request path\n- port: int - The target port number\n- headerList: []*types.HTTPHeader - List of custom HTTP headers to include\n- timeout: time.Duration - Request timeout duration\n- responseSuccessFlag: string - Optional string to check in response body for success\n- log: *zap.SugaredLogger - Logger for recording probe results\n\nOutput:\n- string - Probe result status (Success/Failure)\n- error - Error details if probe fails",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/koderover/zadig/v2/pkg/types\"\n\t\"go.uber.org/zap\"\n)\nfunc doHTTPProbe(protocol, address, path string, port int, headerList []*types.HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\ttlsConfig := &tls.Config{InsecureSkipVerify: true}\n\ttransport := &http.Transport{\n\t\tTLSClientConfig:   tlsConfig,\n\t\tDisableKeepAlives: true,\n\t\tProxy:             http.ProxyURL(nil),\n\t}\n\tclient := &http.Client{\n\t\tTimeout:       timeout,\n\t\tTransport:     transport,\n\t\tCheckRedirect: redirectChecker(false),\n\t}\n\turl, err := formatURL(protocol, address, path, port)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\theaders := buildHeader(headerList)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\treq.Header = headers\n\treq.Host = headers.Get(\"Host\")\n\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\n\tif res.StatusCode >= http.StatusOK && res.StatusCode < http.StatusBadRequest {\n\t\tif responseSuccessFlag != \"\" && !strings.Contains(string(body), responseSuccessFlag) {\n\t\t\treturn Failure, fmt.Errorf(\"HTTP probe failed with response success flag: %s\", responseSuccessFlag)\n\t\t}\n\t\tlog.Infof(\"Probe succeeded for %s, Response: %v\", url, *res)\n\t\treturn Success, nil\n\t}\n\tlog.Warnf(\"Probe failed for %s, response body: %v\", url, string(body))\n\treturn Failure, fmt.Errorf(\"HTTP probe failed with statuscode: %d\", res.StatusCode)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "right_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\ntype HTTPHeader struct {\n\tKey   string\n\tValue string\n}\n\nfunc HTTPProbe(protocol, address, path string, port int, headerList []*HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\turl := fmt.Sprintf(\"%s://%s:%d%s\", protocol, address, port, path)\n\tclient := &http.Client{\n\t\tTimeout: timeout,\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tlog.Errorw(\"Failed to create request\", \"error\", err)\n\t\treturn \"Failure\", err\n\t}\n\n\tfor _, header := range headerList {\n\t\treq.Header.Set(header.Key, header.Value)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Errorw(\"Request failed\", \"error\", err)\n\t\treturn \"Failure\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Errorw(\"Unexpected status code\", \"statusCode\", resp.StatusCode)\n\t\treturn \"Failure\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tif responseSuccessFlag != \"\" {\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tlog.Errorw(\"Failed to read response body\", \"error\", err)\n\t\t\treturn \"Failure\", err\n\t\t}\n\t\tif !containsSuccessFlag(string(body), responseSuccessFlag) {\n\t\t\tlog.Errorw(\"Success flag not found in response body\")\n\t\t\treturn \"Failure\", fmt.Errorf(\"success flag not found in response body\")\n\t\t}\n\t}\n\n\tlog.Infow(\"Probe successful\", \"url\", url)\n\treturn \"Success\", nil\n}\n\nfunc containsSuccessFlag(body, flag string) bool {\n\treturn len(flag) == 0 || (len(body) > 0 && len(flag) > 0 && contains(body, flag))\n}\n\nfunc contains(s, substr string) bool {\n\treturn len(substr) <= len(s) && (substr == s[:len(substr)] || contains(s[1:], substr))\n}\n\nfunc main() {\n\tlogger, _ := zap.NewProduction()\n\tdefer logger.Sync()\n\tsugar := logger.Sugar()\n\n\theaders := []*HTTPHeader{\n\t\t{Key: \"Custom-Header\", Value: \"HeaderValue\"},\n\t}\n\n\tstatus, err := HTTPProbe(\"https\", \"example.com\", \"/api\", 443, headers, 5*time.Second, \"success\", sugar)\n\tif err != nil {\n\t\tsugar.Errorw(\"Probe failed\", \"status\", status, \"error\", err)\n\t} else {\n\t\tsugar.Infow(\"Probe completed\", \"status\", status)\n\t}\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function that establishes a gRPC connection to a server, creates a client, and makes a request to retrieve fixture data for a specific event.\n\nFunction Description: The function `TestFixturesReturnsData` tests the gRPC client's ability to connect to a server and retrieve fixture data for a specified event. It establishes a connection, creates a client, sends a request, and handles potential errors. The connection is automatically closed when the function completes.\n\nInput: \n- `t *testing.T`: The testing context for reporting failures and logging.\n- Implicit context with authentication (via `withAuth`).\n\nOutput: \n- None explicitly returned, but the function will fail the test if any step (connection, client creation, or request) encounters an error. The response from the gRPC server is captured in `resp` but not returned.",
    "Canonical_solution": "import (\n\t\"context\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\nfunc TestFixturesReturnsData(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Fixture(ctx, &rpc.FixtureRequest{Event: \"customer.created\"})\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"testing\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc withAuth(ctx context.Context) context.Context {\n\t// Implement authentication logic here, e.g., adding metadata\n\treturn ctx\n}\n\nfunc TestFixturesReturnsData(t *testing.T) {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewFixtureServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\tctx = withAuth(ctx)\n\n\treq := &pb.FixtureRequest{EventId: \"12345\"}\n\tresp, err := client.GetFixture(ctx, req)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get fixture: %v\", err)\n\t}\n\n\tlog.Printf(\"Fixture data: %v\", resp)\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a metrics server, retrieves metrics, and prints them. The function should handle connection setup and teardown, and provide options for controlling output format.\n\nFunction Description: The function connects to a gRPC metrics server using the provided address, creates a metrics service client, and prints the retrieved metrics. It supports a flag to determine whether to print all metrics or just the total. The connection is automatically closed when the function completes.\n\nInput:\n- metricsServerAddress (string): The address of the gRPC metrics server to connect to\n- totalOnly (bool): Flag indicating whether to print only the total metrics or all metrics\n\nOutput: None (prints metrics to stdout directly)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/grpclog\"\n\tmetricspb \"google.golang.org/grpc/interop/stress/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *metricsServerAddress == \"\" {\n\t\tlogger.Fatal(\"-metrics_server_address is unset\")\n\t}\n\n\tconn, err := grpc.Dial(*metricsServerAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Fatalf(\"cannot connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := metricspb.NewMetricsServiceClient(conn)\n\tprintMetrics(c, *totalOnly)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/metrics/proto\"\n)\n\nfunc RetrieveMetrics(metricsServerAddress string, totalOnly bool) {\n\tconn, err := grpc.Dial(metricsServerAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewMetricsServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\tresp, err := client.GetMetrics(ctx, &pb.MetricsRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve metrics: %v\", err)\n\t}\n\n\tif totalOnly {\n\t\tfmt.Printf(\"Total Metrics: %v\\n\", resp.Total)\n\t} else {\n\t\tfmt.Printf(\"All Metrics: %v\\n\", resp.Metrics)\n\t}\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a server, sends a greeting request, and processes the response.\n\nFunction Description: The function connects to a gRPC server at a specified address, creates a client instance for the Greeter service, sends a HelloRequest with a name parameter, and returns the server's greeting response. It handles connection errors and request failures appropriately.\n\nInput: \n- address [string]: The network address of the gRPC server (e.g., \"localhost:50051\")\n- name [string]: The name to include in the greeting request (optional, defaults to \"world\")\n\nOutput:\n- [string]: The greeting message received from the server\n- [error]: Any error that occurred during connection or request processing",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"os\"\n\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.Message)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\nfunc sendGreeting(address, name string) (string, error) {\n\tif name == \"\" {\n\t\tname = \"world\"\n\t}\n\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\treq := &pb.HelloRequest{Name: name}\n\tres, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not greet: %v\", err)\n\t}\n\n\treturn res.Message, nil\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles plugin registration and message streaming between clients and middleware components.\n\nStruct Description: The pluginServer struct implements a gRPC service for plugin registration and message handling, managing concurrent access with synchronization and supporting both middleware and non-middleware listeners.\n\nFields:\n- UnimplementedPluginServer: pb.UnimplementedPluginServer - Embedded type for forward compatibility\n- lock: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n- RegisterListener: (stream pb.Plugin_RegisterListenerServer) -> error - Handles client registration and message streaming\n  - Input: gRPC bidirectional stream of pb.Plugin_RegisterListenerServer\n  - Output: error indicating operation status\n  - Description: Registers listeners, processes incoming messages, matches against regex patterns, handles middleware responses, and manages one-time listeners\n\n- rpcInit: () -> () - Initializes and starts the gRPC server\n  - Input: None (uses package-level Integrations.RPC configuration)\n  - Output: None (runs as goroutine)\n  - Description: Creates TCP listener, configures gRPC server with interceptors and keepalive, registers service, and starts serving requests",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype pluginServer struct {\n\tpb.UnimplementedPluginServer\n\tlock sync.Mutex\n}\n\nfunc (s *pluginServer) RegisterListener(stream pb.Plugin_RegisterListenerServer) error {\n\ts.lock.Lock()\n\tinitialData, err := stream.Recv()\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistener := initialData.GetListener()\n\tif listener == nil {\n\t\treturn status.Error(codes.InvalidArgument, \"First message must be a listener\")\n\t}\n\n\tisMiddleware := listener.Middleware != nil && *listener.Middleware\n\tisOnce := listener.Once != nil && *listener.Once\n\n\tvar regex *regexp.Regexp\n\tif listener.Regex != nil {\n\t\tregex, err = regexp.Compile(*listener.Regex)\n\t\tif err != nil {\n\t\t\treturn status.Error(codes.InvalidArgument, \"Invalid regex\")\n\t\t}\n\t}\n\n\tvar listenerList *[]chan pb.MiddlewareChannelMessage\n\n\tif isMiddleware {\n\t\tlistenerList = &ListenersMiddleware\n\t} else {\n\t\tlistenerList = &ListenersNonMiddleware\n\t}\n\n\tc := make(chan pb.MiddlewareChannelMessage)\n\t*listenerList = append(*listenerList, c)\n\n\ts.lock.Unlock()\n\tdefer func() {\n\t\tfor i := range *listenerList {\n\t\t\tif (*listenerList)[i] == c {\n\t\t\t\t*listenerList = append((*listenerList)[:i], (*listenerList)[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tmessage := <-c\n\n\t\tsendNilResponse := func() {\n\t\t\tc <- &pb.ListenerClientData_Response{\n\t\t\t\tResponse: &pb.MiddlewareResponse{\n\t\t\t\t\tMsg: nil,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif listener.Regex != nil && !regex.MatchString(message.(*pb.Event).Msg) {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\terr = stream.Send(message.(*pb.Event))\n\t\tif err != nil {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif isMiddleware {\n\t\t\tmwRes, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tswitch data := mwRes.Data.(type) {\n\t\t\tcase *pb.ListenerClientData_Listener:\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn status.Error(codes.InvalidArgument, \"Middleware returned a listener instead of a response\")\n\t\t\tcase *pb.ListenerClientData_Response:\n\t\t\t\tc <- data\n\t\t\t}\n\t\t}\n\n\t\tif isOnce {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc rpcInit() {\n\tif Integrations.RPC == nil {\n\t\treturn\n\t}\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", Integrations.RPC.Port))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgrpcServer := grpc.NewServer(\n\t\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\t\tif err := authorize(ctx); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn handler(ctx, req)\n\t\t\t}),\n\t\t\tgrpc.StreamInterceptor(func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n\t\t\t\tif err := authorize(stream.Context()); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn handler(srv, stream)\n\t\t\t}),\n\t\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{Time: time.Second * 10}),\n\t\t)\n\t\tpb.RegisterPluginServer(grpcServer, &pluginServer{})\n\t\tgrpcServer.Serve(lis)\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"regexp\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype pluginServer struct {\n\tpb.UnimplementedPluginServer\n\tlock sync.Mutex\n}\n\nfunc (s *pluginServer) RegisterListener(stream pb.Plugin_RegisterListenerServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.lock.Lock()\n\t\t// Process the request, match regex, handle middleware, etc.\n\t\t// Example: Check if the message matches a certain pattern\n\t\tmatched, _ := regexp.MatchString(\"your-regex-pattern\", req.Message)\n\t\tif matched {\n\t\t\t// Handle matched message\n\t\t\tfmt.Println(\"Matched message:\", req.Message)\n\t\t}\n\t\ts.lock.Unlock()\n\n\t\t// Example response\n\t\tif err := stream.Send(&pb.Response{Message: \"Processed\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *pluginServer) rpcInit() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to listen: %v\\n\", err)\n\t\treturn\n\t}\n\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tMaxConnectionIdle: 5 * 60 * 1000, // 5 minutes\n\t\t}),\n\t)\n\n\tpb.RegisterPluginServer(grpcServer, s)\n\n\tfmt.Println(\"gRPC server is running on port 50051\")\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tfmt.Printf(\"Failed to serve: %v\\n\", err)\n\t}\n}\n\nfunc main() {\n\tserver := &pluginServer{}\n\tgo server.rpcInit()\n\n\t// Block main goroutine\n\tselect {}\n}"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework. The server should be able to gracefully shut down when the context is canceled.\n\nFunction Description: The MainExt function initializes and starts a gRPC server. It sets up a network listener, creates a gRPC server instance, registers the service implementation, and starts the server in a goroutine. The function waits for the context to be canceled before gracefully shutting down the server.\n\nInput:\n- ctx [context.Context]: The context used to control the lifecycle of the gRPC server. Canceling this context will trigger a graceful shutdown.\n- cfg [Config]: A configuration object containing the port number on which the server should listen.\n\nOutput: None (The function runs indefinitely until the context is canceled or an error occurs.)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\ttriggerpb \"github.com/vanus-labs/vanus/api/trigger\"\n)\n\ntype TriggerServer struct {\n\tcfg Config\n}\n\nfunc NewTriggerServer(cfg Config) *TriggerServer {\n\treturn &TriggerServer{\n\t\tcfg: cfg,\n\t}\n}\n\nfunc MainExt(ctx context.Context, cfg Config) {\n\tlisten, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n\tif err != nil {\n\t\tlog.Error().Msg(\"failed to listen\")\n\t\tos.Exit(-1)\n\t}\n\n\tsrv := NewTriggerServer(cfg)\n\n\tvar opts []grpc.ServerOption\n\tgrpcServer := grpc.NewServer(opts...)\n\ttriggerpb.RegisterTriggerWorkerServer(grpcServer, srv)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Info(ctx).Msg(\"the grpc server ready to work\")\n\t\terr = grpcServer.Serve(listen)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"grpc server occurred an error\")\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\tgrpcServer.GracefulStop()\n\twg.Wait()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Config struct {\n\tPort int\n}\n\ntype server struct{}\n\nfunc MainExt(ctx context.Context, cfg Config) {\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to listen: %v\\n\", err)\n\t\treturn\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\t// Register your service implementation here\n\t// pb.RegisterYourServiceServer(grpcServer, &server{})\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\tfmt.Printf(\"Failed to serve: %v\\n\", err)\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\n\tfmt.Println(\"Shutting down gRPC server...\")\n\tgrpcServer.GracefulStop()\n\tfmt.Println(\"gRPC server stopped.\")\n}\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tcfg := Config{Port: 50051}\n\n\tgo func() {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\t\t<-c\n\t\tcancel()\n\t}()\n\n\tMainExt(ctx, cfg)\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, creates a new gRPC server instance, registers a service implementation, and starts serving incoming requests.\n\nInput: \n- port: string - The network port on which the server should listen (e.g., \":50051\")\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/helloworld/helloworld\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\ts.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype server struct {\n\tpb.UnimplementedYourServiceServer\n}\n\nfunc main() {\n\tport := \":50051\"\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterYourServiceServer(grpcServer, &server{})\n\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a gRPC server in Go that handles metric forwarding operations, including receiving metrics and processing them through a handler function.\n\nStruct Description: The Server struct represents a gRPC server that listens for incoming metric data and processes it using a provided handler function. It manages server lifecycle and handles gRPC communication.\n\nFields:\n- Server: *grpc.Server - The underlying gRPC server instance\n- lis: net.Listener - The network listener for the server\n- handler: func([]*metricpb.Metric) - The function that processes received metrics\n- startMtx: sync.Mutex - Mutex to ensure thread-safe server startup\n\nMethods:\n- NewServer: (handler func([]*metricpb.Metric)) -> *Server - Creates a new Server instance with the given metric handler and initializes the gRPC server\n- Start: (t testing.TB) -> () - Starts the gRPC server on a random available port and begins listening for requests\n- SendMetrics: (ctx context.Context, mlist *forwardrpc.MetricList) -> (*empty.Empty, error) - Handles unary RPC calls for metric submission\n- SendMetricsV2: (server forwardrpc.Forward_SendMetricsV2Server) -> error - Handles streaming RPC calls for metric submission",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\n\t\"context\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/stripe/veneur/v14/forwardrpc\"\n\t\"github.com/stripe/veneur/v14/samplers/metricpb\"\n)\n\ntype Server struct {\n\t*grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\tres := &Server{\n\t\tServer:  grpc.NewServer(),\n\t\thandler: handler,\n\t}\n\n\tforwardrpc.RegisterForwardServer(res.Server, res)\n\treturn res\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\tvar err error\n\ts.lis, err = net.Listen(\"tcp\", \"127.0.0.1:\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create a TCP connection for a test GRPC \"+\n\t\t\t\"server: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := s.Serve(s.lis); err != nil && err != grpc.ErrServerStopped {\n\t\t\tt.Logf(\"failed to stop the test forwarding gRPC server: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) SendMetrics(ctx context.Context, mlist *forwardrpc.MetricList) (*empty.Empty, error) {\n\ts.handler(mlist.Metrics)\n\treturn &empty.Empty{}, nil\n}\n\nfunc (s *Server) SendMetricsV2(\n\tserver forwardrpc.Forward_SendMetricsV2Server,\n) error {\n\tmetrics := []*metricpb.Metric{}\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmetrics = append(metrics, metric)\n\t}\n\t_, err := s.SendMetrics(context.Background(), &forwardrpc.MetricList{\n\t\tMetrics: metrics,\n\t})\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\n\tmetricpb \"path/to/metricpb\"\n\tforwardrpc \"path/to/forwardrpc\"\n)\n\ntype Server struct {\n\tServer   *grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\treturn &Server{\n\t\tServer:  grpc.NewServer(),\n\t\thandler: handler,\n\t}\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\tvar err error\n\ts.lis, err = net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := s.Server.Serve(s.lis); err != nil {\n\t\t\tt.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) SendMetrics(ctx context.Context, mlist *forwardrpc.MetricList) (*emptypb.Empty, error) {\n\ts.handler(mlist.Metrics)\n\treturn &emptypb.Empty{}, nil\n}\n\nfunc (s *Server) SendMetricsV2(server forwardrpc.Forward_SendMetricsV2Server) error {\n\tfor {\n\t\tmlist, err := server.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.handler(mlist.Metrics)\n\t}\n}\n```"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both physical data source operations and execution of data processing tasks, using Unix domain sockets for inter-process communication.\n\nStruct Description: The implementation consists of two main structs: physicalServer handles the materialization of data sources, while executionServer manages the execution of data processing tasks.\n\nFields:\n\nphysicalServer:\n- database: physical.Database - The underlying database implementation\n- socketDir: string - Directory where Unix domain sockets will be created\n- wg: *sync.WaitGroup - WaitGroup for managing server goroutines\n\nexecutionServer:\n- node: execution.Node - The execution node to process data\n\nMethods:\n\nphysicalServer:\n- Materialize(context.Context, *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) - Materializes a data source and starts a gRPC server for execution\n\nexecutionServer:\n- Run(*plugins.RunRequest, plugins.ExecutionDatasource_RunServer) error - Executes the data processing task and streams results back to the client",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/cube2222/octosql/execution\"\n\t\"github.com/cube2222/octosql/physical\"\n\t\"github.com/cube2222/octosql/plugins/internal/plugins\"\n)\n\ntype physicalServer struct {\n\tplugins.UnimplementedDatasourceServer\n\tdatabase  physical.Database\n\tsocketDir string\n\twg        *sync.WaitGroup\n}\n\nfunc (s *physicalServer) Materialize(ctx context.Context, request *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\timpl, _, err := s.database.GetTable(ctx, request.TableContext.TableName, request.TableContext.Options)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't get table: %w\", err)\n\t}\n\n\tnode, err := impl.Materialize(\n\t\tctx,\n\t\tphysical.Environment{\n\t\t\tVariableContext: request.VariableContext.ToNativePhysicalVariableContext(),\n\t\t},\n\t\trequest.Schema.ToNativeSchema(),\n\t\tpushedDownPredicates,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't materialize datasource: %w\", err)\n\t}\n\n\tsocketName := ulid.MustNew(ulid.Now(), rand.Reader).String() + \".sock\"\n\tsocketPath := filepath.Join(s.socketDir, socketName)\n\tlog.Printf(\"Listening execution on %s\", socketPath)\n\tlis, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\texecServer := &executionServer{\n\t\tnode: node,\n\t}\n\ts.wg.Add(1)\n\n\tgrpcServer := grpc.NewServer()\n\tplugins.RegisterExecutionDatasourceServer(grpcServer, execServer)\n\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\treturn &plugins.MaterializeResponse{SocketPath: socketPath}, nil\n}\n\ntype executionServer struct {\n\tplugins.UnimplementedExecutionDatasourceServer\n\tnode execution.Node\n}\n\nfunc (e *executionServer) Run(request *plugins.RunRequest, stream plugins.ExecutionDatasource_RunServer) error {\n\tif err := e.node.Run(\n\t\texecution.ExecutionContext{\n\t\t\tContext:         stream.Context(),\n\t\t\tVariableContext: request.VariableContext.ToNativeExecutionVariableContext(),\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, record execution.Record) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tRecord: plugins.NativeRecordToProto(record),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send record to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, msg execution.MetadataMessage) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tMetadata: plugins.NativeMetadataMessageToProto(msg),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send metadata message to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t); err != nil {\n\t\treturn fmt.Errorf(\"couldn't run node: %w\", err)\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"example.com/project/physical\"\n\t\"example.com/project/execution\"\n\t\"example.com/project/plugins\"\n)\n\ntype physicalServer struct {\n\tdatabase  physical.Database\n\tsocketDir string\n\twg        *sync.WaitGroup\n}\n\ntype executionServer struct {\n\tnode execution.Node\n}\n\nfunc (p *physicalServer) Materialize(ctx context.Context, req *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\tsocketPath := p.socketDir + \"/materialize.sock\"\n\tlistener, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp.wg.Add(1)\n\tgo func() {\n\t\tdefer p.wg.Done()\n\t\tserver := grpc.NewServer()\n\t\tplugins.RegisterExecutionDatasourceServer(server, &executionServer{node: p.database.GetExecutionNode()})\n\t\treflection.Register(server)\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tos.Remove(socketPath)\n\t\t}\n\t}()\n\treturn &plugins.MaterializeResponse{SocketPath: socketPath}, nil\n}\n\nfunc (e *executionServer) Run(req *plugins.RunRequest, stream plugins.ExecutionDatasource_RunServer) error {\n\tresults, err := e.node.Execute(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, result := range results {\n\t\tif err := stream.Send(result); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\t// Example main function to initialize and run the servers\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Implement a gRPC server for remote actor communication in a distributed actor system using Proto.Actor and Go's gRPC framework.\n\nStruct Description: The Remote struct manages the gRPC server and associated components for remote actor communication in a Proto.Actor system.\n\nFields:\n\nactorSystem: *actor.ActorSystem - Reference to the actor system this remote belongs to\ns: *grpc.Server - The gRPC server instance\nedpReader: *endpointReader - Handles incoming gRPC connections\nedpManager: *endpointManager - Manages active endpoints\nconfig: *Config - Configuration for the remote server\nkinds: map[string]*actor.Props - Map of actor kinds to their properties\nactivatorPid: *actor.PID - Process ID for the activator actor\nblocklist: *BlockList - List of blocked endpoints\n\nMethods:\n\nNewRemote: (actorSystem *actor.ActorSystem, config *Config) -> *Remote - Constructor that initializes a new Remote instance with given actor system and configuration\nStart: () -> () - Starts the gRPC server and initializes all remote communication components\nShutdown: (graceful bool) -> () - Stops the gRPC server, either gracefully or forcefully",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log/slog\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/asynkron/protoactor-go/extensions\"\n\t\"github.com/asynkron/protoactor-go/actor\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/grpclog\"\n)\n\ntype Remote struct {\n\tactorSystem  *actor.ActorSystem\n\ts            *grpc.Server\n\tedpReader    *endpointReader\n\tedpManager   *endpointManager\n\tconfig       *Config\n\tkinds        map[string]*actor.Props\n\tactivatorPid *actor.PID\n\tblocklist    *BlockList\n}\n\nfunc NewRemote(actorSystem *actor.ActorSystem, config *Config) *Remote {\n\tr := &Remote{\n\t\tactorSystem: actorSystem,\n\t\tconfig:      config,\n\t\tkinds:       make(map[string]*actor.Props),\n\t\tblocklist:   NewBlockList(),\n\t}\n\tfor k, v := range config.Kinds {\n\t\tr.kinds[k] = v\n\t}\n\n\tactorSystem.Extensions.Register(r)\n\n\treturn r\n}\n\nfunc (r *Remote) Start() {\n\tgrpclog.SetLoggerV2(grpclog.NewLoggerV2(ioutil.Discard, ioutil.Discard, ioutil.Discard))\n\tlis, err := net.Listen(\"tcp\", r.config.Address())\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to listen: %v\", err))\n\t}\n\n\tvar address string\n\tif r.config.AdvertisedHost != \"\" {\n\t\taddress = r.config.AdvertisedHost\n\t} else {\n\t\taddress = lis.Addr().String()\n\t}\n\n\tr.actorSystem.ProcessRegistry.RegisterAddressResolver(r.remoteHandler)\n\tr.actorSystem.ProcessRegistry.Address = address\n\tr.Logger().Info(\"Starting remote with address\", slog.String(\"address\", address))\n\n\tr.edpManager = newEndpointManager(r)\n\tr.edpManager.start()\n\n\tr.s = grpc.NewServer(r.config.ServerOptions...)\n\tr.edpReader = newEndpointReader(r)\n\tRegisterRemotingServer(r.s, r.edpReader)\n\tr.Logger().Info(\"Starting Proto.Actor server\", slog.String(\"address\", address))\n\tgo r.s.Serve(lis)\n}\n\nfunc (r *Remote) Shutdown(graceful bool) {\n\tif graceful {\n\t\tr.edpReader.suspend(true)\n\t\tr.edpManager.stop()\n\n\t\tc := make(chan bool, 1)\n\t\tgo func() {\n\t\t\tr.s.GracefulStop()\n\t\t\tc <- true\n\t\t}()\n\n\t\tselect {\n\t\tcase <-c:\n\t\t\tr.Logger().Info(\"Stopped Proto.Actor server\")\n\t\tcase <-time.After(time.Second * 10):\n\t\t\tr.s.Stop()\n\t\t\tr.Logger().Info(\"Stopped Proto.Actor server\", slog.String(\"err\", \"timeout\"))\n\t\t}\n\t} else {\n\t\tr.s.Stop()\n\t\tr.Logger().Info(\"Killed Proto.Actor server\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage remote\n\nimport (\n\t\"context\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/asynkron/protoactor-go/actor\"\n)\n\ntype Remote struct {\n\tactorSystem  *actor.ActorSystem\n\ts            *grpc.Server\n\tedpReader    *endpointReader\n\tedpManager   *endpointManager\n\tconfig       *Config\n\tkinds        map[string]*actor.Props\n\tactivatorPid *actor.PID\n\tblocklist    *BlockList\n}\n\nfunc NewRemote(actorSystem *actor.ActorSystem, config *Config) *Remote {\n\treturn &Remote{\n\t\tactorSystem: actorSystem,\n\t\tconfig:      config,\n\t\tkinds:       make(map[string]*actor.Props),\n\t\tblocklist:   NewBlockList(),\n\t}\n}\n\nfunc (r *Remote) Start() {\n\tlis, err := net.Listen(\"tcp\", r.config.Address)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tr.s = grpc.NewServer()\n\tr.edpReader = newEndpointReader(r.actorSystem, r.config)\n\tr.edpManager = newEndpointManager(r.actorSystem, r.config)\n\n\t// Register gRPC services here\n\t// pb.RegisterYourServiceServer(r.s, yourServiceImplementation)\n\n\tgo func() {\n\t\tif err := r.s.Serve(lis); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n}\n\nfunc (r *Remote) Shutdown(graceful bool) {\n\tif graceful {\n\t\tr.s.GracefulStop()\n\t} else {\n\t\tr.s.Stop()\n\t}\n}\n```"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a gRPC server in Go that collects and processes metrics data using OpenTelemetry protocol, with capabilities for handling incoming requests, storing metrics, and managing server lifecycle.\n\nStruct Description: GRPCCollector is a gRPC server implementation that handles metrics collection following the OpenTelemetry protocol. It manages incoming requests, stores metrics data, tracks headers, and provides server control functionality.\n\nFields:\n\nField1: collpb.UnimplementedMetricsServiceServer - Embedded type to satisfy gRPC interface requirements\nField2: headersMu sync.Mutex - Mutex for thread-safe access to headers\nField3: headers metadata.MD - Stores incoming request headers\nField4: storage *Storage - Stores collected metrics data\nField5: resultCh <-chan ExportResult - Channel for receiving export results\nField6: listener net.Listener - Network listener for the server\nField7: srv *grpc.Server - gRPC server instance\n\nMethods:\n\nMethod1: NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) - Creates and starts a new gRPC collector instance\nMethod2: Shutdown() - Stops the gRPC server gracefully\nMethod3: Addr() net.Addr - Returns the network address the server is listening on\nMethod4: Collect() *Storage - Returns the storage containing collected metrics\nMethod5: Headers() map[string][]string - Returns collected headers in a thread-safe manner\nMethod6: Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) - Handles incoming metrics export requests and processes them",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"go.opentelemetry.io/proto/otlp/collector/metrics/v1\"\n)\n\ntype GRPCCollector struct {\n\tcollpb.UnimplementedMetricsServiceServer\n\n\theadersMu sync.Mutex\n\theaders   metadata.MD\n\tstorage   *Storage\n\n\tresultCh <-chan ExportResult\n\tlistener net.Listener\n\tsrv      *grpc.Server\n}\n\nfunc NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) {\n\tif endpoint == \"\" {\n\t\tendpoint = \"localhost:0\"\n\t}\n\n\tc := &GRPCCollector{\n\t\tstorage:  NewStorage(),\n\t\tresultCh: resultCh,\n\t}\n\n\tvar err error\n\tc.listener, err = net.Listen(\"tcp\", endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.srv = grpc.NewServer()\n\tcollpb.RegisterMetricsServiceServer(c.srv, c)\n\tgo func() { _ = c.srv.Serve(c.listener) }()\n\n\treturn c, nil\n}\n\nfunc (c *GRPCCollector) Shutdown() { c.srv.Stop() }\n\nfunc (c *GRPCCollector) Addr() net.Addr {\n\treturn c.listener.Addr()\n}\n\nfunc (c *GRPCCollector) Collect() *Storage {\n\treturn c.storage\n}\n\nfunc (c *GRPCCollector) Headers() map[string][]string {\n\tc.headersMu.Lock()\n\tdefer c.headersMu.Unlock()\n\treturn metadata.Join(c.headers)\n}\n\nfunc (c *GRPCCollector) Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) {\n\tc.storage.Add(req)\n\n\tif h, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tc.headersMu.Lock()\n\t\tc.headers = metadata.Join(c.headers, h)\n\t\tc.headersMu.Unlock()\n\t}\n\n\tif c.resultCh != nil {\n\t\tr := <-c.resultCh\n\t\tif r.Response == nil {\n\t\t\treturn &collpb.ExportMetricsServiceResponse{}, r.Err\n\t\t}\n\t\treturn r.Response, r.Err\n\t}\n\treturn &collpb.ExportMetricsServiceResponse{}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"go.opentelemetry.io/collector/pb/collpb\"\n\t\"go.opentelemetry.io/collector/pb/otlpmetrics\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype ExportResult struct{}\n\ntype Storage struct {\n\tmetrics []*otlpmetrics.ResourceMetrics\n}\n\ntype GRPCCollector struct {\n\tcollpb.UnimplementedMetricsServiceServer\n\theadersMu sync.Mutex\n\theaders   metadata.MD\n\tstorage   *Storage\n\tresultCh  <-chan ExportResult\n\tlistener  net.Listener\n\tsrv       *grpc.Server\n}\n\nfunc NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) {\n\tlistener, err := net.Listen(\"tcp\", endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsrv := grpc.NewServer()\n\tcollector := &GRPCCollector{\n\t\tstorage:  &Storage{},\n\t\tresultCh: resultCh,\n\t\tlistener: listener,\n\t\tsrv:      srv,\n\t}\n\n\tcollpb.RegisterMetricsServiceServer(srv, collector)\n\n\tgo func() {\n\t\tif err := srv.Serve(listener); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\treturn collector, nil\n}\n\nfunc (c *GRPCCollector) Shutdown() {\n\tc.srv.GracefulStop()\n}\n\nfunc (c *GRPCCollector) Addr() net.Addr {\n\treturn c.listener.Addr()\n}\n\nfunc (c *GRPCCollector) Collect() *Storage {\n\treturn c.storage\n}\n\nfunc (c *GRPCCollector) Headers() map[string][]string {\n\tc.headersMu.Lock()\n\tdefer c.headersMu.Unlock()\n\treturn c.headers\n}\n\nfunc (c *GRPCCollector) Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) {\n\tc.headersMu.Lock()\n\tc.headers, _ = metadata.FromIncomingContext(ctx)\n\tc.headersMu.Unlock()\n\n\tc.storage.metrics = append(c.storage.metrics, req.ResourceMetrics...)\n\n\tselect {\n\tcase <-c.resultCh:\n\t\t// Handle export result\n\tdefault:\n\t}\n\n\treturn &collpb.ExportMetricsServiceResponse{}, nil\n}\n\nfunc main() {\n\t// Example usage\n\tendpoint := \":50051\"\n\tresultCh := make(chan ExportResult)\n\tcollector, err := NewGRPCCollector(endpoint, resultCh)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer collector.Shutdown()\n\n\t// Use collector.Addr(), collector.Collect(), collector.Headers() as needed\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles unary RPC calls with ORCA (Open Request Cost Aggregation) metrics recording capabilities.\n\nStruct Description: The server struct implements the gRPC service interface (generated from the protobuf definition) and includes ORCA metrics recording functionality.\n\nFields:\n- UnimplementedEchoServer: [pb.UnimplementedEchoServer] - Embedded type to satisfy the gRPC service interface requirements\n\nMethods:\n- UnaryEcho: [Name](ctx context.Context, in *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls, records request costs using ORCA metrics, and returns an echo response\n- main: [Name]() -> None - Sets up the gRPC server, registers the service, configures ORCA metrics reporting, and starts the server\n\nInput Parameters for UnaryEcho:\n- ctx: [context.Context] - Context containing call information and ORCA metrics recorder\n- in: [*pb.EchoRequest] - Incoming request message containing the message to echo\n\nOutput for UnaryEcho:\n- [*pb.EchoResponse] - Response message containing the echoed message\n- [error] - Potential error during processing\n\nNote: The main function doesn't have explicit input/output but performs server setup and execution.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/orca\"\n\t\"google.golang.org/grpc/internal\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tcmr := orca.CallMetricsRecorderFromContext(ctx)\n\tif cmr == nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"unable to retrieve call metrics recorder (missing ORCA ServerOption?)\")\n\t}\n\tcmr.SetRequestCost(\"db_queries\", 10)\n\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(orca.CallMetricsServerOption(nil))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tsmr := orca.NewServerMetricsRecorder()\n\topts := orca.ServiceOptions{\n\t\tMinReportingInterval:  3 * time.Second,\n\t\tServerMetricsProvider: smr,\n\t}\n\tinternal.ORCAAllowAnyMinReportingInterval.(func(so *orca.ServiceOptions))(&opts)\n\tif err := orca.Register(s, opts); err != nil {\n\t\tlog.Fatalf(\"Failed to register ORCA service: %v\", err)\n\t}\n\n\ts.Serve(lis)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/orca\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\torcaMetrics := orca.FromContext(ctx)\n\tif orcaMetrics != nil {\n\t\torcaMetrics.SetRequestCost(1.0) // Example cost\n\t}\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(\n\t\tgrpc.Creds(insecure.NewCredentials()),\n\t\tgrpc.ChainUnaryInterceptor(orca.UnaryServerInterceptor()),\n\t)\n\n\tpb.RegisterEchoServer(s, &server{})\n\n\tlog.Println(\"gRPC server listening on :50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, registers service implementations, and starts serving on a specified port with optional TLS credentials.\n\nFunction Description: The main function initializes and starts a gRPC server that hosts two services: a custom SpannerExecutorProxy service and a standard health check service. It validates required configuration parameters, sets up the network listener, creates the gRPC server instance, registers services, and begins serving requests.\n\nInput:\n- proxyPort (string): The port number on which the gRPC server should listen\n- spannerPort (string): The port number for Spanner service (validation only)\n- cert (string): Path to certificate file for TLS (validation only)\n- Additional client options are obtained internally through getClientOptionsForSysTests()\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Logs server startup information or errors to stdout\n\nNote: The function doesn't explicitly return values but may terminate the program with log.Fatal or log.Fatalf in case of errors during setup. Successful execution results in a continuously running gRPC server.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"cloud.google.com/go/spanner/executor/apiv1/executorpb\"\n\t\"cloud.google.com/go/spanner/test/cloudexecutor/executor\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *proxyPort == \"\" {\n\t\tlog.Fatal(\"Proxy port need to be assigned in order to start worker proxy.\")\n\t}\n\tif *spannerPort == \"\" {\n\t\tlog.Fatal(\"Spanner proxyPort need to be assigned in order to start worker proxy.\")\n\t}\n\tif *cert == \"\" {\n\t\tlog.Fatalf(\"Certificate need to be assigned in order to start worker proxy.\")\n\t}\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%s\", *proxyPort))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\n\tclientOptions := getClientOptionsForSysTests()\n\tcloudProxyServer, err := executor.NewCloudProxyServer(context.Background(), clientOptions)\n\tif err != nil {\n\t\tlog.Fatalf(\"Creating Cloud Proxy Server failed: %v\", err)\n\t}\n\texecutorpb.RegisterSpannerExecutorProxyServer(grpcServer, cloudProxyServer)\n\n\thealthServer := health.NewServer()\n\tgrpc_health_v1.RegisterHealthServer(grpcServer, healthServer)\n\n\tlog.Printf(\"Server started on proxyPort:%s\\n\", *proxyPort)\n\terr = grpcServer.Serve(lis)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to start server on proxyPort: %s\\n\", *proxyPort)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\n\ntype SpannerExecutorProxy struct {\n\t// Implement your service methods here\n}\n\nfunc (s *SpannerExecutorProxy) Execute(ctx context.Context, req *YourRequestType) (*YourResponseType, error) {\n\t// Implement your method logic here\n\treturn &YourResponseType{}, nil\n}\n\nfunc getClientOptionsForSysTests() []grpc.DialOption {\n\t// Implement your client options logic here\n\treturn []grpc.DialOption{}\n}\n\nfunc main() {\n\tproxyPort := flag.String(\"proxyPort\", \"\", \"The port number on which the gRPC server should listen\")\n\tspannerPort := flag.String(\"spannerPort\", \"\", \"The port number for Spanner service (validation only)\")\n\tcert := flag.String(\"cert\", \"\", \"Path to certificate file for TLS (validation only)\")\n\tflag.Parse()\n\n\tif *proxyPort == \"\" || *spannerPort == \"\" || *cert == \"\" {\n\t\tlog.Fatal(\"proxyPort, spannerPort, and cert must be provided\")\n\t}\n\n\tcertificate, err := tls.LoadX509KeyPair(*cert, *cert)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load certificate: %v\", err)\n\t}\n\n\tcertPool := x509.NewCertPool()\n\tca, err := ioutil.ReadFile(*cert)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to read certificate file: %v\", err)\n\t}\n\n\tif ok := certPool.AppendCertsFromPEM(ca); !ok {\n\t\tlog.Fatal(\"failed to append certs\")\n\t}\n\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{certificate},\n\t\tClientCAs:    certPool,\n\t})\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%s\", *proxyPort))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tserver := grpc.NewServer(grpc.Creds(creds))\n\tspannerExecutorProxy := &SpannerExecutorProxy{}\n\t// Register your SpannerExecutorProxy service here\n\t// pb.RegisterSpannerExecutorProxyServer(server, spannerExecutorProxy)\n\n\thealthServer := health.NewServer()\n\tgrpc_health_v1.RegisterHealthServer(server, healthServer)\n\n\tlog.Printf(\"Starting gRPC server on port %s\", *proxyPort)\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both xDS (Discovery Service) and LRS (Load Reporting Service) protocols, with proper request/response channels and connection monitoring capabilities.\n\nStruct Description: The Server struct represents a gRPC server that implements both xDS v3 and LRS v3 services. It manages communication channels for requests/responses and tracks connection state.\n\nFields:\n\nXDSRequestChan: *testutils.Channel - Channel for receiving xDS requests\nXDSResponseChan: chan *Response - Channel for sending xDS responses\nLRSRequestChan: *testutils.Channel - Channel for receiving LRS requests\nLRSResponseChan: chan *Response - Channel for sending LRS responses\nLRSStreamOpenChan: *testutils.Channel - Channel for tracking LRS stream openings\nLRSStreamCloseChan: *testutils.Channel - Channel for tracking LRS stream closings\nNewConnChan: *testutils.Channel - Channel for tracking new connections\nAddress: string - Server's listening address\nxdsServerV3: *xdsServerV3 - xDS v3 server implementation\nlrsServerV3: *lrsServerV3 - LRS v3 server implementation\n\nMethods:\n\nNewServer: (addr string) -> *Server - Creates a new Server instance with initialized channels\nStartServer: (lis net.Listener) -> (*Server, func(), error) - Starts the gRPC server on given listener and returns cleanup function\nStreamAggregatedResources: (s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) -> error - Handles xDS v3 streaming RPC\nStreamLoadStats: (s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) -> error - Handles LRS v3 streaming RPC",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils\"\n\t\"google.golang.org/protobuf/proto\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3lrspb \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n)\n\ntype Server struct {\n\tXDSRequestChan *testutils.Channel\n\tXDSResponseChan chan *Response\n\tLRSRequestChan *testutils.Channel\n\tLRSResponseChan chan *Response\n\tLRSStreamOpenChan *testutils.Channel\n\tLRSStreamCloseChan *testutils.Channel\n\tNewConnChan *testutils.Channel\n\tAddress string\n\t*xdsServerV3\n\t*lrsServerV3\n}\n\ntype wrappedListener struct {\n\tnet.Listener\n\tserver *Server\n}\n\nfunc (wl *wrappedListener) Accept() (net.Conn, error) {\n\tc, err := wl.Listener.Accept()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twl.server.NewConnChan.Send(struct{}{})\n\treturn c, err\n}\n\nfunc StartServer(lis net.Listener) (*Server, func(), error) {\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\treturn nil, func() {}, fmt.Errorf(\"net.Listen() failed: %v\", err)\n\t\t}\n\t}\n\n\ts := NewServer(lis.Addr().String())\n\twp := &wrappedListener{\n\t\tListener: lis,\n\t\tserver:   s,\n\t}\n\n\tserver := grpc.NewServer()\n\tv3lrsgrpc.RegisterLoadReportingServiceServer(server, s)\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(server, s)\n\tgo server.Serve(wp)\n\n\treturn s, func() { server.Stop() }, nil\n}\n\nfunc NewServer(addr string) *Server {\n\ts := &Server{\n\t\tXDSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tNewConnChan:        testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tXDSResponseChan:    make(chan *Response, defaultChannelBufferSize),\n\t\tLRSResponseChan:    make(chan *Response, 1),\n\t\tLRSStreamOpenChan:  testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSStreamCloseChan: testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tAddress:            addr,\n\t}\n\ts.xdsServerV3 = &xdsServerV3{reqChan: s.XDSRequestChan, respChan: s.XDSResponseChan}\n\ts.lrsServerV3 = &lrsServerV3{reqChan: s.LRSRequestChan, respChan: s.LRSResponseChan, streamOpenChan: s.LRSStreamOpenChan, streamCloseChan: s.LRSStreamCloseChan}\n\treturn s\n}\n\ntype xdsServerV3 struct {\n\treqChan  *testutils.Channel\n\trespChan chan *Response\n}\n\nfunc (xdsS *xdsServerV3) StreamAggregatedResources(s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\terrCh := make(chan error, 2)\n\tgo func() {\n\t\tfor {\n\t\t\treq, err := s.Recv()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\txdsS.reqChan.Send(&Request{req, err})\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar retErr error\n\t\tdefer func() {\n\t\t\terrCh <- retErr\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase r := <-xdsS.respChan:\n\t\t\t\tif r.Err != nil {\n\t\t\t\t\tretErr = r.Err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := s.Send(r.Resp.(*v3discoverypb.DiscoveryResponse)); err != nil {\n\t\t\t\t\tretErr = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-s.Context().Done():\n\t\t\t\tretErr = s.Context().Err()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := <-errCh; err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype lrsServerV3 struct {\n\treqChan         *testutils.Channel\n\trespChan        chan *Response\n\tstreamOpenChan  *testutils.Channel\n\tstreamCloseChan *testutils.Channel\n}\n\nfunc (lrsS *lrsServerV3) StreamLoadStats(s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\tlrsS.streamOpenChan.Send(nil)\n\tdefer lrsS.streamCloseChan.Send(nil)\n\n\treq, err := s.Recv()\n\tlrsS.reqChan.Send(&Request{req, err})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase r := <-lrsS.respChan:\n\t\tif r.Err != nil {\n\t\t\treturn r.Err\n\t\t}\n\t\tif err := s.Send(r.Resp.(*v3lrspb.LoadStatsResponse)); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase <-s.Context().Done():\n\t\treturn s.Context().Err()\n\t}\n\n\tfor {\n\t\treq, err := s.Recv()\n\t\tlrsS.reqChan.Send(&Request{req, err})\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\t\"github.com/envoyproxy/go-control-plane/pkg/testutils\"\n)\n\ntype Response struct{}\n\ntype xdsServerV3 struct{}\ntype lrsServerV3 struct{}\n\ntype Server struct {\n\tXDSRequestChan     *testutils.Channel\n\tXDSResponseChan    chan *Response\n\tLRSRequestChan     *testutils.Channel\n\tLRSResponseChan    chan *Response\n\tLRSStreamOpenChan  *testutils.Channel\n\tLRSStreamCloseChan *testutils.Channel\n\tNewConnChan        *testutils.Channel\n\tAddress            string\n\txdsServerV3        *xdsServerV3\n\tlrsServerV3        *lrsServerV3\n}\n\nfunc NewServer(addr string) *Server {\n\treturn &Server{\n\t\tXDSRequestChan:     testutils.NewChannel(),\n\t\tXDSResponseChan:    make(chan *Response),\n\t\tLRSRequestChan:     testutils.NewChannel(),\n\t\tLRSResponseChan:    make(chan *Response),\n\t\tLRSStreamOpenChan:  testutils.NewChannel(),\n\t\tLRSStreamCloseChan: testutils.NewChannel(),\n\t\tNewConnChan:        testutils.NewChannel(),\n\t\tAddress:            addr,\n\t\txdsServerV3:        &xdsServerV3{},\n\t\tlrsServerV3:        &lrsServerV3{},\n\t}\n}\n\nfunc (s *Server) StartServer(lis net.Listener) (*Server, func(), error) {\n\tgrpcServer := grpc.NewServer()\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(grpcServer, s)\n\tv3lrsgrpc.RegisterLoadReportingServiceServer(grpcServer, s)\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tcleanup := func() {\n\t\tgrpcServer.GracefulStop()\n\t}\n\n\treturn s, cleanup, nil\n}\n\nfunc (s *Server) StreamAggregatedResources(stream v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\ts.NewConnChan.Send(nil)\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.XDSRequestChan.Send(req)\n\t\tresp := <-s.XDSResponseChan\n\t\tif err := stream.Send(resp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *Server) StreamLoadStats(stream v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\ts.LRSStreamOpenChan.Send(nil)\n\tdefer s.LRSStreamCloseChan.Send(nil)\n\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.LRSRequestChan.Send(req)\n\t\tresp := <-s.LRSResponseChan\n\t\tif err := stream.Send(resp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc main() {\n\taddr := \":50051\"\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tserver := NewServer(addr)\n\t_, cleanup, err := server.StartServer(lis)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer cleanup()\n\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and handles gRPC communications.\n\nFunction Description: The main function sets up a gRPC server that listens on port 50051, registers the gRPC service implementation, and starts serving requests. It includes error handling for server setup and operation.\n\nInput: None (The function takes no explicit parameters but uses a hardcoded port \":50051\" for listening)\n\nOutput: None (The function doesn't return anything but will log fatal errors if the server fails to start or serve)\n\nNote: The actual gRPC service implementation (greeter struct) is not shown in the reference code but would need to be defined separately to implement the proto.GreeterServer interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"grpc-hello/proto\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\treflection.Register(server)\n\tproto.RegisterGreeterServer(server, &greeter{})\n\n\tfmt.Println(\"grpc server start ...\")\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype greeterServer struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &greeterServer{})\n\n\tlog.Println(\"gRPC server listening on port 50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Create a gRPC server for chaincode communication in a Hyperledger Fabric network, supporting both secure (TLS) and insecure connections, with the ability to handle chaincode registration and message echoing.\n\nStruct Description: ccSrv represents a chaincode gRPC server that listens for incoming connections, handles chaincode registration, and echoes received messages back to the client.\n\nFields:\nl: net.Listener - The network listener for incoming connections\ngrpcSrv: *grpc.Server - The gRPC server instance\nt: *testing.T - Testing context for assertions\nexpectedCCname: string - The expected chaincode name for validation during registration\n\nMethods:\nRegister: (stream pb.ChaincodeSupport_RegisterServer) -> error - Handles the chaincode registration stream, validates the chaincode name, and echoes messages back to the client\nstop: () -> () - Stops the gRPC server and closes the listener\nnewCCServer: (t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) -> *ccSrv - Creates and configures a new chaincode server instance with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\tpb \"github.com/hyperledger/fabric-protos-go-apiv2/peer\"\n\t\"github.com/hyperledger/fabric/common/crypto/tlsgen\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (cs *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tmsg, err := stream.Recv()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequire.Equal(cs.t, pb.ChaincodeMessage_REGISTER.String(), msg.Type.String())\n\tchaincodeID := &pb.ChaincodeID{}\n\terr = proto.Unmarshal(msg.Payload, chaincodeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequire.Equal(cs.t, cs.expectedCCname, chaincodeID.Name)\n\tfor {\n\t\tmsg, _ = stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = stream.Send(msg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (cs *ccSrv) stop() {\n\tcs.grpcSrv.Stop()\n\tcs.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar s *grpc.Server\n\tif withTLS {\n\t\tkeyPair, err := ca.NewServerCertKeyPair(\"localhost\")\n\t\trequire.NoError(t, err)\n\t\tcert, err := tls.X509KeyPair(keyPair.Cert, keyPair.Key)\n\t\trequire.NoError(t, err)\n\t\ttlsConf := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tClientCAs:    x509.NewCertPool(),\n\t\t}\n\t\ttlsConf.ClientCAs.AppendCertsFromPEM(ca.CertBytes())\n\t\ts = grpc.NewServer(grpc.Creds(credentials.NewTLS(tlsConf)))\n\t} else {\n\t\ts = grpc.NewServer()\n\t}\n\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", \"\", port))\n\trequire.NoError(t, err, \"%v\", err)\n\treturn &ccSrv{\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t\tl:              l,\n\t\tgrpcSrv:        s,\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/chaincode/proto\"\n\t\"github.com/hyperledger/fabric/core/comm\"\n\t\"github.com/hyperledger/fabric/core/comm/tlsgen\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (s *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tfor {\n\t\tin, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif in.ChaincodeName != s.expectedCCname {\n\t\t\treturn fmt.Errorf(\"unexpected chaincode name: %s\", in.ChaincodeName)\n\t\t}\n\t\tif err := stream.Send(in); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *ccSrv) stop() {\n\ts.grpcSrv.Stop()\n\ts.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar opts []grpc.ServerOption\n\tif withTLS {\n\t\tcertKeyPair, err := ca.NewServerCertKeyPair(\"localhost\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create server cert/key pair: %s\", err)\n\t\t}\n\t\tcreds := credentials.NewTLS(&tls.Config{\n\t\t\tCertificates: []tls.Certificate{certKeyPair.TLSCert},\n\t\t})\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgrpcSrv := grpc.NewServer(opts...)\n\tsrv := &ccSrv{\n\t\tl:              lis,\n\t\tgrpcSrv:        grpcSrv,\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t}\n\n\tpb.RegisterChaincodeSupportServer(grpcSrv, srv)\n\tgo grpcSrv.Serve(lis)\n\n\treturn srv\n}\n\nfunc main() {\n\t// Example usage\n\tt := &testing.T{}\n\tca, err := tlsgen.NewCA()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create CA: %s\", err)\n\t}\n\tserver := newCCServer(t, 7052, \"myChaincode\", true, ca)\n\tdefer server.stop()\n\n\t// The server is now running and can be tested with a gRPC client\n}\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and registers a service to handle those requests.\n\nFunction Description: The function sets up a gRPC server that listens on a given TCP port, creates a new gRPC server instance, registers a service to handle incoming requests, and starts the server in a goroutine. The server runs until it is stopped or encounters an error.\n\nInput: None (The port is hardcoded as \":50052\" in the example, but could be parameterized)\n\nOutput: None (The function runs indefinitely until stopped or an error occurs, with side effects of starting the gRPC server)\n\nNote: The actual service implementation (ChannelzService) would need to be defined elsewhere and imported. The example shows the server setup pattern but assumes the service is already implemented.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tdefer lis.Close()\n\ts := grpc.NewServer()\n\tservice.RegisterChannelzServiceToServer(s)\n\tgo s.Serve(lis)\n\tdefer s.Stop()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc startGRPCServer() {\n\tlistener, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on port 50052: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\n\t// Assuming ChannelzService is implemented and imported\n\t// channelz.RegisterChannelzServiceServer(grpcServer, &ChannelzService{})\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\tlog.Fatalf(\"Failed to serve gRPC server: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc main() {\n\tstartGRPCServer()\n\tselect {} // Block forever\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles greeting requests and responses.\n\nStruct Description: The server struct implements the GreeterServer interface generated from the protobuf definition, providing the SayHello method to handle incoming gRPC requests.\n\nFields:\nUnimplementedGreeterServer: pb.UnimplementedGreeterServer - Embedded type to ensure forward compatibility with future gRPC updates\n\nMethods:\nSayHello: [Name](ctx context.Context, in *pb.HelloRequest) -> (*pb.HelloReply, error) - Processes incoming HelloRequest, logs the received name, and returns a HelloReply with a greeting message",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Println(\"Server is running on port 50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The function `Run` initializes and starts a gRPC server with the provided network options. It sets up a network listener, creates a gRPC server instance, registers a key service, and handles graceful shutdown upon receiving interrupt or termination signals.\n\nInput: \n- `opts` [struct] - Configuration options for the server, containing:\n  - `Network` [string] - The network type (e.g., \"tcp\")\n  - `Address` [string] - The address to listen on (e.g., \":50051\")\n  - `Prompt` [interface{}] - Optional prompt for the key service\n\nOutput: \n- `error` - Returns an error if the server fails to start or encounters issues during execution",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/getsops/sops/v3/keyservice\"\n\t\"google.golang.org/grpc\"\n)\nfunc Run(opts Opts) error {\n\tlis, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer lis.Close()\n\tgrpcServer := grpc.NewServer()\n\tkeyservice.RegisterKeyServiceServer(grpcServer, keyservice.Server{\n\t\tPrompt: opts.Prompt,\n\t})\n\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, os.Interrupt, os.Kill, syscall.SIGTERM)\n\tgo func(c chan os.Signal) {\n\t\tsig := <-c\n\t\tlis.Close()\n\t\tos.Exit(0)\n\t}(sigc)\n\treturn grpcServer.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype ServerOptions struct {\n\tNetwork string\n\tAddress string\n\tPrompt  interface{}\n}\n\ntype keyServiceServer struct{}\n\nfunc (s *keyServiceServer) SomeRPCMethod(ctx context.Context, req *SomeRequest) (*SomeResponse, error) {\n\t// Implement your RPC method logic here\n\treturn &SomeResponse{}, nil\n}\n\nfunc Run(opts ServerOptions) error {\n\tlistener, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\tRegisterKeyServiceServer(grpcServer, &keyServiceServer{})\n\n\t// Channel to listen for interrupt or termination signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-sigChan\n\t\tgrpcServer.GracefulStop()\n\t}()\n\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\treturn errors.New(\"failed to serve: \" + err.Error())\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\topts := ServerOptions{\n\t\tNetwork: \"tcp\",\n\t\tAddress: \":50051\",\n\t}\n\n\tif err := Run(opts); err != nil {\n\t\t// Handle error\n\t}\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Go struct that implements a mock gRPC server proxy for testing purposes, with start and stop functionality.\n\nStruct Description: The ProxyGRPCMock struct provides a mock implementation of a gRPC server that can be started and stopped programmatically. It allows for custom gRPC service implementations and registration routines to be injected for testing purposes.\n\nFields:\n- GRPCImplementer: [interface{}] - The implementation of the gRPC service handler\n- GRPCRegister: [func(s *grpc.Server, srv interface{})] - The function to register the gRPC service implementation with the server\n- listener: [net.Listener] - The network listener for the gRPC server\n\nMethods:\n- Start: [func(URL string) error] -> [error] - Starts the gRPC server on the specified URL (format \"scheme://path\"). Returns error if initialization fails.\n- Stop: [func() error] -> [error] - Stops the gRPC server by closing the listener. Returns error if no listener exists or closing fails.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"google.golang.org/grpc\"\n)\n\ntype ProxyGRPCMock struct {\n\tGRPCImplementer interface{}\n\tGRPCRegister func(s *grpc.Server, srv interface{})\n\tlistener net.Listener\n}\n\nfunc (p *ProxyGRPCMock) Start(URL string) error {\n\tif p.GRPCImplementer == nil {\n\t\treturn fmt.Errorf(\"Missing gRPC handler\")\n\t}\n\n\tif p.GRPCRegister == nil {\n\t\treturn fmt.Errorf(\"Missing gRPC registration routine\")\n\t}\n\n\turl, err := url.Parse(URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tl, err := net.Listen(url.Scheme, url.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.listener = l\n\n\tgrpcServer := grpc.NewServer()\n\tp.GRPCRegister(grpcServer, p.GRPCImplementer)\n\n\tgo func() {\n\t\tgrpcServer.Serve(l)\n\t}()\n\n\treturn nil\n}\n\nfunc (p *ProxyGRPCMock) Stop() error {\n\tif p.listener == nil {\n\t\treturn fmt.Errorf(\"Missing proxy listener\")\n\t}\n\n\treturn p.listener.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype ProxyGRPCMock struct {\n\tGRPCImplementer interface{}\n\tGRPCRegister    func(s *grpc.Server, srv interface{})\n\tlistener        net.Listener\n\tserver          *grpc.Server\n}\n\nfunc (p *ProxyGRPCMock) Start(URL string) error {\n\tvar err error\n\tp.listener, err = net.Listen(\"tcp\", URL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on %s: %v\", URL, err)\n\t}\n\n\tp.server = grpc.NewServer()\n\tp.GRPCRegister(p.server, p.GRPCImplementer)\n\n\tgo func() {\n\t\tif err := p.server.Serve(p.listener); err != nil {\n\t\t\tfmt.Printf(\"failed to serve: %v\\n\", err)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (p *ProxyGRPCMock) Stop() error {\n\tif p.listener == nil {\n\t\treturn fmt.Errorf(\"no listener to close\")\n\t}\n\tp.server.GracefulStop()\n\terr := p.listener.Close()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close listener: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage\n\tmock := &ProxyGRPCMock{\n\t\tGRPCImplementer: nil, // Replace with actual gRPC service implementation\n\t\tGRPCRegister:    func(s *grpc.Server, srv interface{}) {}, // Replace with actual registration function\n\t}\n\n\terr := mock.Start(\":50051\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error starting server: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Perform tests...\n\n\terr = mock.Stop()\n\tif err != nil {\n\t\tfmt.Printf(\"Error stopping server: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Implement a gRPC server in Go that can handle incoming requests with configurable message size limits, TLS support, and OpenTracing integration.\n\nStruct Description: The Server struct represents a gRPC server instance with configurable settings for buffer size and server options.\n\nFields:\ngrpcServer: *grpc.Server - The underlying gRPC server instance\nbufferSize: int - The buffer size for server operations (currently unused in reference code)\n\nMethods:\nNewServer: () -> *Server - Creates and returns a new Server instance with default values\n\nStart: (url *common.URL) -> () - Starts the gRPC server with the specified URL configuration. Handles:\n  - Network listener setup\n  - Message size configuration\n  - TLS setup if configured\n  - OpenTracing integration\n  - Service registration\n  - Server reflection\n\nStop: () -> () - Immediately stops the gRPC server\n\nGracefulStop: () -> () - Gracefully stops the gRPC server, allowing existing RPCs to complete",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nimport (\n\t\"github.com/dubbogo/gost/log/logger\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nimport (\n\t\"dubbo.apache.org/dubbo-go/v3/common\"\n\t\"dubbo.apache.org/dubbo-go/v3/common/constant\"\n\t\"dubbo.apache.org/dubbo-go/v3/config\"\n\t\"dubbo.apache.org/dubbo-go/v3/protocol\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n\tbufferSize int\n}\n\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\nfunc (s *Server) Start(url *common.URL) {\n\tvar (\n\t\taddr string\n\t\terr  error\n\t)\n\taddr = url.Location\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmaxServerRecvMsgSize := constant.DefaultMaxServerRecvMsgSize\n\tif recvMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerRecvMsgSize, \"\")); convertErr == nil && recvMsgSize != 0 {\n\t\tmaxServerRecvMsgSize = int(recvMsgSize)\n\t}\n\tmaxServerSendMsgSize := constant.DefaultMaxServerSendMsgSize\n\tif sendMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerSendMsgSize, \"\")); err == convertErr && sendMsgSize != 0 {\n\t\tmaxServerSendMsgSize = int(sendMsgSize)\n\t}\n\n\ttracer := opentracing.GlobalTracer()\n\tvar serverOpts []grpc.ServerOption\n\tserverOpts = append(serverOpts,\n\t\tgrpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer)),\n\t\tgrpc.StreamInterceptor(otgrpc.OpenTracingStreamServerInterceptor(tracer)),\n\t\tgrpc.MaxRecvMsgSize(maxServerRecvMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxServerSendMsgSize),\n\t)\n\n\ttlsConfig := config.GetRootConfig().TLSConfig\n\tif tlsConfig != nil {\n\t\tvar cfg *tls.Config\n\t\tcfg, err = config.GetServerTlsConfig(&config.TLSConfig{\n\t\t\tCACertFile:    tlsConfig.CACertFile,\n\t\t\tTLSCertFile:   tlsConfig.TLSCertFile,\n\t\t\tTLSKeyFile:    tlsConfig.TLSKeyFile,\n\t\t\tTLSServerName: tlsConfig.TLSServerName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Grpc Server initialized the TLSConfig configuration\")\n\t\tserverOpts = append(serverOpts, grpc.Creds(credentials.NewTLS(cfg)))\n\t} else {\n\t\tserverOpts = append(serverOpts, grpc.Creds(insecure.NewCredentials()))\n\t}\n\tserver := grpc.NewServer(serverOpts...)\n\ts.grpcServer = server\n\n\tgo func() {\n\t\tproviderServices := config.GetProviderConfig().Services\n\n\t\tif len(providerServices) == 0 {\n\t\t\tpanic(\"provider service map is null\")\n\t\t}\n\t\twaitGrpcExporter(providerServices)\n\t\tregisterService(providerServices, server)\n\t\treflection.Register(server)\n\n\t\tif err = server.Serve(lis); err != nil {\n\t\t\tlogger.Errorf(\"server serve failed with err: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Stop() {\n\ts.grpcServer.Stop()\n}\n\nfunc (s *Server) GracefulStop() {\n\ts.grpcServer.GracefulStop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/opentracing/opentracing-go/ext\"\n\t\"github.com/opentracing/opentracing-go/log\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n\tbufferSize int\n}\n\nfunc NewServer() *Server {\n\treturn &Server{\n\t\tbufferSize: 1024 * 1024, // Default buffer size\n\t}\n}\n\nfunc (s *Server) Start(url *common.URL) {\n\tlistener, err := net.Listen(\"tcp\", url.Host)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar opts []grpc.ServerOption\n\n\t// Message size configuration\n\topts = append(opts, grpc.MaxRecvMsgSize(s.bufferSize), grpc.MaxSendMsgSize(s.bufferSize))\n\n\t// TLS setup\n\tif url.TLSConfig != nil {\n\t\tcreds := credentials.NewTLS(url.TLSConfig)\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\t// OpenTracing integration\n\ttracer := opentracing.GlobalTracer()\n\topts = append(opts, grpc.UnaryInterceptor(s.tracingInterceptor(tracer)))\n\n\ts.grpcServer = grpc.NewServer(opts...)\n\n\t// Service registration\n\t// Register your services here\n\n\t// Server reflection\n\treflection.Register(s.grpcServer)\n\n\tif err := s.grpcServer.Serve(listener); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (s *Server) Stop() {\n\ts.grpcServer.Stop()\n}\n\nfunc (s *Server) GracefulStop() {\n\ts.grpcServer.GracefulStop()\n}\n\nfunc (s *Server) tracingInterceptor(tracer opentracing.Tracer) grpc.UnaryServerInterceptor {\n\treturn func(\n\t\tctx context.Context,\n\t\treq interface{},\n\t\tinfo *grpc.UnaryServerInfo,\n\t\thandler grpc.UnaryHandler,\n\t) (interface{}, error) {\n\t\tspanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier{})\n\t\tspan := tracer.StartSpan(info.FullMethod, ext.RPCServerOption(spanCtx))\n\t\tdefer span.Finish()\n\n\t\tspan.LogFields(log.String(\"event\", \"server request\"), log.String(\"value\", info.FullMethod))\n\n\t\tresp, err := handler(ctx, req)\n\t\tif err != nil {\n\t\t\text.LogError(span, err)\n\t\t}\n\t\treturn resp, err\n\t}\n}\n\ntype common struct {\n\tURL struct {\n\t\tHost      string\n\t\tTLSConfig *tls.Config\n\t}\n}\n\nfunc main() {\n\tserver := NewServer()\n\turl := &common.URL{\n\t\tHost: \"localhost:50051\",\n\t}\n\tserver.Start(url)\n\tdefer server.GracefulStop()\n\n\t// Simulate server running\n\ttime.Sleep(10 * time.Second)\n}\n```"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles various WebSocket operations including checking user online status, sending messages to users, broadcasting messages to all users, and retrieving user lists.\n\nStruct Description: The `server` struct implements the gRPC service interface defined in the protobuf file, providing concrete implementations for WebSocket operations.\n\nFields:\n- UnimplementedAccServerServer: [protobuf.UnimplementedAccServerServer] - Embedded type to ensure forward compatibility with gRPC service updates\n\nMethods:\n- QueryUsersOnline: [Name](ctx context.Context, req *protobuf.QueryUsersOnlineReq) -> (*protobuf.QueryUsersOnlineRsp, error) - Checks if a specified user is currently online\n- SendMsg: [Name](ctx context.Context, req *protobuf.SendMsgReq) -> (*protobuf.SendMsgRsp, error) - Sends a message to a specific user\n- SendMsgAll: [Name](ctx context.Context, req *protobuf.SendMsgAllReq) -> (*protobuf.SendMsgAllRsp, error) - Broadcasts a message to all connected users\n- GetUserList: [Name](ctx context.Context, req *protobuf.GetUserListReq) -> (*protobuf.GetUserListRsp, error) - Retrieves the list of currently connected users\n- Init: [Name]() -> () - Initializes and starts the gRPC server with configuration from Viper",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/link1st/gowebsocket/v2/common\"\n\t\"github.com/link1st/gowebsocket/v2/models\"\n\t\"github.com/link1st/gowebsocket/v2/protobuf\"\n\t\"github.com/link1st/gowebsocket/v2/servers/websocket\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedAccServerServer\n}\n\nfunc (s *server) QueryUsersOnline(c context.Context, req *protobuf.QueryUsersOnlineReq) (rsp *protobuf.QueryUsersOnlineRsp, err error) {\n\trsp = &protobuf.QueryUsersOnlineRsp{}\n\tonline := websocket.CheckUserOnline(req.GetAppID(), req.GetUserID())\n\tsetErr(req, common.OK, \"\")\n\trsp.Online = online\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsg(c context.Context, req *protobuf.SendMsgReq) (rsp *protobuf.SendMsgRsp, err error) {\n\trsp = &protobuf.SendMsgRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\tsendResults, err := websocket.SendUserMessageLocal(req.GetAppID(), req.GetUserID(), data)\n\tif err != nil {\n\t\tsetErr(rsp, common.ServerError, \"\")\n\t\treturn rsp, nil\n\t}\n\tif !sendResults {\n\t\tsetErr(rsp, common.OperationFailure, \"\")\n\t\treturn rsp, nil\n\t}\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsgAll(c context.Context, req *protobuf.SendMsgAllReq) (rsp *protobuf.SendMsgAllRsp, err error) {\n\trsp = &protobuf.SendMsgAllRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\twebsocket.AllSendMessages(req.GetAppID(), req.GetUserID(), data)\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) GetUserList(c context.Context, req *protobuf.GetUserListReq) (rsp *protobuf.GetUserListRsp, err error) {\n\trsp = &protobuf.GetUserListRsp{}\n\tuserList := websocket.GetUserList(req.GetAppID())\n\tsetErr(rsp, common.OK, \"\")\n\trsp.UserID = userList\n\treturn rsp, nil\n}\n\nfunc Init() {\n\trpcPort := viper.GetString(\"app.rpcPort\")\n\tlis, err := net.Listen(\"tcp\", \":\"+rpcPort)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tprotobuf.RegisterAccServerServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/spf13/viper\"\n\t\"your_project/protobuf\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedAccServerServer\n\t// Add any additional fields if necessary\n}\n\nfunc (s *server) QueryUsersOnline(ctx context.Context, req *protobuf.QueryUsersOnlineReq) (*protobuf.QueryUsersOnlineRsp, error) {\n\t// Implement logic to check if the user is online\n\t// Return appropriate response\n\treturn &protobuf.QueryUsersOnlineRsp{IsOnline: true}, nil\n}\n\nfunc (s *server) SendMsg(ctx context.Context, req *protobuf.SendMsgReq) (*protobuf.SendMsgRsp, error) {\n\t// Implement logic to send a message to a specific user\n\t// Return appropriate response\n\treturn &protobuf.SendMsgRsp{Success: true}, nil\n}\n\nfunc (s *server) SendMsgAll(ctx context.Context, req *protobuf.SendMsgAllReq) (*protobuf.SendMsgAllRsp, error) {\n\t// Implement logic to broadcast a message to all users\n\t// Return appropriate response\n\treturn &protobuf.SendMsgAllRsp{Success: true}, nil\n}\n\nfunc (s *server) GetUserList(ctx context.Context, req *protobuf.GetUserListReq) (*protobuf.GetUserListRsp, error) {\n\t// Implement logic to retrieve the list of connected users\n\t// Return appropriate response\n\treturn &protobuf.GetUserListRsp{Users: []string{\"user1\", \"user2\"}}, nil\n}\n\nfunc (s *server) Init() {\n\tviper.SetConfigName(\"config\")\n\tviper.AddConfigPath(\".\")\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading config file, %s\", err)\n\t}\n\n\tport := viper.GetString(\"server.port\")\n\tlis, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\tprotobuf.RegisterAccServerServer(grpcServer, &server{})\n\treflection.Register(grpcServer)\n\n\tlog.Printf(\"Server is running on port %s\", port)\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n\nfunc main() {\n\ts := &server{}\n\ts.Init()\n}\n```"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server to handle incoming requests on a specified network address.\n\nFunction Description: The function `startServer` sets up a gRPC server that listens on the provided TCP address. It creates a new gRPC server instance, registers the Echo service implementation, and begins serving requests. If any step fails, it logs the error and terminates the program.\n\nInput: \n- `addr` [string] - The network address (including port) on which the gRPC server should listen (e.g., \"localhost:50051\").\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error).",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc startServer(addr string) {\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterEchoServer(s, &ecServer{addr: addr})\n\tlog.Printf(\"serving on %s\\n\", addr)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype echoServer struct {\n\tpb.UnimplementedEchoServiceServer\n}\n\nfunc (s *echoServer) Echo(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.Message}, nil\n}\n\nfunc startServer(addr string) {\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on %s: %v\", addr, err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterEchoServiceServer(grpcServer, &echoServer{})\n\n\tlog.Printf(\"Starting gRPC server on %s\", addr)\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve gRPC server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Create a mock CSI (Container Storage Interface) provider server in Go that implements the gRPC interface for a secrets store CSI driver. This server should be able to simulate both successful and error responses for testing purposes.\n\nStruct Description: The MockCSIProviderServer struct represents a mock implementation of a CSI provider server that communicates via gRPC over a Unix domain socket. It allows configuration of mock responses and error conditions for testing the CSI driver integration.\n\nFields:\n- grpcServer: *grpc.Server - The gRPC server instance\n- listener: net.Listener - The network listener for the gRPC server\n- socketPath: string - The filesystem path for the Unix domain socket\n- returnErr: error - An error to return for simulated error conditions\n- errorCode: string - The error code to include in responses\n- objects: []*v1alpha1.ObjectVersion - Mock object versions to return\n- files: []*v1alpha1.File - Mock files to return\n\nMethods:\n- NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) - Creates a new mock server instance with the given socket path\n- SetReturnError(err error) - Sets an error to be returned by the mock server\n- SetObjects(objects map[string]string) - Configures mock object versions to return\n- SetFiles(files []*v1alpha1.File) - Configures mock files to return\n- SetProviderErrorCode(errorCode string) - Sets the error code for responses\n- Start() error - Starts the gRPC server listening on the configured socket\n- Stop() - Gracefully stops the gRPC server\n- Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) - Implements the Mount gRPC method\n- Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) - Implements the Version gRPC method",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"sigs.k8s.io/secrets-store-csi-driver/provider/v1alpha1\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype MockCSIProviderServer struct {\n\tgrpcServer *grpc.Server\n\tlistener   net.Listener\n\tsocketPath string\n\treturnErr  error\n\terrorCode  string\n\tobjects    []*v1alpha1.ObjectVersion\n\tfiles      []*v1alpha1.File\n}\n\nfunc NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) {\n\tserver := grpc.NewServer()\n\ts := &MockCSIProviderServer{\n\t\tgrpcServer: server,\n\t\tsocketPath: socketPath,\n\t}\n\tv1alpha1.RegisterCSIDriverProviderServer(server, s)\n\treturn s, nil\n}\n\nfunc (m *MockCSIProviderServer) SetReturnError(err error) {\n\tm.returnErr = err\n}\n\nfunc (m *MockCSIProviderServer) SetObjects(objects map[string]string) {\n\tvar ov []*v1alpha1.ObjectVersion\n\tfor k, v := range objects {\n\t\tov = append(ov, &v1alpha1.ObjectVersion{Id: k, Version: v})\n\t}\n\tm.objects = ov\n}\n\nfunc (m *MockCSIProviderServer) SetFiles(files []*v1alpha1.File) {\n\tvar ov []*v1alpha1.File\n\tfor _, v := range files {\n\t\tov = append(ov, &v1alpha1.File{\n\t\t\tPath:     v.Path,\n\t\t\tMode:     v.Mode,\n\t\t\tContents: v.Contents,\n\t\t})\n\t}\n\tm.files = ov\n}\n\nfunc (m *MockCSIProviderServer) SetProviderErrorCode(errorCode string) {\n\tm.errorCode = errorCode\n}\n\nfunc (m *MockCSIProviderServer) Start() error {\n\tvar err error\n\tm.listener, err = net.Listen(\"unix\", m.socketPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err = m.grpcServer.Serve(m.listener); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (m *MockCSIProviderServer) Stop() {\n\tm.grpcServer.GracefulStop()\n}\n\nfunc (m *MockCSIProviderServer) Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) {\n\tvar attrib, secret map[string]string\n\tvar filePermission os.FileMode\n\tvar err error\n\n\tif m.returnErr != nil {\n\t\treturn &v1alpha1.MountResponse{}, m.returnErr\n\t}\n\tif err = json.Unmarshal([]byte(req.GetAttributes()), &attrib); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal attributes, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetSecrets()), &secret); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal secrets, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetPermission()), &filePermission); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal file permission, error: %w\", err)\n\t}\n\treturn &v1alpha1.MountResponse{\n\t\tObjectVersion: m.objects,\n\t\tError: &v1alpha1.Error{\n\t\t\tCode: m.errorCode,\n\t\t},\n\t\tFiles: m.files,\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) {\n\treturn &v1alpha1.VersionResponse{\n\t\tVersion:        \"v1alpha1\",\n\t\tRuntimeName:    \"fakeprovider\",\n\t\tRuntimeVersion: \"0.0.10\",\n\t}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\tv1alpha1 \"github.com/kubernetes-sigs/secrets-store-csi-driver/provider/v1alpha1\"\n)\n\ntype MockCSIProviderServer struct {\n\tgrpcServer *grpc.Server\n\tlistener   net.Listener\n\tsocketPath string\n\treturnErr  error\n\terrorCode  string\n\tobjects    []*v1alpha1.ObjectVersion\n\tfiles      []*v1alpha1.File\n}\n\nfunc NewMockCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) {\n\tlistener, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgrpcServer := grpc.NewServer()\n\tserver := &MockCSIProviderServer{\n\t\tgrpcServer: grpcServer,\n\t\tlistener:   listener,\n\t\tsocketPath: socketPath,\n\t}\n\tv1alpha1.RegisterSecretsStoreProviderServer(grpcServer, server)\n\treturn server, nil\n}\n\nfunc (s *MockCSIProviderServer) SetReturnError(err error) {\n\ts.returnErr = err\n}\n\nfunc (s *MockCSIProviderServer) SetObjects(objects map[string]string) {\n\tvar objectVersions []*v1alpha1.ObjectVersion\n\tfor id, version := range objects {\n\t\tobjectVersions = append(objectVersions, &v1alpha1.ObjectVersion{Id: id, Version: version})\n\t}\n\ts.objects = objectVersions\n}\n\nfunc (s *MockCSIProviderServer) SetFiles(files []*v1alpha1.File) {\n\ts.files = files\n}\n\nfunc (s *MockCSIProviderServer) SetProviderErrorCode(errorCode string) {\n\ts.errorCode = errorCode\n}\n\nfunc (s *MockCSIProviderServer) Start() error {\n\treturn s.grpcServer.Serve(s.listener)\n}\n\nfunc (s *MockCSIProviderServer) Stop() {\n\ts.grpcServer.GracefulStop()\n\tos.Remove(s.socketPath)\n}\n\nfunc (s *MockCSIProviderServer) Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) {\n\tif s.returnErr != nil {\n\t\treturn nil, s.returnErr\n\t}\n\treturn &v1alpha1.MountResponse{\n\t\tObjectVersions: s.objects,\n\t\tFiles:          s.files,\n\t\tError:          s.errorCode,\n\t}, nil\n}\n\nfunc (s *MockCSIProviderServer) Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) {\n\tif s.returnErr != nil {\n\t\treturn nil, s.returnErr\n\t}\n\treturn &v1alpha1.VersionResponse{\n\t\tVersion: \"mock-version\",\n\t}, nil\n}\n\nfunc main() {\n\tsocketPath := \"/tmp/mockcsi.sock\"\n\tserver, err := NewMockCSIProviderServer(socketPath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer server.Stop()\n\n\tif err := server.Start(); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a gRPC server in Go that handles authentication services, connects to Redis for data storage, and exposes Prometheus metrics for monitoring.\n\nStruct Description: The authHandler struct implements the AuthServiceServer interface and provides authentication functionality using Redis as the backend storage.\n\nFields:\nredisClient: *redis.Client - The Redis client used for data storage and retrieval\n\nMethods:\nServe: (listener net.Listener) -> error - Starts the gRPC server and begins listening for incoming requests\nRegisterWithPrometheus: () -> error - Registers gRPC and custom metrics with Prometheus\nStartMetricsServer: () -> error - Starts an HTTP server for Prometheus metrics collection\n\nNote: The struct implements all required gRPC service methods defined in the auth.proto file, though these are not shown in the reference code. The main functionality includes:\n1. Setting up a gRPC server with Prometheus monitoring\n2. Establishing Redis connection\n3. Combining gRPC and HTTP servers for both RPC calls and metrics collection\n4. Proper error handling and logging throughout the process",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/go-redis/redis\"\n\t\"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/lucperkins/colossus/proto/auth\"\n)\nfunc main() {\n\tlog.Printf(\"Starting up the gRPC auth server on localhost:%d\", PORT)\n\n\tlog.Print(\"Attempting to connect to Redis\")\n\n\tredisClient := redis.NewClient(&redis.Options{\n\t\tAddr: \"colossus-redis-cluster:6379\",\n\t})\n\n\t_, err := redisClient.Ping().Result()\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis cluster: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully connected to Redis\")\n\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", PORT))\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully created TCP listener\")\n\n\tserver := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),\n\t)\n\n\tauthServer := authHandler{\n\t\tredisClient: redisClient,\n\t}\n\n\thttpServer := &http.Server{\n\t\tHandler: promhttp.HandlerFor(metricsRegistry, promhttp.HandlerOpts{}),\n\t\tAddr:    fmt.Sprintf(\"0.0.0.0:%d\", PROMETHEUS_PORT),\n\t}\n\n\tauth.RegisterAuthServiceServer(server, &authServer)\n\n\tgrpcMetrics.InitializeMetrics(server)\n\n\tmetricsRegistry.MustRegister(grpcMetrics, authCounter, failCounter)\n\n\tlog.Print(\"Successfully registered with Prometheus\")\n\n\tgo func() {\n\t\tlog.Print(\"Starting up HTTP server for Prometheus metrics collection\")\n\n\t\tif err := httpServer.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"Unable to start HTTP server for Prometheus metrics: %v\", err)\n\t\t}\n\t}()\n\n\tlog.Fatal(server.Serve(listener))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\tpb \"path/to/your/proto\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\ntype authHandler struct {\n\tredisClient *redis.Client\n\tpb.UnimplementedAuthServiceServer\n}\n\nfunc (a *authHandler) Serve(listener net.Listener) error {\n\tserver := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),\n\t\tgrpc.StreamInterceptor(grpc_prometheus.StreamServerInterceptor),\n\t)\n\tpb.RegisterAuthServiceServer(server, a)\n\tgrpc_prometheus.Register(server)\n\treflection.Register(server)\n\n\tlog.Println(\"Starting gRPC server...\")\n\treturn server.Serve(listener)\n}\n\nfunc (a *authHandler) RegisterWithPrometheus() error {\n\tgrpc_prometheus.EnableHandlingTimeHistogram()\n\treturn nil\n}\n\nfunc (a *authHandler) StartMetricsServer() error {\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\tlog.Println(\"Starting metrics server on :9090\")\n\treturn http.ListenAndServe(\":9090\", nil)\n}\n\nfunc newRedisClient() *redis.Client {\n\treturn redis.NewClient(&redis.Options{\n\t\tAddr: \"localhost:6379\",\n\t})\n}\n\nfunc main() {\n\tredisClient := newRedisClient()\n\tdefer redisClient.Close()\n\n\thandler := &authHandler{redisClient: redisClient}\n\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := handler.StartMetricsServer(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to start metrics server: %v\", err)\n\t\t}\n\t}()\n\n\tif err := handler.RegisterWithPrometheus(); err != nil {\n\t\tlog.Fatalf(\"Failed to register with Prometheus: %v\", err)\n\t}\n\n\tif err := handler.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Implement a gRPC server in Go that collects and manages execution statistics for tasks in a distributed system.\n\nStruct Description: The Executor struct represents a gRPC server that handles execution statistics collection and management. It maintains a list of execution stats and provides methods to serve gRPC requests and process incoming statistics.\n\nFields:\nstats: []*pb.ExecutionStat - A slice of pointers to ExecutionStat protobuf messages, storing the collected execution statistics.\n\nMethods:\nserveGrpc: (listener net.Listener) -> () - Starts a gRPC server on the given listener, registering the Executor as a GleamExecutorServer implementation.\nCollectExecutionStatistics: (stream pb.GleamExecutor_CollectExecutionStatisticsServer) -> error - Processes a stream of execution statistics, updating the internal stats collection when matching task IDs are found. Returns nil on successful completion or an error if stream processing fails.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/chrislusf/gleam/pb\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Executor struct {\n\tstats []*pb.ExecutionStat\n}\n\nfunc (exe *Executor) serveGrpc(listener net.Listener) {\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterGleamExecutorServer(grpcServer, exe)\n\tgrpcServer.Serve(listener)\n}\n\nfunc (exe *Executor) CollectExecutionStatistics(stream pb.GleamExecutor_CollectExecutionStatisticsServer) error {\n\tfor {\n\t\tstats, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, stat := range stats.Stats {\n\t\t\tfor i, current := range exe.stats {\n\t\t\t\tif current.StepId == stat.StepId && current.TaskId == stat.TaskId {\n\t\t\t\t\texe.stats[i] = stat\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protobuf/package\"\n)\n\ntype Executor struct {\n\tstats []*pb.ExecutionStat\n}\n\nfunc (e *Executor) serveGrpc(listener net.Listener) {\n\tserver := grpc.NewServer()\n\tpb.RegisterGleamExecutorServer(server, e)\n\tif err := server.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n\nfunc (e *Executor) CollectExecutionStatistics(stream pb.GleamExecutor_CollectExecutionStatisticsServer) error {\n\tfor {\n\t\tstat, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == grpc.ErrClientConnClosing {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\te.updateStats(stat)\n\t}\n}\n\nfunc (e *Executor) updateStats(stat *pb.ExecutionStat) {\n\tfor _, existingStat := range e.stats {\n\t\tif existingStat.TaskId == stat.TaskId {\n\t\t\t// Update existing statistics\n\t\t\texistingStat = stat\n\t\t\treturn\n\t\t}\n\t}\n\t// Add new statistics\n\te.stats = append(e.stats, stat)\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\texecutor := &Executor{}\n\texecutor.serveGrpc(listener)\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a function that sets up and starts a gRPC server with reflection capabilities, registering multiple services and handling incoming requests.\n\nFunction Description: The Serve function initializes a gRPC server on a specified TCP port, registers multiple service implementations (RouteGuide and Foobar), enables server reflection for debugging, and starts listening for incoming RPC requests. It also demonstrates protobuf JSON marshaling of a well-known type.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but runs indefinitely to serve requests)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n)\nfunc Serve() {\n\tlis, err := net.Listen(\"tcp\", \":5001\")\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"server: failed to create listener: %v\", err)\n\t}\n\n\te, _ := protojson.Marshal(&WellKnownRequest{Timestamp: timestamppb.Now()})\n\tfmt.Printf(\"string(e) = %+v\\n\", string(e))\n\n\ts := newServer()\n\tgs := grpc.NewServer()\n\tRegisterRouteGuideServer(gs, s)\n\tRegisterFoobarServer(gs, s)\n\treflection.Register(gs)\n\tgs.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype routeGuideServer struct {\n\tpb.UnimplementedRouteGuideServer\n}\n\ntype foobarServer struct {\n\tpb.UnimplementedFoobarServer\n}\n\nfunc (s *routeGuideServer) GetFeature(ctx context.Context, req *pb.Point) (*pb.Feature, error) {\n\tfeature := &pb.Feature{Name: \"Example Feature\", Location: req}\n\treturn feature, nil\n}\n\nfunc (s *foobarServer) DoSomething(ctx context.Context, req *pb.FooRequest) (*pb.FooResponse, error) {\n\tresponse := &pb.FooResponse{Message: \"Foobar response\"}\n\treturn response, nil\n}\n\nfunc Serve() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterRouteGuideServer(s, &routeGuideServer{})\n\tpb.RegisterFoobarServer(s, &foobarServer{})\n\n\treflection.Register(s)\n\n\tlog.Println(\"gRPC server is running on port 50051\")\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Implement a gRPC server for a CSI (Container Storage Interface) driver in Go, including server lifecycle management, request interception, and authentication.\n\nStruct Description: CSIDriver represents a gRPC server implementation for CSI driver operations, managing server lifecycle, intercepting requests, and handling authentication.\n\nFields:\n- listener: net.Listener - Network listener for incoming connections\n- server: *grpc.Server - gRPC server instance\n- servers: *CSIDriverServers - CSI service implementations (Controller, Identity, Node)\n- wg: sync.WaitGroup - Synchronization for graceful shutdown\n- running: bool - Server running state flag\n- lock: sync.Mutex - Mutex for thread-safe operations\n- creds: *CSICreds - Authentication credentials\n- logGRPC: LogGRPC - Callback for logging gRPC calls\n\nMethods:\n- NewCSIDriver(*CSIDriverServers) -> *CSIDriver - Constructor that creates a new CSIDriver instance with given service implementations\n- Start(net.Listener, grpc.UnaryServerInterceptor) -> error - Starts the gRPC server with optional interceptor\n- goServe(chan<- bool) -> - Internal method to start server in goroutine\n- Stop() -> - Stops the server gracefully\n- callInterceptor(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) -> (interface{}, error) - Request interceptor handling authentication and logging",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\ntype LogGRPC func(method string, request, reply interface{}, err error)\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (c *CSIDriver) Start(l net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.listener = l\n\n\tif interceptor == nil {\n\t\tinterceptor = c.callInterceptor\n\t}\n\tc.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\n\tif c.servers.Controller != nil {\n\t\tcsi.RegisterControllerServer(c.server, c.servers.Controller)\n\t}\n\tif c.servers.Identity != nil {\n\t\tcsi.RegisterIdentityServer(c.server, c.servers.Identity)\n\t}\n\tif c.servers.Node != nil {\n\t\tcsi.RegisterNodeServer(c.server, c.servers.Node)\n\t}\n\n\twaitForServer := make(chan bool)\n\tc.goServe(waitForServer)\n\t<-waitForServer\n\tc.running = true\n\treturn nil\n}\n\nfunc (c *CSIDriver) goServe(started chan<- bool) {\n\tgo func() {\n\t\tc.wg.Add(1)\n\t\tdefer c.wg.Done()\n\t\tstarted <- true\n\t\tc.server.Serve(c.listener)\n\t}()\n}\n\nfunc (c *CSIDriver) Stop() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif !c.running {\n\t\treturn\n\t}\n\n\tc.server.Stop()\n\tc.wg.Wait()\n}\n\nfunc (c *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\terr := authInterceptor(c.creds, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsp, err := handler(ctx, req)\n\tif c.logGRPC != nil {\n\t\tc.logGRPC(info.FullMethod, req, rsp, err)\n\t}\n\treturn rsp, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\ntype CSIDriverServers struct {\n\tController grpc.ServiceRegistrar\n\tIdentity   grpc.ServiceRegistrar\n\tNode       grpc.ServiceRegistrar\n}\n\ntype CSICreds struct {\n\t// Define authentication credentials fields\n}\n\ntype LogGRPC func(ctx context.Context, method string, req interface{}, err error)\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (d *CSIDriver) Start(listener net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.running {\n\t\treturn nil\n\t}\n\n\td.listener = listener\n\td.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\td.servers.Controller.RegisterService(d.server)\n\td.servers.Identity.RegisterService(d.server)\n\td.servers.Node.RegisterService(d.server)\n\n\td.running = true\n\td.wg.Add(1)\n\tgo d.goServe()\n\n\treturn nil\n}\n\nfunc (d *CSIDriver) goServe() {\n\tdefer d.wg.Done()\n\tif err := d.server.Serve(d.listener); err != nil {\n\t\td.lock.Lock()\n\t\td.running = false\n\t\td.lock.Unlock()\n\t}\n}\n\nfunc (d *CSIDriver) Stop() {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif !d.running {\n\t\treturn\n\t}\n\n\td.server.GracefulStop()\n\td.running = false\n\td.wg.Wait()\n}\n\nfunc (d *CSIDriver) callInterceptor(\n\tctx context.Context,\n\treq interface{},\n\tinfo *grpc.UnaryServerInfo,\n\thandler grpc.UnaryHandler,\n) (interface{}, error) {\n\tif d.creds != nil {\n\t\t// Perform authentication using d.creds\n\t}\n\n\tresp, err := handler(ctx, req)\n\tif d.logGRPC != nil {\n\t\td.logGRPC(ctx, info.FullMethod, req, err)\n\t}\n\treturn resp, err\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles graceful shutdown.\n\nStruct Description: The Plumber struct represents a gRPC server instance with configuration options, logging, and shutdown capabilities.\n\nFields:\n- Config: *options.Config - Configuration settings for the server\n- CLIOptions: *options.CLIOptions - Command line interface options\n- PersistentConfig: *options.PersistentConfig - Persistent configuration settings\n- Actions: *actions.Actions - Server actions and operations\n- Bus: bus.IBus - Message bus interface\n- ServiceShutdownCtx: context.Context - Context for shutdown signaling\n- log: *logrus.Entry - Logger instance\n\nMethods:\n- startGRPCServer: () -> error - Starts the gRPC server and listens for incoming requests\n- watchServiceShutdown: (*grpc.Server) -> () - Monitors for shutdown signals and stops the gRPC server gracefully",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/batchcorp/plumber-schemas/build/go/protos\"\n\t\"github.com/streamdal/plumber/server\"\n)\n\ntype Plumber struct {\n\tConfig               *options.Config\n\tCLIOptions           *options.CLIOptions\n\tPersistentConfig     *options.PersistentConfig\n\tActions              *actions.Actions\n\tBus                  bus.IBus\n\tServiceShutdownCtx   context.Context\n\tlog                  *logrus.Entry\n}\n\nfunc (p *Plumber) startGRPCServer() error {\n\tlis, err := net.Listen(\"tcp\", p.CLIOptions.Server.GrpcListenAddress)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to listen on '%s': %s\", p.CLIOptions.Server.GrpcListenAddress, err)\n\t}\n\n\tvar opts []grpc.ServerOption\n\n\tgrpcServer := grpc.NewServer(opts...)\n\n\tp.PersistentConfig.ClusterID = p.CLIOptions.Server.ClusterId\n\n\tplumberServer := &server.Server{\n\t\tActions:          p.Actions,\n\t\tPersistentConfig: p.PersistentConfig,\n\t\tAuthToken:        p.CLIOptions.Server.AuthToken,\n\t\tBus:              p.Bus,\n\t\tLog:              logrus.WithField(\"pkg\", \"plumber/cli_server.go\"),\n\t\tCLIOptions:       p.CLIOptions,\n\t}\n\n\tprotos.RegisterPlumberServerServer(grpcServer, plumberServer)\n\n\tgo p.watchServiceShutdown(grpcServer)\n\n\tp.log.Debugf(\"starting gRPC server on %s\", p.CLIOptions.Server.GrpcListenAddress)\n\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\terrCh <- errors.Wrap(err, \"unable to start gRPC server\")\n\t\t}\n\t}()\n\n\tafterCh := time.After(5 * time.Second)\n\n\tselect {\n\tcase <-afterCh:\n\t\treturn nil\n\tcase err := <-errCh:\n\t\treturn err\n\t}\n}\n\nfunc (p *Plumber) watchServiceShutdown(grpcServer *grpc.Server) {\n\t<-p.ServiceShutdownCtx.Done()\n\n\tp.log.Debug(\"received shutdown request in gRPC server via ServiceShutdownCtx\")\n\n\ttime.Sleep(5 * time.Second)\n\n\tgrpcServer.Stop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\t\"myapp/options\"\n\t\"myapp/actions\"\n\t\"myapp/bus\"\n)\n\ntype Plumber struct {\n\tConfig             *options.Config\n\tCLIOptions         *options.CLIOptions\n\tPersistentConfig   *options.PersistentConfig\n\tActions            *actions.Actions\n\tBus                bus.IBus\n\tServiceShutdownCtx context.Context\n\tlog                *logrus.Entry\n}\n\nfunc (p *Plumber) startGRPCServer() error {\n\tlis, err := net.Listen(\"tcp\", p.Config.ServerAddress)\n\tif err != nil {\n\t\tp.log.Errorf(\"failed to listen: %v\", err)\n\t\treturn err\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\t// Register your gRPC services here\n\n\tgo p.watchServiceShutdown(grpcServer)\n\n\tp.log.Infof(\"gRPC server listening on %s\", p.Config.ServerAddress)\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tp.log.Errorf(\"failed to serve: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p *Plumber) watchServiceShutdown(grpcServer *grpc.Server) {\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tselect {\n\tcase <-sigChan:\n\t\tp.log.Info(\"Received shutdown signal\")\n\tcase <-p.ServiceShutdownCtx.Done():\n\t\tp.log.Info(\"Service shutdown context done\")\n\t}\n\n\tp.log.Info(\"Gracefully stopping gRPC server\")\n\tgrpcServer.GracefulStop()\n}\n\nfunc main() {\n\t// Initialize Plumber with necessary configurations and start the server\n}\n```"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both unary and bidirectional streaming RPCs for an echo service, with TLS security.\n\nStruct Description: The server struct implements the EchoServer interface generated from the protobuf definition, providing echo functionality for both unary and streaming RPCs.\n\nFields:\n- UnimplementedEchoServer: pb.UnimplementedEchoServer - Embedded type to ensure forward compatibility\n\nMethods:\n- UnaryEcho: (context.Context, *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls by echoing back the received message\n- BidirectionalStreamingEcho: (pb.Echo_BidirectionalStreamingEchoServer) -> error - Handles bidirectional streaming by continuously receiving messages and echoing them back until the stream ends\n\nInput: None (The struct itself doesn't take input parameters, but its methods do as described above)\n\nOutput: None (The struct doesn't return anything directly, but its methods return values as described above)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/examples/data\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(_ context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tfmt.Printf(\"unary echoing message %q\\n\", in.Message)\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tin, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfmt.Printf(\"server: error receiving from stream: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"bidi echoing message %q\\n\", in.Message)\n\t\tstream.Send(&pb.EchoResponse{Message: in.Message})\n\t}\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"the port to serve on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(data.Path(\"x509/server_cert.pem\"), data.Path(\"x509/server_key.pem\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/echo/protobuf\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.GetMessage()}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := stream.Send(&pb.EchoResponse{Message: req.GetMessage()}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc loadTLSCredentials() (credentials.TransportCredentials, error) {\n\tserverCert, err := tls.LoadX509KeyPair(\"server-cert.pem\", \"server-key.pem\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcaCert, err := ioutil.ReadFile(\"ca-cert.pem\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcaCertPool := x509.NewCertPool()\n\tif ok := caCertPool.AppendCertsFromPEM(caCert); !ok {\n\t\treturn nil, fmt.Errorf(\"failed to add CA certificate\")\n\t}\n\n\treturn credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{serverCert},\n\t\tClientCAs:    caCertPool,\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t}), nil\n}\n\nfunc main() {\n\ttlsCredentials, err := loadTLSCredentials()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to load TLS credentials: %v\", err)\n\t}\n\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer(grpc.Creds(tlsCredentials))\n\tpb.RegisterEchoServer(grpcServer, &server{})\n\n\tlog.Println(\"gRPC server listening on port 50051\")\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles incoming requests with custom stream preprocessing and graceful shutdown capabilities.\n\nStruct Description: The `server` struct represents a gRPC server instance with additional control for graceful shutdown and stream preprocessing.\n\nFields:\n- grpcSrv: *grpc.Server - The underlying gRPC server instance\n- closeC: chan struct{} - Channel used to signal server shutdown\n\nMethods:\n- Serve: (lis net.Listener) -> error - Starts the gRPC server on the provided listener, initializing it with custom stream preprocessing\n- preGrpcStream: (ctx context.Context, info *tap.Info) -> (context.Context, error) - Intercepts incoming gRPC streams before processing, with special handling for the \"/vanus.core.raft.RaftServer/SendMessage\" method",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/tap\"\n)\n\ntype server struct {\n\tgrpcSrv *grpc.Server\n\tcloseC  chan struct{}\n}\n\nfunc (s *server) Serve(lis net.Listener) error {\n\tsrv := grpc.NewServer(\n\t\tgrpc.InTapHandle(s.preGrpcStream),\n\t)\n\ts.grpcSrv = srv\n\n\treturn srv.Serve(lis)\n}\n\nfunc (s *server) preGrpcStream(ctx context.Context, info *tap.Info) (context.Context, error) {\n\tif info.FullMethodName == \"/vanus.core.raft.RaftServer/SendMessage\" {\n\t\tcCtx, cancel := context.WithCancel(ctx)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-cCtx.Done():\n\t\t\tcase <-s.closeC:\n\t\t\t\tcancel()\n\t\t\t}\n\t\t}()\n\t\treturn cCtx, nil\n\t}\n\treturn ctx, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/tap\"\n)\n\ntype server struct {\n\tgrpcSrv *grpc.Server\n\tcloseC  chan struct{}\n}\n\nfunc (s *server) Serve(lis net.Listener) error {\n\ts.grpcSrv = grpc.NewServer(grpc.InTapHandle(s.preGrpcStream))\n\ts.closeC = make(chan struct{})\n\n\tgo func() {\n\t\tif err := s.grpcSrv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\tsigC := make(chan os.Signal, 1)\n\tsignal.Notify(sigC, syscall.SIGINT, syscall.SIGTERM)\n\n\tselect {\n\tcase <-sigC:\n\t\tlog.Println(\"Received shutdown signal\")\n\tcase <-s.closeC:\n\t\tlog.Println(\"Received close signal\")\n\t}\n\n\ts.grpcSrv.GracefulStop()\n\treturn nil\n}\n\nfunc (s *server) preGrpcStream(ctx context.Context, info *tap.Info) (context.Context, error) {\n\tif info.FullMethodName == \"/vanus.core.raft.RaftServer/SendMessage\" {\n\t\tlog.Println(\"Intercepted SendMessage method\")\n\t\t// Add custom preprocessing logic here\n\t}\n\treturn ctx, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tsrv := &server{}\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a gRPC server configuration and management system in Go that handles server setup, TLS configuration, client credentials, and network listeners with support for both buffered and regular network connections.\n\nStruct Description: GRPCServerConfig represents a configuration for setting up a gRPC server with various options including network settings, TLS configuration, and connection parameters.\n\nFields:\n- Address: string - The network address to listen on\n- Network: string - The network type (e.g., \"tcp\", \"unix\", or \"buffered\")\n- TLSCertPath: string - Path to TLS certificate file\n- TLSKeyPath: string - Path to TLS private key file\n- MaxConnAge: time.Duration - Maximum connection age before termination\n- Enabled: bool - Whether the server is enabled\n- BufferSize: int - Size of buffer for buffered connections\n- ClientCAPath: string - Path to client CA certificate file\n- MaxWorkers: uint32 - Maximum number of stream workers\n- flagPrefix: string - Prefix for configuration flags\n\nMethods:\n- Complete: (level zerolog.Level, svcRegistrationFn func(*grpc.Server), opts ...grpc.ServerOption) -> (RunnableGRPCServer, error) - Completes the configuration and returns a runnable server instance\n- listenerAndDialer: () -> (net.Listener, DialFunc, NetDialFunc, error) - Creates a network listener and dialer functions based on configuration\n- tlsOpts: () -> ([]grpc.ServerOption, *certwatcher.CertWatcher, error) - Generates TLS server options based on certificate configuration\n- clientCreds: () -> (credentials.TransportCredentials, error) - Creates client transport credentials based on TLS configuration\n\nStruct Description: completedGRPCServer represents a fully configured and runnable gRPC server instance.\n\nFields:\n- opts: []grpc.ServerOption - Server options\n- listener: net.Listener - Network listener\n- svcRegistrationFn: func(*grpc.Server) - Service registration function\n- listenFunc: func() error - Function to start listening\n- prestopFunc: func() - Function to run before stopping\n- stopFunc: func() - Function to stop the server\n- dial: func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error) - Dial function for clients\n- netDial: func(context.Context, string) (net.Conn, error) - Raw network dial function\n- creds: credentials.TransportCredentials - Client transport credentials\n- certWatcher: *certwatcher.CertWatcher - Certificate watcher for TLS\n\nMethods:\n- WithOpts: (...grpc.ServerOption) -> RunnableGRPCServer - Adds additional server options\n- Listen: (context.Context) -> func() error - Starts the server and returns a listen function\n- DialContext: (context.Context, ...grpc.DialOption) -> (*grpc.ClientConn, error) - Creates a client connection\n- NetDialContext: (context.Context, string) -> (net.Conn, error) - Creates a raw network connection\n- Insecure: () -> bool - Returns whether the connection is insecure\n- GracefulStop: () - Stops the server gracefully",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\n\t\"sigs.k8s.io/controller-runtime/pkg/certwatcher\"\n\n\t\"github.com/authzed/spicedb/internal/grpchelpers\"\n\t\"github.com/authzed/spicedb/pkg/x509util\"\n)\n\ntype GRPCServerConfig struct {\n\tAddress      string\n\tNetwork      string\n\tTLSCertPath  string\n\tTLSKeyPath   string\n\tMaxConnAge   time.Duration\n\tEnabled      bool\n\tBufferSize   int\n\tClientCAPath string\n\tMaxWorkers   uint32\n\n\tflagPrefix string\n}\n\nfunc (c *GRPCServerConfig) Complete(level zerolog.Level, svcRegistrationFn func(server *grpc.Server), opts ...grpc.ServerOption) (RunnableGRPCServer, error) {\n\tif !c.Enabled {\n\t\treturn &disabledGrpcServer{}, nil\n\t}\n\tif c.BufferSize == 0 {\n\t\tc.BufferSize = 1024 * 1024\n\t}\n\topts = append(opts, grpc.KeepaliveParams(keepalive.ServerParameters{\n\t\tMaxConnectionAge: c.MaxConnAge,\n\t}), grpc.NumStreamWorkers(c.MaxWorkers))\n\n\ttlsOpts, certWatcher, err := c.tlsOpts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts = append(opts, tlsOpts...)\n\n\tclientCreds, err := c.clientCreds()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl, dial, netDial, err := c.listenerAndDialer()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen on addr for gRPC server: %w\", err)\n\t}\n\n\tsrv := grpc.NewServer(opts...)\n\tsvcRegistrationFn(srv)\n\treturn &completedGRPCServer{\n\t\topts:              opts,\n\t\tlistener:          l,\n\t\tsvcRegistrationFn: svcRegistrationFn,\n\t\tlistenFunc: func() error {\n\t\t\treturn srv.Serve(l)\n\t\t},\n\t\tdial:    dial,\n\t\tnetDial: netDial,\n\t\tprestopFunc: func() {\n\t\t},\n\t\tstopFunc:    srv.GracefulStop,\n\t\tcreds:       clientCreds,\n\t\tcertWatcher: certWatcher,\n\t}, nil\n}\n\nfunc (c *GRPCServerConfig) listenerAndDialer() (net.Listener, DialFunc, NetDialFunc, error) {\n\tif c.Network == BufferedNetwork {\n\t\tbl := bufconn.Listen(c.BufferSize)\n\t\treturn bl, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\t\topts = append(opts, grpc.WithContextDialer(func(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\t\treturn bl.DialContext(ctx)\n\t\t\t\t}))\n\n\t\t\t\treturn grpchelpers.Dial(ctx, BufferedNetwork, opts...)\n\t\t\t}, func(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\treturn bl.DialContext(ctx)\n\t\t\t}, nil\n\t}\n\tl, err := net.Listen(c.Network, c.Address)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn l, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\treturn grpchelpers.Dial(ctx, c.Address, opts...)\n\t}, nil, nil\n}\n\nfunc (c *GRPCServerConfig) tlsOpts() ([]grpc.ServerOption, *certwatcher.CertWatcher, error) {\n\tswitch {\n\tcase c.TLSCertPath == \"\" && c.TLSKeyPath == \"\":\n\t\treturn nil, nil, nil\n\tcase c.TLSCertPath != \"\" && c.TLSKeyPath != \"\":\n\t\twatcher, err := certwatcher.New(c.TLSCertPath, c.TLSKeyPath)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tcreds := credentials.NewTLS(&tls.Config{\n\t\t\tGetCertificate: watcher.GetCertificate,\n\t\t\tMinVersion:     tls.VersionTLS12,\n\t\t})\n\t\treturn []grpc.ServerOption{grpc.Creds(creds)}, watcher, nil\n\tdefault:\n\t\treturn nil, nil, nil\n\t}\n}\n\nfunc (c *GRPCServerConfig) clientCreds() (credentials.TransportCredentials, error) {\n\tswitch {\n\tcase c.TLSCertPath == \"\" && c.TLSKeyPath == \"\":\n\t\treturn insecure.NewCredentials(), nil\n\tcase c.TLSCertPath != \"\" && c.TLSKeyPath != \"\":\n\t\tvar err error\n\t\tvar pool *x509.CertPool\n\t\tif c.ClientCAPath != \"\" {\n\t\t\tpool, err = x509util.CustomCertPool(c.ClientCAPath)\n\t\t} else {\n\t\t\tpool, err = x509.SystemCertPool()\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn credentials.NewTLS(&tls.Config{RootCAs: pool, MinVersion: tls.VersionTLS12}), nil\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\ntype completedGRPCServer struct {\n\topts              []grpc.ServerOption\n\tlistener          net.Listener\n\tsvcRegistrationFn func(*grpc.Server)\n\tlistenFunc        func() error\n\tprestopFunc       func()\n\tstopFunc          func()\n\tdial              func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error)\n\tnetDial           func(ctx context.Context, s string) (net.Conn, error)\n\tcreds             credentials.TransportCredentials\n\tcertWatcher       *certwatcher.CertWatcher\n}\n\nfunc (c *completedGRPCServer) WithOpts(opts ...grpc.ServerOption) RunnableGRPCServer {\n\tc.opts = append(c.opts, opts...)\n\tsrv := grpc.NewServer(c.opts...)\n\tc.svcRegistrationFn(srv)\n\tc.listenFunc = func() error {\n\t\treturn srv.Serve(c.listener)\n\t}\n\tc.stopFunc = srv.GracefulStop\n\treturn c\n}\n\nfunc (c *completedGRPCServer) Listen(ctx context.Context) func() error {\n\tif c.certWatcher != nil {\n\t\tgo func() {\n\t\t\tif err := c.certWatcher.Start(ctx); err != nil {\n\t\t\t}\n\t\t}()\n\t}\n\treturn c.listenFunc\n}\n\nfunc (c *completedGRPCServer) DialContext(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\topts = append(opts, grpc.WithTransportCredentials(c.creds))\n\treturn c.dial(ctx, opts...)\n}\n\nfunc (c *completedGRPCServer) NetDialContext(ctx context.Context, s string) (net.Conn, error) {\n\treturn c.netDial(ctx, s)\n}\n\nfunc (c *completedGRPCServer) Insecure() bool {\n\treturn c.creds.Info().SecurityProtocol == \"insecure\"\n}\n\nfunc (c *completedGRPCServer) GracefulStop() {\n\tc.prestopFunc()\n\tc.stopFunc()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package grpcserver\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/tap\"\n)\n\ntype GRPCServerConfig struct {\n\tAddress      string\n\tNetwork      string\n\tTLSCertPath  string\n\tTLSKeyPath   string\n\tMaxConnAge   time.Duration\n\tEnabled      bool\n\tBufferSize   int\n\tClientCAPath string\n\tMaxWorkers   uint32\n\tflagPrefix   string\n}\n\ntype RunnableGRPCServer interface {\n\tWithOpts(...grpc.ServerOption) RunnableGRPCServer\n\tListen(context.Context) func() error\n\tDialContext(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error)\n\tNetDialContext(context.Context, string) (net.Conn, error)\n\tInsecure() bool\n\tGracefulStop()\n}\n\ntype completedGRPCServer struct {\n\topts             []grpc.ServerOption\n\tlistener         net.Listener\n\tsvcRegistrationFn func(*grpc.Server)\n\tlistenFunc       func() error\n\tprestopFunc      func()\n\tstopFunc         func()\n\tdial             func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error)\n\tnetDial          func(context.Context, string) (net.Conn, error)\n\tcreds            credentials.TransportCredentials\n\tcertWatcher      *certwatcher.CertWatcher\n}\n\nfunc (c *GRPCServerConfig) Complete(level zerolog.Level, svcRegistrationFn func(*grpc.Server), opts ...grpc.ServerOption) (RunnableGRPCServer, error) {\n\tif !c.Enabled {\n\t\treturn nil, errors.New(\"server not enabled\")\n\t}\n\n\tlistener, dialFunc, netDialFunc, err := c.listenerAndDialer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsOpts, certWatcher, err := c.tlsOpts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserverOpts := append(opts, tlsOpts...)\n\tserverOpts = append(serverOpts, grpc.KeepaliveParams(keepalive.ServerParameters{\n\t\tMaxConnectionAge: c.MaxConnAge,\n\t}))\n\n\treturn &completedGRPCServer{\n\t\topts:             serverOpts,\n\t\tlistener:         listener,\n\t\tsvcRegistrationFn: svcRegistrationFn,\n\t\tlistenFunc:       func() error { return nil },\n\t\tprestopFunc:      func() {},\n\t\tstopFunc:         func() {},\n\t\tdial:             dialFunc,\n\t\tnetDial:          netDialFunc,\n\t\tcreds:            tlsOpts[0].(credentials.TransportCredentials),\n\t\tcertWatcher:      certWatcher,\n\t}, nil\n}\n\nfunc (c *GRPCServerConfig) listenerAndDialer() (net.Listener, func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error), func(context.Context, string) (net.Conn, error), error) {\n\tvar listener net.Listener\n\tvar err error\n\n\tswitch c.Network {\n\tcase \"tcp\":\n\t\tlistener, err = net.Listen(\"tcp\", c.Address)\n\tcase \"unix\":\n\t\tlistener, err = net.Listen(\"unix\", c.Address)\n\tcase \"buffered\":\n\t\tlistener, err = net.Listen(\"tcp\", c.Address) // Placeholder for buffered implementation\n\tdefault:\n\t\treturn nil, nil, nil, errors.New(\"unsupported network type\")\n\t}\n\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\tdialFunc := func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\treturn grpc.DialContext(ctx, c.Address, opts...)\n\t}\n\n\tnetDialFunc := func(ctx context.Context, address string) (net.Conn, error) {\n\t\treturn net.Dial(c.Network, address)\n\t}\n\n\treturn listener, dialFunc, netDialFunc, nil\n}\n\nfunc (c *GRPCServerConfig) tlsOpts() ([]grpc.ServerOption, *certwatcher.CertWatcher, error) {\n\tif c.TLSCertPath == \"\" || c.TLSKeyPath == \"\" {\n\t\treturn []grpc.ServerOption{grpc.Creds(insecure.NewCredentials())}, nil, nil\n\t}\n\n\tcert, err := tls.LoadX509KeyPair(c.TLSCertPath, c.TLSKeyPath)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcertPool := x509.NewCertPool()\n\tif c.ClientCAPath != \"\" {\n\t\tcaCert, err := ioutil.ReadFile(c.ClientCAPath)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif ok := certPool.AppendCertsFromPEM(caCert); !ok {\n\t\t\treturn nil, nil, errors.New(\"failed to append client CA certs\")\n\t\t}\n\t}\n\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tClientCAs:    certPool,\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t})\n\n\treturn []grpc.ServerOption{grpc.Creds(creds)}, nil, nil\n}\n\nfunc (c *GRPCServerConfig) clientCreds() (credentials.TransportCredentials, error) {\n\tif c.TLSCertPath == \"\" || c.TLSKeyPath == \"\" {\n\t\treturn insecure.NewCredentials(), nil\n\t}\n\n\tcert, err := tls.LoadX509KeyPair(c.TLSCertPath, c.TLSKeyPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcertPool := x509.NewCertPool()\n\tif c.ClientCAPath != \"\" {\n\t\tcaCert, err := ioutil.ReadFile(c.ClientCAPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif ok := certPool.AppendCertsFromPEM(caCert); !ok {\n\t\t\treturn nil, errors.New(\"failed to append client CA certs\")\n\t\t}\n\t}\n\n\treturn credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tRootCAs:      certPool,\n\t}), nil\n}\n\nfunc (s *completedGRPCServer) WithOpts(opts ...grpc.ServerOption) RunnableGRPCServer {\n\ts.opts = append(s.opts, opts...)\n\treturn s\n}\n\nfunc (s *completedGRPCServer) Listen(ctx context.Context) func() error {\n\treturn func() error {\n\t\tserver := grpc.NewServer(s.opts...)\n\t\ts.svcRegistrationFn(server)\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tserver.GracefulStop()\n\t\t}()\n\t\treturn server.Serve(s.listener)\n\t}\n}\n\nfunc (s *completedGRPCServer) DialContext(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\treturn s.dial(ctx, opts...)\n}\n\nfunc (s *completedGRPCServer) NetDialContext(ctx context.Context, address string) (net.Conn, error) {\n\treturn s.netDial(ctx, address)\n}\n\nfunc (s *completedGRPCServer) Insecure() bool {\n\treturn s.creds == nil\n}\n\nfunc (s *completedGRPCServer) GracefulStop() {\n\ts.stopFunc()\n}"
  },
  {
    "Task_id": 277,
    "Instruction": "Task Description: Create a gRPC server in Go that handles metric forwarding operations, including server initialization, startup, and metric processing.\n\nStruct Description: The Server struct represents a gRPC server for forwarding metrics. It manages server lifecycle, handles incoming metric data, and provides logging capabilities.\n\nFields:\n\nserver: *grpc.Server - The gRPC server instance\naddress: string - Network address to bind the server to\ningest: sources.Ingest - Interface for processing incoming metrics\nlistener: net.Listener - Network listener for incoming connections\nlogger: *logrus.Entry - Logger for server operations\nopts: *options - Configuration options for the server\nreadyChannel: chan struct{} - Channel to signal when server is ready\n\nMethods:\n\nNew: (address string, logger *logrus.Entry, opts ...Option) -> *Server - Creates a new Server instance with specified address, logger, and optional configurations. Initializes gRPC server and registers services.\n\nStart: (ingest sources.Ingest) -> error - Starts the gRPC server, binds to the specified address, and begins listening for incoming connections. Takes a metric ingestion interface as input. Returns any error that occurs during startup or operation.\n\nSendMetricsV2: (server forwardrpc.Forward_SendMetricsV2Server) -> error - Handles incoming metric streams from clients. Processes each metric received and sends back an empty response when done. Returns any error that occurs during stream processing.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\n\t\"github.com/stripe/veneur/v14/forwardrpc\"\n\t\"github.com/stripe/veneur/v14/sources\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype Server struct {\n\tserver       *grpc.Server\n\taddress      string\n\tingest       sources.Ingest\n\tlistener     net.Listener\n\tlogger       *logrus.Entry\n\topts         *options\n\treadyChannel chan struct{}\n}\n\nfunc New(address string, logger *logrus.Entry, opts ...Option) *Server {\n\tres := &Server{\n\t\taddress:      address,\n\t\tlogger:       logger,\n\t\topts:         &options{},\n\t\tserver:       grpc.NewServer(),\n\t\treadyChannel: make(chan struct{}),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(res.opts)\n\t}\n\n\tif res.opts.traceClient == nil {\n\t\tres.opts.traceClient = trace.DefaultClient\n\t}\n\n\tforwardrpc.RegisterForwardServer(res.server, res)\n\n\treturn res\n}\n\nfunc (s *Server) Start(ingest sources.Ingest) error {\n\ts.ingest = ingest\n\n\tvar err error\n\ts.listener, err = net.Listen(\"tcp\", s.address)\n\tif err != nil {\n\t\ts.logger.WithError(err).WithField(\"address\", s.address).\n\t\t\tErrorf(\"failed to bind import server\")\n\t\treturn err\n\t}\n\n\tlogger := s.logger.WithFields(logrus.Fields{\"address\": s.listener.Addr()})\n\tlogger.Info(\"Starting gRPC server\")\n\n\tclose(s.readyChannel)\n\terr = s.server.Serve(s.listener)\n\tif err != nil {\n\t\tlogger.WithError(err).Error(\"gRPC server was not shut down cleanly\")\n\t}\n\tlogger.Info(\"Stopped gRPC server\")\n\treturn err\n}\n\nfunc (s *Server) SendMetricsV2(\n\tserver forwardrpc.Forward_SendMetricsV2Server,\n) error {\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\ts.logger.WithError(err).Error(\"error recieving metrics\")\n\t\t\treturn err\n\t\t}\n\t\ts.ingest.IngestMetricProto(metric)\n\t}\n\terr := server.SendAndClose(&emptypb.Empty{})\n\tif err != nil {\n\t\ts.logger.WithError(err).Error(\"error closing stream\")\n\t}\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\t\"your_project/sources\"\n\t\"your_project/forwardrpc\"\n)\n\ntype options struct {\n\t// Define any additional configuration options here\n}\n\ntype Server struct {\n\tserver      *grpc.Server\n\taddress     string\n\tingest      sources.Ingest\n\tlistener    net.Listener\n\tlogger      *logrus.Entry\n\topts        *options\n\treadyChannel chan struct{}\n}\n\nfunc New(address string, logger *logrus.Entry, opts ...Option) *Server {\n\tserverOpts := &options{}\n\tfor _, opt := range opts {\n\t\topt(serverOpts)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\treturn &Server{\n\t\tserver:      grpcServer,\n\t\taddress:     address,\n\t\tlogger:      logger,\n\t\topts:        serverOpts,\n\t\treadyChannel: make(chan struct{}),\n\t}\n}\n\nfunc (s *Server) Start(ingest sources.Ingest) error {\n\ts.ingest = ingest\n\tlistener, err := net.Listen(\"tcp\", s.address)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to listen on %s: %v\", s.address, err)\n\t\treturn err\n\t}\n\ts.listener = listener\n\n\tforwardrpc.RegisterForwardServer(s.server, s)\n\tclose(s.readyChannel)\n\n\ts.logger.Infof(\"Server is starting on %s\", s.address)\n\tif err := s.server.Serve(s.listener); err != nil {\n\t\ts.logger.Errorf(\"Failed to serve: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *Server) SendMetricsV2(server forwardrpc.Forward_SendMetricsV2Server) error {\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Error receiving metric: %v\", err)\n\t\t\treturn err\n\t\t}\n\n\t\tif err := s.ingest.Process(metric); err != nil {\n\t\t\ts.logger.Errorf(\"Error processing metric: %v\", err)\n\t\t\treturn err\n\t\t}\n\n\t\tif err := server.Send(&forwardrpc.Empty{}); err != nil {\n\t\t\ts.logger.Errorf(\"Error sending response: %v\", err)\n\t\t\treturn err\n\t\t}\n\t}\n}\n\ntype Option func(*options)\n\nfunc main() {\n\t// Example usage\n\tlogger := logrus.NewEntry(logrus.New())\n\tserver := New(\":50051\", logger)\n\t// Assume `ingest` is an implementation of `sources.Ingest`\n\t// err := server.Start(ingest)\n\t// Handle error if needed\n}\n```"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a gRPC server in Go that handles Bigtable administration and operations, with proper initialization and cleanup capabilities.\n\nStruct Description: The Server struct represents a gRPC server instance that manages Bigtable table administration and operations. It handles network connections, server lifecycle, and maintains internal state.\n\nFields:\nAddr: [string] - The network address the server is listening on\nl: [net.Listener] - The network listener for incoming connections\nsrv: [*grpc.Server] - The gRPC server instance\ns: [*server] - The internal server implementation handling business logic\n\nMethods:\nNewServer: [func(laddr string, opt ...grpc.ServerOption) (*Server, error)] -> Creates and starts a new Server instance\n- Input: laddr (string) - The address to listen on, opt (...grpc.ServerOption) - Optional gRPC server configurations\n- Output: (*Server, error) - Returns the server instance or an error if initialization fails\n- Description: Initializes the server, sets up the listener, registers gRPC services, and starts serving requests in a goroutine\n\nClose: [func(s *Server)] -> Properly shuts down the Server instance\n- Input: None (method receiver)\n- Output: None\n- Description: Stops the gRPC server, closes the listener, and cleans up internal resources",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tl   net.Listener\n\tsrv *grpc.Server\n\ts   *server\n}\n\nfunc NewServer(laddr string, opt ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", laddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts := &Server{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tsrv:  grpc.NewServer(opt...),\n\t\ts: &server{\n\t\t\ttables: make(map[string]*table),\n\t\t},\n\t}\n\tbtapb.RegisterBigtableTableAdminServer(s.srv, s.s)\n\tbtpb.RegisterBigtableServer(s.srv, s.s)\n\n\tgo s.srv.Serve(s.l)\n\n\treturn s, nil\n}\n\nfunc (s *Server) Close() {\n\ts.s.mu.Lock()\n\tif s.s.gcc != nil {\n\t\tclose(s.s.gcc)\n\t}\n\ts.s.mu.Unlock()\n\n\ts.srv.Stop()\n\ts.l.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tl    net.Listener\n\tsrv  *grpc.Server\n\ts    *server\n}\n\ntype server struct {\n\t// Add fields for Bigtable administration and operations\n}\n\nfunc NewServer(laddr string, opt ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", laddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer(opt...)\n\ts := &server{}\n\t// Register Bigtable services here\n\n\tgo func() {\n\t\tif err := srv.Serve(l); err != nil {\n\t\t\tfmt.Printf(\"failed to serve: %v\\n\", err)\n\t\t}\n\t}()\n\n\treturn &Server{\n\t\tAddr: laddr,\n\t\tl:    l,\n\t\tsrv:  srv,\n\t\ts:    s,\n\t}, nil\n}\n\nfunc (s *Server) Close() {\n\ts.srv.GracefulStop()\n\ts.l.Close()\n\t// Clean up internal resources\n}\n\nfunc main() {\n\tserver, err := NewServer(\":50051\")\n\tif err != nil {\n\t\tfmt.Printf(\"failed to start server: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Handle graceful shutdown\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\t<-c\n\n\tserver.Close()\n\tfmt.Println(\"server stopped\")\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles log streaming and processing, including batch processing of log events.\n\nStruct Description: The Source struct represents a gRPC server that receives log streams, processes them in batches, and manages the server lifecycle.\n\nFields:\n- name: string - The name identifier for the source\n- eventPool: *event.Pool - Pool for managing event objects\n- config: *Config - Configuration for the source (bind address, port, etc.)\n- grpcServer: *grpc.Server - The gRPC server instance\n- bc: *batchChain - Batch processing chain for handling log events\n\nMethods:\n- ProductLoop: (productFunc api.ProductFunc) -> None - Starts the main processing loop and gRPC server\n  Input: productFunc - Function for processing produced events\n  Output: None (runs indefinitely as goroutine)\n\n- LogStream: (ls pb.LogService_LogStreamServer) -> error - Handles incoming log streams\n  Input: ls - gRPC stream server interface for log messages\n  Output: error - Any error that occurs during stream processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/loggie-io/loggie/pkg/pipeline\"\n\tpb \"github.com/loggie-io/loggie/pkg/sink/grpc/pb\"\n\t\"github.com/loggie-io/loggie/pkg/util/json\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Source struct {\n\tpb.UnimplementedLogServiceServer\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batchChain\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", s.String())\n\ts.bc = newBatchChain(productFunc, s.config.MaintenanceInterval)\n\tgo s.bc.run()\n\tip := fmt.Sprintf(\"%s:%s\", s.config.Bind, s.config.Port)\n\tlistener, err := net.Listen(s.config.Network, ip)\n\tif err != nil {\n\t\tlog.Panic(\"grpc server listen ip(%s) err: %v\", ip, err)\n\t}\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterLogServiceServer(grpcServer, s)\n\tgo grpcServer.Serve(listener)\n\ts.grpcServer = grpcServer\n\tlog.Info(\"grpc server start listing: %s\", ip)\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tb := newBatch(s.config.Timeout)\n\tfor {\n\t\tlogMsg, err := ls.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tsendErr := ls.SendAndClose(&pb.LogResp{\n\t\t\t\tSuccess:  false,\n\t\t\t\tCount:    0,\n\t\t\t\tErrorMsg: err.Error(),\n\t\t\t})\n\t\t\tif sendErr != nil {\n\t\t\t\tlog.Warn(\"send response fail: %s\", sendErr)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\theader := make(map[string]interface{})\n\t\trawHeader := logMsg.GetHeader()\n\t\tif len(rawHeader) > 0 {\n\t\t\tfor k, v := range rawHeader {\n\t\t\t\theader[k] = string(v)\n\t\t\t}\n\t\t}\n\t\tpackedHeader := logMsg.PackedHeader\n\t\tif len(packedHeader) > 0 {\n\t\t\terr = json.Unmarshal(packedHeader, &header)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Unmarshal packedHeader error: %s\", err)\n\t\t\t}\n\t\t}\n\t\te := s.eventPool.Get()\n\t\te.Fill(e.Meta(), header, logMsg.GetRawLog())\n\t\tb.append(e)\n\t}\n\tif b.size() > 0 {\n\t\ts.bc.append(b)\n\t\tlogResp := b.wait()\n\t\terr := ls.SendAndClose(logResp)\n\t\tif err != nil {\n\t\t\tlog.Error(\"send response fail: %s\", err)\n\t\t}\n\t\treturn err\n\t}\n\treturn ls.SendAndClose(&pb.LogResp{\n\t\tSuccess: true,\n\t\tCount:   0,\n\t})\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/protobuf/package\"\n)\n\ntype Source struct {\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batchChain\n}\n\ntype Config struct {\n\tBindAddress string\n\tPort        string\n}\n\ntype batchChain struct {\n\t// Define fields and methods for batch processing\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlis, err := net.Listen(\"tcp\", s.config.BindAddress+\":\"+s.config.Port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts.grpcServer = grpc.NewServer()\n\tpb.RegisterLogServiceServer(s.grpcServer, s)\n\tlog.Printf(\"gRPC server listening on %s:%s\", s.config.BindAddress, s.config.Port)\n\tif err := s.grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tfor {\n\t\treq, err := ls.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Process the log event\n\t\ts.bc.process(req)\n\t}\n}\n\nfunc main() {\n\t// Initialize Source and start ProductLoop\n}\n```"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a gRPC test server for monitoring metrics that can handle metric descriptor creation and time series requests, while tracking user agents and request counts.\n\nStruct Description: MetricsTestServer is a gRPC server implementation for testing metric monitoring functionality. It maintains state for tracking incoming requests and user agents, and provides methods for server control and data retrieval.\n\nFields:\n- lis: net.Listener - Network listener for the gRPC server\n- srv: *grpc.Server - gRPC server instance\n- Endpoint: string - Server's network endpoint address\n- userAgent: string - Last received User-Agent header from requests\n- createMetricDescriptorReqs: []*monitoringpb.CreateMetricDescriptorRequest - Collected metric descriptor requests\n- createServiceTimeSeriesReqs: []*monitoringpb.CreateTimeSeriesRequest - Collected time series requests\n- RetryCount: int - Number of retry attempts (usage context not shown in code)\n- mu: sync.Mutex - Mutex for thread-safe access to shared fields\n\nMethods:\n- Shutdown() -> None - Gracefully stops the gRPC server\n- UserAgent() -> string - Retrieves and clears the stored User-Agent\n- CreateServiceTimeSeriesRequests() -> []*monitoringpb.CreateTimeSeriesRequest - Retrieves and clears stored time series requests\n- appendCreateMetricDescriptorReq(context.Context, *monitoringpb.CreateMetricDescriptorRequest) -> None - Thread-safe method to store metric descriptor requests\n- appendCreateServiceTimeSeriesReq(context.Context, *monitoringpb.CreateTimeSeriesRequest) -> None - Thread-safe method to store time series requests and capture User-Agent\n- Serve() -> error - Starts serving gRPC requests\n- NewMetricTestServer() -> (*MetricsTestServer, error) - Constructor that initializes the server with default keepalive parameters and registers the metric service",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"cloud.google.com/go/monitoring/apiv3/v2/monitoringpb\"\n\tmetricpb \"google.golang.org/genproto/googleapis/api/metric\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\ntype MetricsTestServer struct {\n\tlis                         net.Listener\n\tsrv                         *grpc.Server\n\tEndpoint                    string\n\tuserAgent                   string\n\tcreateMetricDescriptorReqs  []*monitoringpb.CreateMetricDescriptorRequest\n\tcreateServiceTimeSeriesReqs []*monitoringpb.CreateTimeSeriesRequest\n\tRetryCount                  int\n\tmu                          sync.Mutex\n}\n\nfunc (m *MetricsTestServer) Shutdown() {\n\tm.srv.GracefulStop()\n}\n\nfunc (m *MetricsTestServer) UserAgent() string {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tua := m.userAgent\n\tm.userAgent = \"\"\n\treturn ua\n}\n\nfunc (m *MetricsTestServer) CreateServiceTimeSeriesRequests() []*monitoringpb.CreateTimeSeriesRequest {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treqs := m.createServiceTimeSeriesReqs\n\tm.createServiceTimeSeriesReqs = nil\n\treturn reqs\n}\n\nfunc (m *MetricsTestServer) appendCreateMetricDescriptorReq(ctx context.Context, req *monitoringpb.CreateMetricDescriptorRequest) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.createMetricDescriptorReqs = append(m.createMetricDescriptorReqs, req)\n}\n\nfunc (m *MetricsTestServer) appendCreateServiceTimeSeriesReq(ctx context.Context, req *monitoringpb.CreateTimeSeriesRequest) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.createServiceTimeSeriesReqs = append(m.createServiceTimeSeriesReqs, req)\n\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tm.userAgent = strings.Join(md.Get(\"User-Agent\"), \";\")\n\t}\n}\n\nfunc (m *MetricsTestServer) Serve() error {\n\treturn m.srv.Serve(m.lis)\n}\n\nfunc NewMetricTestServer() (*MetricsTestServer, error) {\n\tsrv := grpc.NewServer(grpc.KeepaliveParams(keepalive.ServerParameters{Time: 5 * time.Minute}))\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestServer := &MetricsTestServer{\n\t\tEndpoint: lis.Addr().String(),\n\t\tlis:      lis,\n\t\tsrv:      srv,\n\t}\n\n\tmonitoringpb.RegisterMetricServiceServer(\n\t\tsrv,\n\t\t&fakeMetricServiceServer{metricsTestServer: testServer},\n\t)\n\n\treturn testServer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\tmonitoringpb \"google.golang.org/genproto/googleapis/monitoring/v3\"\n)\n\ntype MetricsTestServer struct {\n\tlis                          net.Listener\n\tsrv                          *grpc.Server\n\tEndpoint                     string\n\tuserAgent                    string\n\tcreateMetricDescriptorReqs   []*monitoringpb.CreateMetricDescriptorRequest\n\tcreateServiceTimeSeriesReqs  []*monitoringpb.CreateTimeSeriesRequest\n\tRetryCount                   int\n\tmu                           sync.Mutex\n}\n\nfunc NewMetricTestServer() (*MetricsTestServer, error) {\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserver := &MetricsTestServer{\n\t\tlis: lis,\n\t\tsrv: grpc.NewServer(grpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tTime:    5 * 60 * 1000, // 5 minutes\n\t\t\tTimeout: 20 * 1000,     // 20 seconds\n\t\t})),\n\t\tEndpoint: lis.Addr().String(),\n\t}\n\n\tmonitoringpb.RegisterMetricServiceServer(server.srv, server)\n\treturn server, nil\n}\n\nfunc (s *MetricsTestServer) Serve() error {\n\treturn s.srv.Serve(s.lis)\n}\n\nfunc (s *MetricsTestServer) Shutdown() {\n\ts.srv.GracefulStop()\n}\n\nfunc (s *MetricsTestServer) UserAgent() string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tua := s.userAgent\n\ts.userAgent = \"\"\n\treturn ua\n}\n\nfunc (s *MetricsTestServer) CreateServiceTimeSeriesRequests() []*monitoringpb.CreateTimeSeriesRequest {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treqs := s.createServiceTimeSeriesReqs\n\ts.createServiceTimeSeriesReqs = nil\n\treturn reqs\n}\n\nfunc (s *MetricsTestServer) appendCreateMetricDescriptorReq(ctx context.Context, req *monitoringpb.CreateMetricDescriptorRequest) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.createMetricDescriptorReqs = append(s.createMetricDescriptorReqs, req)\n}\n\nfunc (s *MetricsTestServer) appendCreateServiceTimeSeriesReq(ctx context.Context, req *monitoringpb.CreateTimeSeriesRequest) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.createServiceTimeSeriesReqs = append(s.createServiceTimeSeriesReqs, req)\n\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tif ua := md[\"user-agent\"]; len(ua) > 0 {\n\t\t\ts.userAgent = ua[0]\n\t\t}\n\t}\n}\n\nfunc (s *MetricsTestServer) CreateMetricDescriptor(ctx context.Context, req *monitoringpb.CreateMetricDescriptorRequest) (*monitoringpb.MetricDescriptor, error) {\n\ts.appendCreateMetricDescriptorReq(ctx, req)\n\treturn req.MetricDescriptor, nil\n}\n\nfunc (s *MetricsTestServer) CreateTimeSeries(ctx context.Context, req *monitoringpb.CreateTimeSeriesRequest) (*monitoringpb.CreateTimeSeriesResponse, error) {\n\ts.appendCreateServiceTimeSeriesReq(ctx, req)\n\treturn &monitoringpb.CreateTimeSeriesResponse{}, nil\n}\n\nfunc main() {\n\tserver, err := NewMetricTestServer()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer server.Shutdown()\n\n\tif err := server.Serve(); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a mock gRPC server for OpenTelemetry traces receiver that can handle incoming trace data requests, track request metrics, and optionally use TLS for secure communication.\n\nStruct Description: The mockTracesReceiver struct implements a gRPC server for receiving OpenTelemetry trace data, tracking request counts and spans, and handling metadata. It embeds a base mockReceiver struct and implements the ptraceotlp.GRPCServer interface.\n\nFields:\n\nsrv: [*grpc.Server] - The gRPC server instance\nln: [net.Listener] - Network listener for the server\nrequestCount: [*atomic.Int32] - Counter for received requests\ntotalItems: [*atomic.Int32] - Counter for total spans received\nmux: [sync.Mutex] - Mutex for thread-safe operations\nmetadata: [metadata.MD] - Stores metadata from incoming requests\nexportError: [error] - Error to return from export operations\nexportResponse: [func() ptraceotlp.ExportResponse] - Function to generate export responses\nlastRequest: [ptrace.Traces] - Stores the last received trace data\nhasMetadata: [bool] - Flag indicating whether to process metadata\nspanCountByMetadata: [map[string]int] - Tracks span counts by metadata keys\n\nMethods:\n\nExport: [Name](ctx context.Context, req ptraceotlp.ExportRequest) -> (ptraceotlp.ExportResponse, error) - Handles incoming trace export requests, updates counters, and processes metadata\nstart: [Name]() -> () - Starts the gRPC server in a goroutine\n\nAssociated Functions:\n\notelArrowTracesReceiverOnGRPCServer: [Name](ln net.Listener, useTLS bool) -> (*mockTracesReceiver, error) - Creates and configures a new mock traces receiver with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"go.opentelemetry.io/collector/pdata/ptrace\"\n\t\"go.opentelemetry.io/collector/pdata/ptrace/ptraceotlp\"\n)\n\ntype mockReceiver struct {\n\tsrv          *grpc.Server\n\tln           net.Listener\n\trequestCount *atomic.Int32\n\ttotalItems   *atomic.Int32\n\tmux          sync.Mutex\n\tmetadata     metadata.MD\n\texportError  error\n}\n\ntype mockTracesReceiver struct {\n\tptraceotlp.UnimplementedGRPCServer\n\tmockReceiver\n\texportResponse      func() ptraceotlp.ExportResponse\n\tlastRequest         ptrace.Traces\n\thasMetadata         bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (r *mockTracesReceiver) Export(ctx context.Context, req ptraceotlp.ExportRequest) (ptraceotlp.ExportResponse, error) {\n\tr.requestCount.Add(int32(1))\n\ttd := req.Traces()\n\tr.totalItems.Add(int32(td.SpanCount()))\n\tr.mux.Lock()\n\tdefer r.mux.Unlock()\n\tr.metadata, _ = metadata.FromIncomingContext(ctx)\n\tif r.hasMetadata {\n\t\tv1 := r.metadata.Get(\"key1\")\n\t\tv2 := r.metadata.Get(\"key2\")\n\t\thashKey := fmt.Sprintf(\"%s|%s\", v1, v2)\n\t\tr.spanCountByMetadata[hashKey] += (td.SpanCount())\n\t}\n\tr.lastRequest = td\n\treturn r.exportResponse(), r.exportError\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\tsopts := []grpc.ServerOption{}\n\n\tif useTLS {\n\t\t_, currentFile, _, _ := runtime.Caller(0)\n\t\tbasepath := filepath.Dir(currentFile)\n\t\tcertpath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_cert.pem\"))\n\t\tkeypath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_key.pem\"))\n\n\t\tcreds, err := credentials.NewServerTLSFromFile(certpath, keypath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsopts = append(sopts, grpc.Creds(creds))\n\t}\n\n\trcv := &mockTracesReceiver{\n\t\tmockReceiver: mockReceiver{\n\t\t\tsrv:          grpc.NewServer(sopts...),\n\t\t\tln:           ln,\n\t\t\trequestCount: &atomic.Int32{},\n\t\t\ttotalItems:   &atomic.Int32{},\n\t\t},\n\t\texportResponse: ptraceotlp.NewExportResponse,\n\t}\n\n\tptraceotlp.RegisterGRPCServer(rcv.srv, rcv)\n\n\treturn rcv, nil\n}\n\nfunc (r *mockTracesReceiver) start() {\n\tgo func() {\n\t\t_ = r.srv.Serve(r.ln)\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.opentelemetry.io/otel/trace/ptraceotlp\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"go.uber.org/atomic\"\n)\n\ntype mockReceiver struct{}\n\ntype mockTracesReceiver struct {\n\tmockReceiver\n\tsrv                *grpc.Server\n\tln                 net.Listener\n\trequestCount       *atomic.Int32\n\ttotalItems         *atomic.Int32\n\tmux                sync.Mutex\n\tmetadata           metadata.MD\n\texportError        error\n\texportResponse     func() ptraceotlp.ExportResponse\n\tlastRequest        trace.Traces\n\thasMetadata        bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (m *mockTracesReceiver) Export(ctx context.Context, req ptraceotlp.ExportRequest) (ptraceotlp.ExportResponse, error) {\n\tm.mux.Lock()\n\tdefer m.mux.Unlock()\n\n\tm.requestCount.Inc()\n\tm.totalItems.Add(int32(len(req.Traces().Spans())))\n\n\tif m.hasMetadata {\n\t\tmd, ok := metadata.FromIncomingContext(ctx)\n\t\tif ok {\n\t\t\tm.metadata = md\n\t\t\tfor key, values := range md {\n\t\t\t\tm.spanCountByMetadata[key] += len(values)\n\t\t\t}\n\t\t}\n\t}\n\n\tm.lastRequest = req.Traces()\n\n\tif m.exportError != nil {\n\t\treturn nil, m.exportError\n\t}\n\n\tif m.exportResponse != nil {\n\t\treturn m.exportResponse(), nil\n\t}\n\n\treturn ptraceotlp.NewExportResponse(), nil\n}\n\nfunc (m *mockTracesReceiver) start() {\n\tgo func() {\n\t\tif err := m.srv.Serve(m.ln); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\tvar opts []grpc.ServerOption\n\tif useTLS {\n\t\tcreds := credentials.NewTLS(&tls.Config{\n\t\t\t// Configure TLS settings here\n\t\t})\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\tsrv := grpc.NewServer(opts...)\n\treceiver := &mockTracesReceiver{\n\t\tsrv:                srv,\n\t\tln:                 ln,\n\t\trequestCount:       atomic.NewInt32(0),\n\t\ttotalItems:         atomic.NewInt32(0),\n\t\tspanCountByMetadata: make(map[string]int),\n\t}\n\n\tptraceotlp.RegisterGRPCServer(srv, receiver)\n\treceiver.start()\n\n\treturn receiver, nil\n}\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":4317\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = otelArrowTracesReceiverOnGRPCServer(ln, false)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC server with basic lifecycle management capabilities, including initialization, startup, and shutdown.\n\nStruct Description: The Server struct represents a gRPC server instance with network listening capabilities. It manages the server lifecycle and provides methods to start and stop the server gracefully.\n\nFields:\nAddr: [string] - The network address (IP:port) where the server is listening\nPort: [int] - The port number on which the server is listening\nl: [net.Listener] - The network listener for incoming connections\nGsrv: [*grpc.Server] - The gRPC server instance\n\nMethods:\nNewServer: [func(opts ...grpc.ServerOption) (*Server, error)] -> [*Server, error] - Creates a new Server instance with default settings (random available port)\nNewServerWithPort: [func(port int, opts ...grpc.ServerOption) (*Server, error)] -> [*Server, error] - Creates a new Server instance on the specified port\nStart: [func()] -> [] - Starts the gRPC server in a goroutine to handle incoming requests\nClose: [func()] -> [] - Gracefully stops the gRPC server and closes the network listener",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tPort int\n\tl    net.Listener\n\tGsrv *grpc.Server\n}\n\nfunc NewServer(opts ...grpc.ServerOption) (*Server, error) {\n\treturn NewServerWithPort(0, opts...)\n}\n\nfunc NewServerWithPort(port int, opts ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"127.0.0.1:%d\", port))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tAddr: l.Addr().String(),\n\t\tPort: parsePort(l.Addr().String()),\n\t\tl:    l,\n\t\tGsrv: grpc.NewServer(opts...),\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) Start() {\n\tgo func() {\n\t\tif err := s.Gsrv.Serve(s.l); err != nil {\n\t\t\tlog.Printf(\"testutil.Server.Start: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Close() {\n\ts.Gsrv.Stop()\n\ts.l.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tPort int\n\tl    net.Listener\n\tGsrv *grpc.Server\n}\n\nfunc NewServer(opts ...grpc.ServerOption) (*Server, error) {\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tport := lis.Addr().(*net.TCPAddr).Port\n\taddr := lis.Addr().String()\n\tgsrv := grpc.NewServer(opts...)\n\treturn &Server{\n\t\tAddr: addr,\n\t\tPort: port,\n\t\tl:    lis,\n\t\tGsrv: gsrv,\n\t}, nil\n}\n\nfunc NewServerWithPort(port int, opts ...grpc.ServerOption) (*Server, error) {\n\tlis, err := net.Listen(\"tcp\", \":\"+strconv.Itoa(port))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\taddr := lis.Addr().String()\n\tgsrv := grpc.NewServer(opts...)\n\treturn &Server{\n\t\tAddr: addr,\n\t\tPort: port,\n\t\tl:    lis,\n\t\tGsrv: gsrv,\n\t}, nil\n}\n\nfunc (s *Server) Start() {\n\tgo func() {\n\t\tif err := s.Gsrv.Serve(s.l); err != nil {\n\t\t\tfmt.Printf(\"Failed to serve: %v\\n\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Close() {\n\ts.Gsrv.GracefulStop()\n\ts.l.Close()\n}\n```"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles unary RPC calls for an Echo service, including secure communication with transport credentials.\n\nFunction Description: The `startGRPCServer` function initializes and starts a gRPC server with the provided listener and transport credentials. It registers an Echo service implementation and begins serving incoming requests.\n\nInput:\n- `lis` [net.Listener] - A network listener that specifies the address and port to listen on\n- `creds` [credentials.TransportCredentials] - Transport credentials for secure communication (TLS)\n\nOutput:\n- `error` - Returns an error if the server fails to start or encounters a fatal error during operation, otherwise runs indefinitely serving requests",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype ecServer struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *ecServer) UnaryEcho(_ context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.Message}, nil\n}\n\nfunc newServer() *ecServer {\n\treturn &ecServer{}\n}\n\nfunc startGRPCServer(lis net.Listener, creds credentials.TransportCredentials) error {\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, newServer())\n\treturn s.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n)\n\n// EchoServiceServer is the server API for EchoService service.\ntype EchoServiceServer interface {\n\tEcho(context.Context, *EchoRequest) (*EchoResponse, error)\n}\n\n// UnimplementedEchoServiceServer can be embedded to have forward compatible implementations.\ntype UnimplementedEchoServiceServer struct{}\n\nfunc (*UnimplementedEchoServiceServer) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {\n\treturn &EchoResponse{Message: req.Message}, nil\n}\n\n// EchoRequest is the request message for Echo service.\ntype EchoRequest struct {\n\tMessage string\n}\n\n// EchoResponse is the response message for Echo service.\ntype EchoResponse struct {\n\tMessage string\n}\n\n// EchoService is the implementation of EchoServiceServer.\ntype EchoService struct {\n\tUnimplementedEchoServiceServer\n}\n\n// startGRPCServer initializes and starts a gRPC server with the provided listener and transport credentials.\nfunc startGRPCServer(lis net.Listener, creds credentials.TransportCredentials) error {\n\tserver := grpc.NewServer(grpc.Creds(creds))\n\techoService := &EchoService{}\n\tRegisterEchoServiceServer(server, echoService)\n\n\tfmt.Println(\"Starting gRPC server...\")\n\tif err := server.Serve(lis); err != nil {\n\t\treturn fmt.Errorf(\"failed to serve: %v\", err)\n\t}\n\treturn nil\n}\n\n// RegisterEchoServiceServer registers the EchoServiceServer to the gRPC server.\nfunc RegisterEchoServiceServer(s *grpc.Server, srv EchoServiceServer) {\n\ts.RegisterService(&_EchoService_serviceDesc, srv)\n}\n\nvar _EchoService_serviceDesc = grpc.ServiceDesc{\n\tServiceName: \"EchoService\",\n\tHandlerType: (*EchoServiceServer)(nil),\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"Echo\",\n\t\t\tHandler:    _EchoService_Echo_Handler,\n\t\t},\n\t},\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"echo.proto\",\n}\n\nfunc _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\tin := new(EchoRequest)\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n\tif interceptor == nil {\n\t\treturn srv.(EchoServiceServer).Echo(ctx, in)\n\t}\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/EchoService/Echo\",\n\t}\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(EchoServiceServer).Echo(ctx, req.(*EchoRequest))\n\t}\n\treturn interceptor(ctx, in, info, handler)\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the specified gRPC service.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified TCP port, configures keepalive policies, registers the Echo service, and starts serving requests. It handles any errors that occur during setup or serving.\n\nInput: \n- port (string): The port number on which the server should listen, formatted as a string (e.g., \":50051\").\n- kaep (keepalive.EnforcementPolicy): The keepalive enforcement policy for the server.\n- kasp (keepalive.ServerParameters): The keepalive server parameters.\n\nOutput: \n- None (the function runs indefinitely until an error occurs or the server is stopped).\n- Errors during setup or serving are logged and the program exits.\n\nNote: The function assumes the existence of a pre-defined `server` struct that implements the `EchoServer` interface from the generated protobuf code.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\taddress := fmt.Sprintf(\":%v\", *port)\n\tlis, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype server struct{}\n\nfunc main() {\n\tport := \":50051\"\n\tkaep := keepalive.EnforcementPolicy{\n\t\tMinTime:             5 * time.Minute,\n\t\tPermitWithoutStream: true,\n\t}\n\tkasp := keepalive.ServerParameters{\n\t\tTime:    2 * time.Hour,\n\t\tTimeout: 20 * time.Second,\n\t}\n\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(\n\t\tgrpc.KeepaliveEnforcementPolicy(kaep),\n\t\tgrpc.KeepaliveParams(kasp),\n\t)\n\n\tRegisterEchoServer(s, &server{})\n\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Create a function to start a gRPC server for signal exchange, including setting up a network listener and registering the server with gRPC.\n\nFunction Description: The function `startSignal` initializes and starts a gRPC server for signal exchange. It creates a TCP listener on an available port, initializes a new gRPC server instance, registers the signal exchange service, and starts the server in a goroutine. The function is designed for testing purposes and includes error handling.\n\nInput: \n- `t *testing.T`: A testing context for error reporting and test helpers.\n\nOutput:\n- `*grpc.Server`: The created gRPC server instance.\n- `net.Listener`: The network listener used by the gRPC server.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\n\tsigProto \"github.com/netbirdio/netbird/signal/proto\"\n\tsig \"github.com/netbirdio/netbird/signal/server\"\n)\n\nfunc startSignal(t *testing.T) (*grpc.Server, net.Listener) {\n\tt.Helper()\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts := grpc.NewServer()\n\tsrv, err := sig.NewServer(context.Background(), otel.Meter(\"\"))\n\trequire.NoError(t, err)\n\n\tsigProto.RegisterSignalExchangeServer(s, srv)\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\treturn s, lis\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc startSignal(t *testing.T) (*grpc.Server, net.Listener) {\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create listener: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\n\t// Register your signal exchange service here\n\t// pb.RegisterSignalExchangeService(server, &SignalExchangeService{})\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tt.Fatalf(\"Failed to serve gRPC server: %v\", err)\n\t\t}\n\t}()\n\n\treturn server, listener\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a gRPC server for a translation service that can handle text translation requests and return mock translations for testing purposes.\n\nStruct Description: The fakeTranslationServer struct implements a mock gRPC server for the TranslationService, providing a simple translation response without requiring an actual translation service.\n\nFields:\n- UnimplementedTranslationServiceServer: embed - Base type from translatepb package that provides default implementations for all service methods\n\nMethods:\n- TranslateText: [Name](ctx context.Context, req *translatepb.TranslateTextRequest) -> (*translatepb.TranslateTextResponse, error) - Handles translation requests by returning a mock response containing \"Hello World\" as the translated text",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\ttranslate \"cloud.google.com/go/translate/apiv3\"\n\t\"cloud.google.com/go/translate/apiv3/translatepb\"\n\t\"google.golang.org/api/option\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (f *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\tresp := &translatepb.TranslateTextResponse{\n\t\tTranslations: []*translatepb.Translation{\n\t\t\t{TranslatedText: \"Hello World\"},\n\t\t},\n\t}\n\treturn resp, nil\n}\n\nfunc TestTranslateTextWithConcreteClient(t *testing.T) {\n\tctx := context.Background()\n\n\tfakeTranslationServer := &fakeTranslationServer{}\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgsrv := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(gsrv, fakeTranslationServer)\n\tfakeServerAddr := l.Addr().String()\n\tgo func() {\n\t\tif err := gsrv.Serve(l); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tclient, err := translate.NewTranslationClient(ctx,\n\t\toption.WithEndpoint(fakeServerAddr),\n\t\toption.WithoutAuthentication(),\n\t\toption.WithGRPCDialOption(grpc.WithInsecure()),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\ttranslatepb \"path/to/your/protobuf/package\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (s *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\treturn &translatepb.TranslateTextResponse{\n\t\tTranslatedText: \"Hello World\",\n\t}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(grpcServer, &fakeTranslationServer{})\n\treflection.Register(grpcServer)\n\n\tlog.Println(\"gRPC server is running on port 50051\")\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "The provided reference code is at the function level, so I'll provide instructions in the function-level format:\n\nTask Description: Implement a gRPC server setup in Go that handles both Unix domain sockets and TCP connections with TLS support and keepalive configurations.\n\nFunction Description: The code consists of two main functions for setting up a gRPC server: `createListener` creates a network listener for the server, and `grpcServer` configures and creates a gRPC server instance with optional TLS and keepalive settings.\n\nInput:\n1. For `createListener` function:\n   - config [Config] - Configuration object containing listener address and other settings\n\n2. For `grpcServer` function:\n   - config [Config] - Configuration object containing gRPC server settings and TLS configuration\n\nOutput:\n1. For `createListener` function:\n   - [net.Listener] - Network listener ready for gRPC server\n   - [error] - Error if listener creation fails\n\n2. For `grpcServer` function:\n   - [*grpc.Server] - Configured gRPC server instance\n   - [error] - Error if server creation fails\n\nThe Config struct used as input is defined as:\n- GRPCServer [*grpc.Server] - Optional pre-configured gRPC server instance\n- Listener [string] - Network address to listen on (e.g., \"unix:///path/to/socket\" or \"tcp://:port\")\n- Endpoint [string] - Server endpoint\n- ServerTLSConfig [tls.Config] - TLS configuration for secure connections",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/k3s-io/kine/pkg/util\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"go.etcd.io/etcd/server/v3/embed\"\n)\n\ntype Config struct {\n\tGRPCServer           *grpc.Server\n\tListener             string\n\tEndpoint             string\n\tServerTLSConfig      tls.Config\n}\n\nfunc createListener(config Config) (ret net.Listener, rerr error) {\n\tif config.Listener == \"\" {\n\t\tconfig.Listener = KineSocket\n\t}\n\tscheme, address := util.SchemeAndAddress(config.Listener)\n\n\tif scheme == \"unix\" {\n\t\tif err := os.Remove(address); err != nil && !os.IsNotExist(err) {\n\t\t\tlogrus.Warnf(\"failed to remove socket %s: %v\", address, err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := os.Chmod(address, 0600); err != nil {\n\t\t\t\trerr = err\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tscheme = \"tcp\"\n\t}\n\n\treturn net.Listen(scheme, address)\n}\n\nfunc grpcServer(config Config) (*grpc.Server, error) {\n\tif config.GRPCServer != nil {\n\t\treturn config.GRPCServer, nil\n\t}\n\n\tgopts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{\n\t\t\tMinTime:             embed.DefaultGRPCKeepAliveMinTime,\n\t\t\tPermitWithoutStream: false,\n\t\t}),\n\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tTime:    embed.DefaultGRPCKeepAliveInterval,\n\t\t\tTimeout: embed.DefaultGRPCKeepAliveTimeout,\n\t\t}),\n\t}\n\n\tif config.ServerTLSConfig.CertFile != \"\" && config.ServerTLSConfig.KeyFile != \"\" {\n\t\tcreds, err := credentials.NewServerTLSFromFile(config.ServerTLSConfig.CertFile, config.ServerTLSConfig.KeyFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgopts = append(gopts, grpc.Creds(creds))\n\t}\n\n\treturn grpc.NewServer(gopts...), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype Config struct {\n\tGRPCServer     *grpc.Server\n\tListener       string\n\tEndpoint       string\n\tServerTLSConfig tls.Config\n}\n\nfunc createListener(config Config) (net.Listener, error) {\n\tvar network, address string\n\tif strings.HasPrefix(config.Listener, \"unix://\") {\n\t\tnetwork = \"unix\"\n\t\taddress = strings.TrimPrefix(config.Listener, \"unix://\")\n\t} else if strings.HasPrefix(config.Listener, \"tcp://\") {\n\t\tnetwork = \"tcp\"\n\t\taddress = strings.TrimPrefix(config.Listener, \"tcp://\")\n\t} else {\n\t\treturn nil, fmt.Errorf(\"unsupported network type\")\n\t}\n\n\tlistener, err := net.Listen(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn listener, nil\n}\n\nfunc grpcServer(config Config) (*grpc.Server, error) {\n\tvar opts []grpc.ServerOption\n\n\tif config.ServerTLSConfig != (tls.Config{}) {\n\t\tcreds := credentials.NewTLS(&config.ServerTLSConfig)\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\tkaParams := keepalive.ServerParameters{\n\t\tTime:    10 * time.Minute,\n\t\tTimeout: 20 * time.Second,\n\t}\n\topts = append(opts, grpc.KeepaliveParams(kaParams))\n\n\tif config.GRPCServer != nil {\n\t\treturn config.GRPCServer, nil\n\t}\n\n\tserver := grpc.NewServer(opts...)\n\treturn server, nil\n}\n```"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a gRPC server in Go that implements an echo service and health checking functionality. The server should listen on a specified port, handle incoming gRPC requests, and periodically toggle its health status between SERVING and NOT_SERVING states.\n\nFunction Description: The main function sets up a gRPC server with echo service and health check capabilities. It creates a TCP listener, initializes the gRPC server, registers services, and starts serving requests. A background goroutine periodically changes the health status for demonstration purposes.\n\nInput:\n- port (int): The TCP port number on which the server should listen\n- sleep (time.Duration): The interval at which health status should toggle\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Errors are logged if they occur during server setup or operation\n\nNote: The function uses package-level variables for port and sleep duration (typically set via command-line flags) and assumes the existence of an echoServer struct that implements the Echo service interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n\t\"google.golang.org/grpc/health\"\n\thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n\thealthpb \"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\thealthcheck := health.NewServer()\n\thealthgrpc.RegisterHealthServer(s, healthcheck)\n\tpb.RegisterEchoServer(s, &echoServer{})\n\n\tgo func() {\n\t\tnext := healthpb.HealthCheckResponse_SERVING\n\n\t\tfor {\n\t\t\thealthcheck.SetServingStatus(system, next)\n\n\t\t\tif next == healthpb.HealthCheckResponse_SERVING {\n\t\t\t\tnext = healthpb.HealthCheckResponse_NOT_SERVING\n\t\t\t} else {\n\t\t\t\tnext = healthpb.HealthCheckResponse_SERVING\n\t\t\t}\n\n\t\t\ttime.Sleep(*sleep)\n\t\t}\n\t}()\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\n\nvar (\n\tport  = flag.Int(\"port\", 50051, \"The server port\")\n\tsleep = flag.Duration(\"sleep\", 5*time.Second, \"Health status toggle interval\")\n)\n\ntype echoServer struct{}\n\nfunc (s *echoServer) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {\n\treturn &EchoResponse{Message: req.Message}, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\tRegisterEchoServer(grpcServer, &echoServer{})\n\n\thealthServer := health.NewServer()\n\tgrpc_health_v1.RegisterHealthServer(grpcServer, healthServer)\n\n\tgo func() {\n\t\tstatus := grpc_health_v1.HealthCheckResponse_SERVING\n\t\tfor {\n\t\t\thealthServer.SetServingStatus(\"\", status)\n\t\t\tif status == grpc_health_v1.HealthCheckResponse_SERVING {\n\t\t\t\tstatus = grpc_health_v1.HealthCheckResponse_NOT_SERVING\n\t\t\t} else {\n\t\t\t\tstatus = grpc_health_v1.HealthCheckResponse_SERVING\n\t\t\t}\n\t\t\ttime.Sleep(*sleep)\n\t\t}\n\t}()\n\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\tif err := grpcServer.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Implement a gRPC server in Go that provides a simple key-value store service with various RPC methods for setting, getting, and streaming items.\n\nStruct Description: The intStoreServer struct implements a gRPC server for a key-value store service, handling item storage and retrieval operations through different RPC patterns (unary, server streaming, client streaming, and bidirectional streaming).\n\nFields:\nAddr: string - The network address where the server is listening\nl: net.Listener - The network listener for incoming connections\ngsrv: *grpc.Server - The gRPC server instance\nitems: map[string]int32 - The internal storage for key-value pairs\n\nMethods:\nnewIntStoreServer: () -> *intStoreServer - Creates and starts a new server instance on an available port\nstop: () -> () - Gracefully shuts down the server\nSet: (context.Context, *pb.Item) -> (*pb.SetResponse, error) - Unary RPC to set a key-value pair\nsetItem: (*pb.Item) -> int32 - Internal helper method to store an item\nGet: (context.Context, *pb.GetRequest) -> (*pb.Item, error) - Unary RPC to retrieve a value by key\nListItems: (*pb.ListItemsRequest, pb.IntStore_ListItemsServer) -> error - Server streaming RPC to list items matching criteria\nSetStream: (pb.IntStore_SetStreamServer) -> error - Client streaming RPC to set multiple items\nStreamChat: (pb.IntStore_StreamChatServer) -> error - Bidirectional streaming RPC for chat-like communication",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"cloud.google.com/go/rpcreplay/proto/intstore\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype intStoreServer struct {\n\tpb.IntStoreServer\n\n\tAddr string\n\tl    net.Listener\n\tgsrv *grpc.Server\n\n\titems map[string]int32\n}\n\nfunc newIntStoreServer() *intStoreServer {\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := &intStoreServer{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tgsrv: grpc.NewServer(),\n\t}\n\tpb.RegisterIntStoreServer(s.gsrv, s)\n\tgo s.gsrv.Serve(s.l)\n\treturn s\n}\n\nfunc (s *intStoreServer) stop() {\n\ts.gsrv.Stop()\n\ts.l.Close()\n}\n\nfunc (s *intStoreServer) Set(_ context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\told := s.setItem(item)\n\treturn &pb.SetResponse{PrevValue: old}, nil\n}\n\nfunc (s *intStoreServer) setItem(item *pb.Item) int32 {\n\tif s.items == nil {\n\t\ts.items = map[string]int32{}\n\t}\n\told := s.items[item.Name]\n\ts.items[item.Name] = item.Value\n\treturn old\n}\n\nfunc (s *intStoreServer) Get(_ context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\tval, ok := s.items[req.Name]\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.NotFound, \"%q\", req.Name)\n\t}\n\treturn &pb.Item{Name: req.Name, Value: val}, nil\n}\n\nfunc (s *intStoreServer) ListItems(req *pb.ListItemsRequest, ss pb.IntStore_ListItemsServer) error {\n\tfor name, val := range s.items {\n\t\tif val > req.GreaterThan {\n\t\t\tif err := ss.Send(&pb.Item{Name: name, Value: val}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *intStoreServer) SetStream(ss pb.IntStore_SetStreamServer) error {\n\tn := 0\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.setItem(item)\n\t\tn++\n\t}\n\treturn ss.SendAndClose(&pb.Summary{Count: int32(n)})\n}\n\nfunc (s *intStoreServer) StreamChat(ss pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ss.Send(item); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype intStoreServer struct {\n\tpb.UnimplementedIntStoreServer\n\tAddr  string\n\tl     net.Listener\n\tgsrv  *grpc.Server\n\titems map[string]int32\n\tmu    sync.Mutex\n}\n\nfunc newIntStoreServer() *intStoreServer {\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := &intStoreServer{\n\t\tAddr:  lis.Addr().String(),\n\t\tl:     lis,\n\t\tgsrv:  grpc.NewServer(),\n\t\titems: make(map[string]int32),\n\t}\n\tpb.RegisterIntStoreServer(s.gsrv, s)\n\tgo func() {\n\t\tif err := s.gsrv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\treturn s\n}\n\nfunc (s *intStoreServer) stop() {\n\ts.gsrv.GracefulStop()\n\ts.l.Close()\n}\n\nfunc (s *intStoreServer) Set(ctx context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\tvalue := s.setItem(item)\n\treturn &pb.SetResponse{Value: value}, nil\n}\n\nfunc (s *intStoreServer) setItem(item *pb.Item) int32 {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.items[item.Key] = item.Value\n\treturn item.Value\n}\n\nfunc (s *intStoreServer) Get(ctx context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tvalue, exists := s.items[req.Key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"key not found: %s\", req.Key)\n\t}\n\treturn &pb.Item{Key: req.Key, Value: value}, nil\n}\n\nfunc (s *intStoreServer) ListItems(req *pb.ListItemsRequest, stream pb.IntStore_ListItemsServer) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tfor key, value := range s.items {\n\t\tif err := stream.Send(&pb.Item{Key: key, Value: value}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *intStoreServer) SetStream(stream pb.IntStore_SetStreamServer) error {\n\tfor {\n\t\titem, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.setItem(item)\n\t}\n}\n\nfunc (s *intStoreServer) StreamChat(stream pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\titem, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresponse := &pb.Item{Key: item.Key, Value: s.setItem(item)}\n\t\tif err := stream.Send(response); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc main() {\n\tserver := newIntStoreServer()\n\tdefer server.stop()\n\tfmt.Printf(\"Server listening on %s\\n\", server.Addr)\n\tselect {}\n}"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC server with configurable network settings, TLS security, and keepalive parameters.\n\nStruct Description: The Server struct represents a gRPC server instance with network listener capabilities. It provides methods to start and stop the server, and handles configuration of security and connection parameters.\n\nFields:\nListener: [net.Listener] - The network listener for incoming connections\nServer: [*grpc.Server] - The gRPC server instance\n\nMethods:\nStart: [Name]() -> [error] - Starts the gRPC server and begins listening for incoming requests. Returns an error if the listener or server is not initialized.\nStop: [Name]() -> [void] - Gracefully stops the gRPC server if it's running.\nNewServer: [Name](address string, tlsConf *tls.Config, srvKaOpts *keepalive.ServerParameters) -> (*Server, error) - Creates a new Server instance with the specified address, TLS configuration, and keepalive parameters. Sets up default values for message sizes, connection timeout, and enforcement policy if not provided. Returns the server instance or an error if initialization fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype Server struct {\n\tListener net.Listener\n\tServer   *grpc.Server\n}\n\nfunc (s *Server) Start() error {\n\tif s.Listener == nil {\n\t\treturn errors.New(\"nil listener\")\n\t}\n\n\tif s.Server == nil {\n\t\treturn errors.New(\"nil server\")\n\t}\n\n\treturn s.Server.Serve(s.Listener)\n}\n\nfunc (s *Server) Stop() {\n\tif s.Server != nil {\n\t\ts.Server.Stop()\n\t}\n}\n\nfunc NewServer(\n\taddress string,\n\ttlsConf *tls.Config,\n\tsrvKaOpts *keepalive.ServerParameters,\n) (*Server, error) {\n\tif address == \"\" {\n\t\treturn nil, errors.New(\"server listen address not provided\")\n\t}\n\n\tlistener, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar serverOpts []grpc.ServerOption\n\n\tif srvKaOpts != nil {\n\t\tserverOpts = append(serverOpts, grpc.KeepaliveParams(*srvKaOpts))\n\t} else {\n\t\tserverKeepAliveParameters := keepalive.ServerParameters{\n\t\t\tTime:    1 * time.Minute,\n\t\t\tTimeout: 20 * time.Second,\n\t\t}\n\t\tserverOpts = append(serverOpts, grpc.KeepaliveParams(serverKeepAliveParameters))\n\t}\n\n\tif tlsConf != nil {\n\t\tserverOpts = append(serverOpts, grpc.Creds(credentials.NewTLS(tlsConf)))\n\t}\n\n\tserverOpts = append(serverOpts, grpc.MaxSendMsgSize(maxSendMessageSize))\n\tserverOpts = append(serverOpts, grpc.MaxRecvMsgSize(maxRecvMessageSize))\n\n\tkep := keepalive.EnforcementPolicy{\n\t\tMinTime:             serverMinInterval,\n\t\tPermitWithoutStream: true,\n\t}\n\tserverOpts = append(serverOpts, grpc.KeepaliveEnforcementPolicy(kep))\n\n\tserverOpts = append(serverOpts, grpc.ConnectionTimeout(connectionTimeout))\n\n\tserver := grpc.NewServer(serverOpts...)\n\n\treturn &Server{Listener: listener, Server: server}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype Server struct {\n\tListener net.Listener\n\tServer   *grpc.Server\n}\n\nfunc NewServer(address string, tlsConf *tls.Config, srvKaOpts *keepalive.ServerParameters) (*Server, error) {\n\tlistener, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar opts []grpc.ServerOption\n\tif tlsConf != nil {\n\t\topts = append(opts, grpc.Creds(credentials.NewTLS(tlsConf)))\n\t}\n\n\tif srvKaOpts != nil {\n\t\topts = append(opts, grpc.KeepaliveParams(*srvKaOpts))\n\t} else {\n\t\topts = append(opts, grpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tTime:    10 * time.Minute,\n\t\t\tTimeout: 20 * time.Second,\n\t\t}))\n\t}\n\n\topts = append(opts, grpc.MaxRecvMsgSize(1024*1024*4), grpc.MaxSendMsgSize(1024*1024*4))\n\n\tserver := grpc.NewServer(opts...)\n\treturn &Server{Listener: listener, Server: server}, nil\n}\n\nfunc (s *Server) Start() error {\n\tif s.Listener == nil || s.Server == nil {\n\t\treturn errors.New(\"server not properly initialized\")\n\t}\n\treturn s.Server.Serve(s.Listener)\n}\n\nfunc (s *Server) Stop() {\n\tif s.Server != nil {\n\t\ts.Server.GracefulStop()\n\t}\n}"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that sets up and starts a mock gRPC server for management service testing, including generating a WireGuard key for authentication purposes.\n\nFunction Description: The function `startMockManagement` initializes and starts a mock gRPC server that implements a management service interface. It creates a TCP listener on an available port, generates a WireGuard key pair for server authentication, and registers mock implementations of the management service methods. The server runs in a goroutine to handle incoming requests asynchronously.\n\nInput: \n- t *testing.T: Testing context for error reporting and test helpers\n\nOutput:\n- *grpc.Server: The created gRPC server instance\n- net.Listener: The network listener for the server\n- *mock_server.ManagementServiceServerMock: The mock implementation of the management service\n- wgtypes.Key: The generated WireGuard private key for the server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\n\tmgmtProto \"github.com/netbirdio/netbird/management/proto\"\n\t\"github.com/netbirdio/netbird/management/server/mock_server\"\n\t\"golang.zx2c4.com/wireguard/wgctrl/wgtypes\"\n)\n\nfunc startMockManagement(t *testing.T) (*grpc.Server, net.Listener, *mock_server.ManagementServiceServerMock, wgtypes.Key) {\n\tt.Helper()\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ts := grpc.NewServer()\n\n\tserverKey, err := wgtypes.GenerateKey()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmgmtMockServer := &mock_server.ManagementServiceServerMock{\n\t\tGetServerKeyFunc: func(context.Context, *mgmtProto.Empty) (*mgmtProto.ServerKeyResponse, error) {\n\t\t\tresponse := &mgmtProto.ServerKeyResponse{\n\t\t\t\tKey: serverKey.PublicKey().String(),\n\t\t\t}\n\t\t\treturn response, nil\n\t\t},\n\t}\n\n\tmgmtProto.RegisterManagementServiceServer(s, mgmtMockServer)\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\treturn s, lis, mgmtMockServer, serverKey\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"golang.zx2c4.com/wireguard/wgctrl/wgtypes\"\n\t\"github.com/golang/mock/gomock\"\n\t\"example.com/mock_server\"\n)\n\nfunc startMockManagement(t *testing.T) (*grpc.Server, net.Listener, *mock_server.ManagementServiceServerMock, wgtypes.Key) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockService := mock_server.NewManagementServiceServerMock(ctrl)\n\n\tlistener, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create listener: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\tmock_server.RegisterManagementServiceServer(server, mockService)\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tt.Fatalf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\tprivateKey, err := wgtypes.GeneratePrivateKey()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to generate WireGuard key: %v\", err)\n\t}\n\n\treturn server, listener, mockService, privateKey\n}\n\nfunc main() {\n\t// This is just a placeholder to make the package executable.\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both querying and writing data with configurable settings like authentication, timeout, and TLS.\n\nStruct Description: The Client struct represents an InfluxDB client with configuration for server connection, authentication, and HTTP transport settings.\n\nFields:\n- url: url.URL - The base URL of the InfluxDB server\n- username: string - Username for basic authentication\n- password: string - Password for basic authentication\n- httpClient: *http.Client - Custom HTTP client with timeout and transport settings\n- userAgent: string - User agent string for HTTP requests\n- precision: string - Precision for timestamps in queries and writes\n\nMethods:\n- NewClient: [Name](Config) -> (*Client, error) - Creates a new InfluxDB client with the given configuration\n- Query: [Name](Query) -> (*Response, error) - Executes a query against the InfluxDB server and returns the response\n- Write: [Name](BatchPoints) -> (*Response, error) - Writes batch points to the InfluxDB server and returns the response",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: c.UnsafeSsl,\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) Query(q Query) (*Response, error) {\n\tu := c.url\n\n\tu.Path = \"query\"\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"GET\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = \"write\"\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage influxdb\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\ntype Config struct {\n\tURL        string\n\tUsername   string\n\tPassword   string\n\tTimeout    time.Duration\n\tTLSConfig  *tls.Config\n\tUserAgent  string\n\tPrecision  string\n}\n\ntype Query struct {\n\tCommand string\n}\n\ntype BatchPoints struct {\n\tPoints []Point\n}\n\ntype Point struct {\n\tMeasurement string\n\tTags        map[string]string\n\tFields      map[string]interface{}\n\tTimestamp   time.Time\n}\n\ntype Response struct {\n\tResults []Result\n}\n\ntype Result struct {\n\tSeries []Series\n}\n\ntype Series struct {\n\tName    string\n\tColumns []string\n\tValues  [][]interface{}\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tparsedURL, err := url.Parse(config.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thttpClient := &http.Client{\n\t\tTimeout: config.Timeout,\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: config.TLSConfig,\n\t\t},\n\t}\n\n\treturn &Client{\n\t\turl:        *parsedURL,\n\t\tusername:   config.Username,\n\t\tpassword:   config.Password,\n\t\thttpClient: httpClient,\n\t\tuserAgent:  config.UserAgent,\n\t\tprecision:  config.Precision,\n\t}, nil\n}\n\nfunc (c *Client) Query(query Query) (*Response, error) {\n\tqueryURL := c.url\n\tqueryURL.Path = \"/query\"\n\tparams := url.Values{}\n\tparams.Set(\"q\", query.Command)\n\tparams.Set(\"db\", \"mydb\")\n\tqueryURL.RawQuery = params.Encode()\n\n\treq, err := http.NewRequest(\"GET\", queryURL.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.username, c.password)\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to execute query\")\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(batchPoints BatchPoints) (*Response, error) {\n\twriteURL := c.url\n\twriteURL.Path = \"/write\"\n\tparams := url.Values{}\n\tparams.Set(\"db\", \"mydb\")\n\tparams.Set(\"precision\", c.precision)\n\twriteURL.RawQuery = params.Encode()\n\n\tvar buffer bytes.Buffer\n\tfor _, point := range batchPoints.Points {\n\t\tline := fmt.Sprintf(\"%s,%s %s %d\\n\", point.Measurement, formatTags(point.Tags), formatFields(point.Fields), point.Timestamp.UnixNano())\n\t\tbuffer.WriteString(line)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", writeURL.String(), &buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.username, c.password)\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Content-Type\", \"text/plain\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusNoContent {\n\t\treturn nil, errors.New(\"failed to write data\")\n\t}\n\n\treturn &Response{}, nil\n}\n\nfunc formatTags(tags map[string]string) string {\n\tvar result string\n\tfor k, v := range tags {\n\t\tresult += fmt.Sprintf(\"%s=%s,\", k, v)\n\t}\n\treturn result[:len(result)-1]\n}\n\nfunc formatFields(fields map[string]interface{}) string {\n\tvar result string\n\tfor k, v := range fields {\n\t\tresult += fmt.Sprintf(\"%s=%v,\", k, v)\n\t}\n\treturn result[:len(result)-1]\n}\n```"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Go struct that implements a RocketMQ push consumer with configurable options, message handling, and tracing capabilities.\n\nStruct Description: The PushConsumer struct encapsulates a RocketMQ push consumer with additional features like rate limiting, tracing, and message processing. It manages consumer lifecycle and message subscription.\n\nFields:\n\nname: string - Name identifier for the consumer  \nPushConsumer: rocketmq.PushConsumer - Embedded RocketMQ push consumer instance  \nPushConsumerConfig: PushConsumerConfig - Configuration for the consumer  \nsubscribers: map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error) - Map of topic to message handler functions  \ninterceptors: []primitive.Interceptor - List of interceptors for message processing  \nbucket: *ratelimit.Bucket - Rate limiter bucket for controlling consumption rate  \nstarted: bool - Flag indicating if consumer is running  \n\nMethods:\n\nRegisterSingleMessage: (f func(context.Context, *primitive.MessageExt) error) -> *PushConsumer - Registers a single message handler function with tracing and panic recovery  \nStart: () -> error - Initializes and starts the RocketMQ consumer with configured options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"runtime/debug\"\n\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/consumer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/juju/ratelimit\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.12.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype PushConsumer struct {\n\trocketmq.PushConsumer\n\tname string\n\tPushConsumerConfig\n\n\tsubscribers  map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)\n\tinterceptors []primitive.Interceptor\n\tbucket       *ratelimit.Bucket\n\tstarted      bool\n}\n\nfunc (cc *PushConsumer) RegisterSingleMessage(f func(context.Context, *primitive.MessageExt) error) *PushConsumer {\n\ttracer := xtrace.NewTracer(trace.SpanKindConsumer)\n\tattrs := []attribute.KeyValue{\n\t\tsemconv.MessagingSystemKey.String(\"rocketmq\"),\n\t\tsemconv.MessagingRocketmqClientGroupKey.String(cc.Group),\n\t\tsemconv.MessagingRocketmqClientIDKey.String(cc.InstanceName),\n\t\tsemconv.MessagingRocketmqConsumptionModelKey.String(cc.MessageModel),\n\t}\n\n\tfn := func(ctx context.Context, msgs ...*primitive.MessageExt) (result consumer.ConsumeResult, err error) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tresult, err = consumer.ConsumeRetryLater, errors.New(\"consumer message panic\")\n\t\t\t}\n\t\t}()\n\t\tfor _, msg := range msgs {\n\t\t\tvar (\n\t\t\t\tspan trace.Span\n\t\t\t)\n\n\t\t\tif cc.EnableTrace {\n\t\t\t\tcarrier := propagation.MapCarrier{}\n\t\t\t\tfor key, value := range msg.GetProperties() {\n\t\t\t\t\tcarrier[key] = value\n\t\t\t\t}\n\t\t\t\tctx, span = tracer.Start(ctx, msg.Topic, carrier, trace.WithAttributes(attrs...))\n\t\t\t\tspan.SetAttributes(\n\t\t\t\t\tsemconv.MessagingRocketmqNamespaceKey.String(msg.Topic),\n\t\t\t\t\tsemconv.MessagingRocketmqMessageTagKey.String(msg.GetTags()),\n\t\t\t\t)\n\t\t\t\tdefer span.End()\n\t\t\t}\n\n\t\t\tif cc.bucket != nil {\n\t\t\t\tif ok := cc.bucket.WaitMaxDuration(1, cc.WaitMaxDuration); !ok {\n\t\t\t\t\treturn consumer.ConsumeRetryLater, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := f(ctx, msg); err != nil {\n\t\t\t\tif cc.EnableTrace && span != nil {\n\t\t\t\t\tspan.RecordError(err)\n\t\t\t\t}\n\t\t\t\treturn consumer.ConsumeRetryLater, err\n\t\t\t}\n\t\t}\n\t\treturn consumer.ConsumeSuccess, nil\n\t}\n\tcc.subscribers[cc.Topic] = fn\n\treturn cc\n}\n\nfunc (cc *PushConsumer) Start() error {\n\tif cc.started {\n\t\treturn nil\n\t}\n\n\tvar opts = []consumer.Option{\n\t\tconsumer.WithGroupName(cc.Group),\n\t\tconsumer.WithInstance(cc.InstanceName),\n\t\tconsumer.WithNameServer(cc.Addr),\n\t\tconsumer.WithMaxReconsumeTimes(cc.Reconsume),\n\t\tconsumer.WithInterceptor(cc.interceptors...),\n\t\tconsumer.WithConsumeMessageBatchMaxSize(cc.ConsumeMessageBatchMaxSize),\n\t\tconsumer.WithPullBatchSize(cc.PullBatchSize),\n\t\tconsumer.WithConsumeGoroutineNums(cc.ConsumeGoroutineNums),\n\t\tconsumer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: cc.AccessKey,\n\t\t\tSecretKey: cc.SecretKey,\n\t\t}),\n\t}\n\tif cc.PushConsumerConfig.MessageModel == \"BroadCasting\" {\n\t\topts = append(opts, consumer.WithConsumerModel(consumer.BroadCasting))\n\t}\n\n\tclient, err := rocketmq.NewPushConsumer(opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcc.PushConsumer = client\n\n\tselector := consumer.MessageSelector{\n\t\tType:       consumer.TAG,\n\t\tExpression: \"\",\n\t}\n\tif cc.PushConsumerConfig.SubExpression != \"*\" {\n\t\tselector.Expression = cc.PushConsumerConfig.SubExpression\n\t}\n\n\tfor topic, fn := range cc.subscribers {\n\t\tif err := cc.PushConsumer.Subscribe(topic, selector, fn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif cc.Enable {\n\t\tif err := client.Start(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcc.started = true\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 128,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/consumer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/juju/ratelimit\"\n)\n\ntype PushConsumerConfig struct {\n\tGroupName string\n\tTopics    []string\n\tRateLimit int64\n}\n\ntype PushConsumer struct {\n\tname               string\n\trocketmq.PushConsumer\n\tPushConsumerConfig\n\tsubscribers map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)\n\tinterceptors []primitive.Interceptor\n\tbucket       *ratelimit.Bucket\n\tstarted      bool\n\tmu           sync.Mutex\n}\n\nfunc NewPushConsumer(name string, config PushConsumerConfig) *PushConsumer {\n\tbucket := ratelimit.NewBucketWithRate(float64(config.RateLimit), config.RateLimit)\n\treturn &PushConsumer{\n\t\tname:               name,\n\t\tPushConsumerConfig: config,\n\t\tsubscribers:        make(map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)),\n\t\tbucket:             bucket,\n\t}\n}\n\nfunc (pc *PushConsumer) RegisterSingleMessage(f func(context.Context, *primitive.MessageExt) error) *PushConsumer {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tfor _, topic := range pc.Topics {\n\t\tpc.subscribers[topic] = func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) {\n\t\t\tfor _, msg := range msgs {\n\t\t\t\tif err := f(ctx, msg); err != nil {\n\t\t\t\t\treturn consumer.ConsumeRetryLater, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn consumer.ConsumeSuccess, nil\n\t\t}\n\t}\n\treturn pc\n}\n\nfunc (pc *PushConsumer) Start() error {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tif pc.started {\n\t\treturn fmt.Errorf(\"consumer already started\")\n\t}\n\n\tc, err := rocketmq.NewPushConsumer(\n\t\tconsumer.WithGroupName(pc.GroupName),\n\t\tconsumer.WithInterceptor(pc.interceptors...),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor topic, handler := range pc.subscribers {\n\t\tif err := c.Subscribe(topic, consumer.MessageSelector{}, handler); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := c.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tpc.PushConsumer = c\n\tpc.started = true\n\treturn nil\n}\n\nfunc main() {\n\tconfig := PushConsumerConfig{\n\t\tGroupName: \"exampleGroup\",\n\t\tTopics:    []string{\"exampleTopic\"},\n\t\tRateLimit: 100,\n\t}\n\n\tconsumer := NewPushConsumer(\"exampleConsumer\", config)\n\tconsumer.RegisterSingleMessage(func(ctx context.Context, msg *primitive.MessageExt) error {\n\t\tlog.Printf(\"Received message: %s\", msg.Body)\n\t\treturn nil\n\t})\n\n\tif err := consumer.Start(); err != nil {\n\t\tlog.Fatalf(\"Failed to start consumer: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 302,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages in different modes (Sync, Async, OneWay) and support delayed messages.\n\nFunction Description: The following functions provide different ways to send messages to RocketMQ brokers. The producer must be initialized before sending messages.\n\nInput: \n- ctx: context.Context - Context for controlling the message sending process\n- topic: string - The topic to which the message will be sent\n- body: []byte - The message body/content\n- tag: string (for delay message) - Message tag for filtering\n- keys: []string (for delay message) - Message keys for filtering\n- delayLevel: int (for delay message) - Delay level for delayed messages\n- callback: func(ctx context.Context, result *primitive.SendResult, err error) (for async message) - Callback function for async message sending\n\nOutput:\n- error: For OneWay and Async modes, returns error if sending fails\n- (*primitive.SendResult, error): For Sync mode, returns send result and potential error\n- (*primitive.SendResult, error): For delayed sync message, returns send result and potential error\n\nMethods:\n\ninitProducer: () -> error - Initializes the RocketMQ producer with default configuration\n\nsendOneWayMessage: (ctx context.Context, topic string, body []byte) -> error - Sends a message in OneWay mode (fire-and-forget)\n\nsendSyncMessage: (ctx context.Context, topic string, body []byte) -> (*primitive.SendResult, error) - Sends a message in Sync mode (waits for acknowledgment)\n\nsendAsyncMessage: (ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) -> error - Sends a message in Async mode (uses callback)\n\nsendDelaySyncMessage: (ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) -> (*primitive.SendResult, error) - Sends a delayed message in Sync mode",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n)\n\nvar mqProducer rocketmq.Producer\n\nfunc initProducer() error {\n\tvar err error\n\tmqProducer, err = rocketmq.NewProducer(\n\t\tproducer.WithNsResovler(primitive.NewPassthroughResolver([]string{\"172.13.3.160:9876\"})),\n\t\tproducer.WithRetry(3),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn mqProducer.Start()\n}\n\nfunc sendOneWayMessage(ctx context.Context, topic string, body []byte) error {\n\treturn mqProducer.SendOneWay(ctx, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendSyncMessage(ctx context.Context, topic string, body []byte) (*primitive.SendResult, error) {\n\treturn mqProducer.SendSync(ctx, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendAsyncMessage(ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) error {\n\treturn mqProducer.SendAsync(ctx, callback, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendDelaySyncMessage(ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) (*primitive.SendResult, error) {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t}\n\tmsg.WithTag(tag)\n\tmsg.WithKeys(keys)\n\tmsg.WithDelayTimeLevel(delayLevel)\n\treturn mqProducer.SendSync(ctx, msg)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 127,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n)\n\nvar mqProducer rocketmq.Producer\n\nfunc initProducer() error {\n\tvar err error\n\tmqProducer, err = rocketmq.NewProducer(\n\t\tproducer.WithNameServer([]string{\"127.0.0.1:9876\"}),\n\t\tproducer.WithRetry(2),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn mqProducer.Start()\n}\n\nfunc sendOneWayMessage(ctx context.Context, topic string, body []byte) error {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t}\n\treturn mqProducer.SendOneWay(ctx, msg)\n}\n\nfunc sendSyncMessage(ctx context.Context, topic string, body []byte) (*primitive.SendResult, error) {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t}\n\treturn mqProducer.SendSync(ctx, msg)\n}\n\nfunc sendAsyncMessage(ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) error {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t}\n\treturn mqProducer.SendAsync(ctx, func(ctx context.Context, result *primitive.SendResult, err error) {\n\t\tcallback(ctx, result, err)\n\t}, msg)\n}\n\nfunc sendDelaySyncMessage(ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) (*primitive.SendResult, error) {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t\tTags:  tag,\n\t\tKeys:  keys,\n\t}\n\tmsg.WithDelayTimeLevel(delayLevel)\n\treturn mqProducer.SendSync(ctx, msg)\n}\n\nfunc main() {\n\terr := initProducer()\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to initialize producer: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer mqProducer.Shutdown()\n\n\t// Example usage\n\tctx := context.Background()\n\t_, err = sendSyncMessage(ctx, \"testTopic\", []byte(\"Hello RocketMQ\"))\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to send sync message: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages to brokers using different modes (Sync, Async, or OneWay) with configurable options.\n\nStruct Description: The Producer struct encapsulates a RocketMQ producer client with methods for starting, closing, and sending messages. It supports configuration options and interceptors.\n\nFields:\n\n- started: bool - Indicates whether the producer has been started\n- Producer: rocketmq.Producer - The underlying RocketMQ producer instance\n- name: string - Name identifier for the producer\n- ProducerConfig: ProducerConfig - Configuration settings for the producer\n- interceptors: []primitive.Interceptor - List of interceptors for message processing\n\nMethods:\n\n- Start() -> error - Initializes and starts the RocketMQ producer with configured options\n- Close() -> error - Shuts down the producer gracefully\n- SendWithContext(ctx context.Context, msg []byte) -> error - Sends a byte array message with context\n- SendWithMsg(ctx context.Context, msg *primitive.Message) -> error - Sends a primitive.Message with context\n- SendWithResult(ctx context.Context, msg []byte, tag string) -> (*primitive.SendResult, error) - Sends a message with tag and returns send result\n- SendMsg(ctx context.Context, msg *primitive.Message) -> (*primitive.SendResult, error) - Sends a message and returns send result",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/douyu/jupiter/pkg/xlog\"\n)\n\ntype Producer struct {\n\tstarted bool\n\n\trocketmq.Producer\n\tname string\n\tProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc (pc *Producer) Start() error {\n\tif pc.started {\n\t\treturn nil\n\t}\n\n\tclient, err := rocketmq.NewProducer(\n\t\tproducer.WithGroupName(pc.Group),\n\t\tproducer.WithNameServer(pc.Addr),\n\t\tproducer.WithRetry(pc.Retry),\n\t\tproducer.WithInterceptor(pc.interceptors...),\n\t\tproducer.WithInstanceName(pc.InstanceName),\n\t\tproducer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: pc.AccessKey,\n\t\t\tSecretKey: pc.SecretKey,\n\t\t}),\n\t)\n\tif err != nil {\n\t\txlog.Jupiter().Panic(\"create producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tif err := client.Start(); err != nil {\n\t\txlog.Jupiter().Panic(\"start producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tpc.started = true\n\tpc.Producer = client\n\treturn nil\n}\n\nfunc (pc *Producer) Close() error {\n\terr := pc.Shutdown()\n\tif err != nil {\n\t\txlog.Jupiter().Warn(\"consumer close fail\", xlog.Any(\"error\", err.Error()))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\t_, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tmsg.Topic = pc.Topic\n\t_, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\tif tag != \"\" {\n\t\tm.WithTag(tag)\n\t}\n\n\tres, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", string(msg)))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}\n\nfunc (pc *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tres, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 127,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n)\n\ntype ProducerConfig struct {\n\tGroupName   string\n\tNameServers []string\n\tRetryTimes  int\n}\n\ntype Producer struct {\n\tstarted       bool\n\tProducer      rocketmq.Producer\n\tname          string\n\tProducerConfig ProducerConfig\n\tinterceptors  []primitive.Interceptor\n}\n\nfunc NewProducer(name string, config ProducerConfig, interceptors ...primitive.Interceptor) *Producer {\n\treturn &Producer{\n\t\tname:          name,\n\t\tProducerConfig: config,\n\t\tinterceptors:  interceptors,\n\t}\n}\n\nfunc (p *Producer) Start() error {\n\tif p.started {\n\t\treturn errors.New(\"producer already started\")\n\t}\n\n\tp.Producer, _ = rocketmq.NewProducer(\n\t\tproducer.WithGroupName(p.ProducerConfig.GroupName),\n\t\tproducer.WithNameServer(p.ProducerConfig.NameServers),\n\t\tproducer.WithRetry(p.ProducerConfig.RetryTimes),\n\t\tproducer.WithInterceptor(p.interceptors...),\n\t)\n\n\terr := p.Producer.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.started = true\n\treturn nil\n}\n\nfunc (p *Producer) Close() error {\n\tif !p.started {\n\t\treturn errors.New(\"producer not started\")\n\t}\n\n\terr := p.Producer.Shutdown()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.started = false\n\treturn nil\n}\n\nfunc (p *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tif !p.started {\n\t\treturn errors.New(\"producer not started\")\n\t}\n\n\tmessage := &primitive.Message{\n\t\tBody: msg,\n\t}\n\n\t_, err := p.Producer.SendSync(ctx, message)\n\treturn err\n}\n\nfunc (p *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tif !p.started {\n\t\treturn errors.New(\"producer not started\")\n\t}\n\n\t_, err := p.Producer.SendSync(ctx, msg)\n\treturn err\n}\n\nfunc (p *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tif !p.started {\n\t\treturn nil, errors.New(\"producer not started\")\n\t}\n\n\tmessage := &primitive.Message{\n\t\tBody: msg,\n\t\tTags: tag,\n\t}\n\n\treturn p.Producer.SendSync(ctx, message)\n}\n\nfunc (p *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tif !p.started {\n\t\treturn nil, errors.New(\"producer not started\")\n\t}\n\n\treturn p.Producer.SendSync(ctx, msg)\n}\n\nfunc main() {\n\t// Example usage\n\tconfig := ProducerConfig{\n\t\tGroupName:   \"exampleGroup\",\n\t\tNameServers: []string{\"127.0.0.1:9876\"},\n\t\tRetryTimes:  2,\n\t}\n\n\tproducer := NewProducer(\"exampleProducer\", config)\n\terr := producer.Start()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer producer.Close()\n\n\tctx := context.Background()\n\tmsg := []byte(\"Hello RocketMQ\")\n\terr = producer.SendWithContext(ctx, msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET request. It supports caching of downloaded files to avoid redundant network requests. The function handles error cases including failed requests and non-200 status codes. When caching is enabled, subsequent requests for the same URL will return the cached content.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The content of the fetched file as a byte slice\n- `error` - An error object if any step fails (network error, non-200 status, etc.)\n\nNote: The function relies on package-level variables `fileCache` (a map for caching), `fileCacheMutex` (for thread safety), `fileCacheEnable` (boolean to toggle caching), and `verboseReader` (boolean for logging). These should be properly initialized before use.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tfileCache       = make(map[string][]byte)\n\tfileCacheMutex  = &sync.Mutex{}\n\tfileCacheEnable = true\n\tverboseReader   = false\n)\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tif fileCacheEnable {\n\t\tfileCacheMutex.Lock()\n\t\tif data, found := fileCache[fileurl]; found {\n\t\t\tfileCacheMutex.Unlock()\n\t\t\tif verboseReader {\n\t\t\t\tfmt.Println(\"Cache hit for URL:\", fileurl)\n\t\t\t}\n\t\t\treturn data, nil\n\t\t}\n\t\tfileCacheMutex.Unlock()\n\t}\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch file: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"non-200 status code: %d\", resp.StatusCode)\n\t}\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\tif fileCacheEnable {\n\t\tfileCacheMutex.Lock()\n\t\tfileCache[fileurl] = data\n\t\tfileCacheMutex.Unlock()\n\t}\n\n\tif verboseReader {\n\t\tfmt.Println(\"Fetched and cached URL:\", fileurl)\n\t}\n\n\treturn data, nil\n}\n```"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Implement a function to fetch and process Google Font CSS data for embedding in SVG documents.\n\nFunction Description: The function `googlefont` retrieves CSS data from Google Fonts API for a specified font family, embeds it in SVG-compatible format, and returns available font variants. It handles HTTP requests, response processing, and error cases gracefully.\n\nInput: \n- `f` [string] - The font family name to query (e.g., \"Roboto\" or \"Open Sans\")\n\nOutput:\n- `[]string` - A slice of strings representing available font variants (split by \"|\"), or an empty slice if the request fails or returns non-200 status",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nvar (\n\tcanvas = svg.New(os.Stdout)\n)\n\nconst (\n\tgwfURI  = \"http://fonts.googleapis.com/css?family=\"\n\tfontfmt = \"<style type=\\\"text/css\\\">\\n<![CDATA[\\n%s]]>\\n</style>\\n\"\n)\n\nfunc googlefont(f string) []string {\n\tempty := []string{}\n\tr, err := http.Get(gwfURI + url.QueryEscape(f))\n\tif err != nil {\n\t\treturn empty\n\t}\n\tdefer r.Body.Close()\n\tb, rerr := ioutil.ReadAll(r.Body)\n\tif rerr != nil || r.StatusCode != http.StatusOK {\n\t\treturn empty\n\t}\n\tcanvas.Def()\n\tfmt.Fprintf(canvas.Writer, fontfmt, b)\n\tcanvas.DefEnd()\n\treturn strings.Split(fontlist, \"|\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc googlefont(f string) []string {\n\turl := fmt.Sprintf(\"https://fonts.googleapis.com/css?family=%s\", f)\n\tresp, err := http.Get(url)\n\tif err != nil || resp.StatusCode != http.StatusOK {\n\t\treturn []string{}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\n\tcssData := string(body)\n\tvariants := extractVariants(cssData)\n\treturn variants\n}\n\nfunc extractVariants(cssData string) []string {\n\tlines := strings.Split(cssData, \"\\n\")\n\tvar variants []string\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"font-family\") {\n\t\t\tparts := strings.Split(line, \":\")\n\t\t\tif len(parts) > 1 {\n\t\t\t\tfontInfo := strings.TrimSpace(parts[1])\n\t\t\t\tfontInfo = strings.Trim(fontInfo, \";\")\n\t\t\t\tvariants = append(variants, fontInfo)\n\t\t\t}\n\t\t}\n\t}\n\treturn variants\n}\n\nfunc main() {\n\tfontFamily := \"Roboto\"\n\tvariants := googlefont(fontFamily)\n\tfmt.Println(\"Available variants:\", variants)\n}\n```"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Create a function that fetches memory statistics from a specified URL using HTTP GET request and returns the response body.\n\nFunction Description: The function `defaultMemstatsClient` makes an HTTP GET request to the provided URL to fetch memory statistics. It handles the response by reading the body and ensures proper resource cleanup by deferring the closure of the response body. Errors during the request or response handling are returned to the caller.\n\nInput: \n- `url` (string): The URL from which to fetch the memory statistics.\n\nOutput: \n- `[]byte`: The response body containing the memory statistics.\n- `error`: An error object if the HTTP request or response reading fails; otherwise, `nil`.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc defaultMemstatsClient(url string) ([]byte, error) {\n\tutil.Debug(\"Fetching memstats from %s\", url)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc defaultMemstatsClient(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The contents of the file as a byte slice\n- `error` - Any error encountered during the fetch operation (nil if successful)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nvar cacheDir = \"./cache\"\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tcacheFilePath := filepath.Join(cacheDir, filepath.Base(fileurl))\n\tif cachedData, err := ioutil.ReadFile(cacheFilePath); err == nil {\n\t\tfmt.Println(\"Cache hit:\", cacheFilePath)\n\t\treturn cachedData, nil\n\t}\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch file: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"failed to fetch file: status code %d\", resp.StatusCode)\n\t}\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\tif err := os.MkdirAll(cacheDir, os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create cache directory: %v\", err)\n\t}\n\n\tif err := ioutil.WriteFile(cacheFilePath, data, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write cache file: %v\", err)\n\t}\n\n\tfmt.Println(\"Cache miss, fetched and cached:\", cacheFilePath)\n\treturn data, nil\n}"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Implement a file fetcher with caching capability that retrieves files from a given URL using HTTP GET requests and caches the results to avoid redundant network calls.\n\nFunction Description: The FetchFile function checks a cache for the requested file URL. If not found in cache, it makes an HTTP GET request to fetch the file, stores the result in cache, and returns the file content. It handles errors during the fetch operation and returns appropriate status codes.\n\nInput: \n- fileurl [string]: The URL of the file to fetch\n\nOutput:\n- []byte: The content of the fetched file\n- error: Any error encountered during the fetch operation (network error, non-200 status code, or read error)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tinitializeFileCache()\n\tbytes, ok := fileCache[fileurl]\n\tif ok {\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t}\n\t\treturn bytes, nil\n\t}\n\tif verboseReader {\n\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tdefer response.Body.Close()\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype FileFetcher struct {\n\tcache map[string][]byte\n\tmu    sync.Mutex\n}\n\nfunc NewFileFetcher() *FileFetcher {\n\treturn &FileFetcher{\n\t\tcache: make(map[string][]byte),\n\t}\n}\n\nfunc (ff *FileFetcher) FetchFile(fileurl string) ([]byte, error) {\n\tff.mu.Lock()\n\tif content, found := ff.cache[fileurl]; found {\n\t\tff.mu.Unlock()\n\t\treturn content, nil\n\t}\n\tff.mu.Unlock()\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch file: non-200 status code\")\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tff.mu.Lock()\n\tff.cache[fileurl] = content\n\tff.mu.Unlock()\n\n\treturn content, nil\n}\n\nfunc main() {\n\t// Example usage\n\tfetcher := NewFileFetcher()\n\tcontent, err := fetcher.FetchFile(\"http://example.com/file.txt\")\n\tif err != nil {\n\t\t// Handle error\n\t}\n\t// Use content\n}\n```"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response body as a byte slice or an error if the request fails.\n\nFunction Description: The function makes an HTTP GET request to the provided URL, reads the response body, and returns it as a byte slice. It handles errors during the request or reading process and ensures the response body is properly closed to prevent resource leaks.\n\nInput: \n- url (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- ([]byte, error): A byte slice containing the response body if the request is successful, or an error if the request fails or the response body cannot be read.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.github.com/repos/zyedidia/micro/releases\")\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc fetchURL(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n```"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Create a function that retrieves the version information from an etcd server using a simple HTTP GET request.\n\nFunction Description: The function `GetEtcdVersion` makes an HTTP GET request to the specified etcd server's `/version` endpoint, reads the response, and returns the version information as a string. It handles errors for connection issues, unsuccessful HTTP responses, and response body reading failures.\n\nInput: \n- `host` (string): The base URL of the etcd server (e.g., \"http://localhost:2379\")\n\nOutput: \n- (string): The version information returned by the etcd server\n- (error): An error object if any step fails (connection, non-200 response, or body reading error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\nfunc GetEtcdVersion(host string) (string, error) {\n\tresponse, err := http.Get(host + \"/version\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unsuccessful response from etcd server %q: %v\", host, err)\n\t}\n\tversionBytes, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(versionBytes), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc GetEtcdVersion(host string) (string, error) {\n\turl := fmt.Sprintf(\"%s/version\", host)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect to etcd server: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unsuccessful response from etcd server: %s\", resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 316,
    "Instruction": "Task Description: Create a function that performs a simple HTTP GET request to a remote URL and returns the response body as a string.\n\nFunction Description: The function `remote_get` makes an HTTP GET request to the specified remote URL. It handles the response by checking the status code, reading the response body, and returning it as a string. If any errors occur during the request or response processing, they are returned as part of the error output.\n\nInput: \n- `remote` (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- (string, error): A tuple containing the response body as a string and an error. If the request is successful, the error will be nil. If an error occurs, the string will be empty, and the error will contain the relevant error message.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc remote_get(remote string) (string, error) {\n\tresp, err := http.Get(remote)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"remote_get: wrong status code %d\", resp.StatusCode))\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc remote_get(remote string) (string, error) {\n\tresp, err := http.Get(remote)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"failed to fetch data: %s\", resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Implement a function to retrieve node information by making an HTTP GET request to a local server. The function should handle server setup, request execution, and response processing.\n\nFunction Description: The function `getNode` initiates an HTTP server locally, sends a GET request to retrieve node information based on the provided ID, and returns the response body as a string. It handles server lifecycle management and ensures proper resource cleanup.\n\nInput: \n- `id` [string] - The identifier of the node to retrieve\n\nOutput: \n- [string] - The response body containing the node information",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc getNode(id string) string {\n\tlchan := make(chan net.Listener)\n\thttpServe = func(l net.Listener, h http.Handler) error {\n\t\tlchan <- l\n\t\thttp.Serve(l, h)\n\t\treturn nil\n\t}\n\n\tgo func() { run(&http.ServeMux{}, 0, false, \"nbs:\"+dir) }()\n\tl := <-lchan\n\tdefer l.Close()\n\n\tr, err := http.Get(fmt.Sprintf(\"http://%s/getNode?id=%s\", l.Addr().String(), id))\n\tassert.NoError(err)\n\tdefer r.Body.Close()\n\tbody, err := ioutil.ReadAll(r.Body)\n\treturn string(body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nfunc startServer(wg *sync.WaitGroup) {\n\thttp.HandleFunc(\"/node\", func(w http.ResponseWriter, r *http.Request) {\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tfmt.Fprintf(w, \"Node information for ID: %s\", id)\n\t})\n\twg.Done()\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc getNode(id string) string {\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo startServer(&wg)\n\twg.Wait()\n\n\tresp, err := http.Get(fmt.Sprintf(\"http://localhost:8080/node?id=%s\", id))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get node information: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read response body: %v\", err)\n\t}\n\n\treturn string(body)\n}\n\nfunc main() {\n\tnodeInfo := getNode(\"123\")\n\tfmt.Println(nodeInfo)\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to retrieve configuration data from a local admin API endpoint and returns the response body as a string.\n\nFunction Description: The function `getEffectiveConfig` makes an HTTP GET request to a specified local port's admin API endpoint (/api/v1/config_dump). It handles the response by checking the status code, reading the response body, and returning it as a string. It includes proper error handling for failed requests or non-200 status codes.\n\nInput: \n- port [uint32] - The local port number where the admin API is running\n\nOutput:\n- [string] - The response body as a string if the request is successful\n- [error] - An error object describing any issues that occurred during the request (connection error, non-200 status code, or body read error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"errors\"\n)\nfunc getEffectiveConfig(port uint32) (string, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"http://localhost:%d/api/v1/config_dump\", port))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"call admin api failed response status: %d, %s\", resp.StatusCode, string(b)))\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc getEffectiveConfig(port uint32) (string, error) {\n\turl := \"http://localhost:\" + strconv.Itoa(int(port)) + \"/api/v1/config_dump\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to make GET request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"non-200 status code received: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn string(body), nil\n}\n```"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Implement a function to retrieve a proxy address from a specified HTTP endpoint and return it in a formatted string.\n\nFunction Description: The function `getOneProxy` makes an HTTP GET request to a predefined proxy server endpoint, reads the response body to obtain the proxy address, formats it with an \"http://\" prefix, and returns both the formatted and raw proxy strings. It includes basic error handling for the response reading process.\n\nInput: None (The function takes no input parameters)\n\nOutput: \n1. A string representing the formatted proxy address with \"http://\" prefix\n2. A string representing the raw proxy address from the response body",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc getOneProxy() (string, string) {\n\tresp, _ := http.Get(\"http://45.78.45.70:5015/get/\")\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t}\n\tproxy := \"http://\" + string(body)\n\tfmt.Println(\"\u4f7f\u7528\u9ed8\u8ba4\u4ee3\u7406\uff1a\" + proxy)\n\treturn proxy, string(body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getOneProxy() (string, string, error) {\n\tresp, err := http.Get(\"http://example.com/proxy-endpoint\")\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\trawProxy := string(body)\n\tformattedProxy := \"http://\" + rawProxy\n\treturn formattedProxy, rawProxy, nil\n}"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Implement a function to fetch file content from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `FetchFile` retrieves the content of a file from a specified URL using HTTP GET request. It supports caching of fetched files to avoid redundant network requests when the same URL is requested multiple times. The function includes error handling for network issues and invalid HTTP responses.\n\nInput: \n- `fileurl` (string): The URL of the file to be fetched.\n\nOutput: \n- `[]byte`: The content of the file as a byte slice if successful.\n- `error`: An error object describing any issues encountered during the fetch operation (network errors, non-200 status codes, etc.). Returns nil if no error occurs.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar verboseReader = false\nvar fileCacheEnable = true\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tcache      = make(map[string][]byte)\n\tcacheMutex = &sync.Mutex{}\n)\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tcacheMutex.Lock()\n\tif data, found := cache[fileurl]; found {\n\t\tcacheMutex.Unlock()\n\t\treturn data, nil\n\t}\n\tcacheMutex.Unlock()\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch file: non-200 status code\")\n\t}\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcacheMutex.Lock()\n\tcache[fileurl] = data\n\tcacheMutex.Unlock()\n\n\treturn data, nil\n}\n```"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a function to fetch a long-lived user access token from Facebook's Graph API using HTTP GET request.\n\nFunction Description: The function makes an HTTP GET request to Facebook's OAuth endpoint to exchange a short-lived access token for a long-lived one. It handles the request, response reading, and JSON parsing, returning the long-lived token or an error if any step fails.\n\nInput: \n- The function is a method on a struct (FacebookBee) that contains the following fields:\n  - clientID (string): Facebook app client ID\n  - clientSecret (string): Facebook app client secret\n  - accessToken (string): Short-lived user access token to exchange\n\nOutput:\n- string: The long-lived access token if successful\n- error: Descriptive error if any step fails (request, reading response, or parsing JSON)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc (mod *FacebookBee) fetchLongLivedUserAccessToken() (string, error) {\n\tbaseURL := \"https://graph.facebook.com/oauth/access_token\"\n\tv := url.Values{}\n\tv.Set(\"grant_type\", \"fb_exchange_token\")\n\tv.Set(\"client_id\", mod.clientID)\n\tv.Set(\"client_secret\", mod.clientSecret)\n\tv.Set(\"fb_exchange_token\", mod.accessToken)\n\tgraphUrl := baseURL + \"?\" + v.Encode()\n\n\tres, err := http.Get(graphUrl)\n\n\tif err != nil || res == nil {\n\t\treturn \"\", fmt.Errorf(\"fetching long lived user access token failed: %w\", err)\n\t}\n\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"reading content while fetching long lived user access token failed: %w\", err)\n\t}\n\n\ttype RequestResult struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\n\tvar tokenRes RequestResult\n\terr = json.Unmarshal(body, &tokenRes)\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"parsing result while fetching long lived user access token failed: %w\", err)\n\t}\n\n\treturn tokenRes.AccessToken, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype FacebookBee struct {\n\tclientID     string\n\tclientSecret string\n\taccessToken  string\n}\n\nfunc (fb *FacebookBee) GetLongLivedAccessToken() (string, error) {\n\tbaseURL := \"https://graph.facebook.com/v12.0/oauth/access_token\"\n\tparams := url.Values{}\n\tparams.Add(\"grant_type\", \"fb_exchange_token\")\n\tparams.Add(\"client_id\", fb.clientID)\n\tparams.Add(\"client_secret\", fb.clientSecret)\n\tparams.Add(\"fb_exchange_token\", fb.accessToken)\n\n\tresp, err := http.Get(fmt.Sprintf(\"%s?%s\", baseURL, params.Encode()))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.New(\"failed to fetch long-lived access token\")\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttoken, ok := result[\"access_token\"].(string)\n\tif !ok {\n\t\treturn \"\", errors.New(\"access token not found in response\")\n\t}\n\n\treturn token, nil\n}\n\nfunc main() {\n\tfb := FacebookBee{\n\t\tclientID:     \"your_client_id\",\n\t\tclientSecret: \"your_client_secret\",\n\t\taccessToken:  \"your_short_lived_access_token\",\n\t}\n\n\tlongLivedToken, err := fb.GetLongLivedAccessToken()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Long-lived access token:\", longLivedToken)\n}\n```"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a function that fetches properties from a given URL, handles HTTP responses appropriately, and processes the content based on its encoding type.\n\nFunction Description: The function LoadURL makes an HTTP GET request to the specified URL, checks the response status code, reads the response body, and determines the content encoding based on the Content-Type header. It then processes the content and returns the parsed properties or an error if any step fails.\n\nInput: \n- url (string): The URL from which to fetch the properties.\n\nOutput: \n- (*Properties, error): A pointer to a Properties struct containing the parsed data and nil error on success, or nil and an error describing the failure.\n\nNote: The function handles special cases like 404 errors (when IgnoreMissing is true) and validates the Content-Type header before processing. It also ensures proper resource cleanup by deferring the closing of the response body.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc (l *Loader) LoadURL(url string) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: error fetching %q. %s\", url, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 404 && l.IgnoreMissing {\n\t\tLogPrintf(\"properties: %s returned %d. skipping\", url, resp.StatusCode)\n\t\treturn NewProperties(), nil\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"properties: %s returned %d\", url, resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: %s error reading response. %s\", url, err)\n\t}\n\n\tct := resp.Header.Get(\"Content-Type\")\n\tct = strings.Join(strings.Fields(ct), \"\")\n\tvar enc Encoding\n\tswitch strings.ToLower(ct) {\n\tcase \"text/plain\", \"text/plain;charset=iso-8859-1\", \"text/plain;charset=latin1\":\n\t\tenc = ISO_8859_1\n\tcase \"\", \"text/plain;charset=utf-8\":\n\t\tenc = UTF8\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"properties: invalid content type %s\", ct)\n\t}\n\n\treturn l.loadBytes(body, enc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Properties struct {\n\tData map[string]string\n}\n\nfunc LoadURL(url string, IgnoreMissing bool) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound && IgnoreMissing {\n\t\treturn &Properties{Data: make(map[string]string)}, nil\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch URL: \" + resp.Status)\n\t}\n\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif !strings.HasPrefix(contentType, \"text/\") {\n\t\treturn nil, errors.New(\"unsupported content type: \" + contentType)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproperties, err := parseProperties(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn properties, nil\n}\n\nfunc parseProperties(data []byte) (*Properties, error) {\n\tlines := strings.Split(string(data), \"\\n\")\n\tprops := &Properties{Data: make(map[string]string)}\n\n\tfor _, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif line == \"\" || strings.HasPrefix(line, \"#\") {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.SplitN(line, \"=\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, errors.New(\"invalid property line: \" + line)\n\t\t}\n\t\tkey := strings.TrimSpace(parts[0])\n\t\tvalue := strings.TrimSpace(parts[1])\n\t\tprops.Data[key] = value\n\t}\n\n\treturn props, nil\n}\n```"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a function that reads data from a given location, supporting HTTP/HTTPS protocols. The function should handle URL parsing, make HTTP requests, and return the response body or appropriate errors.\n\nFunction Description: The function `ReadLocation` takes a location string (URL) as input, parses it to determine the protocol, and if it's HTTP/HTTPS, makes a GET request to fetch the data. It handles response status checks, reads the response body, and ensures proper resource cleanup.\n\nInput: \n- `loc` (string): A URL string specifying the location to read from (e.g., \"http://example.com/data\")\n\nOutput: \n- `[]byte`: The response body as a byte slice if successful\n- `error`: An error object describing any issues encountered during URL parsing, HTTP request, or response handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tu, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch u.Scheme {\n\tcase \"http\", \"https\":\n\t\tres, err := http.Get(loc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer res.Body.Close()\n\t\tif res.StatusCode != http.StatusOK {\n\t\t\treturn nil, fmt.Errorf(\"%s\", res.Status)\n\t\t}\n\t\tb, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn b, nil\n\t}\n\treturn nil, fmt.Errorf(\"Unsupported location to load: %s\", loc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "import (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tparsedURL, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https\" {\n\t\treturn nil, errors.New(\"unsupported protocol: only HTTP and HTTPS are supported\")\n\t}\n\n\tresp, err := http.Get(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch data: \" + resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified address with JSON payload and room parameters, then processes the response.\n\nFunction Description: The function sends a POST request to a server endpoint with room information and a JSON payload containing a test value. It handles the response by reading the body and printing the result along with a timestamp.\n\nInput:\n- addr (string): The server address to which the POST request will be sent.\n- i (int64): A numeric value that will be included in the JSON payload.\n\nOutput: None (prints response details to stdout, returns nothing)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc post(addr string, i int64) {\n\tresp, err := http.Post(\"http://\"+addr+\"/goim/push/room?operation=1000&type=test&room=\"+os.Args[1], \"application/json\", bytes.NewBufferString(fmt.Sprintf(\"{\\\"test\\\":%d}\", i)))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%s postId:%d, response:%s\\n\", time.Now().Format(\"2006-01-02 15:04:05\"), i, string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc sendPostRequest(addr string, i int64) {\n\turl := fmt.Sprintf(\"http://%s\", addr)\n\tpayload := map[string]interface{}{\n\t\t\"test_value\": i,\n\t\t\"room\":       \"default\",\n\t}\n\n\tjsonData, err := json.Marshal(payload)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshalling JSON:\", err)\n\t\treturn\n\t}\n\n\tresp, err := http.Post(url, \"application/json\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending POST request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Response received at %s: %s\\n\", time.Now().Format(time.RFC3339), string(body))\n}\n\nfunc main() {\n\tsendPostRequest(\"example.com/api\", 12345)\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a function to fetch and update search configuration from a remote URL, comparing it with the current configuration and updating if different.\n\nFunction Description: The function fetchSearchConfig retrieves search configuration from a predefined URL, normalizes it, compares it with the current configuration, and updates the system state if the new configuration is different. It handles HTTP requests, response reading, and configuration normalization.\n\nInput: None (uses predefined searchConfigURL and relies on the Server's state)\n\nOutput: error - Returns an error if any step fails (HTTP request, reading response, normalization, or configuration loading), or nil if successful (whether updated or no change needed)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nvar currentConfig, _ = normalize(defaultSearchConfig)\n\nfunc (s *Server) fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tnewConfig, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewConfig, err = normalize(newConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bytes.Equal(currentConfig, newConfig) {\n\t\treturn nil\n\t}\n\tif err := s.scraper.LoadConfig(newConfig); err != nil {\n\t\treturn err\n\t}\n\ts.state.SearchProviders = s.scraper.Config\n\ts.state.Push()\n\tcurrentConfig = newConfig\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Config struct {\n\t// Define the structure of your configuration here\n}\n\nvar (\n\tsearchConfigURL = \"https://example.com/config\"\n\tcurrentConfig   Config\n\tconfigMutex     sync.Mutex\n)\n\nfunc fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to fetch configuration: non-200 response\")\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar newConfig Config\n\tif err := json.Unmarshal(body, &newConfig); err != nil {\n\t\treturn err\n\t}\n\n\tnormalizeConfig(&newConfig)\n\n\tconfigMutex.Lock()\n\tdefer configMutex.Unlock()\n\n\tif !configsEqual(currentConfig, newConfig) {\n\t\tcurrentConfig = newConfig\n\t\t// Update system state with newConfig if needed\n\t}\n\n\treturn nil\n}\n\nfunc normalizeConfig(config *Config) {\n\t// Implement normalization logic here\n}\n\nfunc configsEqual(a, b Config) bool {\n\taBytes, _ := json.Marshal(a)\n\tbBytes, _ := json.Marshal(b)\n\treturn bytes.Equal(aBytes, bBytes)\n}\n\nfunc main() {\n\tif err := fetchSearchConfig(); err != nil {\n\t\t// Handle error\n\t}\n}\n```"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a function to fetch file content from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `FetchFile` retrieves the content of a file from a specified URL using HTTP GET request. It supports caching of downloaded files to avoid redundant network requests. The cache can be enabled/disabled globally, and cache hits/misses are logged when verbose mode is active. The function handles HTTP errors and returns the file content as a byte array.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput: \n- `[]byte` - The content of the file as a byte array\n- `error` - Any error encountered during the fetch operation (network error, HTTP status error, etc.)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheEnable = true\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tcacheEnabled = true\n\tverboseMode  = true\n\tcache        = make(map[string][]byte)\n\tcacheMutex   sync.Mutex\n)\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tif cacheEnabled {\n\t\tcacheMutex.Lock()\n\t\tif content, found := cache[fileurl]; found {\n\t\t\tcacheMutex.Unlock()\n\t\t\tif verboseMode {\n\t\t\t\tfmt.Println(\"Cache hit:\", fileurl)\n\t\t\t}\n\t\t\treturn content, nil\n\t\t}\n\t\tcacheMutex.Unlock()\n\t}\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch file: \" + resp.Status)\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cacheEnabled {\n\t\tcacheMutex.Lock()\n\t\tcache[fileurl] = content\n\t\tcacheMutex.Unlock()\n\t\tif verboseMode {\n\t\t\tfmt.Println(\"Cache miss:\", fileurl)\n\t\t}\n\t}\n\n\treturn content, nil\n}\n```"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The `fetchFile` function retrieves the contents of a file from a specified URL using HTTP GET. It supports optional caching of file contents to avoid redundant network requests for the same URL. The function handles HTTP errors and returns the file contents as a byte array if successful.\n\nInput: \n- `fileurl` [string] - The URL of the file to fetch\n\nOutput: \n- `[]byte` - The contents of the file as a byte array\n- `error` - An error object if the fetch operation fails (either network error or non-200 HTTP status)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tcache      = make(map[string][]byte)\n\tcacheMutex = &sync.Mutex{}\n)\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tcacheMutex.Lock()\n\tif data, found := cache[fileurl]; found {\n\t\tcacheMutex.Unlock()\n\t\treturn data, nil\n\t}\n\tcacheMutex.Unlock()\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"failed to fetch file: \" + resp.Status)\n\t}\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcacheMutex.Lock()\n\tcache[fileurl] = data\n\tcacheMutex.Unlock()\n\n\treturn data, nil\n}\n```"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Implement a WorkWeiXin struct in Go that interacts with the WeChat Work API to send messages and manage authentication tokens.\n\nStruct Description: The WorkWeiXin struct represents a client for interacting with WeChat Work's API, handling authentication and message sending functionality.\n\nFields:\nCorpID: string - The corporation ID for WeChat Work authentication\nAgentID: string - The application agent ID for message sending\nCorpSecret: string - The corporation secret for authentication\nToken: string - The access token for API requests (may be empty initially)\n\nMethods:\ngetToken: () -> (string, error) - Retrieves an access token from WeChat Work API using CorpID and CorpSecret. Returns the token or an error.\nSend: (receivers []string, title string, content []byte, others ...string) -> error - Sends a markdown message to specified receivers via WeChat Work API. Handles token retrieval if needed. Returns nil on success or an error.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype WorkWeiXin struct {\n\tCorpID     string `json:\"corpId\"`\n\tAgentID    string `json:\"agentId\"`\n\tCorpSecret string `json:\"corpSecret\"`\n\tToken      string `json:\"token\"`\n}\n\nfunc (w WorkWeiXin) Send(receivers []string, title string, content []byte, others ...string) error {\n\tif w.Token == \"\" {\n\t\ttoken, err := w.getToken()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Token = token\n\t}\n\n\treqBody := make(map[string]interface{})\n\treqBody[\"msgtype\"] = \"markdown\"\n\n\ttoUser := \"\"\n\tfor _, v := range receivers {\n\t\ttoUser = v + \"|\"\n\t}\n\treqBody[\"touser\"] = toUser\n\treqBody[\"agentid\"] = w.AgentID\n\tmarkdown := make(map[string]string)\n\tmarkdown[\"content\"] = string(content)\n\treqBody[\"markdown\"] = markdown\n\tdata, _ := json.Marshal(reqBody)\n\tbody := strings.NewReader(string(data))\n\treq, err := http.NewRequest(\n\t\thttp.MethodPost,\n\t\tfmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s\", w.Token),\n\t\tbody,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tre, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t} else {\n\t\tresult := make(map[string]interface{})\n\t\tif err := json.Unmarshal([]byte(re), &result); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif result[\"errcode\"].(float64) == 0 {\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn errors.New(result[\"errmsg\"].(string))\n\t\t}\n\t}\n}\n\nfunc (w WorkWeiXin) getToken() (string, error) {\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=%s&corpsecret=%s\", w.CorpID, w.CorpSecret)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tre, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t} else {\n\t\tresult := make(map[string]interface{})\n\t\tif err := json.Unmarshal([]byte(re), &result); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif result[\"errcode\"].(float64) == 0 {\n\t\t\treturn result[\"access_token\"].(string), nil\n\t\t} else {\n\t\t\treturn \"\", errors.New(result[\"errmsg\"].(string))\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype WorkWeiXin struct {\n\tCorpID     string\n\tAgentID    string\n\tCorpSecret string\n\tToken      string\n}\n\nfunc (w *WorkWeiXin) getToken() (string, error) {\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=%s&corpsecret=%s\", w.CorpID, w.CorpSecret)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif result[\"errcode\"].(float64) != 0 {\n\t\treturn \"\", errors.New(result[\"errmsg\"].(string))\n\t}\n\n\ttoken := result[\"access_token\"].(string)\n\tw.Token = token\n\treturn token, nil\n}\n\nfunc (w *WorkWeiXin) Send(receivers []string, title string, content []byte, others ...string) error {\n\tif w.Token == \"\" {\n\t\tif _, err := w.getToken(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s\", w.Token)\n\treceiverStr := strings.Join(receivers, \"|\")\n\n\tmessage := map[string]interface{}{\n\t\t\"touser\":  receiverStr,\n\t\t\"msgtype\": \"markdown\",\n\t\t\"agentid\": w.AgentID,\n\t\t\"markdown\": map[string]string{\n\t\t\t\"content\": fmt.Sprintf(\"# %s\\n%s\", title, string(content)),\n\t\t},\n\t}\n\n\tmessageBody, err := json.Marshal(message)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := http.Post(url, \"application/json\", bytes.NewBuffer(messageBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn err\n\t}\n\n\tif result[\"errcode\"].(float64) != 0 {\n\t\treturn errors.New(result[\"errmsg\"].(string))\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a RabbitMQ consumer in Go that connects to a RabbitMQ server, declares necessary exchanges and queues, binds them, and consumes messages from the queue. The consumer should be able to gracefully shut down when requested.\n\nStruct Description: The Consumer struct represents a RabbitMQ consumer with connection and channel management capabilities. It handles the lifecycle of consuming messages from a RabbitMQ queue and provides shutdown functionality.\n\nFields:\n- conn: *amqp.Connection - The connection to the RabbitMQ server\n- channel: *amqp.Channel - The communication channel for RabbitMQ operations\n- tag: string - The consumer tag for identifying this consumer\n- done: chan error - Channel for signaling when the consumer has finished shutting down\n\nMethods:\n- NewConsumer: (amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) -> (*Consumer, error) - Creates a new Consumer instance, establishes connection, declares exchange and queue, binds them, and starts consuming messages\n- Shutdown: () -> error - Gracefully shuts down the consumer by canceling consumption and closing the connection\n- handle: (deliveries <-chan amqp.Delivery, done chan error) -> () - Internal method for processing incoming messages (note: this is not exported as it starts with lowercase)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tc := &Consumer{\n\t\tconn:    nil,\n\t\tchannel: nil,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tvar err error\n\n\tlog.Printf(\"dialing %q\", amqpURI)\n\tc.conn, err = amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Dial: %s\", err)\n\t}\n\n\tgo func() {\n\t\tfmt.Printf(\"closing: %s\", <-c.conn.NotifyClose(make(chan *amqp.Error)))\n\t}()\n\n\tlog.Printf(\"got Connection, getting Channel\")\n\tc.channel, err = c.conn.Channel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Channel: %s\", err)\n\t}\n\n\tlog.Printf(\"got Channel, declaring Exchange (%q)\", exchange)\n\tif err = c.channel.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Exchange Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Exchange, declaring Queue %q\", queueName)\n\tqueue, err := c.channel.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Queue (%q %d messages, %d consumers), binding to Exchange (key %q)\",\n\t\tqueue.Name, queue.Messages, queue.Consumers, key)\n\n\tif err = c.channel.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Bind: %s\", err)\n\t}\n\n\tlog.Printf(\"Queue bound to Exchange, starting Consume (consumer tag %q)\", c.tag)\n\tdeliveries, err := c.channel.Consume(\n\t\tqueue.Name,\n\t\tc.tag,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Consume: %s\", err)\n\t}\n\n\tgo handle(deliveries, c.done)\n\n\treturn c, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn fmt.Errorf(\"Consumer cancel failed: %s\", err)\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn fmt.Errorf(\"AMQP connection close error: %s\", err)\n\t}\n\n\treturn <-c.done\n}\n\nfunc handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\n\t\t\t\"got %dB delivery: [%v] %q\",\n\t\t\tlen(d.Body),\n\t\t\td.DeliveryTag,\n\t\t\td.Body,\n\t\t)\n\t\td.Ack(false)\n\t}\n\tdone <- nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 122,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tc := &Consumer{\n\t\tconn:    nil,\n\t\tchannel: nil,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tvar err error\n\n\tc.conn, err = amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Dial: %s\", err)\n\t}\n\n\tc.channel, err = c.conn.Channel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Channel: %s\", err)\n\t}\n\n\tif err = c.channel.ExchangeDeclare(\n\t\texchange,     // name\n\t\texchangeType, // type\n\t\ttrue,         // durable\n\t\tfalse,        // auto-deleted\n\t\tfalse,        // internal\n\t\tfalse,        // no-wait\n\t\tnil,          // arguments\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Exchange Declare: %s\", err)\n\t}\n\n\tqueue, err := c.channel.QueueDeclare(\n\t\tqueueName, // name\n\t\ttrue,      // durable\n\t\tfalse,     // delete when unused\n\t\tfalse,     // exclusive\n\t\tfalse,     // no-wait\n\t\tnil,       // arguments\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Declare: %s\", err)\n\t}\n\n\tif err = c.channel.QueueBind(\n\t\tqueue.Name, // queue name\n\t\tkey,        // routing key\n\t\texchange,   // exchange\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Bind: %s\", err)\n\t}\n\n\tdeliveries, err := c.channel.Consume(\n\t\tqueue.Name, // queue\n\t\tc.tag,      // consumer\n\t\tfalse,      // auto-ack\n\t\tfalse,      // exclusive\n\t\tfalse,      // no-local\n\t\tfalse,      // no-wait\n\t\tnil,        // args\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Consume: %s\", err)\n\t}\n\n\tgo c.handle(deliveries, c.done)\n\n\treturn c, nil\n}\n\nfunc (c *Consumer) handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\td.Ack(false)\n\t}\n\tlog.Printf(\"handle: deliveries channel closed\")\n\tdone <- nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn fmt.Errorf(\"Consumer cancel failed: %s\", err)\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn fmt.Errorf(\"AMQP connection close error: %s\", err)\n\t}\n\n\tdefer log.Printf(\"AMQP shutdown OK\")\n\n\treturn <-c.done\n}\n\nfunc main() {\n\tamqpURI := \"amqp://guest:guest@localhost:5672/\"\n\texchange := \"test-exchange\"\n\texchangeType := \"direct\"\n\tqueueName := \"test-queue\"\n\tkey := \"test-key\"\n\tctag := \"simple-consumer\"\n\n\tc, err := NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag)\n\tif err != nil {\n\t\tlog.Fatalf(\"%s\", err)\n\t}\n\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigc\n\n\tif err := c.Shutdown(); err != nil {\n\t\tlog.Fatalf(\"error during shutdown: %s\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a robust RabbitMQ producer in Go that handles connection management, channel initialization, and message publishing with automatic reconnection capabilities.\n\nStruct Description: The Session struct represents a RabbitMQ producer session that maintains connection state and provides message publishing functionality with automatic reconnection.\n\nFields:\n- name: string - The name of the queue to publish to\n- logger: *log.Logger - Logger for session events\n- connection: *amqp.Connection - RabbitMQ connection object\n- channel: *amqp.Channel - RabbitMQ channel object\n- done: chan bool - Channel to signal shutdown\n- notifyConnClose: chan *amqp.Error - Channel for connection close notifications\n- notifyChanClose: chan *amqp.Error - Channel for channel close notifications\n- notifyConfirm: chan amqp.Confirmation - Channel for publish confirmations\n- isReady: bool - Flag indicating if session is ready to publish\n\nMethods:\n- New(name string, addr string) -> *Session - Creates a new Session instance and starts connection management\n- handleReconnect(addr string) - Manages reconnection logic in a goroutine\n- connect(addr string) -> (*amqp.Connection, error) - Establishes connection to RabbitMQ server\n- handleReInit(conn *amqp.Connection) -> bool - Handles channel reinitialization after connection\n- init(conn *amqp.Connection) -> error - Initializes channel and declares queue\n- changeConnection(connection *amqp.Connection) - Updates connection and sets up close notifications\n- changeChannel(channel *amqp.Channel) - Updates channel and sets up close/confirm notifications\n- Push(data []byte) -> error - Safely publishes message with retry logic\n- UnsafePush(data []byte) -> error - Publishes message without safety checks (used internally)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string) *Session {\n\tsession := Session{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tname:   name,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn &session\n}\n\nfunc (session *Session) handleReconnect(addr string) {\n\tfor {\n\t\tsession.isReady = false\n\t\tlog.Println(\"Attempting to connect\")\n\n\t\tconn, err := session.connect(addr)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to connect. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif done := session.handleReInit(conn); done {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (session *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.changeConnection(conn)\n\tlog.Println(\"Connected!\")\n\treturn conn, nil\n}\n\nfunc (session *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\tsession.isReady = false\n\n\t\terr := session.init(conn)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to initialize channel. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn true\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-session.done:\n\t\t\treturn true\n\t\tcase <-session.notifyConnClose:\n\t\t\tlog.Println(\"Connection closed. Reconnecting...\")\n\t\t\treturn false\n\t\tcase <-session.notifyChanClose:\n\t\t\tlog.Println(\"Channel closed. Re-running init...\")\n\t\t}\n\t}\n}\n\nfunc (session *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = ch.QueueDeclare(\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.changeChannel(ch)\n\tsession.isReady = true\n\tlog.Println(\"Setup!\")\n\n\treturn nil\n}\n\nfunc (session *Session) changeConnection(connection *amqp.Connection) {\n\tsession.connection = connection\n\tsession.notifyConnClose = make(chan *amqp.Error)\n\tsession.connection.NotifyClose(session.notifyConnClose)\n}\n\nfunc (session *Session) changeChannel(channel *amqp.Channel) {\n\tsession.channel = channel\n\tsession.notifyChanClose = make(chan *amqp.Error)\n\tsession.notifyConfirm = make(chan amqp.Confirmation, 1)\n\tsession.channel.NotifyClose(session.notifyChanClose)\n\tsession.channel.NotifyPublish(session.notifyConfirm)\n}\n\nfunc (session *Session) Push(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"failed to push: not connected\")\n\t}\n\tfor {\n\t\terr := session.UnsafePush(data)\n\t\tif err != nil {\n\t\t\tsession.logger.Println(\"Push failed. Retrying...\")\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn errors.New(\"session is shutting down\")\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-session.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\tsession.logger.Println(\"Push confirmed!\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t}\n\t\tsession.logger.Println(\"Push didn't confirm. Retrying...\")\n\t}\n}\n\nfunc (session *Session) UnsafePush(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"not connected to a server\")\n\t}\n\treturn session.channel.Publish(\n\t\t\"\",\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string, logger *log.Logger) *Session {\n\tsession := &Session{\n\t\tname:   name,\n\t\tlogger: logger,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn session\n}\n\nfunc (s *Session) handleReconnect(addr string) {\n\tfor {\n\t\ts.isReady = false\n\t\tconn, err := s.connect(addr)\n\t\tif err != nil {\n\t\t\ts.logger.Println(\"Failed to connect. Retrying...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tif s.handleReInit(conn) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (s *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.changeConnection(conn)\n\treturn conn, nil\n}\n\nfunc (s *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\ts.isReady = false\n\t\terr := s.init(conn)\n\t\tif err != nil {\n\t\t\ts.logger.Println(\"Failed to initialize channel. Retrying...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn true\n\t\tcase <-s.notifyConnClose:\n\t\t\treturn false\n\t\tcase <-s.notifyChanClose:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc (s *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = ch.QueueDeclare(\n\t\ts.name,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.changeChannel(ch)\n\ts.isReady = true\n\ts.logger.Println(\"Channel initialized and ready to publish\")\n\treturn nil\n}\n\nfunc (s *Session) changeConnection(connection *amqp.Connection) {\n\ts.connection = connection\n\ts.notifyConnClose = connection.NotifyClose(make(chan *amqp.Error))\n}\n\nfunc (s *Session) changeChannel(channel *amqp.Channel) {\n\ts.channel = channel\n\ts.notifyChanClose = channel.NotifyClose(make(chan *amqp.Error))\n\ts.notifyConfirm = channel.NotifyPublish(make(chan amqp.Confirmation, 1))\n}\n\nfunc (s *Session) Push(data []byte) error {\n\tif !s.isReady {\n\t\treturn amqp.ErrClosed\n\t}\n\tfor {\n\t\terr := s.UnsafePush(data)\n\t\tif err != nil {\n\t\t\ts.logger.Println(\"Push failed. Retrying...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-s.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\ts.logger.Println(\"Push confirmed\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t\ts.logger.Println(\"Push timeout. Retrying...\")\n\t\t}\n\t}\n}\n\nfunc (s *Session) UnsafePush(data []byte) error {\n\tif !s.isReady {\n\t\treturn amqp.ErrClosed\n\t}\n\treturn s.channel.Publish(\n\t\t\"\",\n\t\ts.name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}\n```"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Implement a RabbitMQ client in Go that handles connection management, queue declaration, and message publishing with retry logic for reliability.\n\nStruct Description: RabbitClient is a struct that encapsulates the functionality for interacting with a RabbitMQ server, including establishing connections, declaring queues, and publishing messages with automatic reconnection attempts on failures.\n\nFields:\n- url: string - The connection URL for the RabbitMQ server\n- queueName: string - The name of the queue to interact with\n- connection: *amqp.Connection - The active RabbitMQ connection\n- channel: *amqp.Channel - The channel for communication with RabbitMQ\n\nMethods:\n- Connect() -> void - Establishes connection to RabbitMQ server, creates a channel, and declares a queue with TTL and priority settings. Implements retry logic on failures.\n- PublishTgMessage(messageBag MessageBag) -> void - Publishes a message to the declared queue after JSON serialization. Implements retry logic on failures and handles reconnection.\n- Close() -> void - Properly closes the channel and connection to RabbitMQ if they exist.\n- NewRabbitClient(url string, queueName string) -> *RabbitClient - Constructor function that initializes and returns a new RabbitClient instance with established connection.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"time\"\n)\n\ntype RabbitClient struct {\n\turl\t\t\tstring\n\tqueueName\tstring\n\tconnection\t*amqp.Connection\n\tchannel\t\t*amqp.Channel\n}\n\nfunc (rc *RabbitClient) Connect() {\n\tfor {\n\t\tvar err error\n\n\t\trc.connection, err = amqp.Dial(rc.url)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't connect to rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\trc.channel, err = rc.connection.Channel()\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't create channel (connect was ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\targs := make(amqp.Table)\n\t\targs[\"x-message-ttl\"] = int32(1000 * 60 * 60 * 24 * 10)\n\t\targs[\"x-max-priority\"] = int32(255)\n\n\t\t_, err = rc.channel.QueueDeclare(\n\t\t\trc.queueName,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\targs,\n\t\t)\n\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't declare queue (connect, channel were ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tfor {\n\t\tbody, err := json.Marshal(messageBag)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error marshaling a message.\")\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Publishing %+v ...\\n\", string(body))\n\n\t\terr = rc.channel.Publish(\n\t\t\t\"\",\n\t\t\trc.queueName,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tamqp.Publishing{\n\t\t\t\tDeliveryMode: amqp.Persistent,\n\t\t\t\tContentType: \"text/plain\",\n\t\t\t\tBody: body,\n\t\t\t\tPriority: messageBag.Priority,\n\t\t\t})\n\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't publish text '%s', will retry in 1 sec: %s\", string(body), err)\n\t\t\trc.Close()\n\t\t\trc.Connect()\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) Close() {\n\tif rc.channel != nil {\n\t\trc.channel.Close()\n\t}\n\tif rc.connection != nil {\n\t\trc.connection.Close()\n\t}\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\trabbit := &RabbitClient{\n\t\turl: url,\n\t\tqueueName: queueName,\n\t}\n\trabbit.Connect()\n\tlog.Println(\"Successfully connected to RabbitMQ\")\n\treturn rabbit\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype MessageBag struct {\n\tContent string\n}\n\ntype RabbitClient struct {\n\turl       string\n\tqueueName string\n\tconnection *amqp.Connection\n\tchannel    *amqp.Channel\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\tclient := &RabbitClient{\n\t\turl:       url,\n\t\tqueueName: queueName,\n\t}\n\tclient.Connect()\n\treturn client\n}\n\nfunc (r *RabbitClient) Connect() {\n\tvar err error\n\tfor {\n\t\tr.connection, err = amqp.Dial(r.url)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Failed to connect to RabbitMQ: %s. Retrying...\", err)\n\t\ttime.Sleep(2 * time.Second)\n\t}\n\n\tr.channel, err = r.connection.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open a channel: %s\", err)\n\t}\n\n\t_, err = r.channel.QueueDeclare(\n\t\tr.queueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Table{\n\t\t\t\"x-message-ttl\": int32(60000),\n\t\t\t\"x-max-priority\": int32(10),\n\t\t},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to declare a queue: %s\", err)\n\t}\n}\n\nfunc (r *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tmessageBody, err := json.Marshal(messageBag)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to serialize message: %s\", err)\n\t}\n\n\tfor {\n\t\terr = r.channel.Publish(\n\t\t\t\"\",\n\t\t\tr.queueName,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tamqp.Publishing{\n\t\t\t\tContentType: \"application/json\",\n\t\t\t\tBody:        messageBody,\n\t\t\t},\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Failed to publish message: %s. Retrying...\", err)\n\t\tr.Connect()\n\t}\n}\n\nfunc (r *RabbitClient) Close() {\n\tif r.channel != nil {\n\t\tr.channel.Close()\n\t}\n\tif r.connection != nil {\n\t\tr.connection.Close()\n\t}\n}\n\nfunc main() {\n\tclient := NewRabbitClient(\"amqp://guest:guest@localhost:5672/\", \"testQueue\")\n\tdefer client.Close()\n\n\tmessage := MessageBag{Content: \"Hello, RabbitMQ!\"}\n\tclient.PublishTgMessage(message)\n}\n```"
  },
  {
    "Task_id": 337,
    "Instruction": "Task Description: Implement a thread-safe RabbitMQ producer in Go that handles connection management, queue/exchange declaration, and message publishing.\n\nStruct Description: AMQPConn represents a RabbitMQ connection with built-in connection pooling and thread safety. It manages the AMQP connection, channel, and provides message sending capability.\n\nFields:\n\nmu: [sync.Mutex] - Mutex for thread-safe operations\nep: [Endpoint] - Configuration endpoint containing AMQP settings\nconn: [*amqp.Connection] - Underlying AMQP connection\nchannel: [*amqp.Channel] - AMQP channel for message operations\nex: [bool] - Flag indicating if connection is expired\nt: [time.Time] - Timestamp of last operation\n\nMethods:\n\nSend: [Name](msg string) -> [error] - Publishes a message to RabbitMQ. Handles connection establishment, channel creation, and queue/exchange declaration if not already done. Returns error if operation fails.\n[Input Parameters]:\n- msg: string - The message to be published\n[Return Type]:\n- error - Returns nil on success, error on failure",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype AMQPConn struct {\n\tmu      sync.Mutex\n\tep      Endpoint\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\tex      bool\n\tt       time.Time\n}\n\nfunc (conn *AMQPConn) Send(msg string) error {\n\tconn.mu.Lock()\n\tdefer conn.mu.Unlock()\n\n\tif conn.ex {\n\t\treturn errExpired\n\t}\n\tconn.t = time.Now()\n\n\tif conn.conn == nil {\n\t\tprefix := \"amqp://\"\n\t\tif conn.ep.AMQP.SSL {\n\t\t\tprefix = \"amqps://\"\n\t\t}\n\n\t\tvar cfg amqp.Config\n\t\tcfg.Dial = func(network, addr string) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(network, addr, time.Second)\n\t\t}\n\t\tc, err := amqp.DialConfig(fmt.Sprintf(\"%s%s\", prefix, conn.ep.AMQP.URI), cfg)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := channel.ExchangeDeclare(\n\t\t\tconn.ep.AMQP.QueueName,\n\t\t\tconn.ep.AMQP.Type,\n\t\t\tconn.ep.AMQP.Durable,\n\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\tconn.ep.AMQP.Internal,\n\t\t\tconn.ep.AMQP.NoWait,\n\t\t\tnil,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif conn.ep.AMQP.Type != \"topic\" {\n\t\t\tif _, err := channel.QueueDeclare(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.Durable,\n\t\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\t\tfalse,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := channel.QueueBind(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.RouteKey,\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tconn.conn = c\n\t\tconn.channel = channel\n\t}\n\n\treturn conn.channel.Publish(\n\t\tconn.ep.AMQP.QueueName,\n\t\tconn.ep.AMQP.RouteKey,\n\t\tconn.ep.AMQP.Mandatory,\n\t\tconn.ep.AMQP.Immediate,\n\t\tamqp.Publishing{\n\t\t\tHeaders:         amqp.Table{},\n\t\t\tContentType:     \"application/json\",\n\t\t\tContentEncoding: \"\",\n\t\t\tBody:            []byte(msg),\n\t\t\tDeliveryMode:    conn.ep.AMQP.DeliveryMode,\n\t\t\tPriority:        conn.ep.AMQP.Priority,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "```go\npackage main\n\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Endpoint struct {\n\tURL          string\n\tExchangeName string\n\tExchangeType string\n\tRoutingKey   string\n\tQueueName    string\n}\n\ntype AMQPConn struct {\n\tmu      sync.Mutex\n\tep      Endpoint\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\tex      bool\n\tt       time.Time\n}\n\nfunc NewAMQPConn(ep Endpoint) *AMQPConn {\n\treturn &AMQPConn{\n\t\tep: ep,\n\t\tex: false,\n\t}\n}\n\nfunc (a *AMQPConn) connect() error {\n\tvar err error\n\ta.conn, err = amqp.Dial(a.ep.URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\ta.channel, err = a.conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = a.channel.ExchangeDeclare(\n\t\ta.ep.ExchangeName,\n\t\ta.ep.ExchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = a.channel.QueueDeclare(\n\t\ta.ep.QueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = a.channel.QueueBind(\n\t\ta.ep.QueueName,\n\t\ta.ep.RoutingKey,\n\t\ta.ep.ExchangeName,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\ta.ex = false\n\ta.t = time.Now()\n\treturn nil\n}\n\nfunc (a *AMQPConn) Send(msg string) error {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif a.conn == nil || a.channel == nil || a.ex {\n\t\tif err := a.connect(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr := a.channel.Publish(\n\t\ta.ep.ExchangeName,\n\t\ta.ep.RoutingKey,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(msg),\n\t\t},\n\t)\n\tif err != nil {\n\t\ta.ex = true\n\t\treturn err\n\t}\n\n\ta.t = time.Now()\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage\n\tep := Endpoint{\n\t\tURL:          \"amqp://guest:guest@localhost:5672/\",\n\t\tExchangeName: \"test_exchange\",\n\t\tExchangeType: \"direct\",\n\t\tRoutingKey:   \"test_key\",\n\t\tQueueName:    \"test_queue\",\n\t}\n\n\tproducer := NewAMQPConn(ep)\n\terr := producer.Send(\"Hello, RabbitMQ!\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that handles OAuth-based headless authentication by establishing a connection to a server, receiving authentication instructions, and returning a JWT token upon successful authentication.\n\nFunction Description: The `ssoLogin` function establishes a WebSocket connection to a specified endpoint for headless OAuth authentication. It listens for server messages, displays authentication instructions to the user, and waits for the JWT token to be returned. The function handles connection closure and interrupts gracefully.\n\nInput: \n- `endpoint` (string): The URL endpoint of the authentication server (e.g., \"https://example.com\")\n\nOutput: \n- `string`: The JWT authentication token received from the server after successful authentication. Returns an empty string if authentication fails or is interrupted.\n\nNote: The function includes proper error handling and connection cleanup, and it displays the authentication URL to the user when received from the server.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"golang.org/x/exp/slog\"\n)\n\nfunc ssoLogin(endpoint string) string {\n\tvar (\n\t\tauthToken string\n\t\tinterrupt = make(chan os.Signal, 1)\n\t\turl, _    = url.Parse(endpoint)\n\t\tsocketURL = fmt.Sprintf(\"wss://%s/api/oauth/headless\", url.Host)\n\t)\n\tsignal.Notify(interrupt, os.Interrupt)\n\tconn, _, err := websocket.DefaultDialer.Dial(socketURL, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"error connecting to endpoint \", socketURL, err.Error())\n\t}\n\tdefer conn.Close()\n\t_, msg, err := conn.ReadMessage()\n\tif err != nil {\n\t\tlog.Fatal(\"error reading from server: \", err.Error())\n\t}\n\tfmt.Printf(\"Please visit:\\n %s \\n to authenticate\\n\", string(msg))\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tgo func() {\n\t\tfor {\n\t\t\tmsgType, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif msgType < 0 {\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(err.Error(), \"normal\") {\n\t\t\t\t\tlog.Fatal(\"read error: \", err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif msgType == websocket.CloseMessage {\n\t\t\t\tdone <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(string(msg), \"JWT: \") {\n\t\t\t\tauthToken = strings.TrimPrefix(string(msg), \"JWT: \")\n\t\t\t} else {\n\t\t\t\tlogger.Log(0, \"Message from server:\", string(msg))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn authToken\n\t\tcase <-interrupt:\n\t\t\terr := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlogger.Log(0, \"write close:\", err.Error())\n\t\t\t}\n\t\t\treturn authToken\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc ssoLogin(endpoint string) string {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tconn, _, err := websocket.DefaultDialer.Dial(endpoint, nil)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to connect to server: %v\", err)\n\t\treturn \"\"\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan struct{})\n\tvar jwtToken string\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error reading message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmsg := string(message)\n\t\t\tif msg == \"AUTH_SUCCESS\" {\n\t\t\t\tjwtToken = msg\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t} else if msg == \"AUTH_URL\" {\n\t\t\t\tfmt.Println(\"Please authenticate by visiting the URL provided by the server.\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Received message:\", msg)\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn jwtToken\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"Interrupt received, closing connection.\")\n\t\t\terr := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error during closing connection: %v\", err)\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn \"\"\n\t\tcase <-ctx.Done():\n\t\t\treturn jwtToken\n\t\t}\n\t}\n}\n\nfunc main() {\n\tendpoint := \"wss://example.com/auth\"\n\ttoken := ssoLogin(endpoint)\n\tif token != \"\" {\n\t\tfmt.Println(\"Authentication successful, JWT Token:\", token)\n\t} else {\n\t\tfmt.Println(\"Authentication failed or interrupted.\")\n\t}\n}"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Create a WebSocket client function in Go that establishes a connection to a server, sends a message, and receives a response using the Gorilla WebSocket library.\n\nFunction Description: The function `TestWebSocketClient` tests WebSocket communication by connecting to a local server, sending a predefined message, and verifying the echoed response. It handles connection establishment, message exchange, and connection cleanup.\n\nInput: \n- `t *testing.T`: Go testing framework context for assertions and logging\n- `serverPort int`: The port number where the WebSocket server is running\n\nOutput: \n- None (void function), but performs assertions to verify successful communication\n- Returns error if any step fails (handled via test assertions)\n\n---\n\nTask Description: Create a WebSocket client function in Go that establishes a connection to a server, sends a message, and receives a response using the Gorilla WebSocket library.\n\nFunction Description: The function `TestWebSocketClient` tests WebSocket communication by connecting to a local server, sending a predefined message, and verifying the echoed response. It handles connection establishment, message exchange, and connection cleanup.\n\nInput: \n- `t *testing.T`: Go testing framework context for assertions and logging\n- `serverPort int`: The port number where the WebSocket server is running\n\nOutput: \n- None (void function), but performs assertions to verify successful communication\n- Returns error if any step fails (handled via test assertions)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/ghttp\"\n\t\"github.com/gogf/gf/v2/test/gtest\"\n\t\"github.com/gogf/gf/v2/util/guid\"\n)\nfunc Test_WebSocket(t *testing.T) {\n\ts := g.Server(guid.S())\n\ts.BindHandler(\"/ws\", func(r *ghttp.Request) {\n\t\tws, err := r.WebSocket()\n\t\tif err != nil {\n\t\t\tr.Exit()\n\t\t}\n\t\tfor {\n\t\t\tmsgType, msg, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = ws.WriteMessage(msgType, msg); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\ts.SetDumpRouterMap(false)\n\ts.Start()\n\tdefer s.Shutdown()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tgtest.C(t, func(t *gtest.T) {\n\t\tconn, _, err := websocket.DefaultDialer.Dial(fmt.Sprintf(\n\t\t\t\"ws://127.0.0.1:%d/ws\", s.GetListenedPort(),\n\t\t), nil)\n\t\tt.AssertNil(err)\n\t\tdefer conn.Close()\n\n\t\tmsg := []byte(\"hello\")\n\t\terr = conn.WriteMessage(websocket.TextMessage, msg)\n\t\tt.AssertNil(err)\n\n\t\tmt, data, err := conn.ReadMessage()\n\t\tt.AssertNil(err)\n\t\tt.Assert(mt, websocket.TextMessage)\n\t\tt.Assert(data, msg)\n\t})\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "```go\npackage main\n\nimport (\n\t\"testing\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/url\"\n\t\"log\"\n)\n\nfunc TestWebSocketClient(t *testing.T, serverPort int) {\n\tu := url.URL{Scheme: \"ws\", Host: \"localhost:\" + string(serverPort), Path: \"/echo\"}\n\tlog.Printf(\"connecting to %s\", u.String())\n\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tt.Fatalf(\"dial: %v\", err)\n\t}\n\tdefer c.Close()\n\n\tmessage := \"Hello, WebSocket!\"\n\terr = c.WriteMessage(websocket.TextMessage, []byte(message))\n\tif err != nil {\n\t\tt.Fatalf(\"write: %v\", err)\n\t}\n\n\t_, response, err := c.ReadMessage()\n\tif err != nil {\n\t\tt.Fatalf(\"read: %v\", err)\n\t}\n\n\tif string(response) != message {\n\t\tt.Fatalf(\"expected %s, got %s\", message, response)\n\t}\n}\n```"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that establishes multiple concurrent connections to a WebSocket server, maintains these connections, and handles incoming messages. The client should be able to gracefully handle connection errors and properly close connections when done.\n\nFunction Description: The function establishes WebSocket connections to a specified server endpoint with unique identifiers, maintains these connections in separate goroutines, and continuously reads incoming messages. Each connection includes user identification and authentication parameters in the URL query string.\n\nInput: \n- None (The function uses hardcoded values for demonstration, but could be modified to accept parameters like host, port, path, and connection count)\n\nOutput: \n- None (The function primarily logs its activities and errors to stdout)\n\nNote: The function runs indefinitely until 100,000 connections are established (for testing purposes), with each connection attempt spaced by 1 second. Each connection runs in its own goroutine and includes error handling for both connection establishment and message reading.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n)\n\nfunc Test(t *testing.T) {\n\ti := 0\n\tfor {\n\t\ti++\n\t\tif i == 100000 {\n\t\t\tfmt.Println(\"\u5df2\u7ecf\u4e86\u89e310000\u4e2a\u94fe\u63a5\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tgo func(id int) {\n\t\t\tu := url.URL{Scheme: \"ws\", Host: \"127.0.0.1:8182\", Path: \"/v1/push\", RawQuery: fmt.Sprintf(\"uid=%d&sign=2&time=%d\", id, time.Now().Unix())}\n\t\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"\u94fe\u63a5\u5730\u5740%s,\u5931\u8d25\u539f\u56e0%s\", u.String(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tfor {\n\t\t\t\t_, _, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"ERR_ERR_ERR_ERR_ERR_ERR_read:\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\tserverHost   = \"localhost\"\n\tserverPort   = \"8080\"\n\tserverPath   = \"/ws\"\n\tconnectionCount = 100000\n)\n\nfunc main() {\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tfor i := 0; i < connectionCount; i++ {\n\t\tgo func(id int) {\n\t\t\tu := url.URL{Scheme: \"ws\", Host: fmt.Sprintf(\"%s:%s\", serverHost, serverPort), Path: serverPath, RawQuery: fmt.Sprintf(\"user_id=%d&auth_token=token%d\", id, id)}\n\t\t\tlog.Printf(\"Connecting to %s\", u.String())\n\n\t\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Dial error for connection %d: %v\", id, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer c.Close()\n\n\t\t\tdone := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(done)\n\t\t\t\tfor {\n\t\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"Read error for connection %d: %v\", id, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tlog.Printf(\"Received message on connection %d: %s\", id, message)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-interrupt:\n\t\t\t\tlog.Printf(\"Interrupt received, closing connection %d\", id)\n\t\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Write close error for connection %d: %v\", id, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\tcase <-time.After(time.Second):\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\n\t\ttime.Sleep(1 * time.Second)\n\t}\n\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a WebSocket client in Go that can establish a connection to a server, handle bidirectional communication (sending and receiving messages), and properly manage connection lifecycle.\n\nStruct Description: The Listener struct represents a WebSocket client that connects to a specified URL, handles message processing with optional schema transformation, and manages concurrent read/write operations.\n\nFields:\n- URL: *url.URL - The WebSocket server URL to connect to\n- Token: string - Authentication token to be included in the connection URL\n- SchemaFunc: func([]byte) (io.Reader, error) - Optional function to transform incoming messages\n- Out: io.Writer - Output writer for received messages\n- InCh: <-chan []byte - Input channel for sending messages to the server\n\nMethods:\n- NewListener: (url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) -> *Listener - Creates a new Listener instance with the specified configuration\n- Listen: (ctx context.Context) -> error - Establishes WebSocket connection, handles concurrent message reading/writing, and manages connection lifecycle until context cancellation or normal closure",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype Listener struct {\n\tURL        *url.URL\n\tToken      string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut        io.Writer\n\tInCh       <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:        url,\n\t\tToken:      token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:        out,\n\t\tInCh:       inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tif l.Token != \"\" {\n\t\tparams := l.URL.Query()\n\t\tparams.Set(\"token\", l.Token)\n\t\tl.URL.RawQuery = params.Encode()\n\t}\n\n\tc, _, err := websocket.DefaultDialer.Dial(l.URL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating websocket connection: %w\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tgrp.Go(func() error {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"error reading from websocket: %w\", err)\n\t\t\t}\n\n\t\t\tvar r io.Reader\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\tr, err = l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = bytes.NewReader(message)\n\t\t\t}\n\n\t\t\tio.Copy(l.Out, r)\n\t\t}\n\t})\n\n\tgrp.Go(func() error {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-l.InCh:\n\t\t\t\tif err := c.WriteMessage(websocket.TextMessage, data); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing to websocket: %w\", err)\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing close message: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\tcase <-done:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t})\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 115,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Listener struct {\n\tURL        *url.URL\n\tToken      string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut        io.Writer\n\tInCh       <-chan []byte\n\tconn       *websocket.Conn\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:        url,\n\t\tToken:      token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:        out,\n\t\tInCh:       inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\theader := make(map[string][]string)\n\theader[\"Authorization\"] = []string{\"Bearer \" + l.Token}\n\n\tconn, _, err := websocket.DefaultDialer.Dial(l.URL.String(), header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect: %w\", err)\n\t}\n\tdefer conn.Close()\n\tl.conn = conn\n\n\tdone := make(chan struct{})\n\tgo l.readMessages(done)\n\tgo l.writeMessages(done)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase <-done:\n\t\treturn nil\n\t}\n}\n\nfunc (l *Listener) readMessages(done chan struct{}) {\n\tdefer close(done)\n\tfor {\n\t\t_, message, err := l.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read error:\", err)\n\t\t\treturn\n\t\t}\n\t\tif l.SchemaFunc != nil {\n\t\t\treader, err := l.SchemaFunc(message)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"schema transform error:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tio.Copy(l.Out, reader)\n\t\t} else {\n\t\t\tl.Out.Write(message)\n\t\t}\n\t}\n}\n\nfunc (l *Listener) writeMessages(done chan struct{}) {\n\tfor {\n\t\tselect {\n\t\tcase message := <-l.InCh:\n\t\t\terr := l.conn.WriteMessage(websocket.TextMessage, message)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"write error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tserverURL, _ := url.Parse(\"ws://example.com/socket\")\n\ttoken := \"your-auth-token\"\n\tschemaFunc := func(data []byte) (io.Reader, error) {\n\t\treturn io.Reader(bytes.NewReader(data)), nil\n\t}\n\tout := os.Stdout\n\tinCh := make(chan []byte)\n\n\tlistener := NewListener(serverURL, token, schemaFunc, out, inCh)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt)\n\n\tgo func() {\n\t\t<-c\n\t\tcancel()\n\t}()\n\n\tif err := listener.Listen(ctx); err != nil {\n\t\tfmt.Println(\"listener error:\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a WebSocket client in Go that connects to a server, sends periodic messages, receives messages from the server, and handles graceful shutdown upon interruption.\n\nFunction Description: The main function establishes a WebSocket connection to a specified server, sets up message reading and writing routines, and handles interrupt signals for graceful termination. It continuously sends timestamp messages at regular intervals while concurrently listening for incoming messages from the server.\n\nInput:\n- Command line argument (flag): addr - string - WebSocket server address (e.g., \"localhost:8080\")\n- Implicit input: System interrupt signal (SIGINT)\n\nOutput:\n- Console logs: Connection status, received messages, and error messages\n- WebSocket messages: Sends timestamp messages to server and receives messages from server\n- Return value: None (program runs until interrupted)\n\nNote: The function uses goroutines for concurrent operations and channels for synchronization and interrupt handling.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tu := url.URL{Scheme: \"ws\", Host: *addr, Path: \"/echo\"}\n\tlog.Printf(\"connecting to %s\", u.String())\n\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"dial:\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"recv: %s\", message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn\n\t\tcase t := <-ticker.C:\n\t\t\terr := c.WriteMessage(websocket.TextMessage, []byte(t.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"interrupt\")\n\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write close:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc main() {\n\taddr := flag.String(\"addr\", \"localhost:8080\", \"WebSocket server address\")\n\tflag.Parse()\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tconn, _, err := websocket.DefaultDialer.Dial(\"ws://\"+*addr+\"/ws\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Dial error:\", err)\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Read error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Received: %s\", message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn\n\t\tcase t := <-ticker.C:\n\t\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(t.Format(time.RFC3339)))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"Interrupt received, closing connection...\")\n\t\t\terr := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Close error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that connects to a server, sends multiple messages at random intervals, and handles incoming messages concurrently.\n\nFunction Description: The function establishes a WebSocket connection to a specified server, spawns a goroutine to continuously read incoming messages, and sends a random number of messages to the server with small delays between each send. The function should properly handle connection errors and ensure the connection is closed when done.\n\nInput:\n- i (int64): Seed value for random number generation\n- room (string): Identifier for the message room/context\n\nOutput: None (the function performs operations but doesn't return any value)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/rs/xid\"\n)\n\nfunc testClient(i int64, room string) {\n\tr := rand.New(rand.NewSource(i))\n\tconn, _, err := websocket.DefaultDialer.Dial(SERVER, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\t_ = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\t\t\t_, _, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tdefer conn.Close()\n\n\tops := r.Intn(100)\n\tfor i := 0; i < ops; i++ {\n\t\tm := msg(r, room)\n\t\terr = conn.WriteMessage(websocket.TextMessage, m)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"err\", err)\n\t\t}\n\t\ttime.Sleep(30 * time.Millisecond)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc connectWebSocket(i int64, room string) {\n\trand.Seed(i)\n\tserverURL := \"ws://example.com/socket\" // Replace with actual server URL\n\tu := url.URL{Scheme: \"ws\", Host: serverURL, Path: \"/ws\"}\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"dial:\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"recv: %s\", message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn\n\t\tcase t := <-ticker.C:\n\t\t\tmsg := fmt.Sprintf(\"Message from room %s at %s\", room, t)\n\t\t\terr := c.WriteMessage(websocket.TextMessage, []byte(msg))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"interrupt\")\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write close:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconnectWebSocket(42, \"room1\")\n}"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: The task involves testing a WebSocket connection to a runtime service, verifying the connection establishment, message exchange, and validating the received runtime information against expected values.\n\nFunction Description: The function `TestRuntimeGetRuntime` tests the WebSocket-based communication with a runtime service. It establishes a connection, sends a request message, receives and parses the response, then validates the response contents including protocol, version, capabilities, and runtime ID.\n\nInput: \n- None (This is a test function that takes a testing.T pointer as per Go testing conventions)\n\nOutput: \n- None (The function reports errors through the testing.T parameter if any assertions fail)\n- Side effect: The test will pass if all validations succeed or fail with appropriate error messages if any checks don't match expected values",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\tensureRuntimeStarted()\n\tws, _, err := websocket.DefaultDialer.Dial(\"ws://localhost:13014/\", nil)\n\tdefer ws.Close()\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif err = sendJSONE(ws, &Message{\"runtime\", \"getruntime\", nil}); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tvar msg runtimeMessage\n\tvar bytes []byte\n\tif _, bytes, err = ws.ReadMessage(); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif err = json.Unmarshal(bytes, &msg); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif msg.Protocol != \"runtime\" || msg.Command != \"runtime\" {\n\t\tt.Errorf(\"Invalid protocol (%s) or command (%s)\", msg.Protocol, msg.Command)\n\t\treturn\n\t}\n\tres := msg.Payload\n\tif res.Type != \"goflow\" {\n\t\tt.Errorf(\"Invalid protocol type: %s\\n\", res.Type)\n\t}\n\tif res.Version != \"0.4\" {\n\t\tt.Errorf(\"Invalid protocol version: %s\\n\", res.Version)\n\t}\n\tif len(res.Capabilities) != 5 {\n\t\tt.Errorf(\"Invalid number of supported capabilities: %v\\n\", res.Capabilities)\n\t}\n\tif res.Id == \"\" {\n\t\tt.Error(\"Runtime Id is empty\")\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/url\"\n\t\"testing\"\n)\n\ntype RuntimeResponse struct {\n\tProtocol    string   `json:\"protocol\"`\n\tVersion     string   `json:\"version\"`\n\tCapabilities []string `json:\"capabilities\"`\n\tRuntimeID   string   `json:\"runtime_id\"`\n}\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\tu := url.URL{Scheme: \"ws\", Host: \"localhost:8080\", Path: \"/runtime\"}\n\tconn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to WebSocket: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\trequest := map[string]string{\"action\": \"get_runtime\"}\n\tif err := conn.WriteJSON(request); err != nil {\n\t\tt.Fatalf(\"Failed to send request: %v\", err)\n\t}\n\n\t_, message, err := conn.ReadMessage()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read message: %v\", err)\n\t}\n\n\tvar response RuntimeResponse\n\tif err := json.Unmarshal(message, &response); err != nil {\n\t\tt.Fatalf(\"Failed to parse response: %v\", err)\n\t}\n\n\texpectedProtocol := \"runtime-protocol\"\n\texpectedVersion := \"1.0.0\"\n\texpectedCapabilities := []string{\"capability1\", \"capability2\"}\n\texpectedRuntimeID := \"runtime-123\"\n\n\tif response.Protocol != expectedProtocol {\n\t\tt.Errorf(\"Expected protocol %s, got %s\", expectedProtocol, response.Protocol)\n\t}\n\tif response.Version != expectedVersion {\n\t\tt.Errorf(\"Expected version %s, got %s\", expectedVersion, response.Version)\n\t}\n\tif len(response.Capabilities) != len(expectedCapabilities) {\n\t\tt.Errorf(\"Expected %d capabilities, got %d\", len(expectedCapabilities), len(response.Capabilities))\n\t}\n\tfor i, capability := range expectedCapabilities {\n\t\tif response.Capabilities[i] != capability {\n\t\t\tt.Errorf(\"Expected capability %s, got %s\", capability, response.Capabilities[i])\n\t\t}\n\t}\n\tif response.RuntimeID != expectedRuntimeID {\n\t\tt.Errorf(\"Expected runtime ID %s, got %s\", expectedRuntimeID, response.RuntimeID)\n\t}\n}\n```"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a function that handles WebSocket connections by upgrading HTTP connections, reading incoming messages, and forwarding them to a channel for further processing.\n\nFunction Description: The function `makeUpgradeOnConnect` generates and returns an HTTP handler function that upgrades incoming HTTP connections to WebSocket connections. It reads messages from the WebSocket connection and sends them to a provided channel. The WebSocket connection is properly closed when processing is complete.\n\nInput: \n- `ch chan string`: A channel of strings used to forward incoming WebSocket messages for further processing.\n\nOutput: \n- Returns a function of type `func(http.ResponseWriter, *http.Request)` that serves as an HTTP handler for WebSocket connections.\n\nNote: The returned HTTP handler function does not explicitly return any value but handles WebSocket communication and message forwarding internally.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer c.Close()\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tch <- string(message)\n\t\t\t}()\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tch <- string(message)\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tmessageChannel := make(chan string)\n\thttp.HandleFunc(\"/ws\", makeUpgradeOnConnect(messageChannel))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Implement a WebSocket handler for shell communication that manages bidirectional data transfer between local and remote connections, including connection upgrading, message forwarding, and proper connection cleanup.\n\nStruct Description: The Shell struct represents a shell session manager that maintains active connections and handles WebSocket communication for shell data transfer.\n\nFields:\n- Name: string - Identifier for the shell session\n- links: map[string]*Link - Map of active connections indexed by connection ID\n- RWMutex: sync.RWMutex - Synchronization primitive for thread-safe access to the links map\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages bidirectional data forwarding between local and remote connections\n- localForward: (id string, local *websocket.Conn) -> None - Reads data from local WebSocket connection and forwards to remote\n- remoteForward: (id string, local *websocket.Conn) -> None - Reads data from remote connection and forwards to local WebSocket",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype Shell struct {\n\tName string\n\tlinks map[string]*Link\n\tsync.RWMutex\n}\n\nfunc (shell *Shell) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogging.Error(\"upgrade websocket failed: %s, err=%v\", shell.Name, err)\n\t\thttp.Error(w, err.Error(), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tdefer local.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.localForward(id, local)\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.remoteForward(id, local)\n\t}()\n\twg.Wait()\n}\n\nfunc (shell *Shell) localForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"localForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tdefer link.Close(true)\n\tfor {\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"read local data for %s failed: %v\", shell.Name, err)\n\t\t\treturn\n\t\t}\n\t\tlink.SendData(data)\n\t\tlogging.Debug(\"local read %d bytes: name=%s, id=%s\", len(data), shell.Name, id)\n\t}\n}\n\nfunc (shell *Shell) remoteForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tch := link.remote.ChanRead(id)\n\tdefer link.Close(true)\n\tfor {\n\t\tmsg := <-ch\n\t\tif msg == nil {\n\t\t\treturn\n\t\t}\n\t\tdata, _ := proto.Marshal(msg)\n\t\tlink.recvBytes += uint64(len(data))\n\t\tlink.recvPacket++\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_shell_data:\n\t\t\terr := local.WriteMessage(websocket.TextMessage, msg.GetSdata().GetData())\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write data for %s failed: %v\", shell.Name, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogging.Debug(\"remote read %d bytes: name=%s, id=%s\",\n\t\t\t\tlen(msg.GetSdata().GetData()), shell.Name, id)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Link struct {\n\tRemote *websocket.Conn\n}\n\ntype Shell struct {\n\tName   string\n\tlinks  map[string]*Link\n\tRWMutex sync.RWMutex\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool { return true },\n}\n\nfunc (s *Shell) WS(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tid := r.URL.Query().Get(\"id\")\n\ts.RWMutex.RLock()\n\tlink, exists := s.links[id]\n\ts.RWMutex.RUnlock()\n\n\tif !exists {\n\t\thttp.Error(w, \"Invalid connection ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tgo s.localForward(id, conn)\n\tgo s.remoteForward(id, conn)\n}\n\nfunc (s *Shell) localForward(id string, local *websocket.Conn) {\n\ts.RWMutex.RLock()\n\tlink, exists := s.links[id]\n\ts.RWMutex.RUnlock()\n\n\tif !exists {\n\t\treturn\n\t}\n\n\tfor {\n\t\t_, message, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tlink.Remote.WriteMessage(websocket.TextMessage, message)\n\t}\n}\n\nfunc (s *Shell) remoteForward(id string, local *websocket.Conn) {\n\ts.RWMutex.RLock()\n\tlink, exists := s.links[id]\n\ts.RWMutex.RUnlock()\n\n\tif !exists {\n\t\treturn\n\t}\n\n\tfor {\n\t\t_, message, err := link.Remote.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tlocal.WriteMessage(websocket.TextMessage, message)\n\t}\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that manages WebSocket connections, including upgrading HTTP connections, reading incoming messages, writing periodic messages, and properly closing the connection.\n\nFunction Description: The `wsHandler` function creates an HTTP handler that upgrades incoming HTTP requests to WebSocket connections. It continuously writes numbered messages to the client while concurrently reading any incoming messages from the client. The function stops after sending a specified number of messages and closes the connection gracefully.\n\nInput:\n- `t *testing.T`: Testing context for error reporting\n- `recvBuffer *bytes.Buffer`: Buffer to store received messages from the WebSocket client\n\nOutput:\n- Returns an `http.HandlerFunc` that implements the WebSocket handling logic\n\nNote: The function doesn't directly return values but rather creates a handler function that manages WebSocket communication through the provided buffer and testing context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\trequire.NoError(t, err)\n\t\tdefer c.Close()\n\t\ti := 0\n\t\tfinish := 5\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\n\t\t\ti++\n\t\t\tdata := struct {\n\t\t\t\tMessage string `json:\"message\"`\n\t\t\t}{\n\t\t\t\tMessage: fmt.Sprintf(\"%d\\n\", i),\n\t\t\t}\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := json.NewEncoder(buf).Encode(data)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = c.WriteMessage(websocket.TextMessage, buf.Bytes())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif i == finish {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\terr = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\trequire.NoError(t, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to upgrade connection: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer close(done)\n\t\t\tfor {\n\t\t\t\t_, message, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Logf(\"Read error: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\n\t\tticker := time.NewTicker(time.Second)\n\t\tdefer ticker.Stop()\n\n\t\tconst maxMessages = 10\n\t\tfor i := 0; i < maxMessages; i++ {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tmsg := fmt.Sprintf(\"Message %d\", i+1)\n\t\t\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(msg)); err != nil {\n\t\t\t\t\tt.Logf(\"Write error: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Implement a WebSocket handler for processing VNC-related messages, including image capture data and clipboard events, using gorilla WebSocket library in Go.\n\nStruct Description: The Process struct manages WebSocket connections for VNC operations, handling message passing between the WebSocket connection and internal channels.\n\nFields:\n- srv: *http.Server - HTTP server instance\n- chWrite: chan *vncnetwork.VncMsg - Channel for outgoing VNC messages\n- chImage: chan *vncnetwork.ImageData - Channel for incoming image data\n- chClipboard: chan *vncnetwork.ClipboardData - Channel for incoming clipboard data\n\nMethods:\n- ws: (w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket connections, upgrades HTTP to WebSocket, and manages message reading/writing\n- Close: () -> None - Closes the WebSocket connection and cleans up resources (implied by defer p.Close() in ws method)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/rule/vnc/vncnetwork\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype Process struct {\n\tsrv         *http.Server\n\tchWrite     chan *vncnetwork.VncMsg\n\tchImage     chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nvar upgrader = websocket.Upgrader{EnableCompression: true}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tlogging.Info(\"child process connected\")\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tdefer p.Close()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer utils.Recover(\"ws read\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\t_, data, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"read message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar msg vncnetwork.VncMsg\n\t\t\terr = proto.Unmarshal(data, &msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch msg.GetXType() {\n\t\t\tcase vncnetwork.VncMsg_capture_data:\n\t\t\t\tp.chImage <- msg.GetData()\n\t\t\tcase vncnetwork.VncMsg_clipboard_event:\n\t\t\t\tp.chClipboard <- msg.GetClipboard()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer utils.Recover(\"ws write\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmsg := <-p.chWrite\n\t\t\tdata, err := proto.Marshal(msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = conn.WriteMessage(websocket.BinaryMessage, data)\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\twg.Wait()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"vncnetwork\"\n)\n\ntype Process struct {\n\tsrv         *http.Server\n\tchWrite     chan *vncnetwork.VncMsg\n\tchImage     chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n\tconn        *websocket.Conn\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tvar err error\n\tp.conn, err = upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Upgrade error:\", err)\n\t\treturn\n\t}\n\tdefer p.Close()\n\n\tgo p.writePump()\n\tp.readPump()\n}\n\nfunc (p *Process) readPump() {\n\tfor {\n\t\t_, message, err := p.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Read error:\", err)\n\t\t\tbreak\n\t\t}\n\t\t// Process incoming message\n\t\t// Example: handle VNC message types\n\t}\n}\n\nfunc (p *Process) writePump() {\n\tfor {\n\t\tselect {\n\t\tcase msg := <-p.chWrite:\n\t\t\terr := p.conn.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase img := <-p.chImage:\n\t\t\terr := p.conn.WriteJSON(img)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase clip := <-p.chClipboard:\n\t\t\terr := p.conn.WriteJSON(clip)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *Process) Close() {\n\tif p.conn != nil {\n\t\tp.conn.Close()\n\t}\n\tclose(p.chWrite)\n\tclose(p.chImage)\n\tclose(p.chClipboard)\n}\n\nfunc main() {\n\t// Example setup\n\tprocess := &Process{\n\t\tchWrite:     make(chan *vncnetwork.VncMsg),\n\t\tchImage:     make(chan *vncnetwork.ImageData),\n\t\tchClipboard: make(chan *vncnetwork.ClipboardData),\n\t}\n\n\thttp.HandleFunc(\"/ws\", process.ws)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that handles specific command requests through a web interface. The server should process incoming commands and forward them to a command parser.\n\nFunction Description: The `cmdHandle` function is an HTTP handler that processes POST requests containing a \"cmd\" parameter. It extracts the command and passes it to a command parser. The `InitWeb` function initializes the web server, registers the handler, and starts listening on a specified URL.\n\nInput:\n- For `cmdHandle`:\n  - `w http.ResponseWriter` - Used to write the HTTP response\n  - `r *http.Request` - Contains the incoming HTTP request\n- For `InitWeb`:\n  - None (uses package-level variable `world.Web_Url` for server address)\n\nOutput:\n- For `cmdHandle`:\n  - None (writes response directly to `http.ResponseWriter`)\n- For `InitWeb`:\n  - None (starts server as a side effect, may log errors)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tcmd := r.FormValue(\"cmd\")\n\tif cmd != \"\" {\n\t\tcm.ParseConsole(g_Cmd, (cmd))\n\t}\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/gm\", cmdHandle)\n\terr := http.ListenAndServe(world.Web_Url, nil)\n\tif err != nil {\n\t\tbase.LOG.Println(\"World Web Server : \", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar Web_Url = \":8080\"\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tcmd := r.FormValue(\"cmd\")\n\tif cmd == \"\" {\n\t\thttp.Error(w, \"Missing cmd parameter\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresponse := parseCommand(cmd)\n\tfmt.Fprintln(w, response)\n}\n\nfunc parseCommand(cmd string) string {\n\t// Placeholder for command parsing logic\n\treturn fmt.Sprintf(\"Command received: %s\", cmd)\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/command\", cmdHandle)\n\tlog.Printf(\"Starting server on %s\", Web_Url)\n\tif err := http.ListenAndServe(Web_Url, nil); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}\n\nfunc main() {\n\tInitWeb()\n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a WebSocket proxy struct in Go that can handle WebSocket connections by forwarding messages between a client and a backend server.\n\nStruct Description: The `WebsocketProxy` struct is a reverse proxy for WebSocket connections. It upgrades incoming HTTP connections to WebSocket, connects to a backend WebSocket server, and forwards messages bidirectionally between the client and backend.\n\nFields:\n- Director: `func(incoming *http.Request, out http.Header)` - Optional function to modify the request headers before connecting to the backend.\n- Backend: `func(*http.Request) *url.URL` - Required function that returns the backend URL to connect to.\n- Upgrader: `*websocket.Upgrader` - Optional WebSocket upgrader configuration for client connections.\n- Dialer: `*websocket.Dialer` - Optional WebSocket dialer configuration for backend connections.\n\nMethods:\n- ServeHTTP: `(rw http.ResponseWriter, req *http.Request)` -> `None` - Main handler method that implements the http.Handler interface. It upgrades the client connection, connects to the backend, and sets up bidirectional message forwarding.\n  - Input Parameters:\n    - rw: `http.ResponseWriter` - The HTTP response writer\n    - req: `*http.Request` - The HTTP request\n  - Description: Handles the WebSocket proxy logic including connection upgrading, backend dialing, and message replication between client and backend.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n\t\tif prior, ok := req.Header[\"X-Forwarded-For\"]; ok {\n\t\t\tclientIP = strings.Join(prior, \", \") + \", \" + clientIP\n\t\t}\n\t\trequestHeader.Set(\"X-Forwarded-For\", clientIP)\n\t}\n\n\trequestHeader.Set(\"X-Forwarded-Proto\", \"http\")\n\tif req.TLS != nil {\n\t\trequestHeader.Set(\"X-Forwarded-Proto\", \"https\")\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\treplicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) {\n\t\tfor {\n\t\t\tmsgType, msg, err := src.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\t\tif e, ok := err.(*websocket.CloseError); ok {\n\t\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terrc <- err\n\t\t\t\tdst.WriteMessage(websocket.CloseMessage, m)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = dst.WriteMessage(msgType, msg)\n\t\t\tif err != nil {\n\t\t\t\terrc <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\tif e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure {\n\t\tlog.Printf(message, err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tupgrader := p.Upgrader\n\tif upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{}\n\t}\n\n\tconn, err := upgrader.Upgrade(rw, req, nil)\n\tif err != nil {\n\t\thttp.Error(rw, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tbackendURL := p.Backend(req)\n\tif backendURL == nil {\n\t\thttp.Error(rw, \"Backend URL is required\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := p.Dialer\n\tif dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\toutReq := req.Clone(req.Context())\n\tif p.Director != nil {\n\t\tp.Director(req, outReq.Header)\n\t}\n\n\tbackendConn, _, err := dialer.Dial(backendURL.String(), outReq.Header)\n\tif err != nil {\n\t\thttp.Error(rw, \"Failed to connect to backend\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer backendConn.Close()\n\n\terrc := make(chan error, 2)\n\tgo proxyWebsocket(conn, backendConn, errc)\n\tgo proxyWebsocket(backendConn, conn, errc)\n\n\tif err := <-errc; err != nil {\n\t\tlog.Println(\"WebSocket proxy error:\", err)\n\t}\n}\n\nfunc proxyWebsocket(src, dest *websocket.Conn, errc chan error) {\n\tfor {\n\t\tmessageType, message, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t\tif err := dest.WriteMessage(messageType, message); err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\thttp.Handle(\"/ws\", &WebsocketProxy{\n\t\tBackend: func(req *http.Request) *url.URL {\n\t\t\treturn &url.URL{Scheme: \"ws\", Host: \"backend.example.com\", Path: \"/ws\"}\n\t\t},\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Create a test WebSocket server that echoes received messages back to the client while notifying a channel for each received message.\n\nFunction Description: The function creates an HTTP test server with WebSocket support. It upgrades incoming HTTP connections to WebSocket, reads incoming messages, notifies a channel when a message is received, and echoes the message back to the client. The server runs until the connection is closed.\n\nInput:\n- t *testing.T: Testing context for error reporting\n- received chan struct{}: Channel to notify when a message is received\n\nOutput:\n- *httptest.Server: Pointer to the created HTTP test server instance",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\n\tgorillawebsocket \"github.com/gorilla/websocket\"\n)\n\nfunc testService(t *testing.T, received chan struct{}) *httptest.Server {\n\tvar httpHandler http.HandlerFunc = func(w http.ResponseWriter, r *http.Request) {\n\t\tvar upgrader gorillawebsocket.Upgrader\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error upgrading websocket:\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\tt, b, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\n\t\t\tconn.WriteMessage(t, b)\n\t\t}\n\t}\n\n\treturn httptest.NewServer(httpHandler)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc createTestWebSocketServer(t *testing.T, received chan struct{}) *httptest.Server {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool { return true },\n\t}\n\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to upgrade connection: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\t\t\terr = conn.WriteMessage(websocket.TextMessage, message)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}))\n\n\treturn server\n}\n```"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The handler function manages WebSocket connections by upgrading HTTP requests, handling incoming messages, and maintaining the connection until closure. It includes error handling for connection issues and logs key events.\n\nInput:\n- w http.ResponseWriter: The HTTP response writer used to send responses\n- r *http.Request: The HTTP request containing connection details\n\nOutput: None (void function), but it performs the following actions:\n- Upgrades HTTP connection to WebSocket\n- Reads and echoes messages\n- Closes the connection when done or on error\n- Logs connection events and errors",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif netheader.IsKubeletProbe(r) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading websocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tlog.Println(\"Connection upgraded to WebSocket. Entering receive loop.\")\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Println(\"Client disconnected.\")\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Handler exiting on error:\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully received: %q\", message)\n\t\tif err = conn.WriteMessage(messageType, message); err != nil {\n\t\t\tlog.Println(\"Failed to write message:\", err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully wrote: %q\", message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to upgrade connection: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tlog.Println(\"Client connected\")\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading message: %v\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Printf(\"Received message: %s\", message)\n\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing message: %v\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlog.Println(\"Client disconnected\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\tlog.Println(\"Server started on :8080\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, manages WebSocket connections, and handles message reading.\n\nFunction Description: The function `NotifyWS` handles WebSocket connections by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It adds the new WebSocket connection to a global list of connections and ensures a message-sending service is running. The function then continuously reads messages from the WebSocket connection until it is closed.\n\nInput: \n- `ctx echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails, otherwise returns `nil` after the WebSocket connection is closed.\n\nNote: The function does not explicitly return any output other than potential errors, but it interacts with global state (`service.WebSocketConns` and `service.SocketRun`) and performs I/O operations on the WebSocket connection.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upGrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdefer ws.Close()\n\tservice.WebSocketConns = append(service.WebSocketConns, ws)\n\n\tif !service.SocketRun {\n\t\tservice.SocketRun = true\n\t\tservice.SendMeg()\n\t}\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tfmt.Println(mt, message, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype Service struct {\n\tWebSocketConns []*websocket.Conn\n\tSocketRun      bool\n\tmu             sync.Mutex\n}\n\nvar service = &Service{}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tservice.mu.Lock()\n\tservice.WebSocketConns = append(service.WebSocketConns, conn)\n\tif !service.SocketRun {\n\t\tservice.SocketRun = true\n\t\tgo messageSender()\n\t}\n\tservice.mu.Unlock()\n\n\tfor {\n\t\t_, _, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tservice.mu.Lock()\n\tfor i, c := range service.WebSocketConns {\n\t\tif c == conn {\n\t\t\tservice.WebSocketConns = append(service.WebSocketConns[:i], service.WebSocketConns[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tservice.mu.Unlock()\n\n\treturn nil\n}\n\nfunc messageSender() {\n\t// Placeholder for message sending logic\n}"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, sends a greeting message to the client, and echoes back any messages received from the client.\n\nFunction Description: The function `hello` handles WebSocket communication by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It then enters a loop where it sends a greeting message to the client and reads messages from the client, printing them to the console. The connection is properly closed when the function exits.\n\nInput: \n- `c echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails or if there is an error during message reading/writing. Otherwise, it returns nil once the connection is closed.\n\nNote: The function runs indefinitely in a loop until the WebSocket connection is closed or an error occurs.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc hello(c echo.Context) error {\n\tws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tfor {\n\t\terr := ws.WriteMessage(websocket.TextMessage, []byte(\"Hello, Client!\"))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", msg)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc hello(c echo.Context) error {\n\tws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\terr = ws.WriteMessage(websocket.TextMessage, []byte(\"Hello, Client!\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprintln(\"Received:\", string(msg))\n\n\t\terr = ws.WriteMessage(websocket.TextMessage, msg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Implement a WebSocket handler for VNC (Virtual Network Computing) functionality that enables remote desktop interaction through a WebSocket connection, including image transmission, clipboard sharing, and input event handling.\n\nStruct Description: The VNC struct represents a VNC over WebSocket handler that manages the connection between a client and a remote VNC server, facilitating bidirectional communication for remote desktop operations.\n\nFields:\n- link: *network.Link - Represents the network link to the remote VNC server\n- chClipboard: chan string - Channel for transmitting clipboard content between client and server\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages the VNC session lifecycle\n- remoteRead: (ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) -> None - Processes incoming messages from the remote VNC server\n- localRead: (ctx context.Context, local *websocket.Conn, remote *conn.Conn) -> None - Handles messages received from the WebSocket client\n- mouseEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse movement and click events\n- keyboardEvent: (remote *conn.Conn, data []byte) -> None - Handles keyboard input events\n- cadEvent: (remote *conn.Conn) -> None - Manages Ctrl+Alt+Del special key combination\n- scrollEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse scroll wheel events",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/jpeg\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/runtime\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype VNC struct {\n\tlink         *network.Link\n\tchClipboard  chan string\n}\n\nfunc (v *VNC) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer local.Close()\n\tch := conn.ChanRead(id)\n\tdefer conn.SendDisconnect(v.link.target, v.link.id)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.remoteRead(ctx, ch, local)\n\t}()\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.localRead(ctx, local, conn)\n\t}()\n\twg.Wait()\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteRead\")\n\tfor {\n\t\tvar msg *network.Msg\n\t\tselect {\n\t\tcase msg = <-ch:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_vnc_image:\n\t\t\tdata, err := decodeImage(msg.GetVimg())\n\t\t\truntime.Assert(err)\n\t\t\treplyImage(local, msg.GetVimg(), data, len(msg.GetVimg().GetData()))\n\t\tcase network.Msg_vnc_clipboard:\n\t\t\tv.chClipboard <- msg.GetVclipboard()\n\t\tdefault:\n\t\t\tlogging.Error(\"on message: %s\", msg.GetXType().String())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *conn.Conn) {\n\tdefer utils.Recover(\"localRead\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"local read: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg struct {\n\t\t\tAction string `json:\"action\"`\n\t\t}\n\t\terr = json.Unmarshal(data, &msg)\n\t\tif err != nil {\n\t\t\tlogging.Error(\"unmarshal: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch msg.Action {\n\t\tcase \"mouse\":\n\t\t\tv.mouseEvent(remote, data)\n\t\tcase \"keyboard\":\n\t\t\tv.keyboardEvent(remote, data)\n\t\tcase \"cad\":\n\t\t\tv.cadEvent(remote)\n\t\tcase \"scroll\":\n\t\t\tv.scrollEvent(remote, data)\n\t\t}\n\t}\n}\n\nfunc decodeImage(data *network.VncImage) ([]byte, error) {\n\tswitch data.GetEncode() {\n\tcase network.VncImage_raw:\n\t\treturn data.GetData(), nil\n\tcase network.VncImage_jpeg:\n\t\timg, err := jpeg.Decode(bytes.NewReader(data.GetData()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trect := img.Bounds()\n\t\traw := image.NewRGBA(rect)\n\t\tdraw.Draw(raw, rect, img, rect.Min, draw.Src)\n\t\treturn raw.Pix, nil\n\tcase network.VncImage_png:\n\t}\n\treturn nil, errors.New(\"unsupported\")\n}\n\nfunc replyImage(conn *websocket.Conn, msg *network.VncImage, data []byte, srcSize int) {\n\tinfo := msg.GetXInfo()\n\tbuf := make([]byte, len(data)+28)\n\tbinary.BigEndian.PutUint32(buf, info.GetScreenWidth())\n\tbinary.BigEndian.PutUint32(buf[4:], info.GetScreenHeight())\n\tbinary.BigEndian.PutUint32(buf[8:], info.GetRectX())\n\tbinary.BigEndian.PutUint32(buf[12:], info.GetRectY())\n\tbinary.BigEndian.PutUint32(buf[16:], info.GetRectWidth())\n\tbinary.BigEndian.PutUint32(buf[20:], info.GetRectHeight())\n\tbinary.BigEndian.PutUint32(buf[24:], uint32(srcSize))\n\tcopy(buf[28:], data)\n\tconn.WriteMessage(websocket.BinaryMessage, buf)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package vnc\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"network\"\n\t\"conn\"\n)\n\ntype VNC struct {\n\tlink        *network.Link\n\tchClipboard chan string\n}\n\nfunc (v *VNC) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tupgrader := websocket.Upgrader{}\n\twsConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer wsConn.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tch := make(chan *network.Msg)\n\tgo v.remoteRead(ctx, ch, wsConn)\n\tgo v.localRead(ctx, wsConn, conn)\n\n\t<-ctx.Done()\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase msg := <-ch:\n\t\t\tif err := local.WriteMessage(websocket.BinaryMessage, msg.Data); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *conn.Conn) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\t_, data, err := local.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.handleLocalMessage(remote, data)\n\t\t}\n\t}\n}\n\nfunc (v *VNC) handleLocalMessage(remote *conn.Conn, data []byte) {\n\tswitch data[0] {\n\tcase 0x01:\n\t\tv.mouseEvent(remote, data[1:])\n\tcase 0x02:\n\t\tv.keyboardEvent(remote, data[1:])\n\tcase 0x03:\n\t\tv.cadEvent(remote)\n\tcase 0x04:\n\t\tv.scrollEvent(remote, data[1:])\n\t}\n}\n\nfunc (v *VNC) mouseEvent(remote *conn.Conn, data []byte) {\n\tremote.SendMouseEvent(data)\n}\n\nfunc (v *VNC) keyboardEvent(remote *conn.Conn, data []byte) {\n\tremote.SendKeyboardEvent(data)\n}\n\nfunc (v *VNC) cadEvent(remote *conn.Conn) {\n\tremote.SendCAD()\n}\n\nfunc (v *VNC) scrollEvent(remote *conn.Conn, data []byte) {\n\tremote.SendScrollEvent(data)\n}"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Implement a WebSocket echo server function in Go that handles WebSocket connections, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The `echo` function upgrades an HTTP connection to a WebSocket connection, continuously reads messages from the client, and echoes them back. It handles connection errors and ensures proper cleanup by closing the connection when done.\n\nInput: \n- `ctx *gin.Context`: A Gin context object containing the HTTP request and response writer needed for WebSocket upgrade.\n\nOutput: \n- None (void function), but it performs the following operations:\n  - Upgrades the HTTP connection to WebSocket\n  - Reads and echoes messages until connection is closed\n  - Handles and logs errors\n  - Closes the WebSocket connection when done",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc echo(ctx *gin.Context) {\n\tw,r := ctx.Writer, ctx.Request\n\tc, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv:%s\", message)\n\t\terr = c.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc echo(ctx *gin.Context) {\n\tconn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)\n\tif err != nil {\n\t\tlog.Println(\"Failed to upgrade to WebSocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ws\", echo)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests on the root path (\"/\") and returns a welcome message.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path. When accessed, it responds with a welcome message. The server listens on port 8080.\n\nInput: None (The HTTP server handles incoming requests automatically)\n\nOutput: None (The function runs indefinitely, serving HTTP responses to incoming requests)\n\n---\n\nNote: Since the reference code is at the package level (with `main` function) rather than a struct/class level, I've provided the function-level instruction format. The code demonstrates a complete executable program rather than a reusable struct/class component.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\tmyHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to my website!\")\n\t}\n\n\thttp.HandleFunc(\"/\", myHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Welcome to the Go HTTP server!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a UDP client in Go that can send data to a specified server address and port using the net package's DialUDP function.\n\nStruct Description: The SocketBee struct represents a UDP client capable of sending data to a server. It embeds a bees.Bee for base functionality and includes a channel for event handling.\n\nFields:\neventChan: chan bees.Event - Channel for handling events within the bee framework.\n\nMethods:\nAction: [Name](action bees.Action) -> []bees.Placeholder - Handles the \"send\" action to transmit data to a UDP server. Takes an action object containing the target address, port, and data to send. Returns a list of placeholders (currently unused). Panics on errors during address resolution, connection establishment, or data transmission.",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/muesli/beehive/bees\"\n)\n\ntype SocketBee struct {\n\tbees.Bee\n\n\teventChan chan bees.Event\n}\n\nfunc (mod *SocketBee) Action(action bees.Action) []bees.Placeholder {\n\touts := []bees.Placeholder{}\n\n\tvar data string\n\tvar addr string\n\tvar port int\n\n\taction.Options.Bind(\"address\", &addr)\n\taction.Options.Bind(\"port\", &port)\n\taction.Options.Bind(\"data\", &data)\n\n\tswitch action.Name {\n\tcase \"send\":\n\t\tsa, err := net.ResolveUDPAddr(\"udp\", addr+\":\"+strconv.Itoa(port))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, sa)\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\t_, err = conn.Write([]byte(data))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\tdefault:\n\t\tpanic(\"Unknown action triggered in \" + mod.Name() + \": \" + action.Name)\n\t}\n\n\treturn outs\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype SocketBee struct {\n\teventChan chan bees.Event\n}\n\nfunc (s *SocketBee) Action(action bees.Action) []bees.Placeholder {\n\taddress := action.TargetAddress\n\tport := action.TargetPort\n\tdata := action.Data\n\n\tserverAddr, err := net.ResolveUDPAddr(\"udp\", fmt.Sprintf(\"%s:%d\", address, port))\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Error resolving address: %v\", err))\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, serverAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Error dialing UDP: %v\", err))\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Error sending data: %v\", err))\n\t}\n\n\treturn []bees.Placeholder{}\n}\n\ntype bees struct{}\n\ntype Event struct{}\n\ntype Action struct {\n\tTargetAddress string\n\tTargetPort    int\n\tData          []byte\n}\n\ntype Placeholder struct{}\n\nfunc main() {\n\t// Example usage\n\taction := Action{\n\t\tTargetAddress: \"127.0.0.1\",\n\t\tTargetPort:    8080,\n\t\tData:          []byte(\"Hello, UDP server!\"),\n\t}\n\n\tsocketBee := SocketBee{\n\t\teventChan: make(chan bees.Event),\n\t}\n\n\tsocketBee.Action(action)\n}\n```"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a function to send a Wake-on-LAN (WoL) magic packet to a target device using UDP broadcast.\n\nFunction Description: The function `WakeUp` sends a Wake-on-LAN magic packet to a specified MAC address over UDP broadcast. It allows optional specification of a local network interface for the broadcast and handles the creation and transmission of the magic packet.\n\nInput:\n- `macAddr` (string): The MAC address of the target device to wake up, in format \"XX:XX:XX:XX:XX:XX\"\n- `broadcastIP` (string): The broadcast IP address to use (e.g., \"255.255.255.255\")\n- `bcastInterface` (string): [Optional] The network interface to use for broadcasting. If empty, system default will be used\n- `port` (int): The UDP port number to use for the WoL packet (typically 7 or 9)\n\nOutput:\n- (error): Returns nil on success, or an error if any step fails (invalid MAC, network error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc WakeUp(macAddr, broadcastIP, bcastInterface string, port int) error {\n\tvar localAddr *net.UDPAddr\n\tvar err error\n\tif bcastInterface != \"\" {\n\t\tlocalAddr, err = ipFromInterface(bcastInterface)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbcastAddr := fmt.Sprintf(\"%s:%d\", broadcastIP, port)\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", bcastAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmp, err := New(macAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbs, err := mp.Marshal()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", localAddr, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tn, err := conn.Write(bs)\n\tif err == nil && n != 102 {\n\t\terr = fmt.Errorf(\"magic packet sent was %d bytes (expected 102 bytes sent)\", n)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc WakeUp(macAddr, broadcastIP, bcastInterface string, port int) error {\n\tmac, err := net.ParseMAC(macAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid MAC address: %v\", err)\n\t}\n\n\tif port <= 0 || port > 65535 {\n\t\treturn errors.New(\"invalid port number\")\n\t}\n\n\tmagicPacket := make([]byte, 102)\n\tfor i := 0; i < 6; i++ {\n\t\tmagicPacket[i] = 0xFF\n\t}\n\tfor i := 1; i <= 16; i++ {\n\t\tcopy(magicPacket[i*6:], mac)\n\t}\n\n\tvar conn *net.UDPConn\n\tif bcastInterface != \"\" {\n\t\tiface, err := net.InterfaceByName(bcastInterface)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to get interface: %v\", err)\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err != nil || len(addrs) == 0 {\n\t\t\treturn fmt.Errorf(\"failed to get interface addresses: %v\", err)\n\t\t}\n\t\tlocalAddr := &net.UDPAddr{IP: addrs[0].(*net.IPNet).IP}\n\t\tconn, err = net.DialUDP(\"udp\", localAddr, &net.UDPAddr{IP: net.ParseIP(broadcastIP), Port: port})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to dial UDP: %v\", err)\n\t\t}\n\t} else {\n\t\tconn, err = net.DialUDP(\"udp\", nil, &net.UDPAddr{IP: net.ParseIP(broadcastIP), Port: port})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to dial UDP: %v\", err)\n\t\t}\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write(magicPacket)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send magic packet: %v\", err)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a function that establishes a UDP connection to a target server, sends a payload, and reads the server's response.\n\nFunction Description: The function `connectUDP` initiates a UDP connection to a specified target address, sends a given payload, and reads the response from the server. It handles local and remote address resolution, connection establishment, and error handling for network operations.\n\nInput: \n- `target` [string] - The target server address in the format \"host:port\" (e.g., \"127.0.0.1:8080\").\n- `payload` [string] - The data to be sent to the server.\n\nOutput: \n- None (prints the server's response to stdout). The function panics on errors during connection setup, sending, or receiving.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc connectUDP(target, payload string) {\n\tLocalAddr, err := net.ResolveUDPAddr(\"udp\", \":54321\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP local address on port 54321 %v\", err))\n\t}\n\tRemoteAddr, err := net.ResolveUDPAddr(\"udp\", target)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP remote address [%s] %v\", target, err))\n\t}\n\tconn, err := net.DialUDP(\"udp\", LocalAddr, RemoteAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to open connection to [%s] %v\", target, err))\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\t_, err = conn.Write([]byte(\"\\n\"))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tpanic(\"Failed to read from socket\")\n\t}\n\tfmt.Print(string(buf[:n]))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc connectUDP(target string, payload string) {\n\t// Resolve the UDP address\n\tremoteAddr, err := net.ResolveUDPAddr(\"udp\", target)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve address: %v\", err))\n\t}\n\n\t// Establish a UDP connection\n\tconn, err := net.DialUDP(\"udp\", nil, remoteAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to dial UDP: %v\", err))\n\t}\n\tdefer conn.Close()\n\n\t// Send the payload\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to send payload: %v\", err))\n\t}\n\n\t// Read the response\n\tbuffer := make([]byte, 1024)\n\tn, _, err := conn.ReadFromUDP(buffer)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to read response: %v\", err))\n\t}\n\n\t// Print the server's response\n\tfmt.Println(string(buffer[:n]))\n}\n\nfunc main() {\n\tif len(os.Args) != 3 {\n\t\tfmt.Println(\"Usage: go run main.go <target> <payload>\")\n\t\treturn\n\t}\n\n\ttarget := os.Args[1]\n\tpayload := os.Args[2]\n\n\tconnectUDP(target, payload)\n}\n```"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: The task involves creating a DNS bootstrap resolver that can query DNS servers to resolve domain names to IP addresses using UDP protocol. The resolver should handle concurrent operations, retry failed queries, and manage connection lifecycle properly.\n\nStruct Description: The Bootstrap struct represents a DNS bootstrap resolver that maintains state for DNS queries, including target domain, server address, and query status. It handles concurrent resolution requests and manages connection retries.\n\nFields:\nfqdn: [string] - The fully qualified domain name to resolve\nport: [uint16] - The port number of the DNS server\nbootstrap: [*net.UDPAddr] - The UDP address of the DNS bootstrap server\nqt: [uint16] - The DNS query type (e.g., A or AAAA records)\nlogger: [*zap.Logger] - Logger for debugging and error reporting\nupdating: [atomic.Bool] - Atomic flag indicating if an update is in progress\nnextUpdate: [time.Time] - Timestamp for the next scheduled update\nreadyNotify: [chan struct{}] - Channel to notify when resolution is complete\nm: [sync.Mutex] - Mutex for protecting shared state\nready: [bool] - Flag indicating if resolution is complete\naddrStr: [string] - The resolved address string\n\nMethods:\nresolve: [Name](ctx context.Context, qt uint16) -> (netip.Addr, uint32, error) - Resolves the configured domain name to an IP address using the specified query type. Handles UDP communication with retries and timeout management. Returns the resolved address, its TTL, or an error.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/IrineSistiana/mosdns/v5/pkg/dnsutils\"\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn      string\n\tport      uint16\n\tbootstrap *net.UDPAddr\n\tqt        uint16\n\tlogger    *zap.Logger\n\n\tupdating   atomic.Bool\n\tnextUpdate time.Time\n\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (sp *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tconst edns0UdpSize = 1200\n\n\tq := new(dns.Msg)\n\tq.SetQuestion(sp.fqdn, qt)\n\tq.SetEdns0(edns0UdpSize, false)\n\n\tc, err := net.DialUDP(\"udp\", nil, sp.bootstrap)\n\tif err != nil {\n\t\treturn netip.Addr{}, 0, err\n\t}\n\tdefer c.Close()\n\n\twriteErrC := make(chan error, 1)\n\ttype res struct {\n\t\tresp *dns.Msg\n\t\terr  error\n\t}\n\treadResC := make(chan res, 1)\n\n\tcancelWrite := make(chan struct{})\n\tdefer close(cancelWrite)\n\tgo func() {\n\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\twriteErrC <- err\n\t\t\treturn\n\t\t}\n\n\t\tretryTicker := time.NewTicker(time.Second)\n\t\tdefer retryTicker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-cancelWrite:\n\t\t\t\treturn\n\t\t\tcase <-retryTicker.C:\n\t\t\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\t\t\twriteErrC <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tm, _, err := dnsutils.ReadMsgFromUDP(c, edns0UdpSize)\n\t\treadResC <- res{resp: m, err: err}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn netip.Addr{}, 0, context.Cause(ctx)\n\tcase err := <-writeErrC:\n\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to write query, %w\", err)\n\tcase r := <-readResC:\n\t\tresp := r.resp\n\t\terr := r.err\n\t\tif err != nil {\n\t\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to read resp, %w\", err)\n\t\t}\n\n\t\tfor _, v := range resp.Answer {\n\t\t\tvar ip net.IP\n\t\t\tvar ttl uint32\n\t\t\tswitch rr := v.(type) {\n\t\t\tcase *dns.A:\n\t\t\t\tip = rr.A\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tcase *dns.AAAA:\n\t\t\t\tip = rr.AAAA\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr, ok := netip.AddrFromSlice(ip)\n\t\t\tif ok {\n\t\t\t\treturn addr, ttl, nil\n\t\t\t}\n\t\t}\n\n\t\treturn netip.Addr{}, 0, errNoAddrInResp\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn        string\n\tport        uint16\n\tbootstrap   *net.UDPAddr\n\tqt          uint16\n\tlogger      *zap.Logger\n\tupdating    atomic.Bool\n\tnextUpdate  time.Time\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (b *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tb.m.Lock()\n\tif b.ready {\n\t\taddr, err := netip.ParseAddr(b.addrStr)\n\t\tb.m.Unlock()\n\t\tif err != nil {\n\t\t\treturn netip.Addr{}, 0, err\n\t\t}\n\t\treturn addr, 0, nil\n\t}\n\tb.m.Unlock()\n\n\tif !b.updating.CompareAndSwap(false, true) {\n\t\tselect {\n\t\tcase <-b.readyNotify:\n\t\t\tb.m.Lock()\n\t\t\taddr, err := netip.ParseAddr(b.addrStr)\n\t\t\tb.m.Unlock()\n\t\t\tif err != nil {\n\t\t\t\treturn netip.Addr{}, 0, err\n\t\t\t}\n\t\t\treturn addr, 0, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn netip.Addr{}, 0, ctx.Err()\n\t\t}\n\t}\n\n\tdefer b.updating.Store(false)\n\n\tconn, err := net.DialUDP(\"udp\", nil, b.bootstrap)\n\tif err != nil {\n\t\tb.logger.Error(\"Failed to dial UDP\", zap.Error(err))\n\t\treturn netip.Addr{}, 0, err\n\t}\n\tdefer conn.Close()\n\n\tquery := buildDNSQuery(b.fqdn, qt)\n\tif _, err := conn.Write(query); err != nil {\n\t\tb.logger.Error(\"Failed to write query\", zap.Error(err))\n\t\treturn netip.Addr{}, 0, err\n\t}\n\n\tconn.SetReadDeadline(time.Now().Add(5 * time.Second))\n\tbuf := make([]byte, 512)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tb.logger.Error(\"Failed to read response\", zap.Error(err))\n\t\treturn netip.Addr{}, 0, err\n\t}\n\n\taddr, ttl, err := parseDNSResponse(buf[:n])\n\tif err != nil {\n\t\tb.logger.Error(\"Failed to parse response\", zap.Error(err))\n\t\treturn netip.Addr{}, 0, err\n\t}\n\n\tb.m.Lock()\n\tb.addrStr = addr.String()\n\tb.ready = true\n\tb.m.Unlock()\n\n\tclose(b.readyNotify)\n\treturn addr, ttl, nil\n}\n\nfunc buildDNSQuery(fqdn string, qt uint16) []byte {\n\t// Implement DNS query construction\n\treturn []byte{}\n}\n\nfunc parseDNSResponse(response []byte) (netip.Addr, uint32, error) {\n\t// Implement DNS response parsing\n\treturn netip.Addr{}, 0, errors.New(\"not implemented\")\n}\n\nfunc main() {\n\t// Example usage\n}\n```"
  },
  {
    "Task_id": 368,
    "Instruction": "Task Description: Implement a UDP client in Go that communicates with a NAT-PMP (Port Mapping Protocol) gateway, handling retries and timeouts for reliable communication.\n\nStruct Description: The `network` struct represents a network connection to a NAT-PMP gateway, maintaining the gateway IP address and providing a method to send requests and receive responses.\n\nFields:\n- gateway: net.IP - The IP address of the NAT-PMP gateway\n\nMethods:\n- call: (msg []byte, timeout time.Duration) -> ([]byte, error) - Sends a UDP message to the NAT-PMP gateway and waits for a response. Implements exponential backoff retry logic with configurable timeout. Returns the response bytes or an error if communication fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nconst nAT_PMP_PORT = 5351\nconst nAT_TRIES = 9\nconst nAT_INITIAL_MS = 250\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) (result []byte, err error) {\n\tvar server net.UDPAddr\n\tserver.IP = n.gateway\n\tserver.Port = nAT_PMP_PORT\n\tconn, err := net.DialUDP(\"udp\", nil, &server)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tresult = make([]byte, 16)\n\n\tvar finalTimeout time.Time\n\tif timeout != 0 {\n\t\tfinalTimeout = time.Now().Add(timeout)\n\t}\n\n\tneedNewDeadline := true\n\n\tvar tries uint\n\tfor tries = 0; (tries < nAT_TRIES && finalTimeout.IsZero()) || time.Now().Before(finalTimeout); {\n\t\tif needNewDeadline {\n\t\t\tnextDeadline := time.Now().Add((nAT_INITIAL_MS << tries) * time.Millisecond)\n\t\t\terr = conn.SetDeadline(minTime(nextDeadline, finalTimeout))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tneedNewDeadline = false\n\t\t}\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tvar bytesRead int\n\t\tvar remoteAddr *net.UDPAddr\n\t\tbytesRead, remoteAddr, err = conn.ReadFromUDP(result)\n\t\tif err != nil {\n\t\t\tif err.(net.Error).Timeout() {\n\t\t\t\ttries++\n\t\t\t\tneedNewDeadline = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif !remoteAddr.IP.Equal(n.gateway) {\n\t\t\tcontinue\n\t\t}\n\t\tif bytesRead < len(result) {\n\t\t\tresult = result[:bytesRead]\n\t\t}\n\t\treturn\n\t}\n\terr = fmt.Errorf(\"Timed out trying to contact gateway\")\n\treturn\n}\n\nfunc minTime(a, b time.Time) time.Time {\n\tif a.IsZero() {\n\t\treturn b\n\t}\n\tif b.IsZero() {\n\t\treturn a\n\t}\n\tif a.Before(b) {\n\t\treturn a\n\t}\n\treturn b\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) ([]byte, error) {\n\tconst maxRetries = 5\n\tconst baseDelay = 500 * time.Millisecond\n\n\taddr := &net.UDPAddr{IP: n.gateway, Port: 5351}\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dial UDP: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tvar response []byte\n\tfor attempt := 0; attempt < maxRetries; attempt++ {\n\t\t_, err := conn.Write(msg)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to send message: %w\", err)\n\t\t}\n\n\t\tconn.SetReadDeadline(time.Now().Add(timeout))\n\t\tresponse = make([]byte, 1024)\n\t\tn, err := conn.Read(response)\n\t\tif err == nil {\n\t\t\treturn response[:n], nil\n\t\t}\n\n\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\ttime.Sleep(baseDelay * (1 << attempt))\n\t\t\tcontinue\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"failed to read response: %w\", err)\n\t}\n\n\treturn nil, errors.New(\"max retries reached, no response from gateway\")\n}\n\nfunc main() {\n\tgatewayIP := net.ParseIP(\"192.168.1.1\")\n\tn := &network{gateway: gatewayIP}\n\n\tmsg := []byte{0, 0, 0, 0} // Example NAT-PMP request\n\ttimeout := 2 * time.Second\n\n\tresponse, err := n.call(msg, timeout)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Response:\", response)\n}\n```"
  },
  {
    "Task_id": 369,
    "Instruction": "Task Description: Create a function that sends a predefined stop marker to a destination address over UDP protocol.\n\nFunction Description: The function `sendStopMarker` establishes a UDP connection between a source address and a destination address, then sends a fixed byte sequence (stop marker) to indicate a stopping condition. It handles basic error logging if the connection fails.\n\nInput: \n- `src` [string]: The source IP address or hostname (without port)\n- `dst` [string]: The destination IP address or hostname (without port)\n\nOutput: None (void function). The function writes the stop marker to the UDP connection but doesn't return any value. Errors are logged if they occur.",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n)\n\nvar stopMarker = []byte{2, 2, 2, 2, 2, 2, 2, 2}\n\nfunc sendStopMarker(src, dst string) {\n\tl, _ := net.ResolveUDPAddr(\"udp\", src+\":2222\")\n\tr, _ := net.ResolveUDPAddr(\"udp\", dst+\":2222\")\n\tconn, err := net.DialUDP(\"udp\", l, r)\n\tif err != nil {\n\t\tlog.Printf(\"fail to send stopmarker: %s\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tconn.Write(stopMarker)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n)\n\nfunc sendStopMarker(src, dst string) {\n\tconst stopMarker = \"STOP\"\n\tsrcAddr, err := net.ResolveUDPAddr(\"udp\", src+\":0\")\n\tif err != nil {\n\t\tlog.Printf(\"Error resolving source address: %v\", err)\n\t\treturn\n\t}\n\n\tdstAddr, err := net.ResolveUDPAddr(\"udp\", dst+\":0\")\n\tif err != nil {\n\t\tlog.Printf(\"Error resolving destination address: %v\", err)\n\t\treturn\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", srcAddr, dstAddr)\n\tif err != nil {\n\t\tlog.Printf(\"Error establishing UDP connection: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(stopMarker))\n\tif err != nil {\n\t\tlog.Printf(\"Error sending stop marker: %v\", err)\n\t}\n}\n\nfunc main() {\n\tsendStopMarker(\"127.0.0.1\", \"192.168.1.1\")\n}"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Implement a UDP-based trap listener for SNMP (Simple Network Management Protocol) messages, capable of receiving and processing traps/informs, with support for SNMPv3 security features and proper resource cleanup.\n\nStruct Description: TrapListener is a struct that manages a UDP listener for SNMP traps, handling incoming messages, security validation, and response generation.\n\nFields:\n- done: chan bool - Channel to signal completion of listener shutdown\n- listening: chan bool - Channel to signal when listener is active\n- Mutex: sync.Mutex - Mutex for thread-safe operations\n- Params: *GoSNMP - Configuration parameters for SNMP handling\n- OnNewTrap: TrapHandlerFunc - Callback function for new trap processing\n- CloseTimeout: time.Duration - Timeout for graceful shutdown\n- conn: *net.UDPConn - UDP connection object\n- proto: string - Protocol type (typically \"udp\")\n- usmStatsUnknownEngineIDsCount: uint32 - Counter for unknown engine IDs (SNMPv3)\n- finish: int32 - Atomic flag for shutdown state\n\nMethods:\n- NewTrapListener() -> *TrapListener - Creates and initializes a new TrapListener instance\n- Close() - Gracefully shuts down the listener and cleans up resources\n- SendUDP(packet *SnmpPacket, addr *net.UDPAddr) -> error - Sends an SNMP packet via UDP\n- listenUDP(addr string) -> error - Main listening loop for incoming traps\n- reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) -> error - Handles SNMPv3 engine ID mismatch reporting",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype TrapListener struct {\n\tdone      chan bool\n\tlistening chan bool\n\tsync.Mutex\n\n\tParams *GoSNMP\n\n\tOnNewTrap TrapHandlerFunc\n\n\tCloseTimeout time.Duration\n\n\tconn  *net.UDPConn\n\tproto string\n\n\tusmStatsUnknownEngineIDsCount uint32\n\n\tfinish int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\ttl := &TrapListener{\n\t\tfinish:       0,\n\t\tdone:         make(chan bool),\n\t\tlistening:    make(chan bool, 1),\n\t\tCloseTimeout: defaultCloseTimeout,\n\t}\n\n\treturn tl\n}\n\nfunc (t *TrapListener) Close() {\n\tif atomic.CompareAndSwapInt32(&t.finish, 0, 1) {\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\n\t\tif t.conn == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err := t.conn.Close(); err != nil {\n\t\t\tt.Params.Logger.Printf(\"failed to Close() the TrapListener socket: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-t.done:\n\t\tcase <-time.After(t.CloseTimeout):\n\t\t\tt.Params.Logger.Printf(\"timeout while awaiting done signal on TrapListener Close()\")\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\tob, err := packet.marshalMsg()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling SnmpPacket: %w\", err)\n\t}\n\n\tcount, err := t.conn.WriteTo(ob, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending SnmpPacket: %w\", err)\n\t}\n\n\tif count != len(ob) {\n\t\tt.Params.Logger.Printf(\"Failed to send all bytes of SnmpPacket!\\n\")\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn, err = net.ListenUDP(udp, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer t.conn.Close()\n\n\tt.listening <- true\n\n\tfor {\n\t\tswitch {\n\t\tcase atomic.LoadInt32(&t.finish) == 1:\n\t\t\tt.done <- true\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tvar buf [4096]byte\n\t\t\trlen, remote, err := t.conn.ReadFromUDP(buf[:])\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&t.finish) == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in read %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg := buf[:rlen]\n\t\t\ttrap, err := t.Params.UnmarshalTrap(msg, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in UnmarshalTrap %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif trap.Version == Version3 && trap.SecurityModel == UserSecurityModel && t.Params.SecurityModel == UserSecurityModel {\n\t\t\t\tsecurityParams, ok := t.Params.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tpacketSecurityParams, ok := trap.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tsnmpEngineID := securityParams.AuthoritativeEngineID\n\t\t\t\tmsgAuthoritativeEngineID := packetSecurityParams.AuthoritativeEngineID\n\t\t\t\tif msgAuthoritativeEngineID != snmpEngineID {\n\t\t\t\t\tif len(msgAuthoritativeEngineID) < 5 || len(msgAuthoritativeEngineID) > 32 {\n\t\t\t\t\t\tatomic.AddUint32(&t.usmStatsUnknownEngineIDsCount, 1)\n\t\t\t\t\t\terr := t.reportAuthoritativeEngineID(trap, snmpEngineID, remote)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.OnNewTrap(trap, remote)\n\n\t\t\tif trap.PDUType == InformRequest {\n\t\t\t\ttrap.PDUType = GetResponse\n\t\t\t\ttrap.Error = NoError\n\t\t\t\ttrap.ErrorIndex = 0\n\t\t\t\terr := t.SendUDP(trap, remote)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tnewSecurityParams, ok := trap.SecurityParameters.Copy().(*UsmSecurityParameters)\n\tif !ok {\n\t\treturn errors.New(\"unable to cast SecurityParams to UsmSecurityParameters\")\n\t}\n\tnewSecurityParams.AuthoritativeEngineID = snmpEngineID\n\treportPacket := trap\n\treportPacket.PDUType = Report\n\treportPacket.MsgFlags &= AuthPriv\n\treportPacket.SecurityParameters = newSecurityParams\n\treportPacket.Variables = []SnmpPDU{\n\t\t{\n\t\t\tName:  usmStatsUnknownEngineIDs,\n\t\t\tValue: int(atomic.LoadUint32(&t.usmStatsUnknownEngineIDsCount)),\n\t\t\tType:  Integer,\n\t\t},\n\t}\n\treturn t.SendUDP(reportPacket, addr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\t\"sync/atomic\"\n\t\"github.com/gosnmp/gosnmp\"\n)\n\ntype TrapHandlerFunc func(packet *gosnmp.SnmpPacket, addr *net.UDPAddr)\n\ntype TrapListener struct {\n\tdone                        chan bool\n\tlistening                   chan bool\n\tMutex                       sync.Mutex\n\tParams                      *gosnmp.GoSNMP\n\tOnNewTrap                   TrapHandlerFunc\n\tCloseTimeout                time.Duration\n\tconn                        *net.UDPConn\n\tproto                       string\n\tusmStatsUnknownEngineIDsCount uint32\n\tfinish                      int32\n}\n\nfunc NewTrapListener(params *gosnmp.GoSNMP, handler TrapHandlerFunc, closeTimeout time.Duration) *TrapListener {\n\treturn &TrapListener{\n\t\tdone:          make(chan bool),\n\t\tlistening:     make(chan bool),\n\t\tParams:        params,\n\t\tOnNewTrap:     handler,\n\t\tCloseTimeout:  closeTimeout,\n\t\tproto:         \"udp\",\n\t}\n}\n\nfunc (tl *TrapListener) Close() {\n\tatomic.StoreInt32(&tl.finish, 1)\n\ttl.conn.Close()\n\tselect {\n\tcase <-tl.done:\n\tcase <-time.After(tl.CloseTimeout):\n\t}\n}\n\nfunc (tl *TrapListener) SendUDP(packet *gosnmp.SnmpPacket, addr *net.UDPAddr) error {\n\ttl.Mutex.Lock()\n\tdefer tl.Mutex.Unlock()\n\t_, err := tl.conn.WriteTo(packet.MarshalMsg(), addr)\n\treturn err\n}\n\nfunc (tl *TrapListener) listenUDP(addr string) error {\n\tvar err error\n\ttl.conn, err = net.ListenUDP(tl.proto, &net.UDPAddr{IP: net.ParseIP(addr)})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tl.conn.Close()\n\n\ttl.listening <- true\n\tbuf := make([]byte, 65536)\n\n\tfor {\n\t\tif atomic.LoadInt32(&tl.finish) == 1 {\n\t\t\ttl.done <- true\n\t\t\treturn nil\n\t\t}\n\n\t\tn, remoteAddr, err := tl.conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tpacket := &gosnmp.SnmpPacket{}\n\t\terr = packet.Unmarshal(buf[:n])\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif tl.Params.Version == gosnmp.Version3 {\n\t\t\tif packet.SecurityParameters != nil {\n\t\t\t\tsp := packet.SecurityParameters.(*gosnmp.UsmSecurityParameters)\n\t\t\t\tif sp.AuthoritativeEngineID != tl.Params.SecurityParameters.(*gosnmp.UsmSecurityParameters).AuthoritativeEngineID {\n\t\t\t\t\ttl.reportAuthoritativeEngineID(packet, sp.AuthoritativeEngineID, remoteAddr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttl.OnNewTrap(packet, remoteAddr)\n\t}\n}\n\nfunc (tl *TrapListener) reportAuthoritativeEngineID(trap *gosnmp.SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tatomic.AddUint32(&tl.usmStatsUnknownEngineIDsCount, 1)\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, processes incoming messages using ROT13 cipher, and sends the transformed messages back to the client.\n\nFunction Description: The function initializes a UDP server that continuously listens for incoming datagrams on a specified port. For each received message, it applies the ROT13 cipher transformation and sends the result back to the originating client. The server handles network errors and cleans up resources properly on exit.\n\nInput:\n- port: int - The UDP port number to listen on (passed as a pointer in the original code)\n\nOutput: None (the function runs indefinitely until terminated or an unrecoverable error occurs)\n\nNote: The function uses external packages for logging (github.com/enfein/mieru/v3/pkg/log) and ROT13 transformation (github.com/enfein/mieru/v3/pkg/testtool). The main processing loop includes error handling for network operations and message processing.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n)\nfunc main() {\n\taddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.Itoa(*port))\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ResolveUDPAddr() failed: %v\", err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ListenUDP() failed: %v\", err)\n\t}\n\tlog.Infof(\"UDP server is initialized, listening to %s\", addr.String())\n\tdefer conn.Close()\n\tbuf := make([]byte, 1500)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Read() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tout, err := testtool.TestHelperRot13(buf[:n])\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"rot13() failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err = conn.WriteToUDP(out, addr); err != nil {\n\t\t\tlog.Errorf(\"Write() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n)\n\nfunc startUDPServer(port *int) {\n\taddr := net.UDPAddr{\n\t\tPort: *port,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", &addr)\n\tif err != nil {\n\t\tlog.Error(\"Failed to start UDP server: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tlog.Info(\"UDP server listening on port %d\", *port)\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-sigChan\n\t\tlog.Info(\"Shutting down UDP server\")\n\t\tconn.Close()\n\t\tos.Exit(0)\n\t}()\n\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tn, clientAddr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error reading from UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tmessage := string(buffer[:n])\n\t\tlog.Info(\"Received message: %s from %s\", message, clientAddr)\n\n\t\ttransformedMessage := testtool.ROT13(message)\n\t\tlog.Info(\"Transformed message: %s\", transformedMessage)\n\n\t\t_, err = conn.WriteToUDP([]byte(transformedMessage), clientAddr)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error sending response: %v\", err)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tport := 8080\n\tstartUDPServer(&port)\n}"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a UDP server for handling SOCKS5 proxy requests, including UDP association and data relay between clients and a Hysteria proxy client.\n\nStruct Description: The Server struct represents a SOCKS5 proxy server with UDP support, handling client connections and relaying UDP traffic through a Hysteria proxy.\n\nFields:\n\nHyClient: [client.Client] - The Hysteria client used for establishing proxy connections\nAuthFunc: [func(username, password string) bool] - Authentication function for SOCKS5 clients\nDisableUDP: [bool] - Flag to disable UDP functionality\nEventLogger: [EventLogger] - Interface for logging server events\n\nMethods:\n\nhandleUDP: [func(conn net.Conn, req *socks5.Request)] - none - Handles a new UDP association request from a SOCKS5 client\nudpServer: [func(udpConn *net.UDPConn, hyUDP client.HyUDPConn)] -> [error] - Manages the UDP relay between client and Hysteria proxy\nsendUDPReply: [func(conn net.Conn, addr *net.UDPAddr)] -> [error] - Sends a UDP association reply to the SOCKS5 client\n\nInterface Description:\n\nEventLogger: Interface for logging UDP-related events\nMethods:\nUDPRequest: [func(addr net.Addr)] - Logs incoming UDP requests\nUDPError: [func(addr net.Addr, err error)] - Logs UDP-related errors",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/txthinking/socks5\"\n\n\t\"github.com/apernet/hysteria/core/v2/client\"\n)\n\ntype Server struct {\n\tHyClient    client.Client\n\tAuthFunc    func(username, password string) bool\n\tDisableUDP  bool\n\tEventLogger EventLogger\n}\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\tdefer conn.Close()\n\n\tif s.EventLogger != nil {\n\t\ts.EventLogger.UDPRequest(conn.RemoteAddr())\n\t}\n\tvar closeErr error\n\tdefer func() {\n\t\tif s.EventLogger != nil {\n\t\t\ts.EventLogger.UDPError(conn.RemoteAddr(), closeErr)\n\t\t}\n\t}()\n\n\thost, _, err := net.SplitHostPort(conn.LocalAddr().String())\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(host, \"0\"))\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer udpConn.Close()\n\n\thyUDP, err := s.HyClient.UDP()\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer hyUDP.Close()\n\n\t_ = sendUDPReply(conn, udpConn.LocalAddr().(*net.UDPAddr))\n\n\terrChan := make(chan error, 2)\n\tgo func() {\n\t\terr := s.udpServer(udpConn, hyUDP)\n\t\terrChan <- err\n\t}()\n\tgo func() {\n\t\t_, err := io.Copy(io.Discard, conn)\n\t\terrChan <- err\n\t}()\n\tcloseErr = <-errChan\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\tvar clientAddr *net.UDPAddr\n\tbuf := make([]byte, udpBufferSize)\n\tfor {\n\t\tn, cAddr, err := udpConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td, err := socks5.NewDatagramFromBytes(buf[:n])\n\t\tif err != nil || d.Frag != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif clientAddr == nil {\n\t\t\tclientAddr = cAddr\n\t\t\tgo func() {\n\t\t\t\tfor {\n\t\t\t\t\tbs, from, err := hyUDP.Receive()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t_ = udpConn.Close()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tatyp, addr, port, err := socks5.ParseAddress(from)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif atyp == socks5.ATYPDomain {\n\t\t\t\t\t\taddr = addr[1:]\n\t\t\t\t\t}\n\t\t\t\t\td := socks5.NewDatagram(atyp, addr, port, bs)\n\t\t\t\t\t_, _ = udpConn.WriteToUDP(d.Bytes(), clientAddr)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else if !clientAddr.IP.Equal(cAddr.IP) || clientAddr.Port != cAddr.Port {\n\t\t\tcontinue\n\t\t}\n\t\t_ = hyUDP.Send(d.Data, d.Address())\n\t}\n}\n\nfunc sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\tvar atyp byte\n\tvar bndAddr, bndPort []byte\n\tif ip4 := addr.IP.To4(); ip4 != nil {\n\t\tatyp = socks5.ATYPIPv4\n\t\tbndAddr = ip4\n\t} else {\n\t\tatyp = socks5.ATYPIPv6\n\t\tbndAddr = addr.IP\n\t}\n\tbndPort = make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bndPort, uint16(addr.Port))\n\tp := socks5.NewReply(socks5.RepSuccess, atyp, bndAddr, bndPort)\n\t_, err := p.WriteTo(conn)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"github.com/yourorg/hysteria/client\"\n)\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\ntype Server struct {\n\tHyClient    client.Client\n\tAuthFunc    func(username, password string) bool\n\tDisableUDP  bool\n\tEventLogger EventLogger\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\tif s.DisableUDP {\n\t\treturn\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", req.Address())\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", nil)\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\tdefer udpConn.Close()\n\n\thyUDP, err := s.HyClient.UDP()\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\tdefer hyUDP.Close()\n\n\tif err := s.sendUDPReply(conn, udpConn.LocalAddr().(*net.UDPAddr)); err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\n\ts.EventLogger.UDPRequest(conn.RemoteAddr())\n\tif err := s.udpServer(udpConn, hyUDP); err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t}\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\tbuf := make([]byte, 65535)\n\tfor {\n\t\tn, clientAddr, err := udpConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.EventLogger.UDPRequest(clientAddr)\n\n\t\t_, err = hyUDP.WriteTo(buf[:n], clientAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tn, _, err = hyUDP.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = udpConn.WriteTo(buf[:n], clientAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *Server) sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\treply := socks5.NewReply(socks5.Succeeded, socks5.UDP, addr.IP, addr.Port)\n\t_, err := conn.Write(reply.Bytes())\n\treturn err\n}\n```"
  },
  {
    "Task_id": 376,
    "Instruction": "Task Description: Create a UDP server in Go that listens for incoming messages on a specified port and prints received messages along with the sender's address.\n\nFunction Description: The function sets up a UDP server that continuously listens for incoming datagrams on a specified port. For each received message, it trims whitespace, prints the message content and the sender's address, and continues listening for new messages.\n\nInput: None (The port and IP address are hardcoded in the function)\n\nOutput: None (The function prints output to stdout but doesn't return any values)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\nfunc main() {\n\tconn, err := net.ListenUDP(\"udp\", &net.UDPAddr{\n\t\tPort: 3000,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer conn.Close()\n\tfmt.Printf(\"server listening %s\\n\", conn.LocalAddr().String())\n\n\tfor {\n\t\tmessage := make([]byte, 20)\n\t\trlen, remote, err := conn.ReadFromUDP(message[:])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdata := strings.TrimSpace(string(message[:rlen]))\n\t\tfmt.Printf(\"received: %s from %s\\n\", data, remote)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc main() {\n\taddr := net.UDPAddr{\n\t\tPort: 8080,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t}\n\tconn, err := net.ListenUDP(\"udp\", &addr)\n\tif err != nil {\n\t\tfmt.Println(\"Error setting up UDP server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, remoteAddr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from UDP:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tmessage := strings.TrimSpace(string(buffer[:n]))\n\t\tfmt.Printf(\"Received message: '%s' from %s\\n\", message, remoteAddr)\n\t}\n}"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, receives messages from clients, and echoes them back to the sender.\n\nFunction Description: The function sets up a UDP server that binds to a given port, continuously listens for incoming messages, and responds by sending the received message back to the client. It handles network errors gracefully and ensures resources are properly cleaned up.\n\nInput: \n- port [string] - The port number on which the UDP server should listen (e.g., \":10002\")\n\nOutput: \n- None (The function runs indefinitely until interrupted)\n- Error messages are printed to stdout if any occur during setup or operation\n\nNote: The function does not return any values but prints status and error messages to stdout. It runs in an infinite loop to handle continuous incoming UDP messages.\n\nThe function performs the following key operations:\n1. Resolves the UDP address using the provided port\n2. Creates and binds a UDP listener\n3. Sets up deferred cleanup for the connection\n4. Enters a loop to read incoming messages and echo them back\n5. Handles and reports any network errors that occur",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tserverType := strings.ToLower(os.Getenv(\"serverType\"))\n\n\tif serverType == \"udp\" {\n\t\tServerAddr, err := net.ResolveUDPAddr(\"udp\", \":10002\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Started UDP server on port 10002\")\n\n\t\tServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tdefer ServerConn.Close()\n\n\t\tbuf := make([]byte, 1024)\n\n\t\tfor {\n\t\t\tn, addr, err := ServerConn.ReadFromUDP(buf)\n\t\t\tfmt.Printf(\"received: %s from: %s\\n\", string(buf[0:n]), addr)\n\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"error: \", err)\n\t\t\t}\n\n\t\t\tServerConn.WriteTo(buf[0:n], addr)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc startUDPServer(port string) {\n\taddr, err := net.ResolveUDPAddr(\"udp\", port)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error resolving address: %v\\n\", err)\n\t\treturn\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error listening on UDP: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfmt.Printf(\"UDP server listening on %s\\n\", port)\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, clientAddr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading from UDP: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Received message from %s: %s\\n\", clientAddr, string(buffer[:n]))\n\n\t\t_, err = conn.WriteToUDP(buffer[:n], clientAddr)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error sending response to %s: %v\\n\", clientAddr, err)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tport := \":10002\"\n\tstartUDPServer(port)\n}"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Implement a WebSocket proxy struct in Go that can handle bidirectional communication between a client and a backend server, including connection upgrading, message replication, and error handling.\n\nStruct Description: The WebsocketProxy struct acts as a reverse proxy for WebSocket connections, forwarding messages between clients and backend servers while handling connection upgrades and error scenarios.\n\nFields:\n\nDirector: func(*http.Request, http.Header) - A function that can modify the outgoing request headers before connecting to the backend.\nBackend: func(*http.Request) *url.URL - A function that returns the backend URL to connect to.\nUpgrader: *websocket.Upgrader - Configures the WebSocket connection upgrade from HTTP.\nDialer: *websocket.Dialer - Configures how to dial the backend WebSocket connection.\n\nMethods:\n\nServeHTTP: (http.ResponseWriter, *http.Request) -> None - The main handler method that:\n  1. Determines the backend URL\n  2. Establishes connection to backend\n  3. Upgrades client connection\n  4. Sets up bidirectional message replication\n  5. Handles ping/pong messages\n  6. Manages connection errors and closures\n\nreplicateWebsocketConn: (*websocket.Conn, *websocket.Conn, chan error) -> None - A helper method that:\n  1. Continuously reads messages from source connection\n  2. Forwards them to destination connection\n  3. Handles connection errors and closure messages\n  4. Reports errors through the provided channel",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/samber/lo\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tconnPub.SetPingHandler(func(appData string) error {\n\t\terr := connBackend.WriteControl(websocket.PingMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = connPub.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif errors.Is(err, websocket.ErrCloseSent) {\n\t\t\treturn nil\n\t\t} else if e, ok := lo.ErrorsAs[net.Error](err); ok && e.Timeout() {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\n\tvar closeError *websocket.CloseError\n\tif ok := errors.As(err, &closeError); !ok || (closeError != nil && closeError.Code == websocket.CloseAbnormalClosure) {\n\t\tlog.Printf(message, err)\n\t}\n}\n\nfunc replicateWebsocketConn(dst, src *websocket.Conn, errc chan error) {\n\tfor {\n\t\tmsgType, msg, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\tif e, ok := lo.ErrorsAs[*websocket.CloseError](err); ok && e != nil {\n\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t\terrc <- err\n\t\t\t_ = dst.WriteMessage(websocket.CloseMessage, m)\n\t\t\tbreak\n\t\t}\n\t\terr = dst.WriteMessage(msgType, msg)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "right_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(*http.Request, http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tbackendURL := p.Backend(r)\n\tif backendURL == nil {\n\t\thttp.Error(w, \"Backend URL not found\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif p.Director != nil {\n\t\tp.Director(r, r.Header)\n\t}\n\n\tconnBackend, resp, err := p.Dialer.Dial(backendURL.String(), r.Header)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to connect to backend\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tconnClient, err := p.Upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer connClient.Close()\n\n\terrChan := make(chan error, 2)\n\tgo p.replicateWebsocketConn(connClient, connBackend, errChan)\n\tgo p.replicateWebsocketConn(connBackend, connClient, errChan)\n\n\tselect {\n\tcase err := <-errChan:\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"WebSocket error\", http.StatusInternalServerError)\n\t\t}\n\t}\n}\n\nfunc (p *WebsocketProxy) replicateWebsocketConn(src, dest *websocket.Conn, errChan chan error) {\n\tfor {\n\t\tmessageType, message, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tif err := dest.WriteMessage(messageType, message); err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tproxy := &WebsocketProxy{\n\t\tDirector: func(req *http.Request, header http.Header) {\n\t\t\t// Modify headers if needed\n\t\t},\n\t\tBackend: func(req *http.Request) *url.URL {\n\t\t\treturn &url.URL{Scheme: \"ws\", Host: \"backend.example.com\"}\n\t\t},\n\t\tUpgrader: &websocket.Upgrader{},\n\t\tDialer:   &websocket.Dialer{},\n\t}\n\n\thttp.Handle(\"/ws\", proxy)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and returns a simple text response.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" message to the response writer. The `main` function sets up the HTTP server by registering the handler and starting the server on port 8080.\n\nInput: \n- `w http.ResponseWriter`: Used to write the HTTP response.\n- `r *http.Request`: Contains information about the incoming HTTP request.\n\nOutput: \n- The `handler` function writes \"Hello World, I'm Golang!\" to the response writer (`w`).\n- The `main` function starts an HTTP server that listens on port 8080 and serves the response from the `handler` function.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Implement a WebSocket server in Go that handles WebSocket connections, messages, and events using the nhooyr.io/websocket package. The server should provide event-based handling for connection establishment, message reception, and connection closure.\n\nStruct Description: The `testServer` struct represents a WebSocket server with event handling capabilities. It manages HTTP routes, WebSocket connections, and provides methods to subscribe to WebSocket events.\n\nFields:\n\n- sync.Mutex: sync.Mutex - Provides thread-safe access to the server's resources\n- eventEmitter: playwright.EventEmitter - Handles event subscription and emission for WebSocket events\n- mux: *http.ServeMux - HTTP request multiplexer for routing\n- testServer: *httptest.Server - HTTP test server instance\n- routes: map[string]http.HandlerFunc - Map of URL paths to their handler functions\n- requestSubscriberes: map[string][]chan *http.Request - Channels for request subscribers\n- PREFIX: string - Server URL prefix\n- EMPTY_PAGE: string - Path to empty page\n- CROSS_PROCESS_PREFIX: string - Prefix for cross-process communication\n- WS_PREFIX: string - WebSocket endpoint prefix\n- PORT: string - Server port number\n\nMethods:\n\n- wsHandler: (w http.ResponseWriter, r *http.Request) -> void - Handles WebSocket connection upgrade and message processing\n- OnceWebSocketConnection: (handler func(c *websocket.Conn, r *http.Request)) -> void - Registers a one-time connection handler\n- OnWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a persistent close handler\n- OnceWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a one-time close handler\n- OnWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a persistent message handler\n- OnceWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a one-time message handler\n- SendOnWebSocketConnection: (msgType websocket.MessageType, data []byte) -> void - Sends a message when a connection is established\n- WaitForWebSocketConnection: () -> <-chan *wsConnection - Returns a channel that receives the first WebSocket connection\n\nAdditional Struct:\n\n- wsConnection: struct - Represents an active WebSocket connection\n  Fields:\n    - Conn: *websocket.Conn - The WebSocket connection\n    - Req: *http.Request - The associated HTTP request\n  Methods:\n    - SendMessage: (msgType websocket.MessageType, data []byte) -> void - Sends a message through the connection",
    "Canonical_solution": "import (\n\t\"github.com/coder/websocket\"\n\t\"github.com/playwright-community/playwright-go\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype testServer struct {\n\tsync.Mutex\n\teventEmitter         playwright.EventEmitter\n\tmux                  *http.ServeMux\n\ttestServer           *httptest.Server\n\troutes               map[string]http.HandlerFunc\n\trequestSubscriberes  map[string][]chan *http.Request\n\tPREFIX               string\n\tEMPTY_PAGE           string\n\tCROSS_PROCESS_PREFIX string\n\tWS_PREFIX            string\n\tPORT                 string\n}\n\nfunc (t *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tInsecureSkipVerify: true,\n\t})\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not upgrade ws connection:\", err)\n\t\treturn\n\t}\n\tdefer c.Close(websocket.StatusNormalClosure, \"\")\n\n\tt.eventEmitter.Emit(\"connection\", c, r)\n\n\tfor {\n\t\ttyp, message, err := c.Read(r.Context())\n\t\tif err != nil {\n\t\t\tcloseErr := new(websocket.CloseError)\n\t\t\tif errors.As(err, closeErr) {\n\t\t\t\tt.eventEmitter.Emit(\"close\", closeErr)\n\t\t\t}\n\t\t\tswitch websocket.CloseStatus(err) {\n\t\t\tcase websocket.StatusNormalClosure, websocket.StatusGoingAway, websocket.StatusNoStatusRcvd:\n\t\t\tdefault:\n\t\t\t\tlog.Println(\"testServer: could not read ws message:\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tt.eventEmitter.Emit(\"message\", c, r, typ, message)\n\t}\n}\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (c *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\terr := c.Conn.Write(c.Req.Context(), msgType, data)\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\treturn\n\t}\n}\n\nfunc (t *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\tt.eventEmitter.Once(\"connection\", handler)\n}\n\nfunc (t *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.On(\"close\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.Once(\"close\", handler)\n}\n\nfunc (t *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.On(\"message\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.Once(\"message\", handler)\n}\n\nfunc (t *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\terr := c.Write(r.Context(), msgType, data)\n\t\tif err != nil {\n\t\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\t\treturn\n\t\t}\n\t})\n}\n\nfunc (t *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\tchannel := make(chan *wsConnection)\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tchannel <- &wsConnection{Conn: c, Req: r}\n\t\tclose(channel)\n\t})\n\treturn channel\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"nhooyr.io/websocket\"\n\t\"nhooyr.io/websocket/wsjson\"\n\t\"github.com/playwright-community/playwright-go\"\n)\n\ntype testServer struct {\n\tsync.Mutex\n\teventEmitter       *playwright.EventEmitter\n\tmux                *http.ServeMux\n\ttestServer         *httptest.Server\n\troutes             map[string]http.HandlerFunc\n\trequestSubscribers map[string][]chan *http.Request\n\tPREFIX             string\n\tEMPTY_PAGE         string\n\tCROSS_PROCESS_PREFIX string\n\tWS_PREFIX          string\n\tPORT               string\n}\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (ws *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\tws.Conn.Write(context.Background(), msgType, data)\n}\n\nfunc (ts *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := websocket.Accept(w, r, nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close(websocket.StatusInternalError, \"internal error\")\n\n\tts.eventEmitter.Emit(\"connection\", &wsConnection{Conn: conn, Req: r})\n\n\tfor {\n\t\tmsgType, msg, err := conn.Read(context.Background())\n\t\tif err != nil {\n\t\t\tif websocket.CloseStatus(err) != websocket.StatusNormalClosure {\n\t\t\t\tts.eventEmitter.Emit(\"close\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tts.eventEmitter.Emit(\"message\", conn, r, msgType, msg)\n\t}\n}\n\nfunc (ts *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\tts.eventEmitter.Once(\"connection\", func(data ...interface{}) {\n\t\tconn := data[0].(*wsConnection)\n\t\thandler(conn.Conn, conn.Req)\n\t})\n}\n\nfunc (ts *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\tts.eventEmitter.On(\"close\", func(data ...interface{}) {\n\t\terr := data[0].(*websocket.CloseError)\n\t\thandler(err)\n\t})\n}\n\nfunc (ts *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\tts.eventEmitter.Once(\"close\", func(data ...interface{}) {\n\t\terr := data[0].(*websocket.CloseError)\n\t\thandler(err)\n\t})\n}\n\nfunc (ts *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tts.eventEmitter.On(\"message\", func(data ...interface{}) {\n\t\tconn := data[0].(*websocket.Conn)\n\t\treq := data[1].(*http.Request)\n\t\tmsgType := data[2].(websocket.MessageType)\n\t\tmsg := data[3].([]byte)\n\t\thandler(conn, req, msgType, msg)\n\t})\n}\n\nfunc (ts *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tts.eventEmitter.Once(\"message\", func(data ...interface{}) {\n\t\tconn := data[0].(*websocket.Conn)\n\t\treq := data[1].(*http.Request)\n\t\tmsgType := data[2].(websocket.MessageType)\n\t\tmsg := data[3].([]byte)\n\t\thandler(conn, req, msgType, msg)\n\t})\n}\n\nfunc (ts *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\tts.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tc.Write(context.Background(), msgType, data)\n\t})\n}\n\nfunc (ts *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\tch := make(chan *wsConnection)\n\tts.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tch <- &wsConnection{Conn: c, Req: r}\n\t})\n\treturn ch\n}\n\nfunc main() {\n\t// Initialize the test server and start listening for WebSocket connections\n}\n```"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Go struct that manages a proxy command process with inter-process communication capabilities using pipes for error handling and status reporting.\n\nStruct Description: The proxyCommand struct represents a proxy process manager that uses os.Pipe for IPC to monitor the startup status of a userland proxy. It handles process execution, pipe communication, and timeout management.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as the proxy process\n\nMethods:\nStart: () -> error - Starts the proxy command and monitors its initialization status through a pipe. Returns nil if successful or an error if the proxy fails to start or times out. Uses a pipe to communicate startup status from the child process and implements a 16-second timeout.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "right_result": "type proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer reader.Close()\n\n\tp.cmd.ExtraFiles = []*os.File{writer}\n\tif err = p.cmd.Start(); err != nil {\n\t\twriter.Close()\n\t\treturn err\n\t}\n\twriter.Close()\n\n\tstartupChan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 1)\n\t\t_, readErr := reader.Read(buf)\n\t\tif readErr != nil {\n\t\t\tstartupChan <- fmt.Errorf(\"failed to read from child process: %w\", readErr)\n\t\t} else if buf[0] != 0 {\n\t\t\tstartupChan <- fmt.Errorf(\"non-zero status received from child process: %d\", buf[0])\n\t\t} else {\n\t\t\tstartupChan <- nil\n\t\t}\n\t}()\n\n\tselect {\n\tcase err := <-startupChan:\n\t\tif err != nil {\n\t\t\tp.cmd.Process.Kill()\n\t\t\tp.cmd.Wait()\n\t\t\treturn err\n\t\t}\n\tcase <-time.After(16 * time.Second):\n\t\tp.cmd.Process.Kill()\n\t\tp.cmd.Wait()\n\t\treturn fmt.Errorf(\"proxy process startup timed out\")\n\t}\n\n\tgo p.cmd.Wait()\n\treturn nil\n}"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawns a child process (via CGO) that runs in a new user namespace, reads the specified file, and returns its contents. It uses two pipes for IPC - one for standard output and another for standard error. The function handles process creation, pipe management, error handling, and cleanup of resources.\n\nInput:\n- nsPath (string): Path to the user namespace configuration\n- path (string): Path to the file to be read\n\nOutput:\n- ([]byte, error): Returns the file contents as bytes if successful, or an error if any step fails (pipe creation, process spawning, reading output, or process execution)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\n\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nfunc readFileInNamespace(nsPath, path string) ([]byte, error) {\n\t// Create pipes for stdout and stderr\n\tstdoutPipeR, stdoutPipeW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stdout pipe: %w\", err)\n\t}\n\tdefer stdoutPipeR.Close()\n\tdefer stdoutPipeW.Close()\n\n\tstderrPipeR, stderrPipeW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stderr pipe: %w\", err)\n\t}\n\tdefer stderrPipeR.Close()\n\tdefer stderrPipeW.Close()\n\n\t// Prepare the command to run in the new namespace\n\tcmd := exec.Command(\"/bin/cat\", path)\n\tcmd.Stdout = stdoutPipeW\n\tcmd.Stderr = stderrPipeW\n\n\t// Set the namespace\n\tcmd.SysProcAttr = &syscall.SysProcAttr{\n\t\tCloneflags: syscall.CLONE_NEWUSER,\n\t}\n\n\t// Start the process\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to start process: %w\", err)\n\t}\n\n\t// Close the write ends of the pipes in the parent process\n\tstdoutPipeW.Close()\n\tstderrPipeW.Close()\n\n\t// Read from stdout and stderr\n\tvar stdoutBuf, stderrBuf bytes.Buffer\n\tgo func() {\n\t\tio.Copy(&stdoutBuf, stdoutPipeR)\n\t}()\n\tgo func() {\n\t\tio.Copy(&stderrBuf, stderrPipeR)\n\t}()\n\n\t// Wait for the process to finish\n\tif err := cmd.Wait(); err != nil {\n\t\treturn nil, fmt.Errorf(\"process execution failed: %w, stderr: %s\", err, stderrBuf.String())\n\t}\n\n\t// Return the output\n\treturn stdoutBuf.Bytes(), nil\n}\n\nfunc main() {\n\t// Example usage\n\tnsPath := \"/proc/self/ns/user\"\n\tfilePath := \"/path/to/file\"\n\tcontent, err := readFileInNamespace(nsPath, filePath)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"File Content:\", string(content))\n}\n```"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a userland proxy using Go's pipe mechanism. The handler starts the proxy process, monitors its initialization status, and handles potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct manages the lifecycle of a userland proxy process, including process execution, IPC communication via pipes, and status monitoring.\n\nFields:\n- cmd: *exec.Cmd - The command object representing the proxy process to be executed.\n- ExtraFiles: []*os.File - Additional file descriptors to be passed to the child process (contains the pipe writer).\n\nMethods:\n- Start() -> error - Initializes the proxy process, establishes IPC via pipe, monitors startup status, and returns any errors encountered during execution or timeout. The method creates a pipe, passes the writer to the child process, reads the initialization status from the pipe reader, and handles errors or timeouts.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "right_result": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n\t\"io\"\n)\n\ntype proxyCommand struct {\n\tcmd        *exec.Cmd\n\tExtraFiles []*os.File\n}\n\nfunc (p *proxyCommand) Start() error {\n\tpipeReader, pipeWriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer pipeReader.Close()\n\tdefer pipeWriter.Close()\n\n\tp.ExtraFiles = append(p.ExtraFiles, pipeWriter)\n\tp.cmd.ExtraFiles = p.ExtraFiles\n\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 1)\n\t\t_, err := pipeReader.Read(buf)\n\t\tif err != nil {\n\t\t\tdone <- err\n\t\t\treturn\n\t\t}\n\t\tdone <- nil\n\t}()\n\n\tselect {\n\tcase err := <-done:\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tp.cmd.Process.Kill()\n\t\treturn errors.New(\"proxy process startup timed out\")\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tcmd := exec.Command(\"your-proxy-command\")\n\tproxy := &proxyCommand{cmd: cmd}\n\tif err := proxy.Start(); err != nil {\n\t\t// Handle error\n\t}\n}\n```"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Go struct that implements a log retrieval mechanism using pipes for inter-process communication, allowing for reading logs from a file and writing them to a pipe for consumption by another process.\n\nStruct Description: The `logRetriever` struct provides a way to read logs from a file and write them to a pipe, implementing `io.ReadCloser` for standard read and close operations. It also includes methods to manage the pipe's writer and output.\n\nFields:\n- reader: *os.File - The read end of the pipe used to consume log data.\n- writer: *os.File - The write end of the pipe used to send log data.\n- output: *fileCloner - A helper component that clones the writer's output to a log file.\n\nMethods:\n- newlogRetriever: (logFile string) -> (*logRetriever, error) - Initializes a new logRetriever instance, creates a pipe, and sets up file cloning. If the log file exists, copies its contents to the pipe.\n- Read: (p []byte) -> (int, error) - Implements io.Reader to read data from the pipe's reader.\n- CloseWriter: () -> error - Closes the pipe's writer to signal the end of data transmission.\n- Close: () -> error - Implements io.Closer to close the pipe's reader and release resources.\n- Opt: () -> cio.Opt - Returns an option for configuring IO streams, using a null reader and the output cloner.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (l *logRetriever, err error) {\n\tl = &logRetriever{}\n\tif l.reader, l.writer, err = os.Pipe(); err != nil {\n\t\treturn\n\t}\n\n\tif l.output, err = newFileCloner(l.writer, logFile); err != nil {\n\t\treturn\n\t}\n\n\tif util.FileExists(logFile) {\n\t\tvar reader io.ReadCloser\n\t\tif reader, err = os.Open(logFile); err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer util.DeferErr(&err, reader.Close)\n\n\t\tif _, err = io.Copy(l.writer, reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nvar _ io.ReadCloser = &logRetriever{}\n\nfunc (l *logRetriever) Opt() cio.Opt {\n\treturn cio.WithStreams(&nullReader{}, l.output, l.output)\n}\n\nfunc (l *logRetriever) Read(p []byte) (n int, err error) {\n\treturn l.reader.Read(p)\n}\n\nfunc (l *logRetriever) CloseWriter() (err error) {\n\treturn l.writer.Close()\n}\n\nfunc (l *logRetriever) Close() error {\n\treturn l.reader.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "right_result": "```go\npackage main\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"errors\"\n)\n\ntype fileCloner struct {\n\tfile *os.File\n}\n\nfunc newFileCloner(filePath string) (*fileCloner, error) {\n\tfile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fileCloner{file: file}, nil\n}\n\nfunc (fc *fileCloner) Write(p []byte) (int, error) {\n\treturn fc.file.Write(p)\n}\n\nfunc (fc *fileCloner) Close() error {\n\treturn fc.file.Close()\n}\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (*logRetriever, error) {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutput, err := newFileCloner(logFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlr := &logRetriever{\n\t\treader: reader,\n\t\twriter: writer,\n\t\toutput: output,\n\t}\n\n\tfile, err := os.Open(logFile)\n\tif err != nil {\n\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tdefer file.Close()\n\t\t_, err = io.Copy(writer, file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn lr, nil\n}\n\nfunc (lr *logRetriever) Read(p []byte) (int, error) {\n\treturn lr.reader.Read(p)\n}\n\nfunc (lr *logRetriever) CloseWriter() error {\n\terr := lr.writer.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn lr.output.Close()\n}\n\nfunc (lr *logRetriever) Close() error {\n\treturn lr.reader.Close()\n}\n\ntype cioOpt struct {\n\treader io.Reader\n\twriter io.Writer\n}\n\nfunc (lr *logRetriever) Opt() cioOpt {\n\treturn cioOpt{\n\t\treader: io.Discard,\n\t\twriter: lr.output,\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tlogRetriever, err := newlogRetriever(\"logfile.txt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer logRetriever.Close()\n\n\t// Read from logRetriever\n\tbuf := make([]byte, 1024)\n\t_, err = logRetriever.Read(buf)\n\tif err != nil && err != io.EOF {\n\t\tpanic(err)\n\t}\n\n\t// Close writer when done\n\terr = logRetriever.CloseWriter()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Go function that implements a basic HTTP server which responds to all requests with a repeated character response of specified size.\n\nFunction Description: The function should start an HTTP server on a specified port that handles all incoming requests by writing a response consisting of a repeated character ('a') with a length determined by the responseSize parameter. The server should log any errors that occur during writing or server startup.\n\nInput: \n- serverPort: string - The port number on which the HTTP server should listen (e.g., \"8080\")\n- responseSize: int - The size/length of the response to be generated (number of 'a' characters to repeat)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are logged to stdout if any occur during server operation\n\nNote: The function doesn't explicitly return values but runs an HTTP server that handles requests and may log errors. The response is written directly to the http.ResponseWriter for each incoming request.\n\nExample usage:\n```go\nfunc main() {\n    startHTTPServer(\"8080\", 1024)  // Starts server on port 8080 with 1024-byte responses\n}\n```",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresponse := bytes.Repeat([]byte(\"a\"), int(*responseSize))\n\taddr := \"localhost:\" + *serverPort\n\tlog.Println(\"Starting HTTP server on:\", addr)\n\tlserr := http.ListenAndServe(addr, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, werr := w.Write(response)\n\t\tif werr != nil {\n\t\t\tlog.Println(werr)\n\t\t}\n\t}))\n\tif lserr != nil {\n\t\tlog.Println(lserr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc startHTTPServer(serverPort string, responseSize int) {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tresponse := strings.Repeat(\"a\", responseSize)\n\t\t_, err := w.Write([]byte(response))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing response: %v\", err)\n\t\t}\n\t})\n\n\taddress := fmt.Sprintf(\":%s\", serverPort)\n\tlog.Printf(\"Starting server on port %s\", serverPort)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}\n\nfunc main() {\n\tstartHTTPServer(\"8080\", 1024)\n}\n```"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Go HTTP server that handles multiple routes and ports concurrently, with specific handlers for different endpoints. The server should mirror incoming requests (displaying request details) by default and respond with \"hello\" for specific pipeline activity routes.\n\nFunction Description: The main function sets up an HTTP server with multiple handlers and listens on multiple ports concurrently. It includes:\n1. A simple helloHandler that responds with \"hello\"\n2. A mirrorHandler that displays detailed request information\n3. Concurrent server instances on ports 9091-9097\n4. A primary server instance on port 9098\n\nInput: None (The functions handle HTTP requests which contain their own input data)\n\nOutput: None (The functions write responses to http.ResponseWriter)\n\nMethods:\n\nhelloHandler: func(w http.ResponseWriter, req *http.Request) - Responds with \"hello\" string\nmirrorHandler: func(w http.ResponseWriter, req *http.Request) - Displays detailed request information including method, URL, headers, and body\nListenAndServe: Called on multiple ports to start HTTP servers concurrently\n\nNote: The code uses http.HandleFunc to register routes and starts servers on multiple ports using goroutines for concurrent operation. The mirrorHandler includes a 10ms delay and outputs request details to both the response and stdout using a TeeWriter.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\nfunc main() {\n\thelloHandler := func(w http.ResponseWriter, req *http.Request) {\n\t\tio.WriteString(w, \"hello\")\n\t}\n\tmirrorHandler := func(w http.ResponseWriter, req *http.Request) {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tbody, err := io.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tbody = []byte(fmt.Sprintf(\"<read failed: %v>\", err))\n\t\t}\n\n\t\ttw := NewTeeWriter(w, os.Stdout)\n\n\t\turl := req.URL.Path\n\t\tif req.URL.Query().Encode() != \"\" {\n\t\t\turl += \"?\" + req.URL.Query().Encode()\n\t\t}\n\n\t\tfmt.Fprintln(tw, \"Your Request\")\n\t\tfmt.Fprintln(tw, \"==============\")\n\t\tfmt.Fprintln(tw, \"Method:\", req.Method)\n\t\tfmt.Fprintln(tw, \"URL   :\", url)\n\n\t\tfmt.Fprintln(tw, \"Header:\")\n\t\tfor k, v := range req.Header {\n\t\t\tfmt.Fprintf(tw, \"    %s: %v\\n\", k, v)\n\t\t}\n\n\t\tfmt.Fprintln(tw, \"Body  :\", string(body))\n\t}\n\n\thttp.HandleFunc(\"/\", mirrorHandler)\n\thttp.HandleFunc(\"/pipeline/activity/1\", helloHandler)\n\thttp.HandleFunc(\"/pipeline/activity/2\", helloHandler)\n\n\tfor _, port := range []int{9091, 9092, 9093, 9094, 9095, 9096, 9097} {\n\t\tgo http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n\t}\n\n\thttp.ListenAndServe(\":9098\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc helloHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintln(w, \"hello\")\n}\n\nfunc mirrorHandler(w http.ResponseWriter, req *http.Request) {\n\ttime.Sleep(10 * time.Millisecond) // 10ms delay\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\thttp.Error(w, \"could not read request body\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\treq.Body.Close()\n\n\tinfo := fmt.Sprintf(\"Method: %s\\nURL: %s\\nHeaders: %v\\nBody: %s\\n\",\n\t\treq.Method, req.URL.String(), req.Header, string(body))\n\tmultiWriter := io.MultiWriter(w, os.Stdout)\n\tio.WriteString(multiWriter, info)\n}\n\nfunc startServer(wg *sync.WaitGroup, port int) {\n\tdefer wg.Done()\n\thttp.HandleFunc(\"/hello\", helloHandler)\n\thttp.HandleFunc(\"/\", mirrorHandler)\n\taddress := fmt.Sprintf(\":%d\", port)\n\tfmt.Printf(\"Starting server on port %d\\n\", port)\n\tif err := http.ListenAndServe(address, nil); err != nil {\n\t\tfmt.Printf(\"Error starting server on port %d: %v\\n\", port, err)\n\t}\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor port := 9091; port <= 9097; port++ {\n\t\twg.Add(1)\n\t\tgo startServer(&wg, port)\n\t}\n\twg.Add(1) // Adding for primary server\n\tgo startServer(&wg, 9098)\n\twg.Wait() // Wait for all goroutines to finish\n}\n```"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Go struct that represents a financial chart for trading visualization, with capabilities to serve HTTP endpoints for health checks, trading data, and trading history. The struct should maintain candle data, orders, and wallet information, and provide methods to serve this data via HTTP endpoints.\n\nStruct Description: The Chart struct represents a financial trading chart with HTTP server capabilities. It maintains candle data, order information, and paper wallet details, and provides methods to serve this data through HTTP endpoints (/health, /data, /history). The struct uses synchronization to handle concurrent access and provides real-time trading visualization data.\n\nFields:\n\nport: int - The port number on which the HTTP server will listen\ncandles: map[string][]Candle - Stores candle data grouped by trading pairs\ndataframe: map[string]*model.Dataframe - Stores dataframe information for each trading pair\nordersIDsByPair: map[string]*set.LinkedHashSetINT64 - Maintains order IDs organized by trading pairs\norderByID: map[int64]model.Order - Maps order IDs to their corresponding order details\npaperWallet: *exchange.PaperWallet - Pointer to the paper trading wallet information\nlastUpdate: time.Time - Timestamp of the last data update\nMutex: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n\nhandleHealth: (w http.ResponseWriter, _ *http.Request) -> None - Handles health check requests, returning service status based on last update time\nhandleData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading data (candles, asset values, equity values) for a specific trading pair in JSON format\nhandleTradingHistoryData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading history data for a specific pair in CSV format\nStart: () -> error - Starts the HTTP server and registers all endpoint handlers",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/rodrigo-brito/ninjabot/exchange\"\n\t\"github.com/rodrigo-brito/ninjabot/model\"\n\t\"github.com/StudioSol/set\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\ntype Chart struct {\n\tsync.Mutex\n\tport            int\n\tcandles         map[string][]Candle\n\tdataframe       map[string]*model.Dataframe\n\tordersIDsByPair map[string]*set.LinkedHashSetINT64\n\torderByID       map[int64]model.Order\n\tpaperWallet     *exchange.PaperWallet\n\tlastUpdate      time.Time\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, _ *http.Request) {\n\tif time.Since(c.lastUpdate) > time.Hour+10*time.Minute {\n\t\t_, err := w.Write([]byte(c.lastUpdate.String()))\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/json\")\n\n\tvar maxDrawdown *drawdown\n\tif c.paperWallet != nil {\n\t\tvalue, start, end := c.paperWallet.MaxDrawdown()\n\t\tmaxDrawdown = &drawdown{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t\tValue: fmt.Sprintf(\"%.1f\", value*100),\n\t\t}\n\t}\n\n\tasset, quote := exchange.SplitAssetQuote(pair)\n\tassetValues, equityValues := c.equityValuesByPair(pair)\n\terr := json.NewEncoder(w).Encode(map[string]interface{}{\n\t\t\"candles\":       c.candlesByPair(pair),\n\t\t\"asset_values\":  assetValues,\n\t\t\"equity_values\": equityValues,\n\t\t\"quote\":         quote,\n\t\t\"asset\":         asset,\n\t\t\"max_drawdown\":  maxDrawdown,\n\t})\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/csv\")\n\tw.Header().Set(\"Content-Disposition\", \"attachment;filename=history_\"+pair+\".csv\")\n\tw.Header().Set(\"Transfer-Encoding\", \"chunked\")\n\n\torders := c.orderStringByPair(pair)\n\n\tbuffer := bytes.NewBuffer(nil)\n\tcsvWriter := csv.NewWriter(buffer)\n\terr := csvWriter.Write([]string{\"created_at\", \"status\", \"side\", \"id\", \"type\", \"quantity\", \"price\", \"total\", \"profit\"})\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing header file: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = csvWriter.WriteAll(orders)\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing data: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tcsvWriter.Flush()\n\n\tw.WriteHeader(http.StatusOK)\n\t_, err = w.Write(buffer.Bytes())\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing response: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n}\n\nfunc (c *Chart) Start() error {\n\thttp.HandleFunc(\"/health\", c.handleHealth)\n\thttp.HandleFunc(\"/history\", c.handleTradingHistoryData)\n\thttp.HandleFunc(\"/data\", c.handleData)\n\n\tfmt.Printf(\"Chart available at http://localhost:%d\\n\", c.port)\n\treturn http.ListenAndServe(fmt.Sprintf(\":%d\", c.port), nil)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/emirpasic/gods/sets/linkedhashset\"\n\t\"github.com/yourusername/yourproject/exchange\"\n\t\"github.com/yourusername/yourproject/model\"\n)\n\ntype Candle struct {\n\tTime   time.Time\n\tOpen   float64\n\tClose  float64\n\tHigh   float64\n\tLow    float64\n\tVolume float64\n}\n\ntype Chart struct {\n\tport             int\n\tcandles          map[string][]Candle\n\tdataframe        map[string]*model.Dataframe\n\tordersIDsByPair  map[string]*linkedhashset.Set\n\torderByID        map[int64]model.Order\n\tpaperWallet      *exchange.PaperWallet\n\tlastUpdate       time.Time\n\tmutex            sync.Mutex\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, _ *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tif time.Since(c.lastUpdate) < 5*time.Minute {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"Service is healthy\"))\n\t} else {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"Service is unhealthy\"))\n\t}\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\thttp.Error(w, \"Missing trading pair\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tdata, exists := c.candles[pair]\n\tif !exists {\n\t\thttp.Error(w, \"Trading pair not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(data)\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\thttp.Error(w, \"Missing trading pair\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\torderIDs, exists := c.ordersIDsByPair[pair]\n\tif !exists {\n\t\thttp.Error(w, \"Trading pair not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/csv\")\n\twriter := csv.NewWriter(w)\n\twriter.Write([]string{\"OrderID\", \"Price\", \"Amount\", \"Timestamp\"})\n\n\tfor _, id := range orderIDs.Values() {\n\t\torderID := id.(int64)\n\t\torder, exists := c.orderByID[orderID]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\t\twriter.Write([]string{\n\t\t\tstrconv.FormatInt(orderID, 10),\n\t\t\tstrconv.FormatFloat(order.Price, 'f', 2, 64),\n\t\t\tstrconv.FormatFloat(order.Amount, 'f', 2, 64),\n\t\t\torder.Timestamp.Format(time.RFC3339),\n\t\t})\n\t}\n\twriter.Flush()\n}\n\nfunc (c *Chart) Start() error {\n\thttp.HandleFunc(\"/health\", c.handleHealth)\n\thttp.HandleFunc(\"/data\", c.handleData)\n\thttp.HandleFunc(\"/history\", c.handleTradingHistoryData)\n\n\treturn http.ListenAndServe(\":\"+strconv.Itoa(c.port), nil)\n}\n\nfunc main() {\n\tchart := &Chart{\n\t\tport:            8080,\n\t\tcandles:         make(map[string][]Candle),\n\t\tdataframe:       make(map[string]*model.Dataframe),\n\t\tordersIDsByPair: make(map[string]*linkedhashset.Set),\n\t\torderByID:       make(map[int64]model.Order),\n\t\tpaperWallet:     &exchange.PaperWallet{},\n\t\tlastUpdate:      time.Now(),\n\t}\n\n\tif err := chart.Start(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Go HTTP server that handles incoming requests, processes JSON payloads, and returns a modified response with a large body and custom headers.\n\nFunction Description: The main function sets up an HTTP server that listens on port 10000. It defines a handler for the root path (\"/\") that:\n1. Reads and closes the request body\n2. Unmarshals the JSON body into a contextEntity struct\n3. Modifies the response status, headers, and body\n4. Marshals the modified contextEntity back to JSON and sends it as the response\n5. Handles errors appropriately with status codes\n\nInput: \n- HTTP requests with JSON body containing a contextEntity structure\n- The handler expects the request body to be a valid JSON representation of contextEntity\n\nOutput:\n- HTTP responses with:\n  - Status 200 on success with modified JSON payload\n  - Status 400 for bad requests (invalid JSON or read errors)\n  - Status 500 for internal server errors (marshaling failures)\n- Response includes:\n  - Custom header \"X-Remote-Name: G.O.O.D\"\n  - Large body (64KB of '-' characters)\n  - Modified contextEntity structure as JSON",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlargeBodySize := 64 * 1024\n\tlargeBody := bytes.Repeat([]byte(`-`), largeBodySize)\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer r.Body.Close()\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity := &contextEntity{}\n\t\terr = json.Unmarshal(body, ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity.Response.StatusCode = 200\n\t\tctxEntity.Response.Header.Add(\"X-Remote-Name\", \"G.O.O.D\")\n\t\tctxEntity.Response.Body = largeBody\n\n\t\tbuff, err := json.Marshal(ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buff)\n\t})\n\n\thttp.ListenAndServe(\":10000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype contextEntity struct {\n\tName  string `json:\"name\"`\n\tValue string `json:\"value\"`\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\t// Read request body\n\tbody, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, \"failed to read request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\t// Unmarshal JSON into contextEntity\n\tvar entity contextEntity\n\tif err := json.Unmarshal(body, &entity); err != nil {\n\t\thttp.Error(w, \"failed to parse JSON payload\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Modify entity\n\tentity.Value += \"_modified\"\n\n\t// Marshal modified entity back to JSON\n\tresponseBody, err := json.Marshal(entity)\n\tif err != nil {\n\t\thttp.Error(w, \"internal server error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Set headers\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"X-Remote-Name\", \"G.O.O.D\")\n\n\t// Build large body response\n\tlargestBody := strings.Repeat(\"-\", 65536)\n\n\t// Write status, headers, and body\n\tw.WriteHeader(http.StatusOK)\n\tw.Write([]byte(largestBody))\n\tw.Write(responseBody)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":10000\", nil)\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a simple HTTP server in Go that sets a cookie when the root path (\"/\") is accessed.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. When a request is made to the root path, it responds by setting a cookie named \"my-cookie\" with the value \"some value\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\thttp.SetCookie(res, &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"some value\",\n\t\t})\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tcookie := &http.Cookie{\n\t\tName:  \"my-cookie\",\n\t\tValue: \"some value\",\n\t}\n\thttp.SetCookie(w, cookie)\n\tw.Write([]byte(\"Cookie has been set\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a simple HTTP server in Go that responds to requests with a greeting message containing the value of the \"AUTHOR\" environment variable.\n\nFunction Description: The main function sets up a basic HTTP server with a single route (\"/\") that responds to all HTTP requests. The response is a plain text message combining \"hello \" with the value of the \"AUTHOR\" environment variable. The server listens on a specified port.\n\nInput: \n- *addr (string pointer): A command-line flag specifying the server address and port to listen on (e.g., \":8080\")\n\nOutput: \n- None (The function runs indefinitely, serving HTTP requests until interrupted)\n- For each HTTP request to \"/\", outputs \"hello [AUTHOR]\" as the response body\n\nNote: The function does not explicitly return any values but writes to the http.ResponseWriter for each incoming request. The server continues running until terminated.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\nfunc main() {\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello \"+os.Getenv(\"AUTHOR\"))\n\t})\n\thttp.ListenAndServe(*addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"flag\"\n)\n\nfunc main() {\n\taddr := flag.String(\"addr\", \":8080\", \"HTTP network address\")\n\tflag.Parse()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tauthor := os.Getenv(\"AUTHOR\")\n\t\tif author == \"\" {\n\t\t\tauthor = \"unknown\"\n\t\t}\n\t\tfmt.Fprintf(w, \"hello %s\", author)\n\t})\n\n\thttp.ListenAndServe(*addr, nil)\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a function that serves a genesis file over HTTP on a specified port, setting the appropriate content type and handling the file serving.\n\nFunction Description: The function `ServeGenesisFileAtPort` creates a basic HTTP server that serves a specified genesis file when requested at the `/genesis.car` endpoint. The server sets the content type to `application/octet-stream` and uses the `http.ServeFile` function to handle the file serving. The server runs on the specified port and panics if it fails to start.\n\nInput:  \n- `genesisFilePath` (string): The file path to the genesis file that will be served.  \n- `port` (int): The port number on which the HTTP server will listen.  \n\nOutput:  \n- None (the function does not return; it panics if the server fails to start).",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeGenesisFileAtPort(genesisFilePath string, port int) {\n\thttp.HandleFunc(\"/genesis.car\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\thttp.ServeFile(w, r, genesisFilePath)\n\t})\n\tpanic(http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc ServeGenesisFileAtPort(genesisFilePath string, port int) {\n\thttp.HandleFunc(\"/genesis.car\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\thttp.ServeFile(w, r, genesisFilePath)\n\t})\n\n\taddress := \":\" + strconv.Itoa(port)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to start server: %v\", err))\n\t}\n}\n\nfunc main() {\n\tServeGenesisFileAtPort(\"path/to/genesis.car\", 8080)\n}\n```"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Go HTTP server that acts as a proxy, forwarding requests based on a header value and returning the corresponding stored response.\n\nFunction Description: The main function sets up an HTTP server with a root handler that retrieves and forwards responses based on the \"proxify\" header. It stores responses in a global map and cleans up after forwarding. The server runs concurrently.\n\nInput: \n- options.HTTPListenerAddress (string): The address and port on which the HTTP server should listen (e.g., \":8080\")\n\nOutput: \n- None (the function runs indefinitely as a server)\n- Errors are logged fatally if the server fails to start\n\nNote: The implementation uses global variables (response and responses) for storing and retrieving HTTP responses. The handler expects requests to contain a \"proxify\" header that serves as a key to look up pre-stored responses in the responses map. After forwarding a response, it removes the corresponding entry from the map.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"io\"\n)\n\nvar (\n\tresponse   *http.Response\n\tresponses  map[string]*http.Response\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tkey := req.Header.Get(\"proxify\")\n\t\tresponse := responses[key]\n\t\tdelete(responses, key)\n\n\t\tfor k, v := range response.Header {\n\t\t\tw.Header().Add(k, strings.Join(v, \"; \"))\n\t\t}\n\t\tw.WriteHeader(response.StatusCode)\n\t\tio.Copy(w, response.Body)\n\t})\n\tgo func() {\n\t\tif err := http.ListenAndServe(options.HTTPListenerAddress, nil); err != nil {\n\t\t\tgologger.Fatal().Msgf(\"Could not listen and serve: %s\\n\", err)\n\t\t}\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tresponses = make(map[string]string)\n\tmutex     = &sync.Mutex{}\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tproxifyKey := r.Header.Get(\"proxify\")\n\tif proxifyKey == \"\" {\n\t\thttp.Error(w, \"missing proxify header\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tresponse, exists := responses[proxifyKey]\n\tdelete(responses, proxifyKey)\n\tmutex.Unlock()\n\n\tif !exists {\n\t\thttp.Error(w, \"response not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Write([]byte(response))\n}\n\nfunc populateResponses() error {\n\tdata, err := ioutil.ReadFile(\"responses.json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(data, &responses)\n}\n\nfunc main() {\n\tif err := populateResponses(); err != nil {\n\t\tlog.Fatalf(\"failed to populate responses: %v\", err)\n\t}\n\n\thttp.HandleFunc(\"/\", handler)\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatalf(\"server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Go HTTP server that serves as an interface for running and displaying scorecard results for GitHub repositories. The server should handle requests, process repository information, execute scorecard checks, and return results in either JSON or HTML format based on the request's content type.\n\nFunction Description: The `serveCmd` function creates and configures a Cobra command that starts an HTTP server. The server listens for requests, processes GitHub repository URLs, runs scorecard checks on those repositories, and returns the results. The function handles template parsing, route registration, and server startup.\n\nInput: \n- `o *options.Options`: A pointer to an options struct containing configuration settings like log level and commit depth\n\nOutput: \n- `*cobra.Command`: Returns a configured Cobra command that can be executed to start the HTTP server\n\nThe function does not explicitly return any values from its Run method, but it does:\n1. Write HTTP responses to the client (through http.ResponseWriter)\n2. Output logs through the logger\n3. May panic in case of critical errors during template parsing or server startup",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/ossf/scorecard/v5/clients/githubrepo\"\n\t\"github.com/ossf/scorecard/v5/clients/ossfuzz\"\n\t\"github.com/ossf/scorecard/v5/log\"\n\t\"github.com/ossf/scorecard/v5/options\"\n\t\"github.com/ossf/scorecard/v5/pkg/scorecard\"\n)\nfunc serveCmd(o *options.Options) *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve the scorecard program over http\",\n\t\tLong:  ``,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tlogger := log.NewLogger(log.ParseLevel(o.LogLevel))\n\n\t\t\tt, err := template.New(\"webpage\").Parse(tpl)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"parsing webpage template\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\thttp.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\trepoParam := r.URL.Query().Get(\"repo\")\n\t\t\t\tconst length = 3\n\t\t\t\ts := strings.SplitN(repoParam, \"/\", length)\n\t\t\t\tif len(s) != length {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\trepo, err := githubrepo.MakeGithubRepo(repoParam)\n\t\t\t\tif err != nil {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\tctx := r.Context()\n\t\t\t\trepoClient := githubrepo.CreateGithubRepoClient(ctx, logger)\n\t\t\t\tossFuzzRepoClient, err := ossfuzz.CreateOSSFuzzClientEager(ossfuzz.StatusURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"initializing clients\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t\tdefer ossFuzzRepoClient.Close()\n\t\t\t\trepoResult, err := scorecard.Run(ctx, repo,\n\t\t\t\t\tscorecard.WithCommitDepth(o.CommitDepth),\n\t\t\t\t\tscorecard.WithRepoClient(repoClient),\n\t\t\t\t\tscorecard.WithOSSFuzzClient(ossFuzzRepoClient),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"running enabled scorecard checks on repo\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\n\t\t\t\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\t\t\tif err := repoResult.AsJSON(o.ShowDetails, log.ParseLevel(o.LogLevel), rw); err != nil {\n\t\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := t.Execute(rw, repoResult); err != nil {\n\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tport := os.Getenv(\"PORT\")\n\t\t\tif port == \"\" {\n\t\t\t\tport = \"8080\"\n\t\t\t}\n\t\t\tlogger.Info(\"Listening on localhost:\" + port + \"\\n\")\n\t\t\terr = http.ListenAndServe(fmt.Sprintf(\"0.0.0.0:%s\", port), nil)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"listening and serving\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t},\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\ntype options struct {\n\tLogLevel   string\n\tCommitDepth int\n}\n\ntype scorecardResult struct {\n\tRepository string `json:\"repository\"`\n\tScore      int    `json:\"score\"`\n}\n\nfunc serveCmd(o *options) *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Start the HTTP server for scorecard results\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\thttp.HandleFunc(\"/scorecard\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\trepo := r.URL.Query().Get(\"repo\")\n\t\t\t\tif repo == \"\" {\n\t\t\t\t\thttp.Error(w, \"Repository not specified\", http.StatusBadRequest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tresult := runScorecardCheck(repo)\n\n\t\t\t\tswitch r.Header.Get(\"Content-Type\") {\n\t\t\t\tcase \"application/json\":\n\t\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\t\tjson.NewEncoder(w).Encode(result)\n\t\t\t\tcase \"text/html\":\n\t\t\t\t\ttmpl, err := template.New(\"result\").Parse(`\n\t\t\t\t\t\t<html>\n\t\t\t\t\t\t<head><title>Scorecard Result</title></head>\n\t\t\t\t\t\t<body>\n\t\t\t\t\t\t\t<h1>Scorecard Result for {{.Repository}}</h1>\n\t\t\t\t\t\t\t<p>Score: {{.Score}}</p>\n\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>`)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\thttp.Error(w, \"Error parsing template\", http.StatusInternalServerError)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t\t\ttmpl.Execute(w, result)\n\t\t\t\tdefault:\n\t\t\t\t\thttp.Error(w, \"Unsupported content type\", http.StatusUnsupportedMediaType)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tlog.Printf(\"Starting server on :8080\")\n\t\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc runScorecardCheck(repo string) scorecardResult {\n\t// Placeholder for actual scorecard logic\n\treturn scorecardResult{\n\t\tRepository: repo,\n\t\tScore:      85, // Example score\n\t}\n}\n\nfunc main() {\n\tviper.AutomaticEnv()\n\to := &options{\n\t\tLogLevel:   viper.GetString(\"LOG_LEVEL\"),\n\t\tCommitDepth: viper.GetInt(\"COMMIT_DEPTH\"),\n\t}\n\n\trootCmd := &cobra.Command{Use: \"app\"}\n\trootCmd.AddCommand(serveCmd(o))\n\n\tif err := rootCmd.Execute(); err != nil {\n\t\tlog.Fatalf(\"Command execution failed: %v\", err)\n\t\tos.Exit(1)\n\t}\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a simple HTTP server in Go that tracks and displays the number of visits by maintaining a cookie-based counter.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles incoming requests. For each request, it checks for a cookie named \"my-cookie\". If the cookie doesn't exist, it creates one with an initial value of \"0\". The function increments the cookie value on each visit and sends it back in the response, effectively maintaining a visit counter.\n\nInput: None (The function takes no direct input parameters. It responds to HTTP requests received on port 9000.)\n\nOutput: None (The function doesn't return any value. It writes the current visit count to the HTTP response and sets/updates the cookie in the response header.)",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"my-cookie\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"my-cookie\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\t\tcount, _ := strconv.Atoi(cookie.Value)\n\t\tcount++\n\t\tcookie.Value = strconv.Itoa(count)\n\n\t\thttp.SetCookie(res, cookie)\n\n\t\tio.WriteString(res, cookie.Value)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc visitCounter(w http.ResponseWriter, r *http.Request) {\n\tcookie, err := r.Cookie(\"my-cookie\")\n\tif err != nil {\n\t\tcookie = &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"0\",\n\t\t}\n\t}\n\n\tcount, _ := strconv.Atoi(cookie.Value)\n\tcount++\n\tcookie.Value = strconv.Itoa(count)\n\thttp.SetCookie(w, cookie)\n\n\tfmt.Fprintf(w, \"Visit count: %d\", count)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", visitCounter)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server with health check and metrics endpoints using Go's net/http package.\n\nFunction Description: The function `serveMetrics` initializes an HTTP server with two endpoints: `/healthz` for health checks (returns \"OK\" with 200 status) and `/metrics` for Prometheus metrics (handled by promhttp). The server listens on the specified address and runs until terminated.\n\nInput: \n- `address` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput: \n- None (function runs indefinitely until server termination)\n- Logs fatal errors if server fails to start",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc serveMetrics(address string) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tlog.Fatal(http.ListenAndServe(address, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc serveMetrics(address string) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tlog.Printf(\"Starting server on %s\", address)\n\tif err := http.ListenAndServe(address, nil); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}\n\nfunc main() {\n\tserveMetrics(\":8080\")\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebSocket connections at the root path (\"/\"). The server should load configuration from a JSON file and start listening on a specified port.\n\nFunction Description: The main function initializes the server by loading configuration, setting up a WebSocket handler at the root path, and starting the HTTP server on the configured port.\n\nInput: None (configuration is loaded from \"config.json\" file)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics if server fails to start)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"golang.org/x/net/websocket\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tConfig = load(\"config.json\")\n\t\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\ts := websocket.Server{Handler: websocket.Handler(wsHandler)}\n\t\ts.ServeHTTP(w, req)\n\t})\n\n\terr := http.ListenAndServe(\":\"+strconv.Itoa(Config.Port), nil)\n\tif err != nil {\n\t\tpanic(\"Error: \" + err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Config struct {\n\tPort string `json:\"port\"`\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc loadConfig(filename string) (Config, error) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn Config{}, err\n\t}\n\tdefer file.Close()\n\n\tvar config Config\n\tdecoder := json.NewDecoder(file)\n\terr = decoder.Decode(&config)\n\tif err != nil {\n\t\treturn Config{}, err\n\t}\n\n\treturn config, nil\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error upgrading connection:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconfig, err := loadConfig(\"config.json\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to load configuration: %v\", err))\n\t}\n\n\thttp.HandleFunc(\"/\", handleWebSocket)\n\n\tfmt.Printf(\"Starting server on port %s\\n\", config.Port)\n\terr = http.ListenAndServe(\":\"+config.Port, nil)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to start server: %v\", err))\n\t}\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles form submissions and displays a simple HTML form.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form. For POST requests, it reads the form value and prints it to the console while still displaying the form. The server listens on port 9000.\n\nInput: None (The function takes no direct input parameters, but receives HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but writes to the HTTP response and prints to console)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t <input type=\"text\" name=\"q\">\n\t\t <input type=\"submit\">\n\n\t\t</form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc formHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodPost {\n\t\tr.ParseForm()\n\t\tname := r.FormValue(\"name\")\n\t\tfmt.Println(\"Received name:\", name)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\tfmt.Fprintf(w, `\n\t\t<!DOCTYPE html>\n\t\t<html>\n\t\t<head>\n\t\t\t<title>Form Submission</title>\n\t\t</head>\n\t\t<body>\n\t\t\t<form method=\"POST\" action=\"/\">\n\t\t\t\t<label for=\"name\">Name:</label>\n\t\t\t\t<input type=\"text\" id=\"name\" name=\"name\" required>\n\t\t\t\t<input type=\"submit\" value=\"Submit\">\n\t\t\t</form>\n\t\t</body>\n\t\t</html>\n\t`)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", formHandler)\n\tfmt.Println(\"Server starting on port 9000...\")\n\thttp.ListenAndServe(\":9000\", nil)\n}\n```"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and starts an HTTP server listening on port 8080.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response.\n- `r *http.Request` - Represents the HTTP request received from the client.\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles form submissions and displays the submitted value. The server should respond to both GET and POST requests on the root path (\"/\") and render an HTML form with a checkbox input.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path (\"/\"). The handler processes form submissions, extracts the form value, and returns an HTML response containing the form and the submitted value.\n\nInput: None (The function takes no direct input parameters. Input is received through HTTP requests.)\n\nOutput: None (The function doesn't return any value. Output is sent through the HTTP response writer.)\n\nNote: The function internally uses http.ResponseWriter to send responses and *http.Request to receive requests. The handler checks for a form value with key \"q\" and includes it in the response. The server listens on port 9000.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t<input type=\"checkbox\" name=\"q\">\n\t\t<input type=\"submit\">\n\n\t\t</form>`+val)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc formHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodPost {\n\t\tr.ParseForm()\n\t}\n\n\tvalue := r.FormValue(\"q\")\n\tresponse := `<html>\n\t\t<body>\n\t\t\t<form method=\"POST\" action=\"/\">\n\t\t\t\t<label for=\"checkbox\">Check me:</label>\n\t\t\t\t<input type=\"checkbox\" name=\"q\" value=\"checked\" id=\"checkbox\" `\n\n\tif value == \"checked\" {\n\t\tresponse += `checked`\n\t}\n\n\tresponse += `>\n\t\t\t\t<input type=\"submit\" value=\"Submit\">\n\t\t\t</form>`\n\n\tif value != \"\" {\n\t\tresponse += `<p>Submitted value: ` + value + `</p>`\n\t}\n\n\tresponse += `</body>\n\t</html>`\n\n\tfmt.Fprint(w, response)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", formHandler)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and responds with \"hello world\".\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path. The handler writes \"hello world\" as the response. The server listens on port 8080.\n\nInput: None (The function takes no direct input parameters; requests are handled via HTTP)\n\nOutput: None (The function doesn't return anything; responses are written to the http.ResponseWriter)\n\nNote: The reference code shows a complete implementation where:\n1. A handler function is defined to write \"hello world\" response\n2. The handler is registered for the root path \"/\"\n3. The server starts listening on port 8080",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"hello world\")) })\n\nfunc main() {\n\thttp.HandleFunc(\"/\", myHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"hello world\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Go HTTP server that implements WebDAV functionality with custom logging and special handling for specific HTTP headers.\n\nStruct Description: The webdav.Handler struct provides WebDAV server functionality with in-memory storage for files and locks. We'll wrap this with custom request handling.\n\nFields:\n- FileSystem: webdav.FileSystem - In-memory filesystem implementation\n- LockSystem: webdav.LockSystem - In-memory lock system implementation\n- Logger: func(*http.Request, error) - Custom logging function for request tracking\n\nMethods:\n- ServeHTTP: (http.ResponseWriter, *http.Request) -> () - Main handler method that processes HTTP requests\n- NewMemFS: () -> webdav.FileSystem - Creates new in-memory filesystem\n- NewMemLS: () -> webdav.LockSystem - Creates new in-memory lock system\n\nAdditional Functions:\n- main: () -> () - Entry point that sets up the server and routes\n- requestHandler: (http.ResponseWriter, *http.Request) -> () - Custom middleware for special header handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"golang.org/x/net/webdav\"\n)\n\ntype customHandler struct {\n\twebdav.Handler\n\tLogger func(*http.Request, error)\n}\n\nfunc (h *customHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.Logger(r, nil)\n\th.Handler.ServeHTTP(w, r)\n}\n\nfunc NewMemFS() webdav.FileSystem {\n\treturn webdav.NewMemFS()\n}\n\nfunc NewMemLS() webdav.LockSystem {\n\treturn webdav.NewMemLS()\n}\n\nfunc requestHandler(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Special-Header\") != \"\" {\n\t\t\tw.Header().Set(\"X-Special-Response\", \"Handled\")\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\tfs := NewMemFS()\n\tls := NewMemLS()\n\n\thandler := &customHandler{\n\t\tHandler: webdav.Handler{\n\t\t\tPrefix:     \"/\",\n\t\t\tFileSystem: fs,\n\t\t\tLockSystem: ls,\n\t\t},\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlog.Printf(\"Request: %s %s, Error: %v\", r.Method, r.URL.Path, err)\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", requestHandler(handler))\n\tlog.Println(\"Starting WebDAV server on :8080\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a Go HTTP server that handles user sessions through cookies, specifically managing a session ID cookie that can be updated with a user's email address via form submission.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both displaying a form and processing form submissions. It manages a session cookie named \"session-id\" which initially has no value but can be updated with the user's email when submitted through the form. The function writes an HTML response containing the current cookie value and a form for submitting an email address.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests which may contain form data in the \"email\" field)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 9000 and responds to requests with HTML content and cookie operations)",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"session-id\")\n\t\tif err != nil {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName: \"session-id\",\n\t\t\t}\n\t\t}\n\n\t\tif req.FormValue(\"email\") != \"\" {\n\t\t\tcookie.Value = req.FormValue(\"email\")\n\t\t}\n\n\t\thttp.SetCookie(res, cookie)\n\n\t\tio.WriteString(res, `<!DOCTYPE html>\n<html>\n  <body>\n    <form>\n    `+cookie.Value+`\n      <input type=\"email\" name=\"email\">\n      <input type=\"submit\">\n    </form>\n  </body>\n</html>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"session-id\")\n\t\tif err != nil {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"session-id\",\n\t\t\t\tValue: \"\",\n\t\t\t}\n\t\t}\n\n\t\tif r.Method == http.MethodPost {\n\t\t\temail := r.FormValue(\"email\")\n\t\t\tif email != \"\" {\n\t\t\t\tcookie.Value = email\n\t\t\t\thttp.SetCookie(w, cookie)\n\t\t\t}\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprintf(w, `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html>\n\t\t\t<head>\n\t\t\t\t<title>Session Management</title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t\t<p>Current session ID: %s</p>\n\t\t\t\t<form method=\"POST\" action=\"/\">\n\t\t\t\t\t<label for=\"email\">Email:</label>\n\t\t\t\t\t<input type=\"email\" id=\"email\" name=\"email\" required>\n\t\t\t\t\t<input type=\"submit\" value=\"Submit\">\n\t\t\t\t</form>\n\t\t\t</body>\n\t\t\t</html>\n\t\t`, cookie.Value)\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a WebSocket server in Go that handles WebSocket connections, upgrades HTTP connections to WebSocket, and manages the connections.\n\nFunction Description: The code consists of two main functions: `StartWSServer` and `wsHandler`. `StartWSServer` initializes and starts an HTTP server that listens for WebSocket connections on a specified address. `wsHandler` is the HTTP handler function that upgrades incoming HTTP requests to WebSocket connections and processes them.\n\nInput: \n- `StartWSServer`: `address` (string) - The network address (e.g., \":8080\") on which the server will listen for incoming connections.\n- `wsHandler`: `w` (http.ResponseWriter) - Used to construct the HTTP response. `r` (*http.Request) - The HTTP request to be upgraded to a WebSocket connection.\n\nOutput: \n- `StartWSServer`: None (panics on error).\n- `wsHandler`: None (logs errors if the WebSocket upgrade fails).",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 65536,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\twsConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\n\tconn := &Conn{\n\t\tCoonType: ConnTypeWS,\n\t\tWS:       wsConn,\n\t}\n\tDoConn(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to upgrade connection: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error reading message: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Received: %s\\n\", message)\n\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error writing message: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to start server: %v\", err))\n\t}\n}\n\nfunc main() {\n\tStartWSServer(\":8080\")\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and responds with plain text.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes a plain text response (\"Dog\") to the client. The handler also sets the Content-Type header to \"text/plain\".\n\nInput: None (The function takes no direct input parameters; it handles HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return anything; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tres.Header()[\"Content-Type\"] = []string{\"text/plain\"}\n\t\tfmt.Fprint(res, \"Dog\")\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tfmt.Fprint(w, \"Dog\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server to serve web content, including handling specific routes for examples and serving static files.\n\nFunction Description: The `serve` function initializes an HTTP server that handles multiple routes. It serves a home page, handles requests for WASM execution files, and processes example-related routes with dynamic content generation. The function uses Go's `net/http` package to create routes and serve content, including HTML templates and static files.\n\nInput: \n- `addr` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput:\n- `error`: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nThe function performs these key operations:\n1. Loads example data using `getExamples()`\n2. Sets up template handling for the home page and example pages\n3. Configures route handlers for:\n   - Root path (\"/\") serving the home page\n   - WASM execution file (\"/wasm_exec.js\")\n   - Example paths (\"/example/[type]/[link]/...\")\n4. Starts the HTTP server on the specified address",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\n\thomeTemplate := template.Must(template.ParseFiles(\"index.html\"))\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\turl := r.URL.Path\n\t\tif url == \"/wasm_exec.js\" {\n\t\t\thttp.FileServer(http.Dir(filepath.Join(build.Default.GOROOT, \"misc/wasm/\"))).ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.Split(url, \"/\")\n\t\tif len(parts) > 4 &&\n\t\t\tparts[1] == \"example\" {\n\t\t\texampleType := parts[2]\n\t\t\texampleLink := parts[3]\n\t\t\tfor _, example := range *examples {\n\t\t\t\tif example.Link != exampleLink {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfiddle := filepath.Join(exampleLink, \"jsfiddle\")\n\t\t\t\tif len(parts[4]) != 0 {\n\t\t\t\t\thttp.StripPrefix(\"/example/\"+exampleType+\"/\"+exampleLink+\"/\", http.FileServer(http.Dir(fiddle))).ServeHTTP(w, r)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttemp := template.Must(template.ParseFiles(\"example.html\"))\n\t\t\t\t_, err := temp.ParseFiles(filepath.Join(fiddle, \"demo.html\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\n\t\t\t\tdata := struct {\n\t\t\t\t\t*Example\n\t\t\t\t\tJS bool\n\t\t\t\t}{\n\t\t\t\t\texample,\n\t\t\t\t\texampleType == \"js\",\n\t\t\t\t}\n\n\t\t\t\terr = temp.Execute(w, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\terr := homeTemplate.Execute(w, examples)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype Example struct {\n\tType string\n\tLink string\n}\n\nfunc getExamples() []Example {\n\t// Placeholder for example data retrieval logic\n\treturn []Example{\n\t\t{Type: \"type1\", Link: \"example1\"},\n\t\t{Type: \"type2\", Link: \"example2\"},\n\t}\n}\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\ttmpl := template.Must(template.ParseFiles(\"templates/home.html\", \"templates/example.html\"))\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path != \"/\" {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\ttmpl.ExecuteTemplate(w, \"home.html\", examples)\n\t})\n\n\thttp.HandleFunc(\"/wasm_exec.js\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"static/wasm_exec.js\")\n\t})\n\n\thttp.HandleFunc(\"/example/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := strings.TrimPrefix(r.URL.Path, \"/example/\")\n\t\tparts := strings.Split(path, \"/\")\n\t\tif len(parts) < 2 {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\texampleType, exampleLink := parts[0], parts[1]\n\t\tfor _, ex := range examples {\n\t\t\tif ex.Type == exampleType && ex.Link == exampleLink {\n\t\t\t\ttmpl.ExecuteTemplate(w, \"example.html\", ex)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\thttp.NotFound(w, r)\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}\n\nfunc main() {\n\tif err := serve(\":8080\"); err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles multiple routes with different functionalities, including a root route, a route to display request headers, and a route to show build information.\n\nFunction Description: The HTTP server will respond to different endpoints with specific behaviors:\n1. Root endpoint (\"/\") returns a greeting message\n2. \"/headers\" endpoint returns all request headers\n3. \"/api/buildstamp\" endpoint returns build information\n\nInput: \n- HTTP requests to specified endpoints (/, /headers, /api/buildstamp)\n- BuildStamp string variable containing build information\n\nOutput: \n- For \"/\": Plain text response \"hello, my name is Go~~\"\n- For \"/headers\": List of all request headers in \"name: value\" format\n- For \"/api/buildstamp\": Current value of BuildStamp variable\n- HTTP responses through the http.ResponseWriter interface",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar BuildStamp = \"No Build Stamp Provided\"\n\nfunc hello(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"hello, my name is Go~~\\n\")\n}\n\nfunc headers(w http.ResponseWriter, req *http.Request) {\n\tfor name, headers := range req.Header {\n\t\tfor _, h := range headers {\n\t\t\tfmt.Fprintf(w, \"%v: %v\\n\", name, h)\n\t\t}\n\t}\n}\n\nfunc buildStamp(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"%s\", BuildStamp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", hello)\n\thttp.HandleFunc(\"/api/buildstamp\", buildStamp)\n\thttp.HandleFunc(\"/headers\", headers)\n\n\thttp.ListenAndServe(\":20219\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar BuildStamp = \"2023-10-01T12:00:00Z\"\n\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"hello, my name is Go~~\")\n}\n\nfunc headersHandler(w http.ResponseWriter, r *http.Request) {\n\tfor name, values := range r.Header {\n\t\tfor _, value := range values {\n\t\t\tfmt.Fprintf(w, \"%s: %s\\n\", name, value)\n\t\t}\n\t}\n}\n\nfunc buildStampHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, BuildStamp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", rootHandler)\n\thttp.HandleFunc(\"/headers\", headersHandler)\n\thttp.HandleFunc(\"/api/buildstamp\", buildStampHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a function that sets up a basic HTTP server to receive SDP (Session Description Protocol) data through HTTP POST requests and forward it through a channel.\n\nFunction Description: The function `httpSDPServer` creates an HTTP server that listens on a specified port. When a POST request is received at the root path (\"/\"), it reads the request body, sends the body content through a channel, and responds with \"done\". The server runs in a separate goroutine to avoid blocking.\n\nInput: \n- port [int] - The port number on which the HTTP server should listen\n\nOutput:\n- [chan string] - A channel that will receive the SDP data from incoming HTTP requests",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tfmt.Fprintf(w, \"done\")\n\t\tsdpChan <- string(body)\n\t})\n\n\tgo func() {\n\t\tpanic(http.ListenAndServe(\":\"+strconv.Itoa(port), nil))\n\t}()\n\n\treturn sdpChan\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChannel := make(chan string)\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == http.MethodPost {\n\t\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsdpChannel <- string(body)\n\t\t\tfmt.Fprintln(w, \"done\")\n\t\t} else {\n\t\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\n\tgo func() {\n\t\thttp.ListenAndServe(\":\"+strconv.Itoa(port), nil)\n\t}()\n\n\treturn sdpChannel\n}\n\nfunc main() {\n\tport := 8080\n\tsdpChannel := httpSDPServer(port)\n\n\tfor sdp := range sdpChannel {\n\t\tfmt.Println(\"Received SDP:\", sdp)\n\t}\n}\n```"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles requests to the root path (\"/\") and returns a welcome message combined with a predefined string variable and a version string.\n\nFunction Description: The main function sets up a basic HTTP server that listens on port 8080. It registers a handler function for the root path (\"/\") which writes a welcome message concatenated with a local string variable and a package-level version string to the response.\n\nInput: None (The HTTP server listens for incoming requests on the specified port)\n\nOutput: None (The function runs indefinitely, serving HTTP responses. The handler writes output to the http.ResponseWriter)\n\nNote: The reference code is at the package level (main package) rather than being encapsulated in a struct or class. The instruction follows the function-level format as requested.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\ta := \"hello \"\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, \"Welcome to my website! \", a, v)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nconst version = \"v1.0\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tmessage := \"Welcome to our server!\"\n\tresponse := fmt.Sprintf(\"%s Version: %s\", message, version)\n\tw.Write([]byte(response))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that starts a debug HTTP server with various endpoints for monitoring and debugging purposes, including standard debug endpoints (pprof, metrics, trace) and custom endpoints.\n\nFunction Description: The function `Start` initializes and launches an HTTP server with multiple debugging and monitoring endpoints. It sets up handlers for standard endpoints like pprof, expvar, trace, and metrics, along with any additional custom endpoints provided. The server runs on a predefined address and serves an index page with links to all available endpoints.\n\nInput: \n- `extra ...Endpoint`: Variadic parameter accepting zero or more custom endpoint objects. Each Endpoint should have:\n  - `Path`: string - The URL path for the endpoint\n  - `Name`: string - Display name for the endpoint\n  - `Handler`: http.Handler - The handler function for the endpoint\n\nOutput: None (the function runs indefinitely serving HTTP requests, or returns if no address is configured)\n\nNote: The function uses package-level variables (not shown in the reference code) including `addr` for the server address, and assumes the existence of handler functions like `expvarHandler`, `gcHandler`, and `freeOSMemoryHandler`.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"strings\"\n\n\t\"golang.org/x/net/trace\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc Start(extra ...Endpoint) {\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tpp := http.NewServeMux()\n\tindex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(`\n\t\t\t\t<a href=\"vars\">Vars</a><br>\n\t\t\t\t<a href=\"debug/pprof/\">PProf</a><br>\n\t\t\t\t<a href=\"metrics\">Metrics</a><br>\n\t\t\t\t<a href=\"debug/requests\">Requests</a><br>\n\t\t\t\t<a href=\"debug/events\">Events</a><br>\n\t\t\t`))\n\t\tfor _, e := range extra {\n\t\t\tfmt.Fprintf(w, `<a href=\"%s\">%s</a><br>`, strings.TrimPrefix(e.Path, \"/\"), e.Name)\n\t\t}\n\t\tw.Write([]byte(`\n\t\t\t\t<br>\n\t\t\t\t<form method=\"post\" action=\"gc\" style=\"display: inline;\"><input type=\"submit\" value=\"GC\"></form>\n\t\t\t\t<form method=\"post\" action=\"freeosmemory\" style=\"display: inline;\"><input type=\"submit\" value=\"Free OS Memory\"></form>\n\t\t\t`))\n\t})\n\tpp.Handle(\"/\", index)\n\tpp.Handle(\"/debug\", index)\n\tpp.Handle(\"/vars\", http.HandlerFunc(expvarHandler))\n\tpp.Handle(\"/gc\", http.HandlerFunc(gcHandler))\n\tpp.Handle(\"/freeosmemory\", http.HandlerFunc(freeOSMemoryHandler))\n\tpp.Handle(\"/debug/pprof/\", http.HandlerFunc(pprof.Index))\n\tpp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\tpp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\tpp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\tpp.Handle(\"/debug/pprof/trace\", http.HandlerFunc(pprof.Trace))\n\tpp.Handle(\"/debug/requests\", http.HandlerFunc(trace.Traces))\n\tpp.Handle(\"/debug/events\", http.HandlerFunc(trace.Events))\n\tpp.Handle(\"/metrics\", promhttp.Handler())\n\tfor _, e := range extra {\n\t\tpp.Handle(e.Path, e.Handler)\n\t}\n\tlog.Println(\"warning: could not start debug HTTP server:\", http.ListenAndServe(addr, pp))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage debugserver\n\nimport (\n\t\"expvar\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"runtime\"\n\t\"runtime/trace\"\n)\n\ntype Endpoint struct {\n\tPath    string\n\tName    string\n\tHandler http.Handler\n}\n\nvar addr string\n\nfunc Start(extra ...Endpoint) {\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tmux := http.NewServeMux()\n\n\t// Standard debug endpoints\n\tmux.Handle(\"/debug/pprof/\", http.HandlerFunc(pprof.Index))\n\tmux.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\tmux.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\tmux.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\tmux.Handle(\"/debug/pprof/trace\", http.HandlerFunc(pprof.Trace))\n\tmux.Handle(\"/debug/vars\", expvar.Handler())\n\tmux.Handle(\"/debug/trace\", http.HandlerFunc(traceHandler))\n\tmux.Handle(\"/debug/gc\", http.HandlerFunc(gcHandler))\n\tmux.Handle(\"/debug/freeOSMemory\", http.HandlerFunc(freeOSMemoryHandler))\n\n\t// Custom endpoints\n\tfor _, endpoint := range extra {\n\t\tmux.Handle(endpoint.Path, endpoint.Handler)\n\t}\n\n\t// Index page\n\tmux.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"<html><body><h1>Debug Server</h1><ul>\")\n\t\tfmt.Fprintln(w, `<li><a href=\"/debug/pprof/\">pprof</a></li>`)\n\t\tfmt.Fprintln(w, `<li><a href=\"/debug/vars\">vars</a></li>`)\n\t\tfmt.Fprintln(w, `<li><a href=\"/debug/trace\">trace</a></li>`)\n\t\tfmt.Fprintln(w, `<li><a href=\"/debug/gc\">gc</a></li>`)\n\t\tfmt.Fprintln(w, `<li><a href=\"/debug/freeOSMemory\">freeOSMemory</a></li>`)\n\t\tfor _, endpoint := range extra {\n\t\t\tfmt.Fprintf(w, `<li><a href=\"%s\">%s</a></li>`, endpoint.Path, endpoint.Name)\n\t\t}\n\t\tfmt.Fprintln(w, \"</ul></body></html>\")\n\t}))\n\n\thttp.ListenAndServe(addr, mux)\n}\n\nfunc traceHandler(w http.ResponseWriter, r *http.Request) {\n\tif err := trace.Start(w); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer trace.Stop()\n}\n\nfunc gcHandler(w http.ResponseWriter, r *http.Request) {\n\truntime.GC()\n\tfmt.Fprintln(w, \"Garbage collection triggered\")\n}\n\nfunc freeOSMemoryHandler(w http.ResponseWriter, r *http.Request) {\n\truntime.FreeOSMemory()\n\tfmt.Fprintln(w, \"OS memory freed\")\n}\n```"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a basic HTTP server in Go that listens on a specified port and responds with \"Hello World!\" to all requests on the root path.\n\nFunction Description: The main function sets up an HTTP server that handles requests to the root path (\"/\") by responding with a \"Hello World!\" message. It uses the net/http package to register a handler function and start the server.\n\nInput: None (The function takes no direct input parameters, but the HTTP server will process incoming HTTP requests)\n\nOutput: None (The function doesn't return anything directly, but it will output \"Hello World!\" as an HTTP response to requests, and may output error messages to the log if the server fails to start)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello World!\")\n\t})\n\n\tport := \":8080\"\n\tif err := http.ListenAndServe(port, nil); err != nil {\n\t\tfmt.Printf(\"Failed to start server: %s\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Create a basic HTTP server in Go that listens on a specified port and responds with a simple greeting message to all incoming requests.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles all incoming requests. When a request is received, it writes a \"Hello!\" response. The server listens on port 80 and logs any errors that occur during startup.\n\nInput: None (The function takes no direct input parameters; configuration is hardcoded)\n\nOutput: None (The function doesn't return anything directly but starts a long-running HTTP server process that handles incoming requests and writes responses)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log/slog\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello!\")\n\t})\n\n\tlog.Info(\"Starting server at port 80\")\n\tif err := http.ListenAndServe(\":80\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\terr := http.ListenAndServe(\":80\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t}\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests on specified routes, supports HTTPS with TLS certificates, and redirects HTTP traffic to HTTPS.\n\nFunction Description: The code demonstrates setting up a basic HTTP server with HTTPS support. It includes a handler function to process requests, sets up an HTTP-to-HTTPS redirect, and starts both HTTP and HTTPS servers concurrently.\n\nInput:\n- Port numbers for HTTP (9999) and HTTPS (10443) servers\n- TLS certificate files (\"cert.pem\" and \"key.pem\")\n- HTTP request objects (*http.Request) for the handler function\n\nOutput:\n- HTTP responses (through http.ResponseWriter)\n- Server logs indicating server status and errors\n- Automatic HTTP-to-HTTPS redirection (301 Moved Permanently)\n\nMethods:\n1. handler(w http.ResponseWriter, req *http.Request) - Processes incoming requests and writes a plain text response\n2. main() - Configures and starts the HTTP and HTTPS servers, including the redirect handler",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"This is an example server.\\n\"))\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tlog.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\")\n\tgo http.ListenAndServe(\":9999\", http.RedirectHandler(\"https://127.0.0.1:10443/\", 301))\n\terr := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Hello, you've reached %s\\n\", req.URL.Path)\n}\n\nfunc redirectToHTTPS(w http.ResponseWriter, req *http.Request) {\n\ttarget := \"https://\" + req.Host + req.URL.RequestURI()\n\thttp.Redirect(w, req, target, http.StatusMovedPermanently)\n}\n\nfunc main() {\n\thttpPort := \":9999\"\n\thttpsPort := \":10443\"\n\tcertFile := \"cert.pem\"\n\tkeyFile := \"key.pem\"\n\n\thttp.HandleFunc(\"/\", handler)\n\n\tgo func() {\n\t\tlog.Printf(\"Starting HTTP server on %s\", httpPort)\n\t\tif err := http.ListenAndServe(httpPort, http.HandlerFunc(redirectToHTTPS)); err != nil {\n\t\t\tlog.Fatalf(\"HTTP server failed: %v\", err)\n\t\t}\n\t}()\n\n\tlog.Printf(\"Starting HTTPS server on %s\", httpsPort)\n\tif err := http.ListenAndServeTLS(httpsPort, certFile, keyFile, nil); err != nil {\n\t\tlog.Fatalf(\"HTTPS server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when a request is received. The server listens on port 8080.\n\nInput:  \n- `w http.ResponseWriter`: Used to construct the HTTP response.  \n- `r *http.Request`: Contains information about the incoming HTTP request.  \n\nOutput:  \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response body. No explicit return value.  \n\nExample usage:  \n```go\nhttp.HandleFunc(\"/\", handler)  \nhttp.ListenAndServe(\":8080\", nil)  \n```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a multipart form and displays an upload form to the client.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form for file uploads. For POST requests, it processes the uploaded file. The server listens on port 9000.\n\nInput: \n- None (The function takes no direct input parameters, but handles HTTP requests with:\n  - GET requests to \"/\" path\n  - POST requests with multipart/form-data containing a file under the \"q\" field)\n\nOutput:\n- For GET requests: Returns HTML form for file upload (content-type: text/html)\n- For POST requests: Processes the uploaded file (prints file info to console)\n- Server runs continuously on port 9000 until terminated",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tfile, hdr, err := req.FormFile(key)\n\t\tfmt.Println(file, hdr, err)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\" enctype=\"multipart/form-data\">\n      <input type=\"file\" name=\"q\">\n      <input type=\"submit\">\n    </form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprint(w, `<html><body><form action=\"/\" method=\"post\" enctype=\"multipart/form-data\">\n\t\t\t<input type=\"file\" name=\"q\" />\n\t\t\t<input type=\"submit\" value=\"Upload\" />\n\t\t\t</form></body></html>`)\n\t\treturn\n\t}\n\n\tif r.Method == http.MethodPost {\n\t\tfile, header, err := r.FormFile(\"q\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unable to read file\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tfmt.Printf(\"Uploaded File: %s\\n\", header.Filename)\n\t\tfmt.Printf(\"File Size: %d\\n\", header.Size)\n\t\tfmt.Printf(\"MIME Header: %v\\n\", header.Header)\n\n\t\tdst, err := os.Create(\"./\" + header.Filename)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Unable to save file\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err := io.Copy(dst, file); err != nil {\n\t\t\thttp.Error(w, \"Unable to save file\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprint(w, \"File uploaded successfully.\")\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", uploadHandler)\n\tfmt.Println(\"Server started at :9000\")\n\thttp.ListenAndServe(\":9000\", nil)\n}\n```"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server with instrumented handlers for metrics collection using Prometheus. The function should register routes for metrics and a custom endpoint, apply middleware for context handling, and instrument handlers with counters and histograms.\n\nFunction Description: The function ExampleInstrumentHandlerWithLabelResolver demonstrates how to create an HTTP server with Prometheus instrumentation. It sets up counter and histogram metrics, creates handlers for specific routes, applies middleware to extract headers into context, and starts the server on port 3000. The function doesn't take any explicit parameters but relies on package-level configurations.\n\nInput: None (uses package-level constants and variables)\n\nOutput: None (starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\tcounter := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"api_requests_total\",\n\t\t\tHelp: \"A counter for requests to the wrapped handler.\",\n\t\t},\n\t\t[]string{\"code\", \"method\", \"myheader\"},\n\t)\n\n\tduration := prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"request_duration_seconds\",\n\t\t\tHelp:    \"A histogram of latencies for requests.\",\n\t\t\tBuckets: []float64{.25, .5, 1, 2.5, 5, 10},\n\t\t},\n\t\t[]string{\"handler\", \"method\", \"myheader\"},\n\t)\n\n\tpullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Pull\"))\n\t})\n\n\topts := WithLabelFromCtx(\"myheader\",\n\t\tfunc(ctx context.Context) string {\n\t\t\treturn ctx.Value(CtxResolverKey).(string)\n\t\t},\n\t)\n\n\tpullChain := InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"pull\"}),\n\t\tInstrumentHandlerCounter(counter, pullHandler, opts),\n\t\topts,\n\t)\n\n\tmiddleware := func(next http.HandlerFunc) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), CtxResolverKey, r.Header.Get(\"x-my-header\"))\n\n\t\t\tnext(w, r.WithContext(ctx))\n\t\t}\n\t}\n\n\thttp.Handle(\"/metrics\", Handler())\n\thttp.Handle(\"/pull\", middleware(pullChain))\n\n\tif err := http.ListenAndServe(\":3000\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n\trequestCounter = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"http_requests_total\",\n\t\t\tHelp: \"Total number of HTTP requests made.\",\n\t\t},\n\t\t[]string{\"path\"},\n\t)\n\trequestDuration = prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_duration_seconds\",\n\t\t\tHelp:    \"Duration of HTTP requests in seconds.\",\n\t\t\tBuckets: prometheus.DefBuckets,\n\t\t},\n\t\t[]string{\"path\"},\n\t)\n)\n\nfunc init() {\n\tprometheus.MustRegister(requestCounter)\n\tprometheus.MustRegister(requestDuration)\n}\n\nfunc instrumentedHandler(path string, h http.HandlerFunc) http.HandlerFunc {\n\treturn promhttp.InstrumentHandlerCounter(requestCounter.MustCurryWith(prometheus.Labels{\"path\": path}),\n\t\tpromhttp.InstrumentHandlerDuration(requestDuration.MustCurryWith(prometheus.Labels{\"path\": path}), h),\n\t)\n}\n\nfunc contextMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\t\t// Here you can extract headers or other information into context\n\t\t// For example: ctx = context.WithValue(ctx, \"HeaderName\", r.Header.Get(\"HeaderName\"))\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\nfunc exampleHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, world!\")\n}\n\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\thttp.Handle(\"/\", contextMiddleware(instrumentedHandler(\"/\", exampleHandler)))\n\n\tport := \":3000\"\n\tfmt.Println(\"Starting server on port\", port)\n\terr := http.ListenAndServe(port, nil)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Server failed: %s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc main() {\n\tExampleInstrumentHandlerWithLabelResolver()\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when the server receives a request to that path.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response back to the client.\n- `r *http.Request` - Contains information about the incoming HTTP request (not used in this simple example).\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the response writer (`w`), which is sent back to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Create a function that implements a basic HTTP server which echoes back the request body to the response.\n\nFunction Description: The function `httpserver` starts an HTTP server on the specified address. It handles all incoming requests to the root path (\"/\") by copying the request body directly to the response writer. This effectively echoes back the received data to the client. The server runs until an error occurs or is manually stopped.\n\nInput:  \n- `addr` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\").\n\nOutput:  \n- `error`: Returns an error if the server fails to start or encounters a fatal error during operation. Returns nil if the server is terminated gracefully.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc httpserver(addr string) error {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tio.Copy(w, req.Body)\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc httpserver(addr string) error {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := io.Copy(w, r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\t}\n\t})\n\treturn http.ListenAndServe(addr, nil)\n}\n\nfunc main() {\n\terr := httpserver(\":8080\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a function that sets up a basic HTTP server to receive SDP (Session Description Protocol) data through HTTP POST requests and forward it through a channel.\n\nFunction Description: The function `httpSDPServer` creates an HTTP server that listens on a specified port. When a POST request is received at the root path (\"/\"), it reads the request body, sends the body content through a channel, and responds with \"done\". The server runs in a separate goroutine to avoid blocking.\n\nInput: \n- `port` [int] - The port number on which the HTTP server should listen.\n\nOutput:\n- `chan string` - A channel that will receive the SDP data from incoming HTTP requests.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tfmt.Fprintf(w, \"done\")\n\t\tsdpChan <- string(body)\n\t})\n\n\tgo func() {\n\t\tpanic(http.ListenAndServe(\":\"+strconv.Itoa(port), nil))\n\t}()\n\n\treturn sdpChan\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == http.MethodPost {\n\t\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsdpChan <- string(body)\n\t\t\tfmt.Fprintln(w, \"done\")\n\t\t} else {\n\t\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\n\tgo func() {\n\t\thttp.ListenAndServe(\":\"+strconv.Itoa(port), nil)\n\t}()\n\n\treturn sdpChan\n}\n\nfunc main() {\n\tport := 8080\n\tsdpChan := httpSDPServer(port)\n\n\tfor sdp := range sdpChan {\n\t\tfmt.Println(\"Received SDP:\", sdp)\n\t}\n}\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement an HTTP worker struct that can process jobs by making HTTP requests with custom headers and handling the responses appropriately.\n\nStruct Description: HTTPWorker is a struct that handles HTTP job processing with configurable user agent and logging capabilities. It implements job execution by making POST requests to specified URLs with JSON payloads and processing the responses.\n\nFields:\nUserAgent: string - The User-Agent header value to be used in HTTP requests\nLogger: *zerolog.Logger - Logger instance for debug and error logging\n\nMethods:\nWork: (job jobqueue.Job) -> *jobqueue.Result - Processes a job by making an HTTP POST request to the job's URL with the job's payload as JSON. Handles request creation, execution, response reading, and result parsing. Returns a jobqueue.Result indicating the outcome of the job processing.\n\nInput Parameters:\n- job: jobqueue.Job - Contains the job details including URL, payload, and timeout\n\nOutput:\n- *jobqueue.Result - The result of the job processing, including status, code, and message",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fireworq/fireworq/jobqueue\"\n\t\"github.com/rs/zerolog\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\nfunc (worker *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\tclient := &http.Client{\n\t\tTimeout: time.Duration(job.Timeout()) * time.Second,\n\t}\n\treq, err := http.NewRequest(\n\t\t\"POST\",\n\t\tjob.URL(),\n\t\tstrings.NewReader(job.Payload()),\n\t)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Cannot create http request: %v\", err),\n\t\t}\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tuserAgent := worker.UserAgent\n\tif userAgent == \"\" {\n\t\tuserAgent = defaultUserAgent\n\t}\n\treq.Header.Add(\"User-Agent\", userAgent)\n\n\tresp, err := client.Do(req)\n\n\tworker.Logger.Debug().\n\t\tStr(\"action\", \"dispatch\").\n\t\tStr(\"worker\", \"HTTPWorker\").\n\t\tStr(\"url\", job.URL()).\n\t\tStr(\"payload\", job.Payload()).\n\t\tMsg(\"Dispatched via HTTP\")\n\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Request failed: %v\", err),\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Cannot read body: %v\", err),\n\t\t}\n\t}\n\n\tvar rslt jobqueue.Result\n\terr = json.Unmarshal(body, &rslt)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus: jobqueue.ResultStatusFailure,\n\t\t\tCode:   resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Cannot parse body as JSON: %v\\nOriginal response body:\\n%s\",\n\t\t\t\terr,\n\t\t\t\tstring(body),\n\t\t\t),\n\t\t}\n\t}\n\n\tif !rslt.IsValid() {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Invalid result status: %s\\nOriginal response body:\\n%s\", rslt.Status, string(body)),\n\t\t}\n\t}\n\n\trslt.Code = resp.StatusCode\n\treturn &rslt\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "right_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\ntype Job struct {\n\tURL     string\n\tPayload interface{}\n\tTimeout time.Duration\n}\n\ntype Result struct {\n\tStatus  string\n\tCode    int\n\tMessage string\n}\n\nfunc (worker *HTTPWorker) Work(job Job) *Result {\n\tclient := &http.Client{\n\t\tTimeout: job.Timeout,\n\t}\n\n\tpayloadBytes, err := json.Marshal(job.Payload)\n\tif err != nil {\n\t\tworker.Logger.Error().Err(err).Msg(\"Failed to marshal payload\")\n\t\treturn &Result{Status: \"error\", Code: 0, Message: \"Failed to marshal payload\"}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", job.URL, bytes.NewBuffer(payloadBytes))\n\tif err != nil {\n\t\tworker.Logger.Error().Err(err).Msg(\"Failed to create request\")\n\t\treturn &Result{Status: \"error\", Code: 0, Message: \"Failed to create request\"}\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", worker.UserAgent)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tworker.Logger.Error().Err(err).Msg(\"Failed to execute request\")\n\t\treturn &Result{Status: \"error\", Code: 0, Message: \"Failed to execute request\"}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tworker.Logger.Error().Err(err).Msg(\"Failed to read response body\")\n\t\treturn &Result{Status: \"error\", Code: resp.StatusCode, Message: \"Failed to read response body\"}\n\t}\n\n\tworker.Logger.Debug().Int(\"status_code\", resp.StatusCode).Msg(\"Request completed\")\n\treturn &Result{Status: \"success\", Code: resp.StatusCode, Message: string(body)}\n}\n\nfunc main() {\n\tlogger := log.With().Logger()\n\tworker := HTTPWorker{\n\t\tUserAgent: \"CustomUserAgent/1.0\",\n\t\tLogger:    &logger,\n\t}\n\n\tjob := Job{\n\t\tURL:     \"http://example.com/api\",\n\t\tPayload: map[string]string{\"key\": \"value\"},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tresult := worker.Work(job)\n\tlogger.Info().Str(\"status\", result.Status).Int(\"code\", result.Code).Str(\"message\", result.Message).Msg(\"Job result\")\n}\n```"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and responds with the requested URL path.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes the requested URL path as plain text in the response.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return any value; it continuously serves HTTP requests until terminated)\n\nNote: The handler function takes two parameters:\n1. res http.ResponseWriter - used to write the HTTP response\n2. req *http.Request - contains information about the incoming request",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprint(res, req.URL.Path)\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(res http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(res, \"Requested URL path: %s\", req.URL.Path)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Go struct that represents local network services capable of running both a DNS server and an HTTP server concurrently. The DNS server should resolve a specific domain to a local IP address, while the HTTP server should serve predefined webpages.\n\nStruct Description: The `localNetworkServices` struct encapsulates functionality for running concurrent DNS and HTTP servers. The DNS server resolves a configured domain to a local IP address, and the HTTP server serves static web content mapped to specific paths.\n\nFields:\n- domain: string - The domain name that will be resolved by the DNS server\n- webpages: map[string]string - A map of URL paths to their corresponding webpage content\n- ipAddr: string - The local IP address that both servers will bind to\n\nMethods:\n- DNSServerIP() -> string - Returns the IP address of the DNS server\n- URL(subpath string) -> string - Constructs a full URL for a given subpath using the configured domain\n- Serve(ctx context.Context) -> error - Starts both DNS and HTTP servers concurrently using an errgroup, returns any error that occurs during execution\n\nAdditional Helper Struct:\n- dnsHandler: Implements the dns.Handler interface to handle DNS queries\n\nFields:\n- records: map[string]string - A map of domain names to their corresponding IP addresses\n\nMethods:\n- ServeDNS(w dns.ResponseWriter, r *dns.Msg) - Handles incoming DNS queries, responding with A records for configured domains",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"github.com/miekg/dns\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (l localNetworkServices) DNSServerIP() string {\n\treturn l.ipAddr\n}\n\nfunc (l localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s/%s\", l.domain, subpath)\n}\n\nfunc (l localNetworkServices) Serve(ctx context.Context) error {\n\terrGroup, _ := errgroup.WithContext(ctx)\n\n\terrGroup.Go(func() error {\n\t\tdnsSrv := &dns.Server{\n\t\t\tAddr: l.ipAddr + \":53\",\n\t\t\tNet:  \"udp\",\n\t\t\tHandler: &dnsHandler{\n\t\t\t\trecords: map[string]string{\n\t\t\t\t\tl.domain + \".\": l.ipAddr,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treturn dnsSrv.ListenAndServe()\n\t})\n\n\terrGroup.Go(func() error {\n\t\tfor path, contents := range l.webpages {\n\t\t\twebpage := contents\n\t\t\thttp.HandleFunc(\"/\"+path, func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tio.WriteString(w, webpage)\n\t\t\t})\n\t\t}\n\n\t\treturn http.ListenAndServe(l.ipAddr+\":80\", nil)\n\t})\n\n\treturn errGroup.Wait()\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tmsg := dns.Msg{}\n\tmsg.SetReply(r)\n\tif r.Question[0].Qtype == dns.TypeA {\n\t\tmsg.Authoritative = true\n\t\tdomain := msg.Question[0].Name\n\t\taddress, ok := h.records[domain]\n\t\tif ok {\n\t\t\tmsg.Answer = append(msg.Answer, &dns.A{\n\t\t\t\tHdr: dns.RR_Header{Name: domain, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 3600},\n\t\t\t\tA:   net.ParseIP(address),\n\t\t\t})\n\t\t} else {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t}\n\n\tw.WriteMsg(&msg)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/miekg/dns\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (lns *localNetworkServices) DNSServerIP() string {\n\treturn lns.ipAddr\n}\n\nfunc (lns *localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s%s\", lns.domain, subpath)\n}\n\nfunc (lns *localNetworkServices) Serve(ctx context.Context) error {\n\tg, ctx := errgroup.WithContext(ctx)\n\n\t// Start DNS server\n\tg.Go(func() error {\n\t\tdnsHandler := &dnsHandler{\n\t\t\trecords: map[string]string{\n\t\t\t\tlns.domain: lns.ipAddr,\n\t\t\t},\n\t\t}\n\t\tserver := &dns.Server{Addr: lns.ipAddr + \":53\", Net: \"udp\", Handler: dnsHandler}\n\t\treturn server.ListenAndServe()\n\t})\n\n\t// Start HTTP server\n\tg.Go(func() error {\n\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tpath := r.URL.Path\n\t\t\tif content, ok := lns.webpages[path]; ok {\n\t\t\t\tfmt.Fprint(w, content)\n\t\t\t} else {\n\t\t\t\thttp.NotFound(w, r)\n\t\t\t}\n\t\t})\n\t\treturn http.ListenAndServe(lns.ipAddr+\":80\", nil)\n\t})\n\n\treturn g.Wait()\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (dh *dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\n\tfor _, q := range r.Question {\n\t\tif ip, ok := dh.records[strings.TrimSuffix(q.Name, \".\")]; ok {\n\t\t\trr := &dns.A{\n\t\t\t\tHdr: dns.RR_Header{Name: q.Name, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 0},\n\t\t\t\tA:   net.ParseIP(ip),\n\t\t\t}\n\t\t\tm.Answer = append(m.Answer, rr)\n\t\t}\n\t}\n\n\tw.WriteMsg(m)\n}\n\nfunc main() {\n\tlns := &localNetworkServices{\n\t\tdomain: \"example.local\",\n\t\twebpages: map[string]string{\n\t\t\t\"/\":        \"<html><body><h1>Welcome to the local server</h1></body></html>\",\n\t\t\t\"/about\":   \"<html><body><h1>About Us</h1></body></html>\",\n\t\t\t\"/contact\": \"<html><body><h1>Contact Us</h1></body></html>\",\n\t\t},\n\t\tipAddr: \"127.0.0.1\",\n\t}\n\n\tctx := context.Background()\n\tif err := lns.Serve(ctx); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a basic HTTP server in Go that echoes back the request headers to the client. The server should handle requests on the root path (\"/\") and respond by writing the request headers to the response.\n\nFunction Description: The `ServeHTTP` function is an HTTP handler that writes the request headers to the response writer. It is registered to handle requests on the root path (\"/\") and starts an HTTP server listening on `127.0.0.1:8080`.\n\nInput: \n- `w http.ResponseWriter`: Used to construct the HTTP response.\n- `r *http.Request`: Contains the incoming HTTP request details, including headers.\n\nOutput: None (writes directly to the `http.ResponseWriter`).",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tr.Header.Write(w)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ServeHTTP)\n\thttp.ListenAndServe(\"127.0.0.1:8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype echoHandler struct{}\n\nfunc (h *echoHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfor name, values := range r.Header {\n\t\tfor _, value := range values {\n\t\t\tfmt.Fprintf(w, \"%s: %s\\n\", name, value)\n\t\t}\n\t}\n}\n\nfunc main() {\n\thttp.Handle(\"/\", &echoHandler{})\n\thttp.ListenAndServe(\"127.0.0.1:8080\", nil)\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a basic HTTP server in Go that serves a template-based web page and handles requests on a configurable port.\n\nFunction Description: The main function sets up an HTTP server with a root route handler that renders a template. It configures the server port from environment variables with a default fallback, then starts the server.\n\nInput: \n- Environment variable \"PORT\" (optional): Specifies the port number to listen on\n- Template file \"todos/index.jet\": The template to be rendered and served\n\nOutput:\n- HTTP server running on the specified port, serving the rendered template at the root path (\"/\")\n- Log output indicating the server's running status and any template errors\n\nNote: The reference code shows the implementation but doesn't explicitly define separate functions for each operation. The main function combines:\n1. Route handling (with template rendering)\n2. Port configuration\n3. Server startup",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tview, err := views.GetTemplate(\"todos/index.jet\")\n\t\tif err != nil {\n\t\t\tlog.Println(\"Unexpected template err:\", err.Error())\n\t\t}\n\t\tview.Execute(w, nil, todos)\n\t})\n\n\tport := os.Getenv(\"PORT\")\n\tif len(port) == 0 {\n\t\tport = \":8080\"\n\t} else if !strings.HasPrefix(\":\", port) {\n\t\tport = \":\" + port\n\t}\n\n\tlog.Println(\"Serving on \" + port)\n\thttp.ListenAndServe(port, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttmpl, err := template.ParseFiles(\"todos/index.jet\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error loading template\", http.StatusInternalServerError)\n\t\t\tlog.Printf(\"Template error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\terr = tmpl.Execute(w, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error rendering template\", http.StatusInternalServerError)\n\t\t\tlog.Printf(\"Render error: %v\", err)\n\t\t}\n\t})\n\n\tlog.Printf(\"Server starting on port %s\", port)\n\terr := http.ListenAndServe(\":\"+port, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles multiple routes with different response messages.\n\nFunction Description: The code demonstrates how to set up a simple HTTP server with two route handlers. The first handler responds to the root path (\"/\") with a \"doggy\" message, while the second handler responds to the \"/cat/\" path with a \"catty\" message. The server listens on port 9000.\n\nInput: \n- None (HTTP requests are automatically handled by the server)\n\nOutput: \n- None (The server writes responses directly to the http.ResponseWriter)\n\nMethods:\n- upTown: Handles requests to the root path (\"/\") and writes \"doggy doggy doggy\" to the response\n- youUp: Handles requests to the \"/cat/\" path and writes \"catty catty catty\" to the response\n- main: Registers the route handlers and starts the HTTP server on port 9000",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc upTown(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"doggy doggy doggy\")\n}\n\nfunc youUp(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"catty catty catty\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc upTown(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"doggy doggy doggy\")\n}\n\nfunc youUp(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"catty catty catty\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a Go HTTP server that serves PNG images generated by a package function.\n\nFunction Description: The main function sets up a basic HTTP server that responds to requests at the root path (\"/\") by generating a PNG image using an external package function and serving it with the correct content type.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the http.ResponseWriter and *http.Request parameters in the handler function)\n\nOutput: None (The function doesn't return any value but serves HTTP responses with PNG image data)",
    "Canonical_solution": "import (\n    \"fmt\"\n    \"net/http\"\n    \"io\"\n    \"bytes\"\n    \"davidhampgonsalves/lifedashboard/pkg\"\n)\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        png := pkg.Generate();\n        w.Header().Set(\"Content-Type\", \"image/png\")\n        io.Copy(w, bytes.NewBuffer(png))\n    })\n\n    fmt.Println(\"Server listening on http://localhost:8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"net/http\"\n)\n\nfunc generateImage() image.Image {\n\timg := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfor x := 0; x < 100; x++ {\n\t\tfor y := 0; y < 100; y++ {\n\t\t\timg.Set(x, y, color.RGBA{uint8(x), uint8(y), 255, 255})\n\t\t}\n\t}\n\treturn img\n}\n\nfunc imageHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"image/png\")\n\timg := generateImage()\n\tpng.Encode(w, img)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", imageHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebDAV requests with custom logging and special handling for certain Litmus test cases.\n\nFunction Description: The main function sets up a WebDAV server with in-memory storage (MemFS) and in-memory locking (MemLS). It includes custom logging for WebDAV operations and special handling for a specific Litmus test case (\"props: 3 (propfind_invalid2)\"). The server listens on a specified port and handles all incoming HTTP requests.\n\nInput: None (though the code uses a command-line flag for port configuration which would be handled by the flag package)\n\nOutput: None (the function runs indefinitely as a server, but may log errors or fatal conditions)\n\nNote: The actual implementation shows the server uses a port flag (not shown in parameters) and produces log output, but these are side effects rather than formal outputs.\n\n---\n\nFor completeness, if we were to describe the webdav.Handler struct being used (though not explicitly defined in this code):\n\nStruct Description: webdav.Handler is a struct from golang.org/x/net/webdav that implements http.Handler for WebDAV protocol operations.\n\nFields:\nFileSystem: webdav.FileSystem - The underlying file system implementation\nLockSystem: webdav.LockSystem - The locking system implementation\nLogger: func(*http.Request, error) - Optional function for logging requests and errors\n\nMethods:\nServeHTTP: ServeHTTP(http.ResponseWriter, *http.Request) -> None - Main handler method that processes HTTP requests according to WebDAV protocol",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"golang.org/x/net/webdav\"\n)\n\ntype MemFS struct {\n\tfiles map[string]*webdav.File\n}\n\nfunc NewMemFS() *MemFS {\n\treturn &MemFS{files: make(map[string]*webdav.File)}\n}\n\nfunc (fs *MemFS) Mkdir(ctx context.Context, name string, perm os.FileMode) error {\n\tfs.files[name] = &webdav.File{}\n\treturn nil\n}\n\nfunc (fs *MemFS) OpenFile(ctx context.Context, name string, flag int, perm os.FileMode) (webdav.File, error) {\n\tif file, exists := fs.files[name]; exists {\n\t\treturn file, nil\n\t}\n\treturn nil, os.ErrNotExist\n}\n\nfunc (fs *MemFS) RemoveAll(ctx context.Context, name string) error {\n\tdelete(fs.files, name)\n\treturn nil\n}\n\nfunc (fs *MemFS) Rename(ctx context.Context, oldName, newName string) error {\n\tif file, exists := fs.files[oldName]; exists {\n\t\tfs.files[newName] = file\n\t\tdelete(fs.files, oldName)\n\t\treturn nil\n\t}\n\treturn os.ErrNotExist\n}\n\nfunc (fs *MemFS) Stat(ctx context.Context, name string) (os.FileInfo, error) {\n\tif _, exists := fs.files[name]; exists {\n\t\treturn &webdav.FileInfo{}, nil\n\t}\n\treturn nil, os.ErrNotExist\n}\n\ntype MemLS struct {\n\tlocks map[string]*webdav.Lock\n}\n\nfunc NewMemLS() *MemLS {\n\treturn &MemLS{locks: make(map[string]*webdav.Lock)}\n}\n\nfunc (ls *MemLS) CreateLock(ctx context.Context, name string, lock *webdav.Lock) error {\n\tls.locks[name] = lock\n\treturn nil\n}\n\nfunc (ls *MemLS) RefreshLock(ctx context.Context, name string, duration time.Duration) error {\n\tif lock, exists := ls.locks[name]; exists {\n\t\tlock.Duration = duration\n\t\treturn nil\n\t}\n\treturn os.ErrNotExist\n}\n\nfunc (ls *MemLS) Unlock(ctx context.Context, name string, token string) error {\n\tdelete(ls.locks, name)\n\treturn nil\n}\n\nfunc customLogger(r *http.Request, err error) {\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v, Method: %s, URL: %s\", err, r.Method, r.URL)\n\t} else {\n\t\tlog.Printf(\"Method: %s, URL: %s\", r.Method, r.URL)\n\t}\n}\n\nfunc main() {\n\tport := flag.String(\"port\", \"8080\", \"HTTP server port\")\n\tflag.Parse()\n\n\tfs := NewMemFS()\n\tls := NewMemLS()\n\n\thandler := &webdav.Handler{\n\t\tFileSystem: fs,\n\t\tLockSystem: ls,\n\t\tLogger:     customLogger,\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif strings.Contains(r.URL.Path, \"propfind_invalid2\") {\n\t\t\thttp.Error(w, \"Invalid propfind request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t})\n\n\tlog.Printf(\"Starting WebDAV server on port %s\", *port)\n\tlog.Fatal(http.ListenAndServe(\":\"+*port, nil))\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Implement a Certificate Authority (CA) service in Go using the Chi router for HTTP routing, supporting both secure and insecure servers, with background jobs and proper shutdown handling.\n\nStruct Description: The CA struct represents a Certificate Authority service that manages HTTP servers (secure and insecure), configuration, authentication, and background tasks.\n\nFields:\n\nauth: [*authority.Authority] - The authority component handling certificate operations  \nconfig: [*config.Config] - Configuration settings for the CA service  \nsrv: [*server.Server] - The main secure HTTP server  \ninsecureSrv: [*server.Server] - Optional insecure HTTP server for certain endpoints  \nmetricsSrv: [*server.Server] - Optional metrics server  \nopts: [*options] - Additional service options  \nrenewer: [*TLSRenewer] - Component handling TLS certificate renewal  \ncompactStop: [chan struct{}] - Channel for stopping the background compaction job  \n\nMethods:\n\nInit: [func(cfg *config.Config) (*CA, error)] - Initializes the CA service with configuration, sets up routers, and prepares servers  \nRun: [func() error] - Starts all servers and background jobs, handles graceful shutdown on errors  \nshouldServeInsecureServer: [func() bool] - (implied private method) Determines if insecure server should be started  \nrunCompactJob: [func()] - (implied private method) Runs background compaction task  \nStop: [func() error] - (implied method) Handles service shutdown and cleanup",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype CA struct {\n\tauth        *authority.Authority\n\tconfig      *config.Config\n\tsrv         *server.Server\n\tinsecureSrv *server.Server\n\tmetricsSrv  *server.Server\n\topts        *options\n\trenewer     *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc (ca *CA) Init(cfg *config.Config) (*CA, error) {\n\tmux := chi.NewRouter()\n\thandler := http.Handler(mux)\n\n\tinsecureMux := chi.NewRouter()\n\tinsecureHandler := http.Handler(insecureMux)\n\n\tmux.Use(middleware.GetHead)\n\tinsecureMux.Use(middleware.GetHead)\n\n\tapi.Route(mux)\n\tmux.Route(\"/1.0\", func(r chi.Router) {\n\t\tapi.Route(r)\n\t})\n\n\tinsecureMux.Get(\"/crl\", api.CRL)\n\tinsecureMux.Get(\"/1.0/crl\", api.CRL)\n\n\tbaseContext := buildContext(auth, scepAuthority, acmeDB, acmeLinker)\n\n\tca.srv = server.New(cfg.Address, handler, tlsConfig)\n\tca.srv.BaseContext = func(net.Listener) context.Context {\n\t\treturn baseContext\n\t}\n\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = server.New(cfg.InsecureAddress, insecureHandler, nil)\n\t\tca.insecureSrv.BaseContext = func(net.Listener) context.Context {\n\t\t\treturn baseContext\n\t\t}\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\tvar wg sync.WaitGroup\n\terrs := make(chan error, 1)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tca.runCompactJob()\n\t}()\n\n\tif ca.insecureSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.insecureSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\tif ca.metricsSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.metricsSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terrs <- ca.srv.ListenAndServe()\n\t}()\n\n\terr := <-errs\n\n\tif !errors.Is(err, http.ErrServerClosed) {\n\t\tlog.Println(\"shutting down due to startup error ...\")\n\t\tif stopErr := ca.Stop(); stopErr != nil {\n\t\t\terr = fmt.Errorf(\"failed stopping CA after error occurred: %w: %w\", err, stopErr)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"stopped CA after error occurred: %w\", err)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 108,
    "right_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype CA struct {\n\tauth         *authority.Authority\n\tconfig       *config.Config\n\tsrv          *server.Server\n\tinsecureSrv  *server.Server\n\tmetricsSrv   *server.Server\n\topts         *options\n\trenewer      *TLSRenewer\n\tcompactStop  chan struct{}\n}\n\nfunc (ca *CA) Init(cfg *config.Config) (*CA, error) {\n\tca.config = cfg\n\tca.compactStop = make(chan struct{})\n\n\tr := chi.NewRouter()\n\tr.Use(middleware.Logger)\n\tr.Get(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\tca.srv = &server.Server{\n\t\tAddr:    cfg.SecureAddr,\n\t\tHandler: r,\n\t}\n\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = &server.Server{\n\t\t\tAddr:    cfg.InsecureAddr,\n\t\t\tHandler: r,\n\t\t}\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tif err := ca.srv.ListenAndServeTLS(ca.config.CertFile, ca.config.KeyFile); err != nil && err != http.ErrServerClosed {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\tif ca.insecureSrv != nil {\n\t\tgo func() {\n\t\t\tif err := ca.insecureSrv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo ca.runCompactJob()\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-sigChan:\n\t\treturn ca.Stop()\n\t}\n}\n\nfunc (ca *CA) shouldServeInsecureServer() bool {\n\treturn ca.config.InsecureAddr != \"\"\n}\n\nfunc (ca *CA) runCompactJob() {\n\tticker := time.NewTicker(24 * time.Hour)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// Perform compaction task\n\t\tcase <-ca.compactStop:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (ca *CA) Stop() error {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := ca.srv.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tif ca.insecureSrv != nil {\n\t\tif err := ca.insecureSrv.Shutdown(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tclose(ca.compactStop)\n\treturn nil\n}\n\nfunc main() {\n\tcfg := &config.Config{\n\t\tSecureAddr:   \":443\",\n\t\tInsecureAddr: \":80\",\n\t\tCertFile:     \"path/to/cert.pem\",\n\t\tKeyFile:      \"path/to/key.pem\",\n\t}\n\n\tca, err := (&CA{}).Init(cfg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := ca.Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes middleware for request logging and rate limiting using Sentinel. The server should handle a GET request at the \"/test\" endpoint.\n\nFunction Description: The function sets up an Echo HTTP server with middleware for logging and rate limiting. The rate limiting is implemented using Sentinel middleware, which extracts the client's real IP from the request headers and applies a block fallback response when the rate limit is exceeded. The server listens on port 1323.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 1323.)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\nfunc Example() {\n\tr := echo.New()\n\tr.Use(middleware.Logger())\n\tr.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx echo.Context) string {\n\t\t\t\tif res, ok := ctx.Get(\"X-Real-IP\").(string); ok {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t\treturn \"\"\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx echo.Context) error {\n\t\t\t\treturn ctx.JSON(400, map[string]interface{}{\n\t\t\t\t\t\"err\":  \"too many requests; the quota used up\",\n\t\t\t\t\t\"code\": 10222,\n\t\t\t\t})\n\t\t\t}),\n\t\t),\n\t)\n\n\tr.GET(\"/test\", func(c echo.Context) error {\n\t\treturn nil\n\t})\n\tr.Logger.Fatal(r.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\tsentinel \"github.com/sentinel-group/sentinel-golang/api\"\n\t\"github.com/sentinel-group/sentinel-golang/core/flow\"\n\t\"github.com/sentinel-group/sentinel-golang/core/base\"\n\t\"github.com/sentinel-group/sentinel-golang/echo/middleware\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\t// Initialize Sentinel\n\tsentinel.InitDefault()\n\n\t// Define rate limiting rules\n\t_, err := flow.LoadRules([]*flow.Rule{\n\t\t{\n\t\t\tResource:        \"GET:/test\",\n\t\t\tMetricType:      flow.QPS,\n\t\t\tCount:           10, // 10 requests per second\n\t\t\tControlBehavior: flow.Reject,\n\t\t},\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Sentinel middleware for rate limiting\n\te.Use(sentinelMiddleware.New(sentinelMiddleware.Config{\n\t\tBlockFallback: func(c echo.Context) error {\n\t\t\treturn c.JSON(http.StatusTooManyRequests, map[string]string{\"message\": \"Too many requests\"})\n\t\t},\n\t}))\n\n\t// Routes\n\te.GET(\"/test\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\t// Start server\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes route handling, middleware integration, and JWT-based authentication for restricted routes.\n\nFunction Description: The main function initializes an Echo server, configures middleware (logger and recovery), sets up routes for login and accessible content, and creates a restricted route group with JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger route handlers)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately as they're referenced but not shown in the provided code.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tr.Use(middleware.JWT([]byte(\"secret\")))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nvar jwtSecret = []byte(\"secret\")\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/accessible\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tr.Use(middleware.JWTWithConfig(middleware.JWTConfig{\n\t\tSigningKey: jwtSecret,\n\t}))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc login(c echo.Context) error {\n\tusername := c.FormValue(\"username\")\n\tpassword := c.FormValue(\"password\")\n\n\tif username == \"user\" && password == \"password\" {\n\t\ttoken := jwt.New(jwt.SigningMethodHS256)\n\n\t\tclaims := token.Claims.(jwt.MapClaims)\n\t\tclaims[\"name\"] = \"John Doe\"\n\t\tclaims[\"admin\"] = true\n\t\tclaims[\"exp\"] = time.Now().Add(time.Hour * 72).Unix()\n\n\t\tt, err := token.SignedString(jwtSecret)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, echo.Map{\n\t\t\t\"token\": t,\n\t\t})\n\t}\n\n\treturn echo.ErrUnauthorized\n}\n\nfunc accessible(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Accessible content\")\n}\n\nfunc restricted(c echo.Context) error {\n\tuser := c.Get(\"user\").(*jwt.Token)\n\tclaims := user.Claims.(jwt.MapClaims)\n\tname := claims[\"name\"].(string)\n\treturn c.String(http.StatusOK, \"Welcome \"+name+\"!\")\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using the Echo framework in Go, with basic middleware and a simple route handler.\n\nFunction Description: The function `StartHTTPServer` initializes a new Echo instance, adds logger and recovery middleware, registers a GET route handler for the root path (\"/\"), and starts the HTTP server on the specified address.\n\nInput:  \n- `address` (string): The network address (e.g., \":8080\") on which the HTTP server should listen.\n\nOutput:  \n- `error`: Returns an error if the server fails to start; otherwise, it blocks until the server is stopped.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\treturn e.Start(address)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\treturn e.Start(address)\n}\n\nfunc main() {\n\tif err := StartHTTPServer(\":8080\"); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that streams JSON-encoded location data with a delay between each transmission.\n\nFunction Description: The main function initializes an Echo server, sets up a GET route handler at the root path (\"/\") that streams location data as JSON with a 1-second delay between each location. The response uses proper HTTP headers for JSON content type and flushes after each location is sent.\n\nInput: None (The function takes no direct input parameters, but relies on a predefined 'locations' collection that should be available in scope)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and handles incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"encoding/json\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSON)\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\tfor _, l := range locations {\n\t\t\tif err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.Response().Flush()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\treturn nil\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype Location struct {\n\tLatitude  float64 `json:\"latitude\"`\n\tLongitude float64 `json:\"longitude\"`\n}\n\nfunc main() {\n\te := echo.New()\n\n\tlocations := []Location{\n\t\t{Latitude: 37.7749, Longitude: -122.4194},\n\t\t{Latitude: 34.0522, Longitude: -118.2437},\n\t\t{Latitude: 40.7128, Longitude: -74.0060},\n\t}\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tc.Response().WriteHeader(http.StatusOK)\n\n\t\tfor _, location := range locations {\n\t\t\tif err := json.NewEncoder(c.Response()).Encode(location); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.Response().Flush()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\treturn nil\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves static files from an embedded filesystem using the go.rice package.\n\nFunction Description: The main function initializes an Echo web server, sets up route handlers for serving static files from an embedded directory (\"app\"), and starts the server on port 1323. The static files are served under the root path (\"/\") and a static prefix path (\"/static/*\").\n\nInput: None (The function takes no explicit parameters)\n\nOutput: None (The function doesn't return anything explicitly but starts an HTTP server that runs indefinitely until interrupted)\n\nNote: The reference code shows the complete implementation at the package level (main function) rather than as an isolated function or struct. The instruction follows the function-level format as the code primarily demonstrates functional behavior rather than object-oriented structure.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\tassetHandler := http.FileServer(rice.MustFindBox(\"app\").HTTPBox())\n\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", assetHandler)))\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/GeertJohan/go.rice\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\t// Create a rice box for the embedded files\n\tbox := rice.MustFindBox(\"app\")\n\n\t// Serve static files from the embedded filesystem\n\te.GET(\"/*\", echo.WrapHandler(http.StripPrefix(\"/\", http.FileServer(box.HTTPBox()))))\n\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", http.FileServer(box.HTTPBox()))))\n\n\t// Start the server on port 1323\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various routes with authentication middleware and serves different endpoints for application management.\n\nFunction Description: The `serve` function initializes and starts an HTTP server using the Echo framework. It sets up route handlers for various endpoints related to application management, including upload, installation, renaming, and deletion of apps. The function also implements authentication middleware (BasicAuth and KeyAuth) to secure certain endpoints. The server runs on the specified host and port.\n\nInput: \n- `host` (string): The host address where the server will run (e.g., \"localhost\" or \"0.0.0.0\")\n- `port` (uint64): The port number on which the server will listen (e.g., 8080)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error, at which point it logs the error and exits)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc serve(host string, port uint64) {\n\te := echo.New()\n\te.HideBanner = true\n\n\tforcedBasicAuth := middleware.BasicAuth(func(username string, password string, c echo.Context) (bool, error) {\n\t\treturn username == config.Current.BasicAuth.Username && password == config.Current.BasicAuth.Password, nil\n\t})\n\tbasicAuth := func(f echo.HandlerFunc) echo.HandlerFunc {\n\t\tif config.Current.BasicAuth.Enable {\n\t\t\treturn forcedBasicAuth(f)\n\t\t} else {\n\t\t\treturn f\n\t\t}\n\t}\n\tworkflowKeyAuth := middleware.KeyAuth(func(s string, c echo.Context) (bool, error) {\n\t\treturn s == config.Current.BuilderKey, nil\n\t})\n\n\te.GET(\"/\", renderIndex, basicAuth)\n\te.GET(\"/favicon.png\", getFavIcon, basicAuth)\n\te.POST(\"/apps\", uploadUnsignedApp, basicAuth)\n\te.GET(\"/apps/:id/install\", appResolver(renderInstall))\n\te.GET(\"/apps/:id/manifest\", appResolver(getManifest))\n\te.GET(\"/apps/:id/resign\", appResolver(resignApp), basicAuth)\n\te.GET(\"/apps/:id/delete\", appResolver(deleteApp), basicAuth)\n\te.GET(\"/apps/:id/rename\", appResolver(renderRenameApp), basicAuth)\n\te.POST(\"/apps/:id/rename\", appResolver(renameApp), basicAuth)\n\te.GET(\"/apps/:id/2fa\", appResolver(render2FAPage), basicAuth)\n\te.POST(\"/apps/:id/2fa\", appResolver(set2FA), basicAuth)\n\te.GET(\"/jobs\", getLastJob, workflowKeyAuth)\n\te.GET(\"/jobs/:id/2fa\", jobResolver(get2FA), workflowKeyAuth)\n\te.POST(\"/jobs/:id/signed\", jobResolver(uploadSignedApp), workflowKeyAuth)\n\n\tlog.Fatal().Err(e.Start(fmt.Sprintf(\"%s:%d\", host, port))).Send()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc serve(host string, port uint64) {\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\t// Basic Auth Middleware\n\tbasicAuth := middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) {\n\t\tif username == \"admin\" && password == \"secret\" {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t})\n\n\t// Key Auth Middleware\n\tkeyAuth := middleware.KeyAuth(func(key string, c echo.Context) (bool, error) {\n\t\treturn key == \"valid-api-key\", nil\n\t})\n\n\t// Routes\n\te.POST(\"/upload\", uploadHandler, basicAuth)\n\te.POST(\"/install\", installHandler, keyAuth)\n\te.PUT(\"/rename\", renameHandler, basicAuth)\n\te.DELETE(\"/delete\", deleteHandler, keyAuth)\n\n\t// Start server\n\taddress := host + \":\" + string(port)\n\tif err := e.Start(address); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}\n\nfunc uploadHandler(c echo.Context) error {\n\t// Handle file upload\n\treturn c.String(http.StatusOK, \"Upload successful\")\n}\n\nfunc installHandler(c echo.Context) error {\n\t// Handle app installation\n\treturn c.String(http.StatusOK, \"Install successful\")\n}\n\nfunc renameHandler(c echo.Context) error {\n\t// Handle app renaming\n\treturn c.String(http.StatusOK, \"Rename successful\")\n}\n\nfunc deleteHandler(c echo.Context) error {\n\t// Handle app deletion\n\treturn c.String(http.StatusOK, \"Delete successful\")\n}\n\nfunc main() {\n\tserve(\"localhost\", 8080)\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves basic server information and runs on a configurable address.\n\nFunction Description: The main function initializes an Echo HTTP server, configures middleware for logging and compression, sets up a route handler for server information, and starts the server on the specified address.\n\nInput: \n- Command-line argument (optional): \"--addr\" to specify the server address (default: \"127.0.0.1:9090\")\n\nOutput: \n- Running HTTP server that responds to GET requests at \"/serverinfo\" with server hostname and address\n- No explicit return value (runs indefinitely until interrupted)\n\nNote: The reference code shows a complete implementation at the package level (main function) rather than a standalone function or struct level. The instruction follows the function-level format as the code primarily demonstrates functional behavior through the main function.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo\"\n\tmd \"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:9090\", \"addr for backend\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tserver := echo.New()\n\tserver.Use(md.Logger())\n\tserver.Use(md.Gzip())\n\n\tserver.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thostname, _ := os.Hostname()\n\t\treturn c.String(http.StatusOK, hostname+\"\\n\"+*addr)\n\t})\n\n\tserver.Start(*addr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\taddr := flag.String(\"addr\", \"127.0.0.1:9090\", \"server address\")\n\tflag.Parse()\n\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.CompressWithConfig(middleware.CompressConfig{\n\t\tLevel: 5,\n\t}))\n\n\te.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thostname, err := os.Hostname()\n\t\tif err != nil {\n\t\t\treturn c.String(http.StatusInternalServerError, \"Error retrieving hostname\")\n\t\t}\n\t\tinfo := fmt.Sprintf(\"Hostname: %s\\nAddress: %s\", hostname, *addr)\n\t\treturn c.String(http.StatusOK, info)\n\t})\n\n\te.Logger.Fatal(e.Start(*addr))\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests on two different endpoints (\"/request\" and \"/stream\") and serves over HTTPS.\n\nFunction Description: The main function initializes an Echo server instance, registers route handlers for two GET endpoints, and starts an HTTPS server using provided TLS certificate files.\n\nInput: None (The function takes no direct input parameters, but relies on external TLS certificate files \"cert.pem\" and \"key.pem\")\n\nOutput: None (The function doesn't return anything but starts a persistent HTTP server process)\n\nNote: The actual route handler functions (request and stream) would need to be implemented separately to handle the respective endpoints. The server will run indefinitely until interrupted, listening on port 1323 with TLS encryption.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/request\", request)\n\te.GET(\"/stream\", stream)\n\te.Logger.Fatal(e.StartTLS(\":1323\", \"cert.pem\", \"key.pem\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.GET(\"/request\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Request endpoint\")\n\t})\n\n\te.GET(\"/stream\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Stream endpoint\")\n\t})\n\n\te.Logger.Fatal(e.StartTLS(\":1323\", \"cert.pem\", \"key.pem\"))\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a Go struct that implements an HTTP server using the Echo framework, supporting both HTTP/2 and HTTPS configurations, with customizable timeouts and root path handling.\n\nStruct Description: The Api struct represents an HTTP server configuration with support for TLS, HTTP/2, and customizable timeouts. It provides methods to start and stop the server gracefully.\n\nFields:\nport: int - The port number on which the server will listen\nbindIp: string - The IP address to bind the server to\ntlsCertFile: string - Path to TLS certificate file (empty for non-HTTPS)\ntlsKeyFile: string - Path to TLS private key file (empty for non-HTTPS)\ntimeout: time.Duration - Server timeout duration for read/write operations\nrootPath: string - The root path for the server's default route\nsrv: *echo.Echo - The Echo server instance\n\nMethods:\nStart: () -> error - Initializes and starts the HTTP server in a goroutine, supporting both TLS and HTTP/2 configurations. Returns nil on successful startup.\nStop: (ctx context.Context) -> error - Gracefully shuts down the server using the provided context. Returns any error that occurs during shutdown.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype Api struct {\n\tport        int\n\tbindIp      string\n\ttlsCertFile string\n\ttlsKeyFile  string\n\ttimeout     time.Duration\n\trootPath    string\n\tsrv         *echo.Echo\n}\n\nfunc (a *Api) Start() error {\n\ta.srv = echo.New()\n\ta.srv.HideBanner = true\n\ta.srv.HidePort = true\n\ta.srv.Server.ReadTimeout = a.timeout\n\ta.srv.Server.IdleTimeout = a.timeout\n\ta.srv.Server.WriteTimeout = a.timeout + a.timeout\n\n\ta.srv.GET(\n\t\ta.rootPath,\n\t\tfunc(c echo.Context) error {\n\t\t\treturn c.HTML(http.StatusOK, `Hey, Gotenberg has no UI, it's an API. Head to the <a href=\"https://gotenberg.dev\">documentation</a> to learn how to interact with it \ud83d\ude80`)\n\t\t},\n\t)\n\n\tgo func() {\n\t\tvar err error\n\t\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\t\terr = a.srv.StartTLS(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), a.tlsCertFile, a.tlsKeyFile)\n\t\t} else {\n\t\t\tserver := &http2.Server{}\n\t\t\terr = a.srv.StartH2CServer(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), server)\n\t\t}\n\t\tif !errors.Is(err, http.ErrServerClosed) {\n\t\t\ta.logger.Fatal(err.Error())\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\treturn a.srv.Shutdown(ctx)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Api struct {\n\tport       int\n\tbindIp     string\n\ttlsCertFile string\n\ttlsKeyFile  string\n\ttimeout    time.Duration\n\trootPath   string\n\tsrv        *echo.Echo\n}\n\nfunc NewApi(port int, bindIp, tlsCertFile, tlsKeyFile string, timeout time.Duration, rootPath string) *Api {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\tapi := &Api{\n\t\tport:       port,\n\t\tbindIp:     bindIp,\n\t\ttlsCertFile: tlsCertFile,\n\t\ttlsKeyFile:  tlsKeyFile,\n\t\ttimeout:    timeout,\n\t\trootPath:   rootPath,\n\t\tsrv:        e,\n\t}\n\n\te.GET(api.rootPath, func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Welcome to the API\")\n\t})\n\n\treturn api\n}\n\nfunc (a *Api) Start() error {\n\taddress := a.bindIp + \":\" + string(a.port)\n\tserver := &http.Server{\n\t\tAddr:         address,\n\t\tReadTimeout:  a.timeout,\n\t\tWriteTimeout: a.timeout,\n\t}\n\n\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\ttlsConfig := &tls.Config{\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t}\n\t\tserver.TLSConfig = tlsConfig\n\t\treturn a.srv.StartTLS(address, a.tlsCertFile, a.tlsKeyFile)\n\t}\n\n\treturn a.srv.StartServer(server)\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\treturn a.srv.Shutdown(ctx)\n}\n\nfunc main() {\n\tapi := NewApi(8080, \"127.0.0.1\", \"\", \"\", 10*time.Second, \"/\")\n\tif err := api.Start(); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic requests and includes middleware for processing statistics.\n\nStruct Description: The Stats struct is used to track and handle statistics for HTTP requests processed by the server.\n\nFields:\n- Count: [int] - Tracks the number of requests processed\n- StartTime: [time.Time] - Records the time when the server started processing requests\n\nMethods:\n- Process: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that increments the request count for each processed request\n- Handle: [func(c echo.Context) error] -> [error] - Handler function that returns the current statistics (request count and uptime) in JSON format\n- NewStats: [func() *Stats] -> [*Stats] - Constructor function that initializes a new Stats instance with default values\n\nAdditional Functions:\n- ServerHeader: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that adds a Server header to responses\n- main: [func()] -> [None] - Entry point that creates the Echo server, registers routes and middleware, and starts the server on port 1323",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Debug = true\n\n\ts := NewStats()\n\te.Use(s.Process)\n\te.GET(\"/stats\", s.Handle)\n\n\te.Use(ServerHeader)\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Stats struct {\n\tCount     int\n\tStartTime time.Time\n}\n\nfunc NewStats() *Stats {\n\treturn &Stats{\n\t\tCount:     0,\n\t\tStartTime: time.Now(),\n\t}\n}\n\nfunc (s *Stats) Process(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\ts.Count++\n\t\treturn next(c)\n\t}\n}\n\nfunc (s *Stats) Handle(c echo.Context) error {\n\tuptime := time.Since(s.StartTime).String()\n\treturn c.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"count\":  s.Count,\n\t\t\"uptime\": uptime,\n\t})\n}\n\nfunc ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderServer, \"Echo/3.0\")\n\t\treturn next(c)\n\t}\n}\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\tstats := NewStats()\n\n\te.Use(stats.Process)\n\te.Use(ServerHeader)\n\n\te.GET(\"/stats\", stats.Handle)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests and serves HTML content with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The main function initializes an Echo server, configures middleware for recovery and logging, sets up a route handler for the root path (\"/\") that returns HTML content, and starts the server with automatic TLS on port 443.\n\nInput: None (The function takes no explicit input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Recover())\n\te.Use(middleware.Logger())\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, `\n\t\t\t<h1>Welcome to Echo!</h1>\n\t\t\t<h3>TLS certificates automatically installed from Let's Encrypt :)</h3>\n\t\t`)\n\t})\n\te.Logger.Fatal(e.StartAutoTLS(\":443\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Recover())\n\te.Use(middleware.Logger())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, \"<h1>Welcome to the Echo Server with Let's Encrypt!</h1>\")\n\t})\n\n\te.AutoTLSManager.Cache = autocert.DirCache(\"/var/www/.cache\")\n\te.Logger.Fatal(e.StartAutoTLS(\":443\"))\n}"
  }
]