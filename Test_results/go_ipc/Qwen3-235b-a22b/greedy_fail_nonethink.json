[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Implement a Go struct that represents a Docker registry repository client, capable of interacting with Docker registry API v2 to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct serves as a client for interacting with a Docker registry's repository, providing methods to access blob storage, manifests, and tag services. It maintains HTTP client configuration and URL building capabilities.\n\nFields:\n- client: *http.Client - Custom HTTP client configured with transport and redirect handling\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nTask Description: Implement a Go struct that represents a tag service for a Docker registry repository, capable of retrieving tag information from a Docker registry API v2.\n\nStruct Description: The `tags` struct provides tag-related operations for a Docker repository, implementing the distribution.TagService interface. It uses HTTP requests to interact with the registry's tag API endpoints.\n\nFields:\n- client: *http.Client - HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing tag-related API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves the descriptor for a specific tag, making HEAD and GET requests as needed to the registry API",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/reference\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn &blobStore{client: r.client, ub: r.ub, name: r.name}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn newManifestService(r.client, r.ub, r.name)\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{client: r.client, ub: r.ub, name: r.name}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\turl, err := t.ub.BuildTagURL(tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err := t.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn distribution.Descriptor{}, &unexpectedStatusCodeError{resp.StatusCode}\n\t}\n\n\tvar desc distribution.Descriptor\n\t// Assuming descriptor is parsed from response headers or body\n\treturn desc, nil\n}\n\ntype unexpectedStatusCodeError struct {\n\tstatusCode int\n}\n\nfunc (e *unexpectedStatusCodeError) Error() string {\n\treturn \"unexpected status code: \" + string(e.statusCode)\n}"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Go HTTP client struct that can make authenticated API requests with custom headers and handle responses, including error status codes.\n\nStruct Description: The Client struct represents an HTTP client with authentication credentials and endpoint configuration, capable of making various HTTP requests and processing responses.\n\nFields:\nUser: string - The username for basic authentication\nApiKey: string - The API key or password for basic authentication\nEndpoint: string - The base URL for API endpoints\n\nMethods:\nisOkStatus: [Name](code int) -> bool - Checks if the HTTP status code indicates a successful response (200, 201, 204 return true; 400, 404, 500, 409, 406 return false)\nnewRequest: [Name](method string, uri string, body interface{}) -> ([]byte, error) - Creates and executes an HTTP request with the given method, URI, and optional body. Returns the response body or an error if the request fails or returns a non-success status code. Automatically adds basic authentication headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tcodes := map[int]bool{\n\t\t200: true,\n\t\t201: true,\n\t\t204: true,\n\t\t400: false,\n\t\t404: false,\n\t\t500: false,\n\t\t409: false,\n\t\t406: false,\n\t}\n\n\treturn codes[code]\n}\n\nfunc (c *Client) newRequest(method, uri string, body interface{}) ([]byte, error) {\n\tvar (\n\t\tclient = &http.Client{}\n\t\turl    = fmt.Sprintf(\"%s/%s\", c.Endpoint, uri)\n\t\terr    error\n\t\treq    *http.Request\n\t)\n\n\tif body != nil {\n\t\tbodyJSON, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq, err = http.NewRequest(method, url, bytes.NewBuffer(bodyJSON))\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error with request: %v - %q\", url, err)\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\ttype apiErr struct {\n\t\t\tErr string `json:\"error\"`\n\t\t}\n\t\tvar outErr apiErr\n\t\tjson.Unmarshal(data, &outErr)\n\t\treturn nil, fmt.Errorf(\"Error in response: %s\", outErr.Err)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tswitch code {\n\tcase 200, 201, 204:\n\t\treturn true\n\tcase 400, 404, 500, 409, 406:\n\t\treturn false\n\t}\n\treturn false\n}\n\nfunc (c *Client) newRequest(method string, uri string, body interface{}) ([]byte, error) {\n\turl := c.Endpoint + uri\n\n\tvar reqBody []byte\n\tvar err error\n\n\tif body != nil {\n\t\treqBody, err = json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\treturn nil, fmt.Errorf(\"received non-ok status code: %d, body: %s\", resp.StatusCode, respBody)\n\t}\n\n\treturn respBody, nil\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server using the Echo framework, which acts as a reverse proxy to route requests to different host servers based on the request's host header.\n\nFunction Description: The function initializes an Echo instance, configures middleware, sets up route handlers, and starts an HTTP server that proxies requests to different Echo instances based on the host header. It maintains a map of hostnames to their corresponding Echo instances for routing purposes.\n\nInput: None (The function takes no parameters but internally uses a map of hostnames to Echo instances)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)\n\n---\n\nTask Description: Create a Go struct that represents a virtual host configuration for an Echo-based HTTP server.\n\nStruct Description: The Host struct represents a virtual host configuration that holds an Echo instance for handling requests to a specific hostname.\n\nFields:\nEcho: *echo.Echo - Pointer to an Echo instance that handles requests for this host\n\nMethods:\nNone (The struct is simple and only holds a reference to an Echo instance)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\thosts := make(map[string]*Host)\n\n\tapi := echo.New()\n\tapi.Use(middleware.Logger())\n\tapi.Use(middleware.Recover())\n\n\thosts[\"api.localhost:1323\"] = &Host{api}\n\n\tapi.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"API\")\n\t})\n\n\te := echo.New()\n\te.Any(\"/*\", func(c echo.Context) (err error) {\n\t\treq := c.Request()\n\t\tres := c.Response()\n\t\thost := hosts[req.Host]\n\n\t\tif host == nil {\n\t\t\terr = echo.ErrNotFound\n\t\t} else {\n\t\t\thost.Echo.ServeHTTP(res, req)\n\t\t}\n\n\t\treturn\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Host struct {\n\tEcho *echo.Echo\n}\n\nfunc setupReverseProxyServer() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\thostMap := map[string]*Host{\n\t\t\"host1.example.com\": {Echo: echo.New()},\n\t\t\"host2.example.com\": {Echo: echo.New()},\n\t}\n\n\tfor hostname, host := range hostMap {\n\t\th := host.Echo\n\t\th.Use(middleware.Logger())\n\t\th.Use(middleware.Recover())\n\n\t\th.Any(\"/*\", func(c echo.Context) error {\n\t\t\treq := c.Request()\n\t\t\tres := c.Response()\n\t\t\thost.Echo.ServeHTTP(res, req)\n\t\t\treturn nil\n\t\t})\n\n\t\te.Any(\"/*\", func(c echo.Context) error {\n\t\t\treq := c.Request()\n\t\t\tres := c.Response()\n\t\t\tif h, ok := hostMap[req.Host]; ok {\n\t\t\t\th.ServeHTTP(res, req)\n\t\t\t} else {\n\t\t\t\thttp.Error(res, \"Host not found\", http.StatusNotFound)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\n\te.Logger.Fatal(e.Start(\":8080\"))\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various API endpoints for a Vault management system, including authentication, token management, secret management, and more.\n\nFunction Description: The StartListener function initializes and starts an Echo HTTP server with configured routes and middleware. It sets up various API endpoints for Vault operations, applies middleware for logging, recovery, and request handling, and serves static assets if provided. The server can be started with or without TLS based on configuration.\n\nInput:\n- listener: config.ListenerConfig - Configuration for the server listener including address and TLS settings\n- assets: *rice.Box - Optional box containing static assets to be served by the server\n\nOutput: None (the function starts the server which runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\t\"log\"\n\n\t\"github.com/caiyeon/goldfish/config\"\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\te        *echo.Echo\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te = echo.New()\n\te.HideBanner = true\n\te.Server.ReadTimeout = 10 * time.Second\n\te.Server.WriteTimeout = 2 * time.Minute\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.BodyLimit(\"32M\"))\n\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\tLevel: 5,\n\t}))\n\n\te.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\tc.Response().Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\tif assets != nil {\n\t\tassetHandler := http.FileServer(assets.HTTPBox())\n\t\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\t\te.GET(\"/assets/css/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/js/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/fonts/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/img/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t}\n\n\te.GET(\"/v1/health\", handlers.Health())\n\te.GET(\"/v1/vaulthealth\", handlers.VaultHealth())\n\te.POST(\"/v1/bootstrap\", handlers.Bootstrap())\n\n\te.POST(\"/v1/login\", handlers.Login())\n\te.POST(\"/v1/login/renew-self\", handlers.RenewSelf())\n\n\te.GET(\"/v1/token/accessors\", handlers.GetTokenAccessors())\n\te.POST(\"/v1/token/lookup-accessor\", handlers.LookupTokenByAccessor())\n\te.POST(\"/v1/token/revoke-accessor\", handlers.RevokeTokenByAccessor())\n\te.POST(\"/v1/token/revoke-self\", handlers.RevokeSelf())\n\te.POST(\"/v1/token/create\", handlers.CreateToken())\n\te.GET(\"/v1/token/listroles\", handlers.ListRoles())\n\te.GET(\"/v1/token/role\", handlers.GetRole())\n\n\te.GET(\"/v1/userpass/users\", handlers.GetUserpassUsers())\n\te.POST(\"/v1/userpass/delete\", handlers.DeleteUserpassUser())\n\n\te.GET(\"/v1/approle/roles\", handlers.GetApproleRoles())\n\te.POST(\"/v1/approle/delete\", handlers.DeleteApproleRole())\n\n\te.GET(\"/v1/ldap/groups\", handlers.GetLDAPGroups())\n\te.GET(\"/v1/ldap/users\", handlers.GetLDAPUsers())\n\n\te.GET(\"/v1/policy\", handlers.GetPolicy())\n\te.DELETE(\"/v1/policy\", handlers.DeletePolicy())\n\te.GET(\"/v1/policy-capabilities\", handlers.PolicyCapabilities())\n\n\te.GET(\"/v1/request\", handlers.GetRequest())\n\te.POST(\"/v1/request/add\", handlers.AddRequest())\n\te.POST(\"/v1/request/approve\", handlers.ApproveRequest())\n\te.DELETE(\"/v1/request/reject\", handlers.RejectRequest())\n\n\te.GET(\"/v1/transit\", handlers.TransitInfo())\n\te.POST(\"/v1/transit/encrypt\", handlers.EncryptString())\n\te.POST(\"/v1/transit/decrypt\", handlers.DecryptString())\n\n\te.GET(\"/v1/mount\", handlers.GetMount())\n\te.POST(\"/v1/mount\", handlers.ConfigMount())\n\n\te.GET(\"/v1/secrets\", handlers.GetSecrets())\n\te.POST(\"/v1/secrets\", handlers.PostSecrets())\n\te.DELETE(\"/v1/secrets\", handlers.DeleteSecrets())\n\n\te.GET(\"/v1/bulletins\", handlers.GetBulletins())\n\n\te.POST(\"/v1/wrapping/wrap\", handlers.WrapHandler())\n\te.POST(\"/v1/wrapping/unwrap\", handlers.UnwrapHandler())\n\n\tif listener.Tls_disable {\n\t\te.Logger.Fatal(e.Start(listener.Address))\n\t\treturn\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/GeertJohan/go.rice\"\n)\n\ntype VaultAPI struct {\n\t// contains secret, auth, token handlers etc.\n}\n\nfunc (api *VaultAPI) SetupRoutes(e *echo.Echo) {\n\t// Authentication routes\n\te.POST(\"/v1/auth/login\", api.LoginHandler)\n\te.POST(\"/v1/auth/logout\", api.LogoutHandler)\n\n\t// Token management routes\n\te.POST(\"/v1/tokens/create\", api.CreateTokenHandler)\n\te.DELETE(\"/v1/tokens/revoke/:token_id\", api.RevokeTokenHandler)\n\te.GET(\"/v1/tokens/lookup/:token_id\", api.LookupTokenHandler)\n\n\t// Secret management routes\n\te.POST(\"/v1/secrets/write/:path\", api.WriteSecretHandler)\n\te.GET(\"/v1/secrets/read/:path\", api.ReadSecretHandler)\n\te.DELETE(\"/v1/secrets/delete/:path\", api.DeleteSecretHandler)\n\n\t// Other Vault-related API endpoints...\n}\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te := echo.New()\n\n\t// Middleware setup\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.RequestID())\n\n\t// Create vault API and register routes\n\tvaultAPI := &VaultAPI{}\n\tvaultAPI.SetupRoutes(e)\n\n\t// Serve static assets if provided\n\tif assets != nil {\n\t\te.StaticFS(\"/\", assets.HTTPBox())\n\t}\n\n\t// Start server with or without TLS\n\tif listener.TLS.Enabled {\n\t\te.Logger.Fatal(e.StartTLS(listener.Address, listener.TLS.CertFile, listener.TLS.KeyFile))\n\t} else {\n\t\te.Logger.Fatal(e.Start(listener.Address))\n\t}\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a function to retrieve metadata and ETag from Google Compute Engine (GCE) metadata server using a custom HTTP client with specific timeout configurations.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the GCE metadata server to fetch metadata value and its associated ETag. It uses a pre-configured HTTP client with custom timeout settings and adds required headers to the request. The function handles various response scenarios including not found errors and non-200 status codes.\n\nInput:\n- suffix [string]: The metadata path suffix to append to the base metadata URL\n\nOutput:\n- value [string]: The retrieved metadata value\n- etag [string]: The ETag header value from the response\n- err [error]: Error object if any error occurs during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/cloud/internal\"\n)\n\nvar metaClient = &http.Client{\n\tTransport: &internal.Transport{\n\t\tBase: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   750 * time.Millisecond,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 750 * time.Millisecond,\n\t\t},\n\t},\n}\n\nfunc getETag(suffix string) (value, etag string, err error) {\n\thost := os.Getenv(\"GCE_METADATA_HOST\")\n\tif host == \"\" {\n\t\thost = \"169.254.169.254\"\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\tres, err := metaClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar metadataBaseURL = \"http://metadata.google.internal/computeMetadata/v1/\"\n\nfunc getETag(suffix string) (value string, etag string, err error) {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy: nil,\n\t\t\tDialContext: (&net.Dialer{\n\t\t\t\tTimeout:   10 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).DialContext,\n\t\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t},\n\t\tTimeout: 10 * time.Second,\n\t}\n\n\turl := metadataBaseURL + suffix\n\treq, _ := http.NewRequestWithContext(context.Background(), \"GET\", url, nil)\n\treq.Header.Set(\"Metadata-token\", \"go-metadata-client\")\n\treq.Header.Set(\"Metadata-flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"HTTP request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", fmt.Errorf(\"metadata not found: %s\", suffix)\n\t} else if resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvalue = \"\"\n\tetag = resp.Header.Get(\"Etag\")\n\n\treturn value, etag, nil\n}"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using Gin framework with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a simple GET route handler, configures automatic TLS certificate management using autocert, and starts the HTTPS server. The server will automatically obtain and renew TLS certificates from Let's Encrypt for specified domains.\n\nInput: None (The function takes no parameters as all configurations are internally defined)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely. It will log.Fatal if there's an error starting the server.)\n\nNote: The function demonstrates a complete setup for a production-ready HTTPS server with automatic certificate management. The domains and cache directory are hardcoded in this example but could be parameterized in a real implementation.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tlog.Fatal(autotls.RunWithManager(r, m))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc runSecureServer() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, HTTPS world!\")\n\t})\n\n\tcertManager := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example.com\", \"www.example.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:      \":443\",\n\t\tHandler:   r,\n\t\tTLSConfig: certManager.TLSConfig(),\n\t}\n\n\tlog.Println(\"Starting secure server on :443\")\n\tif err := server.ListenAndServeTLS(\"\", \"\"); err != nil {\n\t\tlog.Fatal(\"ListenAndServeTLS error: \", err)\n\t}\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a Go struct representing a Docker registry repository client that can interact with a Docker registry API to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct represents a client for interacting with a Docker registry repository. It provides methods to access blob storage, manifests, and tags through the Docker Registry HTTP API V2.\n\nFields:\n- client: *http.Client - Custom HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nAdditional Struct: `tags` - Handles tag operations for a Docker repository\n\nFields:\n- client: *http.Client - HTTP client for making requests\n- ub: *v2.URLBuilder - URL builder for API endpoints\n- name: reference.Named - Named reference to the repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves descriptor information for a specific tag, first trying HEAD request and falling back to GET if needed",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package docker\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/reference\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn &blobStore{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifestService{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\turl, err := t.ub.BuildTagURL(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\treq, err := http.NewRequest(\"HEAD\", url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err := t.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\tdesc := distribution.Descriptor{}\n\t\t// Extract descriptor info from response headers\n\t\treturn desc, nil\n\t}\n\n\t// Fallback to GET request\n\treq, err = http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tresp, err = t.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn distribution.Descriptor{}, &distribution.ErrNotFound{}\n\t}\n\n\t// Parse descriptor from response body\n\tdesc := distribution.Descriptor{}\n\treturn desc, nil\n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a reverse proxy server using Gin framework in Go that forwards incoming HTTP requests to a load-balanced backend server and returns the response to the client.\n\nFunction Description: The main function initializes a Gin HTTP server that acts as a reverse proxy. It handles incoming GET requests, forwards them to a backend server obtained from a load balancer, and returns the backend's response to the client while preserving all headers.\n\nInput:\n- Path parameter: \":path\" (string) - The path component of the URL to be forwarded to the backend server\n- HTTP request headers and body (automatically handled by Gin context)\n\nOutput:\n- HTTP response with:\n  - Status code from backend server (or 500 if proxy fails)\n  - Headers from backend server\n  - Body content from backend server\n- Error logs if any step in the proxying process fails\n\nThe function uses the Gin context (c *gin.Context) to:\n1. Extract the original request\n2. Parse the load-balanced backend address\n3. Modify the request URL to point to the backend\n4. Use HTTP transport to forward the request\n5. Copy backend response headers to client response\n6. Stream the backend response body to the client",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\tproxy, err := url.Parse(getLoadBalanceAddr())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in parse addr: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = proxy.Scheme\n\t\treq.URL.Host = proxy.Host\n\n\t\ttransport := http.DefaultTransport\n\t\tresp, err := transport.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in roundtrip: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\n\t\tfor k, vv := range resp.Header {\n\t\t\tfor _, v := range vv {\n\t\t\t\tc.Header(k, v)\n\t\t\t}\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbufio.NewReader(resp.Body).WriteTo(c.Writer)\n\t\treturn\n\t})\n\n\tif err := r.Run(ReverseServerAddr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar backendServers = []string{\n\t\"http://backend1.example.com\",\n\t\"http://backend2.example.com\",\n\t\"http://backend3.example.com\",\n}\n\nvar currentBackend int\n\nfunc getLoadBalancedBackend() string {\n\tcurrentBackend = (currentBackend + 1) % len(backendServers)\n\treturn backendServers[currentBackend]\n}\n\nfunc proxyHandler(c *gin.Context) {\n\t// Get the original request\n\treq := c.Request\n\n\t// Get a backend server from the load balancer\n\tbackendURL := getLoadBalancedBackend()\n\n\t// Parse the backend URL\n\turl, err := url.Parse(backendURL)\n\tif err != nil {\n\t\tlog.Printf(\"Error parsing backend URL: %v\", err)\n\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to parse backend URL\"})\n\t\treturn\n\t}\n\n\t// Ensure path is correctly set\n\tpath := c.Param(\"path\")\n\tif !strings.HasPrefix(path, \"/\") {\n\t\tpath = \"/\" + path\n\t}\n\turl.Path = path\n\n\t// Modify the request to point to the backend\n\treq.URL = url\n\treq.Host = url.Host\n\n\t// Create a transport to forward the request\n\ttransport := http.DefaultTransport\n\tresp, err := transport.RoundTrip(req)\n\tif err != nil {\n\t\tlog.Printf(\"Error proxying request: %v\", err)\n\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Request proxying failed\"})\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Copy headers from backend response to client response\n\tfor k, vv := range resp.Header {\n\t\tfor _, v := range vv {\n\t\t\tc.Writer.Header().Add(k, v)\n\t\t}\n\t}\n\n\t// Stream the backend response body to the client\n\tc.Writer.WriteHeader(resp.StatusCode)\n\thttputil.NewServerConn(resp.Body, nil).CopyServerConnTo(c.Writer)\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.Any(\"/:path/*any\", func(c *gin.Context) {\n\t\tproxyHandler(c)\n\t})\n\n\tlog.Println(\"Starting reverse proxy on :8080\")\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that retrieves metadata from a metadata server using a custom HTTP client, with support for ETag headers and error handling.\n\nFunction Description: The function `getETag` makes an HTTP GET request to a metadata server endpoint, using a custom HTTP client with specific timeout configurations. It handles the response by checking status codes, reading the response body, and extracting both the content and ETag header. The function includes error handling for various scenarios including connection errors, missing resources, and non-200 status codes.\n\nInput:\n- client *http.Client: A custom HTTP client with configured timeouts for the request\n- suffix string: The path suffix to append to the base metadata URL\n\nOutput:\n- value string: The content of the response body as a string\n- etag string: The ETag header value from the response\n- err error: An error object if any step fails, nil on success",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getETag(client *http.Client, suffix string) (value string, etag string, err error) {\n\turl := \"http://metadata.google.internal/computeMetadata/v1/\" + suffix\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\treq.Header.Set(\"Metadata-token\", \"goog\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\tetag = resp.Header.Get(\"Etag\")\n\tif etag == \"\" {\n\t\treturn \"\", \"\", fmt.Errorf(\"missing ETag header in response\")\n\t}\n\n\treturn string(body), etag, nil\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, with endpoints for basic operations including ping, info retrieval, and counter manipulation with thread-safe increment/reset functionality.\n\nFunction Description: The Run function initializes a Gin HTTP server with four API endpoints under the \"/api/v1\" route group. It handles concurrent counter operations safely using mutex locks and logs requests using klog. The server runs on the specified address from the Options parameter.\n\nInput: \n- op *Options: A pointer to an Options struct containing the ListenAddr field specifying the server's listening address (e.g., \":8080\")\n\nOutput:\n- error: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nStruct Description: (Not applicable as the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\nvar (\n\tCount int\n\tMutex sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.Default()\n\n\tapiv1 := r.Group(\"/api/v1\")\n\t{\n\t\tapiv1.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\")\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"pong\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"app3\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.PUT(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount += 1\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app3: %d\", Count),\n\t\t\t})\n\t\t})\n\n\t\tapiv1.DELETE(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount = 0\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app1: %d\", Count),\n\t\t\t})\n\t\t})\n\t}\n\n\treturn r.Run(op.ListenAddr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\ntype Options struct {\n\tListenAddr string\n}\n\nvar (\n\tcounter int64\n\tmutex   sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.New()\n\n\tapi := r.Group(\"/api/v1\")\n\t{\n\t\tapi.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Ping request received\")\n\t\t\tc.String(http.StatusOK, \"pong\")\n\t\t})\n\n\t\tapi.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Info request received\")\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"version\":  \"1.0.0\",\n\t\t\t\t\"status\":   \"active\",\n\t\t\t\t\"counter\":  getCounter(),\n\t\t\t\t\"endpoint\": \"/api/v1\",\n\t\t\t})\n\t\t})\n\n\t\tapi.POST(\"/counter/inc\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Increment request received\")\n\t\t\tincCounter()\n\t\t\tc.JSON(http.StatusOK, gin.H{\"counter\": getCounter()})\n\t\t})\n\n\t\tapi.POST(\"/counter/reset\", func(c *gin.Context) {\n\t\t\tklog.Info(\"Reset request received\")\n\t\t\tresetCounter()\n\t\t\tc.JSON(http.StatusOK, gin.H{\"counter\": getCounter()})\n\t\t})\n\t}\n\n\tklog.Infof(\"Starting server on %s\", op.ListenAddr)\n\treturn r.Run(op.ListenAddr)\n}\n\nfunc incCounter() {\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\tcounter++\n}\n\nfunc resetCounter() {\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\tcounter = 0\n}\n\nfunc getCounter() int64 {\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\treturn counter\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Go struct that represents a main server application using the Gin web framework, with capabilities for logging configuration, route grouping, and JWT authentication middleware integration.\n\nStruct Description: The Main struct represents a web server application that uses Gin as its web framework. It handles server initialization, route configuration with JWT authentication for protected routes, and serves as the entry point for the application.\n\nFields:\nrouter: *gin.Engine - The Gin engine instance that handles all HTTP routing and middleware\n\nMethods:\ninitServer: () -> error - Initializes the Gin server with configured logging settings (file and console logging based on configuration). Returns error if initialization fails.\nmain: () - Entry point of the application that creates the Main instance, initializes the server, sets up route handlers with JWT authentication for protected routes, and starts the server on the configured port.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/jwt\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\tvar err error\n\n\tif common.Config.EnableGinFileLog {\n\t\tf, _ := os.Create(\"logs/gin.log\")\n\t\tif common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter(os.Stdout, f)\n\t\t} else {\n\t\t\tgin.DefaultWriter = io.MultiWriter(f)\n\t\t}\n\t} else {\n\t\tif !common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter()\n\t\t}\n\t}\n\n\tm.router = gin.Default()\n\n\treturn nil\n}\n\nfunc main() {\n\tm := Main{}\n\n\tif m.initServer() != nil {\n\t\treturn\n\t}\n\n\tc := controllers.User{}\n\tv1 := m.router.Group(\"/api/v1\")\n\t{\n\t\tadmin := v1.Group(\"/admin\")\n\t\t{\n\t\t\tadmin.POST(\"/auth\", c.Authenticate)\n\t\t}\n\n\t\tuser := v1.Group(\"/users\")\n\n\t\tuser.Use(jwt.Auth(common.Config.JwtSecretPassword))\n\t\t{\n\t\t\tuser.POST(\"\", c.AddUser)\n\t\t\tuser.GET(\"/list\", c.ListUsers)\n\t\t\tuser.GET(\"detail/:id\", c.GetUserByID)\n\t\t\tuser.GET(\"/\", c.GetUserByParams)\n\t\t\tuser.DELETE(\":id\", c.DeleteUserByID)\n\t\t\tuser.PATCH(\"\", c.UpdateUser)\n\t\t}\n\t}\n\n\tm.router.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tm.router.Run(common.Config.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\t// Configure logging settings\n\tgin.SetMode(gin.ReleaseMode)\n\n\t// Initialize Gin router\n\tm.router = gin.New()\n\tm.router.Use(gin.Logger())\n\tm.router.Use(gin.Recovery())\n\n\t// TODO: Add file logging if configured\n\n\treturn nil\n}\n\nfunc main() {\n\tapp := &Main{}\n\n\tif err := app.initServer(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Setup route groups and JWT middleware\n\tauthMiddleware := setupJWTMiddleware()\n\n\tapi := app.router.Group(\"/api\")\n\t{\n\t\tauth := api.Group(\"/auth\")\n\t\t{\n\t\t\tauth.POST(\"/login\", loginHandler)\n\t\t}\n\n\t\tprotected := api.Group(\"/protected\")\n\t\tprotected.Use(authMiddleware.MiddlewareFunc())\n\t\t{\n\t\t\tprotected.GET(\"/data\", protectedDataHandler)\n\t\t}\n\t}\n\n\t// Start server on configured port\n\tapp.router.Run(\":8080\")\n}\n\n// Placeholder for JWT middleware setup\nfunc setupJWTMiddleware() *jwt.GinJWTMiddleware {\n\t// Implementation would go here\n\treturn nil\n}\n\n// Placeholder handlers\nfunc loginHandler(c *gin.Context) {}\nfunc protectedDataHandler(c *gin.Context) {}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with a single route handler that responds to GET requests.\n\nFunction Description: The function initializes a default Gin engine with built-in middleware (Logger and Recovery), registers a GET route handler at the path \"/hello\" that responds with a plain text message, and starts the server on port 80. The function is designed to be the main entry point of a Go application using the Gin web framework.\n\nInput: \n- ctx *app.Context: A context object from the eggos framework (used for logging in this example)\n\nOutput: \n- error: Returns any error that occurs during server execution, otherwise nil when the server is properly shut down",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/icexin/eggos/app\"\n)\nfunc main(ctx *app.Context) error {\n\tr := gin.Default()\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"hello from eggos\")\n\t})\n\tctx.Printf(\"run gin server on :80\")\n\treturn r.Run(\":80\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc RunServer(ctx *app.Context) error {\n\tr := gin.Default()\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello from Gin!\")\n\t})\n\tsrv := &http.Server{\n\t\tAddr:    \":80\",\n\t\tHandler: r,\n\t}\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tctx.Logger().Error(\"Failed to start server: %v\", err)\n\t\t}\n\t}()\n\t<-ctx.Done()\n\tif err := srv.Shutdown(context.Background()); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Implement a rate-limited HTTP server using the Gin framework in Go, which includes middleware for request rate limiting and a simple endpoint to test the rate limiting functionality.\n\nFunction Description: The `ginRun` function initializes and starts a Gin HTTP server with rate limiting capabilities. It sets up a leaky bucket rate limiter middleware and provides a single endpoint (\"/rate\") for testing the rate limiting. The server runs on port 8080.\n\nInput: \n- `rps` (int): The maximum number of requests per second that the server will allow (rate limit value)\n\nOutput: \n- None (The function starts an HTTP server that runs indefinitely until interrupted)\n- Logs the current rate limit setting to stdout\n- Responds to HTTP requests on the \"/rate\" endpoint with a JSON message",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc ginRun(rps int) {\n\tlimit = ratelimit.New(rps)\n\n\tapp := gin.Default()\n\tapp.Use(leakBucket())\n\n\tapp.GET(\"/rate\", func(ctx *gin.Context) {\n\t\tctx.JSON(200, \"rate limiting test\")\n\t})\n\n\tlog.Printf(color.CyanString(\"Current Rate Limit: %v requests/s\", rps))\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/time/rate\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc ginRun(rps int) {\n\tr := gin.Default()\n\n\tlimiter := rate.NewLimiter(rate.Limit(rps), rps)\n\n\tfmt.Printf(\"Starting server with rate limit: %d RPS\\n\", rps)\n\n\tr.Use(func(c *gin.Context) {\n\t\tif !limiter.Allow() {\n\t\t\tc.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{\"error\": \"rate limit exceeded\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t})\n\n\tr.GET(\"/rate\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Rate limited request processed successfully\"})\n\t})\n\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: r,\n\t}\n\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tfmt.Printf(\"Failed to start server: %v\\n\", err)\n\t\t}\n\t}()\n\n\tselect {}\n}"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a function to retrieve user information from Facebook's Graph API using an access token, with proper error handling and response validation.\n\nFunction Description: The function GetUserInfo makes an authenticated GET request to Facebook's Graph API to fetch user information (name, email, ID, and picture) using the provided access token. It handles the HTTP request/response cycle, validates the response, and parses the JSON data into a structured format.\n\nInput:\n- token: TokenInfo - A struct containing the Facebook access token (token.AccessToken is used)\n\nOutput:\n- model.UserInfo - A struct containing the user's information (ID, picture URL, name, email, and origin)\n- string - The raw JSON response body from the API\n- error - Any error that occurred during the API request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/tarent/loginsrv/model\"\n)\n\nvar facebookAPI = \"https://graph.facebook.com/v2.12\"\n\nfunc (p Provider) GetUserInfo(token TokenInfo) (model.UserInfo, string, error) {\n\tfu := facebookUser{}\n\n\turl := fmt.Sprintf(\"%v/me?access_token=%v&fields=name,email,id,picture\", facebookAPI, token.AccessToken)\n\n\tclient := &http.Client{}\n\tcontentType := \"application/json\"\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Accept\", contentType)\n\tresp, err := client.Do(req)\n\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif !strings.Contains(resp.Header.Get(\"Content-Type\"), contentType) {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"wrong content-type on facebook get user info: %v\", resp.Header.Get(\"Content-Type\"))\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"got http status %v on facebook get user info\", resp.StatusCode)\n\t}\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error reading facebook get user info: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, &fu)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error parsing facebook get user info: %v\", err)\n\t}\n\n\treturn model.UserInfo{\n\t\tSub:     fu.UserID,\n\t\tPicture: fu.Picture.Data.URL,\n\t\tName:    fu.Name,\n\t\tEmail:   fu.Email,\n\t\tOrigin:  \"facebook\",\n\t}, string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package facebook\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype TokenInfo struct {\n\tAccessToken string `json:\"access_token\"`\n}\n\ntype UserInfo struct {\n\tID      string `json:\"id\"`\n\tPicture string `json:\"picture\"`\n\tName  string `json:\"name\"`\n\tEmail string `json:\"email\"`\n\tOrigin string `json:\"-\"`\n}\n\nfunc GetUserInfo(token TokenInfo) (UserInfo, string, error) {\n\turl := \"https://graph.facebook.com/me?fields=id,name,email,picture&access_token=\" + token.AccessToken\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn UserInfo{}, string(body), fmt.Errorf(\"API request failed with status %d: %s\", resp.StatusCode, body)\n\t}\n\n\tvar userInfo UserInfo\n\terr = json.Unmarshal(body, &userInfo)\n\tif err != nil {\n\t\treturn UserInfo{}, string(body), err\n\t}\n\n\tif userInfo.ID == \"\" {\n\t\treturn UserInfo{}, string(body), fmt.Errorf(\"invalid user info response: missing ID\")\n\t}\n\n\tuserInfo.Origin = \"facebook\"\n\n\treturn userInfo, string(body), nil\n}"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles file uploads, saves them to a specified directory, and returns the file URL.\n\nFunction Description: The main function initializes a Gin HTTP server with file upload capabilities. It sets up a static file server for serving uploaded files and implements a POST endpoint for uploading files. The server saves uploaded files with unique names and returns their access URLs.\n\nInput: \n- HTTP POST request with multipart/form-data containing a file field named \"file\"\n- File content in the request body\n\nOutput:\n- JSON response containing:\n  - Status code (0 for success, non-zero for errors)\n  - Message describing the operation result\n  - Data object containing the URL to access the uploaded file (on success)\n  OR\n  - Error message (on failure)\n\nThe server runs on port 8085 and serves static files from \"/root/file/\" directory. Uploaded files are saved with names formatted as \"timestamp-randomstring.extension\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"gim/pkg/util\"\n)\n\nconst baseUrl = \"http://111.229.238.28:8085/file/\"\n\ntype Response struct {\n\tCode    int         `json:\"code\"`\n\tMessage string      `json:\"message\"`\n\tData    interface{} `json:\"data\"`\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/file\", \"/root/file\")\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfilenames := strings.Split(file.Filename, \".\")\n\t\tname := strconv.FormatInt(time.Now().UnixNano(), 10) + \"-\" + util.RandString(30) + \".\" + filenames[len(filenames)-1]\n\t\tfilePath := \"/root/file/\" + name\n\t\terr = c.SaveUploadedFile(file, filePath)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, Response{\n\t\t\tCode:    0,\n\t\t\tMessage: \"success\",\n\t\t\tData:    map[string]string{\"url\": baseUrl + name},\n\t\t})\n\t})\n\terr := router.Run(\":8085\")\n\tif err != nil {\n\t\tlogger.Logger.Error(\"Run error\", zap.Error(err))\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nconst (\n\tuploadDir = \"/root/file/\"\n\tport      = \":8085\"\n)\n\nfunc generateUniqueFilename(originalName string) string {\n\text := filepath.Ext(originalName)\n\ttimestamp := time.Now().UnixNano()\n\trandomString := fmt.Sprintf(\"%d-%d\", timestamp, rand.Intn(1000))\n\treturn fmt.Sprintf(\"%s%s\", randomString, ext)\n}\n\nfunc uploadFile(c *gin.Context) {\n\tfile, header, err := c.Request.FormFile(\"file\")\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\"code\":    1,\n\t\t\t\"message\": \"Error retrieving the file\",\n\t\t})\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfilename := generateUniqueFilename(header.Filename)\n\tdst := filepath.Join(uploadDir, filename)\n\n\tif err := c.SaveUploadedFile(header, dst); err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\"code\":    2,\n\t\t\t\"message\": \"Unable to save the file\",\n\t\t})\n\t\treturn\n\t}\n\n\tfileURL := fmt.Sprintf(\"http://localhost:%s/%s\", port, filename)\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"code\":    0,\n\t\t\"message\": \"File uploaded successfully\",\n\t\t\"data\": gin.H{\n\t\t\t\"url\": fileURL,\n\t\t},\n\t})\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\t_, err := os.Stat(uploadDir)\n\tif os.IsNotExist(err) {\n\t\tos.MkdirAll(uploadDir, os.ModePerm)\n\t}\n\n\tr.Static(\"/\", uploadDir)\n\tr.POST(\"/upload\", uploadFile)\n\n\tr.Run(port)\n}"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a default Gin engine with logger and recovery middleware, registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- domains: []string - A slice of domain names for which TLS certificates should be obtained (e.g., [\"example1.com\", \"example2.com\"])\n\nOutput: \n- error - Returns an error if the server fails to start, otherwise runs indefinitely (the function will log.Fatal on error)\n\nNote: The function does not explicitly return but will log.Fatal if the server fails to start. The server runs indefinitely when successful.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/autotls\"\n)\n\nfunc runSecureServer(domains []string) error {\n\tr := gin.Default()\n\tr.Use(gin.Recovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\ts := autotls.Server{\n\t\tAddr:      \":443\",\n\t\tHandler:   r,\n\t\tAutoTLSConfig: autotls.Config{\n\t\t\tHosts: domains,\n\t\t},\n\t}\n\n\treturn s.ListenAndServeTLS()\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Go struct that handles HTTP requests to a metadata service with configurable endpoints, versioning, and resource paths. The struct should support request building, execution, and response handling with retry logic and mock capabilities for testing.\n\nStruct Description: The MetaData struct provides a client for interacting with a metadata service API. It supports building requests with versioning, resource types, and sub-resources, executing requests with retry logic, and decoding responses. It includes mock functionality for testing.\n\nFields:\n- mock: requestMock - A function type for mocking requests during testing\n- client: *http.Client - The HTTP client used to execute requests\n\nMethods:\n- NewMetaData(*http.Client) *MetaData - Constructor that initializes a new MetaData instance with an optional custom HTTP client\n- New() *MetaDataRequest - Creates a new request builder instance\n\nThe MetaDataRequest nested struct handles individual request configuration and execution:\n\nFields:\n- version: string - API version to use (defaults to \"latest\")\n- resourceType: string - Type of resource being accessed (defaults to \"meta-data\")\n- resource: string - Main resource path (required)\n- subResource: string - Optional sub-resource path\n- client: *http.Client - HTTP client for request execution\n- sendRequest: requestMock - Optional mock function for testing\n\nMethods:\n- Version(string) IMetaDataRequest - Sets the API version for the request\n- ResourceType(string) IMetaDataRequest - Sets the resource type for the request\n- Resource(string) IMetaDataRequest - Sets the main resource path\n- SubResource(string) IMetaDataRequest - Sets an optional sub-resource path\n- Url() (string, error) - Constructs the full request URL from components\n- Do(interface{}) error - Executes the request and decodes the response into the provided interface\n- send() (string, error) - Internal method that performs the actual HTTP request\n- Decode(string, interface{}) error - Handles response decoding (implementation not shown in reference)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"os\"\n)\n\ntype MetaData struct {\n\tmock requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tclient:      m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype requestMock func(resource string) (string, error)\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest requestMock\n}\n\nfunc (vpc *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tvpc.version = version\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) ResourceType(rtype string) IMetaDataRequest {\n\tvpc.resourceType = rtype\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tvpc.resource = resource\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) SubResource(sub string) IMetaDataRequest {\n\tvpc.subResource = sub\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Url() (string, error) {\n\tif vpc.version == \"\" {\n\t\tvpc.version = \"latest\"\n\t}\n\tif vpc.resourceType == \"\" {\n\t\tvpc.resourceType = \"meta-data\"\n\t}\n\tif vpc.resource == \"\" {\n\t\treturn \"\", errors.New(\"the resource you want to visit must not be nil!\")\n\t}\n\tendpoint := os.Getenv(\"METADATA_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = \"http://100.100.100.200\"\n\t}\n\tr := fmt.Sprintf(\"%s/%s/%s/%s\", endpoint, vpc.version, vpc.resourceType, vpc.resource)\n\tif vpc.subResource == \"\" {\n\t\treturn r, nil\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", r, vpc.subResource), nil\n}\n\nfunc (vpc *MetaDataRequest) Do(api interface{}) (err error) {\n\tvar res = \"\"\n\tfor r := retry.Start(); r.Next(); {\n\t\tif vpc.sendRequest != nil {\n\t\t\tres, err = vpc.sendRequest(vpc.resource)\n\t\t} else {\n\t\t\tres, err = vpc.send()\n\t\t}\n\t\tif !shouldRetry(err) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn vpc.Decode(res, api)\n}\n\nfunc (vpc *MetaDataRequest) send() (string, error) {\n\turl, err := vpc.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\trequ, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := vpc.client.Do(requ)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", fmt.Errorf(\"Aliyun Metadata API Error: Status Code: %d\", resp.StatusCode)\n\t}\n\tdefer resp.Body.Close()\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package metadata\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype requestMock func(string) (string, error)\n\ntype MetaData struct {\n\tmock  requestMock\n\tclient *http.Client\n}\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest  requestMock\n}\n\ntype IMetaDataRequest interface {\n\tVersion(string) IMetaDataRequest\n\tResourceType(string) IMetaDataRequest\n\tResource(string) IMetaDataRequest\n\tSubResource(string) IMetaDataRequest\n\tUrl() (string, error)\n\tDo(interface{}) error\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = http.DefaultClient\n\t}\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tversion:      \"latest\",\n\t\tresourceType: \"meta-data\",\n\t\tclient:       m.client,\n\t\tsendRequest:  m.mock,\n\t}\n}\n\nfunc (r *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tr.version = version\n\treturn r\n}\n\nfunc (r *MetaDataRequest) ResourceType(resourceType string) IMetaDataRequest {\n\tr.resourceType = resourceType\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tr.resource = resource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) SubResource(subResource string) IMetaDataRequest {\n\tr.subResource = subResource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Url() (string, error) {\n\tif r.resource == \"\" {\n\t\treturn \"\", fmt.Errorf(\"resource is required\")\n\t}\n\n\turl := fmt.Sprintf(\"/%s/%s\", r.version, r.resourceType)\n\turl = fmt.Sprintf(\"%s/%s\", url, r.resource)\n\n\tif r.subResource != \"\" {\n\t\turl = fmt.Sprintf(\"%s/%s\", url, r.subResource)\n\t}\n\n\treturn url, nil\n}\n\nfunc (r *MetaDataRequest) Do(out interface{}) error {\n\tresponse, err := r.send()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn r.Decode(response, out)\n}\n\nfunc (r *MetaDataRequest) send() (string, error) {\n\tif r.sendRequest != nil {\n\t\treturn r.sendRequest(r.version)\n\t}\n\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tretryClient := &http.Client{\n\t\tTransport: r.client.Transport,\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\tif len(via) >= 10 {\n\t\t\t\treturn fmt.Errorf(\"too many redirects\")\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tvar resp *http.Response\n\tvar errRetry error\n\n\tfor i := 0; i < 3; i++ {\n\t\tresp, err = retryClient.Do(req)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\terrRetry = err\n\t\ttime.Sleep(2 << i * time.Second)\n\t}\n\n\tif err != nil {\n\t\treturn \"\", errRetry\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, body)\n\t}\n\n\treturn string(body), nil\n}\n\nfunc (r *MetaDataRequest) Decode(data string, out interface{}) error {\n\tswitch v := out.(type) {\n\tcase *string:\n\t\t*v = data\n\tcase *[]byte:\n\t\t*v = []byte(data)\n\tcase *map[string]interface{}:\n\t\tif err := json.Unmarshal([]byte(data), v); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\tif strings.TrimSpace(data) == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\tif err := json.Unmarshal([]byte(data), out); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Go function that handles file uploads along with form data using the Gin web framework. The function should process multipart form data, save uploaded files, and return a response indicating success or failure.\n\nFunction Description: The function is a Gin route handler that processes POST requests to the \"/upload\" endpoint. It handles multipart/form-data submissions containing both form fields (name and email) and file uploads. The function saves all uploaded files to the server and returns a success message with the count of uploaded files and the form field values, or an error message if the operation fails.\n\nInput: \n- Gin context object (c *gin.Context) containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - File uploads: \"files\" (multipart.FileHeader array)\n\nOutput:\n- On success: HTTP 200 status with success message (string)\n- On failure: HTTP 400 status with error message (string)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc handleFileUpload(c *gin.Context) {\n\tname := c.PostForm(\"name\")\n\temail := c.PostForm(\"email\")\n\n\tform, err := c.MultipartForm()\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(400, gin.H{\"error\": \"Failed to parse form data\"})\n\t\treturn\n\t}\n\n\tfiles := form.File[\"files\"]\n\n\tfor _, file := range files {\n\t\terr := c.SaveUploadedFile(file, \"./uploads/\"+file.Filename)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(400, gin.H{\"error\": \"Failed to save uploaded files\"})\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.JSON(200, gin.H{\n\t\t\"message\":       \"Successfully uploaded files\",\n\t\t\"total_files\":   len(files),\n\t\t\"name\":          name,\n\t\t\"email\":         email,\n\t\t\"uploaded_files\": files,\n\t})\n}"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Go function that implements a distributed transaction coordinator using HTTP communication between microservices. The function should handle transaction initiation, propagate transaction context, and coordinate between multiple services.\n\nFunction Description: The function serves as an HTTP handler for initiating a distributed transaction. It receives a transaction ID in the header, prepares transaction data for two different services (Account and Inventory), makes HTTP calls to these services, and handles their responses. The function ensures transaction context (xid) is propagated to all participating services.\n\nInput: \n- Gin context object (gin.Context) containing:\n  - HTTP request headers (including \"x_seata_xid\" for transaction ID)\n  - Request body (not used in this example, but could contain transaction details)\n\nOutput:\n- HTTP responses:\n  - 400 Bad Request with error details if any step fails\n  - Original service response if any service fails (non-200 status)\n  - Success response from the last service if all succeed (200 status)\n- Side effects: Makes HTTP calls to two different services with transaction data",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-a/begin\", func(context *gin.Context) {\n\t\txid := context.Request.Header.Get(\"x_seata_xid\")\n\t\taccount := &Account{\n\t\t\tID:     1000024549,\n\t\t\tAmount: 200,\n\t\t}\n\t\tinv := &Inventory{\n\t\t\tID:  1000000005,\n\t\t\tQty: 2,\n\t\t}\n\n\t\taccountReq, err := json.Marshal(account)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tinvReq, err := json.Marshal(inv)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1, err := http.NewRequest(\"POST\", \"http://localhost:2047/service-b/try\", bytes.NewBuffer(accountReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1.Header.Set(\"x_seata_xid\", xid)\n\n\t\treq2, err := http.NewRequest(\"POST\", \"http://localhost:2048/service-c/try\", bytes.NewBuffer(invReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq2.Header.Set(\"x_seata_xid\", xid)\n\n\t\tclient := &http.Client{}\n\t\tresult1, err := client.Do(req1)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result1.StatusCode != http.StatusOK {\n\t\t\tresult1.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\n\t\tresult2, err := client.Do(req2)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result2.StatusCode == http.StatusOK {\n\t\t\tresult2.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/opentracing/opentracing-go\"\n)\n\nfunc distributeTransaction(c *gin.Context) {\n\tvar (\n\t\terr           error\n\t\treqBody       []byte\n\t\taccountResp   *http.Response\n\t\tinventoryResp *http.Response\n\t)\n\n\t// Extract transaction ID from headers\n\txid := c.Request.Header.Get(\"x_seata_xid\")\n\tif xid == \"\" {\n\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"missing transaction ID in headers\"})\n\t\treturn\n\t}\n\n\t// Read request body if exists (optional for this example)\n\tif c.Request.Body != nil {\n\t\treqBody, err = io.ReadAll(c.Request.Body)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"failed to read request body\", \"details\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tdefer c.Request.Body.Close()\n\t}\n\n\t// Prepare HTTP client with context propagation\n\tclient := &http.Client{}\n\treqHeaders := map[string]string{\n\t\t\"xid\": xid,\n\t\t\"Content-Type\": \"application/json\",\n\t}\n\n\t// Start spans for distributed tracing\n\tspan := opentracing.GlobalTracer().StartSpan(\"distributed_transaction\")\n\tdefer span.Finish()\n\n\t// Call Account Service\n\taccountReq, _ := http.NewRequest(\"POST\", \"http://account-service/api/v1/prepare\", bytes.NewBuffer(reqBody))\n\tfor k, v := range reqHeaders {\n\t\taccountReq.Header.Set(k, v)\n\t}\n\topentracing.GlobalTracer().Inject(\n\t\tspan.Context(),\n\t\topentracing.HTTPHeaders,\n\t\topentracing.HTTPHeadersCarrier(accountReq.Header),\n\t)\n\n\taccountResp, err = client.Do(accountReq)\n\tif err != nil || accountResp.StatusCode != http.StatusOK {\n\t\thandleError(c, err, \"Account service failed\", accountResp)\n\t\treturn\n\t}\n\n\t// Call Inventory Service\n\tinventoryReq, _ := http.NewRequest(\"POST\", \"http://inventory-service/api/v1/prepare\", bytes.NewBuffer(reqBody))\n\tfor k, v := range reqHeaders {\n\t\tinventoryReq.Header.Set(k, v)\n\t}\n\topentracing.GlobalTracer().Inject(\n\t\tspan.Context(),\n\t\topentracing.HTTPHeaders,\n\t\topentracing.HTTPHeadersCarrier(inventoryReq.Header),\n\t)\n\n\tinventoryResp, err = client.Do(inventoryReq)\n\tif err != nil || inventoryResp.StatusCode != http.StatusOK {\n\t\thandleError(c, err, \"Inventory service failed\", inventoryResp)\n\t\treturn\n\t}\n\n\t// Commit phase\n\tcommitErr := commitTransaction(xid)\n\tif commitErr != nil {\n\t\t// Handle rollback or return error\n\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"transaction commit failed\", \"details\": commitErr.Error()})\n\t\treturn\n\t}\n\n\t// Return success response from last service\n\tc.Status(http.StatusOK)\n\tc.Writer.Write([]byte(\"Transaction completed successfully\"))\n}\n\nfunc handleError(c *gin.Context, err error, msg string, resp *http.Response) {\n\tif resp != nil {\n\t\tbodyBytes, _ := io.ReadAll(resp.Body)\n\t\tc.AbortWithStatusJSON(resp.StatusCode, gin.H{\n\t\t\t\"error\":   msg,\n\t\t\t\"details\": err.Error(),\n\t\t\t\"service_response\": string(bodyBytes),\n\t\t})\n\t\treturn\n\t}\n\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\n\t\t\"error\":   msg,\n\t\t\"details\": err.Error(),\n\t})\n}\n\nfunc commitTransaction(xid string) error {\n\t// Implement 2PC commit logic here\n\t// Send commit requests to all participating services\n\t// Handle confirmations and potential rollbacks\n\n\t// Placeholder implementation\n\treturn nil\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a function that demonstrates asynchronous message production to a Kafka topic using the Sarama library in Go. The function should continuously generate and send messages at regular intervals while handling both successful deliveries and errors.\n\nFunction Description: The SaramaProducer function initializes and manages an asynchronous Kafka producer. It configures the producer with specific settings, handles message delivery success/failure notifications in a separate goroutine, and continuously generates and sends messages to a specified Kafka topic. The function runs indefinitely until terminated.\n\nInput: None (The function takes no input parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function doesn't return any value but prints success/error messages to stdout)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc SaramaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tconfig.Producer.Retry.Max = 1000\n\tconfig.Version = sarama.V2_2_0_0\n\n\tproducer, e := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif e != nil {\n\t\tfmt.Println(e)\n\t\treturn\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func(p sarama.AsyncProducer) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase suc := <-p.Successes():\n\t\t\t\tfmt.Println(\"offset: \", suc.Offset, \"timestamp: \", suc.Timestamp.String(), \"partitions: \", suc.Partition)\n\t\t\tcase fail := <-p.Errors():\n\t\t\t\tfmt.Println(\"err: \", fail.Err)\n\t\t\t}\n\t\t}\n\t}(producer)\n\n\tvar value string\n\tfor i := 0; ; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\ttime11 := time.Now()\n\t\tvalue = \"this is a message 0606 \" + time11.Format(\"15:04:05\")\n\t\tmsg := &sarama.ProducerMessage{\n\t\t\tTopic: \"0606_test\",\n\t\t}\n\t\tmsg.Value = sarama.ByteEncoder(value)\n\t\tfmt.Println(value)\n\t\tproducer.Input() <- msg\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc SaramaProducer() {\n\tbrokers := []string{\"localhost:9092\"}\n\ttopic := \"test-topic\"\n\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Retry.Max = 5\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\n\tproducer, err := sarama.NewAsyncProducer(brokers, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start producer: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := producer.Close(); err != nil {\n\t\t\tlog.Printf(\"Failed to close producer: %v\", err)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase msg := <-producer.Successes():\n\t\t\t\tfmt.Printf(\"Message sent to topic %s: %s\\n\", msg.Topic, string(msg.Value))\n\t\t\tcase err := <-producer.Errors():\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Failed to send message: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\trand.Seed(time.Now().UnixNano())\n\tmessageCounter := 0\n\n\tticker := time.NewTicker(2 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tmsg := &sarama.ProducerMessage{\n\t\t\t\tTopic: topic,\n\t\t\t\tValue: sarama.StringEncoder(fmt.Sprintf(\"Message %d - %d\", messageCounter, rand.Intn(1000))),\n\t\t\t}\n\t\t\tproducer.Input() <- msg\n\t\t\tmessageCounter++\n\t\t}\n\t}\n}\n\nfunc main() {\n\tSaramaProducer()\n}"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.\n\nTask Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"testing\"\n)\n\nfunc TestKafkaSyncProducer(t *testing.T) {\n\tconf := sarama.NewConfig()\n\tconf.Producer.RequiredAcks = sarama.WaitForAll\n\tconf.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconf.Producer.Return.Successes = true\n\tconf.Producer.Return.Errors = true\n\tconf.Producer.Retry.Max = 1000\n\tconf.Version = sarama.V2_8_0_0\n\tproducer, err := sarama.NewSyncProducer([]string{\"172.12.12.165:9092\"}, conf)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer producer.Close()\n\tfmt.Println(producer.SendMessage(&sarama.ProducerMessage{\n\t\tTopic: \"gs_pay_transaction_topic\",\n\t\tValue: sarama.ByteEncoder(\"123123\"),\n\t}))\n\tselect {}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 123,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/segmentio/kafka-go\"\n)\n\nfunc sendKafkaMessage() {\n\t// Kafka broker and topic configuration\n\ttopic := \"example-topic\"\n\tbroker := \"localhost:9092\"\n\n\t// Create a new Kafka writer (synchronous producer)\n\twriter := kafka.NewWriter(kafka.WriterConfig{\n\t\tBrokers:  []string{broker},\n\t\tTopic:    topic,\n\t\tBalancer: &kafka.LeastBytes{},\n\t})\n\n\t// Ensure the writer is closed after use\n\tdefer func() {\n\t\terr := writer.Close()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to close writer: %v\\n\", err)\n\t\t}\n\t}()\n\n\t// Message to send\n\tmsg := kafka.Message{\n\t\tKey:   []byte(\"key\"),\n\t\tValue: []byte(\"Hello Kafka!\"),\n\t}\n\n\t// Send message synchronously\n\terr := writer.WriteMessages(nil, msg)\n\tif err != nil {\n\t\tfmt.Printf(\"Error sending message: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Retrieve the latest written message info\n\tpartition, offset, err := writer.PartitionOffset(topic, msg.Key)\n\tif err != nil {\n\t\tfmt.Printf(\"Error getting partition/offset: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Print result\n\tfmt.Printf(\"Message sent successfully. Partition: %d, Offset: %d\\n\", partition, offset)\n}\n\nfunc main() {\n\tsendKafkaMessage()\n}"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Implement a TCP/UDP port scanner with proxy support and configurable source IP addresses.\n\nStruct Description: The Scanner struct provides functionality to check if a specific port is open on a given host, supporting both TCP and UDP protocols. It includes timeout configuration, proxy support, and the ability to specify source IP addresses for the connection.\n\nFields:\n- timeout: time.Duration - Maximum duration to wait for a connection attempt\n- proxyDialer: proxy.Dialer - Optional proxy dialer for making connections through a proxy\n- ListenHandler: *ListenHandler - Configuration for source IP addresses (both IPv4 and IPv6)\n\nMethods:\n- ConnectPort: (host string, p *port.Port, timeout time.Duration) -> (bool, error) - Attempts to connect to the specified port on the given host. Returns true if the port is open/reachable, along with any error that occurred during the connection attempt. The port parameter includes the protocol (TCP/UDP) and port number. The timeout parameter specifies the maximum duration for the connection attempt.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\thostport := net.JoinHostPort(host, fmt.Sprint(p.Port))\n\tvar (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\tif s.proxyDialer != nil {\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t\tproxyDialer, ok := s.proxyDialer.(proxy.ContextDialer)\n\t\tif !ok {\n\t\t\treturn false, errors.New(\"invalid proxy dialer\")\n\t\t}\n\t\tconn, err = proxyDialer.DialContext(ctx, p.Protocol.String(), hostport)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tnetDialer := net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t\tif s.ListenHandler.SourceIp4 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIp4}\n\t\t} else if s.ListenHandler.SourceIP6 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIP6}\n\t\t}\n\t\tconn, err = netDialer.Dial(p.Protocol.String(), hostport)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\tswitch p.Protocol {\n\tcase protocol.UDP:\n\t\tif err := conn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif _, err := conn.Write(nil); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif err := conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tn, err := io.Copy(io.Discard, conn)\n\t\tif err != nil && !os.IsTimeout(err) {\n\t\t\treturn false, err\n\t\t}\n\t\treturn n > 0, nil\n\t}\n\n\treturn true, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "package scanner\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/go-kit/kit/log\"\n\t\"github.com/go-kit/kit/log/level\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype ListenHandler struct {\n\tIPv4 string\n\tIPv6 string\n}\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\t*ListenHandler\n\tlogger log.Logger\n}\n\nfunc NewScanner(timeout time.Duration, proxyDialer proxy.Dialer, lh *ListenHandler, logger log.Logger) *Scanner {\n\treturn &Scanner{\n\t\ttimeout:      timeout,\n\t\tproxyDialer:  proxyDialer,\n\t\tListenHandler: lh,\n\t\tlogger:       log.With(logger, \"component\", \"port_scanner\"),\n\t}\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tnetwork := \"tcp\"\n\tif p.Protocol == port.UDP {\n\t\tnetwork = \"udp\"\n\t}\n\n\tvar dialFn func(network, addr string) (net.Conn, error)\n\tif s.proxyDialer != nil {\n\t\tdialFn = s.proxyDialer.Dial\n\t} else {\n\t\tdialer := &net.Dialer{\n\t\t\tTimeout:   s.timeout,\n\t\t\tLocalAddr: s.getLocalAddr(network),\n\t\t}\n\t\tdialFn = dialer.DialContext\n\t}\n\n\taddr := fmt.Sprintf(\"%s:%d\", host, p.Number)\n\n\tch := make(chan result, 1)\n\tgo func() {\n\t\tconn, err := dialFn(network, addr)\n\t\tif err != nil {\n\t\t\tlevel.Debug(s.logger).Log(\"msg\", \"connection failed\", \"addr\", addr, \"err\", err)\n\t\t\tch <- result{open: false, err: err}\n\t\t\treturn\n\t\t}\n\t\tif p.Protocol == port.TCP {\n\t\t\t_ = conn.Close()\n\t\t} else if p.Protocol == port.UDP {\n\t\t\tdefer conn.Close()\n\t\t\t// For UDP, we can't be sure unless we receive a response\n\t\t\t// But for scanning purposes, successful Dial means it's reachable\n\t\t\tch <- result{open: true, err: nil}\n\t\t\treturn\n\t\t}\n\t\tch <- result{open: true, err: nil}\n\t}()\n\n\tselect {\n\tcase res := <-ch:\n\t\treturn res.open, res.err\n\tcase <-ctx.Done():\n\t\tlevel.Warn(s.logger).Log(\"msg\", \"scan timed out\", \"addr\", addr)\n\t\treturn false, ctx.Err()\n\t}\n}\n\nfunc (s *Scanner) getLocalAddr(network string) net.Addr {\n\tvar ip string\n\tif network == \"tcp6\" || network == \"udp6\" {\n\t\tip = s.ListenHandler.IPv6\n\t} else {\n\t\tip = s.ListenHandler.IPv4\n\t}\n\tif ip == \"\" {\n\t\treturn nil\n\t}\n\t// Dummy port 0 for LocalAddr\n\taddr, _ := net.ResolveTCPAddr(network, net.JoinHostPort(ip, \"0\"))\n\treturn addr\n}\n\ntype result struct {\n\topen bool\n\terr  error\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Create a function that uploads a video file to a specified URL using a multipart/form-data POST request with custom headers.\n\nFunction Description: The function uploads a video file to a given URL with specified form fields and authentication headers. It handles file operations, creates a multipart form payload, sets appropriate headers (including content type and access token), executes the HTTP request, and returns the response body.\n\nInput:\n- url (string): The target URL for the video upload\n- method (string): HTTP method (typically \"POST\")\n- advertiserID (string): The advertiser ID for the form field\n- uploadType (string): The upload type for the form field\n- videoSignature (string): The video signature for the form field\n- filePath (string): Path to the video file to upload\n- accessToken (string): Access token for authentication header\n\nOutput:\n- ([]byte, error): Returns the response body as bytes and any error that occurred during execution\n\nNote: The function should follow the same steps as the reference code, including creating a custom http.Client, setting headers, handling multipart form data, and properly managing resources (file handles, response bodies).",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"video_signature\", \"6b12a8bbbe8e69a2ef5929028b0b50c3\")\n\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\")\n\tdefer file.Close()\n\n\tpart4, errFile4 := writer.CreateFormFile(\"video_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadVideo(url, method, advertiserID, uploadType, videoSignature, filePath, accessToken string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error opening file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\t// Add form fields\n\tif err := writer.WriteField(\"advertiser_id\", advertiserID); err != nil {\n\t\treturn nil, fmt.Errorf(\"error writing advertiser_id field: %w\", err)\n\t}\n\n\tif err := writer.WriteField(\"upload_type\", uploadType); err != nil {\n\t\treturn nil, fmt.Errorf(\"error writing upload_type field: %w\", err)\n\t}\n\n\tif err := writer.WriteField(\"video_signature\", videoSignature); err != nil {\n\t\treturn nil, fmt.Errorf(\"error writing video_signature field: %w\", err)\n\t}\n\n\t// Create form file part\n\tpart, err := writer.CreateFormFile(\"video\", \"video.mp4\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating form file: %w\", err)\n\t}\n\n\t// Copy file content into the form writer\n\tif _, err := io.Copy(part, file); err != nil {\n\t\treturn nil, fmt.Errorf(\"error copying file content: %w\", err)\n\t}\n\n\tif err := writer.Close(); err != nil {\n\t\treturn nil, fmt.Errorf(\"error closing writer: %w\", err)\n\t}\n\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error making request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\treturn respBody, nil\n}"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Go struct that manages multiple TCP and UDP listeners for a proxy server, with methods to register and handle incoming connections.\n\nStruct Description: The Proxy struct manages network listeners for UDP, TCP, and local DNS-over-HTTPS (DoH) connections. It provides methods to create listeners from addresses and handle incoming connections through separate goroutines.\n\nFields:\nudpListeners: []*net.UDPConn - Slice of active UDP listeners\ntcpListeners: []*net.TCPListener - Slice of active TCP listeners\nlocalDoHListeners: []*net.TCPListener - Slice of active local DoH TCP listeners\n\nMethods:\nregisterUDPListener(*net.UDPConn) -> void - Adds a UDP listener to the udpListeners slice\nregisterTCPListener(*net.TCPListener) -> void - Adds a TCP listener to the tcpListeners slice\nregisterLocalDoHListener(*net.TCPListener) -> void - Adds a local DoH listener to the localDoHListeners slice\nudpListenerFromAddr(*net.UDPAddr) -> error - Creates and registers a UDP listener from address\ntcpListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a TCP listener from address\nlocalDoHListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a local DoH listener from address\nudpListener(*net.UDPConn) -> void - Handles incoming UDP connections (runs in goroutine)\ntcpListener(*net.TCPListener) -> void - Handles incoming TCP connections (runs in goroutine)\nstartAcceptingClients() -> void - Starts all registered listeners in separate goroutines",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners    []*net.UDPConn\n\ttcpListeners    []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (proxy *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tproxy.udpListeners = append(proxy.udpListeners, conn)\n}\n\nfunc (proxy *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tproxy.tcpListeners = append(proxy.tcpListeners, listener)\n}\n\nfunc (proxy *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tproxy.localDoHListeners = append(proxy.localDoHListeners, listener)\n}\n\nfunc (proxy *Proxy) udpListenerFromAddr(listenAddr *net.UDPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"udp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"udp4\"\n\t}\n\tclientPc, err := net.ListenUDP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerUDPListener(clientPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) tcpListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerTCPListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) localDoHListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerLocalDoHListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) udpListener(clientPc *net.UDPConn) {\n\tdefer clientPc.Close()\n\tfor {\n\t\tbuffer := make([]byte, MaxDNSPacketSize-1)\n\t\tlength, clientAddr, err := clientPc.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tpacket := buffer[:length]\n\t\tgo proxy.processIncomingQuery(\"udp\", \"udp\", packet, &clientAddr, clientPc, time.Now(), false)\n\t}\n}\n\nfunc (proxy *Proxy) tcpListener(acceptPc *net.TCPListener) {\n\tdefer acceptPc.Close()\n\tfor {\n\t\tclientPc, err := acceptPc.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tdefer clientPc.Close()\n\t\t\tif err := clientPc.SetDeadline(time.Now().Add(proxy.timeout)); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart := time.Now()\n\t\t\tpacket, err := ReadPrefixed(&clientPc)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclientAddr := clientPc.RemoteAddr()\n\t\t\tproxy.processIncomingQuery(\"tcp\", \"tcp\", packet, &clientAddr, clientPc, start, false)\n\t\t}()\n\t}\n}\n\nfunc (proxy *Proxy) startAcceptingClients() {\n\tfor _, clientPc := range proxy.udpListeners {\n\t\tgo proxy.udpListener(clientPc)\n\t}\n\tproxy.udpListeners = nil\n\tfor _, acceptPc := range proxy.tcpListeners {\n\t\tgo proxy.tcpListener(acceptPc)\n\t}\n\tproxy.tcpListeners = nil\n\tfor _, acceptPc := range proxy.localDoHListeners {\n\t\tgo proxy.localDoHListener(acceptPc)\n\t}\n\tproxy.localDoHListeners = nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners       []*net.UDPConn\n\ttcpListeners       []*net.TCPListener\n\tlocalDoHListeners  []*net.TCPListener\n}\n\nfunc (p *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tp.udpListeners = append(p.udpListeners, conn)\n}\n\nfunc (p *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tp.tcpListeners = append(p.tcpListeners, listener)\n}\n\nfunc (p *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tp.localDoHListeners = append(p.localDoHListeners, listener)\n}\n\nfunc (p *Proxy) udpListenerFromAddr(addr *net.UDPAddr) error {\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerUDPListener(conn)\n\treturn nil\n}\n\nfunc (p *Proxy) tcpListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerTCPListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) localDoHListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerLocalDoHListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) udpListener(conn *net.UDPConn) {\n\tbuffer := make([]byte, 65536)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\trecover()\n\t\t\t}()\n\t\t\tp.handleUDPConnection(conn, buffer[:n], addr)\n\t\t}()\n\t}\n}\n\nfunc (p *Proxy) handleUDPConnection(conn *net.UDPConn, data []byte, addr *net.UDPAddr) {\n\t_, err := conn.WriteToUDP(data, addr)\n\tif err != nil {\n\t\treturn\n\t}\n}\n\nfunc (p *Proxy) tcpListener(listener *net.TCPListener) {\n\tfor {\n\t\tconn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgo p.handleTCPConnection(conn)\n\t}\n}\n\nfunc (p *Proxy) handleTCPConnection(conn *net.TCPConn) {\n\tdefer conn.Close()\n\tbuffer := make([]byte, 65536)\n\tfor {\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\t_, err = conn.Write(buffer[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Proxy) startAcceptingClients() {\n\tfor _, listener := range p.udpListeners {\n\t\tgo p.udpListener(listener)\n\t}\n\tfor _, listener := range p.tcpListeners {\n\t\tgo p.tcpListener(listener)\n\t}\n\tfor _, listener := range p.localDoHListeners {\n\t\tgo p.tcpListener(listener)\n\t}\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a Go struct that manages HTTP requests to interact with a community persistence service, including authentication and community creation functionality.\n\nStruct Description: The Manager struct provides methods to interact with a community persistence API, handling authentication and request/response processing. It maintains connection details and context for request cancellation.\n\nFields:\nurl: string - Base URL of the community persistence service\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nctx: context.Context - Context for request cancellation and timeouts\n\nMethods:\nNewManager: (url string, username string, password string, ctx context.Context) -> *Manager - Constructor that initializes a new Manager instance with connection details and context\nCreatePersistentCommunity: (community string, password string) -> (*persisters.Community, error) - Creates a new persistent community by making an authenticated POST request to the service, returning the created community or an error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/pojntfx/weron/internal/persisters\"\n)\n\nvar (\n\tjson = jsoniter.ConfigCompatibleWithStandardLibrary\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(\n\turl string,\n\tusername string,\n\tpassword string,\n\tctx context.Context,\n) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\thc := &http.Client{}\n\n\tu, err := url.Parse(m.url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := u.Query()\n\tq.Set(\"community\", community)\n\tq.Set(\"password\", password)\n\tu.RawQuery = q.Encode()\n\n\treq, err := http.NewRequest(http.MethodPost, u.String(), http.NoBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\n\tres, err := hc.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(res.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := persisters.Community{}\n\tif err := json.Unmarshal(body, &c); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &c, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package community\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(url string, username string, password string, ctx context.Context) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\treq, err := http.NewRequestWithContext(m.ctx, \"POST\", fmt.Sprintf(\"%s/communities\", m.url), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.SetBasicAuth(m.username, m.password)\n\n\t// Assuming the service expects form data\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tbody := fmt.Sprintf(\"name=%s&password=%s\", community, password)\n\treq.Body = ioutil.NopCloser(strings.NewReader(body))\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\t// Assuming persisters.Community is a defined struct that can be decoded from response body\n\tvar createdCommunity persisters.Community\n\tif err := json.NewDecoder(resp.Body).Decode(&createdCommunity); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createdCommunity, nil\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Implement a high-performance TCP server in Go using kqueue for event notification, capable of handling multiple client connections efficiently with non-blocking I/O operations.\n\nStruct Description: The `poller` struct manages a single kqueue instance and handles all I/O operations for its assigned connections. It works as part of an engine (`g *Engine`) to process network events either as a listener (accepting new connections) or as a worker (handling read/write operations).\n\nFields:\n\ng: *Engine - Reference to the parent engine managing all pollers\nmux: sync.Mutex - Mutex for thread-safe access to eventList\nkfd: int - Kqueue file descriptor\nevtfd: int - Event file descriptor (unused in current implementation)\nindex: int - Poller's index in the engine's poller array\nshutdown: bool - Flag to control poller shutdown\nlistener: net.Listener - TCP listener (only for listener pollers)\nisListener: bool - Flag indicating if this is a listener poller\nunixSockAddr: string - Unix socket address (if using UNIX domain sockets)\nReadBuffer: []byte - Buffer for read operations\npollType: string - Type identifier (\"LISTENER\" or \"POLLER\")\neventList: []syscall.Kevent_t - Pending kqueue events to be processed\n\nMethods:\n\naddConn(c *Conn) -> error - Adds a new connection to the poller and registers it for read events\naddDialer(c *Conn) -> error - Adds a dialer connection and registers it for read/write events\ngetConn(fd int) -> *Conn - Retrieves a connection by file descriptor\ndeleteConn(c *Conn) -> - Removes a connection from tracking\ntrigger() -> - Wakes up the kqueue loop\naddRead(fd int) -> - Registers a file descriptor for read events\nresetRead(fd int) -> - Unregisters write events for a file descriptor\nmodWrite(fd int) -> - Registers a file descriptor for write events\naddReadWrite(fd int) -> - Registers a file descriptor for both read and write events\nreadWrite(ev *syscall.Kevent_t) -> - Processes read/write events from kqueue\nstart() -> - Starts the poller's main loop (either acceptorLoop or readWriteLoop)\nacceptorLoop() -> - Listener's main loop that accepts new connections\nreadWriteLoop() -> - Worker's main loop that processes I/O events\nstop() -> - Stops the poller and cleans up resources\nnewPoller(g *Engine, isListener bool, index int) -> (*poller, error) - Constructor that creates either a listener or worker poller",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package netpoll\n\nimport (\n\t\"golang.org/x/sys/unix\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype poller struct {\n\tg           *Engine\n\tmux         sync.Mutex\n\tkfd         int\n\tevtfd       int\n\tindex       int\n\tshutdown    bool\n\tlistener    net.Listener\n\tisListener  bool\n\tunixSockAddr string\n\tReadBuffer   []byte\n\tpollType     string\n\teventList    []unix.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\t// Implementation here\n}\n\nfunc (p *poller) trigger() {\n\t// Implementation here\n}\n\nfunc (p *poller) addRead(fd int) {\n\t// Implementation here\n}\n\nfunc (p *poller) resetRead(fd int) {\n\t// Implementation here\n}\n\nfunc (p *poller) modWrite(fd int) {\n\t// Implementation here\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\t// Implementation here\n}\n\nfunc (p *poller) readWrite(ev *unix.Kevent_t) {\n\t// Implementation here\n}\n\nfunc (p *poller) start() {\n\t// Implementation here\n}\n\nfunc (p *poller) acceptorLoop() {\n\t// Implementation here\n}\n\nfunc (p *poller) readWriteLoop() {\n\t// Implementation here\n}\n\nfunc (p *poller) stop() {\n\t// Implementation here\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\t// Implementation here\n\treturn &poller{}, nil\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Implement a TCP server in Go that handles client connections, processes incoming messages, and generates appropriate responses based on the message type. The server should support graceful shutdown and concurrent client handling.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, processes client requests, and maintains server state including messages, errors, and connection information.\n\nFields:\n- Addr: net.Addr - The network address the server is listening on\n- mu: sync.Mutex - Mutex for thread-safe operations\n- wg: sync.WaitGroup - WaitGroup for managing goroutines\n- closed: bool - Flag indicating if the server is closed\n- closing: chan struct{} - Channel for shutdown signaling\n- messages: []Message - Collection of processed messages\n- errors: []error - Collection of encountered errors\n- brokerMessage: []byte - Pre-prepared broker message data\n- nodeID: int32 - Identifier for the server node\n- partitionCount: int32 - Number of partitions for topic handling\n\nMethods:\n- NewServer() -> (*Server, error) - Creates and starts a new Server instance\n- prepareBrokerMsg() - Prepares the broker message with server information\n- Close() - Gracefully shuts down the server\n- run(net.Listener) - Main server loop handling connections\n- handle(net.Conn) -> error - Processes individual client connections\n- readProduceRequest([]byte) -> (string, []Response, error) - Helper for produce requests\n- readStrList([]byte) -> ([]string, int) - Helper for reading string lists",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr net.Addr\n\tmu   sync.Mutex\n\twg   sync.WaitGroup\n\n\tclosed  bool\n\tclosing chan struct{}\n\n\tmessages []Message\n\terrors   []error\n\n\tbrokerMessage []byte\n\tnodeID        int32\n\n\tpartitionCount int32\n}\n\nfunc NewServer() (*Server, error) {\n\ts := &Server{\n\t\tclosing:        make(chan struct{}),\n\t\tnodeID:         1,\n\t\tpartitionCount: 3,\n\t}\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.Addr = l.Addr()\n\n\ts.prepareBrokerMsg()\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\ts.run(l)\n\t}()\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\thost, port, _ := net.SplitHostPort(s.Addr.String())\n\ts.brokerMessage = make([]byte, 0, 4+2+len(host)+4)\n\ts.brokerMessage = writeInt32(s.brokerMessage, s.nodeID)\n\ts.brokerMessage = writeStr(s.brokerMessage, host)\n\tportN, _ := strconv.Atoi(port)\n\ts.brokerMessage = writeInt32(s.brokerMessage, int32(portN))\n\ts.brokerMessage = writeInt16(s.brokerMessage, -1)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(l net.Listener) {\n\tdefer l.Close()\n\n\taccepts := make(chan net.Conn)\n\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tfor {\n\t\t\tc, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase accepts <- c:\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase c := <-accepts:\n\t\t\tgo func() {\n\t\t\t\tdefer c.Close()\n\t\t\t\tfor {\n\t\t\t\t\tif err := s.handle(c); err != nil {\n\t\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.mu.Lock()\n\t\t\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\t\t\ts.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\tcase <-s.closing:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Server) handle(c net.Conn) error {\n\tvar size int32\n\terr := binary.Read(c, binary.BigEndian, &size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, int(size))\n\n\t_, err = io.ReadFull(c, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tapiKey := int16(binary.BigEndian.Uint16(buf[:2]))\n\tversion := int16(binary.BigEndian.Uint16(buf[2:4]))\n\t_, n := readStr(buf[8:])\n\trequest := buf[8+n:]\n\n\tresponse := make([]byte, 8, 1024)\n\tcopy(response[4:], buf[4:8])\n\n\tswitch apiKey {\n\tcase 0:\n\t\ttopic, responses, err := s.readProduceRequest(request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse = writeArrayHeader(response, 1)\n\t\tresponse = writeStr(response, topic)\n\t\tresponse = writeArrayHeader(response, int32(len(responses)))\n\t\tfor _, r := range responses {\n\t\t\tresponse = writeInt32(response, 0)\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeInt64(response, r.offset)\n\t\t\tresponse = writeInt64(response, 0)\n\t\t\tif version >= 5 {\n\t\t\t\tresponse = writeInt64(response, 0)\n\t\t\t}\n\t\t}\n\t\tresponse = writeInt32(response, 0)\n\n\tcase 3:\n\t\ttopics, _ := readStrList(request)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArray(response, [][]byte{s.brokerMessage})\n\t\tresponse = writeInt16(response, -1)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArrayHeader(response, int32(len(topics)))\n\t\tfor _, t := range topics {\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeStr(response, t)\n\t\t\tresponse = writeBool(response, false)\n\t\t\tresponse = writeArrayHeader(response, s.partitionCount)\n\t\t\tfor i := int32(0); i < s.partitionCount; i++ {\n\t\t\t\tresponse = writeInt16(response, 0)\n\t\t\t\tresponse = writeInt32(response, i+1)\n\t\t\t\tresponse = writeInt32(response, s.nodeID)\n\t\t\t\tif version >= 7 {\n\t\t\t\t\tresponse = writeInt32(response, 0)\n\t\t\t\t}\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t}\n\t\t}\n\tcase 18:\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeArrayHeader(response, 2)\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 3)\n\t\tresponse = writeInt16(response, 1)\n\t\tresponse = writeInt16(response, 1)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported apiKey %d\", apiKey)\n\t}\n\n\tresponseSize := len(response) - 4\n\tbinary.BigEndian.PutUint32(response[:4], uint32(responseSize))\n\t_, err = c.Write(response)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Message struct {\n\tTopic     string\n\tPartition int32\n\tValue     []byte\n}\n\ntype Response struct {\n\tTopic      string\n\tPartition  int32\n\tOffset     int64\n\tErr        error\n}\n\ntype Server struct {\n\tAddr          net.Addr\n\tmu            sync.Mutex\n\twg            sync.WaitGroup\n\tclosed        bool\n\tclosing       chan struct{}\n\tmessages      []Message\n\terrors        []error\n\tbrokerMessage []byte\n\tnodeID        int32\n\tpartitionCount int32\n\tlistener      net.Listener\n}\n\nfunc NewServer(nodeID, partitionCount int32) (*Server, error) {\n\ts := &Server{\n\t\tnodeID:         nodeID,\n\t\tpartitionCount: partitionCount,\n\t\tclosing:        make(chan struct{}),\n\t}\n\ts.prepareBrokerMsg()\n\n\t// Start listening on a random port for demonstration\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.Addr = l.Addr()\n\ts.listener = l\n\n\tgo s.run(l)\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\t// Example broker message format: nodeID(int32), host(string), port(int32)\n\thost, port, _ := net.SplitHostPort(s.Addr.String())\n\ts.brokerMessage = make([]byte, 4+2+len(host)+4)\n\toffset := 0\n\t// Write nodeID as int32\n\ts.brokerMessage[offset] = byte(s.nodeID >> 24)\n\ts.brokerMessage[offset+1] = byte(s.nodeID >> 16)\n\ts.brokerMessage[offset+2] = byte(s.nodeID >> 8)\n\ts.brokerMessage[offset+3] = byte(s.nodeID)\n\toffset += 4\n\n\t// Write host length as int16\n\thostBytes := []byte(host)\n\thostLen := int16(len(hostBytes))\n\ts.brokerMessage[offset] = byte(hostLen >> 8)\n\ts.brokerMessage[offset+1] = byte(hostLen)\n\toffset += 2 + len(hostBytes)\n\n\t// Assume port is already in network byte order\n\tportInt := 0\n\tif port != \"\" {\n\t\tvar ok error\n\t\tif portInt, ok = 0, nil; ok != nil {\n\t\t\tportInt = 9092 // default Kafka port\n\t\t}\n\t}\n\ts.brokerMessage[offset] = byte(portInt >> 24)\n\ts.brokerMessage[offset+1] = byte(portInt >> 16)\n\ts.brokerMessage[offset+2] = byte(portInt >> 8)\n\ts.brokerMessage[offset+3] = byte(portInt)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tif s.closed {\n\t\ts.mu.Unlock()\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.mu.Unlock()\n\n\ts.listener.Close()\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(ln net.Listener) {\n\tdefer s.wg.Done()\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\ts.mu.Lock()\n\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\ts.mu.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\ts.wg.Add(1)\n\t\tgo func() {\n\t\t\tdefer s.wg.Done()\n\t\t\tif err := s.handle(conn); err != nil {\n\t\t\t\ts.mu.Lock()\n\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\ts.mu.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (s *Server) handle(conn net.Conn) error {\n\tdefer conn.Close()\n\tbuf := make([]byte, 1024)\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.closing:\n\t\t\treturn errors.New(\"server closing\")\n\t\tdefault:\n\t\t}\n\n\t\tn, err := conn.Read(buf)\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq := buf[:n]\n\t\tmsgType := req[0]\n\n\t\tswitch msgType {\n\t\tcase 0: // Produce request\n\t\t\ttopic, responses, err := s.readProduceRequest(req[1:])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Store messages\n\t\t\ts.mu.Lock()\n\t\t\tfor _, resp := range responses {\n\t\t\t\ts.messages = append(s.messages, Message{\n\t\t\t\t\tTopic:     topic,\n\t\t\t\t\tPartition: resp.Partition,\n\t\t\t\t\tValue:     req, // In reality, extract actual value\n\t\t\t\t})\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t\t// Send response (just an ack here)\n\t\t\tconn.Write([]byte{0, 0, 0, 1}) // Simple acknowledgment\n\n\t\tcase 1: // Metadata request\n\t\t\tconn.Write(s.brokerMessage)\n\n\t\tdefault:\n\t\t\treturn errors.New(\"unknown request type\")\n\t\t}\n\t}\n}\n\nfunc (s *Server) readProduceRequest(data []byte) (string, []Response, error) {\n\t// Format: topic length (int16), topic (string), partition count (int32), \n\t// followed by partition data (partition id (int32), message set size (int32), message set)\n\toffset := 0\n\t\n\tif len(data) < 2 {\n\t\treturn \"\", nil, errors.New(\"not enough data for topic length\")\n\t}\n\ttopicLen := int(data[0])<<8 | int(data[1])\n\toffset += 2\n\t\n\tif len(data) < offset+topicLen {\n\t\treturn \"\", nil, errors.New(\"not enough data for topic name\")\n\t}\n\ttopic := string(data[offset:offset+topicLen])\n\toffset += topicLen\n\t\n\tif len(data) < offset+4 {\n\t\treturn \"\", nil, errors.New(\"not enough data for partition count\")\n\t}\n\tpartitionCount := int32(data[offset])<<24 | int32(data[offset+1])<<16 | int32(data[offset+2])<<8 | int32(data[offset+3])\n\toffset += 4\n\t\n\tresponses := make([]Response, 0, partitionCount)\n\tfor i := int32(0); i < partitionCount; i++ {\n\t\tif len(data) < offset+4 {\n\t\t\treturn \"\", nil, errors.New(\"not enough data for partition ID\")\n\t\t}\n\t\tpartition := int32(data[offset])<<24 | int32(data[offset+1])<<16 | int32(data[offset+2])<<8 | int32(data[offset+3])\n\t\toffset += 4\n\t\t\n\t\t// Skip message set size and the message set itself\n\t\tif len(data) < offset+4 {\n\t\t\treturn \"\", nil, errors.New(\"not enough data for message set size\")\n\t\t}\n\t\tmsgSetSize := int32(data[offset])<<24 | int32(data[offset+1])<<16 | int32(data[offset+2])<<8 | int32(data[offset+3])\n\t\toffset += 4 + int(msgSetSize)\n\t\t\n\t\tresponses = append(responses, Response{\n\t\t\tTopic:     topic,\n\t\t\tPartition: partition,\n\t\t\tOffset:    0, // In real implementation, this would be the actual offset\n\t\t\tErr:       nil,\n\t\t})\n\t}\n\t\n\treturn topic, responses, nil\n}\n\nfunc readStrList(data []byte) ([]string, int) {\n\tif len(data) < 4 {\n\t\treturn nil, 0\n\t}\n\t\n\tcount := int(data[0])<<24 | int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n\toffset := 4\n\t\n\tstrings := make([]string, 0, count)\n\tfor i := 0; i < count; i++ {\n\t\tif len(data) < offset+2 {\n\t\t\treturn strings, offset\n\t\t}\n\t\tstrLen := int(data[offset])<<8 | int(data[offset+1])\n\t\toffset += 2\n\t\t\n\t\tif len(data) < offset+strLen {\n\t\t\treturn strings, offset + strLen\n\t\t}\n\t\t\n\t\tstr := string(data[offset:offset+strLen])\n\t\tstrings = append(strings, str)\n\t\toffset += strLen\n\t}\n\t\n\treturn strings, offset\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Implement a TCP listener in Go that supports different listening methods (normal, iptables, and socket reuse) for handling incoming client connections, performing protocol negotiation, and managing client tasks.\n\nStruct Description: The Listen struct represents a TCP listener with configurable listening methods and address. It provides methods to start listening using different techniques and handle client connections.\n\nFields:\nmethod: [int] - Specifies the listening method (NORMAL, IPTABLES, or SOREUSE)\naddr: [string] - The address and port to listen on\n\nMethods:\nnewListen: [Name](method int, addr string) -> *Listen - Creates and returns a new Listen instance with the specified method and address\nstart: [Name](mgr *manager.Manager, options *initial.Options) -> void - Starts the listener in a goroutine using the configured method\nnormalListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements standard TCP listening and client handling\nsoReuseListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements socket reuse listening with additional authentication and proxy capabilities",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-reuseport\"\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\tlisten := new(Listen)\n\tlisten.method = method\n\tlisten.addr = addr\n\treturn listen\n}\n\nfunc (listen *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch listen.method {\n\tcase NORMAL:\n\t\tgo listen.normalListen(mgr, options)\n\tcase IPTABLES:\n\t\tgo listen.iptablesListen(mgr, options)\n\tcase SOREUSE:\n\t\tgo listen.soReuseListen(mgr, options)\n\t}\n}\n\nfunc (listen *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", listen.addr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}\n\nfunc (listen *Listen) soReuseListen(mgr *manager.Manager, options *initial.Options) {\n\tlistenAddr := fmt.Sprintf(\"%s:%s\", options.ReuseHost, options.ReusePort)\n\tlistener, err := reuseport.Listen(\"tcp\", listenAddr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\tdefer conn.SetReadDeadline(time.Time{})\n\t\tconn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\n\t\tbuffer := make([]byte, 16)\n\t\tcount, err := io.ReadFull(conn, buffer)\n\n\t\tif err != nil {\n\t\t\tif timeoutErr, ok := err.(net.Error); ok && timeoutErr.Timeout() {\n\t\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif string(buffer[:count]) == share.AuthToken {\n\t\t\tconn.Write([]byte(share.AuthToken))\n\t\t} else {\n\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\tcontinue\n\t\t}\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package listener\n\nimport (\n\t\"github.com/yourproject/manager\"\n\t\"github.com/yourproject/initial\"\n\t\"net\"\n)\n\nconst (\n\tNORMAL = iota\n\tIPTABLES\n\tSOREUSE\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\treturn &Listen{\n\t\tmethod: method,\n\t\taddr:   addr,\n\t}\n}\n\nfunc (l *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch l.method {\n\tcase NORMAL:\n\t\tl.normalListen(mgr, options)\n\tcase IPTABLES:\n\t\t// Implement iptables specific logic if needed\n\tcase SOREUSE:\n\t\tl.soReuseListen(mgr, options)\n\t}\n}\n\nfunc (l *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", l.addr)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tmgr.HandleClient(conn, options)\n\t\t}()\n\t}\n}\n\nfunc (l *Listen) soReuseListen(mgr *manager.Manager, options *initial.Options) {\n\tconfig := &net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t\tvar opErr error\n\t\t\tc.Control(func(fd uintptr) {\n\t\t\t\topErr = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n\t\t\t\tif opErr == nil {\n\t\t\t\t\topErr = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn opErr\n\t\t},\n\t}\n\n\tlistener, err := config.Listen(nil, \"tcp\", l.addr)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tif authenticate(conn, options) {\n\t\t\t\tmgr.HandleClient(conn, options)\n\t\t\t} else {\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc authenticate(conn net.Conn, options *initial.Options) bool {\n\t// Perform authentication handshake or token verification\n\t// Return true if client is authenticated successfully\n\treturn true\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client requests, and manages connection lifecycle with configurable timeouts.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - The request handler interface\nReadTimeout: time.Duration - Maximum duration for reading the entire request\nWriteTimeout: time.Duration - Maximum duration for writing the response\nIdleTimeout: func() time.Duration - Function returning the maximum idle connection duration\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Main server loop that accepts and handles connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual client connection\ninit() - Initializes server resources\nisStarted() bool - Returns server running status\ngetReadTimeout() time.Duration - Returns configured read timeout or default",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, false, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\tlimit := maxTCPQueries\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n\tif srv.Handler == nil {\n\t\tsrv.Handler = DefaultServeMux\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeTCP(context.Context, net.Conn)\n}\n\ntype Server struct {\n\tAddr         string\n\tNet          string\n\tHandler      Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tlock         sync.RWMutex\n\tstarted      bool\n\tshutdown     chan struct{}\n\tconns        map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif s.Handler == nil {\n\t\treturn fmt.Errorf(\"handler required\")\n\t}\n\n\tif s.Net == \"\" {\n\t\ts.Net = \"tcp\"\n\t}\n\n\tif s.Addr == \"\" {\n\t\ts.Addr = \":http\"\n\t}\n\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn s.serveTCP(listener)\n}\n\nfunc (s *Server) serveTCP(ln net.Listener) error {\n\tvar wg sync.WaitGroup\n\n\ts.lock.Lock()\n\ts.started = true\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.lock.Unlock()\n\n\tdefer func() {\n\t\tln.Close()\n\t\ts.lock.Lock()\n\t\tfor conn := range s.conns {\n\t\t\tconn.Close()\n\t\t}\n\t\ts.conns = nil\n\t\ts.started = false\n\t\tclose(s.shutdown)\n\t\ts.lock.Unlock()\n\t}()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\tdefer conn.Close()\n\n\ts.lock.Lock()\n\ts.conns[conn] = struct{}{}\n\ts.lock.Unlock()\n\n\tctx := context.Background()\n\tif idleTimeout := s.IdleTimeout(); idleTimeout > 0 {\n\t\tctx, _ = context.WithTimeout(ctx, idleTimeout)\n\t}\n\n\treadDeadline := s.getReadTimeout()\n\tif readDeadline > 0 {\n\t\tconn.SetReadDeadline(time.Now().Add(readDeadline))\n\t}\n\n\ts.Handler.ServeTCP(ctx, conn)\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif s.conns == nil {\n\t\ts.conns = make(map[net.Conn]struct{})\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\tif s.ReadTimeout > 0 {\n\t\treturn s.ReadTimeout\n\t}\n\treturn 10 * time.Second\n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a TCP server in Go that can handle multiple client connections concurrently, manage server lifecycle, and track active connections.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client communication, and provides server management capabilities.\n\nFields:\n- Addr: string - The network address to listen on (e.g., \":8080\")\n- Net: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\n- Handler: Handler - Interface for custom request handling (implementation not shown)\n- Listener: net.Listener - The underlying network listener\n- conns: map[net.Conn]struct{} - Track active connections\n- lock: sync.RWMutex - Protects concurrent access to server state\n- started: bool - Indicates if server is running\n- shutdown: chan struct{} - Channel for shutdown signaling\n\nMethods:\n- ListenAndServe() error - Starts the server and begins accepting connections\n- init() - Initializes server resources (internal use)\n- serveTCP(net.Listener) error - Main server loop that accepts connections (internal use)\n- serveTCPConn(*sync.WaitGroup, net.Conn) - Handles individual client connections (internal use)\n- isStarted() bool - Thread-safe check of server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tl, err := net.Listen(srv.Net, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Listener = l\n\tsrv.started = true\n\tunlock()\n\treturn srv.serveTCP(l)\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer func() {\n\t\tsrv.lock.Lock()\n\t\tdelete(srv.conns, rw)\n\t\tsrv.lock.Unlock()\n\t\trw.Close()\n\t\twg.Done()\n\t}()\n\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := rw.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = rw.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc unlockOnce(l sync.Locker) func() {\n\tvar once sync.Once\n\treturn func() { once.Do(l.Unlock) }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Handler interface {\n\tServeTCP(context.Context, net.Conn)\n}\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener  net.Listener\n\tconns     map[net.Conn]struct{}\n\tlock      sync.RWMutex\n\tstarted   bool\n\tshutdown  chan struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif s.Handler == nil {\n\t\treturn nil\n\t}\n\tif s.Net == \"\" {\n\t\ts.Net = \"tcp\"\n\t}\n\tif s.Addr == \"\" {\n\t\ts.Addr = \":http\"\n\t}\n\n\tl, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.Listener = l\n\treturn s.serveTCP(l)\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif s.conns == nil {\n\t\ts.conns = make(map[net.Conn]struct{})\n\t}\n\tif s.shutdown == nil {\n\t\ts.shutdown = make(chan struct{})\n\t}\n\ts.started = true\n}\n\nfunc (s *Server) serveTCP(l net.Listener) error {\n\ts.init()\n\tvar wg sync.WaitGroup\n\n\tdefer func() {\n\t\tclose(s.shutdown)\n\t\ts.lock.Lock()\n\t\tfor c := range s.conns {\n\t\t\tc.Close()\n\t\t}\n\t\ts.lock.Unlock()\n\t\twg.Wait()\n\t\ts.lock.Lock()\n\t\ts.started = false\n\t\ts.lock.Unlock()\n\t}()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\n\t\twg.Add(1)\n\t\tgo s.serveTCPConn(&wg, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\tconn.Close()\n\t\twg.Done()\n\t}()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo func() {\n\t\t<-s.shutdown\n\t\tcancel()\n\t}()\n\n\ts.Handler.ServeTCP(ctx, conn)\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a TLS server in Go that handles incoming TCP connections, performs TLS handshakes, manages connection timeouts, and processes domain-specific data through channels.\n\nStruct Description: The TLSServer struct represents a TLS-enabled TCP server that handles secure connections, manages connection state, and processes domain-specific data through channels. It includes functionality for accepting connections, handling TLS handshakes, managing timeouts, and shutting down gracefully.\n\nFields:\n- HTTPSServer: *HTTPSServer - Reference to the parent HTTPSServer containing configuration\n- Cache: *cache.Cache - Cache for storing active connections\n- TCPListen: *net.TCPListener - TCP listener for incoming connections\n- Done: chan byte - Channel for signaling server shutdown\n- DomainData: chan DomainData - Channel for sending domain-specific data\n- Error: chan error - Channel for reporting errors\n\nMethods:\n- NewTLSServer(*HTTPSServer) (*TLSServer, error) - Constructor that initializes a new TLSServer instance\n- ListenAndServe() error - Main server loop that handles domain data and errors\n- Shutdown() - Gracefully shuts down the server\n- Accept() - Accepts incoming connections and handles TLS handshakes (spawned as a goroutine)",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/zoro\"\n)\n\ntype DomainData struct {\n\tDomain string\n\tData   []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(s *HTTPSServer) (*TLSServer, error) {\n\tl, err := net.ListenTCP(\"tcp\", s.TLSAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TLSServer{\n\t\tHTTPSServer: s,\n\t\tCache:       cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tTCPListen:   l,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tdefer close(s.Done)\n\tdefer s.TCPListen.Close()\n\tgo s.Accept()\n\tfor {\n\t\tselect {\n\t\tcase d := <-s.DomainData:\n\t\t\ti, ok := s.Cache.Get(\"domain:\" + d.Domain)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc := i.(*net.TCPConn)\n\t\t\tif err := c.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, err := c.Write(d.Data); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tselect {\n\tcase <-s.Done:\n\t\treturn\n\tcase s.Error <- nil:\n\t}\n}\n\nfunc (s *TLSServer) Accept() {\n\tfor {\n\t\tc1, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.Done:\n\t\t\t\treturn\n\t\t\tcase s.Error <- err:\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif s.HTTPSServer.TLSTimeout != 0 {\n\t\t\tif err := c1.SetKeepAlivePeriod(time.Duration(s.HTTPSServer.TLSTimeout) * time.Second); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\tif err := c1.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\ttc := tls.Server(c1, s.HTTPSServer.TLSConfig)\n\t\tif err := tc.Handshake(); err != nil {\n\t\t\tc1.Close()\n\t\t\tcontinue\n\t\t}\n\t\tcs := tc.ConnectionState()\n\t\tif cs.ServerName == \"\" {\n\t\t\tlog.Println(tc.RemoteAddr().String() + \" no SNI\")\n\t\t\ttc.Close()\n\t\t\tcontinue\n\t\t}\n\t\ts.Cache.Set(tc.RemoteAddr().String(), tc, cache.DefaultExpiration)\n\t\tgo func(tc *tls.Conn) {\n\t\t\tdefer func() {\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x02}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t\ts.Cache.Delete(tc.RemoteAddr().String())\n\t\t\t\ttc.Close()\n\t\t\t}()\n\t\t\tvar bf [1024 * 2]byte\n\t\t\tfor {\n\t\t\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\t\t\tif err := tc.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti, err := tc.Read(bf[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t\tData:    bf[0:i],\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x01}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t}\n\t\t}(tc)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype DomainData struct {\n\tConnection *tls.Conn\n\tData       []byte\n}\n\ntype HTTPSServer struct {\n\tAddr         string\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tTLSConfig    *tls.Config\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(server *HTTPSServer) (*TLSServer, error) {\n\taddr, err := net.ResolveTCPAddr(\"tcp\", server.Addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &TLSServer{\n\t\tHTTPSServer: server,\n\t\tCache:       cache.New(),\n\t\tTCPListen:   listener,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tgo s.Accept()\n\n\tfor {\n\t\tselect {\n\t\tcase data := <-s.DomainData:\n\t\t\tgo s.handleDomainData(data)\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\tcase <-s.Done:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *TLSServer) Accept() {\n\tdefer close(s.Done)\n\n\tfor {\n\t\tconn, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\ts.Error <- err\n\t\t\treturn\n\t\t}\n\n\t\tconn.SetKeepAlive(true)\n\t\tconn.SetKeepAlivePeriod(3 * time.Minute)\n\n\t\ttlsConn := tls.Server(conn, s.HTTPSServer.TLSConfig)\n\t\ttlsConn.SetReadDeadline(time.Now().Add(s.HTTPSServer.ReadTimeout))\n\t\ttlsConn.SetWriteDeadline(time.Now().Add(s.HTTPSServer.WriteTimeout))\n\n\t\tgo s.handleConnection(tlsConn)\n\t}\n}\n\nfunc (s *TLSServer) handleConnection(conn *tls.Conn) {\n\tstate := conn.ConnectionState()\n\ts.Cache.Add(conn.RemoteAddr().String(), conn)\n\n\tif state.NegotiatedProtocolIsMutual && state.NegotiatedProtocol != \"\" {\n\t\tdata := DomainData{\n\t\t\tConnection: conn,\n\t\t\tData:       []byte(state.NegotiatedProtocol),\n\t\t}\n\t\ts.DomainData <- data\n\t}\n}\n\nfunc (s *TLSServer) handleDomainData(data DomainData) {\n\tdefer s.Cache.Remove(data.Connection.RemoteAddr().String())\n\n\t_, err := data.Connection.Write(data.Data)\n\tif err != nil {\n\t\ts.Error <- err\n\t\treturn\n\t}\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tclose(s.Done)\n\ts.TCPListen.Close()\n\tclose(s.DomainData)\n\tclose(s.Error)\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement an HTTP transport struct for sending tracing spans to a collector using Thrift serialization and HTTP protocol.\n\nStruct Description: HTTPTransport is a struct that handles batching and sending tracing spans to a remote collector via HTTP. It supports basic authentication and custom HTTP client configuration.\n\nFields:\n- logger: jaeger.Logger - Logger for reporting errors and debug information\n- url: string - The collector endpoint URL\n- client: *http.Client - Custom HTTP client for making requests\n- batchSize: int - Maximum number of spans to batch before flushing\n- batch: []*zipkincore.Span - Current batch of spans waiting to be sent\n- httpCredentials: *HTTPBasicAuthCredentials - Optional basic auth credentials\n\nMethods:\n- NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) - Constructor that creates a new HTTPTransport with default values and applies options\n- Append(span *jaeger.Span) (int, error) - Adds a span to the current batch, flushes if batch size is reached\n- Flush() (int, error) - Sends all batched spans to the collector and resets the batch\n- Close() error - Cleanup method (currently no-op)\n- send(spans []*zipkincore.Span) error - Internal method that serializes and sends spans via HTTP POST\n- httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) - Helper method that serializes spans using Thrift protocol\n\nAdditional Struct:\n- HTTPBasicAuthCredentials: struct - Holds basic authentication credentials\n  Fields:\n  - username: string - Basic auth username\n  - password: string - Basic auth password",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tc := &HTTPTransport{\n\t\tlogger:    log.NullLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{Timeout: defaultHTTPTimeout},\n\t\tbatchSize: 100,\n\t\tbatch:     []*zipkincore.Span{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(c)\n\t}\n\treturn c, nil\n}\n\nfunc (c *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzSpan := jaeger.BuildZipkinThrift(span)\n\tc.batch = append(c.batch, zSpan)\n\tif len(c.batch) >= c.batchSize {\n\t\treturn c.Flush()\n\t}\n\treturn 0, nil\n}\n\nfunc (c *HTTPTransport) Flush() (int, error) {\n\tcount := len(c.batch)\n\tif count == 0 {\n\t\treturn 0, nil\n\t}\n\terr := c.send(c.batch)\n\tc.batch = c.batch[:0]\n\treturn count, err\n}\n\nfunc (c *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (c *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", c.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif c.httpCredentials != nil {\n\t\treq.SetBasicAuth(c.httpCredentials.username, c.httpCredentials.password)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read response from collector: %s\", err)\n\t}\n\n\tif resp.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"error from collector: code=%d body=%q\", resp.StatusCode, string(respBytes))\n\t}\n\n\treturn nil\n}\n\nfunc httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tt := thrift.NewTMemoryBuffer()\n\tp := thrift.NewTBinaryProtocolTransport(t)\n\tctx := context.Background()\n\tif err := p.WriteListBegin(ctx, thrift.STRUCT, len(spans)); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range spans {\n\t\tif err := s.Write(ctx, p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif err := p.WriteListEnd(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn t.Buffer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/jaegertracing/jaeger\"\n\tzipkin \"github.com/jaegertracing/jaeger/thrift-gen/zipkincore\"\n)\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\ntype HTTPTransport struct {\n\tlogger           jaeger.Logger\n\turl              string\n\tclient           *http.Client\n\tbatchSize        int\n\tbatch            []*zipkin.Span\n\thttpCredentials  *HTTPBasicAuthCredentials\n}\n\ntype HTTPOption func(*HTTPTransport)\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\ttransport := &HTTPTransport{\n\t\turl:       url,\n\t\tbatchSize: 100,\n\t\tbatch:     make([]*zipkin.Span, 0, 100),\n\t\tclient: &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tProxy: nil,\n\t\t\t\tDialContext: (&net.Dialer{\n\t\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t\t}).DialContext,\n\t\t\t\tMaxIdleConns:          100,\n\t\t\t\tIdleConnTimeout:       90 * time.Second,\n\t\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t\t},\n\t\t\tTimeout: 30 * time.Second,\n\t\t},\n\t}\n\n\tfor _, option := range options {\n\t\toption(transport)\n\t}\n\n\tif transport.logger == nil {\n\t\ttransport.logger = jaeger.NullLogger\n\t}\n\n\treturn transport, nil\n}\n\nfunc WithHTTPClient(client *http.Client) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.client = client\n\t}\n}\n\nfunc WithHTTPBatchSize(size int) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.batchSize = size\n\t}\n}\n\nfunc WithHTTPLogger(logger jaeger.Logger) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.logger = logger\n\t}\n}\n\nfunc WithHTTPBasicAuth(credentials HTTPBasicAuthCredentials) HTTPOption {\n\treturn func(t *HTTPTransport) {\n\t\tt.httpCredentials = &credentials\n\t}\n}\n\nfunc (t *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzipkinSpan := t.convertJaegerSpanToZipkin(span)\n\tt.batch = append(t.batch, zipkinSpan)\n\n\tif len(t.batch) >= t.batchSize {\n\t\treturn t.Flush()\n\t}\n\n\treturn len(t.batch), nil\n}\n\nfunc (t *HTTPTransport) Flush() (int, error) {\n\tif len(t.batch) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tspansToSend := t.batch\n\tt.batch = make([]*zipkin.Span, 0, t.batchSize)\n\n\terr := t.send(spansToSend)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(spansToSend), nil\n}\n\nfunc (t *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (t *HTTPTransport) send(spans []*zipkin.Span) error {\n\tbody, err := t.httpSerialize(spans)\n\tif err != nil {\n\t\tt.logger.Error(fmt.Sprintf(\"Failed to serialize spans: %v\", err))\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), \"POST\", t.url, body)\n\tif err != nil {\n\t\tt.logger.Error(fmt.Sprintf(\"Failed to create request: %v\", err))\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif t.httpCredentials != nil {\n\t\tauth := t.httpCredentials.username + \":\" + t.httpCredentials.password\n\t\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(auth)))\n\t}\n\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\tt.logger.Error(fmt.Sprintf(\"HTTP request failed: %v\", err))\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\terrMsg := fmt.Sprintf(\"HTTP server returned status %d\", resp.StatusCode)\n\t\tt.logger.Error(errMsg)\n\t\treturn fmt.Errorf(errMsg)\n\t}\n\n\treturn nil\n}\n\nfunc (t *HTTPTransport) httpSerialize(spans []*zipkin.Span) (*bytes.Buffer, error) {\n\tbuffer := thrift.NewTMemoryBuffer()\n\tprotocol := thrift.NewTBinaryProtocolConf(buffer, &thrift.TConfiguration{})\n\n\t_, err := protocol.WriteListBegin(context.Background(), thrift.STRUCT, len(spans))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, span := range spans {\n\t\terr = span.Write(context.Background(), protocol)\n\t\tif err != nil {\n\t\treturn nil, err\n\t}\n\t}\n\n\terr = protocol.WriteListEnd(context.Background())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buffer, nil\n}\n\nfunc (t *HTTPTransport) convertJaegerSpanToZipkin(span *jaeger.Span) *zipkin.Span {\n\treturn &zipkin.Span{\n\t\tTraceID:           span.TraceID().Low,\n\t\tName:              span.OperationName(),\n\t\tID:                span.SpanID().Low,\n\t\tAnnotations:       []*zipkin.Annotation{},\n\t\tBinaryAnnotations: []*zipkin.BinaryAnnotation{},\n\t}\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both query and write operations with configurable connection settings, authentication, and request parameters.\n\nStruct Description: The Client struct represents an InfluxDB client with configurable connection settings and methods for executing queries and writing data points.\n\nFields:\n\nurl: url.URL - Base URL of the InfluxDB server\nunixSocket: string - Path to Unix domain socket for connection (alternative to TCP)\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nhttpClient: *http.Client - Custom HTTP client with configured transport and timeout\nuserAgent: string - User agent string for HTTP requests\nprecision: string - Default precision for timestamps in queries/writes\n\nMethods:\n\nNewClient: [Name](Config) -> (*Client, error) - Creates a new Client instance with the provided configuration, setting up TLS, proxy, and Unix socket options as needed.\n\nQueryContext: [Name](context.Context, Query) -> (*Response, error) - Executes a query against the InfluxDB server with context support, handling both regular and chunked responses.\n\nWrite: [Name](BatchPoints) -> (*Response, error) - Writes a batch of points to the InfluxDB server, handling serialization and request configuration.\n\nThe Client provides methods for both querying and writing data to InfluxDB with support for:\n- Custom HTTP client configuration (timeouts, TLS, proxies)\n- Unix socket connections\n- Basic authentication\n- Chunked query responses\n- Custom precision for timestamps\n- Context-aware operations\n- Error handling for HTTP and InfluxDB-specific errors",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := new(tls.Config)\n\tif c.TLS != nil {\n\t\ttlsConfig = c.TLS.Clone()\n\t}\n\ttlsConfig.InsecureSkipVerify = c.UnsafeSsl\n\n\ttr := &http.Transport{\n\t\tProxy:           c.Proxy,\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tif c.UnixSocket != \"\" {\n\t\ttr.DisableCompression = true\n\t\ttr.DialContext = func(_ context.Context, _, _ string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", c.UnixSocket)\n\t\t}\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tunixSocket: c.UnixSocket,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"query\")\n\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", q.RetentionPolicy)\n\t}\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif q.NodeID > 0 {\n\t\tvalues.Set(\"node_id\", strconv.Itoa(q.NodeID))\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"POST\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"write\")\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package influxdb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Client represents an InfluxDB client with configurable connection settings\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\n// Config holds configuration options for creating a new InfluxDB client\ntype Config struct {\n\tURL        url.URL\n\tUnixSocket string\n\tUsername   string\n\tPassword   string\n\tHTTPClient *http.Client\n\tUserAgent  string\n\tPrecision  string\n}\n\n// Response represents the response from an InfluxDB server\ntype Response struct {\n\tResults []Result `json:\"results,omitempty\"`\n\tErr     string `json:\"error,omitempty\"`\n}\n\n// Result represents a single result from a query response\ntype Result struct {\n\tSeries  []Series `json:\"series,omitempty\"`\n\tStmtID  int      `json:\"statement_id,omitempty\"`\n\tPartial bool     `json:\"partial,omitempty\"`\n}\n\n// Series represents a series of data points in a result\ntype Series struct {\n\tName    string   `json:\"name,omitempty\"`\n\tTags    map[string]string `json:\"tags,omitempty\"`\n\tColumns []string `json:\"columns,omitempty\"`\n\tValues  [][]interface{} `json:\"values,omitempty\"`\n}\n\n// BatchPoints represents a batch of data points to be written to InfluxDB\ntype BatchPoints struct {\n\tPoints    []Point  `json:\"points\"`\n\tDatabase  string `json:\"database\"`\n\tRetentionPolicy string `json:\"retentionPolicy\"`\n}\n\n// Point represents a single data point\ntype Point struct {\n\tMeasurement string            `json:\"measurement\"`\n\tTags        map[string]string `json:\"tags,omitempty\"`\n\tFields      map[string]interface{} `json:\"fields\"`\n\tTime        time.Time         `json:\"time,omitempty\"`\n}\n\n// Query represents an InfluxDB query request\ntype Query struct {\n\tCommand     string\n\tDatabase    string\n\tRetentionPolicy string\n\tChunked     bool\n\tChunkSize   int\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tif config.HTTPClient == nil {\n\t\ttransport := &http.Transport{\n\t\t\tProxy: http.ProxyURL(nil),\n\t\t\tDialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\t\tif config.UnixSocket != \"\" {\n\t\t\t\t\treturn net.Dial(\"unix\", config.UnixSocket)\n\t\t\t\t}\n\t\t\t\treturn (&net.Dialer{}).DialContext(ctx, network, addr)\n\t\t\t},\n\t\t\tMaxIdleConns:          100,\n\t\t\tIdleConnTimeout:       90 * time.Second,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t}\n\n\t\tconfig.HTTPClient = &http.Client{\n\t\t\tTransport: transport,\n\t\t\tTimeout:   30 * time.Second,\n\t\t}\n\t}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = \"influxdb-client\"\n\t}\n\n\tif config.Precision == \"\" {\n\t\tconfig.Precision = \"n\" // nanoseconds\n\t}\n\n\treturn &Client{\n\t\turl:        config.URL,\n\t\tunixSocket: config.UnixSocket,\n\t\tusername:   config.Username,\n\t\tpassword:   config.Password,\n\t\thttpClient: config.HTTPClient,\n\t\tuserAgent:  config.UserAgent,\n\t\tprecision:  config.Precision,\n\t}, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\tvalues := url.Values{}\n\tvalues.Set(\"q\", q.Command)\n\tif q.Database != \"\" {\n\t\tvalues.Set(\"db\", q.Database)\n\t}\n\tif q.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", q.RetentionPolicy)\n\t}\n\tvalues.Set(\"epoch\", c.precision)\n\n\tendpoint := c.url.ResolveReference(&url.URL{\n\t\tPath:     \"/query\",\n\t\tRawQuery: values.Encode(),\n\t})\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", endpoint.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.Chunked {\n\t\tif q.ChunkSize > 0 {\n\t\t\treq.Header.Set(\"X-Chunk-Size\", fmt.Sprintf(\"%d\", q.ChunkSize))\n\t\t}\n\t\treq.Header.Set(\"X-Chunked\", \"true\")\n\t}\n\n\tif c.username != \"\" || c.password != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, body)\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(response.Results) == 0 && response.Err == \"\" && (resp.StatusCode == 200 || resp.StatusCode == 204) {\n\t\treturn &Response{}, nil\n\t}\n\n\tif response.Err != \"\" {\n\t\treturn nil, fmt.Errorf(\"influxdb error: %s\", response.Err)\n\t}\n\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tbody, err := json.Marshal(bp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalues := url.Values{}\n\tif bp.Database != \"\" {\n\t\tvalues.Set(\"db\", bp.Database)\n\t}\n\tif bp.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", bp.RetentionPolicy)\n\t}\n\tvalues.Set(\"precision\", c.precision)\n\n\tendpoint := c.url.ResolveReference(&url.URL{\n\t\tPath:     \"/write\",\n\t\tRawQuery: values.Encode(),\n\t})\n\n\treq, err := http.NewRequest(\"POST\", endpoint.String(), bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.username != \"\" || c.password != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponseBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, responseBody)\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(responseBody, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets IP TOS (Type of Service) and TTL (Time To Live) values for IPv4 connections, and sends a greeting message to the client.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For each IPv4 connection, it configures the TOS and TTL values using the ipv4 package. It then sends a greeting message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to \"0.0.0.0:1024\" by default)\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving connections)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {\n\t\t\t\tp := ipv4.NewConn(c)\n\t\t\t\tif err := p.SetTOS(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetTTL(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp4\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to bind to port 1024: %v\", err)\n\t}\n\tdefer listener.Close()\n\n\tlog.Println(\"Server listening on port 1024\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\ttcpConn, ok := conn.(*net.TCPConn)\n\tif !ok {\n\t\tlog.Println(\"Connection is not a TCP connection\")\n\t\treturn\n\t}\n\n\tipConn := tcpConn.RemoteAddr().(*net.TCPAddr).IP\n\tif ipConn.To4() == nil {\n\t\tlog.Println(\"Not an IPv4 address, skipping TOS/TTL configuration\")\n\t\treturn\n\t}\n\n\tipv4Conn, err := net.Dial(\"ip4:icmp\", ipConn.String())\n\tif err != nil {\n\t\tlog.Printf(\"Failed to create IPv4 control connection: %v\", err)\n\t\treturn\n\t}\n\tdefer ipv4Conn.Close()\n\n\trawConn, err := ipv4Conn.SyscallConn()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get raw connection: %v\", err)\n\t\treturn\n\t}\n\n\tvar sysErr error\n\terr = rawConn.Control(func(fd uintptr) {\n\t\tsysErr = setTosAndTtl(fd, 0x10, 64)\n\t})\n\tif sysErr != nil {\n\t\tlog.Printf(\"Error setting TOS and TTL: %v\", sysErr)\n\t}\n\n\t_, err = fmt.Fprintf(tcpConn, \"HELLO-R-U-THERE-ACK\\n\")\n\tif err != nil {\n\t\tlog.Printf(\"Failed to send greeting message: %v\", err)\n\t}\n}\n\nfunc setTosAndTtl(fd uintptr, tos int, ttl int) error {\n\t// This function would typically use system calls like setsockopt with IPPROTO_IP,\n\t// IP_TOS and IP_TTL constants to configure TOS and TTL values.\n\t// Actual implementation depends on the OS and may require platform-specific code.\n\treturn nil\n}"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and graceful shutdown capabilities.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - Interface for handling incoming requests\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nShutdownContext(context.Context) error - Gracefully shuts down the server with context support\nisStarted() bool - Helper method to check server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw, writer: w}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) ShutdownContext(ctx context.Context) error {\n\tsrv.lock.Lock()\n\tif !srv.started {\n\t\tsrv.lock.Unlock()\n\t\treturn &Error{err: \"server not started\"}\n\t}\n\n\tsrv.started = false\n\n\tif srv.Listener != nil {\n\t\tsrv.Listener.Close()\n\t}\n\n\tfor rw := range srv.conns {\n\t\trw.SetReadDeadline(aLongTimeAgo)\n\t}\n\n\tsrv.lock.Unlock()\n\n\tvar ctxErr error\n\tselect {\n\tcase <-srv.shutdown:\n\tcase <-ctx.Done():\n\t\tctxErr = ctx.Err()\n\t}\n\n\treturn ctxErr\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeTCP(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr       string\n\tNet        string\n\tHandler    Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tlock         sync.RWMutex\n\tstarted      bool\n\tshutdown     chan struct{}\n\tconns        map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif s.Net == \"\" {\n\t\ts.Net = \"tcp\"\n\t}\n\tln, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.serveTCP(ln)\n}\n\nfunc (s *Server) serveTCP(ln net.Listener) error {\n\ts.lock.Lock()\n\tif s.started {\n\t\ts.lock.Unlock()\n\t\treturn nil\n\t}\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n\ts.lock.Unlock()\n\n\tdefer func() {\n\t\tln.Close()\n\t\tclose(s.shutdown)\n\t\ts.lock.Lock()\n\t\tfor conn := range s.conns {\n\t\t\tconn.Close()\n\t\t}\n\t\ts.conns = nil\n\t\ts.started = false\n\t\ts.lock.Unlock()\n\t}()\n\n\tvar wg sync.WaitGroup\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\ts.serveTCPConn(&wg, conn)\n\t\t}()\n\t}\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer wg.Done()\n\n\ts.lock.Lock()\n\ts.conns[conn] = struct{}{}\n\ts.lock.Unlock()\n\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\tconn.Close()\n\t}()\n\n\tif s.ReadTimeout > 0 {\n\t\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\t}\n\tif s.WriteTimeout > 0 {\n\t\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t}\n\tif idleTimeout := s.IdleTimeout; idleTimeout != nil {\n\t\tconn.SetReadDeadline(time.Now().Add(idleTimeout()))\n\t}\n\n\ts.Handler.ServeTCP(conn)\n}\n\nfunc (s *Server) ShutdownContext(ctx context.Context) error {\n\ts.lock.RLock()\n\tif !s.started {\n\t\ts.lock.RUnlock()\n\t\treturn nil\n\t}\n\ts.lock.RUnlock()\n\n\tclose(s.shutdown)\n\n\twait := make(chan struct{})\n\tgo func() {\n\t\ts.lock.RLock()\n\t\tdefer s.lock.RUnlock()\n\t\tfor conn := range s.conns {\n\t\t\tconn.Close()\n\t\t}\n\t}()\n\t\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase <-wait:\n\t\treturn nil\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Create a Unix domain socket server in Go that listens for incoming connections, handles client communication, and processes received data through a product function. The server should manage connection limits, timeouts, and proper resource cleanup.\n\nStruct Description: The `unix` struct represents a Unix domain socket server with configuration options for path, permissions, and connection handling. It manages the socket lifecycle and processes incoming data.\n\nFields:\n- name: string - Identifier for the server instance\n- config: *Config - Pointer to configuration containing path, mode, timeout, max connections, and max bytes\n- done: chan struct{} - Channel to signal server shutdown\n- eventPool: *event.Pool - Pool for managing event objects\n\nMethods:\n- ProductLoop(productFunc api.ProductFunc) -> void - Main server loop that listens for connections and delegates handling to worker goroutines. Takes a product function for processing events.\n- handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) -> void - Handles individual client connections, reads data, and passes it to the product function. Manages connection timeouts and cleanup.\n- checkBind(path string) -> error - Validates and prepares the socket path by removing existing files if necessary\n- chmod(path string, mode string) -> error - Sets filesystem permissions on the socket file",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/netutil\"\n)\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (k *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", k.String())\n\n\tif err := checkBind(k.config.Path); err != nil {\n\t\tlog.Error(\"check unix sock path error: %+v\", err)\n\t\treturn\n\t}\n\n\tlistener, err := net.Listen(\"unix\", k.config.Path)\n\tif err != nil {\n\t\tlog.Error(\"setup unix listener failed: %v\", err)\n\t\treturn\n\t}\n\n\tif err := chmod(k.config.Path, k.config.Mode); err != nil {\n\t\tlog.Error(\"chmod unix path %s with %s failed: %v\", k.config.Path, k.config.Mode, err)\n\t\treturn\n\t}\n\n\tif k.config.MaxConnections > 0 {\n\t\tlistener = netutil.LimitListener(listener, k.config.MaxConnections)\n\t}\n\n\tdefer listener.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfor {\n\t\tselect {\n\t\tcase <-k.done:\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"unix sock listener accept connection failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo k.handleConn(ctx, conn, productFunc)\n\t}\n}\n\nfunc (k *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuf := bufio.NewReader(conn)\n\tscan := bufio.NewScanner(buf)\n\n\tinitBuffer := make([]byte, k.config.MaxBytes/4)\n\tscan.Buffer(initBuffer, k.config.MaxBytes)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tif err := conn.SetDeadline(time.Now().Add(k.config.Timeout)); err != nil {\n\t\t\tlog.Warn(\"set connection timeout error: %v\", err)\n\t\t}\n\n\t\tif !scan.Scan() {\n\t\t\tif scan.Err() != nil {\n\t\t\t\tlog.Warn(\"scan connection error: %v\", scan.Err())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tbody := scan.Bytes()\n\t\tcopyBody := make([]byte, len(body))\n\t\tcopy(copyBody, body)\n\t\te := k.eventPool.Get()\n\t\te.Fill(e.Meta(), e.Header(), copyBody)\n\n\t\tproductFunc(e)\n\t}\n}\n\nfunc checkBind(path string) error {\n\t_, err := os.Lstat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errors.WithMessagef(err, \"stat path %s failed\", path)\n\t}\n\n\tif err := os.Remove(path); err != nil {\n\t\treturn errors.WithMessagef(err, \"remove path %s failed\", path)\n\t}\n\n\treturn nil\n}\n\nfunc chmod(path string, mode string) error {\n\tparsed, err := strconv.ParseUint(mode, 8, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(path, os.FileMode(parsed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package unix\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\n\t\"api\"\n\t\"event\"\n)\n\ntype Config struct {\n\tPath       string\n\tMode       string\n\tTimeout    time.Duration\n\tMaxConns   int\n\tMaxBytes   int\n}\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (u *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlistener, err := net.Listen(\"unix\", u.config.Path)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to bind: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\terr = u.chmod(u.config.Path, u.config.Mode)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to set permissions: %v\\n\", err)\n\t\treturn\n\t}\n\n\tconns := make(chan net.Conn, u.config.MaxConns)\n\n\tfor i := 0; i < u.config.MaxConns; i++ {\n\t\tgo func() {\n\t\t\tfor conn := range conns {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), u.config.Timeout)\n\t\t\t\tdefer cancel()\n\t\t\t\tu.handleConn(ctx, conn, productFunc)\n\t\t\t}\n\t\t}()\n\t}\n\n\t<-u.done\n\tclose(conns)\n}\n\nfunc (u *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, u.config.MaxBytes)\n\tconn.SetDeadline(time.Now().Add(u.config.Timeout))\n\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Read error: %v\\n\", err)\n\t\treturn\n\t}\n\n\tdata := buffer[:n]\n\teventObj := u.eventPool.Get()\n\tdefer u.eventPool.Put(eventObj)\n\n\teventObj.Data = data\n\tresult, err := productFunc(eventObj)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Product function error: %v\\n\", err)\n\t\treturn\n\t}\n\n\t_, writeErr := conn.Write(result)\n\tif writeErr != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Write error: %v\\n\", writeErr)\n\t}\n}\n\nfunc (u *unix) checkBind(path string) error {\n\tif _, err := os.Stat(path); err == nil {\n\t\terr = os.Remove(path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to remove existing socket file: %w\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *unix) chmod(path string, mode string) error {\n\tperm, err := parseFileMode(mode)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid mode: %w\", err)\n\t}\n\treturn os.Chmod(path, perm)\n}\n\nfunc parseFileMode(modeStr string) (os.FileMode, error) {\n\tvar perm os.FileMode\n\tfmt.Sscanf(modeStr, \"%o\", &perm)\n\treturn perm, nil\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Create a gRPC client in Go that communicates with a Unix domain socket server for various deployment operations.\n\nStruct Description: The DeployClient struct represents a gRPC client that connects to a deployment agent server via Unix domain socket and provides methods for different deployment operations.\n\nFields:\nsocketPath: string - The filesystem path to the Unix domain socket for connecting to the gRPC server\n\nMethods:\nNewDeployClient: [Name](socketPath string) -> *DeployClient - Creates a new DeployClient instance with the specified socket path\nDeployGuestFs: [Name](ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) -> (*deployapi.DeployGuestFsResponse, error) - Deploys guest filesystem\nResizeFs: [Name](ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Resizes filesystem\nFormatFs: [Name](ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Formats filesystem\nSaveToGlance: [Name](ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) -> (*deployapi.SaveToGlanceResponse, error) - Saves image to Glance\nProbeImageInfo: [Name](ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) -> (*deployapi.ImageInfo, error) - Probes image information\nConnectEsxiDisks: [Name](ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) -> (*deployapi.EsxiDisksConnectionInfo, error) - Connects ESXi disks\nDisconnectEsxiDisks: [Name](ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Disconnects ESXi disks",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdeployapi \"yunion.io/x/onecloud/pkg/hostman/hostdeployer/apis\"\n)\n\ntype DeployClient struct {\n\tsocketPath string\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\treturn &DeployClient{socketPath}\n}\n\nfunc grcpDialWithUnixSocket(ctx context.Context, socketPath string) (*grpc.ClientConn, error) {\n\treturn grpc.DialContext(ctx, socketPath, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(time.Second*3),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\tret, err := client.DeployGuestFs(ctx, in, opts...)\n\treturn ret, err\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(\n\tctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption,\n) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(\n\tctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption,\n) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.DisconnectEsxiDisks(ctx, in, opts...)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "package deployclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\tdeployapi \"path/to/deployapi\" // Update with actual import path\n)\n\ntype DeployClient struct {\n\tsocketPath string\n\tconn       *grpc.ClientConn\n\tdeployapi.DeployAgentClient\n}\n\nfunc NewDeployClient(socketPath string) (*DeployClient, error) {\n\tdialer := func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t}\n\n\tconn, err := grpc.Dial(\n\t\tfmt.Sprintf(\"unix://%s\", socketPath),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithContextDialer(dialer),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to gRPC server: %w\", err)\n\t}\n\n\treturn &DeployClient{\n\t\tsocketPath:        socketPath,\n\t\tconn:              conn,\n\t\tDeployAgentClient: deployapi.NewDeployAgentClient(conn),\n\t}, nil\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\treturn c.DeployAgentClient.DeployGuestFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn c.DeployAgentClient.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn c.DeployAgentClient.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\treturn c.DeployAgentClient.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\treturn c.DeployAgentClient.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) (*deployapi.EsxiDisksConnectionInfo, error) {\n\treturn c.DeployAgentClient.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\treturn c.DeployAgentClient.DisconnectEsxiDisks(ctx, in, opts...)\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a function that establishes a secure or insecure gRPC client connection to a server and returns a client instance for making RPC calls.\n\nFunction Description: The function `createGRPCClient` establishes a connection to a gRPC server using the provided server address and security options. It supports both TLS-secured connections (with optional certificate verification) and insecure connections. The function returns a client instance that can be used to make RPC calls to the server.\n\nInput:\n- `serverAddr` (string): The address of the gRPC server in \"host:port\" format\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string, optional): Path to the CA certificate file for TLS verification (required if useTLS is true)\n- `serverHostOverride` (string, optional): Server name used for TLS hostname verification\n\nOutput:\n- `pb.RouteGuideClient`: A gRPC client instance for making RPC calls\n- `*grpc.ClientConn`: The established gRPC connection (should be closed by the caller when done)\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/your/routeguide\" // Update this with your actual package path\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, *grpc.ClientConn, error) {\n\tvar opts []grpc.DialOption\n\n\tif useTLS {\n\t\tvar sn string\n\t\tif serverHostOverride != \"\" {\n\t\t\tsn = serverHostOverride\n\t\t}\n\n\t\tvar creds credentials.TransportCredentials\n\t\tif caFile != \"\" {\n\t\t\tcertPool := x509.NewCertPool()\n\t\t\tca, err := ioutil.ReadFile(caFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"could not read ca certificate file: %v\", err)\n\t\t\t}\n\t\t\tif !certPool.AppendCertsFromPEM(ca) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to append ca certs\")\n\t\t\t}\n\t\t\tcreds = credentials.NewTLS(&tls.Config{\n\t\t\t\tServerName:   sn,\n\t\t\t\tRootCAs:      certPool,\n\t\t\t\tMinVersion:   tls.VersionTLS12,\n\t\t\t})\n\t\t} else {\n\t\t\t// Use system certs if no CA file is provided\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"fail to dial: %v\", err)\n\t}\n\n\tclient := pb.NewRouteGuideClient(conn)\n\treturn client, conn, nil\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a function to send synchronous HTTP requests with custom configurations including headers, authentication, and transport settings.\n\nFunction Description: The function SendWebRequestSync sends an HTTP request with customizable method, headers, body, and authentication. It handles the response, checks for success status codes, and properly manages resources. The function uses a pre-configured HTTP client with custom transport settings for timeout and TLS configuration.\n\nInput:\n- ctx (context.Context): Context for request cancellation and timeouts\n- webhook (*monitor.SendWebhookSync): Pointer to a struct containing request parameters including:\n  - HttpMethod (string): HTTP method (GET, POST, etc.)\n  - Url (string): Target URL\n  - Body (string): Request body content\n  - ContentType (string): Content-Type header value\n  - User (string): Username for basic auth\n  - Password (string): Password for basic auth\n  - HttpHeader (map[string]string): Additional HTTP headers\n\nOutput:\n- error: Returns nil on success (2xx status code), or an error describing the failure (non-2xx status code or transport error)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/context/ctxhttp\"\n\t\"moul.io/http2curl/v2\"\n\n\t\"yunion.io/x/log\"\n\n\t\"yunion.io/x/onecloud/pkg/apis/monitor\"\n)\nvar netTransport = &http.Transport{\n\tTLSClientConfig: &tls.Config{\n\t\tRenegotiation: tls.RenegotiateFreelyAsClient,\n\t},\n\tProxy: http.ProxyFromEnvironment,\n\tDialContext: (&net.Dialer{\n\t\tTimeout: 30 * time.Second,\n\t}).DialContext,\n\tTLSHandshakeTimeout: 5 * time.Second,\n}\nvar netClient = &http.Client{\n\tTimeout:   time.Second * 30,\n\tTransport: netTransport,\n}\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tif webhook.HttpMethod == \"\" {\n\t\twebhook.HttpMethod = http.MethodPost\n\t}\n\n\trequest, err := http.NewRequest(webhook.HttpMethod, webhook.Url, bytes.NewReader([]byte(webhook.Body)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif webhook.ContentType == \"\" {\n\t\twebhook.ContentType = \"application/json\"\n\t}\n\n\trequest.Header.Add(\"Content-Type\", webhook.ContentType)\n\trequest.Header.Add(\"User-Agent\", \"OneCloud Monitor\")\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\trequest.Header.Add(\"Authorization\", GetBasicAuthHeader(webhook.User, webhook.Password))\n\t}\n\n\tfor k, v := range webhook.HttpHeader {\n\t\trequest.Header.Set(k, v)\n\t}\n\n\tcurlCmd, _ := http2curl.GetCurlCommand(request)\n\tlog.Debugf(\"webhook curl: %s\", curlCmd)\n\n\tresp, err := ctxhttp.Do(ctx, netClient, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 == 2 {\n\t\tif _, err := io.Copy(ioutil.Discard, resp.Body); err != nil {\n\t\t\tlog.Errorf(\"Failed to copy resp.Body to ioutil.Discard: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Errorf(\"Webhook failed statuscode: %s, body: %s\", resp.Status, string(body))\n\treturn fmt.Errorf(\"Webhook response status %v\", resp.Status)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Webhook struct {\n\tHttpMethod  string\n\tUrl         string\n\tBody        string\n\tContentType string\n\tUser        string\n\tPassword    string\n\tHttpHeader  map[string]string\n}\n\nfunc SendWebRequestSync(ctx context.Context, webhook *Webhook) error {\n\tbody := bytes.NewBuffer([]byte(webhook.Body))\n\treq, err := http.NewRequestWithContext(ctx, webhook.HttpMethod, webhook.Url, body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\tif webhook.ContentType != \"\" {\n\t\treq.Header.Set(\"Content-Type\", webhook.ContentType)\n\t} else {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\n\tif webhook.User != \"\" || webhook.Password != \"\" {\n\t\tauth := webhook.User + \":\" + webhook.Password\n\t\tbasicAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(auth))\n\t\treq.Header.Set(\"Authorization\", basicAuth)\n\t}\n\n\tfor k, v := range webhook.HttpHeader {\n\t\treq.Header.Set(k, v)\n\t}\n\n\ttransport := &http.Transport{\n\t\tProxy: nil,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   30 * time.Second,\n\t\t\tKeepAlive: 30 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          100,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   30 * time.Second,\n\t}\n\n\tresp, doErr := client.Do(req)\n\tif doErr != nil {\n\t\treturn fmt.Errorf(\"request failed: %w\", doErr)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tbodyBytes, readErr := ioutil.ReadAll(resp.Body)\n\t\tif readErr != nil {\n\t\t\treturn fmt.Errorf(\"non-2xx status code: %d and failed to read body: %v\", resp.StatusCode, readErr)\n\t\t}\n\t\treturn fmt.Errorf(\"non-2xx status code: %d, response: %s\", resp.StatusCode, bodyBytes)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a server, with optional TLS security, and returns a client instance for a specified service.\n\nFunction Description: The function `createGRPCClient` initializes a gRPC client connection to a specified server address. It supports both secure (TLS) and insecure connections based on input parameters. After establishing the connection, it creates and returns a client instance for the RouteGuide service.\n\nInput: \n- `serverAddr` (string): The address of the gRPC server to connect to\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string): Path to the CA certificate file (required if useTLS is true)\n- `serverHostOverride` (string): Server name used for TLS host verification\n\nOutput:\n- `pb.RouteGuideClient`: The generated gRPC client instance for the RouteGuide service\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/examples/data\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tif *caFile == \"\" {\n\t\t\t*caFile = data.Path(\"x509/ca_cert.pem\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tconn, err := grpc.NewClient(*serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"path/to/your/routeguide\" // Update with actual package path\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, error) {\n\tvar opts []grpc.DialOption\n\n\tif useTLS {\n\t\tif caFile == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"caFile must be provided when TLS is enabled\")\n\t\t}\n\n\t\tcreds, err := credentials.NewClientTLSFromFile(caFile, serverHostOverride)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create TLS credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\n\tclient := pb.NewRouteGuideClient(conn)\n\treturn client, nil\n}"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: The task involves creating a gRPC probe client in Go that can establish connections to gRPC servers, perform various probe operations (echo, read, write), and collect metrics about the probe results.\n\nStruct Description: The Probe struct represents a gRPC probe client that manages connections to multiple targets, performs probe operations, and tracks results.\n\nFields:\n\nname: [string] - The name of the probe instance\nsrc: [string] - The source identifier for the probe\nopts: [*options.Options] - Configuration options for the probe\nc: [*configpb.ProbeConf] - gRPC probe-specific configuration\nl: [*logger.Logger] - Logger for recording probe events\ndialOpts: [[]grpc.DialOption] - Options for gRPC dialing\ntargets: [[]endpoint.Endpoint] - List of target endpoints to probe\ncancelFuncs: [map[string]context.CancelFunc] - Map of cancel functions for target operations\ntargetsMu: [sync.Mutex] - Mutex for synchronizing access to targets\nresults: [map[string]*probeRunResult] - Map of probe results by target\n\nMethods:\n\nconnectWithRetry: [func(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn] -> [*grpc.ClientConn] - Establishes a gRPC connection to the target with retry logic, using the specified context, target address, message pattern, and result tracker. Returns the established connection or nil if failed.\n\noneTargetLoop: [func(ctx context.Context, tgt string, index int, result *probeRunResult)] -> [None] - Main probe loop for a single target that continuously performs probe operations (echo/read/write) at regular intervals, using the specified context, target address, target index, and result tracker. Manages connection lifecycle and records metrics.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/google/cloudprober/logger\"\n\t\"github.com/google/cloudprober/metrics\"\n\tconfigpb \"github.com/google/cloudprober/probes/grpc/proto\"\n\t\"github.com/google/cloudprober/probes/options\"\n\t\"github.com/google/cloudprober/probes/probeutils\"\n\t\"github.com/google/cloudprober/targets/endpoint\"\n\n\tgrpcprobepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\tservicepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\t\"google.golang.org/grpc/credentials/local\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype Probe struct {\n\tname     string\n\tsrc      string\n\topts     *options.Options\n\tc        *configpb.ProbeConf\n\tl        *logger.Logger\n\tdialOpts []grpc.DialOption\n\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\n\tresults map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\tsync.Mutex\n\ttarget        string\n\ttotal         metrics.Int\n\tsuccess       metrics.Int\n\tlatency       metrics.Value\n\tconnectErrors metrics.Int\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tconnectTimeout := p.opts.Timeout\n\tif p.c.GetConnectTimeoutMsec() > 0 {\n\t\tconnectTimeout = time.Duration(p.c.GetConnectTimeoutMsec()) * time.Millisecond\n\t}\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in connect loop.\", msgPattern)\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\t\tconnCtx, cancelFunc := context.WithTimeout(ctx, connectTimeout)\n\n\t\tif uriScheme := p.c.GetUriScheme(); uriScheme != \"\" {\n\t\t\ttgt = uriScheme + tgt\n\t\t}\n\t\tconn, err = grpc.DialContext(connCtx, tgt, p.dialOpts...)\n\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tp.l.Warningf(\"ProbeId(%v) connect error: %v\", msgPattern, err)\n\t\t} else {\n\t\t\tp.l.Infof(\"ProbeId(%v) connection established.\", msgPattern)\n\t\t\tbreak\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.connectErrors.Inc()\n\t\tresult.Unlock()\n\t}\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tmsgPattern := fmt.Sprintf(\"%s,%s%s,%03d\", p.src, p.c.GetUriScheme(), tgt, index)\n\n\tconn := p.connectWithRetry(ctx, tgt, msgPattern, result)\n\tif conn == nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := servicepb.NewProberClient(conn)\n\ttimeout := p.opts.Timeout\n\tmethod := p.c.GetMethod()\n\n\tmsgSize := p.c.GetBlobSize()\n\tmsg := make([]byte, msgSize)\n\tprobeutils.PatternPayload(msg, []byte(msgPattern))\n\tticker := time.NewTicker(p.opts.Interval)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in request loop.\", msgPattern)\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t}\n\n\t\treqCtx, cancelFunc := context.WithTimeout(ctx, timeout)\n\t\tvar success int64\n\t\tvar delta time.Duration\n\t\tstart := time.Now()\n\t\tvar err error\n\t\tvar peer peer.Peer\n\t\topts := []grpc.CallOption{\n\t\t\tgrpc.WaitForReady(true),\n\t\t\tgrpc.Peer(&peer),\n\t\t}\n\t\tswitch method {\n\t\tcase configpb.ProbeConf_ECHO:\n\t\t\treq := &grpcprobepb.EchoMessage{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.Echo(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_READ:\n\t\t\treq := &grpcprobepb.BlobReadRequest{\n\t\t\t\tSize: proto.Int32(msgSize),\n\t\t\t}\n\t\t\t_, err = client.BlobRead(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_WRITE:\n\t\t\treq := &grpcprobepb.BlobWriteRequest{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.BlobWrite(reqCtx, req, opts...)\n\t\tdefault:\n\t\t\tp.l.Criticalf(\"Method %v not implemented\", method)\n\t\t}\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tpeerAddr := \"unknown\"\n\t\t\tif peer.Addr != nil {\n\t\t\t\tpeerAddr = peer.Addr.String()\n\t\t\t}\n\t\t\tp.l.Warningf(\"ProbeId(%s) request failed: %v. ConnState: %v. Peer: %v\", msgPattern, err, conn.GetState(), peerAddr)\n\t\t} else {\n\t\t\tsuccess = 1\n\t\t\tdelta = time.Since(start)\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.success.AddInt64(success)\n\t\tresult.latency.AddFloat64(delta.Seconds() / p.opts.LatencyUnit.Seconds())\n\t\tresult.Unlock()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "package probe\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/yourorg/yourrepo/configpb\"\n\t\"github.com/yourorg/yourrepo/endpoint\"\n\t\"github.com/yourorg/yourrepo/logger\"\n\t\"github.com/yourorg/yourrepo/options\"\n\t\"github.com/yourorg/yourrepo/prober\"\n)\n\ntype Probe struct {\n\tname       string\n\tsrc        string\n\topts       *options.Options\n\tc          *configpb.ProbeConf\n\tl          *logger.Logger\n\tdialOpts   []grpc.DialOption\n\ttargets    []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\tresults     map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\tlastSuccess time.Time\n\tlastFailure time.Time\n\tsuccessCount int64\n\tfailureCount int64\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tvar conn *grpc.ClientConn\n\tvar err error\n\n\tbackoff := time.NewTicker(p.opts.InitialRetryDelay)\n\tdefer backoff.Stop()\n\n\ttimeoutTimer := time.NewTimer(p.opts.ConnectionTimeout)\n\tdefer timeoutTimer.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-timeoutTimer.C:\n\t\t\tp.l.Error(\"Connection timed out\", \"target\", tgt)\n\t\t\tresult.failureCount++\n\t\t\tresult.lastFailure = time.Now()\n\t\t\treturn nil\n\t\tcase <-backoff.C:\n\t\t\tconn, err = grpc.DialContext(ctx, tgt, p.dialOpts...)\n\t\t\tif err == nil {\n\t\t\t\tresult.successCount++\n\t\t\t\tresult.lastSuccess = time.Now()\n\t\t\t\treturn conn\n\t\t\t}\n\t\t\tp.l.Warn(\"Connection attempt failed\", \"target\", tgt, \"error\", err)\n\t\t\tresult.failureCount++\n\t\t\tresult.lastFailure = time.Now()\n\n\t\t\tif !p.opts.ShouldRetry(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tvar conn *grpc.ClientConn\n\tvar client prober.ProbeServiceClient\n\tvar err error\n\n\tticker := time.NewTicker(p.opts.Interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif conn != nil {\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tif conn == nil || !isConnectionAlive(conn) {\n\t\t\t\tif conn != nil {\n\t\t\t\t\tconn.Close()\n\t\t\t\t}\n\t\t\t\tconn = p.connectWithRetry(ctx, tgt, p.opts.MessagePattern, result)\n\t\t\t\tif conn == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tclient = prober.NewProbeServiceClient(conn)\n\t\t\t}\n\n\t\t\terr = p.performProbeOperation(ctx, client, tgt, p.opts.Operation, p.opts.MessagePattern)\n\t\t\tif err != nil {\n\t\t\t\tp.l.Error(\"Probe operation failed\", \"target\", tgt, \"error\", err)\n\t\t\t\tresult.failureCount++\n\t\t\t\tresult.lastFailure = time.Now()\n\t\t\t} else {\n\t\t\t\tresult.successCount++\n\t\t\t\tresult.lastSuccess = time.Now()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isConnectionAlive(conn *grpc.ClientConn) bool {\n\tstate := conn.GetState()\n\treturn state == connectivity.Ready\n}\n\nfunc (p *Probe) performProbeOperation(ctx context.Context, client prober.ProbeServiceClient, target string, operation string, messagePattern string) error {\n\tswitch operation {\n\tcase \"echo\":\n\t\t_, err := client.Echo(ctx, &prober.EchoRequest{Message: messagePattern})\n\t\treturn err\n\tcase \"read\":\n\t\t_, err := client.Read(ctx, &prober.ReadRequest{})\n\t\treturn err\n\tcase \"write\":\n\t\t_, err := client.Write(ctx, &prober.WriteRequest{Data: []byte(messagePattern)})\n\t\treturn err\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown operation: %s\", operation)\n\t}\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a function that demonstrates how to establish a gRPC client connection, make a login request to a user service, and handle the response.\n\nFunction Description: The function connects to a gRPC server at a specified address, creates a client for the User service, sends a login request with account credentials, and returns the authentication token. It includes error handling and connection cleanup.\n\nInput: \n- serviceAddress (string): The address of the gRPC server in \"host:port\" format\n- account (string): The user's account name for login\n- password (string): The user's password for login\n\nOutput:\n- token (string): The authentication token returned by the server upon successful login\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function assumes the existence of generated gRPC client code from a protobuf definition that includes a User service with RpcUserLogin method.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v5/v5_user/pb\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(v5_service.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\" // Update with actual path to generated protobuf package\n)\n\nfunc loginToUserService(serviceAddress, account, password string) (string, error) {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not connect to gRPC server: %v\", err)\n\t}\n\tdefer func() {\n\t\tif closeErr := conn.Close(); closeErr != nil {\n\t\t\tlog.Printf(\"Error closing connection: %v\", closeErr)\n\t\t}\n\t}()\n\n\tclient := pb.NewUserServiceClient(conn)\n\n\tctx := context.Background()\n\treq := &pb.UserLoginRequest{\n\t\tAccount:  account,\n\t\tPassword: password,\n\t}\n\n\tresp, err := client.RpcUserLogin(ctx, req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"login request failed: %v\", err)\n\t}\n\n\treturn resp.GetToken(), nil\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a login request, and retrieves an authentication token.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a gRPC client for the User service, sends a login request with account credentials, and returns the authentication token received from the server. The function includes error handling and connection cleanup.\n\nInput:\n- serviceAddress (string): The address of the gRPC server in format \"host:port\"\n- account (string): The user account name for login\n- password (string): The user password for login\n\nOutput:\n- token (string): The authentication token returned by the server\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function generates a unique request UUID for tracking purposes and uses insecure connection (for testing purposes only). In production, you should use proper TLS credentials.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\n// Assuming the following proto-generated packages and structures:\n// import pb \"path/to/your/protobuf/package\"\n\n// LoginRequest represents the request message for logging in a user\ntype LoginRequest struct {\n\tUuid     string `protobuf:\"bytes,1,opt,name=uuid,proto3\" json:\"uuid,omitempty\"`\n\tAccount  string `protobuf:\"bytes,2,opt,name=account,proto3\" json:\"account,omitempty\"`\n\tPassword string `protobuf:\"bytes,3,opt,name=password,proto3\" json:\"password,omitempty\"`\n}\n\n// LoginResponse represents the response message after successful login\ntype LoginResponse struct {\n\tToken string `protobuf:\"bytes,1,opt,name=token,proto3\" json:\"token,omitempty\"`\n}\n\n// UserServiceClient is the client API for UserService service.\n// type UserServiceClient interface {\n// \tLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)\n// }\n\nfunc GetAuthenticationToken(serviceAddress, account, password string) (string, error) {\n\t// Create a gRPC connection to the server\n\tconn, err := grpc.NewClient(serviceAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer conn.Close()\n\n\t// Create a context with timeout\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t// Create the user service client\n\tclient := NewUserServiceClient(conn)\n\n\t// Generate a unique request UUID (for simplicity we're using a static one here; use a proper UUID library in production)\n\trequestUuid := \"request-unique-id-12345\"\n\n\t// Create the login request\n\treq := &LoginRequest{\n\t\tUuid:     requestUuid,\n\t\tAccount:  account,\n\t\tPassword: password,\n\t}\n\n\t// Send the login request\n\tresponse, err := client.Login(ctx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Return the authentication token\n\treturn response.Token, nil\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Implement an HTTP probe function that checks the availability and correctness of a remote HTTP service by making a GET request with custom headers and verifying the response.\n\nFunction Description: The function performs an HTTP probe to a specified URL with custom configuration including timeout, headers, and TLS settings. It verifies the response status code and optionally checks for a success flag in the response body. The function logs the probe results and returns a success/failure status.\n\nInput:\n- protocol: string - The protocol to use (http/https)\n- address: string - The target server address\n- path: string - The request path\n- port: int - The target port number\n- headerList: []*types.HTTPHeader - List of custom HTTP headers to include\n- timeout: time.Duration - Request timeout duration\n- responseSuccessFlag: string - Optional string to check in response body for success\n- log: *zap.SugaredLogger - Logger for recording probe results\n\nOutput:\n- string - Probe result status (Success/Failure)\n- error - Error details if probe fails",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/koderover/zadig/v2/pkg/types\"\n\t\"go.uber.org/zap\"\n)\nfunc doHTTPProbe(protocol, address, path string, port int, headerList []*types.HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\ttlsConfig := &tls.Config{InsecureSkipVerify: true}\n\ttransport := &http.Transport{\n\t\tTLSClientConfig:   tlsConfig,\n\t\tDisableKeepAlives: true,\n\t\tProxy:             http.ProxyURL(nil),\n\t}\n\tclient := &http.Client{\n\t\tTimeout:       timeout,\n\t\tTransport:     transport,\n\t\tCheckRedirect: redirectChecker(false),\n\t}\n\turl, err := formatURL(protocol, address, path, port)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\theaders := buildHeader(headerList)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\treq.Header = headers\n\treq.Host = headers.Get(\"Host\")\n\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\n\tif res.StatusCode >= http.StatusOK && res.StatusCode < http.StatusBadRequest {\n\t\tif responseSuccessFlag != \"\" && !strings.Contains(string(body), responseSuccessFlag) {\n\t\t\treturn Failure, fmt.Errorf(\"HTTP probe failed with response success flag: %s\", responseSuccessFlag)\n\t\t}\n\t\tlog.Infof(\"Probe succeeded for %s, Response: %v\", url, *res)\n\t\treturn Success, nil\n\t}\n\tlog.Warnf(\"Probe failed for %s, response body: %v\", url, string(body))\n\treturn Failure, fmt.Errorf(\"HTTP probe failed with statuscode: %d\", res.StatusCode)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\ntype HTTPHeader struct {\n\tName  string\n\tValue string\n}\n\nfunc httpProbe(protocol, address, path string, port int, headerList []*HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\turl := fmt.Sprintf(\"%s://%s:%d/%s\", protocol, address, port, path)\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to create request: %v\", err)\n\t\treturn \"Failure\", err\n\t}\n\n\tfor _, h := range headerList {\n\t\treq.Header.Set(h.Name, h.Value)\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy: nil,\n\t\t\tDialContext: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).DialContext,\n\t\t\tMaxIdleConns:          1,\n\t\t\tIdleConnTimeout:       30 * time.Second,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Errorf(\"Request failed: %v\", err)\n\t\treturn \"Failure\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to read response body: %v\", err)\n\t\treturn \"Failure\", err\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tlog.Errorf(\"Unexpected status code: %d\", resp.StatusCode)\n\t\treturn \"Failure\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tif responseSuccessFlag != \"\" && !bytes.Contains(body, []byte(responseSuccessFlag)) {\n\t\tlog.Errorf(\"Success flag %q not found in response body\", responseSuccessFlag)\n\t\treturn \"Failure\", fmt.Errorf(\"success flag %q not found in response body\", responseSuccessFlag)\n\t}\n\n\tlog.Infof(\"Probe successful. Status: %d, Body contains success flag: %v\", resp.StatusCode, responseSuccessFlag != \"\")\n\treturn \"Success\", nil\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a function that retrieves metadata from a Google Cloud instance using a custom HTTP client with specific headers and returns both the metadata value and its ETag.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the Google Cloud metadata server to fetch instance metadata. It uses a custom HTTP client with timeout configurations and sets required headers (\"Metadata-Flavor\" and \"User-Agent\"). The function handles various response scenarios including errors and not-found statuses, and returns the metadata value along with its ETag if successful.\n\nInput:\n- `client` (*http.Client): A custom HTTP client configured with specific timeout settings\n- `suffix` (string): The metadata path suffix to append to the base metadata URL\n\nOutput:\n- `value` (string): The retrieved metadata value\n- `etag` (string): The ETag header value from the response\n- `err` (error): Any error encountered during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getETag(client *http.Client, suffix string) (value string, etag string, err error) {\n\tbaseURL := \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n\turl := baseURL + suffix\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", \"Custom-User-Agent\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", fmt.Errorf(\"metadata not found\")\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code %d: %s\", resp.StatusCode, string(body))\n\t}\n\n\tetag = resp.Header.Get(\"ETag\")\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn string(body), etag, nil\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles greeting requests and responses.\n\nStruct Description: The server struct implements the GreeterServer interface generated from the protobuf definition, providing the SayHello method to handle incoming gRPC requests.\n\nFields:\nUnimplementedGreeterServer: pb.UnimplementedGreeterServer - Embedded type to ensure forward compatibility with future gRPC updates\n\nMethods:\nSayHello: [Name](ctx context.Context, in *pb.HelloRequest) -> (*pb.HelloReply, error) - Processes incoming HelloRequest, logs the received name, and returns a HelloReply with a greeting message",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a function that sends a multipart/form-data POST request to a specified URL with file upload capabilities and custom headers.\n\nFunction Description: The function performs an HTTP POST request with multipart form data, including file upload functionality. It constructs the request with custom headers, sends it using a custom HTTP client, and returns the response body as a string. The function handles file operations and request/response lifecycle properly with appropriate error handling.\n\nInput:\n- url (string): The target URL for the POST request\n- method (string): HTTP method (typically \"POST\")\n- filePath (string): Path to the file to be uploaded\n- formFields (map[string]string): Key-value pairs for form fields\n- headers (map[string]string): Custom headers to include in the request\n\nOutput:\n- (string): The response body from the server\n- (error): Any error that occurred during the process (nil if successful)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/image/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"image_signature\", \"1faaf9020e0df18fdf0429e0db211f37\")\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\")\n\tdefer file.Close()\n\tpart4,\n\t\terrFile4 := writer.CreateFormFile(\"image_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\t_ = writer.WriteField(\"filename\", \"auto4_huchao.1faaf9020e0df18fdf0429e0db211f37_test\u73af\u5883slicess_\u5361\u901a_P_HC_HC_en_1X1_0s\")\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc sendMultipartRequest(url, method, filePath string, formFields map[string]string, headers map[string]string) (string, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\tdefer cancel()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tif filePath != \"\" {\n\t\tfile, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"error opening file: %v\", err)\n\t\t}\n\t\tdefer file.Close()\n\n\t\tpart, err := writer.CreateFormFile(\"file\", filePath)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"error creating form file: %v\", err)\n\t\t}\n\n\t\tif _, err := io.Copy(part, file); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"error copying file content: %v\", err)\n\t\t}\n\t}\n\n\tfor key, value := range formFields {\n\t\tif err := writer.WriteField(key, value); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"error writing form field: %v\", err)\n\t\t}\n\t}\n\n\tif err := writer.Close(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"error closing writer: %v\", err)\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, method, url, body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy: nil,\n\t\t\tDialContext: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).DialContext,\n\t\t\tMaxIdleConns:          100,\n\t\t\tIdleConnTimeout:       90 * time.Second,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\n\treturn string(respBody), nil\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles DNS queries and watch functionality, supporting TLS encryption and OpenTracing for distributed tracing.\n\nStruct Description: ServergRPC is a gRPC server implementation that processes DNS queries and provides watch capabilities. It manages server lifecycle, handles TLS configuration, and integrates with tracing systems.\n\nFields:\n\nServer: [*Server] - Embedded DNS server instance that handles core DNS functionality\ngrpcServer: [*grpc.Server] - The gRPC server instance\nlistenAddr: [net.Addr] - Network address the server is listening on\ntlsConfig: [*tls.Config] - TLS configuration for secure connections\nwatch: [watch.Watcher] - Watcher instance for handling watch requests\n\nMethods:\n\nNewServergRPC: [func(addr string, group []*Config) (*ServergRPC, error)] -> Creates a new ServergRPC instance with the given address and configuration group\nServe: [func(l net.Listener) error] -> Starts the gRPC server on the provided listener\nQuery: [func(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error)] -> Handles incoming DNS query requests\nWatch: [func(stream pb.DnsService_WatchServer) error] -> Handles watch stream requests\nStop: [func() error] -> Gracefully stops the server and watcher\nShutdown: [func() error] -> Immediately stops the server without waiting for connections to close",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/coredns/coredns/pb\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/miekg/dns\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype ServergRPC struct {\n\t*Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ts, err := NewServer(addr, group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar tlsConfig *tls.Config\n\tfor _, conf := range s.zones {\n\t\ttlsConfig = conf.TLSConfig\n\t}\n\treturn &ServergRPC{Server: s, tlsConfig: tlsConfig, watch: watch.NewWatcher(watchables(s.zones))}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\ts.m.Lock()\n\ts.listenAddr = l.Addr()\n\ts.m.Unlock()\n\n\tif s.Tracer() != nil {\n\t\tonlyIfParent := func(parentSpanCtx opentracing.SpanContext, method string, req, resp interface{}) bool {\n\t\t\treturn parentSpanCtx != nil\n\t\t}\n\t\tintercept := otgrpc.OpenTracingServerInterceptor(s.Tracer(), otgrpc.IncludingSpans(onlyIfParent))\n\t\ts.grpcServer = grpc.NewServer(grpc.UnaryInterceptor(intercept))\n\t} else {\n\t\ts.grpcServer = grpc.NewServer()\n\t}\n\n\tpb.RegisterDnsServiceServer(s.grpcServer, s)\n\n\tif s.tlsConfig != nil {\n\t\tl = tls.NewListener(l, s.tlsConfig)\n\t}\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tmsg := new(dns.Msg)\n\terr := msg.Unpack(in.Msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, ok := peer.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, errors.New(\"no peer in gRPC context\")\n\t}\n\n\ta, ok := p.Addr.(*net.TCPAddr)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no TCP peer in gRPC context: %v\", p.Addr)\n\t}\n\n\tw := &gRPCresponse{localAddr: s.listenAddr, remoteAddr: a, Msg: msg}\n\n\ts.ServeDNS(ctx, w, msg)\n\n\tpacked, err := w.Msg.Pack()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.DnsPacket{Msg: packed}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\treturn s.watch.Watch(stream)\n}\n\nfunc (s *ServergRPC) Stop() (err error) {\n\ts.m.Lock()\n\tdefer s.m.Unlock()\n\tif s.watch != nil {\n\t\ts.watch.Stop()\n\t}\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.GracefulStop()\n\t}\n\treturn\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.Stop()\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/miekg/dns\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"gopkg.in/yaml.v2\"\n\n\t// Assuming imported packages include necessary modules:\n\t// - \"github.com/opentracing/opentracing-go\"\n\t// - \"github.com/yourorg/yourproject/watch\"\n\t// - \"github.com/yourorg/yourproject/pb\"\n)\n\nvar log = grpclog.LoggerV2()\n\ntype Config struct {\n\tName string `yaml:\"name\"`\n\tHost string `yaml:\"host\"`\n\tPort int    `yaml:\"port\"`\n}\n\ntype Server struct {\n\t// Core DNS server functionality\n\tserveMux *dns.ServeMux\n}\n\nfunc (s *Server) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\ts.serveMux.ServeDNS(w, r)\n}\n\ntype ServergRPC struct {\n\tServer     *Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\tserver := &dns.Server{Addr: addr, Net: \"udp\"}\n\tserveMux := dns.NewServeMux()\n\tserver.Handler = serveMux\n\n\t// Set up TLS configuration\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: false,\n\t\tMinVersion:         tls.VersionTLS12,\n\t}\n\n\t// gRPC server with OpenTracing interceptor\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.Creds(credentials.NewTLS(tlsConfig)),\n\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\tspan, ctx := opentracing.StartSpanFromContext(ctx, info.FullMethod)\n\t\t\tdefer span.Finish()\n\t\t\treturn handler(ctx, req)\n\t\t}),\n\t\tgrpc.StreamInterceptor(func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n\t\t\tspan, ctx := opentracing.StartSpanFromContext(ss.Context(), info.FullMethod)\n\t\t\tdefer span.Finish()\n\t\t\twrapped := grpc.ServerTransportStreamWithContext(ss, ctx)\n\t\t\treturn handler(srv, wrapped)\n\t\t}),\n\t)\n\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twatcher, err := watch.NewWatcher()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ServergRPC{\n\t\tServer: &Server{\n\t\t\tserveMux: serveMux,\n\t\t},\n\t\tgrpcServer: grpcServer,\n\t\tlistenAddr: listener.Addr(),\n\t\ttlsConfig:  tlsConfig,\n\t\twatch:      watcher,\n\t}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\tpb.RegisterDnsServiceServer(s.grpcServer, s)\n\tlog.Infof(\"Starting gRPC server on %s\", l.Addr().String())\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\treq := new(dns.Msg)\n\tif err := req.Unpack(in.Data); err != nil {\n\t\treturn nil, err\n\t}\n\n\trsp := s.serveMux.HandleQuery(req)\n\n\tdata, err := rsp.Pack()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.DnsPacket{\n\t\tData: data,\n\t}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\tctx := stream.Context()\n\tcancelCtx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-cancelCtx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\treq, err := stream.Recv()\n\t\t\t\tif err != nil {\n\t\t\t\t\terrCh <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ts.watch.Notify(req.Key)\n\t\t\t}\n\t\t}\n\t}()\n\n\tsub := s.watch.Subscribe()\n\tdefer s.watch.Unsubscribe(sub)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-cancelCtx.Done():\n\t\t\treturn <-errCh\n\t\tcase event := <-sub.Events:\n\t\t\tif err := stream.Send(&pb.WatchResponse{\n\t\t\t\tEvent: event.Type.String(),\n\t\t\t\tKey:   event.Key,\n\t\t\t\tValue: event.Value,\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *ServergRPC) Stop() error {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\ts.grpcServer.GracefulStop()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(5 * time.Second):\n\t\treturn s.Shutdown()\n\t}\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\ts.grpcServer.Stop()\n\treturn nil\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a function to push metrics to a Prometheus push gateway using HTTP requests with custom headers and client configuration.\n\nFunction Description: The function `doPush` sends collected metrics to a Prometheus push gateway. It validates the job name and grouping labels, constructs the appropriate URL, encodes the metrics in Protocol Buffer format, and makes an HTTP request with custom headers. It handles errors during the process and checks the response status.\n\nInput:\n- `job` (string): The job name to associate with the pushed metrics\n- `grouping` (map[string]string): Key-value pairs for metric grouping\n- `pushURL` (string): The base URL of the Prometheus push gateway\n- `g` (prometheus.Gatherer): Interface to gather metrics\n- `method` (string): HTTP method to use for the request (e.g., \"POST\")\n\nOutput:\n- `error`: Returns nil on success, or an error describing any failure during the push operation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/common/model\"\n)\n\nconst contentTypeHeader = \"Content-Type\"\n\nvar (\n\tclient         = &http.Client{}\n\tdefaultTimeout = time.Second * 15\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif !strings.Contains(pushURL, \"://\") {\n\t\tpushURL = \"http://\" + pushURL\n\t}\n\tif strings.HasSuffix(pushURL, \"/\") {\n\t\tpushURL = pushURL[:len(pushURL)-1]\n\t}\n\n\tif strings.Contains(job, \"/\") {\n\t\treturn fmt.Errorf(\"job contains '/': %s\", job)\n\t}\n\turlComponents := []string{url.QueryEscape(job)}\n\tfor ln, lv := range grouping {\n\t\tif !model.LabelName(ln).IsValid() {\n\t\t\treturn fmt.Errorf(\"grouping label has invalid name: %s\", ln)\n\t\t}\n\t\tif strings.Contains(lv, \"/\") {\n\t\t\treturn fmt.Errorf(\"value of grouping label %s contains '/': %s\", ln, lv)\n\t\t}\n\t\turlComponents = append(urlComponents, ln, lv)\n\t}\n\tpushURL = fmt.Sprintf(\"%s/metrics/job/%s\", pushURL, strings.Join(urlComponents, \"/\"))\n\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtProtoDelim)\n\tfor _, mf := range mfs {\n\t\tfor _, m := range mf.GetMetric() {\n\t\t\tfor _, l := range m.GetLabel() {\n\t\t\t\tif l.GetName() == \"job\" {\n\t\t\t\t\treturn fmt.Errorf(\"pushed metric %s (%s) already contains a job label\", mf.GetName(), m)\n\t\t\t\t}\n\t\t\t\tif _, ok := grouping[l.GetName()]; ok {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"pushed metric %s (%s) already contains grouping label %s\",\n\t\t\t\t\t\tmf.GetName(), m, l.GetName(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenc.Encode(mf)\n\t}\n\treq, err := http.NewRequest(method, pushURL, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(contentTypeHeader, string(expfmt.FmtProtoDelim))\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 202 {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code %d while pushing to %s: %s\", resp.StatusCode, pushURL, body)\n\t}\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/prometheus/client_golang/api\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/common/model\"\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif job == \"\" {\n\t\treturn fmt.Errorf(\"job name is required\")\n\t}\n\n\tu, err := url.Parse(pushURL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid push URL: %v\", err)\n\t}\n\n\tif !strings.HasSuffix(u.Path, \"/\") {\n\t\tu.Path += \"/\"\n\t}\n\tu.Path += \"metrics/job/\" + url.PathEscape(job)\n\n\tfor k, v := range grouping {\n\t\tif k == \"\" || strings.Contains(k, \"/\") {\n\t\t\treturn fmt.Errorf(\"invalid grouping key: %q\", k)\n\t\t}\n\t\tif strings.Contains(v, \"/\") {\n\t\t\treturn fmt.Errorf(\"invalid grouping value: %q\", v)\n\t\t}\n\t\tu.Path += \"/\" + url.PathEscape(k) + \"/\" + url.PathEscape(v)\n\t}\n\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to gather metrics: %v\", err)\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := expfmt.NewEncoder(&buf, expfmt.FmtProtoDelim)\n\tfor _, mf := range mfs {\n\t\tif err := enc.Encode(mf); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode metrics: %v\", err)\n\t\t}\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), method, u.String(), &buf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", string(expfmt.FmtProtoDelim))\n\n\tclient, err := api.NewClient(api.Config{Address: u.Scheme + \"://\" + u.Host})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTTP client: %v\", err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"HTTP request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"server returned HTTP status %s: %s\", resp.Status, body)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both unary and bidirectional streaming RPCs for an echo service, with TLS security.\n\nStruct Description: The server struct implements the EchoServer interface generated from the protobuf definition, providing echo functionality for both unary and streaming RPCs.\n\nFields:\n- UnimplementedEchoServer: pb.UnimplementedEchoServer - Embedded type to ensure forward compatibility\n\nMethods:\n- UnaryEcho: (context.Context, *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls by echoing back the received message\n- BidirectionalStreamingEcho: (pb.Echo_BidirectionalStreamingEchoServer) -> error - Handles bidirectional streaming by continuously receiving messages and echoing them back until the stream ends\n\nInput: None (The struct itself doesn't take input parameters, but its methods do as described above)\n\nOutput: None (The struct doesn't return anything directly, but its methods return values as described above)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/examples/data\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(_ context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tfmt.Printf(\"unary echoing message %q\\n\", in.Message)\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tin, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfmt.Printf(\"server: error receiving from stream: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"bidi echoing message %q\\n\", in.Message)\n\t\tstream.Send(&pb.EchoResponse{Message: in.Message})\n\t}\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"the port to serve on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(data.Path(\"x509/server_cert.pem\"), data.Path(\"x509/server_key.pem\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\n\tpb \"your_package_name/proto\" // Replace with actual proto package path\n)\n\ntype echoServer struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *echoServer) UnaryEcho(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.Message}, nil\n}\n\nfunc (s *echoServer) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := stream.Send(&pb.EchoResponse{Message: req.Message}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, supports optional transport security, and can register services with reflection capabilities.\n\nFunction Description: The main function sets up and starts a gRPC server with configurable options including transport security (TLS) and logging interceptors. It registers a test service and optionally enables server reflection. The server listens on either a Unix socket or TCP port based on configuration.\n\nInput:\n- *cert (string pointer): Path to certificate file for TLS (optional)\n- *cacert (string pointer): Path to CA certificate file (optional)\n- *key (string pointer): Path to private key file (optional)\n- *requirecert (bool pointer): Whether client certificates are required (optional)\n- *quiet (bool pointer): Whether to disable logging interceptors (optional)\n- *port (int pointer): TCP port to listen on (default used if not provided)\n- getUnixSocket (func() string): Function that returns Unix socket path if available (optional)\n\nOutput:\n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are printed to stderr and the program exits with code 1 on failure\n- Success message with listening address is printed to stdout",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/fullstorydev/grpcurl\"\n\tgrpcurl_testing \"github.com/fullstorydev/grpcurl/internal/testing\"\n)\nfunc main() {\n\tvar opts []grpc.ServerOption\n\tif *cert != \"\" {\n\t\tcreds, err := grpcurl.ServerTransportCredentials(*cacert, *cert, *key, *requirecert)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to configure transport credentials: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tif !*quiet {\n\t\topts = append(opts, grpc.UnaryInterceptor(unaryLogger), grpc.StreamInterceptor(streamLogger))\n\t}\n\n\tvar network, addr string\n\tif getUnixSocket != nil && getUnixSocket() != \"\" {\n\t\tnetwork = \"unix\"\n\t\taddr = getUnixSocket()\n\t} else {\n\t\tnetwork = \"tcp\"\n\t\taddr = fmt.Sprintf(\"127.0.0.1:%d\", *port)\n\t}\n\tl, err := net.Listen(network, addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to listen on socket: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tfmt.Printf(\"Listening on %v\\n\", l.Addr())\n\n\tsvr := grpc.NewServer(opts...)\n\n\tgrpcurl_testing.RegisterTestServiceServer(svr, grpcurl_testing.TestServer{})\n\tif !*noreflect {\n\t\treflection.Register(svr)\n\t}\n\n\tif err := svr.Serve(l); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"GRPC server returned error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\n// Assume TestServiceServer is defined elsewhere\ntype testService struct{}\n\nfunc (s *testService) SomeMethod() {} // Placeholder for actual service method\n\nfunc mainFunc(cert, cacert, key *string, requirecert, quiet *bool, port *int, getUnixSocket func() string) {\n\tvar opts []grpc.ServerOption\n\n\t// Set up TLS if certificate and key are provided\n\tif cert != nil && key != nil && *cert != \"\" && *key != \"\" {\n\t\tcreds, err := loadTLSCredentials(*cert, *key, cacert, requirecert)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to generate credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\n\t// Logging interceptor if not quiet\n\tif quiet == nil || !*quiet {\n\t\topts = append(opts, grpc.UnaryInterceptor(loggingInterceptor))\n\t}\n\n\t// Create gRPC server\n\ts := grpc.NewServer(opts...)\n\n\t// Register your test service\n\ttestService := &testService{}\n\t// Replace below with actual service registration, e.g.:\n\t// pb.RegisterTestServiceServer(s, testService)\n\n\t// Enable reflection\n\treflection.Register(s)\n\n\t// Determine listening address\n\tvar listener net.Listener\n\tvar err error\n\n\tif getUnixSocket != nil {\n\t\tsocketPath := getUnixSocket()\n\t\tif socketPath != \"\" {\n\t\t\tlistener, err = net.Listen(\"unix\", socketPath)\n\t\t}\n\t}\n\n\tif listener == nil {\n\t\tportVal := 50051\n\t\tif port != nil && *port > 0 {\n\t\t\tportVal = *port\n\t\t}\n\t\tlistener, err = net.Listen(\"tcp\", fmt.Sprintf(\":%d\", portVal))\n\t}\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Print success message\n\tfmt.Fprintf(os.Stdout, \"Server listening at %s\\n\", listener.Addr().String())\n\n\t// Start serving\n\tif err := s.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n\nfunc loadTLSCredentials(certFile, keyFile string, cacert *string, requirecert *bool) (credentials.TransportCredentials, error) {\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tClientAuth:   tls.NoClientCert,\n\t}\n\n\tif requirecert != nil && *requirecert {\n\t\tif cacert != nil && *cacert != \"\" {\n\t\t\tcaCert, err := os.ReadFile(*cacert)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcaPool := x509.NewCertPool()\n\t\t\tcaPool.AppendCertsFromPEM(caCert)\n\t\t\tconfig.ClientCAs = caPool\n\t\t}\n\t\tconfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t}\n\n\treturn credentials.NewTLS(config), nil\n}\n\nfunc loggingInterceptor(ctx interface{}, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\tlog.Printf(\"Received request: %s\", info.FullMethod)\n\tresp, err := handler(ctx, req)\n\tif err != nil {\n\t\tlog.Printf(\"Error handling request: %v\", err)\n\t} else {\n\t\tlog.Printf(\"Successfully handled request: %s\", info.FullMethod)\n\t}\n\treturn resp, err\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a gRPC service struct in Go that manages a gRPC server for key management operations, including starting the server, graceful shutdown, and immediate termination capabilities.\n\nStruct Description: GRPCService represents a gRPC server wrapper that handles Unix domain socket communication for key management services. It manages server lifecycle and configuration.\n\nFields:\naddr: string - The Unix domain socket address the server will listen on\ntimeout: time.Duration - Connection timeout duration for gRPC connections\nserver: *grpc.Server - The underlying gRPC server instance\nkmsService: Service - The key management service implementation to be registered with gRPC\n\nMethods:\nNewGRPCService(address string, timeout time.Duration, kmsService Service) -> *GRPCService - Constructor that initializes a new GRPCService instance with the given address, timeout and service implementation\nListenAndServe() -> error - Starts the gRPC server on the configured Unix domain socket address and begins serving requests\nShutdown() -> void - Gracefully stops the gRPC server, allowing existing connections to complete\nClose() -> void - Immediately stops the gRPC server without waiting for connections to complete",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tkmsapi \"k8s.io/kms/apis/v2\"\n)\n\ntype GRPCService struct {\n\taddr    string\n\ttimeout time.Duration\n\tserver  *grpc.Server\n\n\tkmsService Service\n}\n\nfunc NewGRPCService(\n\taddress string,\n\ttimeout time.Duration,\n\tkmsService Service,\n) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tln, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\n\tgs := grpc.NewServer(\n\t\tgrpc.ConnectionTimeout(s.timeout),\n\t)\n\ts.server = gs\n\n\tkmsapi.RegisterKeyManagementServiceServer(gs, s)\n\n\treturn gs.Serve(ln)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tif s.server != nil {\n\t\ts.server.GracefulStop()\n\t}\n}\n\nfunc (s *GRPCService) Close() {\n\tif s.server != nil {\n\t\ts.server.Stop()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Service interface {\n\t// Define key management service methods here\n}\n\ntype GRPCService struct {\n\taddr      string\n\ttimeout   time.Duration\n\tserver    *grpc.Server\n\tkmsService Service\n}\n\nfunc NewGRPCService(address string, timeout time.Duration, kmsService Service) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:      address,\n\t\ttimeout:   timeout,\n\t\tserver:    grpc.NewServer(),\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tlis, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Register the KMS service with the gRPC server\n\t// Example: pb.RegisterKeyManagementServiceServer(s.server, s.kmsService)\n\n\treturn s.server.Serve(lis)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\ts.server.GracefulStop()\n}\n\nfunc (s *GRPCService) Close() {\n\ts.server.Stop()\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It includes base URLs, user agent, rate limiting capabilities, and various service clients for different API endpoints.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe rate limiting\nrateLimits: [categories]Rate - Rate limit tracking for different categories\ncommon: service - Shared service implementation\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support and handles response decoding",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Rate struct {\n\tLimit  int\n\tWindow time.Duration\n}\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL    *url.URL\n\tUploadURL  *url.URL\n\tUserAgent  string\n\trateMu     sync.Mutex\n\trateLimits map[string]Rate\n\n\tcommon service\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = http.DefaultClient\n\t}\n\n\treturn &Client{\n\t\tclient:     httpClient,\n\t\trateLimits: make(map[string]Rate),\n\t}\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar reader io.Reader\n\tif body != nil {\n\t\tjsonBody, _ := json.Marshal(body)\n\t\treader = strings.NewReader(string(jsonBody))\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*http.Response, error) {\n\tresp, err := c.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\treturn nil, fmt.Errorf(\"request timeout\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"request failed: %v\", err)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif v != nil && resp.Body != nil {\n\t\tif err := json.NewDecoder(resp.Body).Decode(v); err != nil {\n\t\t\treturn resp, fmt.Errorf(\"failed to decode response: %v\", err)\n\t\t}\n\t}\n\n\treturn resp, nil\n}\n\ntype service struct {\n\tclient *Client\n}\n\ntype APIResponse struct {\n\tResponse *http.Response\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles log streaming and processing, including batch processing of log events.\n\nStruct Description: The Source struct represents a gRPC server that receives log streams, processes them in batches, and manages the server lifecycle.\n\nFields:\n- name: string - The name identifier for the source\n- eventPool: *event.Pool - Pool for managing event objects\n- config: *Config - Configuration for the source (bind address, port, etc.)\n- grpcServer: *grpc.Server - The gRPC server instance\n- bc: *batchChain - Batch processing chain for handling log events\n\nMethods:\n- ProductLoop: (productFunc api.ProductFunc) -> None - Starts the main processing loop and gRPC server\n  Input: productFunc - Function for processing produced events\n  Output: None (runs indefinitely as goroutine)\n\n- LogStream: (ls pb.LogService_LogStreamServer) -> error - Handles incoming log streams\n  Input: ls - gRPC stream server interface for log messages\n  Output: error - Any error that occurs during stream processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/loggie-io/loggie/pkg/pipeline\"\n\tpb \"github.com/loggie-io/loggie/pkg/sink/grpc/pb\"\n\t\"github.com/loggie-io/loggie/pkg/util/json\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Source struct {\n\tpb.UnimplementedLogServiceServer\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batchChain\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", s.String())\n\ts.bc = newBatchChain(productFunc, s.config.MaintenanceInterval)\n\tgo s.bc.run()\n\tip := fmt.Sprintf(\"%s:%s\", s.config.Bind, s.config.Port)\n\tlistener, err := net.Listen(s.config.Network, ip)\n\tif err != nil {\n\t\tlog.Panic(\"grpc server listen ip(%s) err: %v\", ip, err)\n\t}\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterLogServiceServer(grpcServer, s)\n\tgo grpcServer.Serve(listener)\n\ts.grpcServer = grpcServer\n\tlog.Info(\"grpc server start listing: %s\", ip)\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tb := newBatch(s.config.Timeout)\n\tfor {\n\t\tlogMsg, err := ls.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tsendErr := ls.SendAndClose(&pb.LogResp{\n\t\t\t\tSuccess:  false,\n\t\t\t\tCount:    0,\n\t\t\t\tErrorMsg: err.Error(),\n\t\t\t})\n\t\t\tif sendErr != nil {\n\t\t\t\tlog.Warn(\"send response fail: %s\", sendErr)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\theader := make(map[string]interface{})\n\t\trawHeader := logMsg.GetHeader()\n\t\tif len(rawHeader) > 0 {\n\t\t\tfor k, v := range rawHeader {\n\t\t\t\theader[k] = string(v)\n\t\t\t}\n\t\t}\n\t\tpackedHeader := logMsg.PackedHeader\n\t\tif len(packedHeader) > 0 {\n\t\t\terr = json.Unmarshal(packedHeader, &header)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Unmarshal packedHeader error: %s\", err)\n\t\t\t}\n\t\t}\n\t\te := s.eventPool.Get()\n\t\te.Fill(e.Meta(), header, logMsg.GetRawLog())\n\t\tb.append(e)\n\t}\n\tif b.size() > 0 {\n\t\ts.bc.append(b)\n\t\tlogResp := b.wait()\n\t\terr := ls.SendAndClose(logResp)\n\t\tif err != nil {\n\t\t\tlog.Error(\"send response fail: %s\", err)\n\t\t}\n\t\treturn err\n\t}\n\treturn ls.SendAndClose(&pb.LogResp{\n\t\tSuccess: true,\n\t\tCount:   0,\n\t})\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package source\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"github.com/yourorg/yourproject/proto\"\n\tapi \"github.com/yourorg/yourproject/api\"\n\t\"github.com/yourorg/yourproject/event\"\n\t\"github.com/yourorg/yourproject/batch\"\n)\n\ntype Config struct {\n\tBindAddress string\n\tPort        int\n\tBatchSize   int\n}\n\ntype Source struct {\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batch.Chain\n}\n\nfunc NewSource(name string, pool *event.Pool, cfg *Config) *Source {\n\treturn &Source{\n\t\tname:      name,\n\t\teventPool: pool,\n\t\tconfig:    cfg,\n\t\tgrpcServer: grpc.NewServer(),\n\t\tbc:        batch.NewChain(cfg.BatchSize),\n\t}\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", s.config.BindAddress, s.config.Port))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpb.RegisterLogServiceServer(s.grpcServer, s)\n\tgo s.bc.StartProcessing(productFunc)\n\n\tif err := s.grpcServer.Serve(lis); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tfor {\n\t\tselect {\n\t\tcase <-ls.Context().Done():\n\t\t\treturn ls.Context().Err()\n\t\tdefault:\n\t\t\tmsg, err := ls.Recv()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\te := s.eventPool.Get()\n\t\t\te.Parse(msg)\n\t\t\ts.bc.AddEvent(e)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: Implement a gRPC server in Go for a log service that supports append, read, discard, and info operations with concurrent access control and log entry management.\n\nStruct Description: The Server struct represents a gRPC server implementation for a log service that maintains an ordered sequence of log entries with configurable size limits and provides thread-safe operations.\n\nFields:\n- ctx: context.Context - Context for managing server lifecycle\n- options: *Options - Configuration options for the server\n- hardLimit: int - Maximum number of entries before truncation\n- lock: sync.Mutex - Mutex for thread-safe operations\n- locked: struct - Protected data structure containing:\n  - startIndex: Index - First available index in the log\n  - entries: []*logspec.Entry - Slice of log entries\n  - changed: chan struct{} - Channel to notify about log changes\n\nMethods:\n- NewServer: [Name](ctx context.Context, options *Options) -> (*Server, error) - Creates and starts a new Server instance\n- Append: [Name](stream logspec.Log_AppendServer) -> error - Handles append requests via gRPC stream\n- append: [Name](proposals [][]byte) -> []Index - Internal method to append entries to the log\n- lastIndexLocked: [Name]() -> Index - Helper method to get last index (requires lock)\n- Discard: [Name](ctx context.Context, req *logspec.DiscardRequest) -> (*logspec.DiscardReply, error) - Handles discard requests\n- discard: [Name](firstIndex Index) -> - Internal method to discard entries\n- Read: [Name](req *logspec.ReadRequest, stream logspec.Log_ReadServer) -> error - Handles read requests via gRPC stream\n- Info: [Name](ctx context.Context, req *logspec.InfoRequest) -> (*logspec.InfoReply, error) - Returns current log info\n- info: [Name]() -> (*logspec.InfoReply, chan struct{}) - Internal method to get log info\n- InfoStream: [Name](req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) -> error - Streams log info updates",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"github.com/ebay/akutan/logspec\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\ntype Options struct {\n\tAddress string\n\tLimit   int\n}\n\ntype Index = uint64\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\tserver := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.Limit * 3 / 2,\n\t}\n\tserver.locked.startIndex = 1\n\tserver.locked.changed = make(chan struct{})\n\tlistener, err := net.Listen(\"tcp\", options.Address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconst maxMsgSize = 1024 * 1024 * 1024\n\tservice := grpc.NewServer(\n\t\tgrpc.MaxRecvMsgSize(maxMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxMsgSize))\n\tlogspec.RegisterLogServer(service, server)\n\tgo service.Serve(listener)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t\tservice.Stop()\n\t}()\n\treturn server, nil\n}\n\nfunc (server *Server) Append(streams logspec.Log_AppendServer) error {\n\tseq := uint64(0)\n\tfor {\n\t\tseq++\n\t\treq, err := streams.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif req.Sequence != seq {\n\t\t\treturn errors.New(\"out of sequence\")\n\t\t}\n\t\tindexes := server.append(req.Proposals)\n\t\tres := logspec.AppendReply{\n\t\t\tReply: &logspec.AppendReply_Ok{\n\t\t\t\tOk: &logspec.AppendReply_OK{\n\t\t\t\t\tSequence: seq,\n\t\t\t\t\tIndexes:  indexes,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = streams.Send(&res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (server *Server) append(proposals [][]byte) []Index {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tprevLastIndex := server.lastIndexLocked()\n\tnextIndex := prevLastIndex + 1\n\tindexes := make([]Index, len(proposals))\n\tfor i := range proposals {\n\t\tindexes[i] = nextIndex\n\t\tnextIndex++\n\t\tserver.locked.entries = append(server.locked.entries, &logspec.Entry{\n\t\t\tIndex: indexes[i],\n\t\t\tData:  proposals[i],\n\t\t\tSkip:  false,\n\t\t})\n\t}\n\n\tif server.hardLimit > 0 && len(server.locked.entries) >= server.hardLimit {\n\t\tfirstIndex := nextIndex - uint64(server.options.Limit)\n\t\tdiff := firstIndex - server.locked.startIndex\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t\tserver.locked.startIndex = firstIndex\n\t}\n\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n\treturn indexes\n}\n\nfunc (server *Server) lastIndexLocked() Index {\n\treturn server.locked.startIndex + uint64(len(server.locked.entries)) - 1\n}\n\nfunc (server *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\tserver.discard(req.FirstIndex)\n\treturn &logspec.DiscardReply{\n\t\tReply: &logspec.DiscardReply_Ok{\n\t\t\tOk: &logspec.DiscardReply_OK{},\n\t\t},\n\t}, nil\n}\n\nfunc (server *Server) discard(firstIndex Index) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tif firstIndex <= server.locked.startIndex {\n\t\treturn\n\t}\n\tdiff := firstIndex - server.locked.startIndex\n\tif uint64(len(server.locked.entries)) < diff {\n\t\tserver.locked.entries = nil\n\t} else {\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t}\n\tserver.locked.startIndex = firstIndex\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n}\n\nfunc (server *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\tctx := stream.Context()\n\tnextIndex := req.NextIndex\n\tfor {\n\t\tserver.lock.Lock()\n\t\tstartIndex := server.locked.startIndex\n\t\tlastIndex := server.lastIndexLocked()\n\t\tentries := server.locked.entries\n\t\tchangedCh := server.locked.changed\n\t\tserver.lock.Unlock()\n\n\t\tif nextIndex < startIndex {\n\t\t\treturn stream.Send(&logspec.ReadReply{\n\t\t\t\tReply: &logspec.ReadReply_Truncated{\n\t\t\t\t\tTruncated: true,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t\tif nextIndex > lastIndex {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase <-server.ctx.Done():\n\t\t\t\treturn server.ctx.Err()\n\t\t\tcase <-changedCh:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tentries = entries[nextIndex-startIndex:]\n\t\tif len(entries) > 10 {\n\t\t\tentries = entries[:10]\n\t\t}\n\t\terr := stream.Send(&logspec.ReadReply{\n\t\t\tReply: &logspec.ReadReply_Ok{\n\t\t\t\tOk: &logspec.ReadReply_OK{\n\t\t\t\t\tEntries: entries,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnextIndex += uint64(len(entries))\n\t}\n}\n\nfunc (server *Server) Info(context.Context, *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tres, _ := server.info()\n\treturn res, nil\n}\n\nfunc (server *Server) info() (*logspec.InfoReply, chan struct{}) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\treturn &logspec.InfoReply{\n\t\tReply: &logspec.InfoReply_Ok{\n\t\t\tOk: &logspec.InfoReply_OK{\n\t\t\t\tFirstIndex: server.locked.startIndex,\n\t\t\t\tLastIndex:  server.lastIndexLocked(),\n\t\t\t},\n\t\t},\n\t}, server.locked.changed\n}\n\nfunc (server *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tfor {\n\t\tres, changedCh := server.info()\n\t\terr := stream.Send(res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-stream.Context().Done():\n\t\t\treturn stream.Context().Err()\n\t\tcase <-server.ctx.Done():\n\t\t\treturn server.ctx.Err()\n\t\tcase <-changedCh:\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package logservice\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/yourorg/logspec\"\n)\n\ntype Index int64\n\ntype Options struct {\n\tMaxEntries int\n}\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\ts := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.MaxEntries * 3 / 2,\n\t}\n\ts.locked.changed = make(chan struct{}, 1)\n\tgo s.watchContext()\n\treturn s, nil\n}\n\nfunc (s *Server) Append(stream logspec.Log_AppendServer) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (s *Server) append(proposals [][]byte) []Index {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tindices := make([]Index, 0, len(proposals))\n\tfor _, proposal := range proposals {\n\t\tidx := s.lastIndexLocked() + 1\n\t\tentry := &logspec.Entry{\n\t\t\tIndex:   int64(idx),\n\t\t\tPayload: proposal,\n\t\t}\n\t\ts.locked.entries = append(s.locked.entries, entry)\n\t\tindices = append(indices, idx)\n\t\t\n\t\tif len(s.locked.entries) > s.hardLimit {\n\t\t\ts.discardLocked(s.locked.startIndex + 1)\n\t\t}\n\t}\n\t\n\ts.notifyChanged()\n\treturn indices\n}\n\nfunc (s *Server) lastIndexLocked() Index {\n\tif len(s.locked.entries) == 0 {\n\t\treturn s.locked.startIndex\n\t}\n\treturn Index(s.locked.entries[len(s.locked.entries)-1].Index)\n}\n\nfunc (s *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\t\n\tfirstIndex := Index(req.FirstIndex)\n\ts.discardLocked(firstIndex)\n\t\n\treturn &logspec.DiscardReply{\n\t\tLastIndex: int64(s.lastIndexLocked()),\n\t}, nil\n}\n\nfunc (s *Server) discardLocked(firstIndex Index) {\n\tif firstIndex <= s.locked.startIndex {\n\t\treturn\n\t}\n\t\n\tnumToDiscard := int(firstIndex - s.locked.startIndex)\n\tif numToDiscard > len(s.locked.entries) {\n\t\tnumToDiscard = len(s.locked.entries)\n\t}\n\t\n\ts.locked.startIndex += Index(numToDiscard)\n\ts.locked.entries = s.locked.entries[numToDiscard:]\n}\n\nfunc (s *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (s *Server) Info(ctx context.Context, req *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\treply, _ := s.info()\n\treturn reply, nil\n}\n\nfunc (s *Server) info() (*logspec.InfoReply, chan struct{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\t\n\treturn &logspec.InfoReply{\n\t\tFirstIndex: int64(s.locked.startIndex),\n\t\tLastIndex:  int64(s.lastIndexLocked()),\n\t}, s.locked.changed\n}\n\nfunc (s *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (s *Server) watchContext() {\n\t<-s.ctx.Done()\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tclose(s.locked.changed)\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Create a Go HTTP client struct for interacting with an Okta API, handling authentication, session management, and user data retrieval.\n\nStruct Description: The Client struct represents an HTTP client configured to communicate with Okta's API. It maintains client configuration, organization details, and authentication state, providing methods for various API operations.\n\nFields:\n- client: *http.Client - The underlying HTTP client used for requests\n- org: string - The Okta organization domain\n- Url: string - The base Okta URL (defaults to \"okta.com\")\n- ApiToken: string - The API token for authenticated requests\n\nMethods:\n- NewClient(org string) -> *Client - Constructor that initializes a new Client with the specified organization\n- Authenticate(username string, password string) -> (*AuthnResponse, error) - Performs user authentication with username/password\n- Session(sessionToken string) -> (*SessionResponse, error) - Creates a session using a session token\n- User(userID string) -> (*User, error) - Retrieves user details by ID\n- Groups(userID string) -> (*Groups, error) - Gets groups associated with a user\n- call(endpoint string, method string, request interface{}, response interface{}) -> error - Internal method handling the HTTP request/response cycle",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\nfunc NewClient(org string) *Client {\n\tclient := Client{\n\t\tclient: &http.Client{},\n\t\torg:    org,\n\t\tUrl:    \"okta.com\",\n\t}\n\n\treturn &client\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\tvar request = &AuthnRequest{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tvar response = &AuthnResponse{}\n\terr := c.call(\"authn\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tvar request = &SessionRequest{\n\t\tSessionToken: sessionToken,\n\t}\n\n\tvar response = &SessionResponse{}\n\terr := c.call(\"sessions\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tvar response = &User{}\n\terr := c.call(\"users/\"+userID, \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tvar response = &Groups{}\n\terr := c.call(\"users/\"+userID+\"/groups\", \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) call(endpoint, method string, request, response interface{}) error {\n\tdata, _ := json.Marshal(request)\n\n\tvar url = \"https://\" + c.org + \".\" + c.Url + \"/api/v1/\" + endpoint\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Add(\"Accept\", `application/json`)\n\treq.Header.Add(\"Content-Type\", `application/json`)\n\tif c.ApiToken != \"\" {\n\t\treq.Header.Add(\"Authorization\", \"SSWS \"+c.ApiToken)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode == http.StatusOK {\n\t\terr := json.Unmarshal(body, &response)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tvar errors ErrorResponse\n\t\terr = json.Unmarshal(body, &errors)\n\n\t\treturn &errorResponse{\n\t\t\tHTTPCode: resp.StatusCode,\n\t\t\tResponse: errors,\n\t\t\tEndpoint: url,\n\t\t}\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package okta\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\ntype AuthnResponse struct {\n\tSessionToken string `json:\"sessionToken\"`\n}\n\ntype SessionResponse struct {\n\tID string `json:\"id\"`\n}\n\ntype User struct {\n\tID    string `json:\"id\"`\n\tLogin string `json:\"login\"`\n\tName  string `json:\"name\"`\n}\n\ntype Groups struct {\n\tGroups []string `json:\"groups\"`\n}\n\nfunc NewClient(org string) *Client {\n\treturn &Client{\n\t\tclient:   &http.Client{},\n\t\torg:      org,\n\t\tUrl:      \"okta.com\",\n\t\tApiToken: \"\",\n\t}\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\tauthURL := fmt.Sprintf(\"https://%s.%s/api/v1/authn\", c.org, c.Url)\n\treqBody := map[string]string{\n\t\t\"username\": username,\n\t\t\"password\": password,\n\t}\n\n\treqJSON, _ := json.Marshal(reqBody)\n\treq, _ := http.NewRequest(\"POST\", authURL, bytes.NewBuffer(reqJSON))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp := &AuthnResponse{}\n\tif err := c.call(req, resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tsessionURL := fmt.Sprintf(\"https://%s.%s/api/v1/sessions\", c.org, c.Url)\n\treqBody := map[string]string{\n\t\t\"sessionToken\": sessionToken,\n\t}\n\n\treqJSON, _ := json.Marshal(reqBody)\n\treq, _ := http.NewRequest(\"POST\", sessionURL, bytes.NewBuffer(reqJSON))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp := &SessionResponse{}\n\tif err := c.call(req, resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tuserURL := fmt.Sprintf(\"https://%s.%s/api/v1/users/%s\", c.org, c.Url, userID)\n\n\treq, _ := http.NewRequest(\"GET\", userURL, nil)\n\treq.Header.Set(\"Authorization\", \"SSWS \"+c.ApiToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp := &User{}\n\tif err := c.call(req, resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tgroupsURL := fmt.Sprintf(\"https://%s.%s/api/v1/users/%s/groups\", c.org, c.Url, userID)\n\n\treq, _ := http.NewRequest(\"GET\", groupsURL, nil)\n\treq.Header.Set(\"Authorization\", \"SSWS \"+c.ApiToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp := &Groups{}\n\tif err := c.call(req, resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *Client) call(req *http.Request, response interface{}) error {\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn fmt.Errorf(\"API request failed with status %d\", resp.StatusCode)\n\t}\n\n\tif response != nil {\n\t\tif err := json.NewDecoder(resp.Body).Decode(response); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a gRPC server for a translation service that can handle text translation requests and return mock translations for testing purposes.\n\nStruct Description: The fakeTranslationServer struct implements a mock gRPC server for the TranslationService, providing a simple translation response without requiring an actual translation service.\n\nFields:\n- UnimplementedTranslationServiceServer: embed - Base type from translatepb package that provides default implementations for all service methods\n\nMethods:\n- TranslateText: [Name](ctx context.Context, req *translatepb.TranslateTextRequest) -> (*translatepb.TranslateTextResponse, error) - Handles translation requests by returning a mock response containing \"Hello World\" as the translated text",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\ttranslate \"cloud.google.com/go/translate/apiv3\"\n\t\"cloud.google.com/go/translate/apiv3/translatepb\"\n\t\"google.golang.org/api/option\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (f *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\tresp := &translatepb.TranslateTextResponse{\n\t\tTranslations: []*translatepb.Translation{\n\t\t\t{TranslatedText: \"Hello World\"},\n\t\t},\n\t}\n\treturn resp, nil\n}\n\nfunc TestTranslateTextWithConcreteClient(t *testing.T) {\n\tctx := context.Background()\n\n\tfakeTranslationServer := &fakeTranslationServer{}\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgsrv := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(gsrv, fakeTranslationServer)\n\tfakeServerAddr := l.Addr().String()\n\tgo func() {\n\t\tif err := gsrv.Serve(l); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tclient, err := translate.NewTranslationClient(ctx,\n\t\toption.WithEndpoint(fakeServerAddr),\n\t\toption.WithoutAuthentication(),\n\t\toption.WithGRPCDialOption(grpc.WithInsecure()),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\n\tpb \"path/to/translatepb\"\n)\n\ntype fakeTranslationServer struct {\n\tpb.UnimplementedTranslationServiceServer\n}\n\nfunc (s *fakeTranslationServer) TranslateText(ctx context.Context, req *pb.TranslateTextRequest) (*pb.TranslateTextResponse, error) {\n\treturn &pb.TranslateTextResponse{\n\t\tTranslatedText: \"Hello World\",\n\t}, nil\n}"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Implement a Redis-based session management system in Go that allows storing, retrieving, and managing HTTP session data using Redis as the backend storage.\n\nStruct Description: The implementation consists of two main structs - `SessionStore` for handling individual session operations and `Provider` for managing the Redis connection pool and session lifecycle.\n\nFields:\n\nSessionStore:\n- p: *redis.Pool - Redis connection pool\n- sid: string - Session ID\n- lock: sync.RWMutex - Read-write lock for thread safety\n- values: map[interface{}]interface{} - Key-value pairs storing session data\n- maxlifetime: int64 - Session expiration time in seconds\n\nProvider:\n- maxlifetime: int64 - Default session expiration time\n- savePath: string - Redis server address\n- poolsize: int - Connection pool size\n- password: string - Redis authentication password\n- dbNum: int - Redis database number\n- poollist: *redis.Pool - Redis connection pool instance\n\nMethods:\n\nSessionStore:\n- Set(key, value interface{}) error - Stores a key-value pair in the session\n- Get(key interface{}) interface{} - Retrieves a value by key from the session\n- Delete(key interface{}) error - Removes a key-value pair from the session\n- Flush() error - Clears all session data\n- SessionID() string - Returns the session ID\n- SessionRelease(w http.ResponseWriter) - Persists session data to Redis before closing\n\nProvider:\n- SessionInit(maxlifetime int64, savePath string) error - Initializes the Redis connection pool with configuration\n- SessionRead(sid string) (session.Store, error) - Retrieves session data from Redis\n- SessionExist(sid string) bool - Checks if a session exists in Redis\n- SessionRegenerate(oldsid, sid string) (session.Store, error) - Creates a new session ID while preserving data\n- SessionDestroy(sid string) error - Removes session data from Redis",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/astaxie/beego/session\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar redispder = &Provider{}\nvar MaxPoolSize = 100\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (rs *SessionStore) Set(key, value interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values[key] = value\n\treturn nil\n}\n\nfunc (rs *SessionStore) Get(key interface{}) interface{} {\n\trs.lock.RLock()\n\tdefer rs.lock.RUnlock()\n\tif v, ok := rs.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (rs *SessionStore) Delete(key interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\tdelete(rs.values, key)\n\treturn nil\n}\n\nfunc (rs *SessionStore) Flush() error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (rs *SessionStore) SessionID() string {\n\treturn rs.sid\n}\n\nfunc (rs *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tb, err := session.EncodeGob(rs.values)\n\tif err != nil {\n\t\treturn\n\t}\n\tc := rs.p.Get()\n\tdefer c.Close()\n\tc.Do(\"SETEX\", rs.sid, rs.maxlifetime, string(b))\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (rp *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\trp.maxlifetime = maxlifetime\n\tconfigs := strings.Split(savePath, \",\")\n\tif len(configs) > 0 {\n\t\trp.savePath = configs[0]\n\t}\n\tif len(configs) > 1 {\n\t\tpoolsize, err := strconv.Atoi(configs[1])\n\t\tif err != nil || poolsize <= 0 {\n\t\t\trp.poolsize = MaxPoolSize\n\t\t} else {\n\t\t\trp.poolsize = poolsize\n\t\t}\n\t} else {\n\t\trp.poolsize = MaxPoolSize\n\t}\n\tif len(configs) > 2 {\n\t\trp.password = configs[2]\n\t}\n\tif len(configs) > 3 {\n\t\tdbnum, err := strconv.Atoi(configs[3])\n\t\tif err != nil || dbnum < 0 {\n\t\t\trp.dbNum = 0\n\t\t} else {\n\t\t\trp.dbNum = dbnum\n\t\t}\n\t} else {\n\t\trp.dbNum = 0\n\t}\n\trp.poollist = redis.NewPool(func() (redis.Conn, error) {\n\t\tc, err := redis.Dial(\"tcp\", rp.savePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.password != \"\" {\n\t\t\tif _, err := c.Do(\"AUTH\", rp.password); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t_, err = c.Do(\"SELECT\", rp.dbNum)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t}, rp.poolsize)\n\n\treturn rp.poollist.Get().Err()\n}\n\nfunc (rp *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionExist(sid string) bool {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, err := redis.Int(c.Do(\"EXISTS\", sid)); err != nil || existed == 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (rp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, _ := redis.Int(c.Do(\"EXISTS\", oldsid)); existed == 0 {\n\t\tc.Do(\"SET\", sid, \"\", \"EX\", rp.maxlifetime)\n\t} else {\n\t\tc.Do(\"RENAME\", oldsid, sid)\n\t\tc.Do(\"EXPIRE\", sid, rp.maxlifetime)\n\t}\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionDestroy(sid string) error {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tc.Do(\"DEL\", sid)\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package redisSession\n\nimport (\n\t\"errors\"\n\t\"github.com/gomodule/redigo/redis\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tErrSessionNotFound = errors.New(\"session not found\")\n)\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (st *SessionStore) Set(key, value interface{}) error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tst.values[key] = value\n\treturn nil\n}\n\nfunc (st *SessionStore) Get(key interface{}) interface{} {\n\tst.lock.RLock()\n\tdefer st.lock.RUnlock()\n\tif v, ok := st.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (st *SessionStore) Delete(key interface{}) error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tdelete(st.values, key)\n\treturn nil\n}\n\nfunc (st *SessionStore) Flush() error {\n\tst.lock.Lock()\n\tdefer st.lock.Unlock()\n\tst.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (st *SessionStore) SessionID() string {\n\treturn st.sid\n}\n\nfunc (st *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tc := st.p.Get()\n\tdefer c.Close()\n\n\tkeyName := \"session:\" + st.sid\n\tst.lock.RLock()\n\tdefer st.lock.RUnlock()\n\n\tfor k, v := range st.values {\n\t\tc.Do(\"HSET\", keyName, k, v)\n\t}\n\tc.Do(\"EXPIRE\", keyName, st.maxlifetime)\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (pder *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\tpder.maxlifetime = maxlifetime\n\tpder.savePath = savePath\n\tpder.poollist = &redis.Pool{\n\t\tMaxIdle:     100,\n\t\tMaxActive:   pder.poolsize,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", pder.savePath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif pder.password != \"\" {\n\t\t\t\tif _, err := c.Do(\"AUTH\", pder.password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Do(\"SELECT\", pder.dbNum); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, nil\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t_, err := c.Do(\"PING\")\n\t\t\treturn err\n\t\t},\n\t}\n\treturn nil\n}\n\nfunc (pder *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := pder.poollist.Get()\n\tdefer c.Close()\n\n\tsessionKey := \"session:\" + sid\n\texists, _ := redis.Bool(c.Do(\"EXISTS\", sessionKey))\n\tif !exists {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\tvalues := make(map[interface{}]interface{})\n\treply, err := redis.Values(c.Do(\"HGETALL\", sessionKey))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < len(reply); i += 2 {\n\t\tkey, _ := redis.String(reply[i], nil)\n\t\tval, _ := redis.String(reply[i+1], nil)\n\t\tvalues[key] = val\n\t}\n\n\tstore := &SessionStore{\n\t\tp:           pder.poollist,\n\t\tsid:         sid,\n\t\tvalues:      values,\n\t\tmaxlifetime: pder.maxlifetime,\n\t}\n\treturn store, nil\n}\n\nfunc (pder *Provider) SessionExist(sid string) bool {\n\tc := pder.poollist.Get()\n\tdefer c.Close()\n\n\tsessionKey := \"session:\" + sid\n\texists, _ := redis.Bool(c.Do(\"EXISTS\", sessionKey))\n\treturn exists\n}\n\nfunc (pder *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := pder.poollist.Get()\n\tdefer c.Close()\n\n\toldKey := \"session:\" + oldsid\n\tnewKey := \"session:\" + sid\n\n\texists, _ := redis.Bool(c.Do(\"EXISTS\", oldKey))\n\tif !exists {\n\t\treturn nil, ErrSessionNotFound\n\t}\n\n\t// Copy session data to new key\n\tif _, err := c.Do(\"RENAME\", oldKey, newKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set expiration for new key\n\tif _, err := c.Do(\"EXPIRE\", newKey, pder.maxlifetime); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read session data into new store\n\tvalues := make(map[interface{}]interface{})\n\treply, err := redis.Values(c.Do(\"HGETALL\", newKey))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < len(reply); i += 2 {\n\t\tkey, _ := redis.String(reply[i], nil)\n\t\tval, _ := redis.String(reply[i+1], nil)\n\t\tvalues[key] = val\n\t}\n\n\tstore := &SessionStore{\n\t\tp:           pder.poollist,\n\t\tsid:         sid,\n\t\tvalues:      values,\n\t\tmaxlifetime: pder.maxlifetime,\n\t}\n\treturn store, nil\n}\n\nfunc (pder *Provider) SessionDestroy(sid string) error {\n\tc := pder.poollist.Get()\n\tdefer c.Close()\n\n\tsessionKey := \"session:\" + sid\n\t_, err := c.Do(\"DEL\", sessionKey)\n\treturn err\n}"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool and methods for interacting with Redis, including setting, getting, deleting keys, and flushing the database.\n\nStruct Description: RedisStore is a struct that manages a connection pool to Redis and provides methods for common Redis operations with support for expiration times.\n\nFields:\n- pool: *redis.Pool - A connection pool to Redis for efficient connection reuse\n- defaultExpiration: time.Duration - The default expiration time for keys when not explicitly specified\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method for executing Redis commands with serialization and expiration handling",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gomodule/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool             *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\treturn &RedisStore{\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     10,\n\t\t\tIdleTimeout: 240 * time.Second,\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif password != \"\" {\n\t\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn c, err\n\t\t\t},\n\t\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t\t_, err := c.Do(\"PING\")\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (rs *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn rs.invoke(func(command string, args ...interface{}) (interface{}, error) {\n\t\treturn rs.pool.Get().Do(command, args...)\n\t}, key, value, expires)\n}\n\nfunc (rs *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\tdata, err := redis.Bytes(conn.Do(\"GET\", key))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn redis.Scan(data, ptrValue)\n}\n\nfunc (rs *RedisStore) Delete(key string) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (rs *RedisStore) Flush() error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"FLUSHDB\")\n\treturn err\n}\n\nfunc (rs *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\targs := redis.Args{}.Add(key).AddFlat(value)\n\tif expires == 0 {\n\t\texpires = rs.defaultExpiration\n\t}\n\tif expires > 0 {\n\t\targs = args.Add(\"EX\").Add(int64(expires.Seconds()))\n\t}\n\t_, err := f(\"SET\", args...)\n\treturn err\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Redis client struct in Go that manages connections to Redis servers and provides common Redis operations. The implementation should use connection pooling and support thread-safe access to multiple Redis instances.\n\nStruct Description: RedisClient is a struct that encapsulates Redis connection pooling and provides methods for common Redis operations. It maintains a thread-safe map of Redis clients for different server addresses.\n\nFields:\n\npool: *redis.Pool - The connection pool for Redis operations\nAddress: string - The Redis server address (URL)\n\nMethods:\n\nGetRedisClient: (address string, maxIdle int, maxActive int) -> *RedisClient - Retrieves or creates a Redis client for the given address with specified pool settings\nGet: (key string) -> (string, error) - Retrieves the value for a given key from Redis\nSet: (key string, val interface{}) -> (interface{}, error) - Sets the value for a given key in Redis\nLPush: (key string, value ...interface{}) -> (int, error) - Pushes values to the left of a Redis list\nLPop: (key string) -> (string, error) - Pops a value from the left of a Redis list\nHSet: (hashID string, field string, val string) -> error - Sets a field in a Redis hash\nHGet: (hashID string, field string) -> (string, error) - Gets a field from a Redis hash",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tredisMap map[string]*RedisClient\n\tmapMutex *sync.RWMutex\n)\n\nconst (\n\tdefaultMaxIdle   = 10\n\tdefaultMaxActive = 50\n)\n\nfunc init() {\n\tredisMap = make(map[string]*RedisClient)\n\tmapMutex = new(sync.RWMutex)\n}\n\nfunc newPool(redisURL string, maxIdle, maxActive int) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxIdle:   maxIdle,\n\t\tMaxActive: maxActive,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(redisURL)\n\t\t\treturn c, err\n\t\t},\n\t}\n}\n\nfunc GetRedisClient(address string, maxIdle, maxActive int) *RedisClient {\n\tif maxIdle <= 0 {\n\t\tmaxIdle = defaultMaxIdle\n\t}\n\tif maxActive <= 0 {\n\t\tmaxActive = defaultMaxActive\n\t}\n\tvar redis *RedisClient\n\tvar mok bool\n\tmapMutex.RLock()\n\tredis, mok = redisMap[address]\n\tmapMutex.RUnlock()\n\tif !mok {\n\t\tredis = &RedisClient{Address: address, pool: newPool(address, maxIdle, maxActive)}\n\t\tmapMutex.Lock()\n\t\tredisMap[address] = redis\n\t\tmapMutex.Unlock()\n\t}\n\treturn redis\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"GET\", key)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"SET\", key, val))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tret, err := redis.Int(conn.Do(\"LPUSH\", key, value))\n\treturn ret, err\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"LPOP\", key))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"HGET\", hashID, field)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package redisclient\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tclients = make(map[string]*RedisClient)\n\tmu      sync.RWMutex\n)\n\nfunc GetRedisClient(address string, maxIdle int, maxActive int) *RedisClient {\n\tmu.RLock()\n\tif client, exists := clients[address]; exists {\n\t\tmu.RUnlock()\n\t\treturn client\n\t}\n\tmu.RUnlock()\n\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\t// Double-check in case another goroutine created it while we were waiting for the lock\n\tif client, exists := clients[address]; exists {\n\t\treturn client\n\t}\n\n\tclient := &RedisClient{\n\t\tAddress: address,\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     maxIdle,\n\t\t\tMaxActive:   maxActive,\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\treturn redis.Dial(\"tcp\", address)\n\t\t\t},\n\t\t},\n\t}\n\n\tclients[address] = client\n\treturn client\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"GET\", key))\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\treturn conn.Do(\"SET\", key, val)\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\targs := redis.Args{}.Add(key)\n\tfor _, v := range value {\n\t\targs = args.Add(v)\n\t}\n\n\treturn redis.Int(conn.Do(\"LPUSH\", args...))\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"LPOP\", key))\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\n\treturn redis.String(conn.Do(\"HGET\", hashID, field))\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function to fetch video materials from an advertising API using HTTP requests with custom headers and process the response.\n\nFunction Description: The function `getVideo` makes a GET request to a specified API endpoint to retrieve video materials for a given advertiser. It handles request creation, header addition, response processing, and error handling. The response is parsed to extract video information and store it in a global map while returning pagination information.\n\nInput:\n- advertiserId: string - The ID of the advertiser whose videos are being requested\n- page: int - The page number for paginated results\n\nOutput:\n- int - Total number of pages available (for pagination)\n- error - Any error encountered during the HTTP request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar videoImageIdMaterialIdMap = map[string]int64{}\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/get/\"\n\tmethod := \"GET\"\n\tpayload := strings.NewReader(fmt.Sprintf(`{\n    \t\t\t\"advertiser_id\": %s,\n   \t\t\t\t \"page\":%d,\n   \t\t\t\t \"page_size\":100}`, advertiserId, page))\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treq.Header.Add(\"Access-Token\", \"c0bfed085c0dbc19bb2e41920ecd6d2a6d398b32\")\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar getVideoMaterialResp GetVideoMaterialResp\n\terr = json.Unmarshal(body, &getVideoMaterialResp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif getVideoMaterialResp.Code != 0 {\n\t\treturn 0, err\n\t}\n\tfor _, s := range getVideoMaterialResp.Data.List {\n\t\tvideoImageIdMaterialIdMap[s.Id] = s.MaterialId\n\t}\n\treturn getVideoMaterialResp.Data.PageInfo.TotalPage, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"sync\"\n)\n\nvar (\n\tvideoCache = make(map[string][]byte)\n\tcacheMutex sync.Mutex\n)\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := fmt.Sprintf(\"https://advertising-api.com/video-materials?advertiserId=%s&page=%d\", advertiserId, page)\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\treq.Header.Set(\"X-Custom-Header\", \"CustomValue\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn 0, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvar result struct {\n\t\tVideos    []map[string]interface{} `json:\"videos\"`\n\t\tPage      int                      `json:\"page\"`\n\t\tTotalPages int                     `json:\"total_pages\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn 0, err\n\t}\n\n\tcacheMutex.Lock()\n\tdefer cacheMutex.Unlock()\n\n\tfor _, video := range result.Videos {\n\t\tid, ok := video[\"id\"].(string)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tdata, ok := video[\"data\"].([]byte)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tvideoCache[id] = data\n\t}\n\n\treturn result.TotalPages, nil\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool to interact with a Redis server, supporting common operations like Set, Get, Delete, and Flush with configurable expiration times.\n\nStruct Description: RedisStore is a struct that manages a pool of Redis connections and provides methods to interact with Redis, including setting, getting, deleting keys, and flushing the database. It supports configurable expiration times for cached items.\n\nFields:\n- pool: *redis.Pool - A connection pool to manage Redis connections efficiently\n- defaultExpiration: time.Duration - The default expiration time for cached items\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method to handle Redis operations with expiration logic",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gomodule/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool             *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host, password string, defaultExpiration time.Duration) *RedisStore {\n\treturn &RedisStore{\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     10,\n\t\t\tIdleTimeout: 240 * time.Second,\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif password != \"\" {\n\t\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn c, err\n\t\t\t},\n\t\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t\t_, err := c.Do(\"PING\")\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (rs *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\targs := redis.Args{}.Add(key)\n\tif value != nil {\n\t\targs = args.Add(value)\n\t}\n\n\tif expires == 0 {\n\t\texpires = rs.defaultExpiration\n\t}\n\n\tif expires > 0 {\n\t\targs = args.Add(\"EX\").Add(int64(expires.Seconds()))\n\t}\n\n\t_, err := f(args...)\n\treturn err\n}\n\nfunc (rs *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn rs.invoke(func(args ...interface{}) (interface{}, error) {\n\t\tconn := rs.pool.Get()\n\t\tdefer conn.Close()\n\t\treturn conn.Do(\"SET\", args...)\n\t}, key, value, expires)\n}\n\nfunc (rs *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\tvalue, err := redis.Bytes(conn.Do(\"GET\", key))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn redis.Scan(value, ptrValue)\n}\n\nfunc (rs *RedisStore) Delete(key string) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (rs *RedisStore) Flush() error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\t_, err := conn.Do(\"FLUSHDB\")\n\treturn err\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages to brokers using different modes (Sync, Async, or OneWay) with configurable options.\n\nStruct Description: The Producer struct encapsulates a RocketMQ producer client with methods for starting, closing, and sending messages. It supports configuration options and interceptors.\n\nFields:\n\n- started: bool - Indicates whether the producer has been started\n- Producer: rocketmq.Producer - The underlying RocketMQ producer instance\n- name: string - Name identifier for the producer\n- ProducerConfig: ProducerConfig - Configuration settings for the producer\n- interceptors: []primitive.Interceptor - List of interceptors for message processing\n\nMethods:\n\n- Start() -> error - Initializes and starts the RocketMQ producer with configured options\n- Close() -> error - Shuts down the producer gracefully\n- SendWithContext(ctx context.Context, msg []byte) -> error - Sends a byte array message with context\n- SendWithMsg(ctx context.Context, msg *primitive.Message) -> error - Sends a primitive.Message with context\n- SendWithResult(ctx context.Context, msg []byte, tag string) -> (*primitive.SendResult, error) - Sends a message with tag and returns send result\n- SendMsg(ctx context.Context, msg *primitive.Message) -> (*primitive.SendResult, error) - Sends a message and returns send result",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/douyu/jupiter/pkg/xlog\"\n)\n\ntype Producer struct {\n\tstarted bool\n\n\trocketmq.Producer\n\tname string\n\tProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc (pc *Producer) Start() error {\n\tif pc.started {\n\t\treturn nil\n\t}\n\n\tclient, err := rocketmq.NewProducer(\n\t\tproducer.WithGroupName(pc.Group),\n\t\tproducer.WithNameServer(pc.Addr),\n\t\tproducer.WithRetry(pc.Retry),\n\t\tproducer.WithInterceptor(pc.interceptors...),\n\t\tproducer.WithInstanceName(pc.InstanceName),\n\t\tproducer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: pc.AccessKey,\n\t\t\tSecretKey: pc.SecretKey,\n\t\t}),\n\t)\n\tif err != nil {\n\t\txlog.Jupiter().Panic(\"create producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tif err := client.Start(); err != nil {\n\t\txlog.Jupiter().Panic(\"start producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tpc.started = true\n\tpc.Producer = client\n\treturn nil\n}\n\nfunc (pc *Producer) Close() error {\n\terr := pc.Shutdown()\n\tif err != nil {\n\t\txlog.Jupiter().Warn(\"consumer close fail\", xlog.Any(\"error\", err.Error()))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\t_, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tmsg.Topic = pc.Topic\n\t_, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\tif tag != \"\" {\n\t\tm.WithTag(tag)\n\t}\n\n\tres, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", string(msg)))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}\n\nfunc (pc *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tres, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 127,
    "wrong_result": "package rocketmq\n\nimport (\n\t\"context\"\n\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n)\n\ntype ProducerConfig struct {\n\tNameServer string\n\tTopic      string\n\tTag        string\n\tSendMode   string // \"Sync\", \"Async\", or \"OneWay\"\n}\n\ntype Producer struct {\n\tstarted      bool\n\tProducer     rocketmq.Producer\n\tname         string\n\tProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc NewProducer(name string, config ProducerConfig, interceptors ...primitive.Interceptor) *Producer {\n\tp := &Producer{\n\t\tname:           name,\n\t\tProducerConfig: config,\n\t\tinterceptors:   interceptors,\n\t}\n\n\topts := []producer.Option{\n\t\tproducer.WithNameServer([]string{config.NameServer}),\n\t\tproducer.WithInterceptors(interceptors...),\n\t}\n\n\tswitch config.SendMode {\n\tcase \"Sync\":\n\t\topts = append(opts, producer.WithDefaultTopic(config.Topic))\n\tcase \"Async\":\n\t\topts = append(opts, producer.WithDefaultTopic(config.Topic))\n\tcase \"OneWay\":\n\t\topts = append(opts, producer.WithDefaultTopic(config.Topic))\n\tdefault:\n\t\tpanic(\"unsupported send mode\")\n\t}\n\n\tp.Producer = producer.NewProducer(opts...)\n\treturn p\n}\n\nfunc (p *Producer) Start() error {\n\tif !p.started {\n\t\terr := p.Producer.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp.started = true\n\t}\n\treturn nil\n}\n\nfunc (p *Producer) Close() error {\n\tif p.started {\n\t\terr := p.Producer.Shutdown()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp.started = false\n\t}\n\treturn nil\n}\n\nfunc (p *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tmessage := primitive.NewMessage(p.ProducerConfig.Topic, msg)\n\t_, err := p.Producer.Send(context.Background(), message)\n\treturn err\n}\n\nfunc (p *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\t_, err := p.Producer.Send(context.Background(), msg)\n\treturn err\n}\n\nfunc (p *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tmessage := primitive.NewMessageWithTag(p.ProducerConfig.Topic, tag, msg)\n\treturn p.Producer.Send(context.Background(), message)\n}\n\nfunc (p *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\treturn p.Producer.Send(context.Background(), msg)\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a stock quote service that retrieves stock information from an external API and processes the response.\n\nStruct Description: The Stock struct represents a service for fetching stock quotes. It contains configuration fields for API access and implements methods to retrieve quote information.\n\nFields:\nApi: [string] - The base URL of the stock API service\nKey: [string] - The API key used for authentication with the stock service\n\nMethods:\nQuote: [Name](ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) -> [error] - Retrieves stock quote information for a given symbol. Validates the input symbol, makes an HTTP GET request to the stock API, processes the response, and populates the response object with the quote data. Returns error if any step fails.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/stock/proto\"\n)\n\ntype Stock struct {\n\tApi   string\n\tKey   string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif len(req.Symbol) <= 0 || len(req.Symbol) > 5 {\n\t\treturn errors.BadRequest(\"stock.quote\", \"invalid symbol\")\n\t}\n\n\turi := fmt.Sprintf(\"%slast/stock/%s?apikey=%s\", s.Api, req.Symbol, s.Key)\n\n\tresp, err := http.Get(uri)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to get quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\tdefer resp.Body.Close()\n\n\tb, _ := ioutil.ReadAll(resp.Body)\n\n\tif resp.StatusCode != 200 {\n\t\tlogger.Errorf(\"Failed to get quote (non 200): %d %v\\n\", resp.StatusCode, string(b))\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\tvar respBody struct {\n\t\tSymbol    string\n\t\tAsk       float64\n\t\tBid       float64\n\t\tAsize     int32\n\t\tBsize     int32\n\t\tTimestamp int64\n\t}\n\n\tif err := json.Unmarshal(b, &respBody); err != nil {\n\t\tlogger.Errorf(\"Failed to unmarshal quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\trsp.Symbol = respBody.Symbol\n\trsp.AskPrice = respBody.Ask\n\trsp.BidPrice = respBody.Bid\n\trsp.AskSize = respBody.Asize\n\trsp.BidSize = respBody.Bsize\n\trsp.Timestamp = respBody.Timestamp\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Stock struct {\n\tApi string\n\tKey string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif req == nil || req.Symbol == \"\" {\n\t\treturn fmt.Errorf(\"invalid request or empty symbol\")\n\t}\n\n\turl := fmt.Sprintf(\"%s/quote/%s?apikey=%s\", s.Api, req.Symbol, s.Key)\n\n\treqHTTP, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient := &http.Client{}\n\trespHTTP, err := client.Do(reqHTTP)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer respHTTP.Body.Close()\n\n\tif respHTTP.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", respHTTP.StatusCode)\n\t}\n\n\tvar quoteData struct {\n\t\tSymbol  string  `json:\"symbol\"`\n\t\tName    string  `json:\"name\"`\n\t\tPrice   float64 `json:\"price\"`\n\t\tChange  float64 `json:\"change\"`\n\t\tPercent float64 `json:\"percent_change\"`\n\t}\n\n\tif err := json.NewDecoder(respHTTP.Body).Decode(&quoteData); err != nil {\n\t\treturn err\n\t}\n\n\trsp.Symbol = quoteData.Symbol\n\trsp.Name = quoteData.Name\n\trsp.Price = quoteData.Price\n\trsp.Change = quoteData.Change\n\trsp.PercentChange = quoteData.Percent\n\n\treturn nil\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET request. It supports caching of downloaded files to avoid redundant network requests. The function handles error cases including failed requests and non-200 status codes. When caching is enabled, subsequent requests for the same URL will return the cached content.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The content of the fetched file as a byte slice\n- `error` - An error object if any step fails (network error, non-200 status, etc.)\n\nNote: The function relies on package-level variables `fileCache` (a map for caching), `fileCacheMutex` (for thread safety), `fileCacheEnable` (boolean to toggle caching), and `verboseReader` (boolean for logging). These should be properly initialized before use.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar (\n\tfileCache     = make(map[string][]byte)\n\tfileCacheMutex sync.Mutex\n\tfileCacheEnable = true\n\tverboseReader   = true\n)\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tif fileCacheEnable {\n\t\tfileCacheMutex.Lock()\n\t\tif content, ok := fileCache[fileurl]; ok {\n\t\t\tfileCacheMutex.Unlock()\n\t\t\tif verboseReader {\n\t\t\t\tfmt.Printf(\"Returning cached content for URL: %s\\n\", fileurl)\n\t\t\t}\n\t\t\treturn content, nil\n\t\t}\n\t\tfileCacheMutex.Unlock()\n\t}\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch URL: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\tif fileCacheEnable {\n\t\tfileCacheMutex.Lock()\n\t\tfileCache[fileurl] = content\n\t\tfileCacheMutex.Unlock()\n\t\tif verboseReader {\n\t\t\tfmt.Printf(\"Cached content for URL: %s\\n\", fileurl)\n\t\t}\n\t}\n\n\treturn content, nil\n}"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a function to download a file from a given URL, apply an optional filter to the content, and save it to specified directories.\n\nFunction Description: The function `dl` downloads a file from a provided URL, reads its content, applies an optional filter (if provided), and writes the content to one or more specified directories. It handles errors during the HTTP request, reading the response, and file writing, and provides status feedback via console output.\n\nInput:  \n- `f` (type `dlFile`): A struct containing the following fields:  \n  - `name` (string): The name of the file to be saved.  \n  - `url` (string): The URL from which the file will be downloaded.  \n  - `filt` (func([]byte) []byte): An optional function to filter/modify the downloaded content. Can be `nil` if no filtering is needed.  \n  - `dirs` ([]string): A slice of directory paths where the file will be saved.  \n\nOutput:  \n- None (void): The function does not return any value but prints status messages to the console (e.g., \"Sync [filename]: ok\" on success or error messages on failure).  \n\nNote: The function handles errors for HTTP requests, reading response bodies, and file writing, and ensures the response body is closed properly to prevent resource leaks.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc dl(f dlFile) {\n\tfmt.Printf(\"Sync %s: \", f.name)\n\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\tioutil.WriteFile(filepath.Join(dir, f.name), content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Println(\"ok\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype dlFile struct {\n\tname string\n\turl  string\n\tfilt func([]byte) []byte\n\tdirs []string\n}\n\nfunc dl(f dlFile) {\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Printf(\"Sync %s: error fetching from URL: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Printf(\"Sync %s: unexpected status code %d\\n\", f.name, resp.StatusCode)\n\t\treturn\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Sync %s: error reading response body: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\terr := os.MkdirAll(dir, os.ModePerm)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Sync %s: error creating directory %s: %v\\n\", f.name, dir, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilePath := filepath.Join(dir, f.name)\n\t\terr = os.WriteFile(filePath, content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Sync %s: error writing file to %s: %v\\n\", f.name, filePath, err)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tfmt.Printf(\"Sync %s: ok\\n\", f.name)\n}"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Implement a function to fetch and process Google Font CSS data for embedding in SVG documents.\n\nFunction Description: The function `googlefont` retrieves CSS data from Google Fonts API for a specified font family, embeds it in SVG-compatible format, and returns available font variants. It handles HTTP requests, response processing, and error cases gracefully.\n\nInput: \n- `f` [string] - The font family name to query (e.g., \"Roboto\" or \"Open Sans\")\n\nOutput:\n- `[]string` - A slice of strings representing available font variants (split by \"|\"), or an empty slice if the request fails or returns non-200 status",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nvar (\n\tcanvas = svg.New(os.Stdout)\n)\n\nconst (\n\tgwfURI  = \"http://fonts.googleapis.com/css?family=\"\n\tfontfmt = \"<style type=\\\"text/css\\\">\\n<![CDATA[\\n%s]]>\\n</style>\\n\"\n)\n\nfunc googlefont(f string) []string {\n\tempty := []string{}\n\tr, err := http.Get(gwfURI + url.QueryEscape(f))\n\tif err != nil {\n\t\treturn empty\n\t}\n\tdefer r.Body.Close()\n\tb, rerr := ioutil.ReadAll(r.Body)\n\tif rerr != nil || r.StatusCode != http.StatusOK {\n\t\treturn empty\n\t}\n\tcanvas.Def()\n\tfmt.Fprintf(canvas.Writer, fontfmt, b)\n\tcanvas.DefEnd()\n\treturn strings.Split(fontlist, \"|\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc googlefont(f string) []string {\n\turl := fmt.Sprintf(\"https://fonts.googleapis.com/css2?family=%s&display=swap\", f)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn []string{}\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\n\tcss := string(body)\n\tstart := strings.Index(css, \"@font-face\")\n\tif start == -1 {\n\t\treturn []string{}\n\t}\n\n\tcss = css[start:]\n\tlines := strings.Split(css, \"\\n\")\n\tvariants := make([]string, 0)\n\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"font-weight\") || strings.Contains(line, \"font-style\") {\n\t\t\tparts := strings.Split(line, \":\")\n\t\t\tif len(parts) > 1 {\n\t\t\t\tval := strings.TrimSpace(strings.TrimSuffix(parts[1], \";\"))\n\t\t\t\tvariants = append(variants, val)\n\t\t\t}\n\t\t}\n\t}\n\n\tresult := make([]string, 0)\n\tfor i := 0; i < len(variants); i += 2 {\n\t\tweight := variants[i]\n\t\tstyle := \"normal\"\n\t\tif i+1 < len(variants) {\n\t\t\tstyle = variants[i+1]\n\t\t}\n\t\tresult = append(result, fmt.Sprintf(\"%s|%s\", weight, style))\n\t}\n\n\treturn result\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL with optional custom headers and client configuration, while implementing safety measures like response size limiting and proper resource cleanup.\n\nFunction Description: The function `ReadURL` makes an HTTP GET request to the specified URL using a provided HTTP client and optional headers. It ensures proper resource cleanup, checks for successful response status, limits the maximum readable response size, and returns the response body or an error if any step fails.\n\nInput:\n- `url` [string] - The URL to send the GET request to\n- `client` [*http.Client] - The HTTP client to use for the request (can be nil to use http.DefaultClient)\n- `header` [*http.Header] - Optional headers to include in the request (can be nil)\n\nOutput:\n- `body` [[]byte] - The response body if the request is successful\n- `err` [error] - An error object if any step fails, including:\n  - Request creation failure\n  - Network errors\n  - Non-200 status codes (wrapped in HTTPError)\n  - Read errors\n  - Response size exceeding limit",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tmaxReadLength = 10 * 1 << 20\n)\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) (body []byte, err error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{\n\t\t\tStatusCode: resp.StatusCode,\n\t\t\tURL:        url,\n\t\t}\n\t}\n\n\tlimitedReader := &io.LimitedReader{R: resp.Body, N: maxReadLength}\n\tcontents, err := ioutil.ReadAll(limitedReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif limitedReader.N <= 0 {\n\t\treturn nil, errors.New(\"the read limit is reached\")\n\t}\n\n\treturn contents, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype HTTPError struct {\n\tCode int\n}\n\nfunc (e HTTPError) Error() string {\n\treturn fmt.Sprintf(\"HTTP error: status code %d\", e.Code)\n}\n\nvar (\n\tErrResponseTooLarge = fmt.Errorf(\"response body exceeds maximum allowed size\")\n)\n\nconst MaxResponseSize = 10 << 20 // 10 MB\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) ([]byte, error) {\n\tif client == nil {\n\t\tclient = http.DefaultClient\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), \"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, HTTPError{Code: resp.StatusCode}\n\t}\n\n\tvar buf bytes.Buffer\n\tlr := &io.LimitedReader{\n\t\tR: resp.Body,\n\t\tN: MaxResponseSize + 1,\n\t}\n\n\t_, err = io.Copy(&buf, lr)\n\tif err != nil && err != io.EOF {\n\t\treturn nil, err\n\t}\n\n\tif lr.N <= 0 {\n\t\treturn nil, ErrResponseTooLarge\n\t}\n\n\treturn buf.Bytes(), nil\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: The task involves creating a struct and associated method to handle chunked file uploads to a remote server using HTTP PUT requests with proper content range headers.\n\nStruct Description: The UploadSession struct represents an ongoing file upload session, tracking upload state, metadata, and providing methods for chunked upload operations.\n\nFields:\n\nID: string - Unique identifier for the upload session\nOldID: string - Previous session ID (if applicable)\nParentID: string - ID of parent directory\nNodeID: uint64 - Filesystem node identifier\nName: string - Name of the file being uploaded\nExpirationDateTime: time.Time - When the upload session expires\nSize: uint64 - Total size of the file in bytes\nData: []byte - File content data being uploaded\nQuickXORHash: string - File content hash\nModTime: time.Time - File modification time\nretries: int - Number of upload retry attempts\nUploadURL: string - Server endpoint for chunk uploads\nETag: string - Entity tag from server response\nstate: int - Current upload state\nerror: error - Last encountered error\nsync.Mutex: - Mutex for thread-safe operations\n\nMethods:\n\nuploadChunk: (auth *graph.Auth, offset uint64) -> ([]byte, int, error) - Uploads a file chunk starting at specified offset. Returns response body, HTTP status code, and error if any. Handles authentication refresh and proper Content-Range headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/jstaf/onedriver/fs/graph\"\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype UploadSession struct {\n\tID                 string    `json:\"id\"`\n\tOldID              string    `json:\"oldID\"`\n\tParentID           string    `json:\"parentID\"`\n\tNodeID             uint64    `json:\"nodeID\"`\n\tName               string    `json:\"name\"`\n\tExpirationDateTime time.Time `json:\"expirationDateTime\"`\n\tSize               uint64    `json:\"size,omitempty\"`\n\tData               []byte    `json:\"data,omitempty\"`\n\tQuickXORHash       string    `json:\"quickxorhash,omitempty\"`\n\tModTime            time.Time `json:\"modTime,omitempty\"`\n\tretries            int\n\n\tsync.Mutex\n\tUploadURL string `json:\"uploadUrl\"`\n\tETag      string `json:\"eTag,omitempty\"`\n\tstate     int\n\terror\n}\n\nfunc (u *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tu.Lock()\n\turl := u.UploadURL\n\tif url == \"\" {\n\t\tu.Unlock()\n\t\treturn nil, -1, errors.New(\"UploadSession UploadURL cannot be empty\")\n\t}\n\tu.Unlock()\n\n\tend := offset + uploadChunkSize\n\tvar reqChunkSize uint64\n\tif end > u.Size {\n\t\tend = u.Size\n\t\treqChunkSize = end - offset + 1\n\t}\n\tif offset > u.Size {\n\t\treturn nil, -1, errors.New(\"offset cannot be larger than DriveItem size\")\n\t}\n\n\tauth.Refresh()\n\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\n\t\t\"PUT\",\n\t\turl,\n\t\tbytes.NewReader((u.Data)[offset:end]),\n\t)\n\trequest.Header.Add(\"Content-Length\", strconv.Itoa(int(reqChunkSize)))\n\tfrags := fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, u.Size)\n\tlog.Info().Str(\"id\", u.ID).Msg(\"Uploading \" + frags)\n\trequest.Header.Add(\"Content-Range\", frags)\n\n\tresp, err := client.Do(request)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\tdefer resp.Body.Close()\n\tresponse, _ := ioutil.ReadAll(resp.Body)\n\treturn response, resp.StatusCode, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/microsoft/kiota-authentication-graph-go/graph\"\n)\n\ntype UploadSession struct {\n\tID               string\n\tOldID            string\n\tParentID         string\n\tNodeID           uint64\n\tName             string\n\tExpirationDateTime time.Time\n\tSize             uint64\n\tData             []byte\n\tQuickXORHash     string\n\tModTime          time.Time\n\tretries          int\n\tUploadURL        string\n\tETag             string\n\tstate            int\n\terror            error\n\tsync.Mutex\n}\n\nconst (\n\tuploadStateIdle = iota\n\tuploadStateUploading\n\tuploadStateCompleted\n\tuploadStateFailed\n)\n\nfunc (us *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tif auth == nil || us.UploadURL == \"\" || offset >= uint64(len(us.Data)) {\n\t\treturn nil, http.StatusBadRequest, fmt.Errorf(\"invalid parameters\")\n\t}\n\n\t// Define chunk size (e.g., 10 MB)\n\tconst chunkSize = 10 * 1024 * 1024\n\tend := offset + uint64(chunkSize)\n\tif end > uint64(len(us.Data)) {\n\t\tend = uint64(len(us.Data))\n\t}\n\tchunk := us.Data[offset:end]\n\n\t// Prepare request\n\treq, err := http.NewRequest(\"PUT\", us.UploadURL, bytes.NewBuffer(chunk))\n\tif err != nil {\n\t\tus.setError(fmt.Errorf(\"failed to create request: %w\", err))\n\t\treturn nil, http.StatusInternalServerError, us.error\n\t}\n\n\t// Set headers\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, len(us.Data)))\n\n\t// Authentication\n\ttoken, err := auth.GetAccessToken()\n\tif err != nil {\n\t\tus.setError(fmt.Errorf(\"failed to get access token: %w\", err))\n\t\treturn nil, http.StatusUnauthorized, us.error\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\t// Send request\n\tclient := &http.Client{Timeout: 30 * time.Second}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tus.setError(fmt.Errorf(\"request failed: %w\", err))\n\t\treturn nil, http.StatusGatewayTimeout, us.error\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read response body\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tus.setError(fmt.Errorf(\"failed to read response body: %w\", err))\n\t\treturn nil, http.StatusInternalServerError, us.error\n\t}\n\n\t// Handle response\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 300:\n\t\tus.ETag = resp.Header.Get(\"ETag\")\n\t\tus.state = uploadStateUploading\n\t\tif end == uint64(len(us.Data)) {\n\t\t\tus.state = uploadStateCompleted\n\t\t}\n\tcase resp.StatusCode >= 500:\n\t\tus.retries++\n\t\tif us.retries > 3 {\n\t\t\tus.state = uploadStateFailed\n\t\t}\n\tdefault:\n\t\tus.state = uploadStateFailed\n\t}\n\n\treturn body, resp.StatusCode, nil\n}\n\nfunc (us *UploadSession) setError(err error) {\n\tus.Lock()\n\tdefer us.Unlock()\n\tus.error = err\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The contents of the file as a byte slice\n- `error` - Any error encountered during the fetch operation (nil if successful)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n)\n\nvar (\n\tcacheDir = os.TempDir()\n\tcacheMu  sync.RWMutex\n\tverbose  = true\n)\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tfilename := filepath.Base(fileurl)\n\tcachePath := filepath.Join(cacheDir, filename)\n\n\t// Check cache first\n\tif content, err := os.ReadFile(cachePath); err == nil {\n\t\tlogVerbose(\"Using cached version of\", fileurl)\n\t\treturn content, nil\n\t}\n\n\tlogVerbose(\"Fetching\", fileurl)\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch file: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code %d while fetching %s\", resp.StatusCode, fileurl)\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\t// Save to cache\n\tcacheMu.Lock()\n\tdefer cacheMu.Unlock()\n\tif err := os.WriteFile(cachePath, content, 0644); err != nil {\n\t\tlogVerbose(\"Failed to write cache:\", err)\n\t}\n\n\treturn content, nil\n}\n\nfunc logVerbose(v ...interface{}) {\n\tif verbose {\n\t\tfmt.Println(v...)\n\t}\n}"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Implement a file fetcher with caching capability that retrieves files from a given URL using HTTP GET requests and caches the results to avoid redundant network calls.\n\nFunction Description: The FetchFile function checks a cache for the requested file URL. If not found in cache, it makes an HTTP GET request to fetch the file, stores the result in cache, and returns the file content. It handles errors during the fetch operation and returns appropriate status codes.\n\nInput: \n- fileurl [string]: The URL of the file to fetch\n\nOutput:\n- []byte: The content of the fetched file\n- error: Any error encountered during the fetch operation (network error, non-200 status code, or read error)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tinitializeFileCache()\n\tbytes, ok := fileCache[fileurl]\n\tif ok {\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t}\n\t\treturn bytes, nil\n\t}\n\tif verboseReader {\n\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tdefer response.Body.Close()\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar cache = struct {\n\tsync.RWMutex\n\tm map[string][]byte\n}{m: make(map[string][]byte)}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tcache.RLock()\n\tif content, ok := cache.m[fileurl]; ok {\n\t\tcache.RUnlock()\n\t\treturn content, nil\n\t}\n\tcache.RUnlock()\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcache.Lock()\n\tcache.m[fileurl] = content\n\tcache.Unlock()\n\n\treturn content, nil\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response body as a byte slice or an error if the request fails.\n\nFunction Description: The function makes an HTTP GET request to the provided URL, reads the response body, and returns it as a byte slice. It handles errors during the request or reading process and ensures the response body is properly closed to prevent resource leaks.\n\nInput: \n- url (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- ([]byte, error): A byte slice containing the response body if the request is successful, or an error if the request fails or the response body cannot be read.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.github.com/repos/zyedidia/micro/releases\")\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getResponseBody(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, &http.ProtocolError{ErrMsg: \"unexpected status code: \" + resp.Status}\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Write a Go function that retrieves the private IPv4 address of an Amazon EC2 instance by querying the instance metadata service.\n\nFunction Description: The function should make an HTTP GET request to the EC2 instance metadata service at the well-known endpoint (169.254.169.254) to fetch the local IPv4 address. It should handle potential errors during the request, response reading, and IP parsing, and return the IPv4 address in net.IP format.\n\nInput: None (the function takes no parameters)\n\nOutput: \n- On success: Returns the private IPv4 address as a net.IP object (IPv4 format)\n- On failure: Returns nil and an error describing what went wrong (failed request, invalid response, or invalid IP address)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc amazonEC2PrivateIPv4() (net.IP, error) {\n\tres, err := http.Get(\"http://169.254.169.254/latest/meta-data/local-ipv4\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tip := net.ParseIP(string(body))\n\tif ip == nil {\n\t\treturn nil, errors.New(\"invalid ip address\")\n\t}\n\treturn ip.To4(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc GetPrivateIPv4() (net.IP, error) {\n\tclient := &http.Client{\n\t\tTimeout: 10,\n\t}\n\n\treq, err := http.NewRequest(\"GET\", \"http://169.254.169.254/latest/meta-data/local-ipv4\", nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to perform request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\tip := net.ParseIP(string(body))\n\tif ip == nil {\n\t\treturn nil, fmt.Errorf(\"received invalid IP address: %s\", body)\n\t}\n\n\tif ip.To4() == nil {\n\t\treturn nil, fmt.Errorf(\"IP address is not IPv4: %s\", ip.String())\n\t}\n\n\treturn ip, nil\n}"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string]: The URL of the file to be fetched\n\nOutput: \n- `[]byte`: The contents of the file as a byte slice if successful\n- `error`: An error object if any step fails (network error, HTTP error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n)\n\nvar cacheDir = os.TempDir()\nvar cacheLock sync.RWMutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tfilename := filepath.Base(fileurl)\n\tcachePath := filepath.Join(cacheDir, filename)\n\n\tcacheLock.RLock()\n\tif data, err := os.ReadFile(cachePath); err == nil {\n\t\tcacheLock.RUnlock()\n\t\tlog.Printf(\"Cache hit for %s\\n\", fileurl)\n\t\treturn data, nil\n\t}\n\tcacheLock.RUnlock()\n\n\tlog.Printf(\"Fetching %s from network...\\n\", fileurl)\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"HTTP GET error: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP status error: %d\", resp.StatusCode)\n\t}\n\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"read response body error: %v\", err)\n\t}\n\n\tcacheLock.Lock()\n\tdefer cacheLock.Unlock()\n\tif err := os.WriteFile(cachePath, data, 0644); err != nil {\n\t\tlog.Printf(\"Failed to write cache: %v\\n\", err)\n\t}\n\n\treturn data, nil\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: The task involves creating a Go struct that encapsulates functionality for sending push notifications through a push service, handling HTTP communication, and processing responses. The struct should manage HTTP client configuration, request construction, and response handling for push notification delivery.\n\nStruct Description: PushServiceBase is a struct that provides base functionality for push notification services. It manages HTTP client configuration, constructs requests to a push service endpoint, handles authentication, processes responses, and manages delivery results. The struct is designed to be extended by specific push service implementations.\n\nFields:\n\nclient: [*http.Client] - Custom HTTP client configured with TLS settings and timeouts\ninitialism: [string] - Short identifier for the push service\nrawPayloadKey: [string] - Key for raw payload in notification data\nrawNotificationKey: [string] - Key for raw notification in notification data\nserviceURL: [string] - Base URL for the push service endpoint\npushServiceName: [string] - Name of the push service\n\nMethods:\n\nMakePushServiceBase: [func(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase] - Constructor that initializes the PushServiceBase with configuration and creates a custom HTTP client\n\nmulticast: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification)] - Sends push notifications to multiple devices, handles HTTP communication, and processes responses. Takes push service provider, delivery points, result channel, and notification as input, and writes results to the channel\n\nToCMPayload: [func(notif *push.Notification, regIds []string) ([]byte, error)] - Converts notification to payload format (implementation not shown in reference code)\n\nhandleCMMulticastResults: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult)] - Processes multicast results from push service (implementation not shown in reference code)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uniqush/uniqush-push/push\"\n\t\"github.com/uniqush/uniqush-push/util\"\n)\n\ntype PushServiceBase struct {\n\tclient             HTTPClient\n\tinitialism         string\n\trawPayloadKey      string\n\trawNotificationKey string\n\tserviceURL         string\n\tpushServiceName    string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\tconf := &tls.Config{InsecureSkipVerify: false}\n\ttr := &http.Transport{\n\t\tTLSClientConfig:     conf,\n\t\tTLSHandshakeTimeout: time.Second * 5,\n\t\tMaxIdleConnsPerHost: 500,\n\t}\n\tclient := &http.Client{\n\t\tTransport: tr,\n\t\tTimeout:   time.Second * 10,\n\t}\n\treturn PushServiceBase{\n\t\tclient:             client,\n\t\tinitialism:         initialism,\n\t\trawPayloadKey:      rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:         serviceURL,\n\t\tpushServiceName:    pushServiceName,\n\t}\n}\n\nfunc (psb *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tif len(dpList) == 0 {\n\t\treturn\n\t}\n\tregIds := extractRegIds(dpList)\n\n\tjpayload, e0 := psb.ToCMPayload(notif, regIds)\n\n\tif e0 != nil {\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, e0)\n\t\treturn\n\t}\n\n\treq, e1 := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewReader(jpayload))\n\tif req != nil {\n\t\tdefer req.Body.Close()\n\t}\n\tif e1 != nil {\n\t\thttpErr := push.NewErrorf(\"Error constructing HTTP request: %v\", e1)\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, httpErr)\n\t\treturn\n\t}\n\n\tapikey := psp.VolatileData[\"apikey\"]\n\n\treq.Header.Set(\"Authorization\", \"key=\"+apikey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tr, e2 := psb.client.Do(req)\n\tif r != nil {\n\t\tdefer r.Body.Close()\n\t}\n\tif e2 != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\n\t\t\tres.Destination = dp\n\t\t\tif err, ok := e2.(net.Error); ok {\n\t\t\t\tif err.Temporary() {\n\t\t\t\t\tafter := 3 * time.Second\n\t\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t\t}\n\t\t\t} else if err, ok := e2.(*net.DNSError); ok {\n\t\t\t\tafter := 3 * time.Second\n\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t} else {\n\t\t\t\tres.Err = push.NewErrorf(\"Unrecoverable HTTP error sending to %s: %v\", psb.pushServiceName, e2)\n\t\t\t}\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\t}\n\n\tnewAuthToken := r.Header.Get(\"Update-Client-Auth\")\n\tif newAuthToken != \"\" && apikey != newAuthToken {\n\t\tpsp.VolatileData[\"apikey\"] = newAuthToken\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewPushServiceProviderUpdate(psp)\n\t\tresQueue <- res\n\t}\n\n\tswitch r.StatusCode {\n\tcase 500, 503:\n\t\tafter := 0 * time.Second\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\t\t\tres.Destination = dp\n\t\t\terr := push.NewRetryError(psp, dp, notif, after)\n\t\t\tres.Err = err\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\tcase 401:\n\t\terr := push.NewBadPushServiceProviderWithDetails(psp, fmt.Sprintf(\"push service credentials rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\tcase 400:\n\t\terr := push.NewBadNotificationWithDetails(fmt.Sprintf(\"push notification payload rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tcontents, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to read %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tvar result CMResult\n\terr = json.Unmarshal(contents, &result)\n\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to decode %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, result.Results)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package push\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// CMResult represents the result from a push notification service\ntype CMResult struct {\n\t// Add appropriate fields based on expected response structure\n}\n\n// DeliveryPoint represents a target device for push notification delivery\ntype DeliveryPoint struct {\n\tToken string\n}\n\n// Result represents the outcome of a push notification attempt\ntype Result struct {\n\tSuccess bool\n\tError   error\n}\n\n// Notification contains data to be sent in a push notification\ntype Notification struct {\n\tData map[string]interface{}\n}\n\n// PushServiceProvider provides configuration and metadata for a push service\ntype PushServiceProvider struct {\n\tName string\n}\n\n// PushServiceBase encapsulates base functionality for push notification services\ntype PushServiceBase struct {\n\tclient              *http.Client\n\tinitialism          string\n\trawPayloadKey       string\n\trawNotificationKey  string\n\tserviceURL          string\n\tpushServiceName     string\n}\n\n// MakePushServiceBase initializes a new PushServiceBase instance\nfunc MakePushServiceBase(initialism, rawPayloadKey, rawNotificationKey, serviceURL, pushServiceName string) PushServiceBase {\n\treturn PushServiceBase{\n\t\tclient:             &http.Client{},\n\t\tinitialism:         initialism,\n\t\trawPayloadKey:      rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:         serviceURL,\n\t\tpushServiceName:    pushServiceName,\n\t}\n}\n\n// multicast sends push notifications to multiple devices and processes results\nfunc (psb *PushServiceBase) multicast(psp *PushServiceProvider, dpList []*DeliveryPoint, resQueue chan<- *Result, notif *Notification) {\n\tpayload, err := psb.ToCMPayload(notif, getRegistrationIDs(dpList))\n\tif err != nil {\n\t\tresQueue <- &Result{Success: false, Error: err}\n\t\treturn\n\t}\n\n\treq, err := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewBuffer(payload))\n\tif err != nil {\n\t\tresQueue <- &Result{Success: false, Error: err}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := psb.client.Do(req)\n\tif err != nil {\n\t\tresQueue <- &Result{Success: false, Error: err}\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tvar cmResults []CMResult\n\tif err := json.NewDecoder(resp.Body).Decode(&cmResults); err != nil {\n\t\tresQueue <- &Result{Success: false, Error: err}\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, cmResults)\n}\n\n// ToCMPayload converts a notification to the format expected by the push service\nfunc (psb *PushServiceBase) ToCMPayload(notif *Notification, regIds []string) ([]byte, error) {\n\t// Implementation would convert notification to service-specific payload\n\tpayload := map[string]interface{}{\n\t\t\"registration_ids\": regIds,\n\t\t\"data\":             notif.Data,\n\t}\n\treturn json.Marshal(payload)\n}\n\n// handleCMMulticastResults processes results from the push service\nfunc (psb *PushServiceBase) handleCMMulticastResults(psp *PushServiceProvider, dpList []*DeliveryPoint, resQueue chan<- *Result, notif *Notification, results []CMResult) {\n\t// Process each result and send to result channel\n\tfor _, result := range results {\n\t\t// Example logic - actual implementation would depend on CMResult structure\n\t\tsuccess := true // Determine success based on actual result data\n\t\tresQueue <- &Result{Success: success}\n\t}\n}\n\n// Helper function to extract registration IDs from delivery points\nfunc getRegistrationIDs(dpList []*DeliveryPoint) []string {\n\tregIds := make([]string, len(dpList))\n\tfor i, dp := range dpList {\n\t\tregIds[i] = dp.Token\n\t}\n\treturn regIds\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response validation, and resource cleanup. The function is designed to work with metadata services like Google Cloud's metadata server.\n\nInput:  \n- `key` (string): The metadata key to retrieve from the metadata server. This is appended to the base metadata path.\n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tbaseURL := \"http://metadata.google.internal/computeMetadata/v1/\"\n\turl := baseURL + key\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Metadata-token\", \"your-custom-token\")\n\treq.Header.Set(\"Metadata-flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Implement a function to fetch the contents of a file from a given URL and return it as an io.Reader for further processing.  \n\nFunction Description: The function `fetchFile` takes a URL as input, sends an HTTP GET request to fetch the file, reads the response body, and returns it as an `io.Reader`. It handles errors during the HTTP request and response reading.  \n\nInput:  \n- `URL` (string) - The URL of the file to be fetched.  \n\nOutput:  \n- `io.Reader` - A reader containing the contents of the fetched file.  \n\n(Note: The `checkErr` function is assumed to handle errors by panicking or logging.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n\tresp, err := http.Get(URL)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tcheckErr(err)\n\treturn strings.NewReader(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n    \"io\"\n    \"net/http\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n    resp, err := http.Get(URL)\n    if err != nil {\n        checkErr(err)\n    }\n    defer resp.Body.Close()\n\n    data, err := io.ReadAll(resp.Body)\n    if err != nil {\n        checkErr(err)\n    }\n\n    return io.NopCloser(io.NewSectionReader(bytes.NewReader(data), 0, int64(len(data))))\n}\n\nfunc checkErr(err error) {\n    if err != nil {\n        panic(err)\n    }\n}"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a function that fetches properties from a given URL, handles HTTP responses appropriately, and processes the content based on its encoding type.\n\nFunction Description: The function LoadURL makes an HTTP GET request to the specified URL, checks the response status code, reads the response body, and determines the content encoding based on the Content-Type header. It then processes the content and returns the parsed properties or an error if any step fails.\n\nInput: \n- url (string): The URL from which to fetch the properties.\n\nOutput: \n- (*Properties, error): A pointer to a Properties struct containing the parsed data and nil error on success, or nil and an error describing the failure.\n\nNote: The function handles special cases like 404 errors (when IgnoreMissing is true) and validates the Content-Type header before processing. It also ensures proper resource cleanup by deferring the closing of the response body.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc (l *Loader) LoadURL(url string) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: error fetching %q. %s\", url, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 404 && l.IgnoreMissing {\n\t\tLogPrintf(\"properties: %s returned %d. skipping\", url, resp.StatusCode)\n\t\treturn NewProperties(), nil\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"properties: %s returned %d\", url, resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: %s error reading response. %s\", url, err)\n\t}\n\n\tct := resp.Header.Get(\"Content-Type\")\n\tct = strings.Join(strings.Fields(ct), \"\")\n\tvar enc Encoding\n\tswitch strings.ToLower(ct) {\n\tcase \"text/plain\", \"text/plain;charset=iso-8859-1\", \"text/plain;charset=latin1\":\n\t\tenc = ISO_8859_1\n\tcase \"\", \"text/plain;charset=utf-8\":\n\t\tenc = UTF8\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"properties: invalid content type %s\", ct)\n\t}\n\n\treturn l.loadBytes(body, enc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Properties struct {\n\tData map[string]string\n}\n\nfunc LoadURL(url string, IgnoreMissing bool) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound && IgnoreMissing {\n\t\treturn &Properties{Data: make(map[string]string)}, nil\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif !strings.HasPrefix(contentType, \"text/plain\") && !strings.HasPrefix(contentType, \"application/json\") {\n\t\treturn nil, errors.New(\"unsupported content type\")\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tprops := &Properties{Data: make(map[string]string)}\n\n\tif strings.HasPrefix(contentType, \"text/plain\") {\n\t\tlines := strings.Split(string(body), \"\\n\")\n\t\tfor _, line := range lines {\n\t\t\tparts := strings.SplitN(line, \"=\", 2)\n\t\t\tif len(parts) == 2 {\n\t\t\t\tprops.Data[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])\n\t\t\t}\n\t\t}\n\t} else if strings.HasPrefix(contentType, \"application/json\") {\n\t\tvar jsonData map[string]string\n\t\tif err := json.Unmarshal(body, &jsonData); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tprops.Data = jsonData\n\t} else {\n\t\treturn nil, errors.New(\"failed to parse content\")\n\t}\n\n\treturn props, nil\n}"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a function that reads data from a given location, supporting HTTP/HTTPS protocols. The function should handle URL parsing, make HTTP requests, and return the response body or appropriate errors.\n\nFunction Description: The function `ReadLocation` takes a location string (URL) as input, parses it to determine the protocol, and if it's HTTP/HTTPS, makes a GET request to fetch the data. It handles response status checks, reads the response body, and ensures proper resource cleanup.\n\nInput: \n- `loc` (string): A URL string specifying the location to read from (e.g., \"http://example.com/data\")\n\nOutput: \n- `[]byte`: The response body as a byte slice if successful\n- `error`: An error object describing any issues encountered during URL parsing, HTTP request, or response handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tu, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch u.Scheme {\n\tcase \"http\", \"https\":\n\t\tres, err := http.Get(loc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer res.Body.Close()\n\t\tif res.StatusCode != http.StatusOK {\n\t\t\treturn nil, fmt.Errorf(\"%s\", res.Status)\n\t\t}\n\t\tb, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn b, nil\n\t}\n\treturn nil, fmt.Errorf(\"Unsupported location to load: %s\", loc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tparsedURL, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, errors.New(\"invalid URL: \" + err.Error())\n\t}\n\n\tif parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https\" {\n\t\treturn nil, errors.New(\"unsupported protocol: \" + parsedURL.Scheme)\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", loc, nil)\n\tif err != nil {\n\t\treturn nil, errors.New(\"request creation failed: \" + err.Error())\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, errors.New(\"request execution failed: \" + err.Error())\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, errors.New(\"non-200 status code: \" + resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to read response body: \" + err.Error())\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Implement a GIF search functionality using the Giphy API in Go, handling HTTP requests, response parsing, and error management.\n\nStruct Description: The Gifs struct represents a service for searching GIFs using the Giphy API. It maintains configuration and provides methods to interact with the API.\n\nFields:\n- conf: [conf] - Configuration containing the Giphy API key\n\nMethods:\n- New: [func() *Gifs] - Initializes a new Gifs instance by loading configuration\n- Search: [func(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error] - Searches for GIFs using the Giphy API with the provided query and parameters\n\nInput:\n- ctx: [context.Context] - Context for request cancellation and timeouts\n- request: [*gifs.SearchRequest] - Contains search parameters (query, limit, offset, rating, language)\n- response: [*gifs.SearchResponse] - Will be populated with search results\n\nOutput:\n- error: Returns nil on success or an appropriate error on failure",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/config\"\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tgifs \"github.com/micro/services/gifs/proto\"\n)\n\ntype conf struct {\n\tAPIKey string `json:\"api_key\"`\n}\n\ntype Gifs struct {\n\tconf conf\n}\n\nfunc New() *Gifs {\n\tv, err := config.Get(\"micro.gifs\")\n\tif err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\tvar c conf\n\tif err := v.Scan(&c); err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\n\treturn &Gifs{conf: c}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error {\n\tif len(request.Query) == 0 {\n\t\treturn errors.BadRequest(\"gifs.Search\", \"Missing query field\")\n\t}\n\tlimit := defaultLimit\n\tif request.Limit > 0 {\n\t\tlimit = request.Limit\n\t}\n\toffset := defaultOffset\n\tif request.Offset > 0 {\n\t\toffset = request.Offset\n\t}\n\n\trating := defaultRating\n\tif len(request.Rating) > 0 {\n\t\trating = request.Rating\n\t}\n\tlan := defaultLang\n\tif len(request.Lang) > 0 {\n\t\tlan = request.Lang\n\t}\n\trsp, err := http.Get(fmt.Sprintf(giphySearch, g.conf.APIKey, request.Query, limit, offset, rating, lan))\n\tif err != nil {\n\t\tlogger.Errorf(\"Error querying giphy %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tdefer rsp.Body.Close()\n\tb, err := ioutil.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tvar gRsp searchResponse\n\tif err := json.Unmarshal(b, &gRsp); err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tresponse.Data = marshalGifs(gRsp.Data)\n\tresponse.Pagination = &gifs.Pagination{\n\t\tOffset:     gRsp.Pagination.Offset,\n\t\tTotalCount: gRsp.Pagination.TotalCount,\n\t\tCount:      gRsp.Pagination.Count,\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package gifs\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\ntype Gifs struct {\n\tconf *conf\n}\n\ntype conf struct {\n\tGiphyAPIKey string\n}\n\nfunc New() *Gifs {\n\treturn &Gifs{\n\t\tconf: &conf{\n\t\t\tGiphyAPIKey: \"your-giphy-api-key-here\",\n\t\t},\n\t}\n}\n\ntype SearchRequest struct {\n\tQuery    string\n\tLimit    int\n\tOffset   int\n\tRating   string\n\tLanguage string\n}\n\ntype SearchResponse struct {\n\tGIFs []GIF `json:\"gifs\"`\n}\n\ntype GIF struct {\n\tURL string `json:\"url\"`\n}\n\nconst giphyAPIURL = \"https://api.giphy.com/v1/gifs/search\"\n\nfunc (g *Gifs) Search(ctx context.Context, req *SearchRequest, resp *SearchResponse) error {\n\treqURL, err := url.Parse(giphyAPIURL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse base URL: %w\", err)\n\t}\n\n\tparams := url.Values{}\n\tparams.Add(\"api_key\", g.conf.GiphyAPIKey)\n\tparams.Add(\"q\", req.Query)\n\tparams.Add(\"limit\", strconv.Itoa(req.Limit))\n\tparams.Add(\"offset\", strconv.Itoa(req.Offset))\n\tif req.Rating != \"\" {\n\t\tparams.Add(\"rating\", req.Rating)\n\t}\n\tif req.Language != \"\" {\n\t\tparams.Add(\"lang\", req.Language)\n\t}\n\n\treqURL.RawQuery = params.Encode()\n\n\thttpReq, err := http.NewRequestWithContext(ctx, \"GET\", reqURL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTTP request: %w\", err)\n\t}\n\n\thttpClient := &http.Client{}\n\thttpResp, err := httpClient.Do(httpReq)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"HTTP request failed: %w\", err)\n\t}\n\tdefer httpResp.Body.Close()\n\n\tif httpResp.StatusCode < 200 || httpResp.StatusCode >= 300 {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", httpResp.StatusCode)\n\t}\n\n\tbody, err := io.ReadAll(httpResp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\tvar apiResponse struct {\n\t\tData []struct {\n\t\t\tImages struct {\n\t\t\t\tOriginal struct {\n\t\t\t\t\tURL string `json:\"url\"`\n\t\t\t\t} `json:\"original\"`\n\t\t\t} `json:\"images\"`\n\t\t} `json:\"data\"`\n\t}\n\n\tif err := json.Unmarshal(body, &apiResponse); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal JSON response: %w\", err)\n\t}\n\n\tresp.GIFs = make([]GIF, len(apiResponse.Data))\n\tfor i, item := range apiResponse.Data {\n\t\tresp.GIFs[i].URL = item.Images.Original.URL\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response processing, and error checking. The function ensures proper resource cleanup by deferring the closing of the response body.\n\nInput:  \n- `key` (string): The metadata key to be appended to the metadata server's base path.  \n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", \"http://metadata.server/\"+key, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %v\", err)\n\t}\n\n\treq.Header.Set(\"X-Metadata-Token\", \"secret-token\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a function to fetch and update search configuration from a remote URL, comparing it with the current configuration and updating if different.\n\nFunction Description: The function fetchSearchConfig retrieves search configuration from a predefined URL, normalizes it, compares it with the current configuration, and updates the system state if the new configuration is different. It handles HTTP requests, response reading, and configuration normalization.\n\nInput: None (uses predefined searchConfigURL and relies on the Server's state)\n\nOutput: error - Returns an error if any step fails (HTTP request, reading response, normalization, or configuration loading), or nil if successful (whether updated or no change needed)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nvar currentConfig, _ = normalize(defaultSearchConfig)\n\nfunc (s *Server) fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tnewConfig, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewConfig, err = normalize(newConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bytes.Equal(currentConfig, newConfig) {\n\t\treturn nil\n\t}\n\tif err := s.scraper.LoadConfig(newConfig); err != nil {\n\t\treturn err\n\t}\n\ts.state.SearchProviders = s.scraper.Config\n\ts.state.Push()\n\tcurrentConfig = newConfig\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n)\n\ntype Server struct {\n\tsearchConfig map[string]interface{}\n}\n\nconst searchConfigURL = \"https://example.com/config/search.json\"\n\nfunc (s *Server) fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to fetch search config: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvar config map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&config); err != nil {\n\t\treturn fmt.Errorf(\"failed to decode response body: %w\", err)\n\t}\n\n\tnormalized, err := normalizeConfig(config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to normalize config: %w\", err)\n\t}\n\n\tif !reflect.DeepEqual(s.searchConfig, normalized) {\n\t\ts.searchConfig = normalized\n\t\tfmt.Println(\"Search configuration updated\")\n\t} else {\n\t\tfmt.Println(\"Search configuration unchanged\")\n\t}\n\n\treturn nil\n}\n\nfunc normalizeConfig(config map[string]interface{}) (map[string]interface{}, error) {\n\tresult := make(map[string]interface{})\n\tfor k, v := range config {\n\t\tswitch val := v.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tnested, err := normalizeConfig(val)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresult[k] = nested\n\t\tcase []interface{}:\n\t\t\tresult[k] = deepCopySlice(val)\n\t\tdefault:\n\t\t\tresult[k] = val\n\t\t}\n\t}\n\treturn result, nil\n}\n\nfunc deepCopySlice(slice []interface{}) []interface{} {\n\tnewSlice := make([]interface{}, len(slice))\n\tcopy(newSlice, slice)\n\treturn newSlice\n}"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The `fetchFile` function retrieves the contents of a file from a specified URL using HTTP GET. It supports optional caching of file contents to avoid redundant network requests for the same URL. The function handles HTTP errors and returns the file contents as a byte array if successful.\n\nInput: \n- `fileurl` [string] - The URL of the file to fetch\n\nOutput: \n- `[]byte` - The contents of the file as a byte array\n- `error` - An error object if the fetch operation fails (either network error or non-200 HTTP status)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar cache = struct {\n\tsync.RWMutex\n\tm map[string][]byte\n}{m: make(map[string][]byte)}\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tcache.RLock()\n\tif data, ok := cache.m[fileurl]; ok {\n\t\tcache.RUnlock()\n\t\treturn data, nil\n\t}\n\tcache.RUnlock()\n\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"HTTP GET error: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"non-200 HTTP status: %d\", resp.StatusCode)\n\t}\n\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading response body error: %w\", err)\n\t}\n\n\tcache.Lock()\n\tcache.m[fileurl] = data\n\tcache.Unlock()\n\n\treturn data, nil\n}"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a RabbitMQ consumer in Go that connects to a RabbitMQ server, declares necessary exchanges and queues, binds them, and consumes messages from the queue. The consumer should be able to gracefully shut down when requested.\n\nStruct Description: The Consumer struct represents a RabbitMQ consumer with connection and channel management capabilities. It handles the lifecycle of consuming messages from a RabbitMQ queue and provides shutdown functionality.\n\nFields:\n- conn: *amqp.Connection - The connection to the RabbitMQ server\n- channel: *amqp.Channel - The communication channel for RabbitMQ operations\n- tag: string - The consumer tag for identifying this consumer\n- done: chan error - Channel for signaling when the consumer has finished shutting down\n\nMethods:\n- NewConsumer: (amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) -> (*Consumer, error) - Creates a new Consumer instance, establishes connection, declares exchange and queue, binds them, and starts consuming messages\n- Shutdown: () -> error - Gracefully shuts down the consumer by canceling consumption and closing the connection\n- handle: (deliveries <-chan amqp.Delivery, done chan error) -> () - Internal method for processing incoming messages (note: this is not exported as it starts with lowercase)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tc := &Consumer{\n\t\tconn:    nil,\n\t\tchannel: nil,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tvar err error\n\n\tlog.Printf(\"dialing %q\", amqpURI)\n\tc.conn, err = amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Dial: %s\", err)\n\t}\n\n\tgo func() {\n\t\tfmt.Printf(\"closing: %s\", <-c.conn.NotifyClose(make(chan *amqp.Error)))\n\t}()\n\n\tlog.Printf(\"got Connection, getting Channel\")\n\tc.channel, err = c.conn.Channel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Channel: %s\", err)\n\t}\n\n\tlog.Printf(\"got Channel, declaring Exchange (%q)\", exchange)\n\tif err = c.channel.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Exchange Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Exchange, declaring Queue %q\", queueName)\n\tqueue, err := c.channel.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Queue (%q %d messages, %d consumers), binding to Exchange (key %q)\",\n\t\tqueue.Name, queue.Messages, queue.Consumers, key)\n\n\tif err = c.channel.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Bind: %s\", err)\n\t}\n\n\tlog.Printf(\"Queue bound to Exchange, starting Consume (consumer tag %q)\", c.tag)\n\tdeliveries, err := c.channel.Consume(\n\t\tqueue.Name,\n\t\tc.tag,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Consume: %s\", err)\n\t}\n\n\tgo handle(deliveries, c.done)\n\n\treturn c, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn fmt.Errorf(\"Consumer cancel failed: %s\", err)\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn fmt.Errorf(\"AMQP connection close error: %s\", err)\n\t}\n\n\treturn <-c.done\n}\n\nfunc handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\n\t\t\t\"got %dB delivery: [%v] %q\",\n\t\t\tlen(d.Body),\n\t\t\td.DeliveryTag,\n\t\t\td.Body,\n\t\t)\n\t\td.Ack(false)\n\t}\n\tdone <- nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 122,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) (*Consumer, error) {\n\tconn, err := amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\terr = ch.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tconn.Close()\n\t\tch.Close()\n\t\treturn nil, err\n\t}\n\n\tqueue, err := ch.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tconn.Close()\n\t\tch.Close()\n\t\treturn nil, err\n\t}\n\n\terr = ch.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tconn.Close()\n\t\tch.Close()\n\t\treturn nil, err\n\t}\n\n\tdeliveries, err := ch.Consume(\n\t\tqueue.Name,\n\t\tctag,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tconn.Close()\n\t\tch.Close()\n\t\treturn nil, err\n\t}\n\n\tconsumer := &Consumer{\n\t\tconn:    conn,\n\t\tchannel: ch,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tgo consumer.handle(deliveries, consumer.done)\n\n\treturn consumer, nil\n}\n\nfunc (c *Consumer) handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\td.Ack(false)\n\t}\n\tdone <- nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\n\treturn <-c.done\n}\n\nfunc main() {\n\tamqpURI := \"amqp://guest:guest@localhost:5672/\"\n\texchange := \"test_exchange\"\n\texchangeType := \"direct\"\n\tqueueName := \"test_queue\"\n\tkey := \"test_key\"\n\tctag := \"consumer_tag\"\n\n\tconsumer, err := NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create consumer: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := consumer.Shutdown(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to shutdown consumer: %v\", err)\n\t\t}\n\t}()\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t<-sigChan\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a PKCE (Proof Key for Code Exchange) authorization flow in Go that handles OAuth2 token retrieval through a temporary HTTP server.\n\nStruct Description: PKCEAuthorizationFlow represents an OAuth2 authorization flow using PKCE (Proof Key for Code Exchange) mechanism. It manages the state, code verifier, and OAuth configuration needed for the flow, and provides methods to wait for and handle tokens.\n\nFields:\nproviderConfig: [internal.PKCEAuthProviderConfig] - Configuration for the PKCE auth provider\nstate: [string] - CSRF protection state value\ncodeVerifier: [string] - PKCE code verifier string\noAuthConfig: [*oauth2.Config] - OAuth2 configuration including client ID, secret, and endpoints\n\nMethods:\nWaitToken: [Name](ctx context.Context, _ AuthFlowInfo) -> (TokenInfo, error) - Main method that waits for token retrieval by starting a temporary HTTP server and handling the OAuth callback\nstartServer: [Name](server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) - Starts an HTTP server to handle OAuth callback and sends results through channels\nhandleRequest: [Name](req *http.Request) -> (*oauth2.Token, error) - Handles incoming OAuth callback request, validates state, and exchanges code for token",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (p *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\ttokenChan := make(chan *oauth2.Token, 1)\n\terrChan := make(chan error, 1)\n\n\tparsedURL, err := url.Parse(p.oAuthConfig.RedirectURL)\n\tif err != nil {\n\t\treturn TokenInfo{}, fmt.Errorf(\"failed to parse redirect URL: %v\", err)\n\t}\n\n\tserver := &http.Server{Addr: fmt.Sprintf(\":%s\", parsedURL.Port())}\n\tdefer func() {\n\t\tshutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(shutdownCtx); err != nil {\n\t\t\tlog.Errorf(\"failed to close the server: %v\", err)\n\t\t}\n\t}()\n\n\tgo p.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\treturn p.parseOAuthToken(token)\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tcert := p.providerConfig.ClientCertPair\n\t\tif cert != nil {\n\t\t\ttr := &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\tCertificates: []tls.Certificate{*cert},\n\t\t\t\t},\n\t\t\t}\n\t\t\tsslClient := &http.Client{Transport: tr}\n\t\t\tctx := context.WithValue(req.Context(), oauth2.HTTPClient, sslClient)\n\t\t\treq = req.WithContext(ctx)\n\t\t}\n\n\t\ttoken, err := p.handleRequest(req)\n\t\tif err != nil {\n\t\t\trenderPKCEFlowTmpl(w, err)\n\t\t\terrChan <- fmt.Errorf(\"PKCE authorization flow failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\trenderPKCEFlowTmpl(w, nil)\n\t\ttokenChan <- token\n\t})\n\n\tserver.Handler = mux\n\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\terrChan <- err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\n\tif authError := query.Get(queryError); authError != \"\" {\n\t\tauthErrorDesc := query.Get(queryErrorDesc)\n\t\treturn nil, fmt.Errorf(\"%s.%s\", authError, authErrorDesc)\n\t}\n\n\tif state := query.Get(queryState); subtle.ConstantTimeCompare([]byte(p.state), []byte(state)) == 0 {\n\t\treturn nil, fmt.Errorf(\"invalid state\")\n\t}\n\n\tcode := query.Get(queryCode)\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code\")\n\t}\n\n\treturn p.oAuthConfig.Exchange(\n\t\treq.Context(),\n\t\tcode,\n\t\toauth2.SetAuthURLParam(\"code_verifier\", p.codeVerifier),\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"golang.org/x/oauth2\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype AuthFlowInfo struct {\n\tCodeVerifier string\n\tState        string\n}\n\ntype TokenInfo struct {\n\tToken *oauth2.Token\n}\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (f *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn TokenInfo{}, err\n\t}\n\tdefer listener.Close()\n\n\tserver := &http.Server{\n\t\tAddr:    listener.Addr().String(),\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tf.handleRequest(r)\n\t\t}),\n\t}\n\n\ttokenChan := make(chan *oauth2.Token)\n\terrChan := make(chan error)\n\n\tgo f.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\t_ = server.Shutdown(context.Background())\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\t_ = server.Shutdown(context.Background())\n\t\treturn TokenInfo{Token: token}, nil\n\tcase err := <-errChan:\n\t\t_ = server.Shutdown(context.Background())\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (f *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttoken, err := f.handleRequest(r)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Authentication failed\", http.StatusInternalServerError)\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprintf(w, \"Authentication successful! You can close this window.\")\n\t\ttokenChan <- token\n\t})\n\n\terr := server.ListenAndServe()\n\tif err != nil && err != http.ErrServerClosed {\n\t\terrChan <- err\n\t}\n}\n\nfunc (f *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\tstate := query.Get(\"state\")\n\tif state != f.state {\n\t\treturn nil, fmt.Errorf(\"invalid state parameter\")\n\t}\n\n\tcode := query.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code parameter\")\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\ttoken, err := f.oAuthConfig.Exchange(ctx, code, oauth2.VerifierOption(f.codeVerifier))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to exchange token: %w\", err)\n\t}\n\n\treturn token, nil\n}"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that establishes multiple concurrent connections to a WebSocket server, maintains these connections, and handles incoming messages. The client should be able to gracefully handle connection errors and properly close connections when done.\n\nFunction Description: The function establishes WebSocket connections to a specified server endpoint with unique identifiers, maintains these connections in separate goroutines, and continuously reads incoming messages. Each connection includes user identification and authentication parameters in the URL query string.\n\nInput: \n- None (The function uses hardcoded values for demonstration, but could be modified to accept parameters like host, port, path, and connection count)\n\nOutput: \n- None (The function primarily logs its activities and errors to stdout)\n\nNote: The function runs indefinitely until 100,000 connections are established (for testing purposes), with each connection attempt spaced by 1 second. Each connection runs in its own goroutine and includes error handling for both connection establishment and message reading.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n)\n\nfunc Test(t *testing.T) {\n\ti := 0\n\tfor {\n\t\ti++\n\t\tif i == 100000 {\n\t\t\tfmt.Println(\"\u5df2\u7ecf\u4e86\u89e310000\u4e2a\u94fe\u63a5\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tgo func(id int) {\n\t\t\tu := url.URL{Scheme: \"ws\", Host: \"127.0.0.1:8182\", Path: \"/v1/push\", RawQuery: fmt.Sprintf(\"uid=%d&sign=2&time=%d\", id, time.Now().Unix())}\n\t\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"\u94fe\u63a5\u5730\u5740%s,\u5931\u8d25\u539f\u56e0%s\", u.String(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tfor {\n\t\t\t\t_, _, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"ERR_ERR_ERR_ERR_ERR_ERR_read:\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\thost         = \"ws://localhost\"\n\tport         = \"8080\"\n\tpath         = \"/ws\"\n\tconnectionCount = 100000\n\tmaxRetries     = 3\n\tretryDelay     = 5 * time.Second\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc connectWebSocket(connID int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tu := url.URL{\n\t\tScheme: \"ws\",\n\t\tHost:   fmt.Sprintf(\"%s:%s\", host, port),\n\t\tPath:   path,\n\t}\n\tquery := u.Query()\n\tquery.Add(\"id\", fmt.Sprintf(\"client-%d\", connID))\n\tquery.Add(\"token\", fmt.Sprintf(\"auth-token-%d\", connID))\n\tu.RawQuery = query.Encode()\n\n\tvar conn *websocket.Conn\n\tvar err error\n\n\tfor i := 0; i < maxRetries; i++ {\n\t\tconn, _, err = websocket.DefaultDialer.Dial(u.String(), nil)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Connection attempt %d for client %d failed: %v\", i+1, connID, err)\n\t\ttime.Sleep(retryDelay)\n\t}\n\n\tif err != nil {\n\t\tlog.Printf(\"Failed to connect client %d after %d attempts: %v\", connID, maxRetries, err)\n\t\treturn\n\t}\n\n\tlog.Printf(\"Connected client %d to %s\", connID, u.String())\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tlog.Printf(\"Closing connection for client %d\", connID)\n\t\t\terr := conn.Close()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error closing connection for client %d: %v\", connID, err)\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d read error: %v\", connID, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Client %d received: %s\", connID, message)\n\t\t}\n\t}()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < connectionCount; i++ {\n\t\twg.Add(1)\n\t\tgo connectWebSocket(i, &wg)\n\t\ttime.Sleep(1 * time.Second)\n\t}\n\n\twg.Wait()\n\tlog.Println(\"All connections have been processed\")\n}"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that connects to a server, sends multiple messages at random intervals, and handles incoming messages concurrently.\n\nFunction Description: The function establishes a WebSocket connection to a specified server, spawns a goroutine to continuously read incoming messages, and sends a random number of messages to the server with small delays between each send. The function should properly handle connection errors and ensure the connection is closed when done.\n\nInput:\n- i (int64): Seed value for random number generation\n- room (string): Identifier for the message room/context\n\nOutput: None (the function performs operations but doesn't return any value)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/rs/xid\"\n)\n\nfunc testClient(i int64, room string) {\n\tr := rand.New(rand.NewSource(i))\n\tconn, _, err := websocket.DefaultDialer.Dial(SERVER, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\t_ = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\t\t\t_, _, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tdefer conn.Close()\n\n\tops := r.Intn(100)\n\tfor i := 0; i < ops; i++ {\n\t\tm := msg(r, room)\n\t\terr = conn.WriteMessage(websocket.TextMessage, m)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"err\", err)\n\t\t}\n\t\ttime.Sleep(30 * time.Millisecond)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.DefaultDialer\n\nfunc runWebSocketClient(i int64, room string) {\n\trand.Seed(i)\n\turl := \"ws://example.com/socket\" // Replace with actual server URL\n\tconn, _, err := upgrader.Dial(url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Connection error:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Read error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"Received: %s\\n\", message)\n\t\t}\n\t}()\n\n\tnumMessages := rand.Intn(10) + 5\n\tfor j := 0; j < numMessages; j++ {\n\t\tmsg := fmt.Sprintf(\"{\\\"room\\\": \\\"%s\\\", \\\"message\\\": \\\"Hello from seed %d, message %d\\\"}\", room, i, j)\n\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Write error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tdelay := time.Duration(rand.Intn(1000)+500) * time.Millisecond\n\t\ttime.Sleep(delay)\n\t}\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second * 5):\n\t\tfmt.Println(\"Timeout waiting for server messages\")\n\t}\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a WebSocket client in Go that connects to a server, handles incoming messages, and manages connection lifecycle including reconnection logic and graceful shutdown.\n\nFunction Description: The function establishes a WebSocket connection to a specified server endpoint, listens for incoming messages, and prints them to stdout/stderr based on message content. It handles connection errors by implementing automatic reconnection logic and supports graceful shutdown upon receiving an interrupt signal.\n\nInput: None (uses package-level configuration variables for connection details)\n\nOutput: None (writes directly to stdout/stderr, logs to console)\n\nNote: The function relies on several external configuration variables:\n- config.Config.Tap.Proxy.Host (string) - Server hostname\n- config.Config.Tap.Proxy.Front.Port (int) - Server port\n- config.Config.License (string) - License key for authentication\n- kubernetes.GetHubUrl() (string) - Function to get hub URL for health checks",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/kubeshark/kubeshark/config\"\n\t\"github.com/kubeshark/kubeshark/utils\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc runConsoleWithoutProxy() {\n\tlog.Info().Msg(\"Starting scripting console ...\")\n\ttime.Sleep(5 * time.Second)\n\thubUrl := kubernetes.GetHubUrl()\n\tfor {\n\t\tresponse, err := http.Get(fmt.Sprintf(\"%s/echo\", hubUrl))\n\t\tif err != nil || response.StatusCode != 200 {\n\t\t\tlog.Info().Msg(fmt.Sprintf(utils.Yellow, \"Couldn't connect to Hub.\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tinterrupt := make(chan os.Signal, 1)\n\t\tsignal.Notify(interrupt, os.Interrupt)\n\n\t\tlog.Info().Str(\"host\", config.Config.Tap.Proxy.Host).Str(\"url\", hubUrl).Msg(\"Connecting to:\")\n\t\tu := url.URL{\n\t\t\tScheme: \"ws\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%d\", config.Config.Tap.Proxy.Host, config.Config.Tap.Proxy.Front.Port),\n\t\t\tPath:   \"/api/scripts/logs\",\n\t\t}\n\t\theaders := http.Header{}\n\t\theaders.Set(utils.X_KUBESHARK_CAPTURE_HEADER_KEY, utils.X_KUBESHARK_CAPTURE_HEADER_IGNORE_VALUE)\n\t\theaders.Set(\"License-Key\", config.Config.License)\n\n\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), headers)\n\t\tif err != nil {\n\t\t\tlog.Error().Err(err).Msg(\"Websocket dial error, retrying in 5 seconds...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tdefer c.Close()\n\n\t\tdone := make(chan struct{})\n\n\t\tgo func() {\n\t\t\tdefer close(done)\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error().Err(err).Msg(\"Error reading websocket message, reconnecting...\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tmsg := string(message)\n\t\t\t\tif strings.Contains(msg, \":ERROR]\") {\n\t\t\t\t\tmsg = fmt.Sprintf(utils.Red, msg)\n\t\t\t\t\tfmt.Fprintln(os.Stderr, msg)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintln(os.Stdout, msg)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tticker := time.NewTicker(time.Second)\n\t\tdefer ticker.Stop()\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\tlog.Warn().Msg(fmt.Sprintf(utils.Yellow, \"Connection closed, reconnecting...\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\tcase <-interrupt:\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Error().Err(err).Send()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tinterruptSignal = make(chan os.Signal, 1)\n)\n\nfunc connectAndManageWebSocket() {\n\tsignal.Notify(interruptSignal, os.Interrupt)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tgo func() {\n\t\t<-interruptSignal\n\t\tlog.Println(\"Interrupt received, shutting down gracefully...\")\n\t\tcancel()\n\t}()\n\n\tfor {\n\t\tif ctx.Err() != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tu := url.URL{\n\t\t\tScheme: \"ws\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%d\", config.Config.Tap.Proxy.Host, config.Config.Tap.Proxy.Front.Port),\n\t\t\tPath:   \"/ws\",\n\t\t}\n\n\t\theader := make(map[string][]string)\n\t\theader[\"Authorization\"] = []string{\"Bearer \" + config.Config.License}\n\n\t\tconn, _, err := websocket.DefaultDialer.DialContext(ctx, u.String(), header)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Connection failed: %v. Retrying in 5 seconds...\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Println(\"Connected to WebSocket server\")\n\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tlog.Println(\"Closing connection...\")\n\t\t\tconn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tconn.Close()\n\t\t}()\n\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error reading message: %v. Reconnecting...\", err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif string(message) == \"health_check\" {\n\t\t\t\thubURL := kubernetes.GetHubUrl()\n\t\t\t\tlog.Printf(\"Received health check. Current hub URL: %s\", hubURL)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(message) > 0 && message[0] == '{' {\n\t\t\t\tos.Stdout.WriteString(string(message) + \"\\n\")\n\t\t\t} else {\n\t\t\t\tos.Stderr.WriteString(string(message) + \"\\n\")\n\t\t\t}\n\t\t}\n\n\t\tlog.Println(\"Connection closed. Reconnecting in 5 seconds...\")\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a function that handles WebSocket connections by upgrading HTTP connections, reading incoming messages, and forwarding them to a channel for further processing.\n\nFunction Description: The function `makeUpgradeOnConnect` generates and returns an HTTP handler function that upgrades incoming HTTP connections to WebSocket connections. It reads messages from the WebSocket connection and sends them to a provided channel. The WebSocket connection is properly closed when processing is complete.\n\nInput: \n- `ch chan string`: A channel of strings used to forward incoming WebSocket messages for further processing.\n\nOutput: \n- Returns a function of type `func(http.ResponseWriter, *http.Request)` that serves as an HTTP handler for WebSocket connections.\n\nNote: The returned HTTP handler function does not explicitly return any value but handles WebSocket communication and message forwarding internally.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer c.Close()\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tch <- string(message)\n\t\t\t}()\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Could not open websocket connection\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tfor {\n\t\t\tmessageType, p, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif messageType == websocket.TextMessage {\n\t\t\t\tch <- string(p)\n\t\t\t}\n\t\t}\n\n\t\tconn.Close()\n\t}\n}"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Implement a WebSocket handler for shell communication that manages bidirectional data transfer between local and remote connections, including connection upgrading, message forwarding, and proper connection cleanup.\n\nStruct Description: The Shell struct represents a shell session manager that maintains active connections and handles WebSocket communication for shell data transfer.\n\nFields:\n- Name: string - Identifier for the shell session\n- links: map[string]*Link - Map of active connections indexed by connection ID\n- RWMutex: sync.RWMutex - Synchronization primitive for thread-safe access to the links map\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages bidirectional data forwarding between local and remote connections\n- localForward: (id string, local *websocket.Conn) -> None - Reads data from local WebSocket connection and forwards to remote\n- remoteForward: (id string, local *websocket.Conn) -> None - Reads data from remote connection and forwards to local WebSocket",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype Shell struct {\n\tName string\n\tlinks map[string]*Link\n\tsync.RWMutex\n}\n\nfunc (shell *Shell) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogging.Error(\"upgrade websocket failed: %s, err=%v\", shell.Name, err)\n\t\thttp.Error(w, err.Error(), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tdefer local.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.localForward(id, local)\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.remoteForward(id, local)\n\t}()\n\twg.Wait()\n}\n\nfunc (shell *Shell) localForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"localForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tdefer link.Close(true)\n\tfor {\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"read local data for %s failed: %v\", shell.Name, err)\n\t\t\treturn\n\t\t}\n\t\tlink.SendData(data)\n\t\tlogging.Debug(\"local read %d bytes: name=%s, id=%s\", len(data), shell.Name, id)\n\t}\n}\n\nfunc (shell *Shell) remoteForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tch := link.remote.ChanRead(id)\n\tdefer link.Close(true)\n\tfor {\n\t\tmsg := <-ch\n\t\tif msg == nil {\n\t\t\treturn\n\t\t}\n\t\tdata, _ := proto.Marshal(msg)\n\t\tlink.recvBytes += uint64(len(data))\n\t\tlink.recvPacket++\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_shell_data:\n\t\t\terr := local.WriteMessage(websocket.TextMessage, msg.GetSdata().GetData())\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write data for %s failed: %v\", shell.Name, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogging.Debug(\"remote read %d bytes: name=%s, id=%s\",\n\t\t\t\tlen(msg.GetSdata().GetData()), shell.Name, id)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype Link struct {\n\tConn *websocket.Conn\n}\n\ntype Shell struct {\n\tName    string\n\tlinks   map[string]*Link\n\tRWMutex sync.RWMutex\n}\n\nfunc (s *Shell) WS(conn *Conn, w http.ResponseWriter, r *http.Request) {\n\twsConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"WebSocket upgrade failed\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tid := generateUniqueID()\n\tlink := &Link{Conn: wsConn}\n\ts.Lock()\n\ts.links[id] = link\n\ts.Unlock()\n\n\tgo s.localForward(id, wsConn)\n\tgo s.remoteForward(id, wsConn)\n}\n\nfunc (s *Shell) localForward(id string, local *websocket.Conn) {\n\tdefer func() {\n\t\tlocal.Close()\n\t\ts.Lock()\n\t\tdelete(s.links, id)\n\t\ts.Unlock()\n\t}()\n\n\tfor {\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\ts.RLock()\n\t\tlink, exists := s.links[id]\n\t\ts.RUnlock()\n\n\t\tif !exists || link.Conn == nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = link.Conn.WriteMessage(websocket.TextMessage, data)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (s *Shell) remoteForward(id string, local *websocket.Conn) {\n\tdefer func() {\n\t\tlocal.Close()\n\t\ts.Lock()\n\t\tdelete(s.links, id)\n\t\ts.Unlock()\n\t}()\n\n\ts.RLock()\n\tlink, exists := s.links[id]\n\ts.RUnlock()\n\n\tif !exists || link.Conn == nil {\n\t\treturn\n\t}\n\n\tfor {\n\t\t_, data, err := link.Conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = local.WriteMessage(websocket.TextMessage, data)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that manages WebSocket connections, including upgrading HTTP connections, reading incoming messages, writing periodic messages, and properly closing the connection.\n\nFunction Description: The `wsHandler` function creates an HTTP handler that upgrades incoming HTTP requests to WebSocket connections. It continuously writes numbered messages to the client while concurrently reading any incoming messages from the client. The function stops after sending a specified number of messages and closes the connection gracefully.\n\nInput:\n- `t *testing.T`: Testing context for error reporting\n- `recvBuffer *bytes.Buffer`: Buffer to store received messages from the WebSocket client\n\nOutput:\n- Returns an `http.HandlerFunc` that implements the WebSocket handling logic\n\nNote: The function doesn't directly return values but rather creates a handler function that manages WebSocket communication through the provided buffer and testing context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\trequire.NoError(t, err)\n\t\tdefer c.Close()\n\t\ti := 0\n\t\tfinish := 5\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\n\t\t\ti++\n\t\t\tdata := struct {\n\t\t\t\tMessage string `json:\"message\"`\n\t\t\t}{\n\t\t\t\tMessage: fmt.Sprintf(\"%d\\n\", i),\n\t\t\t}\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := json.NewEncoder(buf).Encode(data)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = c.WriteMessage(websocket.TextMessage, buf.Bytes())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif i == finish {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\terr = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\trequire.NoError(t, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/net/websocket\"\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\twebsocket.Handler(func(conn *websocket.Conn) {\n\t\t\tdefer conn.Close()\n\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(2)\n\n\t\t\t// Read messages from client\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor {\n\t\t\t\t\tmsg := make([]byte, 1024)\n\t\t\t\t\tn, err := conn.Read(msg)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\t\trecvBuffer.Write(msg[:n])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\trecvBuffer.Write(msg[:n])\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// Write periodic messages to client\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tticker := time.NewTicker(500 * time.Millisecond)\n\t\t\t\tdefer ticker.Stop()\n\n\t\t\t\tfor i := 1; i <= 5; i++ {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t\terr := websocket.Message.Send(conn, fmt.Sprintf(\"message %d\", i))\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Errorf(\"Failed to send message: %v\", err)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Gracefully close connection after sending all messages\n\t\t\t\terr := conn.Close()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Error closing connection: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\twg.Wait()\n\t\t}).ServeHTTP(w, r)\n\t}\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Implement a WebSocket handler for processing VNC-related messages, including image capture data and clipboard events, using gorilla WebSocket library in Go.\n\nStruct Description: The Process struct manages WebSocket connections for VNC operations, handling message passing between the WebSocket connection and internal channels.\n\nFields:\n- srv: *http.Server - HTTP server instance\n- chWrite: chan *vncnetwork.VncMsg - Channel for outgoing VNC messages\n- chImage: chan *vncnetwork.ImageData - Channel for incoming image data\n- chClipboard: chan *vncnetwork.ClipboardData - Channel for incoming clipboard data\n\nMethods:\n- ws: (w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket connections, upgrades HTTP to WebSocket, and manages message reading/writing\n- Close: () -> None - Closes the WebSocket connection and cleans up resources (implied by defer p.Close() in ws method)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/rule/vnc/vncnetwork\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype Process struct {\n\tsrv         *http.Server\n\tchWrite     chan *vncnetwork.VncMsg\n\tchImage     chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nvar upgrader = websocket.Upgrader{EnableCompression: true}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tlogging.Info(\"child process connected\")\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tdefer p.Close()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer utils.Recover(\"ws read\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\t_, data, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"read message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar msg vncnetwork.VncMsg\n\t\t\terr = proto.Unmarshal(data, &msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch msg.GetXType() {\n\t\t\tcase vncnetwork.VncMsg_capture_data:\n\t\t\t\tp.chImage <- msg.GetData()\n\t\t\tcase vncnetwork.VncMsg_clipboard_event:\n\t\t\t\tp.chClipboard <- msg.GetClipboard()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer utils.Recover(\"ws write\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmsg := <-p.chWrite\n\t\t\tdata, err := proto.Marshal(msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = conn.WriteMessage(websocket.BinaryMessage, data)\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\twg.Wait()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n)\n\nvar upgrader = websockets.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype Process struct {\n\tsrv           *http.Server\n\tconn          *websocket.Conn\n\tchWrite       chan *vncnetwork.VncMsg\n\tchImage       chan *vncnetwork.ImageData\n\tchClipboard   chan *vncnetwork.ClipboardData\n}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tvar err error\n\tp.conn, err = upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Could not open websocket connection\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer p.Close()\n\n\tgo p.writePump()\n\tp.readPump()\n}\n\nfunc (p *Process) Close() {\n\tif p.conn != nil {\n\t\tp.conn.Close()\n\t}\n\tclose(p.chWrite)\n\tclose(p.chImage)\n\tclose(p.chClipboard)\n}\n\nfunc (p *Process) readPump() {\n\tfor {\n\t\t_, message, err := p.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Handle clipboard or other control messages\n\t\t// This assumes a type field in the message to distinguish\n\t\t// between different types of incoming messages\n\t\tvar msg vncnetwork.VncMsg\n\t\terr = json.Unmarshal(message, &msg)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch msg.Type {\n\t\tcase vncnetwork.MsgTypeClipboard:\n\t\t\tvar clipboard vncnetwork.ClipboardData\n\t\t\tif err := json.Unmarshal(message, &clipboard); err == nil {\n\t\t\t\tp.chClipboard <- &clipboard\n\t\t\t}\n\t\tdefault:\n\t\t\tp.chWrite <- &msg\n\t\t}\n\t}\n}\n\nfunc (p *Process) writePump() {\n\tfor {\n\t\tselect {\n\t\tcase image, ok := <-p.chImage:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmsg, _ := json.Marshal(image)\n\t\t\t_ = p.conn.WriteMessage(websocket.BinaryMessage, msg)\n\t\tcase clipboard, ok := <-p.chClipboard:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmsg, _ := json.Marshal(clipboard)\n\t\t\t_ = p.conn.WriteMessage(websocket.TextMessage, msg)\n\t\tcase msg, ok := <-p.chWrite:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdata, _ := json.Marshal(msg)\n\t\t\t_ = p.conn.WriteMessage(websocket.TextMessage, data)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a WebSocket proxy struct in Go that can handle WebSocket connections by forwarding messages between a client and a backend server.\n\nStruct Description: The `WebsocketProxy` struct is a reverse proxy for WebSocket connections. It upgrades incoming HTTP connections to WebSocket, connects to a backend WebSocket server, and forwards messages bidirectionally between the client and backend.\n\nFields:\n- Director: `func(incoming *http.Request, out http.Header)` - Optional function to modify the request headers before connecting to the backend.\n- Backend: `func(*http.Request) *url.URL` - Required function that returns the backend URL to connect to.\n- Upgrader: `*websocket.Upgrader` - Optional WebSocket upgrader configuration for client connections.\n- Dialer: `*websocket.Dialer` - Optional WebSocket dialer configuration for backend connections.\n\nMethods:\n- ServeHTTP: `(rw http.ResponseWriter, req *http.Request)` -> `None` - Main handler method that implements the http.Handler interface. It upgrades the client connection, connects to the backend, and sets up bidirectional message forwarding.\n  - Input Parameters:\n    - rw: `http.ResponseWriter` - The HTTP response writer\n    - req: `*http.Request` - The HTTP request\n  - Description: Handles the WebSocket proxy logic including connection upgrading, backend dialing, and message replication between client and backend.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n\t\tif prior, ok := req.Header[\"X-Forwarded-For\"]; ok {\n\t\t\tclientIP = strings.Join(prior, \", \") + \", \" + clientIP\n\t\t}\n\t\trequestHeader.Set(\"X-Forwarded-For\", clientIP)\n\t}\n\n\trequestHeader.Set(\"X-Forwarded-Proto\", \"http\")\n\tif req.TLS != nil {\n\t\trequestHeader.Set(\"X-Forwarded-Proto\", \"https\")\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\treplicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) {\n\t\tfor {\n\t\t\tmsgType, msg, err := src.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\t\tif e, ok := err.(*websocket.CloseError); ok {\n\t\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terrc <- err\n\t\t\t\tdst.WriteMessage(websocket.CloseMessage, m)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = dst.WriteMessage(msgType, msg)\n\t\t\tif err != nil {\n\t\t\t\terrc <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\tif e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure {\n\t\tlog.Printf(message, err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tbackendURL := p.Backend(req)\n\tif backendURL == nil {\n\t\thttp.Error(rw, \"Backend URL is required\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar upgrader = p.Upgrader\n\tif upgrader == nil {\n\t\tupgrader = &websocket.DefaultUpgrader\n\t}\n\n\tconn, err := upgrader.Upgrade(rw, req, nil)\n\tif err != nil {\n\t\thttp.Error(rw, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := p.Dialer\n\tif dialer == nil {\n\t\tdialer = &websocket.Dialer{}\n\t}\n\n\tbackendConn, resp, err := dialer.Dial(backendURL.String(), nil)\n\tif err != nil {\n\t\tlog.Printf(\"Error connecting to backend: %v\", err)\n\t\tif resp != nil {\n\t\t\tresp.Write(rw)\n\t\t} else {\n\t\t\thttp.Error(rw, \"Error connecting to backend\", http.StatusBadGateway)\n\t\t}\n\t\treturn\n\t}\n\n\tif p.Director != nil {\n\t\treqHeader := http.Header{}\n\t\tp.Director(req, reqHeader)\n\t\tfor k := range reqHeader {\n\t\t\tbackendConn.SetWriteDeadline(conn.UnderlyingConn().SetWriteDeadline)\n\t\t\tbackendConn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf(\"%s: %s\", k, reqHeader.Get(k)))))\n\t\t}\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmessageType, p, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client read error: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = backendConn.WriteMessage(messageType, p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Backend write error: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbackendConn.Close()\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmessageType, p, err := backendConn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif !isExpectedCloseError(err) {\n\t\t\t\t\tlog.Printf(\"Backend read error: %v\", err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = conn.WriteMessage(messageType, p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client write error: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}()\n\n\twg.Wait()\n}\n\nfunc isExpectedCloseError(err error) bool {\n\tif err == io.EOF {\n\t\treturn true\n\t}\n\tif se, ok := err.(net.Error); ok && se.Timeout() {\n\t\treturn true\n\t}\n\treturn false\n}"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Create a test WebSocket server that echoes received messages back to the client while notifying a channel for each received message.\n\nFunction Description: The function creates an HTTP test server with WebSocket support. It upgrades incoming HTTP connections to WebSocket, reads incoming messages, notifies a channel when a message is received, and echoes the message back to the client. The server runs until the connection is closed.\n\nInput:\n- t *testing.T: Testing context for error reporting\n- received chan struct{}: Channel to notify when a message is received\n\nOutput:\n- *httptest.Server: Pointer to the created HTTP test server instance",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\n\tgorillawebsocket \"github.com/gorilla/websocket\"\n)\n\nfunc testService(t *testing.T, received chan struct{}) *httptest.Server {\n\tvar httpHandler http.HandlerFunc = func(w http.ResponseWriter, r *http.Request) {\n\t\tvar upgrader gorillawebsocket.Upgrader\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error upgrading websocket:\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\tt, b, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\n\t\t\tconn.WriteMessage(t, b)\n\t\t}\n\t}\n\n\treturn httptest.NewServer(httpHandler)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"net/http/httptest\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc createWebSocketTestServer(t *testing.T, received chan struct{}) *httptest.Server {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to upgrade connection: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tmessageType, msg, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase received <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tif err := conn.WriteMessage(messageType, msg); err != nil {\n\t\t\t\t\tt.Errorf(\"Failed to write message: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\twg.Wait()\n\t})\n\n\tserver := httptest.NewServer(handler)\n\treturn server\n}"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Implement a WebSocket server function in Go that handles client connections, manages online users, and periodically sends server statistics to connected clients.\n\nFunction Description: The `serverStream` function establishes a WebSocket connection with a client, registers the user in an online user tracking system, and continuously sends server statistics at regular intervals. It handles connection upgrades, user authentication, and graceful connection closure.\n\nInput:\n- `c *gin.Context`: Gin framework context object containing HTTP request information and writer for response\n\nOutput:\n- `any`: Placeholder return value (always nil in this implementation)\n- `error`: Error object indicating connection termination reason (wrapped in custom WsError type)\n\nThe function performs the following operations:\n1. Generates a unique connection ID\n2. Upgrades HTTP connection to WebSocket\n3. Extracts user IP and authentication info\n4. Registers user in online tracking system\n5. Periodically sends server statistics\n6. Handles connection cleanup on exit",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/url\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/nezhahq/nezha/model\"\n\t\"github.com/nezhahq/nezha/service/singleton\"\n)\n\nvar upgrader *websocket.Upgrader\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnId, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\tdefer conn.Close()\n\n\tuserIp := c.GetString(model.CtxKeyRealIPStr)\n\tif userIp == \"\" {\n\t\tuserIp = c.RemoteIP()\n\t}\n\n\tu, isMember := c.Get(model.CtxKeyAuthorizedUser)\n\tvar userId uint64\n\tif isMember {\n\t\tuserId = u.(*model.User).ID\n\t}\n\n\tsingleton.AddOnlineUser(connId, &model.OnlineUser{\n\t\tUserID:      userId,\n\t\tIP:          userIp,\n\t\tConnectedAt: time.Now(),\n\t\tConn:        conn,\n\t})\n\tdefer singleton.RemoveOnlineUser(connId)\n\n\tcount := 0\n\tfor {\n\t\tstat, err := getServerStat(count == 0, isMember)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.WriteMessage(websocket.TextMessage, stat); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tcount += 1\n\t\tif count%4 == 0 {\n\t\t\terr = conn.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\treturn nil, newWsError(\"\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype WsError struct {\n\tReason error\n}\n\nfunc (e WsError) Error() string {\n\treturn fmt.Sprintf(\"WebSocket error: %v\", e.Reason)\n}\n\ntype ServerStats struct {\n\tOnlineUsers int       `json:\"online_users\"`\n\tTimestamp   time.Time `json:\"timestamp\"`\n}\n\ntype Client struct {\n\tconn *websocket.Conn\n\tmu   sync.Mutex\n}\n\nvar (\n\tclients      = make(map[string]*Client)\n\tclientsMutex sync.Mutex\n)\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnID := generateConnectionID()\n\twsConn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, WsError{Reason: fmt.Errorf(\"failed to upgrade connection: %w\", err)}\n\t}\n\n\tip := c.ClientIP()\n\tuser := authenticateUser(c)\n\n\tclient := &Client{conn: wsConn}\n\tclientsMutex.Lock()\n\tclients[ip] = client\n\tclientsMutex.Unlock()\n\n\tdefer func() {\n\t\tclientsMutex.Lock()\n\t\tdelete(clients, ip)\n\t\tclientsMutex.Unlock()\n\t\twsConn.Close()\n\t}()\n\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tstats := ServerStats{\n\t\t\t\tOnlineUsers: len(clients),\n\t\t\t\tTimestamp:   time.Now(),\n\t\t\t}\n\n\t\t\tclient.mu.Lock()\n\t\t\terr := wsConn.WriteJSON(stats)\n\t\t\tclient.mu.Unlock()\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, WsError{Reason: fmt.Errorf(\"connection closed unexpectedly: %w\", err)}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\nfunc generateConnectionID() string {\n\treturn fmt.Sprintf(\"%d\", time.Now().UnixNano())\n}\n\nfunc authenticateUser(c *gin.Context) string {\n\tauthHeader := c.GetHeader(\"Authorization\")\n\tif authHeader == \"\" {\n\t\treturn \"anonymous\"\n\t}\n\treturn authHeader\n}"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The handler function manages WebSocket connections by upgrading HTTP requests, handling incoming messages, and maintaining the connection until closure. It includes error handling for connection issues and logs key events.\n\nInput:\n- w http.ResponseWriter: The HTTP response writer used to send responses\n- r *http.Request: The HTTP request containing connection details\n\nOutput: None (void function), but it performs the following actions:\n- Upgrades HTTP connection to WebSocket\n- Reads and echoes messages\n- Closes the connection when done or on error\n- Logs connection events and errors",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif netheader.IsKubeletProbe(r) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading websocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tlog.Println(\"Connection upgraded to WebSocket. Entering receive loop.\")\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Println(\"Client disconnected.\")\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Handler exiting on error:\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully received: %q\", message)\n\t\tif err = conn.WriteMessage(messageType, message); err != nil {\n\t\t\tlog.Println(\"Failed to write message:\", err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully wrote: %q\", message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to upgrade connection: %v\", err)\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tlog.Println(\"WebSocket connection established\")\n\n\tdefer func() {\n\t\tlog.Println(\"Closing WebSocket connection\")\n\t\tconn.Close()\n\t}()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Printf(\"Error reading message: %v\", err)\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Client closed connection\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Printf(\"Received message: %s\", message)\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing message: %v\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, manages WebSocket connections, and handles message reading.\n\nFunction Description: The function `NotifyWS` handles WebSocket connections by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It adds the new WebSocket connection to a global list of connections and ensures a message-sending service is running. The function then continuously reads messages from the WebSocket connection until it is closed.\n\nInput: \n- `ctx echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails, otherwise returns `nil` after the WebSocket connection is closed.\n\nNote: The function does not explicitly return any output other than potential errors, but it interacts with global state (`service.WebSocketConns` and `service.SocketRun`) and performs I/O operations on the WebSocket connection.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upGrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdefer ws.Close()\n\tservice.WebSocketConns = append(service.WebSocketConns, ws)\n\n\tif !service.SocketRun {\n\t\tservice.SocketRun = true\n\t\tservice.SendMeg()\n\t}\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tfmt.Println(mt, message, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tservice.WebSocketConns = append(service.WebSocketConns, conn)\n\tif !service.SocketRun {\n\t\tgo service.MessageService()\n\t}\n\n\tfor {\n\t\tmessageType, _, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif messageType == websocket.CloseMessage {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Implement a WebSocket echo server function in Go that handles WebSocket connections, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The `echo` function upgrades an HTTP connection to a WebSocket connection, continuously reads messages from the client, and echoes them back. It handles connection errors and ensures proper cleanup by closing the connection when done.\n\nInput: \n- `ctx *gin.Context`: A Gin context object containing the HTTP request and response writer needed for WebSocket upgrade.\n\nOutput: \n- None (void function), but it performs the following operations:\n  - Upgrades the HTTP connection to WebSocket\n  - Reads and echoes messages until connection is closed\n  - Handles and logs errors\n  - Closes the WebSocket connection when done",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc echo(ctx *gin.Context) {\n\tw,r := ctx.Writer, ctx.Request\n\tc, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv:%s\", message)\n\t\terr = c.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc echo(ctx *gin.Context) {\n\tconn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)\n\tif err != nil {\n\t\tctx.AbortWithStatusJSON(500, gin.H{\"error\": \"Failed to upgrade connection\"})\n\t\treturn\n\t}\n\n\tfor {\n\t\tmessageType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif err := conn.WriteMessage(messageType, msg); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tconn.Close()\n}"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Implement a Go struct that tests the health of an NTP (Network Time Protocol) server by checking its stratum level through UDP communication.\n\nStruct Description: The NtpHealthTester struct is responsible for verifying the health of an NTP server by establishing a UDP connection, sending a query, and validating the server's response based on its stratum level. The struct includes methods for testing the server and providing a string representation of the maximum allowed stratum.\n\nFields:\nmaxStratum: int - The maximum acceptable stratum level for the NTP server to be considered healthy.\n\nMethods:\nTest: (ht *HealthTest) -> bool - Tests the health of an NTP server by sending a UDP packet and validating the response. Returns true if the server's stratum is within the acceptable range, false otherwise.\nString: () -> string - Returns a string representation of the maximum allowed stratum level.\nnewNtpHealthTester: (params map[string]interface{}, htp *HealthTestParameters) -> HealthTester - A constructor function that creates a new NtpHealthTester instance with the specified maximum stratum level.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (t *NtpHealthTester) Test(ht *HealthTest) bool {\n\tudpAddress, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(ht.ipAddress.String(), \"123\"))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdata := make([]byte, 48)\n\tdata[0] = 4<<3 | 3\n\n\tconn, err := net.DialUDP(\"udp\", nil, udpAddress)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(ht.timeout))\n\n\t_, err = conn.Read(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := data[1]\n\n\tif stratum == 0 || stratum > byte(t.maxStratum) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (t *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"%d\", t.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := 3\n\tif v, ok := params[\"max_stratum\"]; ok {\n\t\tmaxStratum = typeutil.ToInt(v)\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (ht *NtpHealthTester) Test() bool {\n\tserverAddr := \"pool.ntp.org:123\"\n\tconn, err := net.DialTimeout(\"udp\", serverAddr, 5*time.Second)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer conn.Close()\n\n\tconn.SetDeadline(time.Now().Add(5 * time.Second))\n\n\treq := make([]byte, 48)\n\treq[0] = 0x1B // NTP request mode\n\n\t_, err = conn.Write(req)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tresp := make([]byte, 48)\n\t_, err = conn.Read(resp)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := int(resp[1])\n\treturn stratum <= ht.maxStratum && stratum > 0\n}\n\nfunc (ht *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"NtpHealthTester(maxStratum=%d)\", ht.maxStratum)\n}\n\ntype HealthTestParameters struct{}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) *NtpHealthTester {\n\tmaxStratum := 10\n\tif val, ok := params[\"maxStratum\"].(int); ok {\n\t\tmaxStratum = val\n\t}\n\treturn &NtpHealthTester{\n\t\tmaxStratum: maxStratum,\n\t}\n}"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Implement a UDP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and connection management.\n\nStruct Description: The Client struct represents a UDP client for communicating with KDC servers. It maintains configuration and provides methods for sending data over UDP.\n\nFields:\n\nConfig: [*Config] - Configuration object containing KDC server information and settings\n\nMethods:\n\nsendKDCUDP: [func(realm string, b []byte) -> ([]byte, error)] - Sends data to a KDC server over UDP for a specific realm. Returns the response or error.\ndialKDCUDP: [func(count int, kdcs map[int]string) -> (*net.UDPConn, error)] - Internal method to establish UDP connection to a KDC server from a list of addresses. Returns the connection or error.\nsendUDP: [func(conn *net.UDPConn, b []byte) -> ([]byte, error)] - Internal method to send data over an established UDP connection and read the response. Returns the response data or error.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\tcount, kdcs, err := cl.Config.GetKDCs(realm, false)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tconn, err := dialKDCUDP(count, kdcs)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = cl.sendUDP(conn, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialKDCUDP(count int, kdcs map[int]string) (conn *net.UDPConn, err error) {\n\ti := 1\n\tfor i <= count {\n\t\tudpAddr, e := net.ResolveUDPAddr(\"udp\", kdcs[i])\n\t\tif e != nil {\n\t\t\terr = fmt.Errorf(\"error resolving KDC address: %v\", e)\n\t\t\treturn\n\t\t}\n\t\tconn, err = net.DialUDP(\"udp\", nil, udpAddr)\n\t\tif err == nil {\n\t\t\terr = conn.SetDeadline(time.Now().Add(5 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti++\n\t}\n\terr = errors.New(\"error in getting a UDP connection to any of the KDCs\")\n\treturn\n}\n\nfunc (cl *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\tvar r []byte\n\tdefer conn.Close()\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\tudpbuf := make([]byte, 4096)\n\tn, _, err := conn.ReadFrom(udpbuf)\n\tr = udpbuf[:n]\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"sending over UDP failed to %s: %v\", conn.RemoteAddr().String(), err)\n\t}\n\tif len(r) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from %s\", conn.RemoteAddr().String())\n\t}\n\treturn r, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype Config struct {\n\tKDCs   map[int]string // KDC server addresses indexed by priority\n\tRealm  string\n\tTimeout time.Duration\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tconn, err := c.dialKDCUDP(0, c.Config.KDCs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\treturn c.sendUDP(conn, b)\n}\n\nfunc (c *Client) dialKDCUDP(count int, kdcs map[int]string) (*net.UDPConn, error) {\n\tfor i := count; i < len(kdcs); i++ {\n\t\taddrStr, ok := kdcs[i]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\taddr, err := net.ResolveUDPAddr(\"udp\", addrStr)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\t\tif err == nil {\n\t\t\tif c.Config.Timeout > 0 {\n\t\t\t\tconn.SetDeadline(time.Now().Add(c.Config.Timeout))\n\t\t\t}\n\t\t\treturn conn, nil\n\t\t}\n\t}\n\n\treturn nil, &net.OpError{Op: \"dial\", Net: \"udp\", Err: net.ErrClosed}\n}\n\nfunc (c *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse := make([]byte, 4096)\n\tn, err := conn.Read(response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response[:n], nil\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a function that establishes UDP connections between two remote endpoints, optionally encrypts the initial handshake packets, and forwards traffic between them.\n\nFunction Description: The function `remote2remoteUDP` creates two UDP connections to specified remote endpoints, handles optional encryption of initialization packets, and sets up bidirectional forwarding between the connections. It uses custom networking and crypto utilities for connection management and encryption.\n\nInput:\n- remoteA: string - First remote endpoint address in \"host:port\" format\n- remoteB: string - Second remote endpoint address in \"host:port\" format\n- raenc: bool - Flag to enable encryption for first remote endpoint\n- rbenc: bool - Flag to enable encryption for second remote endpoint\n\nOutput: None (The function runs indefinitely forwarding traffic or returns on error)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"iox/netio\"\n\t\"iox/crypto\"\n)\n\nfunc remote2remoteUDP(remoteA string, remoteB string, raenc bool, rbenc bool) {\n\tremoteAddrA, err := net.ResolveUDPAddr(\"udp\", remoteA)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnA, err := net.DialUDP(\"udp\", nil, remoteAddrA)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnA.Close()\n\n\tremoteAddrB, err := net.ResolveUDPAddr(\"udp\", remoteB)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnB, err := net.DialUDP(\"udp\", nil, remoteAddrB)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnB.Close()\n\n\tremoteCtxA, err := netio.NewUDPCtx(remoteConnA, raenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteCtxB, err := netio.NewUDPCtx(remoteConnB, rbenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif raenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxA.Write(b)\n\t} else {\n\t\tremoteCtxA.Write(netio.UDP_INIT_PACKET)\n\t}\n\tif rbenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxB.Write(b)\n\t} else {\n\t\tremoteCtxB.Write(netio.UDP_INIT_PACKET)\n\t}\n\n\tnetio.ForwardUDP(remoteCtxA, remoteCtxB)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n)\n\nvar (\n\t// Assume these are defined in custom networking/crypto packages\n\tencryptPacket = func(packet []byte, key []byte) ([]byte, error) {\n\t\t// Placeholder for actual encryption logic\n\t\treturn append([]byte{0x01}, packet...), nil\n\t}\n\tdecryptPacket = func(packet []byte, key []byte) ([]byte, error) {\n\t\t// Placeholder for actual decryption logic\n\t\tif len(packet) > 0 && packet[0] == 0x01 {\n\t\t\treturn packet[1:], nil\n\t\t}\n\t\treturn packet, nil\n\t}\n\tgenerateKey = func() []byte {\n\t\tkey := make([]byte, 32)\n\t\trand.Read(key)\n\t\treturn key\n\t}\n)\n\nfunc remote2remoteUDP(remoteA string, remoteB string, raenc bool, rbenc bool) {\n\traAddr, err := net.ResolveUDPAddr(\"udp\", remoteA)\n\tif err != nil {\n\t\tfmt.Println(\"Error resolving remoteA:\", err)\n\t\treturn\n\t}\n\n\trbAddr, err := net.ResolveUDPAddr(\"udp\", remoteB)\n\tif err != nil {\n\t\tfmt.Println(\"Error resolving remoteB:\", err)\n\t\treturn\n\t}\n\n\tconnA, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4zero, Port: 0})\n\tif err != nil {\n\t\tfmt.Println(\"Error creating UDP connection to A:\", err)\n\t\treturn\n\t}\n\tdefer connA.Close()\n\n\tconnB, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4zero, Port: 0})\n\tif err != nil {\n\t\tfmt.Println(\"Error creating UDP connection to B:\", err)\n\t\treturn\n\t}\n\tdefer connB.Close()\n\n\tkeyA := generateKey()\n\tkeyB := generateKey()\n\n\tsendInitPacket := func(conn *net.UDPConn, target *net.UDPAddr, encrypt bool, key []byte) {\n\t\tinitPacket := []byte(\"INIT_PACKET\")\n\t\tif encrypt {\n\t\t\tencrypted, _ := encryptPacket(initPacket, key)\n\t\t\tinitPacket = encrypted\n\t\t}\n\t\tconn.WriteToUDP(initPacket, target)\n\t}\n\n\tvar wg sync.WaitGroup\n\n\tforwardTraffic := func(src, dst *net.UDPConn, encrypt, decrypt bool, key []byte) {\n\t\tdefer wg.Done()\n\t\tbuf := make([]byte, 65536)\n\t\tfor {\n\t\t\tn, addr, err := src.ReadFromUDP(buf)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading from UDP:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpacket := buf[:n]\n\t\t\tif decrypt {\n\t\t\t\tdecrypted, derr := decryptPacket(packet, key)\n\t\t\t\tif derr != nil {\n\t\t\t\t\tfmt.Println(\"Decryption error:\", derr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpacket = decrypted\n\t\t\t}\n\t\t\tif encrypt {\n\t\t\t\tencrypted, eerr := encryptPacket(packet, key)\n\t\t\t\tif eerr != nil {\n\t\t\t\t\tfmt.Println(\"Encryption error:\", eerr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpacket = encrypted\n\t\t\t}\n\t\t\tdst.WriteToUDP(packet, addr)\n\t\t}\n\t}\n\n\tsendInitPacket(connA, raAddr, raenc, keyA)\n\tsendInitPacket(connB, rbAddr, rbenc, keyB)\n\n\twg.Add(4)\n\tgo forwardTraffic(connA, connB, rbenc, raenc, keyB)\n\tgo forwardTraffic(connB, connA, raenc, rbenc, keyA)\n\tgo forwardTraffic(connA, connB, false, false, nil)\n\tgo forwardTraffic(connB, connA, false, false, nil)\n\n\twg.Wait()\n}"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: The task involves creating a DNS bootstrap resolver that can query DNS servers to resolve domain names to IP addresses using UDP protocol. The resolver should handle concurrent operations, retry failed queries, and manage connection lifecycle properly.\n\nStruct Description: The Bootstrap struct represents a DNS bootstrap resolver that maintains state for DNS queries, including target domain, server address, and query status. It handles concurrent resolution requests and manages connection retries.\n\nFields:\nfqdn: [string] - The fully qualified domain name to resolve\nport: [uint16] - The port number of the DNS server\nbootstrap: [*net.UDPAddr] - The UDP address of the DNS bootstrap server\nqt: [uint16] - The DNS query type (e.g., A or AAAA records)\nlogger: [*zap.Logger] - Logger for debugging and error reporting\nupdating: [atomic.Bool] - Atomic flag indicating if an update is in progress\nnextUpdate: [time.Time] - Timestamp for the next scheduled update\nreadyNotify: [chan struct{}] - Channel to notify when resolution is complete\nm: [sync.Mutex] - Mutex for protecting shared state\nready: [bool] - Flag indicating if resolution is complete\naddrStr: [string] - The resolved address string\n\nMethods:\nresolve: [Name](ctx context.Context, qt uint16) -> (netip.Addr, uint32, error) - Resolves the configured domain name to an IP address using the specified query type. Handles UDP communication with retries and timeout management. Returns the resolved address, its TTL, or an error.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/IrineSistiana/mosdns/v5/pkg/dnsutils\"\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn      string\n\tport      uint16\n\tbootstrap *net.UDPAddr\n\tqt        uint16\n\tlogger    *zap.Logger\n\n\tupdating   atomic.Bool\n\tnextUpdate time.Time\n\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (sp *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tconst edns0UdpSize = 1200\n\n\tq := new(dns.Msg)\n\tq.SetQuestion(sp.fqdn, qt)\n\tq.SetEdns0(edns0UdpSize, false)\n\n\tc, err := net.DialUDP(\"udp\", nil, sp.bootstrap)\n\tif err != nil {\n\t\treturn netip.Addr{}, 0, err\n\t}\n\tdefer c.Close()\n\n\twriteErrC := make(chan error, 1)\n\ttype res struct {\n\t\tresp *dns.Msg\n\t\terr  error\n\t}\n\treadResC := make(chan res, 1)\n\n\tcancelWrite := make(chan struct{})\n\tdefer close(cancelWrite)\n\tgo func() {\n\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\twriteErrC <- err\n\t\t\treturn\n\t\t}\n\n\t\tretryTicker := time.NewTicker(time.Second)\n\t\tdefer retryTicker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-cancelWrite:\n\t\t\t\treturn\n\t\t\tcase <-retryTicker.C:\n\t\t\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\t\t\twriteErrC <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tm, _, err := dnsutils.ReadMsgFromUDP(c, edns0UdpSize)\n\t\treadResC <- res{resp: m, err: err}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn netip.Addr{}, 0, context.Cause(ctx)\n\tcase err := <-writeErrC:\n\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to write query, %w\", err)\n\tcase r := <-readResC:\n\t\tresp := r.resp\n\t\terr := r.err\n\t\tif err != nil {\n\t\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to read resp, %w\", err)\n\t\t}\n\n\t\tfor _, v := range resp.Answer {\n\t\t\tvar ip net.IP\n\t\t\tvar ttl uint32\n\t\t\tswitch rr := v.(type) {\n\t\t\tcase *dns.A:\n\t\t\t\tip = rr.A\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tcase *dns.AAAA:\n\t\t\t\tip = rr.AAAA\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr, ok := netip.AddrFromSlice(ip)\n\t\t\tif ok {\n\t\t\t\treturn addr, ttl, nil\n\t\t\t}\n\t\t}\n\n\t\treturn netip.Addr{}, 0, errNoAddrInResp\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package dns\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/net/dns/dnsmessage\"\n\t\"net/netip\"\n)\n\ntype Bootstrap struct {\n\tfqdn         string\n\tport         uint16\n\tbootstrap    *net.UDPAddr\n\tqt           uint16\n\tlogger       *zap.Logger\n\tupdating     atomic.Bool\n\tnextUpdate   time.Time\n\treadyNotify  chan struct{}\n\tm            sync.Mutex\n\tready        bool\n\taddrStr      string\n}\n\nfunc (b *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tconst maxRetries = 3\n\tconst timeout = 5 * time.Second\n\n\tvar lastErr error\n\n\tfor attempt := 0; attempt < maxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn netip.Addr{}, 0, ctx.Err()\n\t\t\tcase <-time.After(timeout):\n\t\t\t}\n\t\t}\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, b.bootstrap)\n\t\tif err != nil {\n\t\t\tlastErr = fmt.Errorf(\"failed to dial UDP: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\terr = conn.SetDeadline(time.Now().Add(timeout))\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tlastErr = fmt.Errorf(\"failed to set deadline: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tquery := dnsmessage.Message{\n\t\t\tHeader: dnsmessage.Header{\n\t\t\t\tID:                 uint16(time.Now().UnixNano()),\n\t\t\t\tRecursionDesired:   true,\n\t\t\t\tOpCode:             dnsmessage.OpCode(0),\n\t\t\t\tResponse:           false,\n\t\t\t\tTruncated:          false,\n\t\t\t\tAuthoritative:      false,\n\t\t\t\tAuthenticatedData:  false,\n\t\t\t\tCheckingDisabled:   false,\n\t\t\t\tZero:               false,\n\t\t\t\tRCode:              dnsmessage.RCode(0),\n\t\t\t},\n\t\t\tQuestions: []dnsmessage.Question{{\n\t\t\t\tName:  dnsmessage.MustNewName(b.fqdn),\n\t\t\t\tType:  dnsmessage.Type(qt),\n\t\t\t\tClass: dnsmessage.ClassINET,\n\t\t\t}},\n\t\t}\n\n\t\tbuf, err := query.Pack()\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tlastErr = fmt.Errorf(\"failed to pack query: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t_, err = conn.Write(buf)\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tlastErr = fmt.Errorf(\"failed to send query: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresponse := make([]byte, 512)\n\t\tn, err := conn.Read(response)\n\t\tconn.Close()\n\t\tif err != nil {\n\t\t\tlastErr = fmt.Errorf(\"failed to read response: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar resp dnsmessage.Message\n\t\terr = resp.Unpack(response[:n])\n\t\tif err != nil {\n\t\t\tlastErr = fmt.Errorf(\"failed to unpack response: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resp.Header.RCode != dnsmessage.RCodeSuccess {\n\t\t\tlastErr = fmt.Errorf(\"DNS error: %s\", resp.Header.RCode.String())\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, ans := range resp.Answers {\n\t\t\tswitch ans.Header.Type {\n\t\t\tcase dnsmessage.TypeA:\n\t\t\t\ta := ans.Body.(*dnsmessage.AResource).A\n\t\t\t\tip := netip.AddrFrom4(a)\n\t\t\t\tttl := ans.Header.TTL\n\t\t\t\treturn ip, ttl, nil\n\t\t\tcase dnsmessage.TypeAAAA:\n\t\t\t\taaaa := ans.Body.(*dnsmessage.AAAAResource).AAAA\n\t\t\t\tip := netip.AddrFrom16(aaaa)\n\t\t\t\tttl := ans.Header.TTL\n\t\t\t\treturn ip, ttl, nil\n\t\t\t}\n\t\t}\n\n\t\tlastErr = fmt.Errorf(\"no A or AAAA record found\")\n\t}\n\n\treturn netip.Addr{}, 0, lastErr\n}"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Implement a UDP server in Go that listens for incoming packets, manages client sessions, and proxies the traffic to a remote destination using a provided proxy dialer.\n\nStruct Description: The UDP struct represents a UDP server that handles incoming connections, manages sessions, and proxies traffic. It maintains session state and coordinates communication between clients and the proxy server.\n\nFields:\n- addr: string - The local address to listen on\n- uaddr: *net.UDPAddr - The resolved UDP address\n- dialer: proxy.Dialer - The dialer used to establish connections\n- proxy: proxy.Proxy - The proxy implementation for forwarding traffic\n\nMethods:\n- NewUDP: (s string, d proxy.Dialer, p proxy.Proxy) -> (*UDP, error) - Creates a new UDP instance by parsing the URL and resolving the address\n- ListenAndServe: () -> () - Starts listening on the UDP port and handles incoming packets\n- serveSession: (session *session) -> () - Handles an individual client session and proxies its traffic\n- DialUDP: (network string, addr string) -> (net.PacketConn, error) - Creates a new packet connection for outbound traffic\n\nAdditional Structs:\n- session: Represents a client session with its communication channels\n  Fields:\n    - key: string - Session identifier\n    - src: *net.UDPAddr - Client address\n    - PacketConn: net.PacketConn - Underlying connection\n    - msgCh: chan []byte - Channel for incoming messages\n    - finCh: chan struct{} - Channel for session termination\n\n- PktConn: Wraps a net.PacketConn with a predefined destination address\n  Fields:\n    - PacketConn: net.PacketConn - Underlying connection\n    - uaddr: *net.UDPAddr - Destination address\n  Methods:\n    - WriteTo: (b []byte, addr net.Addr) -> (int, error) - Writes data to the predefined address",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\nvar nm sync.Map\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu, err := url.Parse(s)\n\tif err != nil {\n\t\tlog.F(\"[udp] parse url err: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tt := &UDP{\n\t\tdialer: d,\n\t\tproxy:  p,\n\t\taddr:   u.Host,\n\t}\n\n\tt.uaddr, err = net.ResolveUDPAddr(\"udp\", t.addr)\n\treturn t, err\n}\n\nfunc (s *UDP) ListenAndServe() {\n\tc, err := net.ListenPacket(\"udp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[udp] failed to listen on UDP %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\n\tlog.F(\"[udp] listening UDP on %s\", s.addr)\n\n\tfor {\n\t\tbuf := pool.GetBuffer(proxy.UDPBufSize)\n\t\tn, srcAddr, err := c.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.F(\"[udp] read error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar sess *session\n\t\tsessKey := srcAddr.String()\n\n\t\tv, ok := nm.Load(sessKey)\n\t\tif !ok || v == nil {\n\t\t\tsess = newSession(sessKey, srcAddr, c)\n\t\t\tnm.Store(sessKey, sess)\n\t\t\tgo s.serveSession(sess)\n\t\t} else {\n\t\t\tsess = v.(*session)\n\t\t}\n\n\t\tsess.msgCh <- buf[:n]\n\t}\n}\n\nfunc (s *UDP) serveSession(session *session) {\n\tdstPC, dialer, err := s.proxy.DialUDP(\"udp\", session.src.String())\n\tif err != nil {\n\t\tlog.F(\"[udp] remote dial error: %v\", err)\n\t\tnm.Delete(session.key)\n\t\treturn\n\t}\n\tdefer dstPC.Close()\n\n\tgo func() {\n\t\tproxy.CopyUDP(session, session.src, dstPC, 2*time.Minute, 5*time.Second)\n\t\tnm.Delete(session.key)\n\t\tclose(session.finCh)\n\t}()\n\n\tlog.F(\"[udp] %s <-> %s\", session.src, dialer.Addr())\n\n\tfor {\n\t\tselect {\n\t\tcase p := <-session.msgCh:\n\t\t\t_, err = dstPC.WriteTo(p, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.F(\"[udp] writeTo error: %v\", err)\n\t\t\t}\n\t\t\tpool.PutBuffer(p)\n\t\tcase <-session.finCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype session struct {\n\tkey string\n\tsrc *net.UDPAddr\n\tnet.PacketConn\n\tmsgCh chan []byte\n\tfinCh chan struct{}\n}\n\nfunc newSession(key string, src net.Addr, srcPC net.PacketConn) *session {\n\tsrcAddr, _ := net.ResolveUDPAddr(\"udp\", src.String())\n\treturn &session{key, srcAddr, srcPC, make(chan []byte, 32), make(chan struct{})}\n}\n\nfunc (s *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\tpc, err := s.dialer.DialUDP(network, s.addr)\n\treturn &PktConn{pc, s.uaddr}, err\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (pc *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn pc.PacketConn.WriteTo(b, pc.uaddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 111,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype UDP struct {\n\taddr    string\n\tuaddr   *net.UDPAddr\n\tdialer  proxy.Dialer\n\tproxy   proxy.Proxy\n\tsessions sync.Map // string -> *session\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu, err := net.ResolveUDPAddr(\"udp\", s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UDP{\n\t\taddr:   s,\n\t\tuaddr:  u,\n\t\tdialer: d,\n\t\tproxy:  p,\n\t}, nil\n}\n\nfunc (u *UDP) ListenAndServe() {\n\tconn, err := net.ListenUDP(\"udp\", u.uaddr)\n\tif err != nil {\n\t\tfmt.Println(\"ListenUDP error:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tbuf := make([]byte, 65536)\n\tfor {\n\t\tn, srcAddr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"ReadFromUDP error:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tdata := make([]byte, n)\n\t\tcopy(data, buf[:n])\n\n\t\tkey := srcAddr.String()\n\t\tsessionIface, _ := u.sessions.LoadOrStore(key, &session{\n\t\t\tkey:     key,\n\t\t\tsrc:     srcAddr,\n\t\t\tmsgCh:   make(chan []byte, 10),\n\t\t\tfinCh:   make(chan struct{}),\n\t\t})\n\n\t\tgo func(sess *session) {\n\t\t\tselect {\n\t\t\tcase sess.msgCh <- data:\n\t\t\tcase <-sess.finCh:\n\t\t\t}\n\t\t}(sessionIface.(*session))\n\n\t\tgo func(sess *session) {\n\t\t\tif sess.PacketConn == nil {\n\t\t\t\tpktConn, err := u.DialUDP(\"udp\", \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"DialUDP error:\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tsess.PacketConn = pktConn\n\t\t\t\tgo u.serveSession(sess)\n\t\t\t}\n\t\t}(sessionIface.(*session))\n\t}\n}\n\nfunc (u *UDP) serveSession(session *session) {\n\tdefer func() {\n\t\tclose(session.finCh)\n\t\tsession.PacketConn.Close()\n\t\tu.sessions.Delete(session.key)\n\t}()\n\n\t// Forward packets from client to remote\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data, ok := <-session.msgCh:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t_, err := session.PacketConn.WriteTo(data, session.src)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"WriteTo error:\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-session.finCh:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Forward packets from remote to client\n\tbuf2 := make([]byte, 65536)\n\tfor {\n\t\tn, _, err := session.PacketConn.ReadFrom(buf2)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"ReadFrom PacketConn error:\", err)\n\t\t\treturn\n\t\t}\n\t\t_, err = conn.WriteToUDP(buf2[:n], session.src)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"WriteToUDP error:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (u *UDP) DialUDP(network string, addr string) (net.PacketConn, error) {\n\tif network == \"\" {\n\t\tnetwork = \"udp\"\n\t}\n\tconn, err := u.dialer.Dial(network, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn.(net.PacketConn), nil\n}\n\ntype session struct {\n\tkey        string\n\tsrc        *net.UDPAddr\n\tnet.PacketConn\n\tmsgCh chan []byte\n\tfinCh chan struct{}\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (pc *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn pc.PacketConn.WriteTo(b, pc.uaddr)\n}"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Implement a UDP-based trap listener for SNMP (Simple Network Management Protocol) messages, capable of receiving and processing traps/informs, with support for SNMPv3 security features and proper resource cleanup.\n\nStruct Description: TrapListener is a struct that manages a UDP listener for SNMP traps, handling incoming messages, security validation, and response generation.\n\nFields:\n- done: chan bool - Channel to signal completion of listener shutdown\n- listening: chan bool - Channel to signal when listener is active\n- Mutex: sync.Mutex - Mutex for thread-safe operations\n- Params: *GoSNMP - Configuration parameters for SNMP handling\n- OnNewTrap: TrapHandlerFunc - Callback function for new trap processing\n- CloseTimeout: time.Duration - Timeout for graceful shutdown\n- conn: *net.UDPConn - UDP connection object\n- proto: string - Protocol type (typically \"udp\")\n- usmStatsUnknownEngineIDsCount: uint32 - Counter for unknown engine IDs (SNMPv3)\n- finish: int32 - Atomic flag for shutdown state\n\nMethods:\n- NewTrapListener() -> *TrapListener - Creates and initializes a new TrapListener instance\n- Close() - Gracefully shuts down the listener and cleans up resources\n- SendUDP(packet *SnmpPacket, addr *net.UDPAddr) -> error - Sends an SNMP packet via UDP\n- listenUDP(addr string) -> error - Main listening loop for incoming traps\n- reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) -> error - Handles SNMPv3 engine ID mismatch reporting",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype TrapListener struct {\n\tdone      chan bool\n\tlistening chan bool\n\tsync.Mutex\n\n\tParams *GoSNMP\n\n\tOnNewTrap TrapHandlerFunc\n\n\tCloseTimeout time.Duration\n\n\tconn  *net.UDPConn\n\tproto string\n\n\tusmStatsUnknownEngineIDsCount uint32\n\n\tfinish int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\ttl := &TrapListener{\n\t\tfinish:       0,\n\t\tdone:         make(chan bool),\n\t\tlistening:    make(chan bool, 1),\n\t\tCloseTimeout: defaultCloseTimeout,\n\t}\n\n\treturn tl\n}\n\nfunc (t *TrapListener) Close() {\n\tif atomic.CompareAndSwapInt32(&t.finish, 0, 1) {\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\n\t\tif t.conn == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err := t.conn.Close(); err != nil {\n\t\t\tt.Params.Logger.Printf(\"failed to Close() the TrapListener socket: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-t.done:\n\t\tcase <-time.After(t.CloseTimeout):\n\t\t\tt.Params.Logger.Printf(\"timeout while awaiting done signal on TrapListener Close()\")\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\tob, err := packet.marshalMsg()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling SnmpPacket: %w\", err)\n\t}\n\n\tcount, err := t.conn.WriteTo(ob, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending SnmpPacket: %w\", err)\n\t}\n\n\tif count != len(ob) {\n\t\tt.Params.Logger.Printf(\"Failed to send all bytes of SnmpPacket!\\n\")\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn, err = net.ListenUDP(udp, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer t.conn.Close()\n\n\tt.listening <- true\n\n\tfor {\n\t\tswitch {\n\t\tcase atomic.LoadInt32(&t.finish) == 1:\n\t\t\tt.done <- true\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tvar buf [4096]byte\n\t\t\trlen, remote, err := t.conn.ReadFromUDP(buf[:])\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&t.finish) == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in read %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg := buf[:rlen]\n\t\t\ttrap, err := t.Params.UnmarshalTrap(msg, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in UnmarshalTrap %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif trap.Version == Version3 && trap.SecurityModel == UserSecurityModel && t.Params.SecurityModel == UserSecurityModel {\n\t\t\t\tsecurityParams, ok := t.Params.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tpacketSecurityParams, ok := trap.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tsnmpEngineID := securityParams.AuthoritativeEngineID\n\t\t\t\tmsgAuthoritativeEngineID := packetSecurityParams.AuthoritativeEngineID\n\t\t\t\tif msgAuthoritativeEngineID != snmpEngineID {\n\t\t\t\t\tif len(msgAuthoritativeEngineID) < 5 || len(msgAuthoritativeEngineID) > 32 {\n\t\t\t\t\t\tatomic.AddUint32(&t.usmStatsUnknownEngineIDsCount, 1)\n\t\t\t\t\t\terr := t.reportAuthoritativeEngineID(trap, snmpEngineID, remote)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.OnNewTrap(trap, remote)\n\n\t\t\tif trap.PDUType == InformRequest {\n\t\t\t\ttrap.PDUType = GetResponse\n\t\t\t\ttrap.Error = NoError\n\t\t\t\ttrap.ErrorIndex = 0\n\t\t\t\terr := t.SendUDP(trap, remote)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tnewSecurityParams, ok := trap.SecurityParameters.Copy().(*UsmSecurityParameters)\n\tif !ok {\n\t\treturn errors.New(\"unable to cast SecurityParams to UsmSecurityParameters\")\n\t}\n\tnewSecurityParams.AuthoritativeEngineID = snmpEngineID\n\treportPacket := trap\n\treportPacket.PDUType = Report\n\treportPacket.MsgFlags &= AuthPriv\n\treportPacket.SecurityParameters = newSecurityParams\n\treportPacket.Variables = []SnmpPDU{\n\t\t{\n\t\t\tName:  usmStatsUnknownEngineIDs,\n\t\t\tValue: int(atomic.LoadUint32(&t.usmStatsUnknownEngineIDsCount)),\n\t\t\tType:  Integer,\n\t\t},\n\t}\n\treturn t.SendUDP(reportPacket, addr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package snmptrap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/soniah/gosnmp\"\n)\n\ntype TrapHandlerFunc func(packet *gosnmp.SnmpPacket, addr *net.UDPAddr)\n\ntype TrapListener struct {\n\tdone                      chan bool\n\tlistening                 chan bool\n\tsync.Mutex\n\tParams                    *gosnmp.GoSNMP\n\tOnNewTrap                 TrapHandlerFunc\n\tCloseTimeout              time.Duration\n\tconn                      *net.UDPConn\n\tproto                     string\n\tusmStatsUnknownEngineIDsCount uint32\n\tfinish                    int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\treturn &TrapListener{\n\t\tdone:      make(chan bool),\n\t\tlistening: make(chan bool),\n\t\tParams:    &gosnmp.GoSNMP{},\n\t\tCloseTimeout: 5 * time.Second,\n\t\tproto:     \"udp\",\n\t}\n}\n\nfunc (t *TrapListener) Close() {\n\tt.Lock()\n\tdefer t.Unlock()\n\n\tif t.conn != nil {\n\t\tt.conn.Close()\n\t\tt.conn = nil\n\t}\n\tclose(t.done)\n}\n\nfunc (t *TrapListener) SendUDP(packet *gosnmp.SnmpPacket, addr *net.UDPAddr) error {\n\tif t.conn == nil {\n\t\treturn errors.New(\"connection not established\")\n\t}\n\t_, err := t.conn.WriteToUDP(packet.Payload, addr)\n\treturn err\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.conn, err = net.ListenUDP(t.proto, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclose(t.listening)\n\tbuffer := make([]byte, 65536)\n\n\tfor {\n\t\tn, remoteAddr, err := t.conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpacket, err := gosnmp.ParseSnmpPacket(buffer[:n], t.Params)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif packet.Version == gosnmp.Version3 && t.Params.SecurityModel == gosnmp.ModelUSM {\n\t\t\tif packet.MsgAuthoritativeEngineID != t.Params.MsgAuthoritativeEngineID {\n\t\t\t\tt.reportAuthoritativeEngineID(packet, packet.MsgAuthoritativeEngineID, remoteAddr)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif t.OnNewTrap != nil {\n\t\t\tgo t.OnNewTrap(packet, remoteAddr)\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *gosnmp.SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tt.usmStatsUnknownEngineIDsCount++\n\tresponse := &gosnmp.SnmpPacket{\n\t\tVersion:   gosnmp.Version3,\n\t\tError:     gosnmp.NoError,\n\t\tErrorIndex: 0,\n\t\tVariables: []gosnmp.SnmpPDU{\n\t\t\tgosnmp.SnmpPDU{\n\t\t\t\tName:  \".1.3.6.1.6.3.15.1.1.1.0\",\n\t\t\t\tType:  gosnmp.OctetString,\n\t\t\t\tValue: []byte(snmpEngineID),\n\t\t\t},\n\t\t},\n\t\tMsgAuthoritativeEngineID: t.Params.MsgAuthoritativeEngineID,\n\t\tSecurity:                 trap.Security,\n\t\tContextEngineID:          trap.ContextEngineID,\n\t\tContextName:              trap.ContextName,\n\t\tSecurityModel:            trap.SecurityModel,\n\t\tSecurityParameters:       trap.SecurityParameters,\n\t\tMsgFlags:                 0x04,\n\t\tMsgSecurityParameters:    trap.MsgSecurityParameters,\n\t}\n\n\treturn t.SendUDP(response, addr)\n}"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a UDP server in Go that handles incoming UDP packets, processes them, and manages connections using a cache system for tracking active connections. The server should support multiple ports with different encryption keys and handle both connection establishment and data packet processing.\n\nStruct Description: The Server struct represents a UDP server instance with TCP and UDP capabilities, including connection caching and encryption support for multiple ports.\n\nFields:\n\nTCPAddr: *net.TCPAddr - TCP address information for the server\nUDPAddr: *net.UDPAddr - UDP address information for the server\nTCPListen: *net.TCPListener - TCP listener instance\nUDPConn: *net.UDPConn - UDP connection instance\nCache: *cache.Cache - Cache for storing active connections\nCkv: *crypto.KV - Default encryption key-value pair\nPortCkv: map[int64]*crypto.KV - Map of port numbers to their respective encryption key-value pairs\n\nMethods:\n\nNewServer: (addr string, password string, portPassword []string) -> (*Server, error) - Creates a new Server instance with the given address, default password, and port-specific passwords\nRunUDPServer: () -> error - Starts the UDP server and begins listening for incoming packets\nUDPHandle: (addr *net.UDPAddr, b []byte) -> error - Handles incoming UDP packets, either establishing new connections or forwarding data to existing connections",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/crypto\"\n)\n\ntype Server struct {\n\tTCPAddr   *net.TCPAddr\n\tUDPAddr   *net.UDPAddr\n\tTCPListen *net.TCPListener\n\tUDPConn   *net.UDPConn\n\tCache     *cache.Cache\n\tCkv       *crypto.KV\n\tPortCkv   map[int64]*crypto.KV\n}\n\nfunc NewServer(addr, password string, portPassword []string) (*Server, error) {\n\tpc := make(map[int64]*crypto.KV)\n\tfor _, v := range portPassword {\n\t\tl := strings.Split(v, \" \")\n\t\tif len(l) != 2 {\n\t\t\treturn nil, errors.New(\"Wrong format: \" + v)\n\t\t}\n\t\tport, err := strconv.ParseInt(l[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tckv := &crypto.KV{\n\t\t\tAESKey: []byte(l[1]),\n\t\t}\n\t\tpc[port] = ckv\n\t}\n\ttaddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tTCPAddr: taddr,\n\t\tUDPAddr: uaddr,\n\t\tCache:   cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tCkv: &crypto.KV{\n\t\t\tAESKey: []byte(password),\n\t\t},\n\t\tPortCkv: pc,\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tvar err error\n\ts.UDPConn, err = net.ListenUDP(\"udp\", s.UDPAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\tn, addr, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func(addr *net.UDPAddr, b []byte) {\n\t\t\tif err := s.UDPHandle(addr, b); err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t}(addr, b[0:n])\n\t}\n\treturn nil\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\tp := &UDPPacket{}\n\tif err := proto.Unmarshal(b, p); err != nil {\n\t\treturn nil\n\t}\n\tif p.Address == \"\" {\n\t\tu, err := NewUDPServer(s, p, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.Cache.Set(\"u:\"+strconv.FormatInt(p.Port, 10), u, cache.DefaultExpiration)\n\t\tdefer s.Cache.Delete(\"u:\" + strconv.FormatInt(p.Port, 10))\n\t\tif err := u.ListenAndServe(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\ti, ok := s.Cache.Get(\"u:\" + strconv.FormatInt(p.Port, 10))\n\tif !ok {\n\t\treturn nil\n\t}\n\tc := i.(*UDPServer)\n\tif err := c.HandlePacket(p); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"sync\"\n)\n\ntype Server struct {\n\tTCPAddr   *net.TCPAddr\n\tUDPAddr   *net.UDPAddr\n\tTCPListen *net.TCPListener\n\tUDPConn   *net.UDPConn\n\tCache     *cache.Cache\n\tCkv       *crypto.KV\n\tPortCkv   map[int64]*crypto.KV\n\tmutex     sync.Mutex\n}\n\nfunc NewServer(addr string, password string, portPassword []string) (*Server, error) {\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefaultKv, err := crypto.NewKV([]byte(password))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportKvs := make(map[int64]*crypto.KV)\n\tfor _, pwd := range portPassword {\n\t\tport, kvStr := parsePortPassword(pwd)\n\t\tkv, err := crypto.NewKV([]byte(kvStr))\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tportKvs[port] = kv\n\t}\n\tcacheInstance := cache.New()\n\treturn &Server{\n\t\tTCPAddr: tcpAddr,\n\t\tUDPAddr: udpAddr,\n\t\tCkv:     defaultKv,\n\t\tPortCkv: portKvs,\n\t\tCache:   cacheInstance,\n\t}, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tconn, err := net.ListenUDP(\"udp\", s.UDPAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.UDPConn = conn\n\tbuffer := make([]byte, 65536)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo s.UDPHandle(addr, buffer[:n])\n\t}\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tvar key *crypto.KV\n\tdestinationPort := int64(addr.Port)\n\tif k, ok := s.PortCkv[destinationPort]; ok {\n\t\tkey = k\n\t} else {\n\t\tkey = s.Ckv\n\t}\n\tdecrypted, err := key.Decrypt(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconnID := generateConnectionID(addr, destinationPort)\n\tconnection, ok := s.Cache.Get(connID)\n\tif !ok {\n\t\tconnection = newConnection(addr, destinationPort, key)\n\t\ts.Cache.Set(connID, connection)\n\t}\n\tconnection.HandleData(decrypted)\n\treturn nil\n}\n\nfunc generateConnectionID(addr *net.UDPAddr, port int64) string {\n\treturn addr.String() + \"-\" + string(port)\n}\n\nfunc parsePortPassword(s string) (int64, string) {\n\tvar port int64\n\tvar pass string\n\t_, _ = fmt.Sscanf(s, \"%d:%s\", &port, &pass)\n\treturn port, pass\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: The provided code demonstrates a WebSocket client implementation in Go for tracker communication in a peer-to-peer network, handling WebSocket connections, message exchange, and WebRTC offer/answer negotiation.\n\nStruct Description: TrackerClient represents a client for interacting with a WebSocket tracker server, managing WebSocket connections, peer connections, and message handling.\n\nFields:\n\nUrl: string - The WebSocket tracker server URL to connect to\nGetAnnounceRequest: func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error) - Function to generate announce requests\nPeerId: [20]byte - The client's peer identifier\nOnConn: onDataChannelOpen - Callback for when data channels open\nLogger: log.Logger - Logger for client operations\nDialer: *websocket.Dialer - WebSocket dialer configuration\nmu: sync.Mutex - Mutex for thread-safe operations\ncond: sync.Cond - Condition variable for connection state changes\noutboundOffers: map[string]outboundOfferValue - Track outbound WebRTC offers\nwsConn: *websocket.Conn - Active WebSocket connection\nclosed: bool - Connection closed flag\npingTicker: *time.Ticker - Timer for sending ping messages\nWebsocketTrackerHttpHeader: func() http.Header - Function to generate WebSocket headers\nICEServers: []webrtc.ICEServer - List of ICE servers for WebRTC\nrtcPeerConns: map[string]*wrappedPeerConnection - Active WebRTC peer connections\n\nMethods:\n\ndoWebsocket: () -> error - Establishes and maintains WebSocket connection to tracker\ntrackerReadLoop: (*websocket.Conn) -> error - Handles incoming WebSocket messages\nwriteMessage: ([]byte) -> error - Writes message to WebSocket connection\nhandleOffer: (offerContext, string) -> error - Processes incoming WebRTC offers\nhandleAnswer: (string, webrtc.SessionDescription) -> void - Processes incoming WebRTC answers",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/anacrolix/log\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v4\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype TrackerClient struct {\n\tUrl                string\n\tGetAnnounceRequest func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId             [20]byte\n\tOnConn             onDataChannelOpen\n\tLogger             log.Logger\n\tDialer             *websocket.Dialer\n\n\tmu             sync.Mutex\n\tcond           sync.Cond\n\toutboundOffers map[string]outboundOfferValue\n\twsConn         *websocket.Conn\n\tclosed         bool\n\tpingTicker     *time.Ticker\n\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers                 []webrtc.ICEServer\n\n\trtcPeerConns map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\ttc.mu.Unlock()\n\n\tvar header http.Header\n\tif tc.WebsocketTrackerHttpHeader != nil {\n\t\theader = tc.WebsocketTrackerHttpHeader()\n\t}\n\n\tc, _, err := tc.Dialer.Dial(tc.Url, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing tracker: %w\", err)\n\t}\n\tdefer c.Close()\n\ttc.Logger.WithDefaultLevel(log.Info).Printf(\"connected\")\n\ttc.mu.Lock()\n\ttc.wsConn = c\n\ttc.cond.Broadcast()\n\ttc.mu.Unlock()\n\tcloseChan := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tc.pingTicker.C:\n\t\t\t\ttc.mu.Lock()\n\t\t\t\terr := c.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\ttc.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-closeChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\terr = tc.trackerReadLoop(tc.wsConn)\n\tclose(closeChan)\n\ttc.mu.Lock()\n\tc.Close()\n\ttc.mu.Unlock()\n\treturn err\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(tracker *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := tracker.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read message error: %w\", err)\n\t\t}\n\t\ttc.Logger.Levelf(log.Debug, \"received message: %q\", message)\n\n\t\tvar ar AnnounceResponse\n\t\tif err := json.Unmarshal(message, &ar); err != nil {\n\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error unmarshalling announce response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase ar.Offer != nil:\n\t\t\tih, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error decoding info_hash in offer: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = tc.handleOffer(offerContext{\n\t\t\t\tSessDesc: *ar.Offer,\n\t\t\t\tId:       ar.OfferID,\n\t\t\t\tInfoHash: ih,\n\t\t\t}, ar.PeerID)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Error, \"handling offer for infohash %x: %v\", ih, err)\n\t\t\t}\n\t\tcase ar.Answer != nil:\n\t\t\ttc.handleAnswer(ar.OfferID, *ar.Answer)\n\t\tdefault:\n\t\t\t_, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Warning, \"unexpected announce response %q\", message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(data []byte) error {\n\tfor tc.wsConn == nil {\n\t\tif tc.closed {\n\t\t\treturn fmt.Errorf(\"%T closed\", tc)\n\t\t}\n\t\ttc.cond.Wait()\n\t}\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, data)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"p2p-tracker/tracker\"\n\t\"p2p-tracker/webrtc\"\n)\n\ntype TrackerClient struct {\n\tUrl                 string\n\tGetAnnounceRequest  func(tracker.AnnounceEvent, [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId              [20]byte\n\tOnConn              onDataChannelOpen\n\tLogger              log.Logger\n\tDialer              *websocket.Dialer\n\tmu                  sync.Mutex\n\tcond                *sync.Cond\n\toutboundOffers      map[string]outboundOfferValue\n\twsConn              *websocket.Conn\n\tclosed              bool\n\tpingTicker          *time.Ticker\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers          []webrtc.ICEServer\n\trtcPeerConns        map[string]*wrappedPeerConnection\n}\n\nfunc (c *TrackerClient) doWebsocket() error {\n\theaders := c.WebsocketTrackerHttpHeader()\n\tconn, _, err := c.Dialer.Dial(c.Url, headers)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.mu.Lock()\n\tc.wsConn = conn\n\tc.cond.Broadcast()\n\tc.mu.Unlock()\n\n\tdefer func() {\n\t\tc.mu.Lock()\n\t\tc.closed = true\n\t\tc.mu.Unlock()\n\t\tc.pingTicker.Stop()\n\t\tc.wsConn.Close()\n\t}()\n\n\tgo c.trackerReadLoop(conn)\n\tc.pingTicker = time.NewTicker(30 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-c.pingTicker.C:\n\t\t\terr := c.writeMessage([]byte(\"ping\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *TrackerClient) trackerReadLoop(conn *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func() {\n\t\t\tvar msg interface{}\n\t\t\terr := json.Unmarshal(message, &msg)\n\t\t\tif err != nil {\n\t\t\t\tc.Logger.Println(\"Failed to parse message:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch v := msg.(type) {\n\t\t\tcase offerContext:\n\t\t\t\tc.handleOffer(v, string(message))\n\t\t\tcase answerContext:\n\t\t\t\tc.handleAnswer(v.PeerID, v.SDP)\n\t\t\tdefault:\n\t\t\t\tc.Logger.Printf(\"Unknown message type: %T\", msg)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (c *TrackerClient) writeMessage(message []byte) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.wsConn == nil {\n\t\treturn ErrNotConnected\n\t}\n\treturn c.wsConn.WriteMessage(websocket.TextMessage, message)\n}\n\nfunc (c *TrackerClient) handleOffer(ctx offerContext, raw string) error {\n\tc.mu.Lock()\n\toffer := outboundOffers[ctx.PeerID]\n\tc.mu.Unlock()\n\n\tif offer.conn == nil {\n\t\treturn ErrNoConnection\n\t}\n\n\terr := offer.conn.SetRemoteDescription(ctx.SDP)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tanswer, err := offer.conn.CreateAnswer(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = offer.conn.SetLocalDescription(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tanswerMsg := answerContext{\n\t\tPeerID: ctx.PeerID,\n\t\tSDP:    answer,\n\t}\n\tmsgBytes, _ := json.Marshal(answerMsg)\n\treturn c.writeMessage(msgBytes)\n}\n\nfunc (c *TrackerClient) handleAnswer(peerID string, sdp webrtc.SessionDescription) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\twconn, exists := c.rtcPeerConns[peerID]\n\tif !exists {\n\t\treturn\n\t}\n\terr := wconn.pc.SetRemoteDescription(sdp)\n\tif err != nil {\n\t\tc.Logger.Printf(\"Error setting remote description for %s: %v\", peerID, err)\n\t}\n}"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Implement a WebSocket proxy struct in Go that can handle bidirectional communication between a client and a backend server, including connection upgrading, message replication, and error handling.\n\nStruct Description: The WebsocketProxy struct acts as a reverse proxy for WebSocket connections, forwarding messages between clients and backend servers while handling connection upgrades and error scenarios.\n\nFields:\n\nDirector: func(*http.Request, http.Header) - A function that can modify the outgoing request headers before connecting to the backend.\nBackend: func(*http.Request) *url.URL - A function that returns the backend URL to connect to.\nUpgrader: *websocket.Upgrader - Configures the WebSocket connection upgrade from HTTP.\nDialer: *websocket.Dialer - Configures how to dial the backend WebSocket connection.\n\nMethods:\n\nServeHTTP: (http.ResponseWriter, *http.Request) -> None - The main handler method that:\n  1. Determines the backend URL\n  2. Establishes connection to backend\n  3. Upgrades client connection\n  4. Sets up bidirectional message replication\n  5. Handles ping/pong messages\n  6. Manages connection errors and closures\n\nreplicateWebsocketConn: (*websocket.Conn, *websocket.Conn, chan error) -> None - A helper method that:\n  1. Continuously reads messages from source connection\n  2. Forwards them to destination connection\n  3. Handles connection errors and closure messages\n  4. Reports errors through the provided channel",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/samber/lo\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tconnPub.SetPingHandler(func(appData string) error {\n\t\terr := connBackend.WriteControl(websocket.PingMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = connPub.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif errors.Is(err, websocket.ErrCloseSent) {\n\t\t\treturn nil\n\t\t} else if e, ok := lo.ErrorsAs[net.Error](err); ok && e.Timeout() {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\n\tvar closeError *websocket.CloseError\n\tif ok := errors.As(err, &closeError); !ok || (closeError != nil && closeError.Code == websocket.CloseAbnormalClosure) {\n\t\tlog.Printf(message, err)\n\t}\n}\n\nfunc replicateWebsocketConn(dst, src *websocket.Conn, errc chan error) {\n\tfor {\n\t\tmsgType, msg, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\tif e, ok := lo.ErrorsAs[*websocket.CloseError](err); ok && e != nil {\n\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t\terrc <- err\n\t\t\t_ = dst.WriteMessage(websocket.CloseMessage, m)\n\t\t\tbreak\n\t\t}\n\t\terr = dst.WriteMessage(msgType, msg)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tdefaultUpgrader = &websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\n\tdefaultDialer = &websocket.Dialer{\n\t\tProxy:            http.ProxyURL(nil),\n\t\tReadBufferSize:   1024,\n\t\tWriteBufferSize:  1024,\n\t\tHandshakeTimeout: 45 * time.Second,\n\t}\n)\n\ntype WebsocketProxy struct {\n\tDirector func(*http.Request, http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif p.Backend == nil {\n\t\tlog.Println(\"websocket proxy: backend function is not set\")\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := p.Backend(r)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocket proxy: backend URL is nil\")\n\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\treturn\n\t}\n\n\tdialer := p.Dialer\n\tif dialer == nil {\n\t\tdialer = defaultDialer\n\t}\n\n\tupgrader := p.Upgrader\n\tif upgrader == nil {\n\t\tupgrader = defaultUpgrader\n\t}\n\n\tbackendHeaders := make(http.Header)\n\tif p.Director != nil {\n\t\tp.Director(r, backendHeaders)\n\t}\n\n\t// Upgrade client connection\n\tclientConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Printf(\"websocket proxy: failed to upgrade client connection: %v\\n\", err)\n\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Connect to backend\n\tbackendConn, resp, err := dialer.Dial(backendURL.String(), backendHeaders)\n\tif err != nil {\n\t\tlog.Printf(\"websocket proxy: failed to connect to backend: %v\\n\", err)\n\t\tif resp != nil && resp.StatusCode >= 400 {\n\t\t\tclientConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(resp.StatusCode, \"\"))\n\t\t} else {\n\t\t\tclientConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(http.StatusInternalServerError, \"backend connection failed\"))\n\t\t}\n\t\tclientConn.Close()\n\t\treturn\n\t}\n\n\terrChan := make(chan error, 2)\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tp.replicateWebsocketConn(clientConn, backendConn, errChan)\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tp.replicateWebsocketConn(backendConn, clientConn, errChan)\n\t}()\n\n\t// Handle ping/pong\n\tclientConn.SetPingHandler(func(appData string) error {\n\t\tclientConn.SetPongHandler(nil) // Disable default pong handler\n\t\tif err := clientConn.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientConn.SetPongHandler(func(appData string) error {\n\t\t\treturn nil\n\t\t})\n\t\treturn nil\n\t})\n\n\tbackendConn.SetPingHandler(func(appData string) error {\n\t\tbackendConn.SetPongHandler(nil)\n\t\tif err := backendConn.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbackendConn.SetPongHandler(func(appData string) error {\n\t\t\treturn nil\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Wait for errors or completion\n\t<-errChan\n\n\t// Cleanup connections\n\tclientConn.Close()\n\tbackendConn.Close()\n\n\twg.Wait()\n\tclose(errChan)\n}\n\nfunc (p *WebsocketProxy) replicateWebsocketConn(src, dst *websocket.Conn, errChan chan error) {\n\tdefer func() {\n\t\tdst.Close()\n\t\tsrc.Close()\n\t}()\n\n\tfor {\n\t\tmsgType, msg, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tif !isExpectedCloseError(err) {\n\t\t\t\tlog.Printf(\"websocket proxy: read error: %v\\n\", err)\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif err := dst.WriteMessage(msgType, msg); err != nil {\n\t\t\tlog.Printf(\"websocket proxy: write error: %v\\n\", err)\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc isExpectedCloseError(err error) bool {\n\tif err == io.EOF {\n\t\treturn true\n\t}\n\tif closeErr, ok := err.(*websocket.CloseError); ok {\n\t\tswitch closeErr.Code {\n\t\tcase websocket.CloseNormalClosure, websocket.CloseGoingAway, websocket.CloseNoStatusReceived:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Go function that establishes a WebSocket connection to a specified URL, sends a protobuf message as a JSON payload, and returns the WebSocket connection for further communication.\n\nFunction Description: The function `openWebSocket` establishes a secure WebSocket connection (wss://) to a given URL with optional custom headers. It authenticates using admin macaroon if no custom headers are provided, sends a protobuf message as JSON, and returns the active WebSocket connection. The caller is responsible for closing the connection.\n\nInput:\n- `node` [*node.HarnessNode] - Node configuration containing REST address and authentication details\n- `url` [string] - The endpoint path for the WebSocket connection\n- `method` [string] - The method parameter to include in the query string\n- `req` [proto.Message] - The protobuf message to send as initial payload\n- `customHeader` [http.Header] - Optional custom HTTP headers for the request\n\nOutput:\n- [*websocket.Conn] - Established WebSocket connection for bidirectional communication\n- [error] - Error if any step in the connection process fails",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lntest/node\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar (\n\twebSocketDialer = &websocket.Dialer{\n\t\tHandshakeTimeout: time.Second,\n\t\tTLSClientConfig:  insecureTransport.TLSClientConfig,\n\t}\n\tcloseMsg = websocket.FormatCloseMessage(\n\t\twebsocket.CloseNormalClosure, \"done\",\n\t)\n)\n\nfunc openWebSocket(node *node.HarnessNode, url, method string,\n\treq proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\n\theader := customHeader\n\tif header == nil {\n\t\theader = make(http.Header)\n\t\tif err := addAdminMacaroon(node, header); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfullURL := fmt.Sprintf(\n\t\t\"wss://%s%s?method=%s\", node.Cfg.RESTAddr(), url, method,\n\t)\n\tconn, resp, err := webSocketDialer.Dial(fullURL, header)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\treqMsg, err := lnrpc.RESTJsonMarshalOpts.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = conn.WriteMessage(websocket.TextMessage, reqMsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc openWebSocket(node *node.HarnessNode, urlStr, method string, req proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tu, err := url.Parse(fmt.Sprintf(\"wss://%s/%s\", node.RestAddress, urlStr))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := u.Query()\n\tquery.Set(\"method\", method)\n\tu.RawQuery = query.Encode()\n\n\theaders := http.Header{}\n\tif customHeader == nil {\n\t\t// Use admin macaroon if no custom headers provided\n\t\tmacaroon, err := node.AdminMacaroon()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\theaders.Set(\"Grpc-Metadata-macaroon\", fmt.Sprintf(\"%x\", macaroon))\n\t} else {\n\t\theaders = customHeader\n\t}\n\n\tconn, _, err := websocket.DefaultDialer.DialContext(ctx, u.String(), headers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Marshal protobuf message to JSON\n\tjsonData, err := json.Marshal(req)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Send initial protobuf message as JSON\n\tif err := conn.WriteMessage(websocket.TextMessage, jsonData); err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that can establish secure connections, handle protocol negotiation, and manage message transmission between client and server. The solution should support TLS configuration, proxy settings, and proper connection cleanup.\n\nStruct Description: The RoundTripper struct implements http.RoundTripper interface to handle WebSocket connections with additional capabilities for Kubernetes API server communication. It manages WebSocket connections with TLS support and proxy configuration.\n\nFields:\n- TLSConfig: *tls.Config - Configuration for TLS/SSL connections\n- Proxier: func(req *http.Request) (*url.URL, error) - Function to determine proxy for requests\n- Conn: *gwebsocket.Conn - Active WebSocket connection\n\nMethods:\n- Connection: () -> *gwebsocket.Conn - Returns the active WebSocket connection\n- DataBufferSize: () -> int - Returns the buffer size for data transmission (32KB by default)\n- TLSClientConfig: () -> *tls.Config - Returns the TLS configuration\n- RoundTrip: (*http.Request) -> (*http.Response, error) - Main method that establishes WebSocket connection, handles protocol negotiation, and returns the HTTP response\n\nAdditional Function:\n- RoundTripperFor: (*restclient.Config) -> (http.RoundTripper, ConnectionHolder, error) - Factory function that creates a configured RoundTripper instance with proper TLS and proxy settings from Kubernetes client configuration",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tgwebsocket \"github.com/gorilla/websocket\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream/wsstream\"\n\tutilnet \"k8s.io/apimachinery/pkg/util/net\"\n\trestclient \"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/transport\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *gwebsocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *gwebsocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(request *http.Request) (retResp *http.Response, retErr error) {\n\tdefer func() {\n\t\tif request.Body != nil {\n\t\t\terr := request.Body.Close()\n\t\t\tif retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}\n\t}()\n\n\tprotocolVersions := request.Header[wsstream.WebSocketProtocolHeader]\n\tdelete(request.Header, wsstream.WebSocketProtocolHeader)\n\n\tdialer := gwebsocket.Dialer{\n\t\tProxy:           rt.Proxier,\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tSubprotocols:    protocolVersions,\n\t\tReadBufferSize:  rt.DataBufferSize() + 1024,\n\t\tWriteBufferSize: rt.DataBufferSize() + 1024,\n\t}\n\tswitch request.URL.Scheme {\n\tcase \"https\":\n\t\trequest.URL.Scheme = \"wss\"\n\tcase \"http\":\n\t\trequest.URL.Scheme = \"ws\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown url scheme: %s\", request.URL.Scheme)\n\t}\n\twsConn, resp, err := dialer.DialContext(request.Context(), request.URL.String(), request.Header)\n\tif err != nil {\n\t\tif errors.Is(err, gwebsocket.ErrBadHandshake) {\n\t\t\tcause := err\n\t\t\tif resp != nil && len(resp.Status) > 0 {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tcause = fmt.Errorf(\"%w (%s)\", err, resp.Status)\n\t\t\t\tresponseErrorBytes, readErr := io.ReadAll(io.LimitReader(resp.Body, 64*1024))\n\t\t\t\tif readErr != nil {\n\t\t\t\t\tcause = fmt.Errorf(\"%w: unable to read error from server response\", cause)\n\t\t\t\t} else {\n\t\t\t\t\tresponseError := strings.TrimSpace(string(responseErrorBytes))\n\t\t\t\t\tif len(responseError) > 0 {\n\t\t\t\t\t\tif obj, _, decodeErr := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); decodeErr == nil {\n\t\t\t\t\t\t\tif status, ok := obj.(*metav1.Status); ok {\n\t\t\t\t\t\t\t\tcause = &apierrors.StatusError{ErrStatus: *status}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcause = fmt.Errorf(\"%w: %s\", cause, responseError)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, &httpstream.UpgradeFailureError{Cause: cause}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tfoundProtocol := false\n\tfor _, protocolVersion := range protocolVersions {\n\t\tif protocolVersion == wsConn.Subprotocol() {\n\t\t\tfoundProtocol = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !foundProtocol {\n\t\twsConn.Close()\n\t\treturn nil, &httpstream.UpgradeFailureError{Cause: fmt.Errorf(\"invalid protocol, expected one of %q, got %q\", protocolVersions, wsConn.Subprotocol())}\n\t}\n\n\trt.Conn = wsConn\n\n\treturn resp, nil\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttransportCfg, err := config.TransportConfig()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttlsConfig, err := transport.TLSConfigFor(transportCfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxy := config.Proxy\n\tif proxy == nil {\n\t\tproxy = utilnet.NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)\n\t}\n\n\tupgradeRoundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxy,\n\t}\n\twrapper, err := transport.HTTPWrappersForConfig(transportCfg, upgradeRoundTripper)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn wrapper, upgradeRoundTripper, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *websocket.Conn\n}\n\nfunc (r *RoundTripper) Connection() *websocket.Conn {\n\treturn r.Conn\n}\n\nfunc (r *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024 // 32KB default buffer size\n}\n\nfunc (r *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn r.TLSConfig\n}\n\nfunc (r *RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tdialer := &websocket.Dialer{\n\t\tProxy:       r.Proxier,\n\t\tTLSClientConfig: r.TLSConfig,\n\t}\n\n\theaders := http.Header{}\n\tfor k, v := range req.Header {\n\t\theaders[k] = v\n\t}\n\n\turlStr := req.URL.String()\n\tconn, resp, err := dialer.Dial(urlStr, headers)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\n\tr.Conn = conn\n\treturn resp, nil\n}\n\ntype ConnectionHolder interface {\n\tConnection() *websocket.Conn\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttlsConfig, err := restclient.TLSConfigFor(config)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tproxier := func(req *http.Request) (*url.URL, error) {\n\t\treturn http.ProxyURL(config.Proxy)(req)\n\t}\n\n\trt := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxier,\n\t}\n\n\treturn rt, rt, nil\n}"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a WebSocket client connection wrapper in Go that provides a simplified interface for reading and writing binary messages over a WebSocket connection, with proper error handling and connection management.\n\nStruct Description: The Conn struct wraps a WebSocket connection and provides io.Reader/io.Writer compatible methods for binary message communication, along with standard net.Conn interface methods.\n\nFields:\nwsConn: *websocket.Conn - The underlying WebSocket connection\nreader: io.Reader - Current message reader for streaming message content\n\nMethods:\nNew: (wsConn *websocket.Conn) -> *Conn - Creates a new Conn wrapper instance\nDial: (ctx context.Context, url string, opts ...DialOption) -> (*Conn, error) - Establishes a new WebSocket connection with optional configuration\nRead: (b []byte) -> (int, error) - Reads binary data from the WebSocket connection (implements io.Reader)\nWrite: (b []byte) -> (int, error) - Writes binary data to the WebSocket connection (implements io.Writer)\nClose: () -> error - Closes the WebSocket connection\nLocalAddr: () -> net.Addr - Returns local network address\nRemoteAddr: () -> net.Addr - Returns remote network address\nSetDeadline: (t time.Time) -> error - Sets both read and write deadlines\nSetReadDeadline: (t time.Time) -> error - Sets read deadline\nSetWriteDeadline: (t time.Time) -> error - Sets write deadline",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: nil,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\toptions := dialOptions{}\n\tfor _, o := range opts {\n\t\to.apply(&options)\n\t}\n\n\tdialer := &websocket.Dialer{\n\t\tHandshakeTimeout: 60 * time.Second,\n\t}\n\n\tif options.tlsConfig != nil {\n\t\tdialer.TLSClientConfig = options.tlsConfig\n\t}\n\n\theader := make(http.Header)\n\tif options.token != \"\" {\n\t\theader.Set(\"Authorization\", \"Bearer \"+options.token)\n\t}\n\n\twsConn, resp, err := dialer.DialContext(\n\t\tctx, url, header,\n\t)\n\tif err == nil {\n\t\treturn New(wsConn), nil\n\t}\n\tif resp == nil {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\tdefer resp.Body.Close()\n\n\terr = fmt.Errorf(\"%d: %w\", resp.StatusCode, err)\n\tif _, ok := retryableStatusCodes[resp.StatusCode]; ok {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\treturn nil, err\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tfor {\n\t\tif c.reader == nil {\n\t\t\tmt, r, err := c.wsConn.NextReader()\n\t\t\tif err != nil {\n\t\t\t\tvar closeErr *websocket.CloseError\n\t\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\t\treturn 0, net.ErrClosed\n\t\t\t\t}\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif mt != websocket.BinaryMessage {\n\t\t\t\treturn 0, fmt.Errorf(\"unexpected message type: %d\", mt)\n\t\t\t}\n\t\t\tc.reader = r\n\t\t}\n\n\t\tn, err := c.reader.Read(b)\n\t\tif n > 0 {\n\t\t\tif err != nil {\n\t\t\t\tc.reader = nil\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err\n\t\t}\n\t\tif err != io.EOF {\n\t\t\tvar closeErr *websocket.CloseError\n\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\treturn 0, net.ErrClosed\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc.reader = nil\n\t}\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tif err := c.wsConn.WriteMessage(websocket.BinaryMessage, b); err != nil {\n\t\tvar closeErr *websocket.CloseError\n\t\tif errors.As(err, &closeErr) {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package websocketconn\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn  *websocket.Conn\n\treader  io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn:  wsConn,\n\t\treader:  nil,\n\t}\n}\n\ntype DialOption func(*websocket.Dialer)\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\tdialer := &websocket.Dialer{}\n\tfor _, opt := range opts {\n\t\topt(dialer)\n\t}\n\twsConn, _, err := dialer.DialContext(ctx, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn New(wsConn), nil\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tif c.reader != nil {\n\t\tn, err := c.reader.Read(b)\n\t\tif err == io.EOF {\n\t\t\tc.reader = nil\n\t\t\treturn n, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\tmsgType, reader, err := c.wsConn.NextReader()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif msgType != websocket.BinaryMessage {\n\t\treturn 0, websocket.ErrUnexpectedMessageType\n\t}\n\n\tc.reader = reader\n\treturn c.reader.Read(b)\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\twriter, err := c.wsConn.NextWriter(websocket.BinaryMessage)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer writer.Close()\n\n\treturn writer.Write(b)\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Implement a WebSocket server handler for a DERP (Distributed Encrypted Relay for Packets) server using the nhooyr.io/websocket library in Go. The handler should upgrade HTTP connections to WebSocket, enforce protocol requirements, and establish the connection for DERP communication.\n\nStruct Description: The DERPServer struct represents a DERP server instance that handles WebSocket connections for relaying encrypted packets between Tailscale nodes.\n\nFields:\nkey: [key.NodePrivate] - The private key used for node authentication\ntailscaleDERP: [*derp.Server] - The underlying DERP server instance that manages relay connections\n\nMethods:\nserveWebsocket: [Name](writer http.ResponseWriter, req *http.Request) -> [void] - Handles incoming HTTP requests by upgrading them to WebSocket connections. Validates the subprotocol, creates a network connection wrapper around the WebSocket, and passes it to the DERP server for handling.\n\nInput:\n- writer: [http.ResponseWriter] - The HTTP response writer\n- req: [*http.Request] - The incoming HTTP request\n\nOutput:\n- None (handles connection directly, may write error responses to writer)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/coder/websocket\"\n\t\"tailscale.com/derp\"\n\t\"tailscale.com/net/wsconn\"\n)\n\ntype DERPServer struct {\n\tkey           key.NodePrivate\n\ttailscaleDERP *derp.Server\n}\n\nfunc (d *DERPServer) serveWebsocket(writer http.ResponseWriter, req *http.Request) {\n\twebsocketConn, err := websocket.Accept(writer, req, &websocket.AcceptOptions{\n\t\tSubprotocols:   []string{\"derp\"},\n\t\tOriginPatterns: []string{\"*\"},\n\t\tCompressionMode: websocket.CompressionDisabled,\n\t})\n\tif err != nil {\n\t\twriter.Header().Set(\"Content-Type\", \"text/plain\")\n\t\twriter.WriteHeader(http.StatusInternalServerError)\n\t\t_, err = writer.Write([]byte(\"Failed to upgrade websocket request\"))\n\t\treturn\n\t}\n\tdefer websocketConn.Close(websocket.StatusInternalError, \"closing\")\n\tif websocketConn.Subprotocol() != \"derp\" {\n\t\twebsocketConn.Close(websocket.StatusPolicyViolation, \"client must speak the derp subprotocol\")\n\t\treturn\n\t}\n\n\twc := wsconn.NetConn(req.Context(), websocketConn, websocket.MessageBinary, req.RemoteAddr)\n\tbrw := bufio.NewReadWriter(bufio.NewReader(wc), bufio.NewWriter(wc))\n\td.tailscaleDERP.Accept(req.Context(), wc, brw, req.RemoteAddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package derpserver\n\nimport (\n\t\"net/http\"\n\n\t\"nhooyr.io/websocket\"\n\t\"nhooyr.io/websocket/wsjson\"\n\t\"tailscale.com/derp\"\n\t\"tailscale.com/key\"\n)\n\ntype DERPServer struct {\n\tkey          key.NodePrivate\n\ttailscaleDERP *derp.Server\n}\n\nfunc (s *DERPServer) serveWebsocket(writer http.ResponseWriter, req *http.Request) {\n\tconn, err := websocket.Accept(writer, req, &websocket.AcceptOptions{\n\t\tSubprotocols: []string{\"https://tailscale.com/derp\"},\n\t})\n\tif err != nil {\n\t\thttp.Error(writer, \"Failed to accept WebSocket connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsubproto := conn.Subprotocol()\n\tif subproto != \"https://tailscale.com/derp\" {\n\t\tconn.Close(websocket.StatusPolicyViolation, \"invalid subprotocol\")\n\t\treturn\n\t}\n\n\twsc := &websocketConn{conn: conn}\n\ts.tailscaleDERP.Handle(wsc)\n}\n\ntype websocketConn struct {\n\tconn *websocket.Conn\n}\n\nfunc (c *websocketConn) Read(b []byte) (int, error) {\n\ttyp, r, err := c.conn.Reader(req.Context())\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif typ != websocket.MessageBinary {\n\t\treturn 0, wsjson.WriteError(c.conn, websocket.StatusUnsupportedData, \"expected binary message\")\n\t}\n\treturn r.Read(b)\n}\n\nfunc (c *websocketConn) Write(b []byte) (int, error) {\n\tw, err := c.conn.Writer(req.Context(), websocket.MessageBinary)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn, err := w.Write(b)\n\tw.Close()\n\treturn n, err\n}\n\nfunc (c *websocketConn) Close() error {\n\treturn c.conn.Close(websocket.StatusNormalClosure, \"\")\n}"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Implement a WebSocket server in Go that handles WebSocket connections, messages, and events using the nhooyr.io/websocket package. The server should provide event-based handling for connection establishment, message reception, and connection closure.\n\nStruct Description: The `testServer` struct represents a WebSocket server with event handling capabilities. It manages HTTP routes, WebSocket connections, and provides methods to subscribe to WebSocket events.\n\nFields:\n\n- sync.Mutex: sync.Mutex - Provides thread-safe access to the server's resources\n- eventEmitter: playwright.EventEmitter - Handles event subscription and emission for WebSocket events\n- mux: *http.ServeMux - HTTP request multiplexer for routing\n- testServer: *httptest.Server - HTTP test server instance\n- routes: map[string]http.HandlerFunc - Map of URL paths to their handler functions\n- requestSubscriberes: map[string][]chan *http.Request - Channels for request subscribers\n- PREFIX: string - Server URL prefix\n- EMPTY_PAGE: string - Path to empty page\n- CROSS_PROCESS_PREFIX: string - Prefix for cross-process communication\n- WS_PREFIX: string - WebSocket endpoint prefix\n- PORT: string - Server port number\n\nMethods:\n\n- wsHandler: (w http.ResponseWriter, r *http.Request) -> void - Handles WebSocket connection upgrade and message processing\n- OnceWebSocketConnection: (handler func(c *websocket.Conn, r *http.Request)) -> void - Registers a one-time connection handler\n- OnWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a persistent close handler\n- OnceWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a one-time close handler\n- OnWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a persistent message handler\n- OnceWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a one-time message handler\n- SendOnWebSocketConnection: (msgType websocket.MessageType, data []byte) -> void - Sends a message when a connection is established\n- WaitForWebSocketConnection: () -> <-chan *wsConnection - Returns a channel that receives the first WebSocket connection\n\nAdditional Struct:\n\n- wsConnection: struct - Represents an active WebSocket connection\n  Fields:\n    - Conn: *websocket.Conn - The WebSocket connection\n    - Req: *http.Request - The associated HTTP request\n  Methods:\n    - SendMessage: (msgType websocket.MessageType, data []byte) -> void - Sends a message through the connection",
    "Canonical_solution": "import (\n\t\"github.com/coder/websocket\"\n\t\"github.com/playwright-community/playwright-go\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype testServer struct {\n\tsync.Mutex\n\teventEmitter         playwright.EventEmitter\n\tmux                  *http.ServeMux\n\ttestServer           *httptest.Server\n\troutes               map[string]http.HandlerFunc\n\trequestSubscriberes  map[string][]chan *http.Request\n\tPREFIX               string\n\tEMPTY_PAGE           string\n\tCROSS_PROCESS_PREFIX string\n\tWS_PREFIX            string\n\tPORT                 string\n}\n\nfunc (t *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tInsecureSkipVerify: true,\n\t})\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not upgrade ws connection:\", err)\n\t\treturn\n\t}\n\tdefer c.Close(websocket.StatusNormalClosure, \"\")\n\n\tt.eventEmitter.Emit(\"connection\", c, r)\n\n\tfor {\n\t\ttyp, message, err := c.Read(r.Context())\n\t\tif err != nil {\n\t\t\tcloseErr := new(websocket.CloseError)\n\t\t\tif errors.As(err, closeErr) {\n\t\t\t\tt.eventEmitter.Emit(\"close\", closeErr)\n\t\t\t}\n\t\t\tswitch websocket.CloseStatus(err) {\n\t\t\tcase websocket.StatusNormalClosure, websocket.StatusGoingAway, websocket.StatusNoStatusRcvd:\n\t\t\tdefault:\n\t\t\t\tlog.Println(\"testServer: could not read ws message:\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tt.eventEmitter.Emit(\"message\", c, r, typ, message)\n\t}\n}\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (c *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\terr := c.Conn.Write(c.Req.Context(), msgType, data)\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\treturn\n\t}\n}\n\nfunc (t *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\tt.eventEmitter.Once(\"connection\", handler)\n}\n\nfunc (t *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.On(\"close\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.Once(\"close\", handler)\n}\n\nfunc (t *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.On(\"message\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.Once(\"message\", handler)\n}\n\nfunc (t *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\terr := c.Write(r.Context(), msgType, data)\n\t\tif err != nil {\n\t\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\t\treturn\n\t\t}\n\t})\n}\n\nfunc (t *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\tchannel := make(chan *wsConnection)\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tchannel <- &wsConnection{Conn: c, Req: r}\n\t\tclose(channel)\n\t})\n\treturn channel\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"nhooyr.io/websocket\"\n\t\"nhooyr.io/websocket/wsjson\"\n)\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (wsc *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\tctx := context.Background()\n\tswitch msgType {\n\tcase websocket.MessageText:\n\t\twsc.Conn.Write(ctx, websocket.MessageText, data)\n\tcase websocket.MessageBinary:\n\t\twsc.Conn.Write(ctx, websocket.MessageBinary, data)\n\t}\n}\n\ntype testServer struct {\n\tsync.Mutex\n\teventEmitter          EventEmitter\n\tmux                   *http.ServeMux\n\ttestServer            *httptest.Server\n\troutes                map[string]http.HandlerFunc\n\trequestSubscribers    map[string][]chan *http.Request\n\tPREFIX                string\n\tEMPTY_PAGE            string\n\tCROSS_PROCESS_PREFIX  string\n\tWS_PREFIX             string\n\tPORT                  string\n\tonceConnectionHandler func(c *websocket.Conn, r *http.Request)\n\tcloseHandlers         []func(err *websocket.CloseError)\n\tmessageHandlers       []func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)\n\tconnectionChan        chan *wsConnection\n}\n\nfunc NewTestServer() *testServer {\n\tts := &testServer{\n\t\tmux:                  http.NewServeMux(),\n\t\troutes:               make(map[string]http.HandlerFunc),\n\t\trequestSubscribers:   make(map[string][]chan *http.Request),\n\t\tconnectionChan:       make(chan *wsConnection, 1),\n\t\teventEmitter:         NewEventEmitter(),\n\t}\n\tts.testServer = httptest.NewServer(ts.mux)\n\treturn ts\n}\n\nfunc (s *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tc, err := websocket.Accept(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"WebSocket upgrade failed: \"+err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif s.onceConnectionHandler != nil {\n\t\tonceHandler := s.onceConnectionHandler\n\t\ts.onceConnectionHandler = nil\n\t\tonceHandler(c, r)\n\t}\n\n\tconn := &wsConnection{Conn: c, Req: r}\n\ts.connectionChan <- conn\n\n\tfor {\n\t\tmsgType, msg, err := c.Read(r.Context())\n\t\tif err != nil {\n\t\t\tif closeErr, ok := err.(*websocket.CloseError); ok {\n\t\t\t\tfor _, handler := range s.closeHandlers {\n\t\t\t\t\thandler(closeErr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tfor _, handler := range s.messageHandlers {\n\t\t\thandler(c, r, msgType, msg)\n\t\t}\n\t}\n}\n\nfunc (s *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.onceConnectionHandler = handler\n}\n\nfunc (s *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.closeHandlers = append(s.closeHandlers, handler)\n}\n\nfunc (s *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\ts.Lock()\n\tdefer s.Unlock()\n\toriginalHandler := handler\n\twrappedHandler := func(err *websocket.CloseError) {\n\t\toriginalHandler(err)\n\t\ts.closeHandlers = removeCloseHandler(s.closeHandlers, wrappedHandler)\n\t}\n\ts.closeHandlers = append(s.closeHandlers, wrappedHandler)\n}\n\nfunc (s *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.messageHandlers = append(s.messageHandlers, handler)\n}\n\nfunc (s *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\ts.Lock()\n\tdefer s.Unlock()\n\toriginalHandler := handler\n\twrappedHandler := func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte) {\n\t\toriginalHandler(c, r, msgType, msg)\n\t\ts.messageHandlers = removeMessageHandler(s.messageHandlers, wrappedHandler)\n\t}\n\ts.messageHandlers = append(s.messageHandlers, wrappedHandler)\n}\n\nfunc (s *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\tconn := <-s.connectionChan\n\tconn.SendMessage(msgType, data)\n}\n\nfunc (s *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\treturn s.connectionChan\n}\n\nfunc removeCloseHandler(handlers []func(err *websocket.CloseError), handlerToRemove func(err *websocket.CloseError)) []func(err *websocket.CloseError) {\n\tresult := make([]func(err *websocket.CloseError), 0)\n\tfor _, h := range handlers {\n\t\tif h != handlerToRemove {\n\t\t\tresult = append(result, h)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc removeMessageHandler(handlers []func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)), handlerToRemove func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) []func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tresult := make([]func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)), 0)\n\tfor _, h := range handlers {\n\t\tif h != handlerToRemove {\n\t\t\tresult = append(result, h)\n\t\t}\n\t}\n\treturn result\n}"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: The task involves creating a WebSocket handler in Go that upgrades HTTP connections to WebSocket connections, manages the connection lifecycle, and handles message exchange between client and server.\n\nStruct Description: The WsHandler struct is responsible for managing WebSocket connections, including upgrading HTTP connections, handling incoming messages, and managing connection state.\n\nFields:\n- svcCtx: *svc.ServiceContext - A reference to the service context containing dependencies and configuration\n\nMethods:\n- Upgrade: (ginCtx *gin.Context) -> void - Upgrades an HTTP connection to a WebSocket connection and manages the connection lifecycle\n  Input: ginCtx *gin.Context - The Gin context containing HTTP request and response objects\n  Output: None (handles connection directly)\n\n- onReceive: (ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) -> (pb.ResponseCode, error) - Handles incoming WebSocket messages\n  Input: \n    - ctx context.Context - Context for the operation\n    - connection *gatewayservicelogic.Connection - The WebSocket connection object\n    - typ websocket.MessageType - Type of the WebSocket message\n    - msg []byte - The message content\n  Output:\n    - pb.ResponseCode - Response code indicating processing result\n    - error - Any error that occurred during processing",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tgatewayservicelogic \"github.com/cherish-chat/xxim-server/app/gateway/internal/logic/gatewayservice\"\n\t\"github.com/cherish-chat/xxim-server/common/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/zeromicro/go-zero/core/logx\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"io\"\n\t\"math\"\n\t\"nhooyr.io/websocket\"\n\t\"strings\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tr := ginCtx.Request\n\tw := ginCtx.Writer\n\tlogger := logx.WithContext(r.Context())\n\theaders := make(map[string]string)\n\tfor k, v := range r.Header {\n\t\tif len(v) > 0 {\n\t\t\theaders[k] = v[0]\n\t\t}\n\t}\n\theader := &pb.RequestHeader{\n\t\tClientIp: utils.Http.GetClientIP(r),\n\t}\n\tcompressionMode := websocket.CompressionNoContextTakeover\n\tif strings.Contains(r.UserAgent(), \"Safari\") {\n\t\tcompressionMode = websocket.CompressionDisabled\n\t}\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tSubprotocols:         nil,\n\t\tInsecureSkipVerify:   true,\n\t\tOriginPatterns:       nil,\n\t\tCompressionMode:      compressionMode,\n\t\tCompressionThreshold: 0,\n\t})\n\tif err != nil {\n\t\tif r.URL.Path == \"/\" {\n\t\t\treturn\n\t\t}\n\t\tlogger.Errorf(\"failed to accept websocket connection: %v\", err)\n\t\treturn\n\t}\n\tc.SetReadLimit(math.MaxInt32)\n\tbeforeConnectResp, err := h.svcCtx.CallbackService.UserBeforeConnect(r.Context(), &pb.UserBeforeConnectReq{Header: header})\n\tif err != nil {\n\t\tlogger.Errorf(\"beforeConnect error: %v\", err)\n\t\tc.Close(websocket.StatusCode(pb.WebsocketCustomCloseCode_CloseCodeServerInternalError), err.Error())\n\t\treturn\n\t}\n\tif !beforeConnectResp.Success {\n\t\tc.Close(websocket.StatusCode(beforeConnectResp.CloseCode), beforeConnectResp.CloseReason)\n\t\treturn\n\t}\n\n\theader.UserId = beforeConnectResp.UserId\n\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\tctx, cancelFunc := context.WithCancel(r.Context())\n\tconnection := gatewayservicelogic.NewWebsocketConnect(ctx, header, c)\n\tdefer func() {\n\t\tgatewayservicelogic.ConnectionLogic.OnDisconnect(connection)\n\t}()\n\tgo func() {\n\t\tdefer cancelFunc()\n\t\tfor {\n\t\t\tlogger.Debugf(\"start read\")\n\t\t\ttyp, msg, err := c.Read(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t} else if websocket.CloseStatus(err) == websocket.StatusNormalClosure ||\n\t\t\t\t\twebsocket.CloseStatus(err) == websocket.StatusGoingAway {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"connection reset by peer\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"corrupt input\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlogx.Errorf(\"failed to read message: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\t_, _ = h.onReceive(ctx, connection, typ, msg)\n\t\t\t}()\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\tvar aesKey []byte\n\tvar aesIv []byte\n\tvar isEncrypt bool\n\n\tconnection.PublicKeyLock.RLock()\n\t{\n\t\tif len(connection.SharedSecret) == 0 {\n\t\t\tisEncrypt = false\n\t\t} else {\n\t\t\tisEncrypt = true\n\t\t\taesKey = connection.SharedSecret[:]\n\t\t\taesIv = connection.SharedSecret[8:24]\n\t\t}\n\t}\n\tconnection.PublicKeyLock.RUnlock()\n\n\tif isEncrypt {\n\t\tvar err error\n\t\tmsg, err = utils.Aes.Decrypt(aesKey, aesIv, msg)\n\t\tif err != nil {\n\t\t\tlogx.Errorf(\"decrypt message error: %v\", err)\n\t\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t\t}\n\t}\n\n\tapiRequest := &pb.GatewayApiRequest{}\n\terr := proto.Unmarshal(msg, apiRequest)\n\tif err != nil {\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t}\n\tapiRequest.Header = connection.GetHeader()\n\troute, ok := universalRouteMap[apiRequest.Path]\n\ttracer := otel.Tracer(common.TraceName)\n\tpropagator := otel.GetTextMapPropagator()\n\tspanName := apiRequest.Path\n\tcarrier := propagation.MapCarrier{\n\t\t\"appId\":       apiRequest.Header.AppId,\n\t\t\"userId\":      apiRequest.Header.UserId,\n\t\t\"clientIp\":    apiRequest.Header.ClientIp,\n\t\t\"installId\":   apiRequest.Header.InstallId,\n\t\t\"platform\":    apiRequest.Header.Platform.String(),\n\t\t\"deviceModel\": apiRequest.Header.DeviceModel,\n\t\t\"osVersion\":   apiRequest.Header.OsVersion,\n\t\t\"appVersion\":  apiRequest.Header.AppVersion,\n\t\t\"connectTime\": connection.ConnectedTime.Format(\"2006-01-02 15:04:05\"),\n\t\t\"extra\":       apiRequest.Header.Extra,\n\t}\n\tspanCtx := propagator.Extract(ctx, carrier)\n\tspanCtx, span := tracer.Start(spanCtx, spanName,\n\t\toteltrace.WithSpanKind(oteltrace.SpanKindServer),\n\t)\n\tdefer span.End()\n\tpropagator.Inject(spanCtx, carrier)\n\tif !ok {\n\t\tlogx.Errorf(\"path 404 not found: %s\", apiRequest.Path)\n\t\tspan.SetStatus(codes.Error, \"path\"+apiRequest.Path+\"404 not found\")\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", \"path 404 not found\")\n\t}\n\tcode, responseBody, err := route(spanCtx, connection, apiRequest)\n\tif len(responseBody) > 0 {\n\t\terr := connection.SendMessage(ctx, responseBody)\n\t\tif err != nil {\n\t\t\tlogx.Infof(\"failed to write message: %v\", err)\n\t\t}\n\t}\n\tspan.SetAttributes(attribute.Int(\"responseBody.length\", len(responseBody)))\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, err.Error())\n\t} else {\n\t\tspan.SetStatus(codes.Ok, \"\")\n\t}\n\treturn code, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package handler\n\nimport (\n\t\"context\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/net/websocket\"\n\tpb \"your_project/protobuf\"\n\t\"your_project/gatewayservicelogic\"\n\t\"your_project/svc\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tconn, err := websocket.Upgrade(ginCtx.Writer, ginCtx.Request, nil, 1024, 1024)\n\tif err != nil {\n\t\thttpStatus := websocket.StatusBadRequest\n\t\tif e, ok := err.(websocket.HandshakeError); ok && !e.Temporary() {\n\t\t\thttpStatus = websocket.StatusForbidden\n\t\t}\n\t\tginCtx.AbortWithStatusJSON(httpStatus, gin.H{\"error\": \"could not open websocket connection\"})\n\t\treturn\n\t}\n\n\tconnection := gatewayservicelogic.NewConnection(conn, h.svcCtx)\n\tdefer connection.Close()\n\n\tfor {\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tcode, processErr := h.onReceive(context.Background(), connection, msgType, msg)\n\t\tif processErr != nil {\n\t\t\t// Handle error and potentially send error response to client\n\t\t\t_ = conn.WriteMessage(websocket.TextMessage, []byte(processErr.Error()))\n\t\t} else if code != pb.ResponseCode_CONTINUE {\n\t\t\t// Handle non-continue codes as needed\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\t// Process message based on type\n\tswitch typ {\n\tcase websocket.TextMessage:\n\t\t// Handle text message\n\t\terr := connection.WriteMessage(websocket.TextMessage, append([]byte(\"received: \"), msg...))\n\t\tif err != nil {\n\t\t\treturn pb.ResponseCode_INTERNAL_ERROR, err\n\t\t}\n\t\treturn pb.ResponseCode_SUCCESS, nil\n\tcase websocket.BinaryMessage:\n\t\t// Handle binary message\n\t\terr := connection.WriteMessage(websocket.BinaryMessage, msg)\n\t\tif err != nil {\n\t\t\treturn pb.ResponseCode_INTERNAL_ERROR, err\n\t\t}\n\t\treturn pb.ResponseCode_SUCCESS, nil\n\tdefault:\n\t\treturn pb.ResponseCode_BAD_REQUEST, nil\n\t}\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawnUserNamespaceCat creates a child process in a new user namespace to read a specified file. It establishes two pipes (one for standard output and one for standard error) to communicate between the parent and child processes. The function handles process creation, data transfer through pipes, process waiting, and error handling.\n\nInput:\n- nsPath (string): Path to the user namespace to spawn the process in\n- path (string): Path to the file that should be read by the child process\n\nOutput:\n- ([]byte, error): Returns the file contents as a byte slice if successful, or an error if any step fails. The error contains detailed information about the failure.\n\nNote: The function relies on an external C function spawn_userns_cat which handles the actual process creation in the new namespace. The function manages proper resource cleanup through defer statements and handles both successful and error cases with appropriate return values.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/sirupsen/logrus\"\n)\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n//go:generate gcc -o spawn_userns_cat.so -shared -fPIC spawn_userns_cat.c\n// #cgo LDFLAGS: -L. -lspawn_userns_cat\n// #include \"spawn_userns_cat.h\"\nimport \"C\"\n\nfunc spawnUserNamespaceCat(nsPath, path string) ([]byte, error) {\n\tvar outPipe, errPipe [2]int\n\tif errno := syscall.Pipe(outPipe[:]); errno != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stdout pipe: %w\", errno)\n\t}\n\tif errno := syscall.Pipe(errPipe[:]); errno != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create stderr pipe: %w\", errno)\n\t}\n\n\tnsPathC := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(nsPathC))\n\tpathC := C.CString(path)\n\tdefer C.free(unsafe.Pointer(pathC))\n\n\tcOutRead := C.int(outPipe[0])\n\tcOutWrite := C.int(outPipe[1])\n\tcErrRead := C.int(errPipe[0])\n\tcErrWrite := C.int(errPipe[1])\n\n\tpid, errno := C.spawn_userns_cat(\n\t\tnsPathC,\n\t\tpathC,\n\t\tcOutRead,\n\t\tcOutWrite,\n\t\tcErrRead,\n\t\tcErrWrite,\n\t)\n\tif errno != 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn userns cat process: %v\", syscall.Errno(errno))\n\t}\n\n\tsyscall.Close(outPipe[1])\n\tsyscall.Close(errPipe[1])\n\n\tdefer func() {\n\t\tsyscall.Wait4(int(pid), nil, 0, nil)\n\t\tsyscall.Close(outPipe[0])\n\t\tsyscall.Close(errPipe[0])\n\t}()\n\n\tvar outBuf, errBuf bytes.Buffer\n\tgo io.Copy(&outBuf, os.NewFile(uintptr(outPipe[0]), \"pipe-out\"))\n\tgo io.Copy(&errBuf, os.NewFile(uintptr(errPipe[0]), \"pipe-err\"))\n\n\tws, err := syscall.Wait4(int(pid), nil, 0, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error waiting for child process: %w\", err)\n\t}\n\tif !ws.Exited() || ws.ExitStatus() != 0 {\n\t\treturn nil, fmt.Errorf(\"child process failed: %s\", errBuf.String())\n\t}\n\n\treturn outBuf.Bytes(), nil\n}"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a child process using Go's pipe mechanism. The handler should start the child process, monitor its initialization status through the pipe, and handle potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct encapsulates a child process command and provides methods to manage its execution and IPC communication.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as a child process.\n\nMethods:\nStart: Start() -> error - Initializes the child process, establishes a pipe for communication, monitors the child's initialization status, and returns any errors encountered during startup or a timeout if the child process fails to initialize within the specified duration.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tstdout, err := p.cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get stdout pipe: %w\", err)\n\t}\n\tstderr, err := p.cmd.StderrPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get stderr pipe: %w\", err)\n\t}\n\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"failed to start command: %w\", err)\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tstatusChan := make(chan error, 1)\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\treader := bufio.NewReader(stdout)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tline, err := reader.ReadString('\\n')\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err != io.EOF {\n\t\t\t\t\t\tstatusChan <- fmt.Errorf(\"stdout read error: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif line == \"INITIALIZED\\n\" {\n\t\t\t\t\tstatusChan <- nil\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\treader := bufio.NewReader(stderr)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\t_, err := reader.ReadString('\\n')\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(statusChan)\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tp.cmd.Process.Kill()\n\t\treturn errors.New(\"timeout waiting for child process initialization\")\n\tcase err := <-statusChan:\n\t\tif err != nil {\n\t\t\tp.cmd.Process.Kill()\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Go function that securely copies a password to the system clipboard using osascript (AppleScript) via a pipe, ensuring the password is handled safely and the clipboard is cleared after use.\n\nFunction Description: The function `copyViaOsascript` uses an inter-process communication mechanism (pipe) to securely pass a password to the AppleScript command `osascript`, which then sets the password in the system clipboard. The function ensures proper resource cleanup and checks for successful execution.\n\nInput:\n- `ctx context.Context`: Context for managing the command's lifecycle and cancellation.\n- `password string`: The password string to be copied to the clipboard.\n\nOutput:\n- `error`: Returns an error if any step fails (pipe creation, command execution, or clipboard setting). Returns nil on success.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\targs := []string{\n\t\t\"-e\", `use framework \"Foundation\"`,\n\t\t\"-e\", \"use scripting additions\",\n\t\t\"-e\", \"set type to current application's NSPasteboardTypeString\",\n\t\t\"-e\", \"set pb to current application's NSPasteboard's generalPasteboard()\",\n\t\t\"-e\", \"pb's clearContents()\",\n\t\t\"-e\", `pb's setString:\"\" forType:\"org.nspasteboard.ConcealedType\"`,\n\t\t\"-e\", `pb's setString:(do shell script \"cat 0<&3\") forType:type`,\n\t}\n\tcmd := exec.CommandContext(ctx, \"osascript\", args...)\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.ExtraFiles = []*os.File{r}\n\tgo func() {\n\t\tdefer w.Close()\n\t\t_, _ = io.WriteString(w, password)\n\t}()\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(out) != \"true\\n\" {\n\t\treturn fmt.Errorf(\"osascript failed to set password: %s\", string(out))\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\tcmd := exec.CommandContext(ctx, \"osascript\", \"-e\", \"on run {input}\")\n\tstdin, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tstdin.Close()\n\t\tcmd.Wait()\n\t}()\n\n\t_, err = io.WriteString(stdin, password)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cmd.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Go struct that manages a proxy command process with inter-process communication capabilities using pipes for error handling and status reporting.\n\nStruct Description: The proxyCommand struct represents a proxy process manager that uses os.Pipe for IPC to monitor the startup status of a userland proxy. It handles process execution, pipe communication, and timeout management.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as the proxy process\n\nMethods:\nStart: () -> error - Starts the proxy command and monitors its initialization status through a pipe. Returns nil if successful or an error if the proxy fails to start or times out. Uses a pipe to communicate startup status from the child process and implements a 16-second timeout.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tstdout, err := p.cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tstderr, err := p.cmd.StderrPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\ttype result struct {\n\t\terr error\n\t}\n\n\tresultChan := make(chan result, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 1)\n\t\t_, err := io.ReadFull(stdout, buf)\n\t\tif err != nil {\n\t\t\tresultChan <- result{err: err}\n\t\t\treturn\n\t\t}\n\t\tresultChan <- result{err: nil}\n\t}()\n\n\tselect {\n\tcase res := <-resultChan:\n\t\tif res.err != nil {\n\t\t\tp.cmd.Process.Kill()\n\t\t\treturn res.err\n\t\t}\n\tcase <-time.After(16 * time.Second):\n\t\tp.cmd.Process.Kill()\n\t\treturn errors.New(\"proxy command timed out during startup\")\n\t}\n\n\tgo func() {\n\t\tio.Copy(os.Stdout, stdout)\n\t\tio.Copy(os.Stderr, stderr)\n\t}()\n\n\treturn nil\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Go struct that represents a basic HTTP server capable of serving static files from a specified directory, with fallback to a default page when files are not found.\n\nStruct Description: The Site struct represents a simple HTTP server that serves static files from a \"./site\" directory. It handles file requests and falls back to serving \"index.html\" when the requested file is not found.\n\nFields: (This struct has no explicit fields as it's used purely for organizing HTTP server functionality)\n\nMethods:\n\nMethod1: New() -> *Site - A constructor function that creates and returns a new instance of the Site struct.\n\nMethod2: Run() - Starts the HTTP server on the port specified in the configuration. It sets up a file server handler with custom 404 behavior and begins listening for requests.\n\nMethod3: notFound(http.ResponseWriter, *http.Request) - A helper function that serves the \"./site/index.html\" file when a requested resource is not found. Takes standard HTTP handler parameters and returns nothing.\n\nMethod4: server(http.FileSystem) -> http.Handler - A helper function that creates a custom file server handler with fallback behavior. Takes a filesystem interface and returns an HTTP handler.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\ntype Site struct {\n}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\tdata, _ := ioutil.ReadFile(\"./site/index.html\")\n\t_, _ = fmt.Fprintf(w, string(data))\n\treturn\n}\n\nfunc server(fs http.FileSystem) http.Handler {\n\tfileServer := http.FileServer(fs)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfilePath := path.Clean(\"./site\" + r.URL.Path)\n\t\t_, err := os.Stat(filePath)\n\t\tif err != nil {\n\t\t\tnotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfileServer.ServeHTTP(w, r)\n\t})\n}\n\nfunc (s *Site) Run() {\n\tport := config.Conf.Site.SiteBase.ListenPort\n\taddr := fmt.Sprintf(\":%d\", port)\n\thttp.ListenAndServe(addr, server(http.Dir(\"./site\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype Site struct{}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc (s *Site) Run(port int) {\n\tfs := http.Dir(\"./site\")\n\tfileServer := s.server(fs)\n\taddr := fmt.Sprintf(\":%d\", port)\n\thttp.ListenAndServe(addr, fileServer)\n}\n\nfunc (s *Site) notFound(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, \"./site/index.html\")\n}\n\nfunc (s *Site) server(fs http.FileSystem) http.Handler {\n\tfsh := http.FileServer(fs)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := fs.Open(r.URL.Path)\n\t\tif os.IsNotExist(err) {\n\t\t\ts.notFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfsh.ServeHTTP(w, r)\n\t})\n}"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawns a child process (via CGO) that runs in a new user namespace, reads the specified file, and returns its contents. It uses two pipes for IPC - one for standard output and another for standard error. The function handles process creation, pipe management, error handling, and cleanup of resources.\n\nInput:\n- nsPath (string): Path to the user namespace configuration\n- path (string): Path to the file to be read\n\nOutput:\n- ([]byte, error): Returns the file contents as bytes if successful, or an error if any step fails (pipe creation, process spawning, reading output, or process execution)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\n\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n/*\n#cgo CFLAGS: -Wall -Wextra -Werror\n#include <sched.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n\nextern int childFunc(void *arg);\n\nint createChildProcess(int pipeOutFd, int pipeErrFd, const char *filePath) {\n    // Prepare arguments for clone()\n    void* stack = NULL;\n    size_t stackSize = 1024 * 1024; // 1MB stack\n    stack = malloc(stackSize);\n    if (stack == NULL) {\n        return -ENOMEM;\n    }\n\n    // Fork the child process using clone with new user namespace\n    pid_t pid = clone(childFunc, stack + stackSize, CLONE_NEWUSER | SIGCHLD, filePath);\n    free(stack);\n    if (pid == -1) {\n        return -errno;\n    }\n\n    // Close child ends of the pipes\n    close(pipeOutFd);\n    close(pipeErrFd);\n\n    // Wait for child to finish\n    int status;\n    if (waitpid(pid, &status, 0) == -1) {\n        return -errno;\n    }\n\n    if (!WIFEXITED(status)) {\n        return -ECHILD;\n    }\n\n    return WEXITSTATUS(status);\n}\n*/\nimport \"C\"\n\n// readInUserNamespace spawns a process in a new user namespace and reads the file contents.\nfunc readInUserNamespace(nsPath, path string) ([]byte, error) {\n\t// Create two pipes for stdout and stderr\n\toutPipe, errPipe := [2]int{}, [2]int{}\n\tif errno := C.pipe((*C.int)(&outPipe)); errno != 0 {\n\t\treturn nil, fmt.Errorf(\"failed to create stdout pipe: %v\", errno)\n\t}\n\tdefer func() {\n\t\tC.close(C.int(outPipe[0]))\n\t\tC.close(C.int(outPipe[1]))\n\t}()\n\n\tif errno := C.pipe((*C.int)(&errPipe)); errno != 0 {\n\t\treturn nil, fmt.Errorf(\"failed to create stderr pipe: %v\", errno)\n\t}\n\tdefer func() {\n\t\tC.close(C.int(errPipe[0]))\n\t\tC.close(C.int(errPipe[1]))\n\t}()\n\n\t// Convert Go string to C string\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\t// Spawn child process\n\tretCode := C.createChildProcess(C.int(outPipe[1]), C.int(errPipe[1]), cPath)\n\tif retCode != 0 {\n\t\terrMsg := fmt.Sprintf(\"child process failed with code %d\", retCode)\n\t\t// Try reading stderr\n\t\tstderr, _ := io.ReadAll(os.NewFile(uintptr(errPipe[0]), \"stderr\"))\n\t\tif len(stderr) > 0 {\n\t\t\terrMsg += \": \" + string(stderr)\n\t\t}\n\t\treturn nil, fmt.Errorf(errMsg)\n\t}\n\n\t// Read stdout from pipe\n\treturn io.ReadAll(os.NewFile(uintptr(outPipe[0]), \"stdout\"))\n}\n\n//export childFunc\nfunc childFunc(arg unsafe.Pointer) C.int {\n\tfilePath := C.GoString((*C.char)(arg))\n\n\t// Redirect stdout and stderr to the pipes\n\tif C.dup2(C.int(outPipe[1]), C.int(1)) == -1 {\n\t\tmsg := C.strerror(C.errno)\n\t\tC.write(C.int(errPipe[1]), unsafe.Pointer(msg), C.strlen(msg))\n\t\treturn 1\n\t}\n\tif C.dup2(C.int(errPipe[1]), C.int(2)) == -1 {\n\t\tmsg := C.strerror(C.errno)\n\t\tC.write(C.int(errPipe[1]), unsafe.Pointer(msg), C.strlen(msg))\n\t\treturn 1\n\t}\n\n\t// Close all pipe ends in child\n\tC.close(C.int(outPipe[0]))\n\tC.close(C.int(outPipe[1]))\n\tC.close(C.int(errPipe[0]))\n\tC.close(C.int(errPipe[1]))\n\n\t// Open and read the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tmsg := C.CString(err.Error())\n\t\tdefer C.free(unsafe.Pointer(msg))\n\t\tC.write(C.int(2), unsafe.Pointer(msg), C.strlen(msg))\n\t\treturn 1\n\t}\n\tdefer file.Close()\n\n\tcontent, err := io.ReadAll(file)\n\tif err != nil {\n\t\tmsg := C.CString(err.Error())\n\t\tdefer C.free(unsafe.Pointer(msg))\n\t\tC.write(C.int(2), unsafe.Pointer(msg), C.strlen(msg))\n\t\treturn 1\n\t}\n\n\tos.Stdout.Write(content)\n\treturn 0\n}"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a userland proxy using Go's pipe mechanism. The handler starts the proxy process, monitors its initialization status, and handles potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct manages the lifecycle of a userland proxy process, including process execution, IPC communication via pipes, and status monitoring.\n\nFields:\n- cmd: *exec.Cmd - The command object representing the proxy process to be executed.\n- ExtraFiles: []*os.File - Additional file descriptors to be passed to the child process (contains the pipe writer).\n\nMethods:\n- Start() -> error - Initializes the proxy process, establishes IPC via pipe, monitors startup status, and returns any errors encountered during execution or timeout. The method creates a pipe, passes the writer to the child process, reads the initialization status from the pipe reader, and handles errors or timeouts.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd       *exec.Cmd\n\tExtraFiles []*os.File\n}\n\nfunc (p *proxyCommand) Start() error {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create pipe: %w\", err)\n\t}\n\tp.ExtraFiles = append(p.ExtraFiles, writer)\n\n\tp.cmd.ExtraFiles = p.ExtraFiles\n\n\tif err := p.cmd.Start(); err != nil {\n\t\treader.Close()\n\t\twriter.Close()\n\t\treturn fmt.Errorf(\"failed to start command: %w\", err)\n\t}\n\n\twriter.Close()\n\n\tstatusChan := make(chan error, 1)\n\tgo func() {\n\t\tdefer reader.Close()\n\t\tscanner := bufio.NewScanner(reader)\n\t\tfor scanner.Scan() {\n\t\t\tline := scanner.Text()\n\t\t\tif line == \"INITIALIZED\" {\n\t\t\t\tstatusChan <- nil\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif err := scanner.Err(); err != nil && err != io.EOF {\n\t\t\tstatusChan <- fmt.Errorf(\"scanner error: %w\", err)\n\t\t} else {\n\t\t\tstatusChan <- fmt.Errorf(\"proxy exited without initialization\")\n\t\t}\n\t}()\n\n\tselect {\n\tcase err := <-statusChan:\n\t\tif err != nil {\n\t\t\tp.cmd.Process.Kill()\n\t\t\treturn fmt.Errorf(\"proxy initialization failed: %w\", err)\n\t\t}\n\t\treturn nil\n\tcase <-time.After(5 * time.Second):\n\t\tp.cmd.Process.Kill()\n\t\treturn fmt.Errorf(\"proxy initialization timed out\")\n\t}\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Go struct that implements a log retrieval mechanism using pipes for inter-process communication, allowing for reading logs from a file and writing them to a pipe for consumption by another process.\n\nStruct Description: The `logRetriever` struct provides a way to read logs from a file and write them to a pipe, implementing `io.ReadCloser` for standard read and close operations. It also includes methods to manage the pipe's writer and output.\n\nFields:\n- reader: *os.File - The read end of the pipe used to consume log data.\n- writer: *os.File - The write end of the pipe used to send log data.\n- output: *fileCloner - A helper component that clones the writer's output to a log file.\n\nMethods:\n- newlogRetriever: (logFile string) -> (*logRetriever, error) - Initializes a new logRetriever instance, creates a pipe, and sets up file cloning. If the log file exists, copies its contents to the pipe.\n- Read: (p []byte) -> (int, error) - Implements io.Reader to read data from the pipe's reader.\n- CloseWriter: () -> error - Closes the pipe's writer to signal the end of data transmission.\n- Close: () -> error - Implements io.Closer to close the pipe's reader and release resources.\n- Opt: () -> cio.Opt - Returns an option for configuring IO streams, using a null reader and the output cloner.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (l *logRetriever, err error) {\n\tl = &logRetriever{}\n\tif l.reader, l.writer, err = os.Pipe(); err != nil {\n\t\treturn\n\t}\n\n\tif l.output, err = newFileCloner(l.writer, logFile); err != nil {\n\t\treturn\n\t}\n\n\tif util.FileExists(logFile) {\n\t\tvar reader io.ReadCloser\n\t\tif reader, err = os.Open(logFile); err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer util.DeferErr(&err, reader.Close)\n\n\t\tif _, err = io.Copy(l.writer, reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nvar _ io.ReadCloser = &logRetriever{}\n\nfunc (l *logRetriever) Opt() cio.Opt {\n\treturn cio.WithStreams(&nullReader{}, l.output, l.output)\n}\n\nfunc (l *logRetriever) Read(p []byte) (n int, err error) {\n\treturn l.reader.Read(p)\n}\n\nfunc (l *logRetriever) CloseWriter() (err error) {\n\treturn l.writer.Close()\n}\n\nfunc (l *logRetriever) Close() error {\n\treturn l.reader.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype fileCloner struct {\n\twriter *os.File\n}\n\nfunc (fc *fileCloner) Write(p []byte) (int, error) {\n\treturn fc.writer.Write(p)\n}\n\ntype logRetriever struct {\n\treader  *os.File\n\twriter  *os.File\n\toutput  *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (*logRetriever, error) {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfc := &fileCloner{writer: w}\n\n\tlr := &logRetriever{\n\t\treader: r,\n\t\twriter: w,\n\t\toutput: fc,\n\t}\n\n\tfile, err := os.Open(logFile)\n\tif err == nil {\n\t\t_, err = io.Copy(w, file)\n\t\tfile.Close()\n\t\tif err != nil {\n\t\t\tlr.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn lr, nil\n}\n\nfunc (lr *logRetriever) Read(p []byte) (int, error) {\n\treturn lr.reader.Read(p)\n}\n\nfunc (lr *logRetriever) CloseWriter() error {\n\treturn lr.writer.Close()\n}\n\nfunc (lr *logRetriever) Close() error {\n\terr1 := lr.reader.Close()\n\terr2 := lr.writer.Close()\n\tif err1 != nil {\n\t\treturn err1\n\t}\n\treturn err2\n}\n\ntype Opt func(*IOStreams)\n\nfunc (lr *logRetriever) Opt() Opt {\n\treturn func(io *IOStreams) {\n\t\tio.In = nil\n\t\tio.Out = lr.output\n\t}\n}\n\ntype IOStreams struct {\n\tIn  io.Reader\n\tOut io.Writer\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It maintains client state, base URLs, user agent, rate limits, and provides access to various API services. The struct includes methods for creating new requests and executing them.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe access to rate limits\nrateLimits: [categories]Rate - Rate limit tracking for different API categories\ncommon: service - Shared service instance used by all API services\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support, rate limiting, and response handling",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\ntype Rate struct {\n\tLimit  int\n\tWindow time.Duration\n}\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL    *url.URL\n\tUploadURL  *url.URL\n\tUserAgent  string\n\trateMu     sync.Mutex\n\trateLimits map[string]Rate\n\n\tcommon service\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tProxy: nil,\n\t\t\t\tDialContext: (&net.Dialer{\n\t\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t\t}).DialContext,\n\t\t\t\tMaxIdleConnsPerHost:   512,\n\t\t\t\tIdleConnTimeout:       90 * time.Second,\n\t\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t\t},\n\t\t\tTimeout: 60 * time.Second,\n\t\t}\n\t}\n\n\tbaseURL, _ := url.Parse(\"https://api.example.com/\")\n\tuploadURL, _ := url.Parse(\"https://uploads.example.com/\")\n\n\tc := &Client{\n\t\tclient:     httpClient,\n\t\tBaseURL:    baseURL,\n\t\tUploadURL:  uploadURL,\n\t\tUserAgent:  \"ExampleAPI-GoClient/1.0\",\n\t\trateLimits: make(map[string]Rate),\n\t}\n\n\tc.common.client = c\n\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\trel, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu := c.BaseURL.ResolveReference(rel)\n\n\tvar reqBody io.Reader\n\tif body != nil {\n\t\tswitch v := body.(type) {\n\t\tcase string:\n\t\t\treqBody = strings.NewReader(v)\n\t\tcase []byte:\n\t\t\treqBody = bytes.NewBuffer(v)\n\t\tdefault:\n\t\t\tj, err := json.Marshal(body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treqBody = bytes.NewBuffer(j)\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), reqBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\treturn req, nil\n}\n\ntype Response struct {\n\t*http.Response\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tc.rateMu.Lock()\n\tlimiter, exists := c.rateLimits[\"default\"]\n\tif !exists {\n\t\tlimiter = Rate{Limit: 100, Window: time.Minute}\n\t\tc.rateLimits[\"default\"] = limiter\n\t}\n\tc.rateMu.Unlock()\n\n\tif limiter.Window > 0 && limiter.Limit > 0 {\n\t\tlim := rate.NewLimiter(rate.Every(limiter.Window), limiter.Limit)\n\t\tif err := lim.Wait(ctx); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"rate limit wait failed: %w\", err)\n\t\t}\n\t}\n\n\tresp, err := c.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tresponse := &Response{resp}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn response, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\t_, err = io.Copy(w, resp.Body)\n\t\t} else {\n\t\t\terr = json.NewDecoder(resp.Body).Decode(v)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn response, fmt.Errorf(\"response decoding failed: %w\", err)\n\t\t}\n\t}\n\n\treturn response, nil\n}\n\ntype service struct {\n\tclient *Client\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Go struct that represents a financial chart for trading visualization, with capabilities to serve HTTP endpoints for health checks, trading data, and trading history. The struct should maintain candle data, orders, and wallet information, and provide methods to serve this data via HTTP endpoints.\n\nStruct Description: The Chart struct represents a financial trading chart with HTTP server capabilities. It maintains candle data, order information, and paper wallet details, and provides methods to serve this data through HTTP endpoints (/health, /data, /history). The struct uses synchronization to handle concurrent access and provides real-time trading visualization data.\n\nFields:\n\nport: int - The port number on which the HTTP server will listen\ncandles: map[string][]Candle - Stores candle data grouped by trading pairs\ndataframe: map[string]*model.Dataframe - Stores dataframe information for each trading pair\nordersIDsByPair: map[string]*set.LinkedHashSetINT64 - Maintains order IDs organized by trading pairs\norderByID: map[int64]model.Order - Maps order IDs to their corresponding order details\npaperWallet: *exchange.PaperWallet - Pointer to the paper trading wallet information\nlastUpdate: time.Time - Timestamp of the last data update\nMutex: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n\nhandleHealth: (w http.ResponseWriter, _ *http.Request) -> None - Handles health check requests, returning service status based on last update time\nhandleData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading data (candles, asset values, equity values) for a specific trading pair in JSON format\nhandleTradingHistoryData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading history data for a specific pair in CSV format\nStart: () -> error - Starts the HTTP server and registers all endpoint handlers",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/rodrigo-brito/ninjabot/exchange\"\n\t\"github.com/rodrigo-brito/ninjabot/model\"\n\t\"github.com/StudioSol/set\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\ntype Chart struct {\n\tsync.Mutex\n\tport            int\n\tcandles         map[string][]Candle\n\tdataframe       map[string]*model.Dataframe\n\tordersIDsByPair map[string]*set.LinkedHashSetINT64\n\torderByID       map[int64]model.Order\n\tpaperWallet     *exchange.PaperWallet\n\tlastUpdate      time.Time\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, _ *http.Request) {\n\tif time.Since(c.lastUpdate) > time.Hour+10*time.Minute {\n\t\t_, err := w.Write([]byte(c.lastUpdate.String()))\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/json\")\n\n\tvar maxDrawdown *drawdown\n\tif c.paperWallet != nil {\n\t\tvalue, start, end := c.paperWallet.MaxDrawdown()\n\t\tmaxDrawdown = &drawdown{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t\tValue: fmt.Sprintf(\"%.1f\", value*100),\n\t\t}\n\t}\n\n\tasset, quote := exchange.SplitAssetQuote(pair)\n\tassetValues, equityValues := c.equityValuesByPair(pair)\n\terr := json.NewEncoder(w).Encode(map[string]interface{}{\n\t\t\"candles\":       c.candlesByPair(pair),\n\t\t\"asset_values\":  assetValues,\n\t\t\"equity_values\": equityValues,\n\t\t\"quote\":         quote,\n\t\t\"asset\":         asset,\n\t\t\"max_drawdown\":  maxDrawdown,\n\t})\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/csv\")\n\tw.Header().Set(\"Content-Disposition\", \"attachment;filename=history_\"+pair+\".csv\")\n\tw.Header().Set(\"Transfer-Encoding\", \"chunked\")\n\n\torders := c.orderStringByPair(pair)\n\n\tbuffer := bytes.NewBuffer(nil)\n\tcsvWriter := csv.NewWriter(buffer)\n\terr := csvWriter.Write([]string{\"created_at\", \"status\", \"side\", \"id\", \"type\", \"quantity\", \"price\", \"total\", \"profit\"})\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing header file: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = csvWriter.WriteAll(orders)\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing data: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tcsvWriter.Flush()\n\n\tw.WriteHeader(http.StatusOK)\n\t_, err = w.Write(buffer.Bytes())\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing response: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n}\n\nfunc (c *Chart) Start() error {\n\thttp.HandleFunc(\"/health\", c.handleHealth)\n\thttp.HandleFunc(\"/history\", c.handleTradingHistoryData)\n\thttp.HandleFunc(\"/data\", c.handleData)\n\n\tfmt.Printf(\"Chart available at http://localhost:%d\\n\", c.port)\n\treturn http.ListenAndServe(fmt.Sprintf(\":%d\", c.port), nil)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Candle struct {\n\tTime   time.Time `json:\"time\"`\n\tOpen   float64   `json:\"open\"`\n\tHigh   float64   `json:\"high\"`\n\tLow    float64   `json:\"low\"`\n\tClose  float64   `json:\"close\"`\n\tVolume float64   `json:\"volume\"`\n}\n\ntype Chart struct {\n\tport              int\n\tcandles           map[string][]Candle\n\tdataframe         map[string]*model.Dataframe\n\tordersIDsByPair   map[string]*set.LinkedHashSetINT64\n\torderByID         map[int64]model.Order\n\tpaperWallet       *exchange.PaperWallet\n\tlastUpdate        time.Time\n\tMutex             sync.Mutex\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, _ *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\thealth := map[string]string{\n\t\t\"status\": \"healthy\",\n\t\t\"since\":  c.lastUpdate.String(),\n\t}\n\tif time.Since(c.lastUpdate) > 5*time.Minute {\n\t\thealth[\"status\"] = \"stale data\"\n\t}\n\tjson.NewEncoder(w).Encode(health)\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tpair := vars[\"pair\"]\n\n\tc.Mutex.Lock()\n\tcandles, exists := c.candles[pair]\n\tc.Mutex.Unlock()\n\n\tif !exists {\n\t\thttp.Error(w, fmt.Sprintf(\"No data for pair %s\", pair), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tresponse := struct {\n\t\tCandles  []Candle  `json:\"candles\"`\n\t\tAssets   []float64 `json:\"assets\"`\n\t\tEquity   []float64 `json:\"equity\"`\n\t}{}\n\n\tresponse.Candles = candles\n\tif df, ok := c.dataframe[pair]; ok {\n\t\tresponse.Assets = df.Assets\n\t\tresponse.Equity = df.Equity\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tpair := vars[\"pair\"]\n\n\tc.Mutex.Lock()\n\tids, exists := c.ordersIDsByPair[pair]\n\tc.Mutex.Unlock()\n\n\tif !exists {\n\t\thttp.Error(w, fmt.Sprintf(\"No order history for pair %s\", pair), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/csv\")\n\tfmt.Fprintf(w, \"order_id,timestamp,status\\n\")\n\tfor _, id := range ids.ToSlice() {\n\t\tif order, ok := c.orderByID[id]; ok {\n\t\t\tfmt.Fprintf(w, \"%d,%s,%s\\n\", order.ID, order.Timestamp.Format(time.RFC3339), order.Status)\n\t\t}\n\t}\n}\n\nfunc (c *Chart) Start() error {\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/health\", c.handleHealth).Methods(\"GET\")\n\tr.HandleFunc(\"/data/{pair}\", c.handleData).Methods(\"GET\")\n\tr.HandleFunc(\"/history/{pair}\", c.handleTradingHistoryData).Methods(\"GET\")\n\n\taddr := fmt.Sprintf(\":%d\", c.port)\n\treturn http.ListenAndServe(addr, r)\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a simple HTTP server in Go that responds to requests with a greeting message containing the value of the \"AUTHOR\" environment variable.\n\nFunction Description: The main function sets up a basic HTTP server with a single route (\"/\") that responds to all HTTP requests. The response is a plain text message combining \"hello \" with the value of the \"AUTHOR\" environment variable. The server listens on a specified port.\n\nInput: \n- *addr (string pointer): A command-line flag specifying the server address and port to listen on (e.g., \":8080\")\n\nOutput: \n- None (The function runs indefinitely, serving HTTP requests until interrupted)\n- For each HTTP request to \"/\", outputs \"hello [AUTHOR]\" as the response body\n\nNote: The function does not explicitly return any values but writes to the http.ResponseWriter for each incoming request. The server continues running until terminated.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\nfunc main() {\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello \"+os.Getenv(\"AUTHOR\"))\n\t})\n\thttp.ListenAndServe(*addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tauthor := os.Getenv(\"AUTHOR\")\n\t\tfmt.Fprintf(w, \"hello %s\", author)\n\t})\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a Go struct that represents a metric sink for sending metrics to a Cortex metrics server using HTTP with advanced configuration options.\n\nStruct Description: The CortexMetricSink struct is responsible for batching and sending metrics to a Cortex server via HTTP with support for custom headers, basic authentication, proxy configuration, and connection pooling.\n\nFields:\n\nURL: string - The endpoint URL of the Cortex server to send metrics to\nRemoteTimeout: time.Duration - Timeout for HTTP requests to Cortex\nProxyURL: string - URL of the proxy server to use (optional)\nClient: *http.Client - Custom HTTP client for making requests\nlogger: *logrus.Entry - Logger for the sink\nname: string - Name identifier for the sink\ntraceClient: *trace.Client - Tracing client for distributed tracing\naddHeaders: map[string]string - Additional headers to include in requests\nbasicAuth: *BasicAuthType - Basic authentication credentials (optional)\nbatchWriteSize: int - Maximum number of metrics to batch before sending\ncounters: map[counterMapKey]float64 - Internal counter storage\nconvertCountersToMonotonic: bool - Flag to convert counters to monotonic values\nexcludedTags: map[string]struct{} - Tags to exclude from metrics\nhost: string - Host identifier for metrics\n\nMethods:\n\nStart: (tc *trace.Client) -> error - Initializes the sink with tracing and HTTP client configuration\nwriteMetrics: (ctx context.Context, metrics []samplers.InterMetric) -> error - Processes and sends a batch of metrics to Cortex\n\nBasicAuthType Struct Description: Nested struct for storing basic authentication credentials\n\nFields:\n\nUsername: util.StringSecret - Basic auth username (secret type)\nPassword: util.StringSecret - Basic auth password (secret type)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/golang/snappy\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/prometheus/prometheus/prompb\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/veneur/v14/samplers\"\n\t\"github.com/stripe/veneur/v14/sinks\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype CortexMetricSink struct {\n\tURL                        string\n\tRemoteTimeout              time.Duration\n\tProxyURL                   string\n\tClient                     *http.Client\n\tlogger                     *logrus.Entry\n\tname                       string\n\ttraceClient                *trace.Client\n\taddHeaders                 map[string]string\n\tbasicAuth                  *BasicAuthType\n\tbatchWriteSize             int\n\tcounters                   map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags               map[string]struct{}\n\thost                       string\n}\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret `yaml:\"username\"`\n\tPassword util.StringSecret `yaml:\"password\"`\n}\n\nfunc (s *CortexMetricSink) Start(tc *trace.Client) error {\n\ts.logger.Infof(\"Starting sink for %s\", s.URL)\n\tt := http.DefaultTransport.(*http.Transport).Clone()\n\tt.MaxIdleConns = MaxConns\n\tt.MaxConnsPerHost = MaxConns\n\tt.MaxIdleConnsPerHost = MaxConns\n\n\tif len(s.ProxyURL) > 0 {\n\t\tp, err := url.Parse(s.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"malformed cortex_proxy_url\")\n\t\t}\n\t\tt.Proxy = http.ProxyURL(p)\n\t}\n\n\ts.Client = &http.Client{\n\t\tTimeout:   s.RemoteTimeout,\n\t\tTransport: t,\n\t}\n\n\ts.traceClient = tc\n\treturn nil\n}\n\nfunc (s *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\tspan, _ := trace.StartSpanFromContext(ctx, \"\")\n\tdefer span.ClientFinish(s.traceClient)\n\n\twr := s.makeWriteRequest(metrics)\n\n\tdata, err := wr.Marshal()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to marshal proto\\\"\")\n\t}\n\n\tvar buf bytes.Buffer\n\tencoded := snappy.Encode(nil, data)\n\tbuf.Write(encoded)\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", s.URL, &buf)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to create http request\\\"\")\n\t}\n\n\treq.Header.Set(\"Content-Encoding\", \"snappy\")\n\treq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\treq.Header.Set(\"User-Agent\", \"veneur/cortex\")\n\treq.Header.Set(\"X-Prometheus-Remote-Write-Version\", \"0.1.0\")\n\tfor key, value := range s.addHeaders {\n\t\treq.Header.Set(key, value)\n\t}\n\tif s.basicAuth != nil {\n\t\treq.SetBasicAuth(s.basicAuth.Username.Value, s.basicAuth.Password.Value)\n\t}\n\n\tts := time.Now()\n\tr, err := s.Client.Do(req)\n\tif err != nil {\n\t\tspan.Error(err)\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: misc http client error\\\" duration_secs=%.2f\", time.Since(ts).Seconds())\n\t}\n\tdefer r.Body.Close()\n\n\tif r.StatusCode >= 300 {\n\t\tb, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: downstream returned error response with unreadable body\\\" response_code=%d\", r.StatusCode)\n\t\t}\n\t\treturn fmt.Errorf(\"cortex_err=\\\"failed to write batch: error response\\\", response_code=%d response_body=\\\"%s\\\"\", r.StatusCode, b)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package metrics\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/yourorg/yourproject/samplers\"\n\t\"github.com/yourorg/yourproject/util\"\n\t\"github.com/yourorg/yourproject/trace\"\n)\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret\n\tPassword util.StringSecret\n}\n\ntype CortexMetricSink struct {\n\tURL                   string\n\tRemoteTimeout         time.Duration\n\tProxyURL              string\n\tClient                *http.Client\n\tlogger                *logrus.Entry\n\tname                  string\n\ttraceClient           *trace.Client\n\taddHeaders            map[string]string\n\tbasicAuth             *BasicAuthType\n\tbatchWriteSize        int\n\tcounters              map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags          map[string]struct{}\n\thost                  string\n}\n\nfunc (sink *CortexMetricSink) Start(tc *trace.Client) error {\n\t// Implementation here\n\treturn nil\n}\n\nfunc (sink *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\t// Implementation here\n\treturn nil\n}\n\ntype counterMapKey struct {\n\tName string\n\tTags map[string]string\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebSocket connections at the root path (\"/\"). The server should load configuration from a JSON file and start listening on a specified port.\n\nFunction Description: The main function initializes the server by loading configuration, setting up a WebSocket handler at the root path, and starting the HTTP server on the configured port.\n\nInput: None (configuration is loaded from \"config.json\" file)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics if server fails to start)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"golang.org/x/net/websocket\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tConfig = load(\"config.json\")\n\t\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\ts := websocket.Server{Handler: websocket.Handler(wsHandler)}\n\t\ts.ServeHTTP(w, req)\n\t})\n\n\terr := http.ListenAndServe(\":\"+strconv.Itoa(Config.Port), nil)\n\tif err != nil {\n\t\tpanic(\"Error: \" + err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"golang.org/x/net/websocket\"\n)\n\ntype Config struct {\n\tPort string `json:\"port\"`\n}\n\nfunc loadConfig() (*Config, error) {\n\tfile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar config Config\n\terr = json.NewDecoder(file).Decode(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &config, nil\n}\n\nfunc handleWebSocket(ws *websocket.Conn) {\n\tdefer ws.Close()\n\tfor {\n\t\tvar reply string\n\t\terr := websocket.Message.Receive(ws, &reply)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error receiving message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received: %s\", reply)\n\t\terr = websocket.Message.Send(ws, \"Echo: \"+reply)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error sending message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconfig, err := loadConfig()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to load config: %v\", err))\n\t}\n\n\thttp.Handle(\"/\", websocket.Handler(handleWebSocket))\n\n\taddr := \":\" + config.Port\n\tlog.Printf(\"Starting server on %s\", addr)\n\terr = http.ListenAndServe(addr, nil)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to start server: %v\", err))\n\t}\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Implement a function to start an HTTP server with configurable parameters including authentication, TLS, and database integration. The function should handle routing, authentication wrapping, and server startup with both HTTP and HTTPS support.\n\nFunction Description: The `Start` function initializes and starts an HTTP server with various endpoints for database operations. It supports optional authentication via a pre-shared token and can be configured to use TLS for secure connections. The server connects to a tiedot database and provides RESTful endpoints for database operations.\n\nInput:\n- `dir` (string): Directory path for the tiedot database\n- `port` (int): Port number to listen on\n- `tlsCrt` (string): Path to TLS certificate file (empty for HTTP)\n- `tlsKey` (string): Path to TLS private key file (empty for HTTP)\n- `jwtPubKey` (string): JWT public key (unused in reference code)\n- `jwtPrivateKey` (string): JWT private key (unused in reference code)\n- `bind` (string): Network interface to bind to (empty for all interfaces)\n- `authToken` (string): Pre-shared token for authentication (empty to disable)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics on error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/HouzuoGuo/tiedot/db\"\n\t\"github.com/HouzuoGuo/tiedot/tdlog\"\n)\n\nvar (\n\tHttpDB *db.DB\n)\n\nfunc Start(dir string, port int, tlsCrt, tlsKey, jwtPubKey, jwtPrivateKey, bind, authToken string) {\n\tvar err error\n\tHttpDB, err = db.OpenDB(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thttp.HandleFunc(\"/\", Welcome)\n\thttp.HandleFunc(\"/version\", Version)\n\thttp.HandleFunc(\"/memstats\", MemStats)\n\n\tvar authWrap func(http.HandlerFunc) http.HandlerFunc\n\tif authToken != \"\" {\n\t\ttdlog.Noticef(\"API endpoints now require the pre-shared token in Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tif \"token \"+authToken != r.Header.Get(\"Authorization\") {\n\t\t\t\t\thttp.Error(w, \"\", http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\toriginalHandler(w, r)\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"API endpoints do not require Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn originalHandler\n\t\t}\n\t}\n\n\thttp.HandleFunc(\"/create\", authWrap(Create))\n\thttp.HandleFunc(\"/rename\", authWrap(Rename))\n\thttp.HandleFunc(\"/drop\", authWrap(Drop))\n\thttp.HandleFunc(\"/all\", authWrap(All))\n\thttp.HandleFunc(\"/scrub\", authWrap(Scrub))\n\thttp.HandleFunc(\"/sync\", authWrap(Sync))\n\thttp.HandleFunc(\"/query\", authWrap(Query))\n\thttp.HandleFunc(\"/count\", authWrap(Count))\n\thttp.HandleFunc(\"/insert\", authWrap(Insert))\n\thttp.HandleFunc(\"/get\", authWrap(Get))\n\thttp.HandleFunc(\"/getpage\", authWrap(GetPage))\n\thttp.HandleFunc(\"/update\", authWrap(Update))\n\thttp.HandleFunc(\"/delete\", authWrap(Delete))\n\thttp.HandleFunc(\"/approxdoccount\", authWrap(ApproxDocCount))\n\thttp.HandleFunc(\"/index\", authWrap(Index))\n\thttp.HandleFunc(\"/indexes\", authWrap(Indexes))\n\thttp.HandleFunc(\"/unindex\", authWrap(Unindex))\n\thttp.HandleFunc(\"/shutdown\", authWrap(Shutdown))\n\thttp.HandleFunc(\"/dump\", authWrap(Dump))\n\n\tiface := \"all interfaces\"\n\tif bind != \"\" {\n\t\tiface = bind\n\t}\n\n\tif tlsCrt != \"\" {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTPS), port %d.\", iface, port)\n\t\tif err := http.ListenAndServeTLS(fmt.Sprintf(\"%s:%d\", bind, port), tlsCrt, tlsKey, nil); err != nil {\n\t\t\ttdlog.Panicf(\"Failed to start HTTPS service - %s\", err)\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTP), port %d.\", iface, port)\n\t\thttp.ListenAndServe(fmt.Sprintf(\"%s:%d\", bind, port), nil)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/syndtr/goleveldb/leveldb\"\n)\n\nfunc Start(dir string, port int, tlsCrt string, tlsKey string, jwtPubKey string, jwtPrivateKey string, bind string, authToken string) {\n\tif bind == \"\" {\n\t\tbind = \"0.0.0.0\"\n\t}\n\n\taddr := fmt.Sprintf(\"%s:%d\", bind, port)\n\tr := gin.Default()\n\n\tdb, err := leveldb.OpenFile(dir, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\n\tapi := r.Group(\"/api\")\n\tif authToken != \"\" {\n\t\tapi.Use(func(c *gin.Context) {\n\t\t\ttoken := c.GetHeader(\"Authorization\")\n\t\t\tif token != \"Bearer \"+authToken {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"unauthorized\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n\n\tapi.GET(\"/docs/:collection\", func(c *gin.Context) {\n\t\t// Handle GET /docs/:collection\n\t})\n\n\tapi.POST(\"/docs/:collection\", func(c *gin.Context) {\n\t\t// Handle POST /docs/:collection\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: r,\n\t}\n\n\tif tlsCrt == \"\" || tlsKey == \"\" {\n\t\t// HTTP\n\t\tfmt.Printf(\"Starting HTTP server on %s\\n\", addr)\n\t\terr = server.ListenAndServe()\n\t} else {\n\t\t// HTTPS\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = tls.VersionTLS12\n\n\t\tln, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\ttlsListener := tls.NewListener(ln, config)\n\t\tfmt.Printf(\"Starting HTTPS server on %s\\n\", addr)\n\t\terr = server.Serve(tlsListener)\n\t}\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a function that checks the health status of a Kubernetes cluster by making an HTTP GET request to the cluster's livez endpoint using a custom HTTP client with TLS configuration.\n\nFunction Description: The function `GetClusterStatusByAPI` verifies the health of a Kubernetes cluster by sending an HTTPS request to the cluster's `/livez` endpoint. It uses a custom `http.Client` with TLS configuration loaded from the cluster's connection settings. The function returns a boolean indicating the cluster's health status and a string containing any error messages or the response body if the check fails.\n\nInput: \n- `addr` [string]: The address of the Kubernetes cluster API server.\n- `cluster` [*model.Cluster]: A pointer to a cluster object containing connection configuration details.\n\nOutput: \n- [bool]: `true` if the cluster is healthy (HTTP status code 200), `false` otherwise.\n- [string]: An empty string if the cluster is healthy, otherwise an error message or the response body.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/client-go/rest\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\treqURL := fmt.Sprintf(\"https://%s/livez\", addr)\n\tconf, err := clusterUtil.LoadConnConf(cluster, addr)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"load cluster config error %s\", err.Error())\n\t}\n\ttls2, err := rest.TransportFor(conf)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"config transport error %s\", err.Error())\n\t}\n\tclient := &http.Client{Timeout: 1 * time.Second, Transport: tls2}\n\trequest, _ := http.NewRequest(\"GET\", reqURL, nil)\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Https get error %s\", err.Error())\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode == 200 {\n\t\treturn true, \"\"\n\t}\n\ts, _ := ioutil.ReadAll(response.Body)\n\treturn false, fmt.Sprintf(\"Api check error %s\", string(s))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Cluster struct {\n\tCertData       []byte\n\tKeyData        []byte\n\tCAData         []byte\n}\n\nfunc GetClusterStatusByAPI(addr string, cluster *Cluster) (bool, string) {\n\t// Load client cert\n\tcert, err := tls.X509KeyPair(cluster.CertData, cluster.KeyData)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Error loading client certificate: %v\", err)\n\t}\n\n\t// Load CA cert\n\tcaCertPool := x509.NewCertPool()\n\tif !caCertPool.AppendCertsFromPEM(cluster.CAData) {\n\t\treturn false, \"Failed to append CA certificate\"\n\t}\n\n\t// Setup TLS config\n\ttlsConfig := &tls.Config{\n\t\tCertificates:       []tls.Certificate{cert},\n\t\tRootCAs:            caCertPool,\n\t\tInsecureSkipVerify: false,\n\t}\n\n\t// Create custom HTTP client with timeout\n\tclient := &http.Client{\n\t\tTimeout: 10 * time.Second,\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t},\n\t}\n\n\t// Construct URL\n\turl := fmt.Sprintf(\"%s/livez\", addr)\n\n\t// Make GET request\n\tresp, err := client.Get(url)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"HTTP GET error: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read response body\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\n\t// Check status code\n\tif resp.StatusCode == http.StatusOK {\n\t\treturn true, \"\"\n\t}\n\n\treturn false, string(body)\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that serves Prometheus metrics via an HTTP server, updating custom metrics (uptime and packet count) on each request.\n\nFunction Description: The ServeMetricsAt function starts an HTTP server to expose Prometheus metrics. It registers custom metrics (uptime and packet count), updates them on each request to the metrics endpoint, and serves the metrics using the Prometheus HTTP handler. The function runs the server in a goroutine to avoid blocking the main program.\n\nInput:\n- addr (string): The network address (including port) where the metrics server should listen (e.g., \":8080\")\n- c (*collector.Collector): A pointer to a collector instance used to get the current packet count (can be nil)\n\nOutput: None (the function runs indefinitely in a background goroutine)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n\t\"github.com/dreadl0ck/netcap/collector\"\n)\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tprometheus.MustRegister(upTime)\n\tprometheus.MustRegister(numPackets)\n\n\tfmt.Println(\"starting to serve metrics at:\", addr+metricsRoute)\n\n\tgo func() {\n\t\tmetricsHandler := promhttp.Handler()\n\n\t\thttp.HandleFunc(metricsRoute, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupTime.WithLabelValues().Set(math.RoundToEven(time.Since(startTime).Seconds())\n\n\t\t\tif c != nil {\n\t\t\t\tnumPackets.WithLabelValues().Set(float64(c.GetNumPackets()))\n\t\t\t}\n\n\t\t\tmetricsHandler.ServeHTTP(w, r)\n\t\t})\n\t\tlog.Fatal(\"failed to serve metrics: \", http.ListenAndServe(addr, nil))\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\ntype collector struct {\n\tpacketCount int\n\tmu          sync.Mutex\n}\n\nfunc (c *collector) GetPacketCount() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.packetCount\n}\n\nfunc (c *collector) IncrementPacketCount() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.packetCount++\n}\n\nfunc ServeMetricsAt(addr string, c *collector) {\n\tuptime := prometheus.NewDesc(\n\t\t\"my_application_uptime_seconds\",\n\t\t\"Uptime of the application in seconds\",\n\t\tnil, nil,\n\t)\n\tpacketCount := prometheus.NewDesc(\n\t\t\"my_application_packet_count\",\n\t\t\"Total number of packets processed\",\n\t\tnil, nil,\n\t)\n\n\tprometheus.MustRegister(prometheus.NewCollectors(\n\t\tprometheus.CollectorFunc(func(ch chan<- prometheus.Metric) {\n\t\t\tstartTime := time.Now().Unix()\n\n\t\t\tch <- prometheus.MustNewConstMetric(\n\t\t\t\tuptime,\n\t\t\t\tprometheus.GaugeValue,\n\t\t\t\tfloat64(time.Now().Unix()-startTime),\n\t\t\t)\n\n\t\t\tvar count float64 = 0\n\t\t\tif c != nil {\n\t\t\t\tcount = float64(c.GetPacketCount())\n\t\t\t}\n\n\t\t\tch <- prometheus.MustNewConstMetric(\n\t\t\t\tpacketCount,\n\t\t\t\tprometheus.CounterValue,\n\t\t\t\tcount,\n\t\t\t)\n\t\t}),\n\t))\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tgo func() {\n\t\thttp.ListenAndServe(addr, nil)\n\t}()\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a function that performs an HTTP request with custom headers and handles the response, including error handling and logging for debugging purposes.\n\nFunction Description: The function `realRequest` performs an HTTP request with custom headers, handles authentication, and processes the response. It includes validation of required headers, adds security tokens and user agents, computes signatures for authentication, and handles response errors. Debug logging is available for both requests and responses.\n\nInput:\n- `ctx` (context.Context): Context for the request, allowing cancellation and timeouts.\n- `project` (*LogProject): A struct containing project-specific details like base URL, access keys, and user agent.\n- `method` (string): HTTP method (e.g., \"GET\", \"POST\").\n- `uri` (string): The URI path for the request.\n- `headers` (map[string]string): A map of HTTP headers to include in the request.\n- `body` ([]byte): The request body as a byte slice.\n\nOutput:\n- (*http.Response, error): Returns the HTTP response and an error if any occurred during the request or response handling. The error is wrapped in custom error types for better context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"time\"\n\n\t\"github.com/go-kit/kit/log/level\"\n)\n\nvar (\n\tdefaultRequestTimeout = 60 * time.Second\n\tdefaultRetryTimeout   = 90 * time.Second\n\tdefaultHttpClient     = &http.Client{\n\t\tTimeout: defaultRequestTimeout,\n\t}\n)\n\nfunc realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif _, ok := headers[\"x-log-bodyrawsize\"]; !ok {\n\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'x-log-bodyrawsize' header\"))\n\t}\n\n\tbaseURL := project.getBaseURL()\n\theaders[\"Host\"] = baseURL\n\theaders[\"Date\"] = nowRFC1123()\n\theaders[\"x-log-apiversion\"] = version\n\theaders[\"x-log-signaturemethod\"] = signatureMethod\n\tif len(project.UserAgent) > 0 {\n\t\theaders[\"User-Agent\"] = project.UserAgent\n\t} else {\n\t\theaders[\"User-Agent\"] = DefaultLogUserAgent\n\t}\n\n\tif project.SecurityToken != \"\" {\n\t\theaders[\"x-acs-security-token\"] = project.SecurityToken\n\t}\n\n\tif body != nil {\n\t\tbodyMD5 := fmt.Sprintf(\"%X\", md5.Sum(body))\n\t\theaders[\"Content-MD5\"] = bodyMD5\n\t\tif _, ok := headers[\"Content-Type\"]; !ok {\n\t\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'Content-Type' header\"))\n\t\t}\n\t}\n\n\tdigest, err := signature(project.AccessKeySecret, method, uri, headers)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tauth := fmt.Sprintf(\"SLS %v:%v\", project.AccessKeyID, digest)\n\theaders[\"Authorization\"] = auth\n\n\treader := bytes.NewReader(body)\n\turlStr := fmt.Sprintf(\"%s%s\", baseURL, uri)\n\treq, err := http.NewRequest(method, urlStr, reader)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Add(k, v)\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpRequest(req, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Request:\\n%v\", string(dump))\n\t}\n\n\tresp, err := project.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\terr := &Error{}\n\t\terr.HTTPCode = (int32)(resp.StatusCode)\n\t\tdefer resp.Body.Close()\n\t\tbuf, ioErr := ioutil.ReadAll(resp.Body)\n\t\tif ioErr != nil {\n\t\t\treturn nil, NewBadResponseError(ioErr.Error(), resp.Header, resp.StatusCode)\n\t\t}\n\t\tif jErr := json.Unmarshal(buf, err); jErr != nil {\n\t\t\treturn nil, NewBadResponseError(string(buf), resp.Header, resp.StatusCode)\n\t\t}\n\t\terr.RequestID = resp.Header.Get(RequestIDHeader)\n\t\treturn nil, err\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpResponse(resp, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Response:\\n%v\", string(dump))\n\t}\n\treturn resp, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/blake2b\"\n)\n\ntype LogProject struct {\n\tBaseURL    string\n\tAccessKey  string\n\tSecretKey  string\n\tUserAgent  string\n\tEnableDebug bool\n}\n\nvar (\n\tErrMissingHeader = fmt.Errorf(\"required header is missing\")\n\tErrUnauthorized  = fmt.Errorf(\"unauthorized: invalid signature or credentials\")\n\tErrBadRequest    = func(msg string) error { return fmt.Errorf(\"bad request: %s\", msg) }\n)\n\nfunc realRequest(ctx context.Context, project *LogProject, method string, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif project == nil {\n\t\treturn nil, fmt.Errorf(\"project cannot be nil\")\n\t}\n\tif headers == nil {\n\t\theaders = make(map[string]string)\n\t}\n\n\t// Validate required headers\n\trequiredHeaders := []string{\"Content-Type\", \"Accept\"}\n\tfor _, key := range requiredHeaders {\n\t\tif _, ok := headers[key]; !ok {\n\t\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrMissingHeader, key)\n\t\t}\n\t}\n\n\t// Set default User-Agent if not provided\n\tif _, ok := headers[\"User-Agent\"]; !ok {\n\t\theaders[\"User-Agent\"] = project.UserAgent\n\t}\n\n\t// Build URL\n\turl := project.BaseURL + uri\n\n\t// Create request\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Set headers\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\t// Add security token using signed authorization\n\ttimestamp := time.Now().UnixNano() / int64(time.Millisecond)\n\tsignature := computeSignature(project.SecretKey, method, uri, timestamp, body)\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"BLT %s:%d:%s\", project.AccessKey, timestamp, signature))\n\n\t// Debug logging of the request\n\tif project.EnableDebug {\n\t\tlog.Printf(\"Request: %s %s\\nHeaders: %v\\nBody: %s\\n\",\n\t\t\tmethod, url, req.Header, string(body))\n\t}\n\n\t// Send request\n\tclient := &http.Client{}\n\tresp, err := client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n\t}\n\n\t// Debug logging of the response\n\tif project.EnableDebug {\n\t\tdefer resp.Body.Close()\n\t\tbodyBytes, _ := ioutil.ReadAll(resp.Body)\n\t\tlog.Printf(\"Response Status: %s\\nHeaders: %v\\nBody: %s\\n\",\n\t\t\tresp.Status, resp.Header, string(bodyBytes))\n\t\t// Re-read body for further processing\n\t\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))\n\t}\n\n\t// Handle HTTP errors\n\tswitch resp.StatusCode {\n\tcase http.StatusUnauthorized:\n\t\treturn resp, ErrUnauthorized\n\tcase http.StatusBadRequest:\n\t\tdefer resp.Body.Close()\n\t\tbodyBytes, _ := ioutil.ReadAll(resp.Body)\n\t\treturn resp, fmt.Errorf(\"%w: %s\", ErrBadRequest(string(bodyBytes)), string(bodyBytes))\n\tcase http.StatusInternalServerError:\n\t\treturn resp, fmt.Errorf(\"internal server error: %d\", resp.StatusCode)\n\t}\n\n\treturn resp, nil\n}\n\n// computeSignature generates a secure signature for authentication.\nfunc computeSignature(secret, method, uri string, timestamp int64, body []byte) string {\n\thasher, _ := blake2b.New512(nil)\n\thasher.Write([]byte(secret))\n\thasher.Write([]byte(method))\n\thasher.Write([]byte(uri))\n\thasher.Write([]byte(fmt.Sprintf(\"%d\", timestamp)))\n\thasher.Write(body)\n\tsum := hasher.Sum(nil)\n\treturn hex.EncodeToString(sum)\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that starts a debug HTTP server with various endpoints for monitoring and debugging purposes, including standard debug endpoints (pprof, metrics, trace) and custom endpoints.\n\nFunction Description: The function `Start` initializes and launches an HTTP server with multiple debugging and monitoring endpoints. It sets up handlers for standard endpoints like pprof, expvar, trace, and metrics, along with any additional custom endpoints provided. The server runs on a predefined address and serves an index page with links to all available endpoints.\n\nInput: \n- `extra ...Endpoint`: Variadic parameter accepting zero or more custom endpoint objects. Each Endpoint should have:\n  - `Path`: string - The URL path for the endpoint\n  - `Name`: string - Display name for the endpoint\n  - `Handler`: http.Handler - The handler function for the endpoint\n\nOutput: None (the function runs indefinitely serving HTTP requests, or returns if no address is configured)\n\nNote: The function uses package-level variables (not shown in the reference code) including `addr` for the server address, and assumes the existence of handler functions like `expvarHandler`, `gcHandler`, and `freeOSMemoryHandler`.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"strings\"\n\n\t\"golang.org/x/net/trace\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc Start(extra ...Endpoint) {\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tpp := http.NewServeMux()\n\tindex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(`\n\t\t\t\t<a href=\"vars\">Vars</a><br>\n\t\t\t\t<a href=\"debug/pprof/\">PProf</a><br>\n\t\t\t\t<a href=\"metrics\">Metrics</a><br>\n\t\t\t\t<a href=\"debug/requests\">Requests</a><br>\n\t\t\t\t<a href=\"debug/events\">Events</a><br>\n\t\t\t`))\n\t\tfor _, e := range extra {\n\t\t\tfmt.Fprintf(w, `<a href=\"%s\">%s</a><br>`, strings.TrimPrefix(e.Path, \"/\"), e.Name)\n\t\t}\n\t\tw.Write([]byte(`\n\t\t\t\t<br>\n\t\t\t\t<form method=\"post\" action=\"gc\" style=\"display: inline;\"><input type=\"submit\" value=\"GC\"></form>\n\t\t\t\t<form method=\"post\" action=\"freeosmemory\" style=\"display: inline;\"><input type=\"submit\" value=\"Free OS Memory\"></form>\n\t\t\t`))\n\t})\n\tpp.Handle(\"/\", index)\n\tpp.Handle(\"/debug\", index)\n\tpp.Handle(\"/vars\", http.HandlerFunc(expvarHandler))\n\tpp.Handle(\"/gc\", http.HandlerFunc(gcHandler))\n\tpp.Handle(\"/freeosmemory\", http.HandlerFunc(freeOSMemoryHandler))\n\tpp.Handle(\"/debug/pprof/\", http.HandlerFunc(pprof.Index))\n\tpp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\tpp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\tpp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\tpp.Handle(\"/debug/pprof/trace\", http.HandlerFunc(pprof.Trace))\n\tpp.Handle(\"/debug/requests\", http.HandlerFunc(trace.Traces))\n\tpp.Handle(\"/debug/events\", http.HandlerFunc(trace.Events))\n\tpp.Handle(\"/metrics\", promhttp.Handler())\n\tfor _, e := range extra {\n\t\tpp.Handle(e.Path, e.Handler)\n\t}\n\tlog.Println(\"warning: could not start debug HTTP server:\", http.ListenAndServe(addr, pp))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package debugserver\n\nimport (\n\t\"expvar\"\n\t\"fmt\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n)\n\ntype Endpoint struct {\n\tPath    string\n\tName    string\n\tHandler http.Handler\n}\n\nvar addr string\n\nfunc Start(extra ...Endpoint) {\n\tmux := http.NewServeMux()\n\n\tendpoints := []Endpoint{\n\t\t{\"/debug/vars\", \"expvar\", http.HandlerFunc(expvarHandler)},\n\t\t{\"/debug/pprof/\", \"pprof\", http.HandlerFunc(pprof.Index)},\n\t\t{\"/debug/pprof/cmdline\", \"cmdline\", http.HandlerFunc(pprof.Cmdline)},\n\t\t{\"/debug/pprof/profile\", \"profile\", http.HandlerFunc(pprof.Profile)},\n\t\t{\"/debug/pprof/symbol\", \"symbol\", http.HandlerFunc(pprof.Symbol)},\n\t\t{\"/debug/pprof/trace\", \"trace\", http.HandlerFunc(pprof.Trace)},\n\t\t{\"/debug/gc\", \"GC\", http.HandlerFunc(gcHandler)},\n\t\t{\"/debug/freeosmemory\", \"FreeOSMemory\", http.HandlerFunc(freeOSMemoryHandler)},\n\t}\n\n\tfor _, ep := range append(endpoints, extra...) {\n\t\tmux.Handle(ep.Path, ep.Handler)\n\t}\n\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"<html><body><h1>Debug Endpoints</h1><ul>\")\n\t\tfor _, ep := range mux.(*http.ServeMux).HandlersRouted() {\n\t\t\tfmt.Fprintf(w, \"<li><a href=\\\"%s\\\">%s</a></li>\", ep.Pattern, ep.Handler)\n\t\t}\n\t\tfmt.Fprintf(w, \"</ul></body></html>\")\n\t})\n\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\thttp.ListenAndServe(addr, mux)\n}\n\nfunc (mux *http.ServeMux) HandlersRouted() []struct{ Pattern string; Handler string } {\n\t// This is a placeholder to simulate getting registered routes.\n\t// Actual implementation would require reflection or tracking during registration.\n\treturn nil\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server with instrumented handlers for metrics collection using Prometheus. The function should register routes for metrics and a custom endpoint, apply middleware for context handling, and instrument handlers with counters and histograms.\n\nFunction Description: The function ExampleInstrumentHandlerWithLabelResolver demonstrates how to create an HTTP server with Prometheus instrumentation. It sets up counter and histogram metrics, creates handlers for specific routes, applies middleware to extract headers into context, and starts the server on port 3000. The function doesn't take any explicit parameters but relies on package-level configurations.\n\nInput: None (uses package-level constants and variables)\n\nOutput: None (starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\tcounter := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"api_requests_total\",\n\t\t\tHelp: \"A counter for requests to the wrapped handler.\",\n\t\t},\n\t\t[]string{\"code\", \"method\", \"myheader\"},\n\t)\n\n\tduration := prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"request_duration_seconds\",\n\t\t\tHelp:    \"A histogram of latencies for requests.\",\n\t\t\tBuckets: []float64{.25, .5, 1, 2.5, 5, 10},\n\t\t},\n\t\t[]string{\"handler\", \"method\", \"myheader\"},\n\t)\n\n\tpullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Pull\"))\n\t})\n\n\topts := WithLabelFromCtx(\"myheader\",\n\t\tfunc(ctx context.Context) string {\n\t\t\treturn ctx.Value(CtxResolverKey).(string)\n\t\t},\n\t)\n\n\tpullChain := InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"pull\"}),\n\t\tInstrumentHandlerCounter(counter, pullHandler, opts),\n\t\topts,\n\t)\n\n\tmiddleware := func(next http.HandlerFunc) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), CtxResolverKey, r.Header.Get(\"x-my-header\"))\n\n\t\t\tnext(w, r.WithContext(ctx))\n\t\t}\n\t}\n\n\thttp.Handle(\"/metrics\", Handler())\n\thttp.Handle(\"/pull\", middleware(pullChain))\n\n\tif err := http.ListenAndServe(\":3000\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n\thttpRequestsCounter = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"http_requests_total\",\n\t\t\tHelp: \"Total number of HTTP requests.\",\n\t\t},\n\t\t[]string{\"handler\", \"method\", \"status\"},\n\t)\n\n\thttpRequestLatency = prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_latency_seconds\",\n\t\t\tHelp:    \"Latency of HTTP requests.\",\n\t\t\tBuckets: prometheus.DefBuckets,\n\t\t},\n\t\t[]string{\"handler\"},\n\t)\n)\n\nfunc init() {\n\tprometheus.MustRegister(httpRequestsCounter)\n\tprometheus.MustRegister(httpRequestLatency)\n}\n\nfunc withLabelResolver(next http.HandlerFunc, handlerName string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\n\t\tctx := context.WithValue(r.Context(), \"handler\", handlerName)\n\t\tr = r.WithContext(ctx)\n\n\t\twrapped := &responseWriter{ResponseWriter: w}\n\t\tnext.ServeHTTP(wrapped, r)\n\n\t\tstatus := fmt.Sprintf(\"%d\", wrapped.status)\n\t\thttpRequestsCounter.WithLabelValues(handlerName, r.Method, status).Inc()\n\t\thttpRequestLatency.WithLabelValues(handlerName).Observe(time.Since(start).Seconds())\n\t}\n}\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tstatus int\n}\n\nfunc (rw *responseWriter) WriteHeader(code int) {\n\trw.status = code\n\trw.ResponseWriter.WriteHeader(code)\n}\n\nfunc metricsMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\theaderValue := r.Header.Get(\"X-Custom-Header\")\n\t\tctx := context.WithValue(r.Context(), \"custom_header\", headerValue)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\nfunc customEndpoint(w http.ResponseWriter, r *http.Request) {\n\thandlerName := r.Context().Value(\"handler\").(string)\n\tcustomHeader := r.Context().Value(\"custom_header\").(string)\n\tlog.Printf(\"Handling %s endpoint with custom header: %s\", handlerName, customHeader)\n\tfmt.Fprintf(w, \"Hello from custom endpoint!\\n\")\n}\n\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/custom\", withLabelResolver(customEndpoint, \"custom\"))\n\n\tserver := &http.Server{\n\t\tAddr:    \":3000\",\n\t\tHandler: metricsMiddleware(mux),\n\t}\n\n\tlog.Println(\"Starting server on :3000\")\n\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"Could not start server: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement an HTTP worker struct that can process jobs by making HTTP requests with custom headers and handling the responses appropriately.\n\nStruct Description: HTTPWorker is a struct that handles HTTP job processing with configurable user agent and logging capabilities. It implements job execution by making POST requests to specified URLs with JSON payloads and processing the responses.\n\nFields:\nUserAgent: string - The User-Agent header value to be used in HTTP requests\nLogger: *zerolog.Logger - Logger instance for debug and error logging\n\nMethods:\nWork: (job jobqueue.Job) -> *jobqueue.Result - Processes a job by making an HTTP POST request to the job's URL with the job's payload as JSON. Handles request creation, execution, response reading, and result parsing. Returns a jobqueue.Result indicating the outcome of the job processing.\n\nInput Parameters:\n- job: jobqueue.Job - Contains the job details including URL, payload, and timeout\n\nOutput:\n- *jobqueue.Result - The result of the job processing, including status, code, and message",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fireworq/fireworq/jobqueue\"\n\t\"github.com/rs/zerolog\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\nfunc (worker *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\tclient := &http.Client{\n\t\tTimeout: time.Duration(job.Timeout()) * time.Second,\n\t}\n\treq, err := http.NewRequest(\n\t\t\"POST\",\n\t\tjob.URL(),\n\t\tstrings.NewReader(job.Payload()),\n\t)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Cannot create http request: %v\", err),\n\t\t}\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tuserAgent := worker.UserAgent\n\tif userAgent == \"\" {\n\t\tuserAgent = defaultUserAgent\n\t}\n\treq.Header.Add(\"User-Agent\", userAgent)\n\n\tresp, err := client.Do(req)\n\n\tworker.Logger.Debug().\n\t\tStr(\"action\", \"dispatch\").\n\t\tStr(\"worker\", \"HTTPWorker\").\n\t\tStr(\"url\", job.URL()).\n\t\tStr(\"payload\", job.Payload()).\n\t\tMsg(\"Dispatched via HTTP\")\n\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Request failed: %v\", err),\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Cannot read body: %v\", err),\n\t\t}\n\t}\n\n\tvar rslt jobqueue.Result\n\terr = json.Unmarshal(body, &rslt)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus: jobqueue.ResultStatusFailure,\n\t\t\tCode:   resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Cannot parse body as JSON: %v\\nOriginal response body:\\n%s\",\n\t\t\t\terr,\n\t\t\t\tstring(body),\n\t\t\t),\n\t\t}\n\t}\n\n\tif !rslt.IsValid() {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Invalid result status: %s\\nOriginal response body:\\n%s\", rslt.Status, string(body)),\n\t\t}\n\t}\n\n\trslt.Code = resp.StatusCode\n\treturn &rslt\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\nfunc (w *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\tctx, cancel := context.WithTimeout(context.Background(), job.Timeout)\n\tdefer cancel()\n\n\tpayloadBytes, err := json.Marshal(job.Payload)\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"Failed to marshal job payload\")\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  \"error\",\n\t\t\tCode:    500,\n\t\t\tMessage: \"Payload marshaling failed\",\n\t\t}\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", job.URL, bytes.NewBuffer(payloadBytes))\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"Failed to create HTTP request\")\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  \"error\",\n\t\t\tCode:    500,\n\t\t\tMessage: \"Request creation failed\",\n\t\t}\n\t}\n\n\treq.Header.Set(\"User-Agent\", w.UserAgent)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"HTTP request failed\")\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  \"error\",\n\t\t\tCode:    500,\n\t\t\tMessage: \"HTTP request failed\",\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {\n\t\tvar result jobqueue.Result\n\t\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\t\tw.Logger.Warn().Err(err).Msg(\"Failed to decode response body\")\n\t\t\treturn &jobqueue.Result{\n\t\t\t\tStatus:  \"success\",\n\t\t\t\tCode:    resp.StatusCode,\n\t\t\t\tMessage: \"Job processed successfully, but response parsing failed\",\n\t\t\t}\n\t\t}\n\t\treturn &result\n\t}\n\n\treturn &jobqueue.Result{\n\t\tStatus:  \"failure\",\n\t\tCode:    resp.StatusCode,\n\t\tMessage: \"Received non-success status code from server\",\n\t}\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Go struct that represents local network services capable of running both a DNS server and an HTTP server concurrently. The DNS server should resolve a specific domain to a local IP address, while the HTTP server should serve predefined webpages.\n\nStruct Description: The `localNetworkServices` struct encapsulates functionality for running concurrent DNS and HTTP servers. The DNS server resolves a configured domain to a local IP address, and the HTTP server serves static web content mapped to specific paths.\n\nFields:\n- domain: string - The domain name that will be resolved by the DNS server\n- webpages: map[string]string - A map of URL paths to their corresponding webpage content\n- ipAddr: string - The local IP address that both servers will bind to\n\nMethods:\n- DNSServerIP() -> string - Returns the IP address of the DNS server\n- URL(subpath string) -> string - Constructs a full URL for a given subpath using the configured domain\n- Serve(ctx context.Context) -> error - Starts both DNS and HTTP servers concurrently using an errgroup, returns any error that occurs during execution\n\nAdditional Helper Struct:\n- dnsHandler: Implements the dns.Handler interface to handle DNS queries\n\nFields:\n- records: map[string]string - A map of domain names to their corresponding IP addresses\n\nMethods:\n- ServeDNS(w dns.ResponseWriter, r *dns.Msg) - Handles incoming DNS queries, responding with A records for configured domains",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"github.com/miekg/dns\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (l localNetworkServices) DNSServerIP() string {\n\treturn l.ipAddr\n}\n\nfunc (l localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s/%s\", l.domain, subpath)\n}\n\nfunc (l localNetworkServices) Serve(ctx context.Context) error {\n\terrGroup, _ := errgroup.WithContext(ctx)\n\n\terrGroup.Go(func() error {\n\t\tdnsSrv := &dns.Server{\n\t\t\tAddr: l.ipAddr + \":53\",\n\t\t\tNet:  \"udp\",\n\t\t\tHandler: &dnsHandler{\n\t\t\t\trecords: map[string]string{\n\t\t\t\t\tl.domain + \".\": l.ipAddr,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treturn dnsSrv.ListenAndServe()\n\t})\n\n\terrGroup.Go(func() error {\n\t\tfor path, contents := range l.webpages {\n\t\t\twebpage := contents\n\t\t\thttp.HandleFunc(\"/\"+path, func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tio.WriteString(w, webpage)\n\t\t\t})\n\t\t}\n\n\t\treturn http.ListenAndServe(l.ipAddr+\":80\", nil)\n\t})\n\n\treturn errGroup.Wait()\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tmsg := dns.Msg{}\n\tmsg.SetReply(r)\n\tif r.Question[0].Qtype == dns.TypeA {\n\t\tmsg.Authoritative = true\n\t\tdomain := msg.Question[0].Name\n\t\taddress, ok := h.records[domain]\n\t\tif ok {\n\t\t\tmsg.Answer = append(msg.Answer, &dns.A{\n\t\t\t\tHdr: dns.RR_Header{Name: domain, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 3600},\n\t\t\t\tA:   net.ParseIP(address),\n\t\t\t})\n\t\t} else {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t}\n\n\tw.WriteMsg(&msg)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/miekg/dns\"\n)\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h *dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\tm.Compress = false\n\n\tif len(m.Question) == 0 {\n\t\tw.WriteMsg(m)\n\t\treturn\n\t}\n\n\tfor _, q := range m.Question {\n\t\tif q.Qtype == dns.TypeA {\n\t\t\tipStr, ok := h.records[q.Name]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip := net.ParseIP(ipStr)\n\t\t\tif ip == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trr := &dns.A{\n\t\t\t\tHdr: dns.RR_Header{\n\t\t\t\t\tName:   q.Name,\n\t\t\t\t\tRrtype: dns.TypeA,\n\t\t\t\t\tClass:  dns.ClassINET,\n\t\t\t\t\tTtl:    300,\n\t\t\t\t},\n\t\t\t\tA: ip,\n\t\t\t}\n\t\t\tm.Answer = append(m.Answer, rr)\n\t\t}\n\t}\n\tw.WriteMsg(m)\n}\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (s *localNetworkServices) DNSServerIP() string {\n\treturn s.ipAddr\n}\n\nfunc (s *localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s/%s\", s.domain, subpath)\n}\n\nfunc (s *localNetworkServices) Serve(ctx context.Context) error {\n\tmux := http.NewServeMux()\n\tfor path, content := range s.webpages {\n\t\tpathCopy := content\n\t\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tfmt.Fprint(w, pathCopy)\n\t\t})\n\t}\n\n\tdnsSrv := &dns.Server{\n\t\tAddr:    s.ipAddr,\n\t\tNet:     \"udp\",\n\t\tHandler: &dnsHandler{records: map[string]string{s.domain + \".\": s.ipAddr}},\n\t}\n\n\thttpSrv := &http.Server{\n\t\tAddr:    s.ipAddr,\n\t\tHandler: mux,\n\t}\n\n\tgo func() {\n\t\t<-ctx.Done()\n\t\t_ = dnsSrv.Shutdown()\n\t\t_ = httpSrv.Shutdown(context.Background())\n\t}()\n\n\terrChan := make(chan error, 2)\n\n\tgo func() {\n\t\tif err := dnsSrv.ListenAndServe(); err != nil {\n\t\t\terrChan <- fmt.Errorf(\"DNS server error: %w\", err)\n\t\t}\n\t\tclose(errChan)\n\t}()\n\n\tgo func() {\n\t\tif err := httpSrv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\terrChan <- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t}\n\t\tclose(errChan)\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\treturn err\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests with tracing capabilities using OpenCensus. The server should respond to requests with a simple message, perform tracing operations, and make an external HTTP request while propagating the trace context.\n\nFunction Description: The main function sets up an HTTP server with tracing middleware. It registers a root handler (\"/\") that responds with \"hello world\", creates trace spans, adds annotations/attributes, and makes an external HTTP request to example.com while maintaining trace context.\n\nInput: None (The function takes no direct input parameters. HTTP requests come through the server's routing mechanism.)\n\nOutput: None (The function doesn't return anything directly. It starts an HTTP server that listens indefinitely on port 50030 and handles incoming requests by writing responses to http.ResponseWriter.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/plugin/ochttp\"\n)\n\nfunc main() {\n\tclient := &http.Client{Transport: &ochttp.Transport{}}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\n\t\t_, span := trace.StartSpan(req.Context(), \"child\")\n\t\tdefer span.End()\n\t\tspan.Annotate([]trace.Attribute{trace.StringAttribute(\"key\", \"value\")}, \"something happened\")\n\t\tspan.AddAttributes(trace.StringAttribute(\"hello\", \"world\"))\n\t\ttime.Sleep(time.Millisecond * 125)\n\n\t\tr, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\t\tr = r.WithContext(req.Context())\n\t\tresp, err := client.Do(r)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t} else {\n\t\t\tresp.Body.Close()\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":50030\", &ochttp.Handler{}))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/exporter/zipkin\"\n\t\"go.opencensus.io/plugin/ochttp\"\n\t\"go.opencensus.io/trace\"\n)\n\nfunc main() {\n\t// Setup Zipkin exporter\n\tlocalEndpoint := \"http://localhost:9411/api/v2/spans\"\n\tzipkinExporter, err := zipkin.NewExporter(zipkin.WithURL(localEndpoint))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttrace.RegisterExporter(zipkinExporter)\n\ttrace.SetDefaultSampler(trace.AlwaysSample())\n\n\t// Setup HTTP server with tracing middleware\n\thandler := &ochttp.Handler{\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\tvar span *trace.Span\n\t\t\tctx, span = trace.StartSpan(ctx, \"helloWorldHandler\")\n\t\t\tdefer span.End()\n\n\t\t\tspan.AddAttributes(\n\t\t\t\ttrace.StringAttribute(\"http.method\", r.Method),\n\t\t\t\ttrace.StringAttribute(\"http.path\", r.URL.Path),\n\t\t\t)\n\n\t\t\t// Perform an external HTTP request with trace context propagation\n\t\t\tclient := &http.Client{}\n\t\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\t\treq = req.WithContext(ctx)\n\t\t\tresp, err := client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Failed to make external request\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\tspan.Annotate([]trace.Attribute{\n\t\t\t\ttrace.Int64Attribute(\"response.size\", int64(len(body))),\n\t\t\t}, \"Received response from example.com\")\n\n\t\t\tfmt.Fprintf(w, \"hello world\")\n\t\t}),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:    \":50030\",\n\t\tHandler: handler,\n\t}\n\n\tserver.ListenAndServe()\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that performs HTTP requests with customizable options including TLS configuration, request method, headers, and payload.\n\nFunction Description: The function DoRequest executes HTTP requests with various configurable options. It handles TLS configuration (including insecure mode), sets request headers, processes different HTTP methods, and manages response reading. The function is designed to be flexible for different API interaction scenarios while maintaining security and error handling.\n\nInput:\n- opt (EtcdRequestOption struct) - Configuration options for the HTTP request containing:\n  - Endpoint (string): Base URL for the request\n  - Api (string): API endpoint path\n  - PostData (string): Request payload data\n  - TlsConfig (*tls.Config): TLS configuration (nil for insecure)\n  - Method (string): HTTP method (GET, POST, etc.)\n  - Silent (bool): Unused in current implementation\n\nOutput:\n- (string) - Response body content as string\n- (error) - Error object if request fails, nil on success",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/cdk-team/CDK/pkg/errors\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\tif opt.TlsConfig == nil || len(opt.TlsConfig.Certificates) == 0 || opt.TlsConfig.RootCAs == nil {\n\t\topt.TlsConfig = &tls.Config{InsecureSkipVerify: true}\n\t}\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t},\n\t\tTimeout: time.Duration(5) * time.Second,\n\t}\n\n\trequest, err := http.NewRequest(opt.Method, opt.Endpoint+opt.Api, bytes.NewBuffer([]byte(opt.PostData)))\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found while generate post request in net.http .\"}\n\t}\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(request)\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t} else if err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\treturn string(content), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\turl := strings.TrimSuffix(opt.Endpoint, \"/\") + \"/\" + strings.TrimPrefix(opt.Api, \"/\")\n\tmethod := opt.Method\n\tif method == \"\" {\n\t\tmethod = \"GET\"\n\t}\n\n\tvar reqBody *bytes.Buffer\n\tif method == \"POST\" || method == \"PUT\" {\n\t\treqBody = bytes.NewBuffer([]byte(opt.PostData))\n\t} else {\n\t\treqBody = bytes.NewBuffer(nil)\n\t}\n\n\treq, err := http.NewRequest(method, url, reqBody)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t},\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn string(body), fmt.Errorf(\"non-2xx status code: %d\", resp.StatusCode)\n\t}\n\n\treturn string(body), nil\n}"
  }
]