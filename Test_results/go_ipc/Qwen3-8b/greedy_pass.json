[
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles JSONP requests, serving dynamic JSON data wrapped in a callback function.\n\nFunction Description: The main function initializes an Echo server, sets up middleware for logging and recovery, serves static files from a \"public\" directory, and defines a route (\"/jsonp\") that responds to GET requests with JSONP-formatted data containing a response message, current timestamp, and random number.\n\nInput: None (The function takes no direct input parameters, but the \"/jsonp\" endpoint accepts an optional query parameter \"callback\" specifying the JSONP callback function name)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and serves responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Static(\"/\", \"public\")\n\n\te.GET(\"/jsonp\", func(c echo.Context) error {\n\t\tcallback := c.QueryParam(\"callback\")\n\t\tvar content struct {\n\t\t\tResponse  string    `json:\"response\"`\n\t\t\tTimestamp time.Time `json:\"timestamp\"`\n\t\t\tRandom    int       `json:\"random\"`\n\t\t}\n\t\tcontent.Response = \"Sent via JSONP\"\n\t\tcontent.Timestamp = time.Now().UTC()\n\t\tcontent.Random = rand.Intn(1000)\n\t\treturn c.JSONP(http.StatusOK, callback, &content)\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n\t\"time\"\n\t\"math/rand\"\n\t\"encoding/json\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\te.Static(\"/\", \"public\")\n\te.GET(\"/jsonp\", func(c echo.Context) error {\n\t\tcallback := c.Query(\"callback\")\n\t\tif callback == \"\" {\n\t\t\tcallback = \"jsonpCallback\"\n\t\t}\n\t\tmessage := \"Hello, JSONP!\"\n\t\ttimestamp := time.Now().Unix()\n\t\trandom := rand.Intn(100)\n\t\tdata := map[string]interface{}{\n\t\t\t\"message\":   message,\n\t\t\t\"timestamp\": timestamp,\n\t\t\t\"random\":    random,\n\t\t}\n\t\tjsonData, _ := json.Marshal(data)\n\t\tresponse := callback + \"(\" + string(jsonData) + \")\"\n\t\tc.Response().Header().Set(\"Content-Type\", \"application/javascript\")\n\t\treturn c.String(http.StatusOK, response)\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic routes and includes middleware for logging and recovery.\n\nFunction Description: The main function initializes a new Echo instance, sets up middleware for logging and panic recovery, defines a route handler for the root path (\"/\"), and starts the HTTP server on port 1323.\n\nInput: None (The function takes no direct input parameters; configuration is done internally)\n\nOutput: None (The function does not return any value; it starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\\n\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Go struct that represents an HTTP server application using the Echo framework, with configurable options and standard middleware.\n\nStruct Description: The `App` struct represents an HTTP server application built on the Echo framework. It encapsulates the Echo engine instance and provides methods to initialize and run the server with common middleware (recovery, logging) and default routes.\n\nFields:\n- Engine: *echo.Echo - The core Echo framework instance that handles HTTP routing and middleware\n- Conf: *conf.Conf - Configuration object for server settings (port, debug mode, etc.)\n\nMethods:\n- NewApp: func(opts ...AppOptions) *App - Constructor that initializes a new App instance with optional configuration. Applies default middleware (recovery, logging) and sets up basic routes.\n  Input: opts ...AppOptions (variadic parameter for configuration options)\n  Output: *App (new App instance)\n\n- Run: func() - Starts the HTTP server using the configured port from Conf. Panics if server fails to start.\n  Input: None\n  Output: None (runs indefinitely until server stops)\n\n- Must: func(error) - Helper function (not shown in reference) that panics on error, typically used for server startup\n  Input: error\n  Output: None",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\toptions := AppOptions{}\n\tfor _, i := range opts {\n\t\toptions = i\n\t\tbreak\n\t}\n\n\toptions.init()\n\n\tengine := echo.New()\n\n\tengine.Debug = conf.UBool(\"debug\")\n\n\tengine.Use(middleware.Recover())\n\n\tengine.GET(\"/favicon.ico\", func(c echo.Context) error {\n\t\treturn c.Redirect(http.StatusMovedPermanently, \"/static/images/favicon.ico\")\n\t})\n\n\tengine.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `${method} | ${status} | ${uri} -> ${latency_human}` + \"\\n\",\n\t}))\n\n\tapp := &App{\n\t\tEngine: engine,\n\t}\n\n\treturn app\n}\n\nfunc (app *App) Run() {\n\tMust(app.Engine.Start(\":\" + app.Conf.UString(\"port\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/yourpackage/conf\"\n\t\"net/http\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n\tConf   *conf.Conf\n}\n\ntype AppOptions struct {\n\tConf *conf.Conf\n}\n\nfunc (o AppOptions) Apply(app *App) {\n\tapp.Conf = o.Conf\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\tapp := &App{\n\t\tEngine: echo.New(),\n\t\tConf:   &conf.Conf{},\n\t}\n\tfor _, opt := range opts {\n\t\topt.Apply(app)\n\t}\n\tapp.Engine.Use(middleware.Recovery())\n\tapp.Engine.Use(middleware.Logger())\n\tapp.Engine.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Welcome to the server!\")\n\t})\n\treturn app\n}\n\nfunc Must(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (a *App) Run() {\n\tMust(a.Engine.Start(fmt.Sprintf(\":%d\", a.Conf.Port)))\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Implement an auto-managed HTTP provider in Go using the Echo framework that can dynamically start/stop an HTTP server with health check capabilities.\n\nStruct Description: AutoManagedProvider is a struct that manages an Echo-based HTTP server with automatic startup/shutdown capabilities and provides health check endpoints.\n\nFields:\n- activeProvider: *echo.Echo - The Echo HTTP server instance\n- activeProviderRunning: bool - Flag indicating if the server is currently running\n- activeProviderTesting: bool - Flag indicating if the server is in testing mode\n- httpClient: *http.Client - HTTP client used for internal communications\n- autoManagePort: int - Port number for the managed HTTP server\n\nMethods:\n- NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider - Constructor that creates a new AutoManagedProvider with configuration\n- UpdateTTL() - Manages the server lifecycle (starts if not running, stops if shutdown)\n- isShutdown() bool - Checks if the server should be shutdown (returns bool)\n- getCurrentNode() interface{} - Returns current node information for health checks (returns interface{})",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider        *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient            *http.Client\n\tautoManagePort        int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyFromEnvironment,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   5 * time.Second,\n\t\t\tKeepAlive: 5 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          10,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxConnsPerHost:       10,\n\t}\n\n\thttpClient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   2 * time.Second,\n\t}\n\n\tp := &AutoManagedProvider{\n\t\thttpClient:            httpClient,\n\t\tautoManagePort:        autoManPort,\n\t\tactiveProviderRunning: false,\n\t}\n\n\treturn p\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n\tif p.isShutdown() && p.activeProviderRunning {\n\t\tp.activeProvider.Close()\n\t\treturn\n\t}\n\n\tif p.activeProviderRunning {\n\t\treturn\n\t}\n\n\tif !p.activeProviderTesting {\n\t\tp.activeProvider = echo.New()\n\t\tp.activeProvider.HideBanner = true\n\t\tp.activeProvider.GET(\"/_health\", func(context echo.Context) error {\n\t\t\treturn context.JSON(http.StatusOK, p.getCurrentNode())\n\t\t})\n\t}\n\tgo func() {\n\t\tp.activeProviderRunning = true\n\t\tappURI := fmt.Sprintf(\"0.0.0.0:%d\", p.autoManagePort)\n\t\tp.activeProvider.Start(appURI)\n\t\tp.activeProviderRunning = false\n\t}()\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n\treturn false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "import (\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n\n    \"github.com/labstack/echo/v4\"\n)\n\ntype AutoManagedProvider struct {\n    activeProvider *echo.Echo\n    activeProviderRunning bool\n    activeProviderTesting bool\n    httpClient *http.Client\n    autoManagePort int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n    provider := &AutoManagedProvider{\n        autoManagePort: autoManPort,\n        activeProviderTesting: false,\n        httpClient: &http.Client{\n            Timeout: refreshTTL,\n        },\n    }\n\n    provider.activeProvider = echo.New()\n    provider.activeProvider.GET(\"/healthz\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"OK\")\n    })\n    provider.activeProvider.GET(\"/readyz\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"OK\")\n    })\n\n    if !provider.activeProviderTesting {\n        provider.startServer()\n    }\n\n    return provider\n}\n\nfunc (p *AutoManagedProvider) startServer() {\n    if p.activeProviderRunning {\n        return\n    }\n\n    go func() {\n        if err := p.activeProvider.Start(fmt.Sprintf(\":%d\", p.autoManagePort)); err != nil {\n            fmt.Println(\"Server stopped:\", err)\n        }\n        p.activeProviderRunning = true\n    }()\n}\n\nfunc (p *AutoManagedProvider) stopServer() {\n    if !p.activeProviderRunning {\n        return\n    }\n\n    p.activeProvider.Close()\n    p.activeProviderRunning = false\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n    if !p.activeProviderRunning {\n        p.startServer()\n    } else {\n        if p.isShutdown() {\n            p.stopServer()\n        }\n    }\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n    return false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n    return map[string]interface{}{\n        \"host\": \"localhost\",\n        \"port\": p.autoManagePort,\n        \"status\": \"healthy\",\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user authentication with JWT tokens. The server should have routes for login, accessible content, and restricted content that requires JWT authentication.\n\nFunction Description: The main function initializes an Echo server, configures middleware for logging and recovery, sets up route handlers for login and accessible content, and creates a restricted route group that requires JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger its handlers)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately but are referenced in this main function. The JWT configuration uses a custom claims structure (jwtCustomClaims) which should also be defined elsewhere.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tconfig := middleware.JWTConfig{\n\t\tClaims:     &jwtCustomClaims{},\n\t\tSigningKey: []byte(\"secret\"),\n\t}\n\tr.Use(middleware.JWTWithConfig(config))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n    \"github.com/labstack/echo/v4\"\n    \"github.com/labstack/echo/v4/middleware\"\n    \"github.com/dgrijalva/jwt-go\"\n)\n\ntype jwtCustomClaims struct{}\n\nfunc main() {\n    e := echo.New()\n    e.Use(middleware.Logger())\n    e.Use(middleware.Recovery())\n\n    e.POST(\"/login\", loginHandler)\n    e.GET(\"/accessible\", accessibleHandler)\n\n    jwtConfig := jwt.Config{\n        SigningMethod: \"HS256\",\n        KeyFunc: func(token *jwt.Token) (interface{}, error) {\n            return []byte(\"secret-key\"), nil\n        },\n        Claims: jwtCustomClaims{},\n    }\n\n    restrictedGroup := e.Group(\"/restricted\")\n    restrictedGroup.Use(jwt.JWTWithConfig(jwtConfig))\n    restrictedGroup.GET(\"/content\", restrictedHandler)\n\n    e.Start(\":1323\")\n}\n\nfunc loginHandler(c echo.Context) error {\n    return c.JSON(200, map[string]string{\"message\": \"Login successful\"})\n}\n\nfunc accessibleHandler(c echo.Context) error {\n    return c.JSON(200, map[string]string{\"message\": \"Accessible content\"})\n}\n\nfunc restrictedHandler(c echo.Context) error {\n    return c.JSON(200, map[string]string{\"message\": \"Restricted content\"})\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various API endpoints for a Vault management system, including authentication, token management, secret management, and more.\n\nFunction Description: The StartListener function initializes and starts an Echo HTTP server with configured routes and middleware. It sets up various API endpoints for Vault operations, applies middleware for logging, recovery, and request handling, and serves static assets if provided. The server can be started with or without TLS based on configuration.\n\nInput:\n- listener: config.ListenerConfig - Configuration for the server listener including address and TLS settings\n- assets: *rice.Box - Optional box containing static assets to be served by the server\n\nOutput: None (the function starts the server which runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\t\"log\"\n\n\t\"github.com/caiyeon/goldfish/config\"\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\te        *echo.Echo\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te = echo.New()\n\te.HideBanner = true\n\te.Server.ReadTimeout = 10 * time.Second\n\te.Server.WriteTimeout = 2 * time.Minute\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.BodyLimit(\"32M\"))\n\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\tLevel: 5,\n\t}))\n\n\te.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\tc.Response().Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\tif assets != nil {\n\t\tassetHandler := http.FileServer(assets.HTTPBox())\n\t\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\t\te.GET(\"/assets/css/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/js/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/fonts/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/img/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t}\n\n\te.GET(\"/v1/health\", handlers.Health())\n\te.GET(\"/v1/vaulthealth\", handlers.VaultHealth())\n\te.POST(\"/v1/bootstrap\", handlers.Bootstrap())\n\n\te.POST(\"/v1/login\", handlers.Login())\n\te.POST(\"/v1/login/renew-self\", handlers.RenewSelf())\n\n\te.GET(\"/v1/token/accessors\", handlers.GetTokenAccessors())\n\te.POST(\"/v1/token/lookup-accessor\", handlers.LookupTokenByAccessor())\n\te.POST(\"/v1/token/revoke-accessor\", handlers.RevokeTokenByAccessor())\n\te.POST(\"/v1/token/revoke-self\", handlers.RevokeSelf())\n\te.POST(\"/v1/token/create\", handlers.CreateToken())\n\te.GET(\"/v1/token/listroles\", handlers.ListRoles())\n\te.GET(\"/v1/token/role\", handlers.GetRole())\n\n\te.GET(\"/v1/userpass/users\", handlers.GetUserpassUsers())\n\te.POST(\"/v1/userpass/delete\", handlers.DeleteUserpassUser())\n\n\te.GET(\"/v1/approle/roles\", handlers.GetApproleRoles())\n\te.POST(\"/v1/approle/delete\", handlers.DeleteApproleRole())\n\n\te.GET(\"/v1/ldap/groups\", handlers.GetLDAPGroups())\n\te.GET(\"/v1/ldap/users\", handlers.GetLDAPUsers())\n\n\te.GET(\"/v1/policy\", handlers.GetPolicy())\n\te.DELETE(\"/v1/policy\", handlers.DeletePolicy())\n\te.GET(\"/v1/policy-capabilities\", handlers.PolicyCapabilities())\n\n\te.GET(\"/v1/request\", handlers.GetRequest())\n\te.POST(\"/v1/request/add\", handlers.AddRequest())\n\te.POST(\"/v1/request/approve\", handlers.ApproveRequest())\n\te.DELETE(\"/v1/request/reject\", handlers.RejectRequest())\n\n\te.GET(\"/v1/transit\", handlers.TransitInfo())\n\te.POST(\"/v1/transit/encrypt\", handlers.EncryptString())\n\te.POST(\"/v1/transit/decrypt\", handlers.DecryptString())\n\n\te.GET(\"/v1/mount\", handlers.GetMount())\n\te.POST(\"/v1/mount\", handlers.ConfigMount())\n\n\te.GET(\"/v1/secrets\", handlers.GetSecrets())\n\te.POST(\"/v1/secrets\", handlers.PostSecrets())\n\te.DELETE(\"/v1/secrets\", handlers.DeleteSecrets())\n\n\te.GET(\"/v1/bulletins\", handlers.GetBulletins())\n\n\te.POST(\"/v1/wrapping/wrap\", handlers.WrapHandler())\n\te.POST(\"/v1/wrapping/unwrap\", handlers.UnwrapHandler())\n\n\tif listener.Tls_disable {\n\t\te.Logger.Fatal(e.Start(listener.Address))\n\t\treturn\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/abiosoft/risepkg\"\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *risepkg.Box) {\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\t// Routes\n\te.POST(\"/auth/login\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Authentication successful\"})\n\t})\n\te.GET(\"/token\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"token\": \"example_token\"})\n\t})\n\te.POST(\"/token/revoke\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Token revoked\"})\n\t})\n\te.GET(\"/secret/:name\", func(c echo.Context) error {\n\t\tname := c.Param(\"name\")\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"secret\": name})\n\t})\n\te.POST(\"/secret/:name\", func(c echo.Context) error {\n\t\tname := c.Param(\"name\")\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Secret stored: \" + name})\n\t})\n\te.DELETE(\"/secret/:name\", func(c echo.Context) error {\n\t\tname := c.Param(\"name\")\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Secret deleted: \" + name})\n\t})\n\n\t// Static assets\n\tif assets != nil {\n\t\te.Static(\"/\", assets)\n\t}\n\n\t// Start server\n\tif listener.TLSConfig != nil {\n\t\te.StartTLS(listener.Addr, listener.TLSConfig.CertFile, listener.TLSConfig.KeyFile)\n\t} else {\n\t\te.Start(listener.Addr)\n\t}\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user-related requests with CORS support and logging middleware.\n\nFunction Description: The main function initializes an Echo server instance, configures middleware (logger, recovery, and CORS), sets up route handlers, and starts the server on port 1323.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handler function `getUsers` would need to be implemented separately to handle the GET request to \"/api/users\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"https://labstack.com\", \"https://labstack.net\"},\n\t\tAllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\te.Use(middleware.CORS())\n\te.GET(\"/api/users\", getUsers)\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc getUsers(c echo.Context) error {\n\treturn nil\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that includes rate limiting middleware using Sentinel, with custom resource extraction and block fallback handlers.\n\nFunction Description: The function sets up a Fiber web server with Sentinel middleware for rate limiting. The middleware extracts the client's real IP from headers as the resource key and provides a custom JSON response when requests are blocked. The server listens on port 8080 and includes a test endpoint.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import \"github.com/gofiber/fiber/v2\"\n\nfunc Example() {\n\tapp := fiber.New()\n\tapp.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx *fiber.Ctx) string {\n\t\t\t\treturn ctx.GetReqHeaders()[\"X-Real-IP\"]\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx *fiber.Ctx) error {\n\t\t\t\treturn ctx.Status(400).JSON(struct {\n\t\t\t\t\tError string `json:\"error\"`\n\t\t\t\t\tCode  int    `json:\"code\"`\n\t\t\t\t}{\n\t\t\t\t\t\"too many request; the quota used up\",\n\t\t\t\t\t10222,\n\t\t\t\t})\n\t\t\t})),\n\t)\n\n\tapp.Get(\"/test\", func(ctx *fiber.Ctx) error { return nil })\n\t_ = app.Listen(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/alibaba/sentinel-go\"\n)\n\nfunc getRealIP(c *fiber.Ctx) string {\n\tip := c.Get(\"X-Real-IP\")\n\tif ip != \"\" {\n\t\treturn ip\n\t}\n\tip = c.Get(\"X-Forwarded-For\")\n\tif ip != \"\" {\n\t\treturn ip\n\t}\n\treturn c.IP()\n}\n\nfunc main() {\n\tsentinel.Init()\n\tapp := fiber.New()\n\n\tapp.Use(func(c *fiber.Ctx) error {\n\t\tip := getRealIP(c)\n\t\tresourceKey := ip\n\t\tctx := context.Background()\n\t\tentry, err := sentinel.Entry(resourceKey, sentinel.WithEntryParam(ctx))\n\t\tif err != nil {\n\t\t\treturn c.Status(429).JSON(fiber.Map{\"error\": \"Too many requests\"})\n\t\t}\n\t\tdefer entry.Exit()\n\t\treturn c.Next()\n\t})\n\n\tapp.Get(\"/test\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Test endpoint\")\n\t})\n\n\tapp.Listen(\":8080\")\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that handles health checks and image conversion requests.\n\nFunction Description: The main function initializes and configures a Fiber HTTP server, sets up middleware for ETag generation, defines route handlers for health checks and image conversion, and starts the server on a specified host and port.\n\nInput:\n- Configuration parameters (host, port, read buffer size, concurrency, keepalive settings) are read from the config.Config object\n- No direct input parameters to the main function itself\n\nOutput:\n- Running HTTP server that listens on specified address\n- Console output indicating server status\n- Potential fatal error if server fails to start\n\nThe function performs these key operations:\n1. Initializes Fiber app with custom configuration\n2. Adds ETag middleware\n3. Registers route handlers:\n   - /healthz endpoint for health checks\n   - /* catch-all endpoint for image conversion\n4. Starts the server and handles startup errors",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"webp_server_go/config\"\n\t\"webp_server_go/handler\"\n)\n\nvar app = fiber.New(fiber.Config{\n\tServerHeader:          \"WebP Server Go\",\n\tAppName:               \"WebP Server Go\",\n\tDisableStartupMessage: true,\n\tProxyHeader:           \"X-Real-IP\",\n\tReadBufferSize:        config.Config.ReadBufferSize,\n\tConcurrency:           config.Config.Concurrency,\n\tDisableKeepalive:      config.Config.DisableKeepalive,\n})\n\nfunc main() {\n\tapp.Use(etag.New(etag.Config{\n\t\tWeak: true,\n\t}))\n\n\tlistenAddress := config.Config.Host + \":\" + config.Config.Port\n\n\tapp.Get(\"/healthz\", handler.Healthz)\n\tapp.Get(\"/*\", handler.Convert)\n\n\tfmt.Println(\"WebP Server Go is Running on http://\" + listenAddress)\n\n\tbindErr := app.Listen(listenAddress)\n\tif bindErr != nil {\n\t\tlog.Fatal(\"Error starting server: \", bindErr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"log\"\n)\n\nfunc main() {\n\t// Example config values; in a real scenario, these would be loaded from config.Config\n\thost := \"0.0.0.0\"\n\tport := \"3000\"\n\treadBufferSize := 1024\n\tconcurrency := 100\n\tkeepAlive := true\n\n\tapp := fiber.New(fiber.Config{\n\t\tHost:          host,\n\t\tPort:          port,\n\t\tReadBufferSize: readBufferSize,\n\t\tConcurrency:   concurrency,\n\t\tKeepAlive:     keepAlive,\n\t})\n\n\tapp.Use(fiber.Etag())\n\n\tapp.Get(\"/healthz\", func(c *fiber.Ctx) error {\n\t\treturn c.Status(fiber.StatusOK).JSON(fiber.Map{\"status\": \"ok\"})\n\t})\n\n\tapp.Use(\"/*\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Image conversion request received\")\n\t})\n\n\tfmt.Printf(\"Server started on http://%s:%s\\n\", host, port)\n\tif err := app.Listen(fmt.Sprintf(\"%s:%s\", host, port)); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go for a dashboard application that manages queues and tenants, with optional basic authentication and template rendering capabilities.\n\nStruct Description: The Dashboard struct represents a web dashboard that provides queue management functionality through HTTP endpoints. It uses the Fiber framework for routing and middleware, supports HTML template rendering, and can be configured with basic authentication.\n\nFields:\n\nApp: *fiber.App - The Fiber application instance for handling HTTP requests\nqueue: models.Queue - Interface for queue operations\ntenantManager: models.TenantManager - Interface for tenant management operations\ncfg: config.DashboardConfig - Configuration settings for the dashboard\n\nMethods:\n\nNewDashboard: (queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) -> *Dashboard - Initializes a new Dashboard instance with the given dependencies and configuration, sets up template engine, basic auth middleware, and route handlers\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nQueues: (c *fiber.Ctx) -> error - Handler for GET / route\nNewQueue: (c *fiber.Ctx) -> error - Handler for POST /queues route\nQueue: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue route\nQueueSettings: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/settings route\nSaveQueueSettings: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/settings route\nDeleteQueueConfirm: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/delete route\nDeleteQueue: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/delete route\nMessage: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/messages/:message route",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n\t\"github.com/gofiber/template/html/v2\"\n)\n\ntype Dashboard struct {\n\tApp *fiber.App\n\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tvar engine *html.Engine\n\n\tif cfg.Dev {\n\t\tengine = html.New(\"./dashboard/views\", \".html\")\n\t\tengine.Reload(true)\n\t\tengine.Debug(true)\n\t} else {\n\t\thttp.FS(viewsfs)\n\t\tfs2, err := fs.Sub(viewsfs, \"views\")\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tengine = html.NewFileSystem(http.FS(fs2), \".html\")\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tViews:                 engine,\n\t\tDisableStartupMessage: true,\n\t})\n\n\tif cfg.User != \"\" && cfg.Pass != \"\" {\n\t\tapp.Use(basicauth.New(basicauth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.User: cfg.Pass,\n\t\t\t},\n\t\t}))\n\t}\n\n\td := &Dashboard{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Get(\"/\", d.Queues)\n\tapp.Post(\"/queues\", d.NewQueue)\n\tapp.Get(\"/queues/:queue\", d.Queue)\n\tapp.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"Dashboard: http://localhost:%d\\n\", d.cfg.Port)\n\treturn d.App.Listen(fmt.Sprintf(\":%d\", d.cfg.Port))\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Shutdown()\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/template/html\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n)\n\ntype Dashboard struct {\n\tApp         *fiber.App\n\tqueue       models.Queue\n\ttenantManager models.TenantManager\n\tcfg         config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tapp := fiber.New()\n\n\t// Set up template engine\n\tengine := html.New(\"templates\", \".html\")\n\tapp.Use(engine)\n\n\t// Add basic auth middleware if enabled\n\tif cfg.Auth.Enabled {\n\t\tapp.Use(basicauth.New(basicauth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.Auth.Username: cfg.Auth.Password,\n\t\t\t},\n\t\t}))\n\t}\n\n\t// Define routes\n\tapp.Get(\"/\", d.Queues)\n\tapp.Post(\"/queues\", d.NewQueue)\n\tapp.Get(\"/queues/:queue\", d.Queue)\n\tapp.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn &Dashboard{\n\t\tApp:         app,\n\t\tqueue:       queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:         cfg,\n\t}\n}\n\nfunc (d *Dashboard) Start() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Listen(\":8080\")\n\t}\n\treturn nil\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Shutdown()\n\t}\n\treturn nil\n}\n\nfunc (d *Dashboard) Queues(c *fiber.Ctx) error {\n\tqueues, err := d.queue.List()\n\tif err != nil {\n\t\treturn c.Status(500).SendString(\"Internal Server Error\")\n\t}\n\treturn c.Render(\"queues\", fiber.Map{\n\t\t\"Queues\": queues,\n\t})\n}\n\nfunc (d *Dashboard) NewQueue(c *fiber.Ctx) error {\n\tname := c.FormValue(\"name\")\n\tif name == \"\" {\n\t\treturn c.Status(400).SendString(\"Name is required\")\n\t}\n\terr := d.queue.Create(name)\n\tif err != nil {\n\t\treturn c.Status(500).SendString(\"Failed to create queue\")\n\t}\n\treturn c.Redirect(\"/queues\")\n}\n\nfunc (d *Dashboard) Queue(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tqueue, err := d.queue.Get(queueName)\n\tif err != nil {\n\t\treturn c.Status(404).SendString(\"Queue not found\")\n\t}\n\treturn c.Render(\"queue\", fiber.Map{\n\t\t\"Queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) QueueSettings(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tqueue, err := d.queue.Get(queueName)\n\tif err != nil {\n\t\treturn c.Status(404).SendString(\"Queue not found\")\n\t}\n\treturn c.Render(\"queue_settings\", fiber.Map{\n\t\t\"Queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) SaveQueueSettings(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tmaxMessages := c.FormValue(\"max_messages\")\n\terr := d.queue.UpdateSettings(queueName, maxMessages)\n\tif err != nil {\n\t\treturn c.Status(500).SendString(\"Failed to update settings\")\n\t}\n\treturn c.Redirect(\"/queues/\" + queueName)\n}\n\nfunc (d *Dashboard) DeleteQueueConfirm(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tqueue, err := d.queue.Get(queueName)\n\tif err != nil {\n\t\treturn c.Status(404).SendString(\"Queue not found\")\n\t}\n\treturn c.Render(\"delete_queue\", fiber.Map{\n\t\t\"Queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) DeleteQueue(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\terr := d.queue.Delete(queueName)\n\tif err != nil {\n\t\treturn c.Status(500).SendString(\"Failed to delete queue\")\n\t}\n\treturn c.Redirect(\"/\")\n}\n\nfunc (d *Dashboard) Message(c *fiber.Ctx) error {\n\tqueueName := c.Params(\"queue\")\n\tmessageId := c.Params(\"message\")\n\tmessage, err := d.queue.GetMessage(queueName, messageId)\n\tif err != nil {\n\t\treturn c.Status(404).SendString(\"Message not found\")\n\t}\n\treturn c.Render(\"message\", fiber.Map{\n\t\t\"Message\": message,\n\t})\n}"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Implement a Fiber-based HTTP server in Go that handles Amazon SQS (Simple Queue Service) API requests, including authentication, routing, and various SQS operations.\n\nStruct Description: The SQS struct represents an HTTP server that processes Amazon SQS API requests. It uses Fiber framework for HTTP handling and includes queue management functionality with tenant isolation.\n\nFields:\n\nApp: *fiber.App - Fiber application instance for HTTP server\nqueue: models.Queue - Queue management interface\ntenantManager: models.TenantManager - Tenant management interface\ncfg: config.SQSConfig - Configuration for the SQS server\n\nMethods:\n\nNewSQS: (queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) -> *SQS - Constructor that initializes the SQS server with dependencies and configuration\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nAction: (c *fiber.Ctx) -> error - Main request handler that routes SQS API requests based on X-Amz-Target header\nSendMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessage SQS operation\nSendMessageBatch: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessageBatch SQS operation\nReceiveMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles ReceiveMessage SQS operation\nDeleteMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles DeleteMessage SQS operation\nListQueues: (c *fiber.Ctx, tenantId int64) -> error - Handles ListQueues SQS operation\nGetQueueURL: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueUrl SQS operation\nCreateQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles CreateQueue SQS operation\nGetQueueAttributes: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueAttributes SQS operation\nPurgeQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles PurgeQueue SQS operation\nChangeMessageVisibility: (c *fiber.Ctx, tenantId int64) -> error - Handles ChangeMessageVisibility SQS operation\nerrorHandler: (ctx *fiber.Ctx, err error) -> error - Custom error handler for the Fiber app\nauthMiddleware: (c *fiber.Ctx) -> error - Authentication middleware for tenant validation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/valyala/fasthttp/fasthttpadaptor\"\n)\n\ntype SQS struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\ts := &SQS{\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t\tErrorHandler:          s.errorHandler,\n\t\tBodyLimit:             cfg.MaxRequestSize,\n\t})\n\n\tapp.Use(s.authMiddleware)\n\tapp.Post(\"/*\", s.Action)\n\n\ts.App = app\n\n\treturn s\n}\n\nfunc (s *SQS) Start() error {\n\tif !s.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"SQS Endpoint: http://localhost:%d\\n\", s.cfg.Port)\n\treturn s.App.Listen(fmt.Sprintf(\":%d\", s.cfg.Port))\n}\n\nfunc (s *SQS) Stop() error {\n\tif s.cfg.Enabled {\n\t\treturn s.App.Shutdown()\n\t}\n\treturn nil\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\tawsMethodHeader, ok := c.GetReqHeaders()[\"X-Amz-Target\"]\n\tif !ok {\n\t\treturn errors.New(\"X-Amz-Target header not found\")\n\t}\n\tawsMethod := awsMethodHeader[0]\n\n\tvar r *http.Request = &http.Request{}\n\tfasthttpadaptor.ConvertRequest(c.Context(), r, false)\n\n\ttenantId := c.Locals(\"tenantId\").(int64)\n\n\tvar rc error\n\tswitch awsMethod {\n\tcase \"AmazonSQS.SendMessage\":\n\t\trc = s.SendMessage(c, tenantId)\n\tcase \"AmazonSQS.SendMessageBatch\":\n\t\trc = s.SendMessageBatch(c, tenantId)\n\tcase \"AmazonSQS.ReceiveMessage\":\n\t\trc = s.ReceiveMessage(c, tenantId)\n\tcase \"AmazonSQS.DeleteMessage\":\n\t\trc = s.DeleteMessage(c, tenantId)\n\tcase \"AmazonSQS.ListQueues\":\n\t\trc = s.ListQueues(c, tenantId)\n\tcase \"AmazonSQS.GetQueueUrl\":\n\t\trc = s.GetQueueURL(c, tenantId)\n\tcase \"AmazonSQS.CreateQueue\":\n\t\trc = s.CreateQueue(c, tenantId)\n\tcase \"AmazonSQS.GetQueueAttributes\":\n\t\trc = s.GetQueueAttributes(c, tenantId)\n\tcase \"AmazonSQS.PurgeQueue\":\n\t\trc = s.PurgeQueue(c, tenantId)\n\tcase \"AmazonSQS.ChangeMessageVisibility\":\n\t\trc = s.ChangeMessageVisibility(c, tenantId)\n\tdefault:\n\t\trc = NewSQSError(400, \"UnsupportedOperation\", fmt.Sprintf(\"SQS method %s not implemented\", awsMethod))\n\t}\n\n\treturn rc\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware\"\n\t\"your_project/models\"\n\t\"your_project/config\"\n)\n\ntype SQS struct {\n\tApp         *fiber.App\n\tqueue       models.Queue\n\ttenantManager models.TenantManager\n\tcfg         config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\tapp := fiber.New()\n\tsqs := &SQS{\n\t\tApp:         app,\n\t\tqueue:       queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:         cfg,\n\t}\n\tsqs.setupRoutes()\n\treturn sqs\n}\n\nfunc (s *SQS) setupRoutes() {\n\ts.App.Use(func(c *fiber.Ctx) error {\n\t\treturn s.authMiddleware(c)\n\t})\n\ts.App.Post(\"/\", s.Action)\n\ts.App.Use(fiber.ErrorHandler(s.errorHandler))\n}\n\nfunc (s *SQS) authMiddleware(c *fiber.Ctx) error {\n\ttenantIDStr := c.Get(\"X-Tenant-ID\")\n\tif tenantIDStr == \"\" {\n\t\treturn c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{\"error\": \"Missing tenant ID\"})\n\t}\n\ttenantID, err := strconv.ParseInt(tenantIDStr, 10, 64)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{\"error\": \"Invalid tenant ID\"})\n\t}\n\tif !s.tenantManager.Exists(tenantID) {\n\t\treturn c.Status(fiber.StatusForbidden).JSON(fiber.Map{\"error\": \"Tenant not found\"})\n\t}\n\tc.Locals(\"tenantID\", tenantID)\n\treturn nil\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\ttarget := c.Get(\"X-Amz-Target\")\n\tif target == \"\" {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing X-Amz-Target header\"})\n\t}\n\tswitch target {\n\tcase \"SendMessage\":\n\t\treturn s.SendMessage(c, c.Locals(\"tenantID\").(int64))\n\tcase \"SendMessageBatch\":\n\t\treturn s.SendMessageBatch(c, c.Locals(\"tenantID\").(int64))\n\tcase \"ReceiveMessage\":\n\t\treturn s.ReceiveMessage(c, c.Locals(\"tenantID\").(int64))\n\tcase \"DeleteMessage\":\n\t\treturn s.DeleteMessage(c, c.Locals(\"tenantID\").(int64))\n\tcase \"ListQueues\":\n\t\treturn s.ListQueues(c, c.Locals(\"tenantID\").(int64))\n\tcase \"GetQueueUrl\":\n\t\treturn s.GetQueueURL(c, c.Locals(\"tenantID\").(int64))\n\tcase \"CreateQueue\":\n\t\treturn s.CreateQueue(c, c.Locals(\"tenantID\").(int64))\n\tcase \"GetQueueAttributes\":\n\t\treturn s.GetQueueAttributes(c, c.Locals(\"tenantID\").(int64))\n\tcase \"PurgeQueue\":\n\t\treturn s.PurgeQueue(c, c.Locals(\"tenantID\").(int64))\n\tcase \"ChangeMessageVisibility\":\n\t\treturn s.ChangeMessageVisibility(c, c.Locals(\"tenantID\").(int64))\n\tdefault:\n\t\treturn c.Status(fiber.StatusNotFound).JSON(fiber.Map{\"error\": \"Unsupported operation\"})\n\t}\n}\n\nfunc (s *SQS) SendMessage(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\tmessageBody, ok := req[\"MessageBody\"].(string)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing MessageBody\"})\n\t}\n\tif err := s.queue.SendMessage(tenantID, messageBody); err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to send message\"})\n\t}\n\treturn c.JSON(fiber.Map{\"MessageId\": \"12345\"})\n}\n\nfunc (s *SQS) SendMessageBatch(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\tmessages, ok := req[\"Messages\"].([]interface{})\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing Messages\"})\n\t}\n\tfor _, msg := range messages {\n\t\tmsgBody, ok := msg.(map[string]interface{})[\"Body\"].(string)\n\t\tif !ok {\n\t\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid message body\"})\n\t\t}\n\t\tif err := s.queue.SendMessage(tenantID, msgBody); err != nil {\n\t\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to send batch message\"})\n\t\t}\n\t}\n\treturn c.JSON(fiber.Map{\"MD5OfMessageBody\": \"abcdef1234567890\"})\n}\n\nfunc (s *SQS) ReceiveMessage(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\tmaxMessages, ok := req[\"MaxNumberOfMessages\"].(int64)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing MaxNumberOfMessages\"})\n\t}\n\tmessageAttributes, ok := req[\"MessageAttributeNames\"].([]interface{})\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing MessageAttributeNames\"})\n\t}\n\tmessages, err := s.queue.ReceiveMessage(tenantID, maxMessages, messageAttributes)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to receive message\"})\n\t}\n\treturn c.JSON(messages)\n}\n\nfunc (s *SQS) DeleteMessage(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\treceiptHandle, ok := req[\"ReceiptHandle\"].(string)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing ReceiptHandle\"})\n\t}\n\tif err := s.queue.DeleteMessage(tenantID, receiptHandle); err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to delete message\"})\n\t}\n\treturn c.JSON(fiber.Map{\"success\": true})\n}\n\nfunc (s *SQS) ListQueues(c *fiber.Ctx, tenantID int64) error {\n\tqueues, err := s.queue.ListQueues(tenantID)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to list queues\"})\n\t}\n\treturn c.JSON(queues)\n}\n\nfunc (s *SQS) GetQueueURL(c *fiber.Ctx, tenantID int64) error {\n\tqueueName, ok := c.Query(\"QueueName\")\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing QueueName\"})\n\t}\n\turl, err := s.queue.GetQueueURL(tenantID, queueName)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to get queue URL\"})\n\t}\n\treturn c.JSON(fiber.Map{\"QueueUrl\": url})\n}\n\nfunc (s *SQS) CreateQueue(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\tqueueName, ok := req[\"QueueName\"].(string)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing QueueName\"})\n\t}\n\turl, err := s.queue.CreateQueue(tenantID, queueName)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to create queue\"})\n\t}\n\treturn c.JSON(fiber.Map{\"QueueUrl\": url})\n}\n\nfunc (s *SQS) GetQueueAttributes(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\tattributeNames, ok := req[\"AttributeName\"].([]interface{})\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing AttributeName\"})\n\t}\n\tattributes, err := s.queue.GetQueueAttributes(tenantID, attributeNames)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to get queue attributes\"})\n\t}\n\treturn c.JSON(attributes)\n}\n\nfunc (s *SQS) PurgeQueue(c *fiber.Ctx, tenantID int64) error {\n\tqueueName, ok := c.Query(\"QueueName\")\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing QueueName\"})\n\t}\n\tif err := s.queue.PurgeQueue(tenantID, queueName); err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to purge queue\"})\n\t}\n\treturn c.JSON(fiber.Map{\"success\": true})\n}\n\nfunc (s *SQS) ChangeMessageVisibility(c *fiber.Ctx, tenantID int64) error {\n\tvar req map[string]interface{}\n\tif err := c.BodyParser(&req); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Invalid request body\"})\n\t}\n\treceiptHandle, ok := req[\"ReceiptHandle\"].(string)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing ReceiptHandle\"})\n\t}\n\tvisibilityTimeout, ok := req[\"VisibilityTimeout\"].(int64)\n\tif !ok {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Missing VisibilityTimeout\"})\n\t}\n\tif err := s.queue.ChangeMessageVisibility(tenantID, receiptHandle, visibilityTimeout); err != nil {\n\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Failed to change message visibility\"})\n\t}\n\treturn c.JSON(fiber.Map{\"success\": true})\n}\n\nfunc (s *SQS) errorHandler(ctx *fiber.Ctx, err error) error {\n\tlog.Printf(\"Error: %v\", err)\n\treturn ctx.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": \"Internal server error\"})\n}\n\nfunc (s *SQS) Start() error {\n\tif !s.cfg.Enabled {\n\t\treturn nil\n\t}\n\tport := fmt.Sprintf(\":%d\", s.cfg.Port)\n\treturn s.App.Listen(port)\n}\n\nfunc (s *SQS) Stop() error {\n\tif !s.cfg.Enabled {\n\t\treturn nil\n\t}\n\treturn s.App.Shutdown()\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with configurable settings including middleware, routes, and TLS support.\n\nFunction Description: The function serves as the entry point for starting a Gin-based HTTP server. It initializes the Gin engine with default middleware (Logger and Recovery) and additional custom middleware (CORS, Correlation, Auth, etc.). It registers various route handlers for different endpoints including health checks, metrics, and a home route. The server can be started with or without TLS based on configuration.\n\nInput: \n- None (configuration is read from viper and cobra command context)\n\nOutput: \n- None (runs HTTP server as a blocking operation, panics on error)\n\nMethods:\n- The function itself serves as the main execution method for the cobra.Command's Run field\n\nNote: The function uses global configuration via viper and is designed to work as part of a cobra CLI command structure. It handles server startup errors by panicking, which is appropriate for a main application entry point.\n\n(Strictly following the format with no extra characters)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n)\n\nvar towerCmd = &cobra.Command{\n\tUse:   \"api\",\n\tShort: \"Start beaver api server\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tr := gin.Default()\n\n\t\tr.Use(middleware.Cors())\n\t\tr.Use(middleware.Correlation())\n\t\tr.Use(middleware.Logger())\n\t\tr.Use(middleware.Metric())\n\t\tr.Use(middleware.Auth())\n\n\t\tr.GET(\"/favicon.ico\", func(c *gin.Context) {\n\t\t\tc.String(http.StatusNoContent, \"\")\n\t\t})\n\n\t\tr.GET(\"/\", controller.Home)\n\n\t\tr.GET(\"/_health\", controller.Health)\n\n\t\tr.GET(\n\t\t\tviper.GetString(\"app.metrics.prometheus.endpoint\"),\n\t\t\tgin.WrapH(controller.Metrics()),\n\t\t)\n\n\t\tvar runerr error\n\n\t\tif viper.GetBool(\"app.tls.status\") {\n\t\t\trunerr = r.RunTLS(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t\tviper.GetString(\"app.tls.pemPath\"),\n\t\t\t\tviper.GetString(\"app.tls.keyPath\"),\n\t\t\t)\n\t\t} else {\n\t\t\trunerr = r.Run(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t)\n\t\t}\n\n\t\tif runerr != nil {\n\t\t\tpanic(runerr.Error())\n\t\t}\n\t},\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n\t\"github.com/spf13/cobra\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc Run(cmd *cobra.Command, args []string) {\n\tengine := gin.Default()\n\n\tengine.Use(corsMiddleware, correlationMiddleware, authMiddleware)\n\n\tengine.GET(\"/health\", healthCheckHandler)\n\tengine.GET(\"/metrics\", metricsHandler)\n\tengine.GET(\"/\", homeHandler)\n\n\taddress := viper.GetString(\"server.address\")\n\tuseTLS := viper.GetBool(\"server.tls.enabled\")\n\n\tvar err error\n\tif useTLS {\n\t\tcertFile := viper.GetString(\"server.tls.cert\")\n\t\tkeyFile := viper.GetString(\"server.tls.key\")\n\t\terr = engine.RunTLS(address, certFile, keyFile)\n\t} else {\n\t\terr = engine.Run(address)\n\t}\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc corsMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tc.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tc.Next()\n\t}\n}\n\nfunc correlationMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tc.Next()\n\t}\n}\n\nfunc authMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tc.Next()\n\t}\n}\n\nfunc healthCheckHandler(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": \"healthy\"})\n}\n\nfunc metricsHandler(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"metrics\": \"example\"})\n}\n\nfunc homeHandler(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome\"})\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that implements a session-based counter. The server should increment and persist a counter value across requests using Redis as the session store.\n\nFunction Description: The main function initializes a Gin web server with Redis-based session management and implements a GET endpoint (\"/incr\") that increments and returns a counter value stored in the session.\n\nInput: None (The function takes no direct input parameters. Input comes through HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly. Output is sent as HTTP responses. The \"/incr\" endpoint returns JSON with the current count value)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/redis\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \"localhost:6379\",\n\t})\n\n\tstore, _ := redis.NewRedisStore(3600*time.Second, \"session:\", rdb)\n\n\trouter := gin.Default()\n\trouter.Use(sessions.Sessions(\"my_session\", store))\n\n\trouter.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tcount := session.Get(\"counter\")\n\t\tif count == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = count.(int) + 1\n\t\t}\n\t\tsession.Set(\"counter\", count)\n\t\tsession.Save(c)\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with caching capabilities for specific routes using in-memory storage.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), configures an in-memory cache store, and sets up a GET route (\"/cache_ping\") that returns a cached response. The cached response includes a \"pong\" message with the current Unix timestamp, and the cache is set to expire after one minute.\n\nInput: None (The function takes no parameters as it sets up the server configuration internally)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8080)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/cache\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tstore := cache.NewInMemoryStore(time.Second)\n\tr.GET(\"/cache_ping\", cache.CachePage(store, time.Minute, func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t}))\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n    \"time\"\n    \"github.com/gin-gonic/gin\"\n)\n\nfunc SetupServer() {\n    r := gin.Default()\n    cache := make(map[string]time.Time)\n    r.GET(\"/cache_ping\", func(c *gin.Context) {\n        if timestamp, exists := cache[\"cache_ping\"]; exists {\n            if time.Since(timestamp) < time.Minute {\n                c.JSON(200, gin.H{\"message\": \"pong\", \"timestamp\": timestamp.Unix()})\n                return\n            }\n        }\n        now := time.Now()\n        cache[\"cache_ping\"] = now\n        c.JSON(200, gin.H{\"message\": \"pong\", \"timestamp\": now.Unix()})\n    })\n    r.Run(\":8080\")\n}"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint to handle and respond to header data.\n\nFunction Description: The function initializes a Gin router with default middleware, registers a GET handler for the root path (\"/\"), processes incoming request headers, and returns a JSON response containing specific header values. The server listens on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but processes HTTP request headers internally)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\th := testHeader{}\n\n\t\tif err := c.ShouldBindHeader(&h); err != nil {\n\t\t\tc.JSON(http.StatusOK, err)\n\t\t}\n\n\t\tfmt.Printf(\"%#v\\n\", h)\n\t\tc.JSON(http.StatusOK, gin.H{\"Rate\": h.Rate, \"Domain\": h.Domain})\n\t})\n\n\tr.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n    \"github.com/gin-gonic/gin\"\n    \"net/http\"\n)\n\nfunc SetupServer() {\n    r := gin.Default()\n    r.GET(\"/\", func(c *gin.Context) {\n        headers := make(map[string]string)\n        for k, v := range c.Request.Header {\n            headers[k] = v[0]\n        }\n        c.JSON(http.StatusOK, headers)\n    })\n    r.Run(\":8080\")\n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a reverse proxy server using Gin framework in Go that forwards incoming HTTP requests to a load-balanced backend server and returns the response to the client.\n\nFunction Description: The main function initializes a Gin HTTP server that acts as a reverse proxy. It handles incoming GET requests, forwards them to a backend server obtained from a load balancer, and returns the backend's response to the client while preserving all headers.\n\nInput:\n- Path parameter: \":path\" (string) - The path component of the URL to be forwarded to the backend server\n- HTTP request headers and body (automatically handled by Gin context)\n\nOutput:\n- HTTP response with:\n  - Status code from backend server (or 500 if proxy fails)\n  - Headers from backend server\n  - Body content from backend server\n- Error logs if any step in the proxying process fails\n\nThe function uses the Gin context (c *gin.Context) to:\n1. Extract the original request\n2. Parse the load-balanced backend address\n3. Modify the request URL to point to the backend\n4. Use HTTP transport to forward the request\n5. Copy backend response headers to client response\n6. Stream the backend response body to the client",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\tproxy, err := url.Parse(getLoadBalanceAddr())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in parse addr: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = proxy.Scheme\n\t\treq.URL.Host = proxy.Host\n\n\t\ttransport := http.DefaultTransport\n\t\tresp, err := transport.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in roundtrip: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\n\t\tfor k, vv := range resp.Header {\n\t\t\tfor _, v := range vv {\n\t\t\t\tc.Header(k, v)\n\t\t\t}\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbufio.NewReader(resp.Body).WriteTo(c.Writer)\n\t\treturn\n\t})\n\n\tif err := r.Run(ReverseServerAddr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar backends = []string{\"http://backend1:8080\", \"http://backend2:8080\"}\nvar currentIndex int\nvar mu sync.Mutex\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/*path\", func(c *gin.Context) {\n\t\tmu.Lock()\n\t\tcurrentIndex = (currentIndex + 1) % len(backends)\n\t\tmu.Unlock()\n\n\t\toriginalRequest := c.Request\n\t\tbackendURL := backends[currentIndex]\n\t\tparsedBackend, err := url.Parse(backendURL)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error parsing backend URL: %v\", err)\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\n\t\toriginalURL := originalRequest.URL\n\t\tnewURL := parsedBackend.ResolveReference(&url.URL{\n\t\t\tPath:     originalURL.Path,\n\t\t\tRawQuery: originalURL.RawQuery,\n\t\t})\n\n\t\tbody, err := io.ReadAll(originalRequest.Body)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading request body: %v\", err)\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\t\toriginalRequest.Body.Close()\n\n\t\tnewRequest, err := http.NewRequest(originalRequest.Method, newURL.String(), bytes.NewBuffer(body))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error creating new request: %v\", err)\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\n\t\tnewRequest.Header = make(http.Header)\n\t\tfor name, values := range originalRequest.Header {\n\t\t\tif name != \"Host\" {\n\t\t\t\tnewRequest.Header[name] = values\n\t\t\t}\n\t\t}\n\t\tnewRequest.Header.Set(\"Host\", parsedBackend.Host)\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(newRequest)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error forwarding request: %v\", err)\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tfor name, values := range resp.Header {\n\t\t\tc.Header(name, values...)\n\t\t}\n\n\t\tc.Status(resp.StatusCode)\n\n\t\t_, err = io.Copy(c.Writer, resp.Body)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error copying response body: %v\", err)\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, save the uploaded file to the server, and return a success message with the file details and form fields.\n\nFunction Description: The function initializes a Gin router, configures it to handle multipart form uploads (with a maximum size limit), serves static files from a public directory, and sets up a POST endpoint for file uploads. The endpoint binds the incoming request to a struct containing the file and form fields, saves the file to the server, and returns a success message with the file name and form field values.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it sends HTTP responses through the Gin context)\n\nNote: The function assumes the existence of a `BindFile` struct type which should contain at least these fields:\n- File: *multipart.FileHeader - The uploaded file\n- Name: string - A form field value\n- Email: string - A form field value",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\n\t\tif err := c.ShouldBind(&bindFile); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfile := bindFile.File\n\t\tdst := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"upload file err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, bindFile.Name, bindFile.Email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype BindFile struct {\n\tFile *multipart.FileHeader `form:\"file\"`\n\tName string `form:\"name\"`\n\tEmail string `form:\"email\"`\n}\n\nfunc SetupGinServer() {\n\tengine := gin.Default()\n\tengine.MaxMultipartMemory = 8 << 20 // 8 MB\n\tengine.Static(\"/public\", \"./public\")\n\tengine.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\t\tif err := c.Bind(&bindFile); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tfile := bindFile.File\n\t\tif file == nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"no file uploaded\"})\n\t\t\treturn\n\t\t}\n\t\tdst := \"./uploads/\" + file.Filename\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"file_name\": file.Filename,\n\t\t\t\"name\": bindFile.Name,\n\t\t\t\"email\": bindFile.Email,\n\t\t})\n\t})\n\tengine.Run(\":8080\")\n}"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests for inventory operations, specifically for trying inventory items. The server should parse JSON input, process the inventory try operation, and return appropriate JSON responses.\n\nFunction Description: The main function sets up a Gin HTTP server with a single POST endpoint \"/service-c/try\" that accepts JSON inventory data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- HTTP POST request with JSON body containing inventory data (structure not shown in reference code but implied to have an ID field)\n- Gin context object providing request/response capabilities\n\nOutput:\n- Success case (200 status):\n  ```json\n  {\n    \"success\": true,\n    \"message\": \"inventory [ID] tried!\"\n  }\n  ```\n- Error case (400 status):\n  ```json\n  {\n    \"success\": false,\n    \"message\": \"[error description]\"\n  }\n  ```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-c/try\", func(context *gin.Context) {\n\t\tinv := &Inventory{}\n\t\terr := context.BindJSON(inv)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"inventory %d tried!\", inv.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"inventory %d tried!\", inv.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8082\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Inventory struct {\n\tID string `json:\"id\"`\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/service-c/try\", func(c *gin.Context) {\n\t\tvar inventory Inventory\n\t\tif err := c.BindJSON(&inventory); err != nil {\n\t\t\tc.AbortWithStatusJSON(400, gin.H{\n\t\t\t\t\"success\": false,\n\t\t\t\t\"message\": err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif inventory.ID == \"\" {\n\t\t\tc.AbortWithStatusJSON(400, gin.H{\n\t\t\t\t\"success\": false,\n\t\t\t\t\"message\": \"ID is required\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(200, gin.H{\n\t\t\t\"success\": true,\n\t\t\t\"message\": fmt.Sprintf(\"inventory %s tried!\", inventory.ID),\n\t\t})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, and serves static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling multipart form uploads. It processes uploaded files along with name and email form fields, saves the files to the server, and returns a success message.\n\nInput: None (The function takes no direct input parameters but handles HTTP requests with the following expected inputs:\n- POST /upload requests containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - Multipart files: \"files\" (array of files)\n- GET requests for static files from the \"./public\" directory)\n\nOutput: None (The function doesn't return any value but produces the following outputs:\n- For successful uploads: HTTP 200 response with success message\n- For errors: HTTP 400 responses with error messages\n- Static file serving for requests to the root path)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc SetupServer() {\n\trouter := gin.Default()\n\n\trouter.Static(\"/public\", \"./public\")\n\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tif err := c.Request.ParseMultipartForm(10 << 20); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to parse form\"})\n\t\t\treturn\n\t\t}\n\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tif name == \"\" || email == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"Missing name or email\"})\n\t\t\treturn\n\t\t}\n\n\t\tfiles := c.MultipartForm.File[\"files\"]\n\t\tif len(files) == 0 {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"No files uploaded\"})\n\t\t\treturn\n\t\t}\n\n\t\tif err := os.MkdirAll(\"uploads\", os.ModePerm); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create upload directory\"})\n\t\t\treturn\n\t\t}\n\n\t\tfor _, file := range files {\n\t\t\tsrc, err := file.Open()\n\t\t\tif err != nil {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to open file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer src.Close()\n\n\t\t\tdstPath := \"uploads/\" + file.Filename\n\t\t\tdst, err := os.Create(dstPath)\n\t\t\tif err != nil {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dst.Close()\n\n\t\t\tif _, err := io.Copy(dst, src); err != nil {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"Files uploaded successfully\",\n\t\t\t\"name\":    name,\n\t\t\t\"email\":   email,\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but the server configuration is hardcoded in the function)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The static file directory (\"/tmp\") and server port (\":8080\") are hardcoded in this implementation but could be made configurable through parameters in a more flexible version.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/static\", \"/tmp\")\n\trouter.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello, World!\"})\n\t})\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic string response.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler for the \"/ping\" endpoint, and starts the server on the default port (8080). When a GET request is made to \"/ping\", it responds with the string \"pong\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything; it starts an HTTP server that runs until interrupted)",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n    router := gin.Default()\n    router.GET(\"/ping\", func(c *gin.Context) {\n        c.String(200, \"pong\")\n    })\n    router.Run(\":8080\")\n}"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, which includes session management using Redis for storing and incrementing a counter value.\n\nFunction Description: The function sets up a Gin web server with Redis-based session management. It provides a single endpoint \"/incr\" that increments a counter stored in the session and returns the current count in JSON format. The server runs on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly, but sends JSON responses to HTTP requests and runs the web server indefinitely)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/go-redis/redis/v8\"\n    \"github.com/gin-contrib/sessions\"\n    \"github.com/gin-contrib/sessions/redis\"\n    \"net/http\"\n)\n\nfunc SetupServer() {\n    rdb := redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\",\n        DB:       0,\n    })\n\n    store := redis.NewStore(rdb, \"session\", []byte(\"secret\"))\n\n    r := gin.Default()\n    r.Use(sessions.Sessions(\"session\", store))\n\n    r.POST(\"/incr\", func(c *gin.Context) {\n        session := sessions.Default(c)\n        count := session.Get(\"count\")\n        if count == nil {\n            count = 1\n        } else {\n            count = count.(int) + 1\n        }\n        session.Set(\"count\", count)\n        session.Save()\n        c.JSON(http.StatusOK, gin.H{\"count\": count})\n    })\n\n    r.Run(\":8000\")\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses to clients and runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"strconv\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Use(gin.Gzip())\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\ttimestamp := time.Now().Unix()\n\t\tc.String(http.StatusOK, \"pong\\n\"+strconv.FormatInt(timestamp, 10))\n\t})\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint. The endpoint should accept a name parameter, make a gRPC call to a Greeter service, and return the response as JSON. The function should handle both successful responses and errors from the gRPC call.\n\nFunction Description: The function initializes a Gin router with default middleware, establishes a gRPC connection to a Greeter service, and defines a GET endpoint at \"/rest/n/:name\". When called, the endpoint extracts the name parameter, makes a gRPC call to the Greeter service, and returns either the greeting message or an error in JSON format. The server listens on port 8080.\n\nInput: None (The function takes no direct input parameters but relies on incoming HTTP requests to the defined endpoint)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/gin-gonic/examples/grpc/example1/gen/helloworld/v1\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := v1.NewGreeterClient(conn)\n\n\tr := gin.Default()\n\tr.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\n\t\treq := &v1.HelloRequest{Name: name}\n\t\tres, err := client.SayHello(c, req)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"error\": err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"result\": fmt.Sprint(res.Message),\n\t\t})\n\t})\n\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"could not run server: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n\t\"your.package.greeter\"\n)\n\nfunc SetupServer() {\n\trouter := gin.Default()\n\trouter.Use(gin.Recovery())\n\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := greeter.NewGreeterClient(conn)\n\n\trouter.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tresp, err := client.SayHello(ctx, &greeter.HelloRequest{Name: name})\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(200, gin.H{\"message\": resp.Message})\n\t})\n\n\trouter.Run(\":8080\")\n}"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles user management with versioned API endpoints and authentication middleware.\n\nFunction Description: The main function initializes a Gin router with versioned API endpoints (/v1 and /v2) for user management. Each version has public GET endpoints and protected POST endpoints that require authentication through middleware.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8081)\n\nMethods:\n\nAuthMiddleWare: () -> gin.HandlerFunc - Returns a Gin middleware function that handles authentication for protected routes\nAddV1User: (*gin.Context) -> None - Handles POST requests to add users for API version 1\nAddV2User: (*gin.Context) -> None - Handles POST requests to add users for API version 2",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tapiV1 := router.Group(\"/v1\")\n\n\tapiV1.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V1 Users\")\n\t})\n\n\tauthV1 := apiV1.Group(\"/\", AuthMiddleWare())\n\n\tauthV1.POST(\"users/add\", AddV1User)\n\n\tapiV2 := router.Group(\"/v2\")\n\n\tapiV2.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V2 Users\")\n\t})\n\n\tauthV2 := apiV2.Group(\"/\", AuthMiddleWare())\n\n\tauthV2.POST(\"users/add\", AddV2User)\n\n\t_ = router.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tv1 := r.Group(\"/v1\")\n\tv2 := r.Group(\"/v2\")\n\n\tv1.GET(\"/users\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Public GET for v1\"})\n\t})\n\n\tv2.GET(\"/users\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Public GET for v2\"})\n\t})\n\n\tv1.POST(\"/users\", AuthMiddleware(), AddV1User)\n\tv2.POST(\"/users\", AuthMiddleware(), AddV2User)\n\n\tr.Run(\":8081\")\n}\n\nfunc AuthMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttoken := c.GetHeader(\"Authorization\")\n\t\tif token != \"Bearer secret\" {\n\t\t\tc.AbortWithStatus(401)\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc AddV1User(c *gin.Context) {\n\tc.JSON(201, gin.H{\"message\": \"User added in v1\"})\n}\n\nfunc AddV2User(c *gin.Context) {\n\tc.JSON(201, gin.H{\"message\": \"User added in v2\"})\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, with endpoints for basic operations including ping, info retrieval, and counter manipulation with thread-safe increment/reset functionality.\n\nFunction Description: The Run function initializes a Gin HTTP server with four API endpoints under the \"/api/v1\" route group. It handles concurrent counter operations safely using mutex locks and logs requests using klog. The server runs on the specified address from the Options parameter.\n\nInput: \n- op *Options: A pointer to an Options struct containing the ListenAddr field specifying the server's listening address (e.g., \":8080\")\n\nOutput:\n- error: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nStruct Description: (Not applicable as the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\nvar (\n\tCount int\n\tMutex sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.Default()\n\n\tapiv1 := r.Group(\"/api/v1\")\n\t{\n\t\tapiv1.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\")\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"pong\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"app3\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.PUT(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount += 1\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app3: %d\", Count),\n\t\t\t})\n\t\t})\n\n\t\tapiv1.DELETE(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount = 0\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app1: %d\", Count),\n\t\t\t})\n\t\t})\n\t}\n\n\treturn r.Run(op.ListenAddr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n\t\"sync\"\n)\n\ntype Options struct {\n\tListenAddr string\n}\n\ntype Counter struct {\n\tcount int\n\tmu    sync.Mutex\n}\n\nvar counter = &Counter{}\n\nfunc Run(op *Options) error {\n\trouter := gin.Default()\n\n\trouter.Use(func(c *gin.Context) {\n\t\tklog.Infof(\"Request: %s %s\", c.Request.Method, c.Request.URL.Path)\n\t\tc.Next()\n\t})\n\n\tv1 := router.Group(\"/api/v1\")\n\t{\n\t\tv1.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tc.JSON(200, gin.H{\"message\": \"pong\"})\n\t\t})\n\n\t\tv1.GET(\"/info\", func(c *gin.Context) {\n\t\t\tc.JSON(200, gin.H{\"count\": counter.count})\n\t\t})\n\n\t\tv1.POST(\"/counter/increment\", func(c *gin.Context) {\n\t\t\tcounter.mu.Lock()\n\t\t\tcounter.count++\n\t\t\tcounter.mu.Unlock()\n\t\t\tc.JSON(200, gin.H{\"status\": \"incremented\"})\n\t\t})\n\n\t\tv1.POST(\"/counter/reset\", func(c *gin.Context) {\n\t\t\tcounter.mu.Lock()\n\t\t\tcounter.count = 0\n\t\t\tcounter.mu.Unlock()\n\t\t\tc.JSON(200, gin.H{\"status\": \"reset\"})\n\t\t})\n\t}\n\n\tif err := router.Run(op.ListenAddr); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that returns a \"pong\" message with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\":    \"pong\",\n\t\t\t\"timestamp\":  time.Now().Unix(),\n\t\t})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a JSON message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at \"/api/hello\" that returns a JSON response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/api/hello\" endpoint)\n\nOutput: \n- When successful: The server runs indefinitely, listening on port 8080\n- When failing: An error message is printed if the server fails to start\n- HTTP Response: For GET requests to \"/api/hello\", returns a JSON response with status 200 OK: {\"message\": \"Hello, HTTP!\"}",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\n\terr := router.Run(\":8080\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"log\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and the message \"pong [current_unix_timestamp]\" when the \"/ping\" endpoint is accessed)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\ttimestamp := time.Now().Unix()\n\t\tmsg := \"pong\" + strconv.FormatInt(timestamp, 10)\n\t\tc.String(200, msg)\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with static file serving capabilities and a simple ping endpoint.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), serves static files from a binary filesystem at the \"/static\" route, and sets up a GET endpoint at \"/ping\" that returns a simple text response. The server listens on port 8080.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\tassetfs \"github.com/elazarl/go-bindata-assetfs\"\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.Use(static.Serve(\"/static\", BinaryFileSystem(\"data\")))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t}\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc StartServer() {\n\tr := gin.Default()\n\tr.Static(\"/static\", \"./static\")\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server that sends responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tts := time.Now().Unix()\n\t\tc.String(200, \"pong\"+strconv.FormatInt(ts, 10))\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements a simple session-based counter. The server should increment and return a counter value with each request, storing the count in a session.\n\nFunction Description: The main function initializes a Gin server with session middleware, sets up a route handler for GET requests at \"/incr\" that increments and returns a session-based counter, and starts the server on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value, but starts an HTTP server that responds to requests with JSON containing the current count, e.g., {\"count\": 5})",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/cookie\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tstore := cookie.NewStore([]byte(\"secret_key\"))\n\tr.Use(sessions.Sessions(\"my-session\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tcount, ok := session.Get(\"count\").(int)\n\t\tif !ok {\n\t\t\tcount = 0\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save(c.Request, c.Writer)\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Implement a JWT-based authentication service using Gin framework in Go, which provides public endpoints for token generation and private endpoints that require valid JWT tokens for access.\n\nFunction Description: The main function sets up a Gin HTTP server with JWT authentication. It creates two route groups: a public group for token generation and a private group that requires JWT authentication. The public endpoint generates JWT tokens, while the private endpoint demonstrates protected access.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests with the following possible inputs:\n- GET request to \"/api/\" for token generation\n- GET request to \"/api/private/\" for accessing protected content)\n\nOutput: HTTP responses with the following possible outputs:\n- For \"/api/\": JSON response containing a JWT token or error message\n- For \"/api/private/\": JSON response with protected content or authentication error\n- The server runs continuously on localhost:8080",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\nfunc GenerateToken(username string) (string, error) {\n\tclaims := jwt.MapClaims{\n\t\t\"username\": username,\n\t\t\"exp\":      time.Now().Add(time.Hour).Unix(),\n\t}\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString([]byte(\"my-secret-key\"))\n}\n\nfunc JWTAuthMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.AbortWithStatusJSON(401, gin.H{\"error\": \"Missing token\"})\n\t\t\treturn\n\t\t}\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method\")\n\t\t\t}\n\t\t\treturn []byte(\"my-secret-key\"), nil\n\t\t})\n\n\t\tif err != nil || !token.Valid {\n\t\t\tc.AbortWithStatusJSON(401, gin.H{\"error\": \"Invalid token\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/api/\", func(c *gin.Context) {\n\t\ttoken, err := GenerateToken(\"user\")\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(500, gin.H{\"error\": \"Failed to generate token\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": token})\n\t})\n\n\tprivateGroup := r.Group(\"/api/private/\")\n\tprivateGroup.Use(JWTAuthMiddleware())\n\tprivateGroup.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Protected content\"})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests to a specific endpoint, processes JSON input, and returns appropriate JSON responses.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint \"/service-b/try\" that receives JSON account data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- None (the function takes no direct input parameters, but receives HTTP requests with JSON payloads matching the Account struct format)\n\nOutput:\n- None (the function doesn't return any value directly, but sends HTTP responses with JSON bodies containing either success or error messages)\n\nNote: The Account struct (not shown in reference code) would typically contain at least an ID field to be properly processed by this endpoint.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-b/try\", func(context *gin.Context) {\n\t\taccount := &Account{}\n\t\terr := context.BindJSON(account)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"account %d tried!\", account.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"account %d tried!\", account.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Account struct {\n\tID int `json:\"id\"`\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/service-b/try\", func(c *gin.Context) {\n\t\tvar account Account\n\t\tif err := c.BindJSON(&account); err != nil {\n\t\t\tc.JSON(400, gin.H{\"error\": \"Invalid JSON payload\"})\n\t\t\treturn\n\t\t}\n\t\tif account.ID <= 0 {\n\t\t\tc.JSON(400, gin.H{\"error\": \"Invalid account ID\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(200, gin.H{\"success\": true, \"message\": \"Account processed\", \"id\": account.ID})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles file uploads, saves them to a specified directory, and returns the file URL.\n\nFunction Description: The main function initializes a Gin HTTP server with file upload capabilities. It sets up a static file server for serving uploaded files and implements a POST endpoint for uploading files. The server saves uploaded files with unique names and returns their access URLs.\n\nInput: \n- HTTP POST request with multipart/form-data containing a file field named \"file\"\n- File content in the request body\n\nOutput:\n- JSON response containing:\n  - Status code (0 for success, non-zero for errors)\n  - Message describing the operation result\n  - Data object containing the URL to access the uploaded file (on success)\n  OR\n  - Error message (on failure)\n\nThe server runs on port 8085 and serves static files from \"/root/file/\" directory. Uploaded files are saved with names formatted as \"timestamp-randomstring.extension\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"gim/pkg/util\"\n)\n\nconst baseUrl = \"http://111.229.238.28:8085/file/\"\n\ntype Response struct {\n\tCode    int         `json:\"code\"`\n\tMessage string      `json:\"message\"`\n\tData    interface{} `json:\"data\"`\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/file\", \"/root/file\")\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfilenames := strings.Split(file.Filename, \".\")\n\t\tname := strconv.FormatInt(time.Now().UnixNano(), 10) + \"-\" + util.RandString(30) + \".\" + filenames[len(filenames)-1]\n\t\tfilePath := \"/root/file/\" + name\n\t\terr = c.SaveUploadedFile(file, filePath)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, Response{\n\t\t\tCode:    0,\n\t\t\tMessage: \"success\",\n\t\t\tData:    map[string]string{\"url\": baseUrl + name},\n\t\t})\n\t})\n\terr := router.Run(\":8085\")\n\tif err != nil {\n\t\tlogger.Logger.Error(\"Run error\", zap.Error(err))\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\t\"crypto/rand\"\n\t\"math/big\"\n)\n\nfunc generateRandomString(length int) string {\n\tconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\tresult := make([]byte, length)\n\tfor i := 0; i < length; i++ {\n\t\trandNum, _ := rand.Int(rand.Reader, big.NewInt(int64(len(letters))))\n\t\tresult[i] = letters[randNum.Int64()]\n\t}\n\treturn string(result)\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tuploadDir := \"./root/file\"\n\tif _, err := os.Stat(uploadDir); os.IsNotExist(err) {\n\t\tos.MkdirAll(uploadDir, os.ModePerm)\n\t}\n\tr.Static(\"/file\", uploadDir)\n\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tc.Request.ParseMultipartForm(10 << 20)\n\t\tfile, err := c.Request.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"status\": 1,\n\t\t\t\t\"message\": \"Failed to retrieve file\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tif file.Size() == 0 {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"status\": 1,\n\t\t\t\t\"message\": \"File is empty\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\toriginalFilename := file.Filename\n\t\tlastDot := strings.LastIndex(originalFilename, \".\")\n\t\tif lastDot == -1 {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"status\": 1,\n\t\t\t\t\"message\": \"Invalid filename\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\textension := originalFilename[lastDot:]\n\n\t\ttimestamp := time.Now().UnixNano()\n\t\trandomStr := generateRandomString(8)\n\t\tuniqueFilename := fmt.Sprintf(\"%d-%s%s\", timestamp, randomStr, extension)\n\n\t\tfilePath := filepath.Join(uploadDir, uniqueFilename)\n\t\toutFile, err := os.Create(filePath)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"status\": 1,\n\t\t\t\t\"message\": \"Failed to create file\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tdefer outFile.Close()\n\n\t\tif _, err := io.Copy(outFile, file); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"status\": 1,\n\t\t\t\t\"message\": \"Failed to save file\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\turl := fmt.Sprintf(\"http://localhost:8085/file/%s\", uniqueFilename)\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"status\": 0,\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"data\": gin.H{\n\t\t\t\t\"url\": url,\n\t\t\t},\n\t\t})\n\t})\n\n\tr.Run(\":8085\")\n}"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements JWT-based authentication with public and private routes. The server should generate tokens for public access and validate them for private routes.\n\nFunction Description: The main function sets up a Gin server with two route groups: public routes that generate JWT tokens, and private routes that require valid JWT tokens for access. The server runs on localhost:8080.\n\nInput: None (The function takes no direct input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens for requests)\n\nMethods:\n\n1. Public route handler: Handles GET requests to \"/api/\" and generates a JWT token\n   - Input: Gin context object\n   - Output: JSON response containing either the token or an error message\n\n2. Private route handler: Handles GET requests to \"/api/private/\" and requires valid JWT\n   - Input: Gin context object (with validated JWT)\n   - Output: JSON response with a private message\n\n3. Server startup: Starts the Gin server on port 8080\n   - Input: Address string (\"localhost:8080\")\n   - Output: None (blocks and serves requests)",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tsecret := \"secret_key\"\n\n\tr.GET(\"/api/\", func(c *gin.Context) {\n\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\t\"user\": \"test\",\n\t\t})\n\t\tsignedToken, _ := token.SignedString([]byte(secret))\n\t\tc.JSON(http.StatusOK, gin.H{\"token\": signedToken})\n\t})\n\n\tauthMiddleware := func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Missing token\"})\n\t\t\treturn\n\t\t}\n\t\ttokenParts := strings.Split(tokenString, \" \")\n\t\tif len(tokenParts) != 2 || tokenParts[0] != \"Bearer\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token format\"})\n\t\t\treturn\n\t\t}\n\t\ttokenString = tokenParts[1]\n\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected signing method\")\n\t\t\t}\n\t\t\treturn []byte(secret), nil\n\t\t})\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\treturn\n\t\t}\n\t\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\t\tc.Next()\n\t\t} else {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t}\n\t}\n\n\tr.GET(\"/api/private/\", authMiddleware, func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Private message\"})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with custom template delimiters and a date formatting function, serving HTML content from a template file.\n\nFunction Description: The function initializes a Gin router with custom template delimiters \"{[{\" and \"}]}\", registers a template formatting function \"formatAsDate\", loads an HTML template file, and sets up a GET route handler that renders the template with a predefined date value. The server listens on port 8080.\n\nInput: None (The function takes no input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Delims(\"{[{\", \"}]}\")\n\trouter.SetFuncMap(template.FuncMap{\n\t\t\"formatAsDate\": formatAsDate,\n\t})\n\trouter.LoadHTMLFiles(\"./testdata/raw.tmpl\")\n\n\trouter.GET(\"/raw\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"raw.tmpl\", gin.H{\n\t\t\t\"now\": time.Date(2017, 0o7, 0o1, 0, 0, 0, 0, time.UTC),\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"html/template\"\n)\n\nfunc main() {\n\tengine := gin.Default()\n\tengine.SetDelims(\"{[{\", \"}]}\")\n\tengine.SetFuncMap(template.FuncMap{\n\t\t\"formatAsDate\": func(t time.Time) string {\n\t\t\treturn t.Format(\"2006-01-02\")\n\t\t},\n\t})\n\tengine.LoadHTMLGlob(\"template.html\")\n\tengine.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(200, \"template.html\", gin.H{\n\t\t\t\"date\": time.Now(),\n\t\t})\n\t})\n\tengine.Run(\":8080\")\n}"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that serves HTML templates, static files, and a favicon, with routes for the main page and a foo page.\n\nFunction Description: The main function initializes a Gin router, sets up HTML templates from embedded files, serves static files, defines route handlers for the root path (\"/\"), \"/foo\" path, and favicon, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but relies on embedded filesystem content for templates and assets)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)\n\nNote: The implementation assumes the existence of an embedded filesystem (variable 'f' of type embed.FS) containing template files in \"templates/\" and \"templates/foo/\" directories, and assets in an \"assets/\" directory.",
    "Canonical_solution": "import (\n\t\"embed\"\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\ttempl := template.Must(template.New(\"\").ParseFS(f, \"templates/*.tmpl\", \"templates/foo/*.tmpl\"))\n\trouter.SetHTMLTemplate(templ)\n\n\trouter.StaticFS(\"/public\", http.FS(f))\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n\t\t\t\"title\": \"Main website\",\n\t\t})\n\t})\n\n\trouter.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"bar.tmpl\", gin.H{\n\t\t\t\"title\": \"Foo website\",\n\t\t})\n\t})\n\n\trouter.GET(\"favicon.ico\", func(c *gin.Context) {\n\t\tfile, _ := f.ReadFile(\"assets/favicon.ico\")\n\t\tc.Data(\n\t\t\thttp.StatusOK,\n\t\t\t\"image/x-icon\",\n\t\t\tfile,\n\t\t)\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"embed\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\n//go:embed templates/* templates/foo/* assets/*\nvar f embed.FS\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.LoadHTMLFiles(\"templates/index.html\", \"templates/foo/index.html\")\n\tr.StaticFS(\"/assets\", http.FS(f))\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.html\", nil)\n\t})\n\tr.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"foo/index.html\", nil)\n\t})\n\tr.StaticFile(\"/favicon.ico\", \"assets/favicon.ico\")\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, serving static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling file uploads with additional form fields. It validates the upload, saves the file, and returns a success message with the form data.\n\nInput: None (The function takes no direct input parameters but processes HTTP requests with the following expected form data:\n- \"name\": string - Name field from the form\n- \"email\": string - Email field from the form\n- \"file\": file - File to be uploaded)\n\nOutput: None (The function doesn't return any value but sends HTTP responses:\n- Success: HTTP 200 with upload confirmation message\n- Error: HTTP 400 with error message for invalid requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfilename := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, \"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc SetupServer() {\n\tr := gin.Default()\n\tr.StaticFS(\"/public\", http.Dir(\"public\"))\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tc.Request.ParseMultipartForm(10 << 20)\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\t\tfile, err := c.FormFile(\"file\")\n\n\t\tif name == \"\" || email == \"\" || err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"missing fields\"})\n\t\t\treturn\n\t\t}\n\n\t\tif file == nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"no file uploaded\"})\n\t\t\treturn\n\t\t}\n\n\t\tif _, err := os.Stat(\"uploads\"); os.IsNotExist(err) {\n\t\t\tif err := os.MkdirAll(\"uploads\", os.ModePerm); err != nil {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to create uploads directory\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tdst := \"uploads/\" + file.Filename\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"failed to save file\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\":  \"File uploaded successfully\",\n\t\t\t\"name\":     name,\n\t\t\t\"email\":    email,\n\t\t\t\"filename\": file.Filename,\n\t\t})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves a static favicon file and responds to a GET request with a text message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), serves a static favicon file, registers a GET route handler, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but sends responses to HTTP requests and runs the server indefinitely)\n\nNote: The instruction is for function-level code as the reference code shows a main function implementation rather than a struct/class implementation.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tapp := gin.Default()\n\n\tapp.StaticFile(\"/favicon.ico\", \"./favicon.ico\")\n\n\tapp.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello favicon.\")\n\t})\n\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.StaticFile(\"/favicon.ico\", \"static/favicon.ico\")\n\tr.GET(\"/message\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello from Gin!\")\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Go function that initializes and configures a Gin HTTP server with New Relic monitoring middleware, and defines a simple route handler.\n\nFunction Description: The function sets up a basic Gin web server with default middleware (Logger and Recovery), configures New Relic monitoring if environment variables are present, and registers a root route handler that returns \"Hello World!\". The server runs on the default port (8080).\n\nInput: None (uses environment variables APP_NAME and NEW_RELIC_API_KEY for optional New Relic configuration)\n\nOutput: None (starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/newrelic/go-agent\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tcfg := newrelic.NewConfig(os.Getenv(\"APP_NAME\"), os.Getenv(\"NEW_RELIC_API_KEY\"))\n\tapp, err := newrelic.NewApplication(cfg)\n\tif err != nil {\n\t\tlog.Printf(\"failed to make new_relic app: %v\", err)\n\t} else {\n\t\trouter.Use(NewRelicMonitoring(app))\n\t}\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello World!\\n\")\n\t})\n\trouter.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/newrelic/go-agent/v3/newrelic\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc InitializeServer() {\n\tengine := gin.Default()\n\n\tapiKey := os.Getenv(\"NEW_RELIC_API_KEY\")\n\tif apiKey != \"\" {\n\t\tapp, err := newrelic.NewApplication(newrelic.Config{\n\t\t\tLicenseKey: apiKey,\n\t\t\tAppName:    os.Getenv(\"APP_NAME\"),\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to initialize New Relic: %v\", err)\n\t\t}\n\t\tengine.Use(newrelic.CreateHandler(app))\n\t}\n\n\tengine.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello World!\")\n\t})\n\n\tif err := engine.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at the \"/ping\" endpoint that responds with \"pong\", and starts the server on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends \"pong\" as a response to GET requests at \"/ping\" and runs the HTTP server continuously until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- None (The function takes no parameters as it's the main entry point)\n\nOutput: \n- None (The function doesn't return but runs an HTTP server indefinitely or until fatal error)\n\nNote: The function uses autotls.Run() which automatically obtains and renews TLS certificates from Let's Encrypt for the specified domains. The server will listen on both HTTP (port 80) and HTTPS (port 443) ports.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/xtaci/autotls\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tautotls.Run(router, []string{\"example.com\"})\n}"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that provides translation services through the DeepLX API. The server should handle GET and POST requests, implement authentication middleware, and support proxy configuration.\n\nFunction Description: The main function initializes a Gin HTTP server with CORS support, sets up routes for translation services, and starts the server on a specified port. It includes:\n1. Configuration initialization\n2. Proxy setup (if configured)\n3. Route handlers for root (/) and translation (/translate) endpoints\n4. Authentication middleware for protected routes\n5. Translation request processing and response handling\n\nInput:\n- Configuration parameters (IP, Port, Proxy, Token) from initConfig()\n- Environment variable PROXY (optional)\n- HTTP requests:\n  * GET / - Returns server information\n  * POST /translate - Accepts JSON payload with translation parameters\n\nOutput:\n- HTTP responses:\n  * For GET /: JSON response with server information\n  * For POST /translate: JSON response with translation results or error message\n- Console output: Server startup message and configuration status\n\nStruct Description: (Not applicable - the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\n\ttranslate \"github.com/OwO-Network/DeepLX/translate\"\n\t\"github.com/gin-contrib/cors\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tcfg := initConfig()\n\n\tfmt.Printf(\"DeepL X has been successfully launched! Listening on %v:%v\\n\", cfg.IP, cfg.Port)\n\tfmt.Println(\"Developed by sjlleo <i@leo.moe> and missuo <me@missuo.me>.\")\n\n\tproxyURL := os.Getenv(\"PROXY\")\n\tif proxyURL == \"\" {\n\t\tproxyURL = cfg.Proxy\n\t}\n\tif proxyURL != \"\" {\n\t\tproxy, err := url.Parse(proxyURL)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to parse proxy URL: %v\", err)\n\t\t}\n\t\thttp.DefaultTransport = &http.Transport{\n\t\t\tProxy: http.ProxyURL(proxy),\n\t\t}\n\t}\n\n\tif cfg.Token != \"\" {\n\t\tfmt.Println(\"Access token is set.\")\n\t}\n\n\tgin.SetMode(gin.ReleaseMode)\n\tr := gin.Default()\n\tr.Use(cors.Default())\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"code\":    http.StatusOK,\n\t\t\t\"message\": \"DeepL Free API, Developed by sjlleo and missuo. Go to /translate with POST. http://github.com/OwO-Network/DeepLX\",\n\t\t})\n\t})\n\n\tr.POST(\"/translate\", authMiddleware(cfg), func(c *gin.Context) {\n\t\treq := PayloadFree{}\n\t\tc.BindJSON(&req)\n\n\t\tsourceLang := req.SourceLang\n\t\ttargetLang := req.TargetLang\n\t\ttranslateText := req.TransText\n\t\ttagHandling := req.TagHandling\n\n\t\tproxyURL := cfg.Proxy\n\n\t\tif tagHandling != \"\" && tagHandling != \"html\" && tagHandling != \"xml\" {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"code\":    http.StatusBadRequest,\n\t\t\t\t\"message\": \"Invalid tag_handling value. Allowed values are 'html' and 'xml'.\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tresult, err := translate.TranslateByDeepLX(sourceLang, targetLang, translateText, tagHandling, proxyURL, \"\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Translation failed: %s\", err)\n\t\t}\n\n\t\tif result.Code == http.StatusOK {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":         http.StatusOK,\n\t\t\t\t\"id\":           result.ID,\n\t\t\t\t\"data\":         result.Data,\n\t\t\t\t\"alternatives\": result.Alternatives,\n\t\t\t\t\"source_lang\":  result.SourceLang,\n\t\t\t\t\"target_lang\":  result.TargetLang,\n\t\t\t\t\"method\":       result.Method,\n\t\t\t})\n\t\t} else {\n\t\t\tc.JSON(result.Code, gin.H{\n\t\t\t\t\"code\":    result.Code,\n\t\t\t\t\"message\": result.Message,\n\t\t\t})\n\t\t}\n\t})\n\n\tr.Run(fmt.Sprintf(\"%v:%v\", cfg.IP, cfg.Port))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Config struct {\n\tIP      string\n\tPort    string\n\tProxy   string\n\tToken   string\n}\n\nfunc initConfig() Config {\n\treturn Config{\n\t\tIP:      os.Getenv(\"IP\"),\n\t\tPort:    os.Getenv(\"PORT\"),\n\t\tProxy:   os.Getenv(\"PROXY\"),\n\t\tToken:   os.Getenv(\"TOKEN\"),\n\t}\n}\n\nfunc CORS() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tc.Header(\"Access-Control-Allow-Origin\", \"*\")\n\t\tc.Header(\"Access-Control-Allow-Methods\", \"GET, POST\")\n\t\tc.Header(\"Access-Control-Allow-Headers\", \"Authorization\")\n\t\tc.Next()\n\t}\n}\n\nfunc AuthMiddleware(token string) gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tauthHeader := c.GetHeader(\"Authorization\")\n\t\tif !strings.HasPrefix(authHeader, \"Bearer \"+token) {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc main() {\n\tconfig := initConfig()\n\trouter := gin.Default()\n\trouter.Use(CORS())\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\":  \"Translation Server\",\n\t\t\t\"version\":  \"1.0.0\",\n\t\t\t\"port\":     config.Port,\n\t\t\t\"ip\":       config.IP,\n\t\t\t\"proxy\":    config.Proxy != \"\",\n\t\t\t\"auth\":     config.Token != \"\",\n\t\t})\n\t})\n\n\trouter.POST(\"/translate\", AuthMiddleware(config.Token), func(c *gin.Context) {\n\t\tvar reqBody struct {\n\t\t\tText        string `json:\"text\"`\n\t\t\tSourceLang  string `json:\"source_lang\"`\n\t\t\tTargetLang  string `json:\"target_lang\"`\n\t\t}\n\t\tif err := c.ShouldBindJSON(&reqBody); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request body\"})\n\t\t\treturn\n\t\t}\n\n\t\tif reqBody.Text == \"\" || reqBody.SourceLang == \"\" || reqBody.TargetLang == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"Missing required fields\"})\n\t\t\treturn\n\t\t}\n\n\t\tproxyURL := \"\"\n\t\tif config.Proxy != \"\" {\n\t\t\tparsedProxy, _ := url.Parse(config.Proxy)\n\t\t\tproxyURL = parsedProxy.String()\n\t\t}\n\n\t\tclient := &http.Client{}\n\t\tif proxyURL != \"\" {\n\t\t\tproxy, _ := url.Parse(config.Proxy)\n\t\t\tclient.Transport = &http.Transport{\n\t\t\t\tProxy: http.ProxyURL(proxy),\n\t\t\t}\n\t\t}\n\n\t\tdeeplxURL := \"https://api.deeplx.com/translate\"\n\t\treq, _ := http.NewRequest(\"POST\", deeplxURL, bytes.NewBuffer([]byte(fmt.Sprintf(`{\"text\": \"%s\", \"source_lang\": \"%s\", \"target_lang\": \"%s\"}`, reqBody.Text, reqBody.SourceLang, reqBody.TargetLang))))\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+config.Token)\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to connect to DeepLX API\"})\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tvar result map[string]interface{}\n\t\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to parse response\"})\n\t\t\treturn\n\t\t}\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Translation failed\", \"details\": result})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"translation\": result[\"translation\"]})\n\t})\n\n\tserverAddr := fmt.Sprintf(\"%s:%s\", config.IP, config.Port)\n\tfmt.Println(\"Server starting on\", serverAddr)\n\tif config.Proxy != \"\" {\n\t\tfmt.Println(\"Using proxy:\", config.Proxy)\n\t} else {\n\t\tfmt.Println(\"Proxy not configured\")\n\t}\n\n\trouter.Run(serverAddr)\n}"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles various routes including a ping endpoint, user lookup, and authenticated admin updates.\n\nFunction Description: The main function initializes a Gin web server with default middleware (Logger and Recovery), sets up route handlers for different HTTP methods, and starts the server on port 8080. It includes:\n1. A simple ping/pong endpoint\n2. A user lookup endpoint with path parameters\n3. An authenticated admin endpoint for updating values\n4. Basic authentication middleware for protected routes\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything, but sends HTTP responses to clients)\n\nNote: The code assumes the existence of a global DB map variable (not shown in the reference) for storing user values. The actual implementation would need to include this or an alternative storage mechanism.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tr.GET(\"/user/:name\", func(c *gin.Context) {\n\t\tuser := c.Params.ByName(\"name\")\n\t\tvalue, ok := DB[user]\n\t\tif ok {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"value\": value})\n\t\t} else {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"status\": \"no value\"})\n\t\t}\n\t})\n\n\tauthorized := r.Group(\"/\", gin.BasicAuth(gin.Accounts{\n\t\t\"foo\":  \"bar\",\n\t\t\"manu\": \"123\",\n\t}))\n\n\tauthorized.POST(\"admin\", func(c *gin.Context) {\n\t\tuser := c.MustGet(gin.AuthUserKey).(string)\n\n\t\tvar json struct {\n\t\t\tValue string `json:\"value\" binding:\"required\"`\n\t\t}\n\n\t\tif c.Bind(&json) == nil {\n\t\t\tDB[user] = json.Value\n\t\t\tc.JSON(200, gin.H{\"status\": \"ok\"})\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"encoding/base64\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar DB = map[string]string{}\n\nfunc authMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tauthHeader := c.GetHeader(\"Authorization\")\n\t\tif authHeader == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n\t\t\treturn\n\t\t}\n\t\tparts := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(parts) != 2 || parts[0] != \"Basic\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid auth type\"})\n\t\t\treturn\n\t\t}\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid base64\"})\n\t\t\treturn\n\t\t}\n\t\tcredentials := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(credentials) != 2 || credentials[0] != \"admin\" || credentials[1] != \"password\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid credentials\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\t\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t})\n\t\n\tr.GET(\"/user/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tuser, exists := DB[id]\n\t\tif !exists {\n\t\t\tc.AbortWithStatusJSON(http.StatusNotFound, gin.H{\"error\": \"User not found\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"user\": user})\n\t})\n\t\n\tr.PUT(\"/admin/update\", authMiddleware(), func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Admin update successful\"})\n\t})\n\t\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Create a simple HTTP server in Go using the Gin framework that handles file uploads via POST requests.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint (\"/upload\") that receives and discards uploaded file data, then responds with \"ok\". The server runs on port 8888.\n\nInput: None (The function takes no direct input parameters, but receives HTTP POST requests with file data in the request body)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and body \"ok\" for successful uploads)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tbody := c.Request.Body\n\t\tio.Copy(io.Discard, body)\n\t\tc.String(http.StatusOK, \"ok\")\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tc.Request.ParseMultipartForm(10 << 20)\n\t\t_, _ = c.FormFile(\"file\")\n\t\t_ = c.Request.Body.Close()\n\t\tc.String(200, \"ok\")\n\t})\n\tr.Run(\":8888\")\n}"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but configuration is hardcoded: static files are served from \"/tmp\" and the server listens on port 8080)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Static(\"/\", \"/tmp\")\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, World!\"})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters. HTTP requests to the \"/ping\" endpoint serve as indirect input.)\n\nOutput: None (The function doesn't return any value directly. It sends HTTP responses to clients as output.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gin.Gzip())\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\ttimestamp := time.Now().Unix()\n\t\tc.String(http.StatusOK, \"pong\\n%s\", strconv.FormatInt(timestamp, 10))\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Create a TCP client in Go that establishes a connection to a server, sends a message, and handles the connection lifecycle properly.\n\nFunction Description: The function establishes a TCP connection to a specified server address, sends a predefined message (\"hello\"), and prints the number of bytes written or any error encountered. It ensures the connection is properly closed after use.\n\nInput: None (The server address is hardcoded as \"127.0.0.1:49153\" in this example)\n\nOutput: \n- On success: Prints the number of bytes written to the connection (integer)\n- On failure: Prints the error encountered during connection or writing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n)\n\nfunc main() {\n\tdialer := &net.Dialer{\n\t\tLocalAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\t\tPort: 0,\n\t\t},\n\t}\n\n\tconn, err := dialer.Dial(\"tcp\", \"127.0.0.1:49153\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tt := &wrappedConn{conn}\n\tvar w io.Writer = t\n\tif n, err := w.Write([]byte(\"hello\")); err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(n)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:49153\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tmsg := []byte(\"hello\")\n\tn, err := conn.Write(msg)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(n)\n\t}\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Implement a TCP client function in Go that establishes a connection to a server, sends data, and receives a response.\n\nFunction Description: The function `Tcp` handles TCP communication with a remote server. It establishes a connection, sends optional data, and reads the server's response. Errors are captured and returned in the response structure. The connection is automatically closed when the function completes.\n\nInput: \n- `ctx context.Context`: Context for managing deadlines and cancellation signals\n- `req *pb.TcpRequest`: Request object containing:\n  - `Address string`: The server address to connect to (format \"host:port\")\n  - `Data string`: Optional data to send to the server\n- `rsp *pb.TcpResponse`: Response object to populate with results\n\nOutput:\n- `error`: Returns an error if address validation fails, otherwise nil (errors during TCP operations are stored in the response)\n- Modifies `rsp` with:\n  - `Status string`: \"OK\" on success or error message\n  - `Data string`: Received data from server (if any)",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\tpb \"github.com/micro/services/ping/proto\"\n)\n\nfunc (p *Ping) Tcp(ctx context.Context, req *pb.TcpRequest, rsp *pb.TcpResponse) error {\n\tif len(req.Address) == 0 {\n\t\treturn errors.BadRequest(\"ping.tcp\", \"missing address\")\n\t}\n\n\tc, err := net.Dial(\"tcp\", req.Address)\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\tdefer c.Close()\n\n\tif len(req.Data) == 0 {\n\t\trsp.Status = \"OK\"\n\t\treturn nil\n\t}\n\n\tfmt.Fprint(c, req.Data)\n\n\tdata, err := bufio.NewReader(c).ReadString('\\n')\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\n\trsp.Status = \"OK\"\n\trsp.Data = data\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "import (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"io\"\n\t\"bytes\"\n)\n\nfunc Tcp(ctx context.Context, req *pb.TcpRequest, rsp *pb.TcpResponse) error {\n\tparts := strings.Split(req.Address, \":\")\n\tif len(parts) != 2 {\n\t\trsp.Status = \"Invalid address format\"\n\t\treturn errors.New(\"invalid address format\")\n\t}\n\thost, port := parts[0], parts[1]\n\tif _, err := strconv.Atoi(port); err != nil {\n\t\trsp.Status = \"Invalid port number\"\n\t\treturn errors.New(\"invalid port number\")\n\t}\n\tconn, err := net.DialContext(ctx, \"tcp\", req.Address)\n\tif err != nil {\n\t\trsp.Status = \"Connection failed\"\n\t\trsp.Data = \"\"\n\t\treturn nil\n\t}\n\tdefer conn.Close()\n\tif req.Data != \"\" {\n\t\t_, err = conn.Write([]byte(req.Data))\n\t\tif err != nil {\n\t\t\trsp.Status = \"Send failed\"\n\t\t\trsp.Data = \"\"\n\t\t\treturn nil\n\t\t}\n\t}\n\tvar response bytes.Buffer\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := conn.Read(buffer)\n\t\tif n > 0 {\n\t\t\tresponse.Write(buffer[:n])\n\t\t}\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trsp.Status = \"Read failed\"\n\t\t\trsp.Data = \"\"\n\t\t\treturn nil\n\t\t}\n\t}\n\trsp.Data = response.String()\n\trsp.Status = \"OK\"\n\treturn nil\n}"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Implement a TCP/UDP port scanner with proxy support and configurable source IP addresses.\n\nStruct Description: The Scanner struct provides functionality to check if a specific port is open on a given host, supporting both TCP and UDP protocols. It includes timeout configuration, proxy support, and the ability to specify source IP addresses for the connection.\n\nFields:\n- timeout: time.Duration - Maximum duration to wait for a connection attempt\n- proxyDialer: proxy.Dialer - Optional proxy dialer for making connections through a proxy\n- ListenHandler: *ListenHandler - Configuration for source IP addresses (both IPv4 and IPv6)\n\nMethods:\n- ConnectPort: (host string, p *port.Port, timeout time.Duration) -> (bool, error) - Attempts to connect to the specified port on the given host. Returns true if the port is open/reachable, along with any error that occurred during the connection attempt. The port parameter includes the protocol (TCP/UDP) and port number. The timeout parameter specifies the maximum duration for the connection attempt.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\thostport := net.JoinHostPort(host, fmt.Sprint(p.Port))\n\tvar (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\tif s.proxyDialer != nil {\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t\tproxyDialer, ok := s.proxyDialer.(proxy.ContextDialer)\n\t\tif !ok {\n\t\t\treturn false, errors.New(\"invalid proxy dialer\")\n\t\t}\n\t\tconn, err = proxyDialer.DialContext(ctx, p.Protocol.String(), hostport)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tnetDialer := net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t\tif s.ListenHandler.SourceIp4 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIp4}\n\t\t} else if s.ListenHandler.SourceIP6 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIP6}\n\t\t}\n\t\tconn, err = netDialer.Dial(p.Protocol.String(), hostport)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\tswitch p.Protocol {\n\tcase protocol.UDP:\n\t\tif err := conn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif _, err := conn.Write(nil); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif err := conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tn, err := io.Copy(io.Discard, conn)\n\t\tif err != nil && !os.IsTimeout(err) {\n\t\t\treturn false, err\n\t\t}\n\t\treturn n > 0, nil\n\t}\n\n\treturn true, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype port struct {\n\tProtocol string\n\tPort     int\n}\n\ntype ListenHandler struct {\n\tLocalIP net.IP\n}\n\nfunc (lh *ListenHandler) GetLocalAddr() *net.UDPAddr {\n\tif lh.LocalIP == nil {\n\t\treturn &net.UDPAddr{}\n\t}\n\treturn &net.UDPAddr{IP: lh.LocalIP}\n}\n\ntype ProxyDialer struct {\n\t// Custom proxy dialer implementation\n}\n\nfunc (pd *ProxyDialer) Dial(network, address string) (net.Conn, error) {\n\t// Proxy dialer implementation\n\treturn nil, nil\n}\n\ntype Scanner struct {\n\ttimeout       time.Duration\n\tproxyDialer   *ProxyDialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port, timeout time.Duration) (bool, error) {\n\tprotocol := p.Protocol\n\tportNum := p.Port\n\n\tvar dialer *net.Dialer\n\tif s.proxyDialer != nil {\n\t\tdialer = &net.Dialer{\n\t\t\tTimeout:   timeout,\n\t\t\tLocalAddr: s.ListenHandler.GetLocalAddr(),\n\t\t}\n\t} else {\n\t\tdialer = &net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t}\n\n\tif protocol == \"tcp\" {\n\t\tconn, err := dialer.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", host, portNum))\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tconn.Close()\n\t\treturn true, nil\n\t} else if protocol == \"udp\" {\n\t\tlocalAddr := dialer.LocalAddr\n\t\tif localAddr == nil {\n\t\t\tlocalAddr = &net.UDPAddr{}\n\t\t}\n\t\tremoteAddr := &net.UDPAddr{\n\t\t\tIP:   net.ParseIP(host),\n\t\t\tPort: portNum,\n\t\t}\n\t\tconn, err := net.DialUDP(\"udp\", localAddr, remoteAddr)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdefer conn.Close()\n\n\t\t_, err = conn.Write([]byte{})\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tbuffer := make([]byte, 1024)\n\t\tn, _, err := conn.ReadFrom(buffer)\n\t\tif n > 0 {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\treturn false, fmt.Errorf(\"unsupported protocol: %s\", protocol)\n}"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It holds configuration information and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Pointer to configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC server for the specified realm using TCP. Returns the response or error.\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful. Returns the response or accumulated errors.\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a KDC server, including sending data and reading response. Ensures connection is closed when done.",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"io\"\n\t\"errors\"\n)\n\ntype Config struct {\n\tKDCs map[string][]string\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tkdcs, ok := c.Config.KDCs[realm]\n\tif !ok || len(kdcs) == 0 {\n\t\treturn nil, fmt.Errorf(\"no KDCs found for realm %s\", realm)\n\t}\n\tkdcMap := make(map[int]string)\n\tfor i, addr := range kdcs {\n\t\tkdcMap[i] = addr\n\t}\n\treturn c.dialSendTCP(kdcMap, b)\n}\n\nfunc (c *Client) dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errors []error\n\tvar response []byte\n\n\tfor k, addr := range kdcs {\n\t\tconn, err := net.Dial(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\terrors = append(errors, err)\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\t\ttcpConn := conn.(*net.TCPConn)\n\t\tresp, err := c.sendTCP(tcpConn, b)\n\t\tif err == nil {\n\t\t\treturn resp, nil\n\t\t}\n\t\terrors = append(errors, err)\n\t}\n\n\tif len(errors) > 0 {\n\t\treturn nil, fmt.Errorf(\"failed to connect to any KDC: %v\", errors)\n\t}\n\treturn nil, errors.New(\"no KDCs tried\")\n}\n\nfunc (c *Client) sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\n\tif _, err := conn.Write(b); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response []byte\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tp, err := reader.ReadBytes('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse = append(response, p...)\n\t}\n\treturn response, nil\n}"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP client in Go that establishes a connection to a server, handles data transmission, and manages connection lifecycle with proper error handling and resource cleanup.\n\nStruct Description: The `Client` struct represents a TCP client that connects to a server using a round-robin server selection strategy. It manages server connections, handles policy enforcement, and processes data transmission for both TCP and UDP protocols.\n\nFields:\n- serverPicker: [protocol.ServerPicker] - Selects servers in a round-robin fashion from available server list  \n- policyManager: [policy.Manager] - Manages connection policies including timeouts and user levels\n\nMethods:\n- NewClient: [func(ctx context.Context, config *ClientConfig) (*Client, error)] -> (*Client, error) - Creates a new Client instance with server configurations and policy manager\n- Process: [func(ctx context.Context, link *transport.Link, dialer internet.Dialer) error] -> error - Main processing method that establishes connection, handles handshake, and manages data transfer between client and server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/xtls/xray-core/common\"\n\t\"github.com/xtls/xray-core/common/buf\"\n\t\"github.com/xtls/xray-core/common/errors\"\n\t\"github.com/xtls/xray-core/common/net\"\n\t\"github.com/xtls/xray-core/common/protocol\"\n\t\"github.com/xtls/xray-core/common/retry\"\n\t\"github.com/xtls/xray-core/common/session\"\n\t\"github.com/xtls/xray-core/common/signal\"\n\t\"github.com/xtls/xray-core/common/task\"\n\t\"github.com/xtls/xray-core/core\"\n\t\"github.com/xtls/xray-core/features/policy\"\n\t\"github.com/xtls/xray-core/transport\"\n\t\"github.com/xtls/xray-core/transport/internet\"\n\t\"github.com/xtls/xray-core/transport/internet/stat\"\n)\n\ntype Client struct {\n\tserverPicker  protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tserverList := protocol.NewServerList()\n\tfor _, rec := range config.Server {\n\t\ts, err := protocol.NewServerSpecFromPB(rec)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"failed to get server spec\").Base(err)\n\t\t}\n\t\tserverList.AddServer(s)\n\t}\n\tif serverList.Size() == 0 {\n\t\treturn nil, errors.New(\"0 target server\")\n\t}\n\n\tv := core.MustFromContext(ctx)\n\tc := &Client{\n\t\tserverPicker:  protocol.NewRoundRobinServerPicker(serverList),\n\t\tpolicyManager: v.GetFeature(policy.ManagerType()).(policy.Manager),\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\toutbounds := session.OutboundsFromContext(ctx)\n\tob := outbounds[len(outbounds)-1]\n\tif !ob.Target.IsValid() {\n\t\treturn errors.New(\"target not specified.\")\n\t}\n\tob.Name = \"socks\"\n\tob.CanSpliceCopy = 2\n\tdestination := ob.Target\n\n\tvar server *protocol.ServerSpec\n\tvar dest net.Destination\n\tvar conn stat.Connection\n\n\tif err := retry.ExponentialBackoff(5, 100).On(func() error {\n\t\tserver = c.serverPicker.PickServer()\n\t\tdest = server.Destination()\n\t\trawConn, err := dialer.Dial(ctx, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconn = rawConn\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn errors.New(\"failed to find an available destination\").Base(err)\n\t}\n\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\terrors.LogInfoInner(ctx, err, \"failed to closed connection\")\n\t\t}\n\t}()\n\n\tp := c.policyManager.ForLevel(0)\n\n\trequest := &protocol.RequestHeader{\n\t\tVersion: socks5Version,\n\t\tCommand: protocol.RequestCommandTCP,\n\t\tAddress: destination.Address,\n\t\tPort:    destination.Port,\n\t}\n\n\tif destination.Network == net.Network_UDP {\n\t\trequest.Command = protocol.RequestCommandUDP\n\t}\n\n\tuser := server.PickUser()\n\tif user != nil {\n\t\trequest.User = user\n\t\tp = c.policyManager.ForLevel(user.Level)\n\t}\n\n\tif err := conn.SetDeadline(time.Now().Add(p.Timeouts.Handshake)); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to set deadline for handshake\")\n\t}\n\tudpRequest, err := ClientHandshake(request, conn, conn)\n\tif err != nil {\n\t\treturn errors.New(\"failed to establish connection to server\").AtWarning().Base(err)\n\t}\n\tif udpRequest != nil {\n\t\tif udpRequest.Address == net.AnyIP || udpRequest.Address == net.AnyIPv6 {\n\t\t\tudpRequest.Address = dest.Address\n\t\t}\n\t}\n\n\tif err := conn.SetDeadline(time.Time{}); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to clear deadline after handshake\")\n\t}\n\n\tvar newCtx context.Context\n\tvar newCancel context.CancelFunc\n\tif session.TimeoutOnlyFromContext(ctx) {\n\t\tnewCtx, newCancel = context.WithCancel(context.Background())\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\ttimer := signal.CancelAfterInactivity(ctx, func() {\n\t\tcancel()\n\t\tif newCancel != nil {\n\t\t\tnewCancel()\n\t\t}\n\t}, p.Timeouts.ConnectionIdle)\n\n\tvar requestFunc func() error\n\tvar responseFunc func() error\n\tif request.Command == protocol.RequestCommandTCP {\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\treturn buf.Copy(link.Reader, buf.NewWriter(conn), buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treturn buf.Copy(buf.NewReader(conn), link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t} else if request.Command == protocol.RequestCommandUDP {\n\t\tudpConn, err := dialer.Dial(ctx, udpRequest.Destination())\n\t\tif err != nil {\n\t\t\treturn errors.New(\"failed to create UDP connection\").Base(err)\n\t\t}\n\t\tdefer udpConn.Close()\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\twriter := &UDPWriter{Writer: udpConn, Request: request}\n\t\t\treturn buf.Copy(link.Reader, writer, buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treader := &UDPReader{Reader: udpConn}\n\t\t\treturn buf.Copy(reader, link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t}\n\n\tif newCtx != nil {\n\t\tctx = newCtx\n\t}\n\n\tresponseDonePost := task.OnSuccess(responseFunc, task.Close(link.Writer))\n\tif err := task.Run(ctx, requestFunc, responseDonePost); err != nil {\n\t\treturn errors.New(\"connection ends\").Base(err)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "type Client struct {\n\tserverPicker protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tserverPicker := protocol.NewRoundRobinServerPicker(config.Servers)\n\tpolicyManager := policy.NewManager(config.Policy)\n\treturn &Client{\n\t\tserverPicker: serverPicker,\n\t\tpolicyManager: policyManager,\n\t}, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\tserver, err := c.serverPicker.PickServer()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttimeout, _ := c.policyManager.GetTimeout()\n\tconn, err := dialer.DialContext(ctx, \"tcp\", server.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\t_, err = conn.Write([]byte(\"Hello\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Process data\n\treturn nil\n}"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Implement a Go struct that handles DNS queries over UDP with context support and deadline management.\n\nStruct Description: DNSEndpoint represents a DNS server endpoint capable of performing DNS queries with context support, deadline management, and transaction ID matching.\n\nFields:\nAddr: string - The address of the DNS server in \"host:port\" format\n\nMethods:\nExchange: (ctx context.Context, payload, buf []byte) -> (n int, err error) - Performs a DNS query exchange:\n  - Establishes a UDP connection to the server\n  - Sets deadline from context if available\n  - Generates random transaction ID\n  - Sends DNS query payload\n  - Reads response and validates transaction ID\n  - Returns number of bytes read or any error\n  - Automatically closes connection when done",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n)\n\ntype DNSEndpoint struct {\n\tAddr string\n}\n\nfunc (e *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (n int, err error) {\n\td := &net.Dialer{}\n\tc, err := d.DialContext(ctx, \"udp\", e.Addr)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"dial: %v\", err)\n\t}\n\tdefer c.Close()\n\tif t, ok := ctx.Deadline(); ok {\n\t\t_ = c.SetDeadline(t)\n\t}\n\tif _, err := rand.Read(payload[:2]); err != nil {\n\t\treturn 0, err\n\t}\n\t_, err = c.Write(payload)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"write: %v\", err)\n\t}\n\tid := uint16(payload[0])<<8 | uint16(buf[1])\n\tfor {\n\t\tif n, err = c.Read(buf[:514]); err != nil {\n\t\t\treturn n, fmt.Errorf(\"read: %v\", err)\n\t\t}\n\t\tif n < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif id != uint16(buf[0])<<8|uint16(buf[1]) {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "type DNSEndpoint struct {\n\tAddr string\n}\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"net\"\n)\n\nfunc (e *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (n int, err error) {\n\taddr, err := net.ResolveUDPAddr(\"udp\", e.Addr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer conn.Close()\n\n\tif deadline, ok := ctx.Deadline(); ok {\n\t\tconn.SetDeadline(deadline)\n\t}\n\n\tid := make([]byte, 2)\n\tif _, err := rand.Read(id); err != nil {\n\t\treturn 0, err\n\t}\n\ttransactionID := binary.BigEndian.Uint16(id)\n\n\tbufToSend := make([]byte, 2+len(payload))\n\tbinary.BigEndian.PutUint16(bufToSend[0:2], transactionID)\n\tcopy(bufToSend[2:], payload)\n\n\tnWrite, err := conn.Write(bufToSend)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif nWrite != len(bufToSend) {\n\t\treturn 0, errors.New(\"failed to send all data\")\n\t}\n\n\tnRead, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treceivedID := binary.BigEndian.Uint16(buf[0:2])\n\tif receivedID != transactionID {\n\t\treturn 0, errors.New(\"transaction ID mismatch\")\n\t}\n\n\treturn nRead, nil\n}"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It maintains configuration and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC for the specified realm, handling multiple KDC addresses and error cases\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a single KDC connection",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "type Config struct {\n    KDCs map[string]string\n}\n\ntype Client struct {\n    Config *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n    realmAddr, exists := c.Config.KDCs[realm]\n    if !exists {\n        return nil, errors.New(\"KDC not found for realm\")\n    }\n    kdcs := map[int]string{0: realmAddr}\n    return c.dialSendTCP(kdcs, b)\n}\n\nfunc (c *Client) dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n    for k, addr := range kdcs {\n        conn, err := net.Dial(\"tcp\", addr)\n        if err != nil {\n            continue\n        }\n        defer conn.Close()\n        resp, err := c.sendTCP(conn, b)\n        if err == nil {\n            return resp, nil\n        }\n    }\n    return nil, errors.New(\"all KDC addresses failed\")\n}\n\nfunc (c *Client) sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n    _, err := conn.Write(b)\n    if err != nil {\n        return nil, err\n    }\n    buf := make([]byte, 1024)\n    n, err := conn.Read(buf)\n    if err != nil {\n        return nil, err\n    }\n    return buf[:n], nil\n}"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Implement a TCP client in Go that periodically sends metrics data to an OpenTSDB server, handling different types of metrics (counters, gauges, histograms, meters, and timers) with appropriate formatting.\n\nStruct Description: The OpenTSDBConfig struct contains configuration parameters for connecting to an OpenTSDB server and sending metrics data at regular intervals.\n\nFields:\nAddr: *net.TCPAddr - The TCP address of the OpenTSDB server\nRegistry: Registry - The metrics registry containing all metrics to be reported\nFlushInterval: time.Duration - The interval at which metrics are sent to the server\nDurationUnit: time.Duration - The time unit for converting timer metrics\nPrefix: string - The prefix to be added to all metric names\n\nMethods:\nOpenTSDBWithConfig: OpenTSDBWithConfig(c OpenTSDBConfig) - Starts a ticker that periodically calls openTSDB with the given configuration at the specified FlushInterval\nopenTSDB: openTSDB(c *OpenTSDBConfig) error - Establishes a TCP connection to the OpenTSDB server, formats and sends all metrics from the registry, and returns any error that occurs during the process",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\ntype OpenTSDBConfig struct {\n\tAddr          *net.TCPAddr\n\tRegistry      Registry\n\tFlushInterval time.Duration\n\tDurationUnit  time.Duration\n\tPrefix        string\n}\n\nfunc OpenTSDBWithConfig(c OpenTSDBConfig) {\n\tfor _ = range time.Tick(c.FlushInterval) {\n\t\tif err := openTSDB(&c); nil != err {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\nfunc openTSDB(c *OpenTSDBConfig) error {\n\tshortHostname := getShortHostname()\n\tnow := time.Now().Unix()\n\tdu := float64(c.DurationUnit)\n\tconn, err := net.DialTCP(\"tcp\", nil, c.Addr)\n\tif nil != err {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tw := bufio.NewWriter(conn)\n\tc.Registry.Each(func(name string, i interface{}) {\n\t\tswitch metric := i.(type) {\n\t\tcase Counter:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, metric.Count(), shortHostname)\n\t\tcase Gauge:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %d host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase GaugeFloat64:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %f host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase Histogram:\n\t\t\th := metric.Snapshot()\n\t\t\tps := h.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, h.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, h.Min(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, h.Max(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, h.Mean(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, h.StdDev(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4], shortHostname)\n\t\tcase Meter:\n\t\t\tm := metric.Snapshot()\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, m.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, m.RateMean(), shortHostname)\n\t\tcase Timer:\n\t\t\tt := metric.Snapshot()\n\t\t\tps := t.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, t.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, t.Min()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, t.Max()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, t.Mean()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, t.StdDev()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean-rate %d %.2f host=%s\\n\", c.Prefix, name, now, t.RateMean(), shortHostname)\n\t\t}\n\t\tw.Flush()\n\t})\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "type OpenTSDBConfig struct {\n\tAddr         *net.TCPAddr\n\tRegistry     Registry\n\tFlushInterval time.Duration\n\tDurationUnit time.Duration\n\tPrefix       string\n}\n\nfunc OpenTSDBWithConfig(c OpenTSDBConfig) {\n\tticker := time.NewTicker(c.FlushInterval)\n\tfor range ticker.C {\n\t\tif err := openTSDB(&c); err != nil {\n\t\t\tfmt.Printf(\"Error sending metrics: %v\\n\", err)\n\t\t}\n\t}\n}\n\nfunc openTSDB(c *OpenTSDBConfig) error {\n\tconn, err := net.DialTCP(\"tcp\", nil, c.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tmetrics := c.Registry.GetAllMetrics()\n\tfor _, metric := range metrics {\n\t\tmetricName := c.Prefix + \".\" + metric.Name\n\t\tvar value string\n\t\tswitch metric.Type {\n\t\tcase \"counter\":\n\t\t\tvalue = fmt.Sprintf(\"%d\", metric.Value)\n\t\tcase \"gauge\":\n\t\t\tvalue = fmt.Sprintf(\"%d\", metric.Value)\n\t\tcase \"histogram\":\n\t\t\tvalue = fmt.Sprintf(\"%d\", metric.Value)\n\t\tcase \"meter\":\n\t\t\tvalue = fmt.Sprintf(\"%f\", metric.Value)\n\t\tcase \"timer\":\n\t\t\tduration := metric.Value.(time.Duration)\n\t\t\tconverted := duration / c.DurationUnit\n\t\t\tvalue = fmt.Sprintf(\"%f\", converted)\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\ttimestamp := time.Now().UnixNano() / 1e6\n\t\tline := fmt.Sprintf(\"put %s %s %d\\n\", metricName, value, timestamp)\n\t\tif _, err := conn.Write([]byte(line)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype Registry interface {\n\tGetAllMetrics() []Metric\n}\n\ntype Metric struct {\n\tName  string\n\tType  string\n\tValue interface{}\n}"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Implement a TCP client in Go that can establish connections to servers, handle TLS if required, and manage timeouts for network operations.\n\nStruct Description: The Client struct represents a configurable TCP client capable of handling both plain TCP and TLS connections, with various timeout controls and DNS message exchange functionality.\n\nFields:\n\nNet: string - Network type (e.g., \"tcp\", \"tcp-tls\", \"udp\")\nUDPSize: uint16 - UDP buffer size for DNS messages\nTLSConfig: *tls.Config - TLS configuration for secure connections\nDialer: *net.Dialer - Custom dialer for connection establishment\nTimeout: time.Duration - Overall operation timeout\nDialTimeout: time.Duration - Timeout specifically for connection establishment\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nTsigSecret: map[string]string - TSIG authentication secrets\nSingleInflight: bool - Whether to use singleflight for duplicate request suppression\ngroup: singleflight - Internal singleflight group for request deduplication\n\nMethods:\n\nDial: (address string) -> (*Conn, error) - Establishes a connection to the specified address, handling TLS if configured\nExchange: (m *Msg, address string) -> (*Msg, time.Duration, error) - Performs a complete DNS message exchange with timeout handling\nexchange: (m *Msg, a string) -> (*Msg, time.Duration, error) - Internal method for performing the actual message exchange\ngetTimeoutForRequest: (timeout time.Duration) -> time.Duration - Calculates the appropriate timeout for a request considering various configuration options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tNet       string\n\tUDPSize   uint16\n\tTLSConfig *tls.Config\n\tDialer    *net.Dialer\n\tTimeout   time.Duration\n\tDialTimeout    time.Duration\n\tReadTimeout    time.Duration\n\tWriteTimeout   time.Duration\n\tTsigSecret     map[string]string\n\tSingleInflight bool\n\tgroup          singleflight\n}\n\nfunc (c *Client) Dial(address string) (conn *Conn, err error) {\n\tvar d net.Dialer\n\tif c.Dialer == nil {\n\t\td = net.Dialer{Timeout: c.getTimeoutForRequest(c.dialTimeout())}\n\t} else {\n\t\td = *c.Dialer\n\t}\n\n\tnetwork := c.Net\n\tif network == \"\" {\n\t\tnetwork = \"udp\"\n\t}\n\n\tuseTLS := strings.HasPrefix(network, \"tcp\") && strings.HasSuffix(network, \"-tls\")\n\n\tconn = new(Conn)\n\tif useTLS {\n\t\tnetwork = strings.TrimSuffix(network, \"-tls\")\n\t\tconn.Conn, err = tls.DialWithDialer(&d, network, address, c.TLSConfig)\n\t} else {\n\t\tconn.Conn, err = d.Dial(network, address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (r *Msg, rtt time.Duration, err error) {\n\tif !c.SingleInflight {\n\t\treturn c.exchange(m, address)\n\t}\n\n\tq := m.Question[0]\n\tkey := fmt.Sprintf(\"%s:%d:%d\", q.Name, q.Qtype, q.Qclass)\n\tr, rtt, err, shared := c.group.Do(key, func() (*Msg, time.Duration, error) {\n\t\treturn c.exchange(m, address)\n\t})\n\tif r != nil && shared {\n\t\tr = r.Copy()\n\t}\n\n\treturn r, rtt, err\n}\n\nfunc (c *Client) exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {\n\tvar co *Conn\n\n\tco, err = c.Dial(a)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer co.Close()\n\n\topt := m.IsEdns0()\n\tif opt != nil && opt.UDPSize() >= MinMsgSize {\n\t\tco.UDPSize = opt.UDPSize()\n\t}\n\tif opt == nil && c.UDPSize >= MinMsgSize {\n\t\tco.UDPSize = c.UDPSize\n\t}\n\n\tco.TsigSecret = c.TsigSecret\n\tt := time.Now()\n\tco.SetWriteDeadline(t.Add(c.getTimeoutForRequest(c.writeTimeout())))\n\tif err = co.WriteMsg(m); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tco.SetReadDeadline(time.Now().Add(c.getTimeoutForRequest(c.readTimeout())))\n\tr, err = co.ReadMsg()\n\tif err == nil && r.Id != m.Id {\n\t\terr = ErrId\n\t}\n\trtt = time.Since(t)\n\treturn r, rtt, err\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tvar requestTimeout time.Duration\n\tif c.Timeout != 0 {\n\t\trequestTimeout = c.Timeout\n\t} else {\n\t\trequestTimeout = timeout\n\t}\n\tif c.Dialer != nil && c.Dialer.Timeout != 0 {\n\t\tif c.Dialer.Timeout < requestTimeout {\n\t\t\trequestTimeout = c.Dialer.Timeout\n\t\t}\n\t}\n\treturn requestTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "type Conn struct {\n\tconn net.Conn\n}\n\ntype Client struct {\n\tNet        string\n\tUDPSize    uint16\n\tTLSConfig  *tls.Config\n\tDialer     *net.Dialer\n\tTimeout    time.Duration\n\tDialTimeout time.Duration\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tTsigSecret map[string]string\n\tSingleInflight bool\n\tgroup singleflight.Group\n}\n\nfunc (c *Client) Dial(address string) (*Conn, error) {\n\tvar conn net.Conn\n\tvar err error\n\tif c.Net == \"tcp-tls\" {\n\t\tconn, err = tls.DialWithDialer(c.Dialer, \"tcp\", address, c.TLSConfig)\n\t} else {\n\t\tconn, err = c.Dialer.Dial(\"tcp\", address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Conn{conn: conn}, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (*Msg, time.Duration, error) {\n\tif c.SingleInflight {\n\t\tresult, ok, err := c.group.Do(address, func() (interface{}, error) {\n\t\t\treturn c.exchange(m, address)\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\t\tif ok {\n\t\t\treturn result.(*Msg), 0, nil\n\t\t}\n\t}\n\ttimeout := c.getTimeoutForRequest(c.Timeout)\n\tconn, err := c.Dial(address)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer conn.Close()\n\treturn c.exchange(m, address, timeout, conn)\n}\n\nfunc (c *Client) exchange(m *Msg, address string, timeout time.Duration, conn *Conn) (*Msg, time.Duration, error) {\n\tconn.conn.SetDeadline(time.Now().Add(timeout))\n\t_, err := conn.conn.Write(m)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tbuffer := make([]byte, c.UDPSize)\n\tn, err := conn.conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tresponse := &Msg{}\n\t// parse response\n\treturn response, timeout, nil\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\treturn time.Duration(math.Min(float64(timeout), float64(c.Timeout)))\n}"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and applies specific traffic class and hop limit settings if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely until terminated.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"syscall\"\n)\n\nconst (\n\tIPPROTO_IPV6  = 41\n\tIPV6_TCLASS   = 92\n\tIPV6_HOPLIMIT = 93\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Accept error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\tdefer conn.Close()\n\t\t\tremoteAddr := conn.RemoteAddr()\n\t\t\ttcpAddr, ok := remoteAddr.(*net.TCPAddr)\n\t\t\tif ok && tcpAddr.IP.To4() == nil {\n\t\t\t\tfd, err := conn.File()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"File error: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := syscall.SetsockoptInt(int(fd.Fd()), IPPROTO_IPV6, IPV6_TCLASS, 0x20); err != nil {\n\t\t\t\t\tlog.Printf(\"SetsockoptInt TCLASS: %v\", err)\n\t\t\t\t}\n\t\t\t\tif err := syscall.SetsockoptInt(int(fd.Fd()), IPPROTO_IPV6, IPV6_HOPLIMIT, 64); err != nil {\n\t\t\t\t\tlog.Printf(\"SetsockoptInt HOPLIMIT: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsg := []byte(\"HELLO-R-U-THERE-ACK\")\n\t\t\tif _, err := conn.Write(msg); err != nil {\n\t\t\t\tlog.Printf(\"Write error: %v\", err)\n\t\t\t}\n\t\t}(conn)\n\t}\n}"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a Git daemon in Go that handles TCP connections for Git operations, including upload-pack and upload-archive services, with connection management, timeout handling, and access control.\n\nStruct Description: The GitDaemon struct represents a TCP server that handles Git protocol connections. It manages client connections, enforces limits, and processes Git service requests.\n\nFields:\n\nctx: [context.Context] - Context for cancellation and timeout propagation  \naddr: [string] - TCP address to listen on  \nfinished: [chan struct{}] - Channel to signal server shutdown  \nconns: [connections] - Track active connections (wrapper around map[net.Conn]struct{})  \ncfg: [*config.Config] - Server configuration  \nbe: [*backend.Backend] - Backend for repository access and authentication  \nwg: [sync.WaitGroup] - Wait group for graceful shutdown  \nonce: [sync.Once] - Ensure cleanup happens once  \nlogger: [*log.Logger] - Structured logger  \ndone: [atomic.Bool] - Atomic flag indicating server shutdown status  \n\nMethods:\n\nNewGitDaemon: [func(context.Context) (*GitDaemon, error)] -> Creates a new GitDaemon instance with context-derived configuration  \nListenAndServe: [func() error] -> Starts listening on configured address and serves connections  \nServe: [func(net.Listener) error] -> Handles incoming connections on provided listener (main server loop)  \nhandleClient: [func(net.Conn)] -> Processes individual client connections (private method)  \n\nHelper Types:\n\nserverConn: [struct] - Wraps net.Conn with timeout handling  \nconnections: [struct] - Thread-safe connection tracking with sync.Map  \n\nKey Behaviors:\n1. Implements exponential backoff for temporary connection errors\n2. Enforces maximum connection limits\n3. Handles Git protocol packets (pktline format)\n4. Validates repository paths and access permissions\n5. Processes both git-upload-pack and git-upload-archive services\n6. Implements idle and maximum timeout handling\n7. Provides clean shutdown via context cancellation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/pkg/access\"\n\t\"github.com/charmbracelet/soft-serve/pkg/backend\"\n\t\"github.com/charmbracelet/soft-serve/pkg/config\"\n\t\"github.com/charmbracelet/soft-serve/pkg/git\"\n\t\"github.com/charmbracelet/soft-serve/pkg/utils\"\n\t\"github.com/go-git/go-git/v5/plumbing/format/pktline\"\n)\n\ntype GitDaemon struct {\n\tctx      context.Context\n\taddr     string\n\tfinished chan struct{}\n\tconns    connections\n\tcfg      *config.Config\n\tbe       *backend.Backend\n\twg       sync.WaitGroup\n\tonce     sync.Once\n\tlogger   *log.Logger\n\tdone     atomic.Bool\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg := config.FromContext(ctx)\n\taddr := cfg.Git.ListenAddr\n\td := &GitDaemon{\n\t\tctx:      ctx,\n\t\taddr:     addr,\n\t\tfinished: make(chan struct{}, 1),\n\t\tcfg:      cfg,\n\t\tbe:       backend.FromContext(ctx),\n\t\tconns:    connections{m: make(map[net.Conn]struct{})},\n\t\tlogger:   log.FromContext(ctx).WithPrefix(\"gitdaemon\"),\n\t}\n\treturn d, nil\n}\n\nfunc (d *GitDaemon) ListenAndServe() error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\tlistener, err := net.Listen(\"tcp\", d.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.Serve(listener)\n}\n\nfunc (d *GitDaemon) Serve(listener net.Listener) error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\n\td.wg.Add(1)\n\tdefer d.wg.Done()\n\tdefer listener.Close()\n\n\tvar tempDelay time.Duration\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-d.finished:\n\t\t\t\treturn ErrServerClosed\n\t\t\tdefault:\n\t\t\t\td.logger.Debugf(\"git: error accepting connection: %v\", err)\n\t\t\t}\n\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif d.conns.Size()+1 >= d.cfg.Git.MaxConnections {\n\t\t\td.logger.Debugf(\"git: max connections reached, closing %s\", conn.RemoteAddr())\n\t\t\td.fatal(conn, git.ErrMaxConnections)\n\t\t\tcontinue\n\t\t}\n\n\t\td.wg.Add(1)\n\t\tgo func() {\n\t\t\td.handleClient(conn)\n\t\t\td.wg.Done()\n\t\t}()\n\t}\n}\n\nfunc (d *GitDaemon) handleClient(conn net.Conn) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tidleTimeout := time.Duration(d.cfg.Git.IdleTimeout) * time.Second\n\tc := &serverConn{\n\t\tConn:          conn,\n\t\tidleTimeout:   idleTimeout,\n\t\tcloseCanceler: cancel,\n\t}\n\tif d.cfg.Git.MaxTimeout > 0 {\n\t\tdur := time.Duration(d.cfg.Git.MaxTimeout) * time.Second\n\t\tc.maxDeadline = time.Now().Add(dur)\n\t}\n\td.conns.Add(c)\n\tdefer func() {\n\t\td.conns.Close(c)\n\t}()\n\n\terrc := make(chan error, 1)\n\n\ts := pktline.NewScanner(c)\n\tgo func() {\n\t\tif !s.Scan() {\n\t\t\tif err := s.Err(); err != nil {\n\t\t\t\terrc <- err\n\t\t\t}\n\t\t}\n\t\terrc <- nil\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tif err := ctx.Err(); err != nil {\n\t\t\td.logger.Debugf(\"git: connection context error: %v\", err)\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t}\n\t\treturn\n\tcase err := <-errc:\n\t\tif nerr, ok := err.(net.Error); ok && nerr.Timeout() {\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\td.logger.Debugf(\"git: error scanning pktline: %v\", err)\n\t\t\td.fatal(c, git.ErrSystemMalfunction)\n\t\t\treturn\n\t\t}\n\n\t\tline := s.Bytes()\n\t\tsplit := bytes.SplitN(line, []byte{' '}, 2)\n\t\tif len(split) != 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\tservice := git.Service(split[0])\n\t\tswitch service {\n\t\tcase git.UploadPackService:\n\t\tcase git.UploadArchiveService:\n\t\tdefault:\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\topts := bytes.SplitN(split[1], []byte{0}, 3)\n\t\tif len(opts) < 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\thost := strings.TrimPrefix(string(opts[1]), \"host=\")\n\t\textraParams := map[string]string{}\n\n\t\tif len(opts) > 2 {\n\t\t\tbuf := bytes.TrimPrefix(opts[2], []byte{0})\n\t\t\tfor _, o := range bytes.Split(buf, []byte{0}) {\n\t\t\t\topt := string(o)\n\t\t\t\tif opt == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tkv := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(kv) != 2 {\n\t\t\t\t\td.logger.Errorf(\"git: invalid option %q\", opt)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\textraParams[kv[0]] = kv[1]\n\t\t\t}\n\t\t}\n\n\t\tbe := d.be\n\t\tif !be.AllowKeyless(ctx) {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tname := utils.SanitizeRepo(string(opts[0]))\n\t\td.logger.Debugf(\"git: connect %s %s %s\", c.RemoteAddr(), service, name)\n\t\tdefer d.logger.Debugf(\"git: disconnect %s %s %s\", c.RemoteAddr(), service, name)\n\n\t\trepo := name + \".git\"\n\t\treposDir := filepath.Join(d.cfg.DataPath, \"repos\")\n\t\tif err := git.EnsureWithin(reposDir, repo); err != nil {\n\t\t\td.logger.Debugf(\"git: error ensuring repo path: %v\", err)\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tif _, err := d.be.Repository(ctx, repo); err != nil {\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tauth := be.AccessLevel(ctx, name, \"\")\n\t\tif auth < access.ReadOnlyAccess {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tenvs := []string{\n\t\t\t\"SOFT_SERVE_REPO_NAME=\" + name,\n\t\t\t\"SOFT_SERVE_REPO_PATH=\" + filepath.Join(reposDir, repo),\n\t\t\t\"SOFT_SERVE_HOST=\" + host,\n\t\t\t\"SOFT_SERVE_LOG_PATH=\" + filepath.Join(d.cfg.DataPath, \"log\", \"hooks.log\"),\n\t\t}\n\n\t\tif len(extraParams) > 0 {\n\t\t\tvar gitProto string\n\t\t\tfor k, v := range extraParams {\n\t\t\t\tif len(gitProto) > 0 {\n\t\t\t\t\tgitProto += \":\"\n\t\t\t\t}\n\t\t\t\tgitProto += k + \"=\" + v\n\t\t\t}\n\t\t\tenvs = append(envs, \"GIT_PROTOCOL=\"+gitProto)\n\t\t}\n\n\t\tenvs = append(envs, d.cfg.Environ()...)\n\n\t\tcmd := git.ServiceCommand{\n\t\t\tStdin:  c,\n\t\t\tStdout: c,\n\t\t\tStderr: c,\n\t\t\tEnv:    envs,\n\t\t\tDir:    filepath.Join(reposDir, repo),\n\t\t}\n\n\t\tif err := service.Handler(ctx, cmd); err != nil {\n\t\t\td.logger.Debugf(\"git: error handling request: %v\", err)\n\t\t\td.fatal(c, err)\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/go-kit/log\"\n\t\"github.com/go-kit/log/level\"\n)\n\ntype serverConn struct {\n\tconn net.Conn\n}\n\nfunc (sc *serverConn) deadline() time.Time {\n\treturn sc.conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n}\n\ntype connections struct {\n\tm sync.Map\n}\n\nfunc (c *connections) add(conn net.Conn) {\n\tc.m.Store(conn, struct{}{})\n}\n\nfunc (c *connections) remove(conn net.Conn) {\n\tc.m.Delete(conn)\n}\n\ntype GitDaemon struct {\n\tctx    context.Context\n\taddr   string\n\tfinished chan struct{}\n\tconns  *connections\n\tcfg    *config.Config\n\tbe     *backend.Backend\n\twg     sync.WaitGroup\n\tonce   sync.Once\n\tlogger *log.Logger\n\tdone   atomic.Bool\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg, err := config.Load(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &GitDaemon{\n\t\tctx:    ctx,\n\t\taddr:   cfg.Addr,\n\t\tfinished: make(chan struct{}),\n\t\tconns:  &connections{},\n\t\tcfg:    cfg,\n\t\tbe:     backend.NewBackend(),\n\t\tlogger: log.NewLogfmtLogger(log.NewSyncWriter(nil)),\n\t}, nil\n}\n\nfunc (g *GitDaemon) ListenAndServe() error {\n\tlistener, err := net.Listen(\"tcp\", g.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn g.Serve(listener)\n}\n\nfunc (g *GitDaemon) Serve(l net.Listener) error {\n\tdefer l.Close()\n\tg.wg.Add(1)\n\tdefer g.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase <-g.finished:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"temporary connection error\", \"err\", err)\n\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif g.conns.Len() >= g.cfg.MaxConnections {\n\t\t\t\tconn.Close()\n\t\t\t\tlevel.Warn(g.logger).Log(\"msg\", \"max connections reached\", \"count\", g.conns.Len())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tg.conns.add(conn)\n\t\t\tg.wg.Add(1)\n\t\t\tgo g.handleClient(conn)\n\t\t}\n\t}\n}\n\nfunc (g *GitDaemon) handleClient(conn net.Conn) {\n\tdefer func() {\n\t\tg.conns.remove(conn)\n\t\tconn.Close()\n\t\tg.wg.Done()\n\t}()\n\tsc := &serverConn{conn: conn}\n\tif err := sc.deadline(); err != nil {\n\t\tlevel.Error(g.logger).Log(\"msg\", \"setting deadline\", \"err\", err)\n\t\treturn\n\t}\n\t// Process Git protocol\n\tpacket, err := readPacket(conn)\n\tif err != nil {\n\t\tlevel.Error(g.logger).Log(\"msg\", \"reading packet\", \"err\", err)\n\t\treturn\n\t}\n\tif packet == \"git-upload-pack\" {\n\t\tif err := g.processUploadPack(conn); err != nil {\n\t\t\tlevel.Error(g.logger).Log(\"msg\", \"processing upload-pack\", \"err\", err)\n\t\t}\n\t} else if packet == \"git-upload-archive\" {\n\t\tif err := g.processUploadArchive(conn); err != nil {\n\t\t\tlevel.Error(g.logger).Log(\"msg\", \"processing upload-archive\", \"err\", err)\n\t\t}\n\t} else {\n\t\tlevel.Error(g.logger).Log(\"msg\", \"unknown packet\", \"packet\", packet)\n\t}\n}\n\nfunc (g *GitDaemon) processUploadPack(conn net.Conn) error {\n\t// Implement upload-pack logic\n\treturn nil\n}\n\nfunc (g *GitDaemon) processUploadArchive(conn net.Conn) error {\n\t// Implement upload-archive logic\n\treturn nil\n}\n\nfunc readPacket(conn net.Conn) (string, error) {\n\t// Read pktline\n\tn, err := conn.Read([]byte{0, 0, 0, 0})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif n < 4 {\n\t\treturn \"\", fmt.Errorf(\"short packet\")\n\t}\n\tsize := int32(*(*int32)(unsafe.Pointer(&n)))\n\tif size == 0 {\n\t\treturn \"\", nil\n\t}\n\tbuffer := make([]byte, size)\n\tn, err = conn.Read(buffer)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(buffer), nil\n}"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management. The server should be able to start, accept connections, read data from clients, and properly shut down while cleaning up resources.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management capabilities. It maintains state about active connections and provides methods to start, serve, and manage the server lifecycle.\n\nFields:\n\nAddr: [string] - The network address to listen on (e.g., \":8080\")\nNet: [string] - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: [Handler] - The handler for processing incoming requests\nReadTimeout: [time.Duration] - Maximum duration for reading a request\nWriteTimeout: [time.Duration] - Maximum duration for writing a response\nIdleTimeout: [func() time.Duration] - Function returning idle connection timeout\nlock: [sync.RWMutex] - Protects concurrent access to server state\nstarted: [bool] - Indicates if server is running\nshutdown: [chan struct{}] - Channel for shutdown signaling\nconns: [map[net.Conn]struct{}] - Map of active connections\n\nMethods:\n\nListenAndServe: [Name]() -> [error] - Starts the server and begins accepting connections\nserveTCP: [Name](net.Listener) -> [error] - Main TCP serving loop that accepts connections\nserveTCPConn: [Name](*sync.WaitGroup, net.Conn) -> [] - Handles an individual TCP connection\nreadTCP: [Name](net.Conn, time.Duration) -> ([]byte, error) - Reads data from a TCP connection\ninit: [Name]() -> [] - Initializes server resources\nisStarted: [Name]() -> [bool] - Checks if server is running\ngetIdleTimeout: [Name]() -> [time.Duration] - Returns idle timeout duration\ngetReadTimeout: [Name]() -> [time.Duration] - Returns read timeout duration",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := net.Listen(srv.Net, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer wg.Done()\n\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := srv.getIdleTimeout()\n\n\tfor srv.isStarted() {\n\t\tm, err := srv.readTCP(rw, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n}\n\nfunc (srv *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\n\tvar length uint16\n\tif err := binary.Read(conn, binary.BigEndian, &length); err != nil {\n\t\treturn nil, err\n\t}\n\n\tm := make([]byte, length)\n\tif _, err := io.ReadFull(conn, m); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn m, nil\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getIdleTimeout() time.Duration {\n\tif srv.IdleTimeout != nil {\n\t\treturn srv.IdleTimeout()\n\t}\n\treturn tcpIdleTimeout\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "type Server struct {\n\tAddr      string\n\tNet       string\n\tHandler   func(conn net.Conn) error\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tlock       sync.RWMutex\n\tstarted    bool\n\tshutdown   chan struct{}\n\tconns      map[net.Conn]struct{}\n}\n\nfunc (s *Server) init() {\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getIdleTimeout() time.Duration {\n\treturn s.IdleTimeout()\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif s.isStarted() {\n\t\treturn errors.New(\"server already started\")\n\t}\n\ts.init()\n\ts.started = true\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.serveTCP(listener)\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tdefer listener.Close()\n\tfor {\n\t\tselect {\n\t\tcase <-s.shutdown:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif opErr, ok := err.(net.OpError); ok && opErr.Timeout() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.lock.Lock()\n\t\t\ts.conns[conn] = struct{}{}\n\t\t\ts.lock.Unlock()\n\t\t\tgo s.serveTCPConn(conn)\n\t\t}\n\t}\n}\n\nfunc (s *Server) serveTCPConn(conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\tconn.Close()\n\t}()\n\t\n\tconn.SetReadDeadline(time.Now().Add(s.getReadTimeout()))\n\tconn.SetWriteDeadline(time.Now().Add(s.getWriteTimeout()))\n\t\n\ttimeout := s.getIdleTimeout()\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\t\n\tdata, err := s.readTCP(conn, timeout)\n\tif err != nil {\n\t\tif opErr, ok := err.(net.OpError); ok && opErr.Timeout() {\n\t\t\tlog.Println(\"Read timeout\")\n\t\t} else {\n\t\t\tlog.Println(\"Read error:\", err)\n\t\t}\n\t\treturn\n\t}\n\t\n\tif err := s.Handler(conn); err != nil {\n\t\tlog.Println(\"Handler error:\", err)\n\t}\n}\n\nfunc (s *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer[:n], nil\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Implement a TCP server in Go that handles client connections, processes incoming messages, and generates appropriate responses based on the message type. The server should support graceful shutdown and concurrent client handling.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, processes client requests, and maintains server state including messages, errors, and connection information.\n\nFields:\n- Addr: net.Addr - The network address the server is listening on\n- mu: sync.Mutex - Mutex for thread-safe operations\n- wg: sync.WaitGroup - WaitGroup for managing goroutines\n- closed: bool - Flag indicating if the server is closed\n- closing: chan struct{} - Channel for shutdown signaling\n- messages: []Message - Collection of processed messages\n- errors: []error - Collection of encountered errors\n- brokerMessage: []byte - Pre-prepared broker message data\n- nodeID: int32 - Identifier for the server node\n- partitionCount: int32 - Number of partitions for topic handling\n\nMethods:\n- NewServer() -> (*Server, error) - Creates and starts a new Server instance\n- prepareBrokerMsg() - Prepares the broker message with server information\n- Close() - Gracefully shuts down the server\n- run(net.Listener) - Main server loop handling connections\n- handle(net.Conn) -> error - Processes individual client connections\n- readProduceRequest([]byte) -> (string, []Response, error) - Helper for produce requests\n- readStrList([]byte) -> ([]string, int) - Helper for reading string lists",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr net.Addr\n\tmu   sync.Mutex\n\twg   sync.WaitGroup\n\n\tclosed  bool\n\tclosing chan struct{}\n\n\tmessages []Message\n\terrors   []error\n\n\tbrokerMessage []byte\n\tnodeID        int32\n\n\tpartitionCount int32\n}\n\nfunc NewServer() (*Server, error) {\n\ts := &Server{\n\t\tclosing:        make(chan struct{}),\n\t\tnodeID:         1,\n\t\tpartitionCount: 3,\n\t}\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.Addr = l.Addr()\n\n\ts.prepareBrokerMsg()\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\ts.run(l)\n\t}()\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\thost, port, _ := net.SplitHostPort(s.Addr.String())\n\ts.brokerMessage = make([]byte, 0, 4+2+len(host)+4)\n\ts.brokerMessage = writeInt32(s.brokerMessage, s.nodeID)\n\ts.brokerMessage = writeStr(s.brokerMessage, host)\n\tportN, _ := strconv.Atoi(port)\n\ts.brokerMessage = writeInt32(s.brokerMessage, int32(portN))\n\ts.brokerMessage = writeInt16(s.brokerMessage, -1)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(l net.Listener) {\n\tdefer l.Close()\n\n\taccepts := make(chan net.Conn)\n\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tfor {\n\t\t\tc, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase accepts <- c:\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase c := <-accepts:\n\t\t\tgo func() {\n\t\t\t\tdefer c.Close()\n\t\t\t\tfor {\n\t\t\t\t\tif err := s.handle(c); err != nil {\n\t\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.mu.Lock()\n\t\t\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\t\t\ts.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\tcase <-s.closing:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Server) handle(c net.Conn) error {\n\tvar size int32\n\terr := binary.Read(c, binary.BigEndian, &size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, int(size))\n\n\t_, err = io.ReadFull(c, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tapiKey := int16(binary.BigEndian.Uint16(buf[:2]))\n\tversion := int16(binary.BigEndian.Uint16(buf[2:4]))\n\t_, n := readStr(buf[8:])\n\trequest := buf[8+n:]\n\n\tresponse := make([]byte, 8, 1024)\n\tcopy(response[4:], buf[4:8])\n\n\tswitch apiKey {\n\tcase 0:\n\t\ttopic, responses, err := s.readProduceRequest(request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse = writeArrayHeader(response, 1)\n\t\tresponse = writeStr(response, topic)\n\t\tresponse = writeArrayHeader(response, int32(len(responses)))\n\t\tfor _, r := range responses {\n\t\t\tresponse = writeInt32(response, 0)\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeInt64(response, r.offset)\n\t\t\tresponse = writeInt64(response, 0)\n\t\t\tif version >= 5 {\n\t\t\t\tresponse = writeInt64(response, 0)\n\t\t\t}\n\t\t}\n\t\tresponse = writeInt32(response, 0)\n\n\tcase 3:\n\t\ttopics, _ := readStrList(request)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArray(response, [][]byte{s.brokerMessage})\n\t\tresponse = writeInt16(response, -1)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArrayHeader(response, int32(len(topics)))\n\t\tfor _, t := range topics {\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeStr(response, t)\n\t\t\tresponse = writeBool(response, false)\n\t\t\tresponse = writeArrayHeader(response, s.partitionCount)\n\t\t\tfor i := int32(0); i < s.partitionCount; i++ {\n\t\t\t\tresponse = writeInt16(response, 0)\n\t\t\t\tresponse = writeInt32(response, i+1)\n\t\t\t\tresponse = writeInt32(response, s.nodeID)\n\t\t\t\tif version >= 7 {\n\t\t\t\t\tresponse = writeInt32(response, 0)\n\t\t\t\t}\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t}\n\t\t}\n\tcase 18:\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeArrayHeader(response, 2)\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 3)\n\t\tresponse = writeInt16(response, 1)\n\t\tresponse = writeInt16(response, 1)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported apiKey %d\", apiKey)\n\t}\n\n\tresponseSize := len(response) - 4\n\tbinary.BigEndian.PutUint32(response[:4], uint32(responseSize))\n\t_, err = c.Write(response)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Message struct {\n\tTopic   string\n\tPayload []byte\n}\n\ntype Response struct {\n\tPartition int32\n\tOffset    int64\n}\n\ntype Server struct {\n\tAddr        net.Addr\n\tmu          sync.Mutex\n\twg          sync.WaitGroup\n\tclosed      bool\n\tclosing     chan struct{}\n\tmessages    []Message\n\terrors      []error\n\tbrokerMessage []byte\n\tnodeID      int32\n\tpartitionCount int32\n}\n\nfunc NewServer(addr string, nodeID int32, partitionCount int32) (*Server, error) {\n\tserver := &Server{\n\t\tAddr:          &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 8080},\n\t\tclosing:       make(chan struct{}),\n\t\tnodeID:        nodeID,\n\t\tpartitionCount: partitionCount,\n\t}\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tserver.run(listener)\n\treturn server, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\tmsg := fmt.Sprintf(\"NodeID: %d, Partitions: %d\", s.nodeID, s.partitionCount)\n\ts.brokerMessage = []byte(msg)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.Addr = nil\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(listener net.Listener) {\n\tdefer listener.Close()\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.mu.Lock()\n\t\t\ts.errors = append(s.errors, err)\n\t\t\ts.mu.Unlock()\n\t\t\tbreak\n\t\t}\n\t\ts.wg.Add(1)\n\t\tgo s.handle(conn)\n\t}\n}\n\nfunc (s *Server) handle(conn net.Conn) {\n\tdefer func() {\n\t\tconn.Close()\n\t\ts.wg.Done()\n\t}()\n\tif s.closed {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\ts.mu.Lock()\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"panic: %v\", r))\n\t\t\ts.mu.Unlock()\n\t\t}\n\t}()\n\treader := bufio.NewReader(conn)\n\tdata, _ := reader.ReadBytes('\\n')\n\tif len(data) == 0 {\n\t\treturn\n\t}\n\tif s.closed {\n\t\treturn\n\t}\n\tif len(s.brokerMessage) == 0 {\n\t\ts.prepareBrokerMsg()\n\t}\n\t_, _, err := s.readProduceRequest(data)\n\tif err != nil {\n\t\ts.mu.Lock()\n\t\ts.errors = append(s.errors, err)\n\t\ts.mu.Unlock()\n\t}\n}\n\nfunc (s *Server) readProduceRequest(data []byte) (string, []Response, error) {\n\tif len(data) == 0 {\n\t\treturn \"\", nil, errors.New(\"empty request\")\n\t}\n\tvar offset int\n\tstr, rem, err := s.readStrList(data, &offset)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\tresponses := make([]Response, len(str))\n\tfor i := range str {\n\t\tresponses[i] = Response{Partition: int32(i), Offset: int64(i * 100)}\n\t}\n\treturn str[0], responses, nil\n}\n\nfunc (s *Server) readStrList(data []byte, offset *int) ([]string, int) {\n\tvar result []string\n\tfor *offset < len(data) && data[*offset] != ',' {\n\t\tif data[*offset] == '\"' {\n\t\t\t*offset++\n\t\t\tvar sb []byte\n\t\t\tfor *offset < len(data) && data[*offset] != '\"' {\n\t\t\t\tsb = append(sb, data[*offset])\n\t\t\t\t*offset++\n\t\t\t}\n\t\t\tif *offset < len(data) {\n\t\t\t\t*offset++\n\t\t\t}\n\t\t\tresult = append(result, string(sb))\n\t\t} else {\n\t\t\tvar sb []byte\n\t\t\tfor *offset < len(data) && data[*offset] != ',' {\n\t\t\t\tsb = append(sb, data[*offset])\n\t\t\t\t*offset++\n\t\t\t}\n\t\t\tresult = append(result, string(sb))\n\t\t}\n\t}\n\t*offset++\n\treturn result, *offset\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a TCP echo server in Go that listens for incoming connections on a specified port, reads data from clients, and echoes the same data back to them.\n\nFunction Description: The function implements a simple TCP server that continuously accepts client connections, reads data from each connection, and writes the same data back (echo). It handles network errors appropriately and ensures resources are cleaned up.\n\nInput: None (The port number is hardcoded as \":9000\" in the implementation)\n\nOutput: None (The function runs indefinitely until interrupted, with all output being network communication with clients)",
    "Canonical_solution": "import \"net\"\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfor {\n\t\t\tbs := make([]byte, 1024)\n\t\t\tn, err := conn.Read(bs)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t_, err = conn.Write(bs[:n])\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"io\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to start server:\", err)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Accept error:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\tdefer conn.Close()\n\t\t\tbuf := make([]byte, 1024)\n\t\t\tfor {\n\t\t\t\tn, err := conn.Read(buf)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tlog.Println(\"Read error:\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t_, err := conn.Write(buf[:n])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(conn)\n\t}\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets IP TOS (Type of Service) and TTL (Time To Live) values for IPv4 connections, and sends a greeting message to the client.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For each IPv4 connection, it configures the TOS and TTL values using the ipv4 package. It then sends a greeting message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to \"0.0.0.0:1024\" by default)\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving connections)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {\n\t\t\t\tp := ipv4.NewConn(c)\n\t\t\t\tif err := p.SetTOS(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetTTL(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Accept error:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tfd, err := c.File()\n\t\t\tif err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer fd.Close()\n\n\t\t\tif err := syscall.SetsockoptInt(fd.Fd(), syscall.SOL_IP, syscall.IP_TOS, 0x10); err != nil {\n\t\t\t\tfmt.Println(\"Set TOS error:\", err)\n\t\t\t}\n\n\t\t\tif err := syscall.SetsockoptInt(fd.Fd(), syscall.SOL_IP, syscall.IP_TTL, 64); err != nil {\n\t\t\t\tfmt.Println(\"Set TTL error:\", err)\n\t\t\t}\n\n\t\t\tmsg := []byte(\"HELLO-R-U-THERE-ACK\")\n\t\t\tif _, err := c.Write(msg); err != nil {\n\t\t\t\tfmt.Println(\"Write error:\", err)\n\t\t\t}\n\n\t\t\tc.Close()\n\t\t}(conn)\n\t}\n}"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Create a Unix domain socket server in Go that listens for incoming connections, handles client communication, and processes received data through a product function. The server should manage connection limits, timeouts, and proper resource cleanup.\n\nStruct Description: The `unix` struct represents a Unix domain socket server with configuration options for path, permissions, and connection handling. It manages the socket lifecycle and processes incoming data.\n\nFields:\n- name: string - Identifier for the server instance\n- config: *Config - Pointer to configuration containing path, mode, timeout, max connections, and max bytes\n- done: chan struct{} - Channel to signal server shutdown\n- eventPool: *event.Pool - Pool for managing event objects\n\nMethods:\n- ProductLoop(productFunc api.ProductFunc) -> void - Main server loop that listens for connections and delegates handling to worker goroutines. Takes a product function for processing events.\n- handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) -> void - Handles individual client connections, reads data, and passes it to the product function. Manages connection timeouts and cleanup.\n- checkBind(path string) -> error - Validates and prepares the socket path by removing existing files if necessary\n- chmod(path string, mode string) -> error - Sets filesystem permissions on the socket file",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/netutil\"\n)\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (k *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", k.String())\n\n\tif err := checkBind(k.config.Path); err != nil {\n\t\tlog.Error(\"check unix sock path error: %+v\", err)\n\t\treturn\n\t}\n\n\tlistener, err := net.Listen(\"unix\", k.config.Path)\n\tif err != nil {\n\t\tlog.Error(\"setup unix listener failed: %v\", err)\n\t\treturn\n\t}\n\n\tif err := chmod(k.config.Path, k.config.Mode); err != nil {\n\t\tlog.Error(\"chmod unix path %s with %s failed: %v\", k.config.Path, k.config.Mode, err)\n\t\treturn\n\t}\n\n\tif k.config.MaxConnections > 0 {\n\t\tlistener = netutil.LimitListener(listener, k.config.MaxConnections)\n\t}\n\n\tdefer listener.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfor {\n\t\tselect {\n\t\tcase <-k.done:\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"unix sock listener accept connection failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo k.handleConn(ctx, conn, productFunc)\n\t}\n}\n\nfunc (k *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuf := bufio.NewReader(conn)\n\tscan := bufio.NewScanner(buf)\n\n\tinitBuffer := make([]byte, k.config.MaxBytes/4)\n\tscan.Buffer(initBuffer, k.config.MaxBytes)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tif err := conn.SetDeadline(time.Now().Add(k.config.Timeout)); err != nil {\n\t\t\tlog.Warn(\"set connection timeout error: %v\", err)\n\t\t}\n\n\t\tif !scan.Scan() {\n\t\t\tif scan.Err() != nil {\n\t\t\t\tlog.Warn(\"scan connection error: %v\", scan.Err())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tbody := scan.Bytes()\n\t\tcopyBody := make([]byte, len(body))\n\t\tcopy(copyBody, body)\n\t\te := k.eventPool.Get()\n\t\te.Fill(e.Meta(), e.Header(), copyBody)\n\n\t\tproductFunc(e)\n\t}\n}\n\nfunc checkBind(path string) error {\n\t_, err := os.Lstat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errors.WithMessagef(err, \"stat path %s failed\", path)\n\t}\n\n\tif err := os.Remove(path); err != nil {\n\t\treturn errors.WithMessagef(err, \"remove path %s failed\", path)\n\t}\n\n\treturn nil\n}\n\nfunc chmod(path string, mode string) error {\n\tparsed, err := strconv.ParseUint(mode, 8, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(path, os.FileMode(parsed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Config struct {\n\tPath      string\n\tMode      string\n\tTimeout   time.Duration\n\tMaxConnections int\n\tMaxBytes  int\n}\n\ntype unix struct {\n\tname    string\n\tconfig  *Config\n\tdone    chan struct{}\n\teventPool *event.Pool\n}\n\ntype event struct{}\n\nfunc (e *event) Pool() *event.Pool {\n\treturn &event.Pool{}\n}\n\nfunc (u *unix) checkBind(path string) error {\n\tif _, err := os.Stat(path); err == nil {\n\t\tif err := os.Remove(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *unix) chmod(path string, mode string) error {\n\tm, err := strconv.ParseInt(mode, 8, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Chmod(path, os.FileMode(m)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *unix) ProductLoop(productFunc func([]byte)) {\n\tif err := u.checkBind(u.config.Path); err != nil {\n\t\tlog.Fatalf(\"failed to check bind: %v\", err)\n\t}\n\tif err := u.chmod(u.config.Path, u.config.Mode); err != nil {\n\t\tlog.Fatalf(\"failed to set permissions: %v\", err)\n\t}\n\n\tlistener, err := net.Listen(\"unix\", u.config.Path)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tdefer listener.Close()\n\n\tif u.config.Timeout > 0 {\n\t\tlistener.SetDeadline(time.Now().Add(u.config.Timeout))\n\t}\n\n\tconnChan := make(chan net.Conn, u.config.MaxConnections)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase conn := <-connChan:\n\t\t\t\tu.handleConn(context.Background(), conn, productFunc)\n\t\t\tcase <-u.done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-u.done:\n\t\t\treturn\n\t\tdefault:\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif opErr, ok := err.(*net.OpError); ok && opErr.Timeout() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlog.Printf(\"accept error: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconnChan <- conn\n\t\t}\n\t}\n}\n\nfunc (u *unix) handleConn(ctx context.Context, conn net.Conn, productFunc func([]byte)) {\n\tconn.SetDeadline(time.Now().Add(u.config.Timeout))\n\tbuffer := make([]byte, u.config.MaxBytes)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\tif opErr, ok := err.(*net.OpError); ok && opErr.Timeout() {\n\t\t\tlog.Printf(\"read timeout: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"read error: %v\", err)\n\t\t}\n\t\tconn.Close()\n\t\treturn\n\t}\n\tdata := buffer[:n]\n\tproductFunc(data)\n\tconn.Close()\n}"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets specific IPv6 traffic class and hop limit for IPv6 connections, and sends an acknowledgment message to each client.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and configures specific network parameters (traffic class and hop limit) if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. Each client connection is handled in a separate goroutine.\n\nInput: None (The function takes no explicit parameters but binds to port 1024 by default)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations and may log fatal errors)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"syscall\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp6\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Accept error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\taddr := conn.RemoteAddr()\n\t\t\ttcpAddr, ok := addr.(*net.TCPAddr)\n\t\t\tif !ok {\n\t\t\t\tlog.Printf(\"Unexpected address type: %T\", addr)\n\t\t\t\tconn.Close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tip := tcpAddr.IP\n\t\t\tif ip.To4() == nil {\n\t\t\t\tfd, err := conn.File()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"File error: %v\", err)\n\t\t\t\t\tconn.Close()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := syscall.SetsockoptInt(fd.Fd(), syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, 0x10); err != nil {\n\t\t\t\t\tlog.Printf(\"SetsockoptInt error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif err := syscall.SetsockoptInt(fd.Fd(), syscall.IPPROTO_IPV6, syscall.IPV6_HOPLIMIT, 30); err != nil {\n\t\t\t\t\tlog.Printf(\"SetsockoptInt error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err := conn.Write([]byte(\"HELLO-R-U-THERE-ACK\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Write error: %v\", err)\n\t\t\t}\n\t\t\tconn.Close()\n\t\t}(conn)\n\t}\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific traffic class and hop limit settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For IPv6 clients, it configures specific network parameters (traffic class and hop limit) before sending an acknowledgment message. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to a fixed port \"[::]:1024\")\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving clients)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv6\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"syscall\"\n)\n\nfunc main() {\n    listener, err := net.Listen(\"tcp\", \"[::]:1024\")\n    if err != nil {\n        panic(err)\n    }\n    defer listener.Close()\n\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n            fmt.Println(\"Accept error:\", err)\n            continue\n        }\n\n        go func(c net.Conn) {\n            fd := c.File()\n            if fd == nil {\n                return\n            }\n            defer fd.Close()\n\n            if err := syscall.SetsockoptInt(fd.Fd(), syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, 0x20); err != nil {\n                fmt.Println(\"Setsockopt IPV6_TCLASS error:\", err)\n            }\n\n            if err := syscall.SetsockoptInt(fd.Fd(), syscall.IPPROTO_IPV6, syscall.IPV6_HOPLIMIT, 64); err != nil {\n                fmt.Println(\"Setsockopt IPV6_HOPLIMIT error:\", err)\n            }\n\n            _, err := c.Write([]byte(\"ACK\\n\"))\n            if err != nil {\n                fmt.Println(\"Write error:\", err)\n            }\n\n            c.Close()\n        }(conn)\n    }\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Implement a gRPC client in Go that establishes a secure connection to a gRPC server with authentication, sends a request, and processes the response.\n\nFunction Description: The function `doClientWork` demonstrates how to create a gRPC client that connects to a server, authenticates using provided credentials, sends a \"Hello\" request, and logs the response. It handles connection setup, authentication, RPC call execution, and connection cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes, but these could be parameterized in a real implementation)\n\nOutput: None (The function logs results to stdout but doesn't return any values)\n\n---\n\nTask Description: Implement an authentication struct for gRPC credentials in Go that provides request metadata and specifies transport security requirements.\n\nStruct Description: The `Authentication` struct implements gRPC's `credentials.PerRPCCredentials` interface to provide per-RPC credentials (login/password) for gRPC requests.\n\nFields:\nLogin: string - The username for authentication\nPassword: string - The password for authentication\n\nMethods:\nGetRequestMetadata: (context.Context, ...string) -> (map[string]string, error) - Returns the authentication metadata (login/password) to be included in RPC requests\nRequireTransportSecurity: () -> bool - Indicates whether transport security is required (returns false in this implementation)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Authentication struct {\n\tLogin    string\n\tPassword string\n}\n\nfunc (a *Authentication) GetRequestMetadata(context.Context, ...string) (map[string]string, error) {\n\treturn map[string]string{\"login\": a.Login, \"password\": a.Password}, nil\n}\nfunc (a *Authentication) RequireTransportSecurity() bool {\n\treturn false\n}\n\nfunc doClientWork() {\n\tauth := Authentication{\n\t\tLogin:    \"gopher\",\n\t\tPassword: \"password\",\n\t}\n\n\tconn, err := grpc.Dial(\"localhost\"+port, grpc.WithInsecure(), grpc.WithPerRPCCredentials(&auth))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tc := NewGreeterClient(conn)\n\n\tr, err := c.SayHello(context.Background(), &HelloRequest{Name: \"gopher\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"doClientWork: %s\", r.Message)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "type Authentication struct {\n    Login    string\n    Password string\n}\n\nfunc (a *Authentication) GetRequestMetadata(ctx context.Context, uri string) (map[string]string, error) {\n    return map[string]string{\"login\": a.Login, \"password\": a.Password}, nil\n}\n\nfunc (a *Authentication) RequireTransportSecurity() bool {\n    return false\n}\n\nimport (\n    \"context\"\n    \"log\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials\"\n)\n\nfunc doClientWork() {\n    const (\n        serverAddr = \"localhost:50051\"\n        login     = \"user\"\n        password  = \"pass\"\n    )\n\n    auth := &Authentication{\n        Login:    login,\n        Password: password,\n    }\n\n    creds := grpc.InsecureCredentials()\n    conn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(auth))\n    if err != nil {\n        log.Fatalf(\"Failed to connect: %v\", err)\n    }\n    defer conn.Close()\n\n    client := NewHelloServiceClient(conn)\n    req := &HelloRequest{Message: \"Hello\"}\n    resp, err := client.SayHello(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"RPC call failed: %v\", err)\n    }\n\n    log.Printf(\"Received: %s\", resp.Message)\n}"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Create a Go function that establishes a secure gRPC client connection to a server, performs a math operation (addition) using the gRPC service, and returns the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:8092 using TLS credentials from a specified certificate file. It creates a client for the MathService, sends a request with two integer arguments, and returns the server's response containing the result of the addition operation.\n\nInput: \n- None (all configuration is hardcoded in the function)\n\nOutput:\n- Prints the response code and message from the gRPC server to stdout\n- Returns nothing (void function)\n\nNote: The function handles connection establishment, service client creation, request sending, and connection cleanup automatically. Error conditions will cause the function to panic.",
    "Canonical_solution": "import (\n\t\"google.golang.org/grpc\"\n\t\"grpcSSLCode/message\"\n\t\"context\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"fmt\"\n\t\"google.golang.org/grpc/credentials\"\n)\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile(\"./keys/server.pem\", \"go-grpc-example\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tgrpc.WithInsecure()\n\n\tconn, err := grpc.Dial(\"localhost:8092\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer conn.Close()\n\n\tserviceClient := message.NewMathServiceClient(conn)\n\n\taddArgs := message.RequestArgs{Args1: 3, Args2: 5}\n\n\tresponse, err := serviceClient.AddMethod(context.Background(), &addArgs)\n\tif err != nil {\n\t\tgrpclog.Fatal(err.Error())\n\t}\n\n\tfmt.Println(response.GetCode(), response.GetMessage())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/tls\"\n)\n\nfunc connectAndAdd() {\n\tcert, err := os.ReadFile(\"server.crt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{{Certificate: cert}},\n\t}\n\n\tcreds := credentials.NewTLS(tlsConfig)\n\n\tconn, err := grpc.Dial(\"localhost:8092\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewMathServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tresp, err := client.Add(ctx, &AddRequest{A: 2, B: 3})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Response Code: %d, Message: %s\\n\", resp.Code, resp.Message)\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a Go function that makes a gRPC call to a test service's EmptyCall method, handling connection establishment and cleanup.\n\nFunction Description: The function invokes the EmptyCall RPC method on a gRPC test service. It establishes a connection to the server with timeout and blocking options, makes the RPC call, and properly closes the connection. The function handles both connection errors and RPC call errors.\n\nInput:\n- address: string - The server address to connect to\n- dialOptions: []grpc.DialOption - List of gRPC dial options for connection configuration\n\nOutput:\n- *testpb.Empty - The response from the EmptyCall RPC\n- error - Any error that occurred during connection or RPC call",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions []grpc.DialOption) (*testpb.Empty, error) {\n\tdialOptions = append(dialOptions, grpc.WithBlock())\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tclientConn, err := grpc.DialContext(ctx, address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer clientConn.Close()\n\n\tclient := testpb.NewTestServiceClient(clientConn)\n\n\tempty, err := client.EmptyCall(context.Background(), new(testpb.Empty))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn empty, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"yourpackage/testpb\"\n)\n\nfunc CallEmptyCall(address string, dialOptions []grpc.DialOption) (*emptypb.Empty, error) {\n\tconn, err := grpc.Dial(address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := testpb.NewTestServiceClient(conn)\n\tctx := context.Background()\n\tresp, err := client.EmptyCall(ctx, &emptypb.Empty{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC connection to a remote server, performs profiling operations based on input flags, and handles connection cleanup.\n\nFunction Description: The function `remoteCommand` establishes an insecure gRPC connection to a specified address, creates a profiling client, and executes either profiling enable/disable operations or retrieves a snapshot based on command-line flags. It handles connection timeouts and ensures proper connection closure.\n\nInput:\n- Context (implicit through package variables)\n- Command-line flags (implicit through package variables):\n  - `flagAddress`: string - gRPC server address to connect to\n  - `flagTimeout`: int - connection timeout in seconds (0 for no timeout)\n  - `flagEnableProfiling`: bool - whether to enable profiling\n  - `flagDisableProfiling`: bool - whether to disable profiling\n  - `flagRetrieveSnapshot`: bool - whether to retrieve a snapshot\n  - `flagSnapshot`: string - snapshot identifier (when retrieving)\n\nOutput:\n- error - returns nil on success, or an error describing what went wrong during execution",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tppb \"google.golang.org/grpc/profiling/proto\"\n)\nfunc remoteCommand() error {\n\tctx := context.Background()\n\tif *flagTimeout > 0 {\n\t\tvar cancel func()\n\t\tctx, cancel = context.WithTimeout(context.Background(), time.Duration(*flagTimeout)*time.Second)\n\t\tdefer cancel()\n\t}\n\n\tlogger.Infof(\"dialing %s\", *flagAddress)\n\tcc, err := grpc.Dial(*flagAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Errorf(\"cannot dial %s: %v\", *flagAddress, err)\n\t\treturn err\n\t}\n\tdefer cc.Close()\n\n\tc := ppb.NewProfilingClient(cc)\n\n\tif *flagEnableProfiling || *flagDisableProfiling {\n\t\treturn setEnabled(ctx, c, *flagEnableProfiling)\n\t}\n\tif *flagRetrieveSnapshot {\n\t\treturn retrieveSnapshot(ctx, c, *flagSnapshot)\n\t}\n\treturn fmt.Errorf(\"what should I do with the remote target?\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"flag\"\n\t\"time\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"your.package.profiling\"\n)\n\nvar (\n\tflagAddress         string\n\tflagTimeout         int\n\tflagEnableProfiling bool\n\tflagDisableProfiling bool\n\tflagRetrieveSnapshot bool\n\tflagSnapshot        string\n)\n\nfunc init() {\n\tflag.StringVar(&flagAddress, \"address\", \"localhost:50051\", \"gRPC server address\")\n\tflag.IntVar(&flagTimeout, \"timeout\", 0, \"connection timeout in seconds\")\n\tflag.BoolVar(&flagEnableProfiling, \"enable-profiling\", false, \"enable profiling\")\n\tflag.BoolVar(&flagDisableProfiling, \"disable-profiling\", false, \"disable profiling\")\n\tflag.BoolVar(&flagRetrieveSnapshot, \"retrieve-snapshot\", false, \"retrieve a snapshot\")\n\tflag.StringVar(&flagSnapshot, \"snapshot\", \"\", \"snapshot identifier\")\n}\n\nfunc remoteCommand() error {\n\tif flagEnableProfiling && flagDisableProfiling {\n\t\treturn fmt.Errorf(\"both enable and disable profiling flags are set\")\n\t}\n\tif flagRetrieveSnapshot && flagSnapshot == \"\" {\n\t\treturn fmt.Errorf(\"snapshot flag is required when retrieving a snapshot\")\n\t}\n\n\tctx := context.Background()\n\tif flagTimeout > 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(ctx, time.Second*time.Duration(flagTimeout))\n\t\tdefer cancel()\n\t}\n\n\tconn, err := grpc.DialContext(ctx, flagAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := profiling.NewProfilingClient(conn)\n\n\tvar errResp error\n\tif flagEnableProfiling {\n\t\t_, err := client.EnableProfiling(ctx, &profiling.EnableProfilingRequest{})\n\t\tif err != nil {\n\t\t\terrResp = fmt.Errorf(\"failed to enable profiling: %v\", err)\n\t\t}\n\t} else if flagDisableProfiling {\n\t\t_, err := client.DisableProfiling(ctx, &profiling.DisableProfilingRequest{})\n\t\tif err != nil {\n\t\t\terrResp = fmt.Errorf(\"failed to disable profiling: %v\", err)\n\t\t}\n\t} else if flagRetrieveSnapshot {\n\t\tif flagSnapshot == \"\" {\n\t\t\treturn fmt.Errorf(\"snapshot identifier is required\")\n\t\t}\n\t\tresp, err := client.RetrieveSnapshot(ctx, &profiling.RetrieveSnapshotRequest{SnapshotId: flagSnapshot})\n\t\tif err != nil {\n\t\t\terrResp = fmt.Errorf(\"failed to retrieve snapshot: %v\", err)\n\t\t}\n\t}\n\n\treturn errResp\n}"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a PubSub service, publishes messages, and handles connection cleanup.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 1234, creates a PubSub service client, publishes two predefined messages, and ensures proper connection closure. It demonstrates basic gRPC client operations including connection establishment, RPC calls, and resource cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function publishes messages to the server and logs errors if any occur)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"gobook.examples/ch4-04-grpc/grpc-pubsub/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"yourproject/pubsub\"\n)\n\nfunc publishMessages() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pubsub.NewPubSubClient(conn)\n\tmessages := []string{\"Message one\", \"Message two\"}\n\tfor _, msg := range messages {\n\t\tctx := context.Background()\n\t\t_, err := client.Publish(ctx, &pubsub.PublishRequest{Payload: msg})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC server for Google Pub/Sub emulator and initializes a Pub/Sub client using that connection.\n\nFunction Description: The function demonstrates how to set up a connection to a local gRPC server (Pub/Sub emulator) using insecure credentials, then creates a Pub/Sub client with the established connection. The client should be properly closed when no longer needed.\n\nInput: None (uses hardcoded values for demonstration purposes)\n\nOutput: None (function demonstrates setup pattern, actual Pub/Sub client is created but not used)\n\nNote: The function uses context.Background() for simplicity in the example, and hardcodes \"project\" as the Google Cloud project ID for demonstration purposes. In production code, these would typically be parameters.",
    "Canonical_solution": "import (\n\t\"cloud.google.com/go/pubsub\"\n\t\"cloud.google.com/go/pubsub/pstest\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n)\nfunc ExampleNewServer() {\n\tctx := context.Background()\n\tsrv := pstest.NewServer()\n\tconn, err := grpc.Dial(srv.Addr, grpc.WithInsecure())\n\tif err != nil {\n\t}\n\tclient, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t}\n\tdefer client.Close()\n\t_ = client\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n    \"context\"\n    \"cloud.google.com/go/pubsub\"\n    \"google.golang.org/grpc\"\n)\n\nfunc setupPubSubClient() {\n    ctx := context.Background()\n    conn, err := grpc.Dial(\"localhost:8085\", grpc.WithInsecure())\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    client, err := pubsub.NewClient(ctx, \"project\", pubsub.WithGRPCConn(conn))\n    if err != nil {\n        panic(err)\n    }\n    defer client.Close()\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a function that connects to a gRPC server, retrieves pod information using the HyperD Public API, and returns the response.\n\nFunction Description: The function establishes an insecure connection to a gRPC server at the specified address, creates a Public API client, sends a PodInfoRequest for a specific pod ID, and returns the pod information response. The connection is automatically closed when the function completes.\n\nInput: \n- server string: The address of the gRPC server (e.g., \"localhost:50051\")\n- podID string: The ID of the pod to query (e.g., \"pod-zpIOTSAjmM\")\n\nOutput:\n- *types.PodInfoResponse: The response containing pod information\n- error: Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/hyperhq/hyperd/types\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(server, grpc.WithInsecure())\n\tif err != nil {\n\t\tfmt.Printf(\"Connect server error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tclient := types.NewPublicAPIClient(conn)\n\trequest := types.PodInfoRequest{\n\t\tPodID: \"pod-zpIOTSAjmM\",\n\t}\n\tresponse, err := client.PodInfo(context.Background(), &request)\n\tif err != nil {\n\t\tfmt.Printf(\"Get PodInfo error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Got response: %v\", response)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"hyperdpublic\" // Assuming this is the package name for generated gRPC client code\n\t\"hyperdpublic/types\" // Assuming this is the package for the request/response types\n)\n\nfunc GetPodInfo(server, podID string) (*types.PodInfoResponse, error) {\n\tconn, err := grpc.Dial(server, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := hyperdpublic.NewPublicAPIClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\trequest := &types.PodInfoRequest{\n\t\tPodId: podID,\n\t}\n\n\tresponse, err := client.PodInfo(ctx, request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and processes the response.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client instance for the Greeter service, sends a HelloRequest with a name parameter, and logs the server's response or any errors encountered during the process.\n\nInput: \n- address: string - The server address in format \"host:port\" (default: \"localhost:50051\")\n- name: string - The name to send in the greeting request (default: \"world\")\n\nOutput:\n- None (directly logs results to console)\n- Side effect: Sends gRPC request and receives response",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"go.opencensus.io/examples/grpc/proto\"\n\t\"go.opencensus.io/plugin/ocgrpc\"\n)\n\nconst (\n\taddress     = \"localhost:50051\"\n\tdefaultName = \"world\"\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithStatsHandler(&ocgrpc.ClientHandler{}), grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Cannot connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Printf(\"Could not greet: %v\", err)\n\t} else {\n\t\tlog.Printf(\"Greeting: %s\", r.Message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"greetpb\"\n)\n\nfunc greetClient(address string, name string) {\n\tif address == \"\" {\n\t\taddress = \"localhost:50051\"\n\t}\n\tif name == \"\" {\n\t\tname = \"world\"\n\t}\n\n\tconn, err := grpc.Dial(address, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := greetpb.NewGreeterClient(conn)\n\n\treq := &greetpb.HelloRequest{\n\t\tName: name,\n\t}\n\n\tctx := context.Background()\n\tresp, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to greet: %v\", err)\n\t}\n\n\tlog.Printf(\"Server response: %s\\n\", resp.Message)\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Create a gRPC client in Go that connects to a RouteGuide service, performs various operations (getting features, listing features within a rectangle, recording a route, and conducting route chat), and handles secure/insecure connections.\n\nFunction Description: The main function establishes a connection to a gRPC server, creates a RouteGuide client, and demonstrates various service operations. It handles both secure (TLS) and insecure connections based on input flags.\n\nInput:\n- Command line flags (implicit):\n  - tls (bool): Whether to use TLS encryption\n  - serverHostOverride (string): Server name for certificate validation\n  - caFile (string): Path to CA certificate file\n  - serverAddr (string): Server address in format host:port\n\nOutput:\n- None (direct output to console/logger)\n- Side effects: Makes gRPC calls to server and prints results\n\nMethods called (from RouteGuideClient):\n1. printFeature(client, point) - Gets and prints a feature at given point\n2. printFeatures(client, rectangle) - Lists features within given rectangle\n3. runRecordRoute(client) - Records a route and prints statistics\n4. runRouteChat(client) - Conducts bidirectional route chat",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &pb.Point{409146138, -746188906})\n\tprintFeature(client, &pb.Point{0, 0})\n\tprintFeatures(client, &pb.Rectangle{&pb.Point{400000000, -750000000}, &pb.Point{420000000, -730000000}})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/examples/route_guide/route_guide\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n)\n\nvar (\n\ttls         bool\n\tserverHostOverride string\n\tcaFile      string\n\tserverAddr  string\n)\n\nfunc main() {\n\tflag.BoolVar(&tls, \"tls\", false, \"Use TLS\")\n\tflag.StringVar(&serverHostOverride, \"server-host-override\", \"\", \"Server name for certificate validation\")\n\tflag.StringVar(&caFile, \"ca-file\", \"\", \"Path to CA certificate file\")\n\tflag.StringVar(&serverAddr, \"server-addr\", \"localhost:50051\", \"Server address\")\n\tflag.Parse()\n\n\topts := []grpc.DialOption{}\n\tif tls {\n\t\tcert, err := os.ReadFile(caFile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to read CA file: %v\", err)\n\t\t}\n\t\tcerts := x509.NewCertPool()\n\t\tif !certs.AppendCertsFromPEM(cert) {\n\t\t\tlog.Fatalf(\"Failed to append CA certificate\")\n\t\t}\n\t\tcreds := credentials.NewTLS(&tls.Config{\n\t\t\tRootCAs: certs,\n\t\t\tServerName: serverHostOverride,\n\t\t})\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := route_guide.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &route_guide.Point{Latitude: 40960000, Longitude: -740000})\n\tprintFeatures(client, &route_guide.Rectangle{\n\t\tLo: &route_guide.Point{Latitude: 40960000, Longitude: -740000},\n\t\tHi: &route_guide.Point{Latitude: 40960000 + 100000, Longitude: -740000 + 100000},\n\t})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}\n\nfunc printFeature(client route_guide.RouteGuideClient, point *route_guide.Point) {\n\tctx := context.Background()\n\tfeature, err := client.GetFeature(ctx, point)\n\tif err != nil {\n\t\tlog.Fatalf(\"GetFeature: %v\", err)\n\t}\n\tif feature.GetName() == \"\" {\n\t\tfmt.Printf(\"Found no feature at (%d, %d)\\n\", point.Latitude, point.Longitude)\n\t} else {\n\t\tfmt.Printf(\"Found feature called %s at (%d, %d)\\n\", feature.GetName(), feature.GetLocation().GetLatitude(), feature.GetLocation().GetLongitude())\n\t}\n}\n\nfunc printFeatures(client route_guide.RouteGuideClient, rectangle *route_guide.Rectangle) {\n\tctx := context.Background()\n\tfeatures, err := client.ListFeatures(ctx, rectangle)\n\tif err != nil {\n\t\tlog.Fatalf(\"ListFeatures: %v\", err)\n\t}\n\tif len(features) == 0 {\n\t\tfmt.Printf(\"No features found in the given rectangle.\\n\")\n\t} else {\n\t\tfmt.Printf(\"Found %d features in the given rectangle:\\n\", len(features))\n\t\tfor _, feature := range features {\n\t\t\tfmt.Printf(\"Feature called %s at (%d, %d)\\n\", feature.GetName(), feature.GetLocation().GetLatitude(), feature.GetLocation().GetLongitude())\n\t\t}\n\t}\n}\n\nfunc runRecordRoute(client route_guide.RouteGuideClient) {\n\tctx := context.Background()\n\tpoints := make([]*route_guide.Point, 0, 10)\n\tfor i := 0; i < 10; i++ {\n\t\tpoints = append(points, &route_guide.Point{\n\t\t\tLatitude:  409600000 + int64(i)*100000,\n\t\t\tLongitude: -740000000 + int64(i)*100000,\n\t\t})\n\t}\n\tstream, err := client.RecordRoute(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"RecordRoute: %v\", err)\n\t}\n\tfor _, p := range points {\n\t\tif err := stream.Send(p); err != nil {\n\t\t\tlog.Fatalf(\"Send: %v\", err)\n\t\t}\n\t}\n\tresp, err := stream.CloseAndRecv()\n\tif err != nil {\n\t\tlog.Fatalf(\"CloseAndRecv: %v\", err)\n\t}\n\tfmt.Printf(\"RouteSummary: %v\\n\", resp)\n}\n\nfunc runRouteChat(client route_guide.RouteGuideClient) {\n\tctx := context.Background()\n\tstream, err := client.RouteChat(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"RouteChat: %v\", err)\n\t}\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tpoint := &route_guide.Point{\n\t\t\t\tLatitude:  409600000 + int64(i)*100000,\n\t\t\t\tLongitude: -740000000 + int64(i)*100000,\n\t\t\t}\n\t\t\tif err := stream.Send(point); err != nil {\n\t\t\t\tlog.Fatalf(\"Send: %v\", err)\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}()\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Recv: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Received: %v\\n\", resp)\n\t}\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and receives a response.\n\nFunction Description: The function establishes a connection to a gRPC server using the provided address, creates a client for the HelloService, sends a HelloRequest with the specified name, and returns the server's response. It handles connection errors and timeout contexts.\n\nInput:\n- addr: string - The address of the gRPC server to connect to (e.g., \"127.0.0.1:8972\")\n- name: string - The name to include in the greeting request\n\nOutput:\n- string - The greeting response from the server\n- error - Any error that occurred during the process\n\nNote: The function should properly close the connection when done and handle context timeouts.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"hello_grpc_client/proto\"\n\t\"log\"\n\t\"time\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:8972\", \"the address to connect to\")\n\tname = flag.String(\"name\", defaultName, \"Name to greet\")\n)\n\nfunc main() {\n\tflag.Parse()\n\tconn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := proto.NewHelloServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.SayHello(ctx, &proto.HelloRequest{\n\t\tName: *name,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\n\tlog.Printf(\"Greeting: %s\", r.GetReply())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc Greet(addr, name string) (string, error) {\n\tconnCtx, connCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer connCancel()\n\n\tconn, err := grpc.DialContext(connCtx, addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer conn.Close()\n\n\tclient := NewHelloServiceClient(conn)\n\treq := &HelloRequest{Name: name}\n\n\trpcCtx, rpcCancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer rpcCancel()\n\n\tresp, err := client.Hello(rpcCtx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn resp.Greeting, nil\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and properly handle the connection lifecycle.\n\nFunction Description: The function tests gRPC client functionality by connecting to a user authentication service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper gRPC connection management and metadata handling.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None directly returned, but prints authentication tokens to stdout\n- Returns error if connection or RPC calls fail\n\nNote: The function includes error handling and connection cleanup via defer. It uses metadata to pass a UUID for request tracking and demonstrates multiple RPC calls in a loop.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/src\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/google/uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"authpb\"\n)\n\nfunc TestLogin(serviceAddress, account, password string, testCount int) error {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := authpb.NewAuthServiceClient(conn)\n\n\tfor i := 0; i < testCount; i++ {\n\t\tuuidStr := uuid.New().String()\n\t\tctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs(\"uuid\", uuidStr))\n\t\treq := &authpb.LoginRequest{\n\t\t\tUsername: account,\n\t\t\tPassword: password,\n\t\t}\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Received token: %s\\n\", resp.Token)\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, publishes messages, and handles connection cleanup.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client for the PubsubService, publishes two predefined messages, and ensures proper connection closure. The function handles potential connection errors and publishing failures.\n\nInput: None (The target server address is hardcoded as \"localhost:1234\" and messages are predefined)\n\nOutput: None (The function performs side effects by publishing messages to the gRPC server and may terminate the program on errors)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"ch4.4-3/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"pubsubpb\"\n)\n\nfunc PublishMessages() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithTimeout(5*time.Second))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pubsubpb.NewPubsubServiceClient(conn)\n\tmessages := []string{\"Hello\", \"World\"}\n\tfor _, msg := range messages {\n\t\t_, err := client.Publish(context.Background(), &pubsubpb.PublishRequest{Message: msg})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to publish message: %v\", err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and handle the responses.\n\nFunction Description: The function tests a gRPC client implementation by connecting to a user service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper connection handling, metadata usage, and error handling in gRPC communications.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None (prints tokens to stdout)\n- Returns error if connection or RPC fails\n\nNote: The function includes proper connection cleanup using defer and demonstrates metadata handling for request tracing.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/utils\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/user_agent/pb\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n)\n\nfunc TestLogin(serviceAddress string, account string, password string, testCount int) error {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := NewUserServiceClient(conn)\n\n\tfor i := 0; i < testCount; i++ {\n\t\treqUUID := uuid.New().String()\n\t\tmd := metadata.Pairs(\"x-uuid\", reqUUID)\n\t\tctx := metadata.NewContext(context.Background(), md)\n\t\treq := &LoginRequest{Account: account, Password: password}\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Received token: %s\\n\", resp.Token)\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a function that tests a gRPC client connection to a user authentication service, sends multiple login requests, and prints the received authentication tokens.\n\nFunction Description: The function establishes an insecure gRPC connection to a specified server address, creates a user client, and sends 20 consecutive login requests with metadata containing a UUID. Each successful response's token is printed, while errors cause immediate termination.\n\nInput: None (The service address is hardcoded as \"127.0.0.1:8881\" and login credentials are fixed as account \"hwholiday\" and password \"123456\")\n\nOutput: None (The function prints tokens to stdout and may return early on error through testing.T's Error method)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/google/uuid\"\n\t\"yourpackage/userpb\"\n)\n\nfunc TestLoginRequests(t *testing.T) {\n\tconn, err := grpc.Dial(\"127.0.0.1:8881\", grpc.WithInsecure())\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := userpb.NewUserServiceClient(conn)\n\n\tfor i := 0; i < 20; i++ {\n\t\tuuidStr := uuid.New().String()\n\t\tctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs(\"uuid\", uuidStr))\n\t\tresp, err := client.Login(ctx, &userpb.LoginRequest{\n\t\t\tAccount: \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(resp.Token)\n\t}\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Write a Go function that tests the version retrieval functionality of a gRPC service using the Stripe CLI client. The function should establish a connection to the gRPC server, call the Version method, and verify the response matches the expected version.\n\nFunction Description: The function `TestVersionReturnsCLIVersion` is a test function that verifies the version information returned by a gRPC service. It establishes an authenticated connection to a gRPC server, calls the Version RPC method, and checks that the returned version matches the expected value (\"master\"). The connection is properly closed after the test completes.\n\nInput: \n- `t *testing.T`: The testing context provided by Go's testing framework for reporting test failures and logging.\n- Implicit context from `withAuth(context.Background())`: An authenticated context for the gRPC call.\n\nOutput: \n- The function does not return any value but will fail the test if any of the following occur:\n  - The gRPC connection cannot be established\n  - The Version RPC call fails\n  - The returned version does not match the expected value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Version(ctx, &rpc.VersionRequest{})\n\tif err != nil {\n\t\tt.Fatalf(\"Version failed: %v\", err)\n\t}\n\n\texpected := rpc.VersionResponse{\n\t\tVersion: \"master\",\n\t}\n\n\tassert.Equal(t, expected.Version, resp.Version)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-go\"\n\t\"github.com/stripe/stripe-go/version\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := stripe.NewStripeServiceClient(conn)\n\tresp, err := client.Version(ctx, &version.Request{})\n\tif err != nil {\n\t\tt.Fatalf(\"Version call failed: %v\", err)\n\t}\n\tif resp.Version != \"master\" {\n\t\tt.Errorf(\"expected version master, got %s\", resp.Version)\n\t}\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Implement a gRPC client function in Go that connects to a gRPC server, performs unary and streaming RPCs, and handles communication with the server.\n\nFunction Description: The function `doClientWork` establishes a connection to a gRPC server, performs a unary RPC call (`Hello`), and then sets up bidirectional streaming (`Channel`). It sends messages periodically in one goroutine while receiving messages in the main goroutine.\n\nInput: None (The server address is hardcoded as \"localhost:1234\")\n\nOutput: None (The function prints received messages to stdout and logs errors to stderr)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc doClientWork() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(reply.GetValue())\n\n\tstream, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\tif err := stream.Send(&String{Value: \"hi\"}); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tfor {\n\t\tlog.Println(222)\n\n\t\treply, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(reply.GetValue())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc doClientWork() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewMyServiceClient(conn)\n\n\t// Unary RPC\n\tresp, err := client.Hello(context.Background(), &HelloRequest{Message: \"Hello\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"Hello failed: %v\", err)\n\t}\n\tfmt.Printf(\"Hello response: %s\\n\", resp.Response)\n\n\t// Streaming RPC\n\tstream, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Channel failed: %v\", err)\n\t}\n\n\tsend := func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\terr := stream.Send(&ChannelRequest{Message: fmt.Sprintf(\"Message %d\", i)})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"Send error: %v\", err)\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\terr := stream.CloseSend()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"CloseSend error: %v\", err)\n\t\t}\n\t}\n\n\tgo send()\n\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err == nil {\n\t\t\tfmt.Printf(\"Received: %s\\n\", msg.Message)\n\t\t} else if err == io.EOF {\n\t\t\tbreak\n\t\t} else {\n\t\t\tlog.Fatalf(\"Recv error: %v\", err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a function to test gRPC client functionality for user login using Go's gRPC package. The function should establish a connection to a gRPC server, send multiple login requests with metadata, and handle responses.\n\nFunction Description: The function tests the gRPC client's ability to communicate with a user service. It establishes an insecure connection to the specified server address, creates a client instance, and sends 20 consecutive login requests with generated UUID metadata. Each request uses the same account credentials and prints the received authentication token.\n\nInput: None (The function is a test function with hardcoded values)\n\nOutput: None (The function prints tokens to stdout and may return errors through the testing framework)\n\nNote: The function uses package-level variables and imports from external packages as shown in the reference code. The connection is automatically closed when the function completes.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/utils\"\n\tuuid \"github.com/satori/go.uuid\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuserpb \"userpb\"\n)\n\nfunc testLogin() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := userpb.NewUserClient(conn)\n\n\tfor i := 0; i < 20; i++ {\n\t\tuuidStr := uuid.New().String()\n\t\tmd := metadata.New(map[string]string{\"uuid\": uuidStr})\n\t\tctx := metadata.NewContext(context.Background(), md)\n\t\treq := &userpb.LoginRequest{\n\t\t\tUsername: \"testuser\",\n\t\t\tPassword: \"testpass\",\n\t\t}\n\t\tres, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Login failed: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Received token: %s\\n\", res.Token)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a HelloService server, sends a greeting, and handles the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:1234, creates a client for the HelloService, sends a \"hello\" message, and processes the server's reply. It handles connection errors and RPC call errors appropriately.\n\nInput: None (The server address and message are hardcoded in this example)\n\nOutput: None (The function logs errors and doesn't return any value, though in a real implementation you might want to return the reply or error)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\ths \"ch4.4-1/helloservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := hs.NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &hs.String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"hello/hello.pb\"\n)\n\nfunc SayHello() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := hello.NewHelloServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\treq := &hello.HelloRequest{Message: \"hello\"}\n\tresp, err := client.Hello(ctx, req)\n\tif err != nil {\n\t\tlog.Fatalf(\"RPC failed: %v\", err)\n\t}\n\tlog.Printf(\"Received: %s\", resp.Reply)\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a metrics server, retrieves metrics, and prints them. The function should handle connection setup and teardown, and provide options for controlling output format.\n\nFunction Description: The function connects to a gRPC metrics server using the provided address, creates a metrics service client, and prints the retrieved metrics. It supports a flag to determine whether to print all metrics or just the total. The connection is automatically closed when the function completes.\n\nInput:\n- metricsServerAddress (string): The address of the gRPC metrics server to connect to\n- totalOnly (bool): Flag indicating whether to print only the total metrics or all metrics\n\nOutput: None (prints metrics to stdout directly)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/grpclog\"\n\tmetricspb \"google.golang.org/grpc/interop/stress/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *metricsServerAddress == \"\" {\n\t\tlogger.Fatal(\"-metrics_server_address is unset\")\n\t}\n\n\tconn, err := grpc.Dial(*metricsServerAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Fatalf(\"cannot connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := metricspb.NewMetricsServiceClient(conn)\n\tprintMetrics(c, *totalOnly)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"metrics\"\n)\n\nfunc GetMetricsFromServer(metricsServerAddress string, totalOnly bool) {\n\tconn, err := grpc.Dial(metricsServerAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := metrics.NewMetricsServiceClient(conn)\n\tctx := context.Background()\n\tresp, err := client.GetMetrics(ctx, &metrics.GetMetricsRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get metrics: %v\", err)\n\t}\n\n\tif totalOnly {\n\t\tfmt.Printf(\"Total: %d\\n\", resp.Total)\n\t} else {\n\t\tfmt.Printf(\"Total: %d\\n\", resp.Total)\n\t\tfmt.Printf(\"Count: %d\\n\", resp.Count)\n\t\tfmt.Printf(\"Average: %.2f\\n\", resp.Average)\n\t}\n}"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework. The server should be able to gracefully shut down when the context is canceled.\n\nFunction Description: The MainExt function initializes and starts a gRPC server. It sets up a network listener, creates a gRPC server instance, registers the service implementation, and starts the server in a goroutine. The function waits for the context to be canceled before gracefully shutting down the server.\n\nInput:\n- ctx [context.Context]: The context used to control the lifecycle of the gRPC server. Canceling this context will trigger a graceful shutdown.\n- cfg [Config]: A configuration object containing the port number on which the server should listen.\n\nOutput: None (The function runs indefinitely until the context is canceled or an error occurs.)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\ttriggerpb \"github.com/vanus-labs/vanus/api/trigger\"\n)\n\ntype TriggerServer struct {\n\tcfg Config\n}\n\nfunc NewTriggerServer(cfg Config) *TriggerServer {\n\treturn &TriggerServer{\n\t\tcfg: cfg,\n\t}\n}\n\nfunc MainExt(ctx context.Context, cfg Config) {\n\tlisten, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n\tif err != nil {\n\t\tlog.Error().Msg(\"failed to listen\")\n\t\tos.Exit(-1)\n\t}\n\n\tsrv := NewTriggerServer(cfg)\n\n\tvar opts []grpc.ServerOption\n\tgrpcServer := grpc.NewServer(opts...)\n\ttriggerpb.RegisterTriggerWorkerServer(grpcServer, srv)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Info(ctx).Msg(\"the grpc server ready to work\")\n\t\terr = grpcServer.Serve(listen)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"grpc server occurred an error\")\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\tgrpcServer.GracefulStop()\n\twg.Wait()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net\"\n    \"google.golang.org/grpc\"\n)\n\nfunc MainExt(ctx context.Context, cfg Config) {\n    listener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n\n    server := grpc.NewServer()\n    myService := &myServiceImpl{}\n    RegisterMyServiceServer(server, myService)\n\n    go func() {\n        if err := server.Serve(listener); err != nil {\n            log.Fatalf(\"gRPC server failed: %v\", err)\n        }\n    }()\n\n    <-ctx.Done()\n\n    server.GracefulStop()\n    <-server.Done()\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, creates a new gRPC server instance, registers a service implementation, and starts serving incoming requests.\n\nInput: \n- port: string - The network port on which the server should listen (e.g., \":50051\")\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/helloworld/helloworld\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\ts.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype HelloServiceServer interface {\n\tSayHello(ctx context.Context, req *HelloRequest) (*HelloResponse, error)\n}\n\ntype HelloRequest struct {\n\tName string\n}\n\ntype HelloResponse struct {\n\tMessage string\n}\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, req *HelloRequest) (*HelloResponse, error) {\n\treturn &HelloResponse{Message: \"Hello, \" + req.Name}, nil\n}\n\nfunc main() {\n\tport := \":50051\"\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\t// Register the service with the gRPC server\n\t// This assumes a generated server implementation, which would be created from a .proto file\n\t// For demonstration, we use a placeholder registration\n\tRegisterHelloServiceServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a gRPC server in Go that handles metric forwarding operations, including receiving metrics and processing them through a handler function.\n\nStruct Description: The Server struct represents a gRPC server that listens for incoming metric data and processes it using a provided handler function. It manages server lifecycle and handles gRPC communication.\n\nFields:\n- Server: *grpc.Server - The underlying gRPC server instance\n- lis: net.Listener - The network listener for the server\n- handler: func([]*metricpb.Metric) - The function that processes received metrics\n- startMtx: sync.Mutex - Mutex to ensure thread-safe server startup\n\nMethods:\n- NewServer: (handler func([]*metricpb.Metric)) -> *Server - Creates a new Server instance with the given metric handler and initializes the gRPC server\n- Start: (t testing.TB) -> () - Starts the gRPC server on a random available port and begins listening for requests\n- SendMetrics: (ctx context.Context, mlist *forwardrpc.MetricList) -> (*empty.Empty, error) - Handles unary RPC calls for metric submission\n- SendMetricsV2: (server forwardrpc.Forward_SendMetricsV2Server) -> error - Handles streaming RPC calls for metric submission",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\n\t\"context\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/stripe/veneur/v14/forwardrpc\"\n\t\"github.com/stripe/veneur/v14/samplers/metricpb\"\n)\n\ntype Server struct {\n\t*grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\tres := &Server{\n\t\tServer:  grpc.NewServer(),\n\t\thandler: handler,\n\t}\n\n\tforwardrpc.RegisterForwardServer(res.Server, res)\n\treturn res\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\tvar err error\n\ts.lis, err = net.Listen(\"tcp\", \"127.0.0.1:\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create a TCP connection for a test GRPC \"+\n\t\t\t\"server: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := s.Serve(s.lis); err != nil && err != grpc.ErrServerStopped {\n\t\t\tt.Logf(\"failed to stop the test forwarding gRPC server: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) SendMetrics(ctx context.Context, mlist *forwardrpc.MetricList) (*empty.Empty, error) {\n\ts.handler(mlist.Metrics)\n\treturn &empty.Empty{}, nil\n}\n\nfunc (s *Server) SendMetricsV2(\n\tserver forwardrpc.Forward_SendMetricsV2Server,\n) error {\n\tmetrics := []*metricpb.Metric{}\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmetrics = append(metrics, metric)\n\t}\n\t_, err := s.SendMetrics(context.Background(), &forwardrpc.MetricList{\n\t\tMetrics: metrics,\n\t})\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"google.golang.org/grpc\"\n\t\"your.package.forwardrpc\"\n\t\"your.package.metricpb\"\n)\n\ntype Server struct {\n\tServer   *grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\ts := &Server{\n\t\thandler: handler,\n\t}\n\ts.Server = grpc.NewServer()\n\tforwardrpc.RegisterForwardServer(s.Server, s)\n\treturn s\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\tif s.lis != nil {\n\t\tt.Fatal(\"Server already started\")\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts.lis = lis\n\n\tgo func() {\n\t\tif err := s.Server.Serve(lis); err != nil {\n\t\t\tt.Errorf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) SendMetrics(ctx context.Context, mlist *forwardrpc.MetricList) (*empty.Empty, error) {\n\ts.handler(mlist.Metrics)\n\treturn &empty.Empty{}, nil\n}\n\nfunc (s *Server) SendMetricsV2(server forwardrpc.Forward_SendMetricsV2Server) error {\n\tvar metrics []*metricpb.Metric\n\tfor {\n\t\tm, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\ts.handler(metrics)\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmetrics = append(metrics, m)\n\t}\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both physical data source operations and execution of data processing tasks, using Unix domain sockets for inter-process communication.\n\nStruct Description: The implementation consists of two main structs: physicalServer handles the materialization of data sources, while executionServer manages the execution of data processing tasks.\n\nFields:\n\nphysicalServer:\n- database: physical.Database - The underlying database implementation\n- socketDir: string - Directory where Unix domain sockets will be created\n- wg: *sync.WaitGroup - WaitGroup for managing server goroutines\n\nexecutionServer:\n- node: execution.Node - The execution node to process data\n\nMethods:\n\nphysicalServer:\n- Materialize(context.Context, *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) - Materializes a data source and starts a gRPC server for execution\n\nexecutionServer:\n- Run(*plugins.RunRequest, plugins.ExecutionDatasource_RunServer) error - Executes the data processing task and streams results back to the client",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/cube2222/octosql/execution\"\n\t\"github.com/cube2222/octosql/physical\"\n\t\"github.com/cube2222/octosql/plugins/internal/plugins\"\n)\n\ntype physicalServer struct {\n\tplugins.UnimplementedDatasourceServer\n\tdatabase  physical.Database\n\tsocketDir string\n\twg        *sync.WaitGroup\n}\n\nfunc (s *physicalServer) Materialize(ctx context.Context, request *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\timpl, _, err := s.database.GetTable(ctx, request.TableContext.TableName, request.TableContext.Options)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't get table: %w\", err)\n\t}\n\n\tnode, err := impl.Materialize(\n\t\tctx,\n\t\tphysical.Environment{\n\t\t\tVariableContext: request.VariableContext.ToNativePhysicalVariableContext(),\n\t\t},\n\t\trequest.Schema.ToNativeSchema(),\n\t\tpushedDownPredicates,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't materialize datasource: %w\", err)\n\t}\n\n\tsocketName := ulid.MustNew(ulid.Now(), rand.Reader).String() + \".sock\"\n\tsocketPath := filepath.Join(s.socketDir, socketName)\n\tlog.Printf(\"Listening execution on %s\", socketPath)\n\tlis, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\texecServer := &executionServer{\n\t\tnode: node,\n\t}\n\ts.wg.Add(1)\n\n\tgrpcServer := grpc.NewServer()\n\tplugins.RegisterExecutionDatasourceServer(grpcServer, execServer)\n\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\treturn &plugins.MaterializeResponse{SocketPath: socketPath}, nil\n}\n\ntype executionServer struct {\n\tplugins.UnimplementedExecutionDatasourceServer\n\tnode execution.Node\n}\n\nfunc (e *executionServer) Run(request *plugins.RunRequest, stream plugins.ExecutionDatasource_RunServer) error {\n\tif err := e.node.Run(\n\t\texecution.ExecutionContext{\n\t\t\tContext:         stream.Context(),\n\t\t\tVariableContext: request.VariableContext.ToNativeExecutionVariableContext(),\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, record execution.Record) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tRecord: plugins.NativeRecordToProto(record),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send record to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, msg execution.MetadataMessage) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tMetadata: plugins.NativeMetadataMessageToProto(msg),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send metadata message to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t); err != nil {\n\t\treturn fmt.Errorf(\"couldn't run node: %w\", err)\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"syscall\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/yourusername/plugins\"\n\t\"yourpackage/physical\"\n\t\"yourpackage/execution\"\n)\n\ntype physicalServer struct {\n\tdatabase *physical.Database\n\tsocketDir string\n\twg       *sync.WaitGroup\n}\n\ntype executionServer struct {\n\tnode *execution.Node\n}\n\nfunc (s *physicalServer) Materialize(ctx context.Context, req *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\tsocketDir := s.socketDir\n\tif err := os.MkdirAll(socketDir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\tsocketPath := filepath.Join(socketDir, \"materialize.sock\")\n\tos.Remove(socketPath)\n\tlistener, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer listener.Close()\n\n\tgrpcServer := grpc.NewServer()\n\tnode := s.database.GetExecutionNode()\n\texecServer := &executionServer{node: node}\n\tplugins.RegisterExecutionDatasourceServer(grpcServer, execServer)\n\n\tgo func() {\n\t\tsigChan := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\t\t<-sigChan\n\t\tgrpcServer.Stop()\n\t}() \n\n\tgo func() {\n\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\tfmt.Printf(\"gRPC server exited with error: %v\\n\", err)\n\t\t}\n\t}()\n\n\ts.wg.Add(1)\n\treturn &plugins.MaterializeResponse{}, nil\n}\n\nfunc (s *executionServer) Run(req *plugins.RunRequest, srv plugins.ExecutionDatasource_RunServer) error {\n\tresults := s.node.Process(req)\n\tfor _, result := range results {\n\t\tif err := srv.Send(&plugins.ExecutionResult{Data: result}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles unary RPC calls with ORCA (Open Request Cost Aggregation) metrics recording capabilities.\n\nStruct Description: The server struct implements the gRPC service interface (generated from the protobuf definition) and includes ORCA metrics recording functionality.\n\nFields:\n- UnimplementedEchoServer: [pb.UnimplementedEchoServer] - Embedded type to satisfy the gRPC service interface requirements\n\nMethods:\n- UnaryEcho: [Name](ctx context.Context, in *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls, records request costs using ORCA metrics, and returns an echo response\n- main: [Name]() -> None - Sets up the gRPC server, registers the service, configures ORCA metrics reporting, and starts the server\n\nInput Parameters for UnaryEcho:\n- ctx: [context.Context] - Context containing call information and ORCA metrics recorder\n- in: [*pb.EchoRequest] - Incoming request message containing the message to echo\n\nOutput for UnaryEcho:\n- [*pb.EchoResponse] - Response message containing the echoed message\n- [error] - Potential error during processing\n\nNote: The main function doesn't have explicit input/output but performs server setup and execution.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/orca\"\n\t\"google.golang.org/grpc/internal\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tcmr := orca.CallMetricsRecorderFromContext(ctx)\n\tif cmr == nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"unable to retrieve call metrics recorder (missing ORCA ServerOption?)\")\n\t}\n\tcmr.SetRequestCost(\"db_queries\", 10)\n\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(orca.CallMetricsServerOption(nil))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tsmr := orca.NewServerMetricsRecorder()\n\topts := orca.ServiceOptions{\n\t\tMinReportingInterval:  3 * time.Second,\n\t\tServerMetricsProvider: smr,\n\t}\n\tinternal.ORCAAllowAnyMinReportingInterval.(func(so *orca.ServiceOptions))(&opts)\n\tif err := orca.Register(s, opts); err != nil {\n\t\tlog.Fatalf(\"Failed to register ORCA service: %v\", err)\n\t}\n\n\ts.Serve(lis)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n)\n\ntype orcaRecorder struct {\n\tstartTime time.Time\n}\n\nfunc (r *orcaRecorder) Start() {\n\tr.startTime = time.Now()\n}\n\nfunc (r *orcaRecorder) Stop() {\n\tduration := time.Since(r.startTime)\n\tlog.Printf(\"ORCA Metric - Request Duration: %v\", duration)\n}\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n\trecorder *orcaRecorder\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\ts.recorder.Start()\n\tdefer s.recorder.Stop()\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\t// Assume pb.RegisterEchoServer is defined from the protobuf\n\tsrv := &server{\n\t\trecorder: &orcaRecorder{},\n\t}\n\tpb.RegisterEchoServer(s, srv)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, registers service implementations, and starts serving on a specified port with optional TLS credentials.\n\nFunction Description: The main function initializes and starts a gRPC server that hosts two services: a custom SpannerExecutorProxy service and a standard health check service. It validates required configuration parameters, sets up the network listener, creates the gRPC server instance, registers services, and begins serving requests.\n\nInput:\n- proxyPort (string): The port number on which the gRPC server should listen\n- spannerPort (string): The port number for Spanner service (validation only)\n- cert (string): Path to certificate file for TLS (validation only)\n- Additional client options are obtained internally through getClientOptionsForSysTests()\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Logs server startup information or errors to stdout\n\nNote: The function doesn't explicitly return values but may terminate the program with log.Fatal or log.Fatalf in case of errors during setup. Successful execution results in a continuously running gRPC server.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"cloud.google.com/go/spanner/executor/apiv1/executorpb\"\n\t\"cloud.google.com/go/spanner/test/cloudexecutor/executor\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *proxyPort == \"\" {\n\t\tlog.Fatal(\"Proxy port need to be assigned in order to start worker proxy.\")\n\t}\n\tif *spannerPort == \"\" {\n\t\tlog.Fatal(\"Spanner proxyPort need to be assigned in order to start worker proxy.\")\n\t}\n\tif *cert == \"\" {\n\t\tlog.Fatalf(\"Certificate need to be assigned in order to start worker proxy.\")\n\t}\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%s\", *proxyPort))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\n\tclientOptions := getClientOptionsForSysTests()\n\tcloudProxyServer, err := executor.NewCloudProxyServer(context.Background(), clientOptions)\n\tif err != nil {\n\t\tlog.Fatalf(\"Creating Cloud Proxy Server failed: %v\", err)\n\t}\n\texecutorpb.RegisterSpannerExecutorProxyServer(grpcServer, cloudProxyServer)\n\n\thealthServer := health.NewServer()\n\tgrpc_health_v1.RegisterHealthServer(grpcServer, healthServer)\n\n\tlog.Printf(\"Server started on proxyPort:%s\\n\", *proxyPort)\n\terr = grpcServer.Serve(lis)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to start server on proxyPort: %s\\n\", *proxyPort)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_check\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"io/ioutil\"\n\t\"context\"\n\t\"time\"\n)\n\nfunc isValidPort(port string) bool {\n\tif port == \"\" {\n\t\treturn false\n\t}\n\tp, err := strconv.Atoi(port)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn p >= 1 && p <= 65535\n}\n\nfunc loadCertificate(certFile string) (tls.Certificate, error) {\n\tcert, err := tls.LoadX509KeyPair(certFile, certFile)\n\tif err != nil {\n\t\treturn tls.Certificate{}, err\n\t}\n\treturn cert, nil\n}\n\nfunc main() {\n\tproxyPort := \"50051\"\n\tspannerPort := \"8080\"\n\tcert := \"/path/to/cert.pem\"\n\n\tif !isValidPort(proxyPort) {\n\t\tlog.Fatalf(\"Invalid proxy port: %s\", proxyPort)\n\t}\n\tif !isValidPort(spannerPort) {\n\t\tlog.Fatalf(\"Invalid spanner port: %s\", spannerPort)\n\t}\n\n\tif cert != \"\" {\n\t\tif _, err := os.Stat(cert); os.IsNotExist(err) {\n\t\t\tlog.Fatalf(\"Certificate file not found: %s\", cert)\n\t\t}\n\t}\n\n\tvar opts []grpc.ServerOption\n\tvar listener net.Listener\n\tvar err error\n\n\tif cert != \"\" {\n\t\tcert, err := loadCertificate(cert)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load certificate: %v\", err)\n\t\t}\n\t\ttlsConfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t}\n\t\tlistener, err = tls.Listen(\"tcp\", \":\"+proxyPort, tlsConfig)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS listener: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.Creds(grpc.NewTLS(tlsConfig)))\n\t} else {\n\t\tlistener, err = net.Listen(\"tcp\", \":\"+proxyPort)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create listener: %v\", err)\n\t\t}\n\t}\n\n\tserver := grpc.NewServer(opts...)\n\n\thealthServer := health.NewServer()\n\tgrpc_health_check.RegisterHealthServer(server, healthServer)\n\n\ttype SpannerExecutorProxyServer struct{}\n\n\tfunc (s *SpannerExecutorProxyServer) ExecuteSpannerQuery(ctx context.Context, req *SpannerRequest) (*SpannerResponse, error) {\n\t\treturn &SpannerResponse{}, nil\n\t}\n\n\tspannerServer := &SpannerExecutorProxyServer{}\n\t// Register the custom service\n\t// Assuming the service is defined in a package and the server is an instance of the service's server\n\t// For the purpose of this code, we'll assume the service is registered as 'SpannerExecutorProxy'\n\t// In a real scenario, this would require the service definition\n\t// For example: spannerpb.RegisterSpannerExecutorProxyServer(server, spannerServer)\n\n\treflection.Register(server)\n\n\tif err := server.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and handles gRPC communications.\n\nFunction Description: The main function sets up a gRPC server that listens on port 50051, registers the gRPC service implementation, and starts serving requests. It includes error handling for server setup and operation.\n\nInput: None (The function takes no explicit parameters but uses a hardcoded port \":50051\" for listening)\n\nOutput: None (The function doesn't return anything but will log fatal errors if the server fails to start or serve)\n\nNote: The actual gRPC service implementation (greeter struct) is not shown in the reference code but would need to be defined separately to implement the proto.GreeterServer interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"grpc-hello/proto\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\treflection.Register(server)\n\tproto.RegisterGreeterServer(server, &greeter{})\n\n\tfmt.Println(\"grpc server start ...\")\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"your/proto\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx context.Context, in *proto.HelloRequest) (*proto.HelloReply, error) {\n\treturn &proto.HelloReply{Message: \"Hello, \" + in.Name}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tproto.RegisterGreeterServer(s, &server{})\n\treflection.Register(s)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Create a gRPC server for chaincode communication in a Hyperledger Fabric network, supporting both secure (TLS) and insecure connections, with the ability to handle chaincode registration and message echoing.\n\nStruct Description: ccSrv represents a chaincode gRPC server that listens for incoming connections, handles chaincode registration, and echoes received messages back to the client.\n\nFields:\nl: net.Listener - The network listener for incoming connections\ngrpcSrv: *grpc.Server - The gRPC server instance\nt: *testing.T - Testing context for assertions\nexpectedCCname: string - The expected chaincode name for validation during registration\n\nMethods:\nRegister: (stream pb.ChaincodeSupport_RegisterServer) -> error - Handles the chaincode registration stream, validates the chaincode name, and echoes messages back to the client\nstop: () -> () - Stops the gRPC server and closes the listener\nnewCCServer: (t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) -> *ccSrv - Creates and configures a new chaincode server instance with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\tpb \"github.com/hyperledger/fabric-protos-go-apiv2/peer\"\n\t\"github.com/hyperledger/fabric/common/crypto/tlsgen\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (cs *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tmsg, err := stream.Recv()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequire.Equal(cs.t, pb.ChaincodeMessage_REGISTER.String(), msg.Type.String())\n\tchaincodeID := &pb.ChaincodeID{}\n\terr = proto.Unmarshal(msg.Payload, chaincodeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequire.Equal(cs.t, cs.expectedCCname, chaincodeID.Name)\n\tfor {\n\t\tmsg, _ = stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = stream.Send(msg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (cs *ccSrv) stop() {\n\tcs.grpcSrv.Stop()\n\tcs.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar s *grpc.Server\n\tif withTLS {\n\t\tkeyPair, err := ca.NewServerCertKeyPair(\"localhost\")\n\t\trequire.NoError(t, err)\n\t\tcert, err := tls.X509KeyPair(keyPair.Cert, keyPair.Key)\n\t\trequire.NoError(t, err)\n\t\ttlsConf := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tClientCAs:    x509.NewCertPool(),\n\t\t}\n\t\ttlsConf.ClientCAs.AppendCertsFromPEM(ca.CertBytes())\n\t\ts = grpc.NewServer(grpc.Creds(credentials.NewTLS(tlsConf)))\n\t} else {\n\t\ts = grpc.NewServer()\n\t}\n\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", \"\", port))\n\trequire.NoError(t, err, \"%v\", err)\n\treturn &ccSrv{\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t\tl:              l,\n\t\tgrpcSrv:        s,\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/reflect/protoset\"\n\t\"google.golang.org/protobuf/reflect/protoutil\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/protowrap\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/any\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/bytes\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/duration\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/fieldmask\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/structpb\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/timestamp\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/wrappers\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/any\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/bytes\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/duration\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/fieldmask\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/structpb\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/timestamp\"\n\t\"google.golang.org/protobuf/encoding/protowrap/protowrappers/wrappers\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (s *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif msg.Type == pb.ChaincodeMessage_REGISTER {\n\t\t\tif msg.Payload != nil {\n\t\t\t\tvar registrationRequest pb.RegistrationRequest\n\t\t\t\tif err := proto.Unmarshal(msg.Payload, &registrationRequest); err == nil {\n\t\t\t\t\tif registrationRequest.Name != s.expectedCCname {\n\t\t\t\t\t\treturn status.Errorf(codes.InvalidArgument, \"Invalid chaincode name\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn status.Errorf(codes.InvalidArgument, \"Failed to parse registration request\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif err := stream.Send(msg); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *ccSrv) stop() {\n\ts.grpcSrv.Stop()\n\ts.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar lis net.Listener\n\tvar tlsConfig *tls.Config\n\tvar err error\n\n\tif withTLS {\n\t\tcert, key, err := ca.GenerateServerCert(\"localhost\", port)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to generate server cert: %v\", err)\n\t\t}\n\t\ttlsConfig = &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientCAs:    ca.RootCerts(),\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t}\n\t\tlis, err = tls.Listen(\"tcp\", fmt.Sprintf(\":%d\", port), tlsConfig)\n\t} else {\n\t\tlis, err = net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\t}\n\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgrpcSrv := grpc.NewServer()\n\tpb.RegisterChaincodeSupportServer(grpcSrv, s)\n\tgo func() {\n\t\tif err := grpcSrv.Serve(lis); err != nil {\n\t\t\tt.Errorf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\n\treturn &ccSrv{\n\t\tl:              lis,\n\t\tgrpcSrv:        grpcSrv,\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t}\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and registers a service to handle those requests.\n\nFunction Description: The function sets up a gRPC server that listens on a given TCP port, creates a new gRPC server instance, registers a service to handle incoming requests, and starts the server in a goroutine. The server runs until it is stopped or encounters an error.\n\nInput: None (The port is hardcoded as \":50052\" in the example, but could be parameterized)\n\nOutput: None (The function runs indefinitely until stopped or an error occurs, with side effects of starting the gRPC server)\n\nNote: The actual service implementation (ChannelzService) would need to be defined elsewhere and imported. The example shows the server setup pattern but assumes the service is already implemented.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tdefer lis.Close()\n\ts := grpc.NewServer()\n\tservice.RegisterChannelzServiceToServer(s)\n\tgo s.Serve(lis)\n\tdefer s.Stop()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc setupGRPCServer() {\n\tlistener, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tchannelz.RegisterChannelzServiceServer(s, channelzService)\n\tgo func() {\n\t\tif err := s.Serve(listener); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server exited with error: %v\", err)\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles greeting requests and responses.\n\nStruct Description: The server struct implements the GreeterServer interface generated from the protobuf definition, providing the SayHello method to handle incoming gRPC requests.\n\nFields:\nUnimplementedGreeterServer: pb.UnimplementedGreeterServer - Embedded type to ensure forward compatibility with future gRPC updates\n\nMethods:\nSayHello: [Name](ctx context.Context, in *pb.HelloRequest) -> (*pb.HelloReply, error) - Processes incoming HelloRequest, logs the received name, and returns a HelloReply with a greeting message",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/generated/proto\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tfmt.Printf(\"Received: %s\\n\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello, \" + in.GetName() + \"!\"}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The function `Run` initializes and starts a gRPC server with the provided network options. It sets up a network listener, creates a gRPC server instance, registers a key service, and handles graceful shutdown upon receiving interrupt or termination signals.\n\nInput: \n- `opts` [struct] - Configuration options for the server, containing:\n  - `Network` [string] - The network type (e.g., \"tcp\")\n  - `Address` [string] - The address to listen on (e.g., \":50051\")\n  - `Prompt` [interface{}] - Optional prompt for the key service\n\nOutput: \n- `error` - Returns an error if the server fails to start or encounters issues during execution",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/getsops/sops/v3/keyservice\"\n\t\"google.golang.org/grpc\"\n)\nfunc Run(opts Opts) error {\n\tlis, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer lis.Close()\n\tgrpcServer := grpc.NewServer()\n\tkeyservice.RegisterKeyServiceServer(grpcServer, keyservice.Server{\n\t\tPrompt: opts.Prompt,\n\t})\n\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, os.Interrupt, os.Kill, syscall.SIGTERM)\n\tgo func(c chan os.Signal) {\n\t\tsig := <-c\n\t\tlis.Close()\n\t\tos.Exit(0)\n\t}(sigc)\n\treturn grpcServer.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Options struct {\n\tNetwork string\n\tAddress string\n\tPrompt  interface{}\n}\n\nfunc Run(opts *Options) error {\n\tlistener, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserver := grpc.NewServer()\n\tkeyService := &KeyService{Prompt: opts.Prompt}\n\tRegisterKeyServiceServer(server, keyService)\n\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tlog.Printf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, os.Interrupt, os.Kill)\n\t<-quit\n\n\tserver.GracefulStop()\n\t<-server.Done()\n\tlistener.Close()\n\treturn nil\n}\n\ntype KeyService struct {\n\tPrompt interface{}\n}\n\nfunc (k *KeyService) GetPrompt(ctx context.Context, req *EmptyRequest) (*PromptResponse, error) {\n\treturn &PromptResponse{Prompt: k.Prompt}, nil\n}\n\ntype EmptyRequest struct{}\n\ntype PromptResponse struct {\n\tPrompt interface{}\n}\n\nfunc RegisterKeyServiceServer(s *grpc.Server, srv KeyServiceServer) {\n\ts.RegisterService(&KeyServiceServerImpl{srv}, &KeyService_ServiceDesc{})\n}\n\ntype KeyServiceServer interface {\n\tGetPrompt(context.Context, *EmptyRequest) (*PromptResponse, error)\n}\n\ntype KeyServiceServerImpl struct {\n\tsrv KeyServiceServer\n}\n\nfunc (k *KeyServiceServerImpl) GetPrompt(ctx context.Context, req *EmptyRequest) (*PromptResponse, error) {\n\treturn k.srv.GetPrompt(ctx, req)\n}\n\nvar KeyService_ServiceDesc = grpc.ServiceDesc{\n\tServiceName: \"KeyService\",\n\tHandlerType: (*KeyServiceServer)(nil),\n\tMethods:     map[string]*grpc.MethodDesc{\"GetPrompt\": &grpc.MethodDesc{}},\n\tStreams:     map[string]*grpc.StreamDesc{},\n}"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles various WebSocket operations including checking user online status, sending messages to users, broadcasting messages to all users, and retrieving user lists.\n\nStruct Description: The `server` struct implements the gRPC service interface defined in the protobuf file, providing concrete implementations for WebSocket operations.\n\nFields:\n- UnimplementedAccServerServer: [protobuf.UnimplementedAccServerServer] - Embedded type to ensure forward compatibility with gRPC service updates\n\nMethods:\n- QueryUsersOnline: [Name](ctx context.Context, req *protobuf.QueryUsersOnlineReq) -> (*protobuf.QueryUsersOnlineRsp, error) - Checks if a specified user is currently online\n- SendMsg: [Name](ctx context.Context, req *protobuf.SendMsgReq) -> (*protobuf.SendMsgRsp, error) - Sends a message to a specific user\n- SendMsgAll: [Name](ctx context.Context, req *protobuf.SendMsgAllReq) -> (*protobuf.SendMsgAllRsp, error) - Broadcasts a message to all connected users\n- GetUserList: [Name](ctx context.Context, req *protobuf.GetUserListReq) -> (*protobuf.GetUserListRsp, error) - Retrieves the list of currently connected users\n- Init: [Name]() -> () - Initializes and starts the gRPC server with configuration from Viper",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/link1st/gowebsocket/v2/common\"\n\t\"github.com/link1st/gowebsocket/v2/models\"\n\t\"github.com/link1st/gowebsocket/v2/protobuf\"\n\t\"github.com/link1st/gowebsocket/v2/servers/websocket\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedAccServerServer\n}\n\nfunc (s *server) QueryUsersOnline(c context.Context, req *protobuf.QueryUsersOnlineReq) (rsp *protobuf.QueryUsersOnlineRsp, err error) {\n\trsp = &protobuf.QueryUsersOnlineRsp{}\n\tonline := websocket.CheckUserOnline(req.GetAppID(), req.GetUserID())\n\tsetErr(req, common.OK, \"\")\n\trsp.Online = online\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsg(c context.Context, req *protobuf.SendMsgReq) (rsp *protobuf.SendMsgRsp, err error) {\n\trsp = &protobuf.SendMsgRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\tsendResults, err := websocket.SendUserMessageLocal(req.GetAppID(), req.GetUserID(), data)\n\tif err != nil {\n\t\tsetErr(rsp, common.ServerError, \"\")\n\t\treturn rsp, nil\n\t}\n\tif !sendResults {\n\t\tsetErr(rsp, common.OperationFailure, \"\")\n\t\treturn rsp, nil\n\t}\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsgAll(c context.Context, req *protobuf.SendMsgAllReq) (rsp *protobuf.SendMsgAllRsp, err error) {\n\trsp = &protobuf.SendMsgAllRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\twebsocket.AllSendMessages(req.GetAppID(), req.GetUserID(), data)\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) GetUserList(c context.Context, req *protobuf.GetUserListReq) (rsp *protobuf.GetUserListRsp, err error) {\n\trsp = &protobuf.GetUserListRsp{}\n\tuserList := websocket.GetUserList(req.GetAppID())\n\tsetErr(rsp, common.OK, \"\")\n\trsp.UserID = userList\n\treturn rsp, nil\n}\n\nfunc Init() {\n\trpcPort := viper.GetString(\"app.rpcPort\")\n\tlis, err := net.Listen(\"tcp\", \":\"+rpcPort)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tprotobuf.RegisterAccServerServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype server struct {\n\tpb.UnimplementedAccServerServer\n\tonlineUsers map[string]*websocket.Conn\n\tmu          sync.RWMutex\n}\n\nfunc (s *server) QueryUsersOnline(ctx context.Context, req *pb.QueryUsersOnlineReq) (*pb.QueryUsersOnlineRsp, error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\t_, exists := s.onlineUsers[req.UserId]\n\treturn &pb.QueryUsersOnlineRsp{IsOnline: exists}, nil\n}\n\nfunc (s *server) SendMsg(ctx context.Context, req *pb.SendMsgReq) (*pb.SendMsgRsp, error) {\n\ts.mu.RLock()\n\tconn, exists := s.onlineUsers[req.UserId]\n\ts.mu.RUnlock()\n\tif !exists {\n\t\treturn &pb.SendMsgRsp{Success: false, Msg: \"User not found\"}, nil\n\t}\n\tif err := conn.WriteMessage(websocket.TextMessage, []byte(req.Msg)); err != nil {\n\t\treturn &pb.SendMsgRsp{Success: false, Msg: \"Failed to send message\"}, nil\n\t}\n\treturn &pb.SendMsgRsp{Success: true}, nil\n}\n\nfunc (s *server) SendMsgAll(ctx context.Context, req *pb.SendMsgAllReq) (*pb.SendMsgAllRsp, error) {\n\ts.mu.RLock()\n\tfor _, conn := range s.onlineUsers {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(req.Msg)); err != nil {\n\t\t\tfmt.Println(\"Error broadcasting message:\", err)\n\t\t}\n\t}\n\ts.mu.RUnlock()\n\treturn &pb.SendMsgAllRsp{Success: true}, nil\n}\n\nfunc (s *server) GetUserList(ctx context.Context, req *pb.GetUserListReq) (*pb.GetUserListRsp, error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tuserList := make([]string, 0, len(s.onlineUsers))\n\tfor user := range s.onlineUsers {\n\t\tuserList = append(userList, user)\n\t}\n\treturn &pb.GetUserListRsp{UserList: userList}, nil\n}\n\nfunc (s *server) Init() {\n\t// Initialize WebSocket connections\n\tgo func() {\n\t\tupgrader := websocket.Upgrader{CheckOrigin: true}\n\t\thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tconn, _ := upgrader.Upgrade(w, r, nil)\n\t\t\ts.mu.Lock()\n\t\t\ts.onlineUsers[r.URL.Query().Get(\"user\")] = conn\n\t\t\ts.mu.Unlock()\n\t\t})\n\t}()\n\t\n\t// Start gRPC server\n\tlis, _ := net.Listen(\"tcp\", \":\"+viper.GetString(\"grpc_port\"))\n\tsrv := grpc.NewServer()\n\tpb.RegisterAccServerServer(srv, s)\n\tif err := srv.Serve(lis); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server to handle incoming requests on a specified network address.\n\nFunction Description: The function `startServer` sets up a gRPC server that listens on the provided TCP address. It creates a new gRPC server instance, registers the Echo service implementation, and begins serving requests. If any step fails, it logs the error and terminates the program.\n\nInput: \n- `addr` [string] - The network address (including port) on which the gRPC server should listen (e.g., \"localhost:50051\").\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error).",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc startServer(addr string) {\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterEchoServer(s, &ecServer{addr: addr})\n\tlog.Printf(\"serving on %s\\n\", addr)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "import (\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/yourorg/echo\"\n)\n\nfunc startServer(addr string) {\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\techo.RegisterEchoServer(s, &echo.EchoService{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Create a mock CSI (Container Storage Interface) provider server in Go that implements the gRPC interface for a secrets store CSI driver. This server should be able to simulate both successful and error responses for testing purposes.\n\nStruct Description: The MockCSIProviderServer struct represents a mock implementation of a CSI provider server that communicates via gRPC over a Unix domain socket. It allows configuration of mock responses and error conditions for testing the CSI driver integration.\n\nFields:\n- grpcServer: *grpc.Server - The gRPC server instance\n- listener: net.Listener - The network listener for the gRPC server\n- socketPath: string - The filesystem path for the Unix domain socket\n- returnErr: error - An error to return for simulated error conditions\n- errorCode: string - The error code to include in responses\n- objects: []*v1alpha1.ObjectVersion - Mock object versions to return\n- files: []*v1alpha1.File - Mock files to return\n\nMethods:\n- NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) - Creates a new mock server instance with the given socket path\n- SetReturnError(err error) - Sets an error to be returned by the mock server\n- SetObjects(objects map[string]string) - Configures mock object versions to return\n- SetFiles(files []*v1alpha1.File) - Configures mock files to return\n- SetProviderErrorCode(errorCode string) - Sets the error code for responses\n- Start() error - Starts the gRPC server listening on the configured socket\n- Stop() - Gracefully stops the gRPC server\n- Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) - Implements the Mount gRPC method\n- Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) - Implements the Version gRPC method",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"sigs.k8s.io/secrets-store-csi-driver/provider/v1alpha1\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype MockCSIProviderServer struct {\n\tgrpcServer *grpc.Server\n\tlistener   net.Listener\n\tsocketPath string\n\treturnErr  error\n\terrorCode  string\n\tobjects    []*v1alpha1.ObjectVersion\n\tfiles      []*v1alpha1.File\n}\n\nfunc NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) {\n\tserver := grpc.NewServer()\n\ts := &MockCSIProviderServer{\n\t\tgrpcServer: server,\n\t\tsocketPath: socketPath,\n\t}\n\tv1alpha1.RegisterCSIDriverProviderServer(server, s)\n\treturn s, nil\n}\n\nfunc (m *MockCSIProviderServer) SetReturnError(err error) {\n\tm.returnErr = err\n}\n\nfunc (m *MockCSIProviderServer) SetObjects(objects map[string]string) {\n\tvar ov []*v1alpha1.ObjectVersion\n\tfor k, v := range objects {\n\t\tov = append(ov, &v1alpha1.ObjectVersion{Id: k, Version: v})\n\t}\n\tm.objects = ov\n}\n\nfunc (m *MockCSIProviderServer) SetFiles(files []*v1alpha1.File) {\n\tvar ov []*v1alpha1.File\n\tfor _, v := range files {\n\t\tov = append(ov, &v1alpha1.File{\n\t\t\tPath:     v.Path,\n\t\t\tMode:     v.Mode,\n\t\t\tContents: v.Contents,\n\t\t})\n\t}\n\tm.files = ov\n}\n\nfunc (m *MockCSIProviderServer) SetProviderErrorCode(errorCode string) {\n\tm.errorCode = errorCode\n}\n\nfunc (m *MockCSIProviderServer) Start() error {\n\tvar err error\n\tm.listener, err = net.Listen(\"unix\", m.socketPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err = m.grpcServer.Serve(m.listener); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (m *MockCSIProviderServer) Stop() {\n\tm.grpcServer.GracefulStop()\n}\n\nfunc (m *MockCSIProviderServer) Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) {\n\tvar attrib, secret map[string]string\n\tvar filePermission os.FileMode\n\tvar err error\n\n\tif m.returnErr != nil {\n\t\treturn &v1alpha1.MountResponse{}, m.returnErr\n\t}\n\tif err = json.Unmarshal([]byte(req.GetAttributes()), &attrib); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal attributes, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetSecrets()), &secret); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal secrets, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetPermission()), &filePermission); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal file permission, error: %w\", err)\n\t}\n\treturn &v1alpha1.MountResponse{\n\t\tObjectVersion: m.objects,\n\t\tError: &v1alpha1.Error{\n\t\t\tCode: m.errorCode,\n\t\t},\n\t\tFiles: m.files,\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) {\n\treturn &v1alpha1.VersionResponse{\n\t\tVersion:        \"v1alpha1\",\n\t\tRuntimeName:    \"fakeprovider\",\n\t\tRuntimeVersion: \"0.0.10\",\n\t}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/container-storage-interface/spec/lib/go/csi/v1alpha1\"\n\t\"google.golang.org/grpc\"\n)\n\ntype MockCSIProviderServer struct {\n\tgrpcServer *grpc.Server\n\tlistener   net.Listener\n\tsocketPath string\n\treturnErr  error\n\terrorCode  string\n\tobjects    []*v1alpha1.ObjectVersion\n\tfiles      []*v1alpha1.File\n}\n\nfunc NewMockCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) {\n\tlis, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tserver := &MockCSIProviderServer{\n\t\tgrpcServer: grpc.NewServer(),\n\t\tlistener:   lis,\n\t\tsocketPath: socketPath,\n\t}\n\tv1alpha1.RegisterIdentityServer(server.grpcServer, server)\n\tv1alpha1.RegisterControllerServer(server.grpcServer, server)\n\tv1alpha1.RegisterNodeServer(server.grpcServer, server)\n\treturn server, nil\n}\n\nfunc (m *MockCSIProviderServer) SetReturnError(err error) {\n\tm.returnErr = err\n}\n\nfunc (m *MockCSIProviderServer) SetObjects(objects map[string]string) {\n\tm.objects = make([]*v1alpha1.ObjectVersion, 0, len(objects))\n\tfor k, v := range objects {\n\t\tm.objects = append(m.objects, &v1alpha1.ObjectVersion{\n\t\t\tName:  k,\n\t\t\tValue: v,\n\t\t})\n\t}\n}\n\nfunc (m *MockCSIProviderServer) SetFiles(files []*v1alpha1.File) {\n\tm.files = files\n}\n\nfunc (m *MockCSIProviderServer) SetProviderErrorCode(errorCode string) {\n\tm.errorCode = errorCode\n}\n\nfunc (m *MockCSIProviderServer) Start() error {\n\tgo func() {\n\t\tif err := m.grpcServer.Serve(m.listener); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"gRPC server failed: %v\\n\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (m *MockCSIProviderServer) Stop() {\n\tm.grpcServer.Stop()\n\tm.listener.Close()\n\tos.Remove(m.socketPath)\n}\n\nfunc (m *MockCSIProviderServer) Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) {\n\tif m.returnErr != nil {\n\t\treturn nil, m.returnErr\n\t}\n\treturn &v1alpha1.VersionResponse{\n\t\tDriverName:  \"mock-secrets-store-csi-driver\",\n\t\tDriverVersion: \"v1.0.0\",\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) {\n\tif m.returnErr != nil {\n\t\treturn nil, m.returnErr\n\t}\n\treturn &v1alpha1.MountResponse{\n\t\tObjects: m.objects,\n\t\tFiles:   m.files,\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) NodePublishVolume(ctx context.Context, req *v1alpha1.NodePublishVolumeRequest) (*v1alpha1.NodePublishVolumeResponse, error) {\n\treturn &v1alpha1.NodePublishVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) NodeUnpublishVolume(ctx context.Context, req *v1alpha1.NodeUnpublishVolumeRequest) (*v1alpha1.NodeUnpublishVolumeResponse, error) {\n\treturn &v1alpha1.NodeUnpublishVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) NodeGetId(ctx context.Context, req *v1alpha1.NodeGetIdRequest) (*v1alpha1.NodeGetIdResponse, error) {\n\treturn &v1alpha1.NodeGetIdResponse{\n\t\tNodeId: \"mock-node\",\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) NodeGetCapabilities(ctx context.Context, req *v1alpha1.NodeGetCapabilitiesRequest) (*v1alpha1.NodeGetCapabilitiesResponse, error) {\n\treturn &v1alpha1.NodeGetCapabilitiesResponse{\n\t\tCapabilities: []*v1alpha1.NodeCapability{\n\t\t\t{\n\t\t\t\tType: &v1alpha1.NodeCapability_Socket{\n\t\t\t\t\tSocket: &v1alpha1.Socket{\n\t\t\t\t\t\tPath: \"/var/run/secrets.sock\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) NodeGetVolumeStats(ctx context.Context, req *v1alpha1.NodeGetVolumeStatsRequest) (*v1alpha1.NodeGetVolumeStatsResponse, error) {\n\treturn &v1alpha1.NodeGetVolumeStatsResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerPublishVolume(ctx context.Context, req *v1alpha1.ControllerPublishVolumeRequest) (*v1alpha1.ControllerPublishVolumeResponse, error) {\n\treturn &v1alpha1.ControllerPublishVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerUnpublishVolume(ctx context.Context, req *v1alpha1.ControllerUnpublishVolumeRequest) (*v1alpha1.ControllerUnpublishVolumeResponse, error) {\n\treturn &v1alpha1.ControllerUnpublishVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerGetCapabilities(ctx context.Context, req *v1alpha1.ControllerGetCapabilitiesRequest) (*v1alpha1.ControllerGetCapabilitiesResponse, error) {\n\treturn &v1alpha1.ControllerGetCapabilitiesResponse{\n\t\tCapabilities: []*v1alpha1.ControllerCapability{\n\t\t\t{\n\t\t\t\tType: &v1alpha1.ControllerCapability_Socket{\n\t\t\t\t\tSocket: &v1alpha1.Socket{\n\t\t\t\t\t\tPath: \"/var/run/secrets.sock\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerGetVolume(ctx context.Context, req *v1alpha1.ControllerGetVolumeRequest) (*v1alpha1.ControllerGetVolumeResponse, error) {\n\treturn &v1alpha1.ControllerGetVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerListVolumes(ctx context.Context, req *v1alpha1.ControllerListVolumesRequest) (*v1alpha1.ControllerListVolumesResponse, error) {\n\treturn &v1alpha1.ControllerListVolumesResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerRemoveVolume(ctx context.Context, req *v1alpha1.ControllerRemoveVolumeRequest) (*v1alpha1.ControllerRemoveVolumeResponse, error) {\n\treturn &v1alpha1.ControllerRemoveVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) ControllerExpandVolume(ctx context.Context, req *v1alpha1.ControllerExpandVolumeRequest) (*v1alpha1.ControllerExpandVolumeResponse, error) {\n\treturn &v1alpha1.ControllerExpandVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) CreateVolume(ctx context.Context, req *v1alpha1.CreateVolumeRequest) (*v1alpha1.CreateVolumeResponse, error) {\n\treturn &v1alpha1.CreateVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) DeleteVolume(ctx context.Context, req *v1alpha1.DeleteVolumeRequest) (*v1alpha1.DeleteVolumeResponse, error) {\n\treturn &v1alpha1.DeleteVolumeResponse{}, nil\n}\n\nfunc (m *MockCSIProviderServer) GetCapacity(ctx context.Context, req *v1alpha1.GetCapacityRequest) (*v1alpha1.GetCapacityResponse, error) {\n\treturn &v1alpha1.GetCapacityResponse{}, nil\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a gRPC server in Go that handles authentication services, connects to Redis for data storage, and exposes Prometheus metrics for monitoring.\n\nStruct Description: The authHandler struct implements the AuthServiceServer interface and provides authentication functionality using Redis as the backend storage.\n\nFields:\nredisClient: *redis.Client - The Redis client used for data storage and retrieval\n\nMethods:\nServe: (listener net.Listener) -> error - Starts the gRPC server and begins listening for incoming requests\nRegisterWithPrometheus: () -> error - Registers gRPC and custom metrics with Prometheus\nStartMetricsServer: () -> error - Starts an HTTP server for Prometheus metrics collection\n\nNote: The struct implements all required gRPC service methods defined in the auth.proto file, though these are not shown in the reference code. The main functionality includes:\n1. Setting up a gRPC server with Prometheus monitoring\n2. Establishing Redis connection\n3. Combining gRPC and HTTP servers for both RPC calls and metrics collection\n4. Proper error handling and logging throughout the process",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/go-redis/redis\"\n\t\"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/lucperkins/colossus/proto/auth\"\n)\nfunc main() {\n\tlog.Printf(\"Starting up the gRPC auth server on localhost:%d\", PORT)\n\n\tlog.Print(\"Attempting to connect to Redis\")\n\n\tredisClient := redis.NewClient(&redis.Options{\n\t\tAddr: \"colossus-redis-cluster:6379\",\n\t})\n\n\t_, err := redisClient.Ping().Result()\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis cluster: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully connected to Redis\")\n\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", PORT))\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully created TCP listener\")\n\n\tserver := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),\n\t)\n\n\tauthServer := authHandler{\n\t\tredisClient: redisClient,\n\t}\n\n\thttpServer := &http.Server{\n\t\tHandler: promhttp.HandlerFor(metricsRegistry, promhttp.HandlerOpts{}),\n\t\tAddr:    fmt.Sprintf(\"0.0.0.0:%d\", PROMETHEUS_PORT),\n\t}\n\n\tauth.RegisterAuthServiceServer(server, &authServer)\n\n\tgrpcMetrics.InitializeMetrics(server)\n\n\tmetricsRegistry.MustRegister(grpcMetrics, authCounter, failCounter)\n\n\tlog.Print(\"Successfully registered with Prometheus\")\n\n\tgo func() {\n\t\tlog.Print(\"Starting up HTTP server for Prometheus metrics collection\")\n\n\t\tif err := httpServer.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"Unable to start HTTP server for Prometheus metrics: %v\", err)\n\t\t}\n\t}()\n\n\tlog.Fatal(server.Serve(listener))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\ntype authHandler struct {\n\tredisClient *redis.Client\n}\n\nvar (\n\tauthRequests = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"auth_requests_total\",\n\t\t\tHelp: \"Total number of authentication requests\",\n\t\t},\n\t\t[]string{\"method\"},\n\t)\n)\n\nfunc (h *authHandler) Serve(listener net.Listener) error {\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),\n\t\tgrpc.StreamInterceptor(grpc_prometheus.StreamServerInterceptor),\n\t)\n\n\tgrpc_prometheus.Register(grpcServer)\n\th.RegisterWithPrometheus()\n\n\treflection.Register(grpcServer)\n\th.registerAuthMethods(grpcServer)\n\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\treturn fmt.Errorf(\"failed to serve: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (h *authHandler) RegisterWithPrometheus() error {\n\tif err := prometheus.Register(authRequests); err != nil {\n\t\treturn fmt.Errorf(\"failed to register auth metrics: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (h *authHandler) StartMetricsServer() error {\n\thttpServer := &http.Server{\n\t\tAddr:         \":8080\",\n\t\tHandler:      promhttp.Handler(),\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t}\n\n\tgo func() {\n\t\tif err := httpServer.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"failed to start metrics server: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (h *authHandler) registerAuthMethods(s *grpc.Server) {\n\t// Register all required gRPC methods from auth.proto\n\t// Example method stubs:\n\t// s.RegisterAuthServiceServer(h)\n}\n\nfunc main() {\n\tredisClient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tauthServer := &authHandler{\n\t\tredisClient: redisClient,\n\t}\n\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tif err := authServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a function that sets up and starts a gRPC server with reflection capabilities, registering multiple services and handling incoming requests.\n\nFunction Description: The Serve function initializes a gRPC server on a specified TCP port, registers multiple service implementations (RouteGuide and Foobar), enables server reflection for debugging, and starts listening for incoming RPC requests. It also demonstrates protobuf JSON marshaling of a well-known type.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but runs indefinitely to serve requests)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n)\nfunc Serve() {\n\tlis, err := net.Listen(\"tcp\", \":5001\")\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"server: failed to create listener: %v\", err)\n\t}\n\n\te, _ := protojson.Marshal(&WellKnownRequest{Timestamp: timestamppb.Now()})\n\tfmt.Printf(\"string(e) = %+v\\n\", string(e))\n\n\ts := newServer()\n\tgs := grpc.NewServer()\n\tRegisterRouteGuideServer(gs, s)\n\tRegisterFoobarServer(gs, s)\n\treflection.Register(gs)\n\tgs.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"net\"\n\t\"your.package.route_guide\"\n\t\"your.package.foobar\"\n)\n\nfunc Serve() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ts := grpc.NewServer()\n\troute_guide.RegisterRouteGuideServer(s, &routeGuideServer{})\n\tfoobar.RegisterFoobarServer(s, &foobarServer{})\n\treflection.Register(s)\n\tif err := s.Serve(lis); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Implement a gRPC server for a CSI (Container Storage Interface) driver in Go, including server lifecycle management, request interception, and authentication.\n\nStruct Description: CSIDriver represents a gRPC server implementation for CSI driver operations, managing server lifecycle, intercepting requests, and handling authentication.\n\nFields:\n- listener: net.Listener - Network listener for incoming connections\n- server: *grpc.Server - gRPC server instance\n- servers: *CSIDriverServers - CSI service implementations (Controller, Identity, Node)\n- wg: sync.WaitGroup - Synchronization for graceful shutdown\n- running: bool - Server running state flag\n- lock: sync.Mutex - Mutex for thread-safe operations\n- creds: *CSICreds - Authentication credentials\n- logGRPC: LogGRPC - Callback for logging gRPC calls\n\nMethods:\n- NewCSIDriver(*CSIDriverServers) -> *CSIDriver - Constructor that creates a new CSIDriver instance with given service implementations\n- Start(net.Listener, grpc.UnaryServerInterceptor) -> error - Starts the gRPC server with optional interceptor\n- goServe(chan<- bool) -> - Internal method to start server in goroutine\n- Stop() -> - Stops the server gracefully\n- callInterceptor(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) -> (interface{}, error) - Request interceptor handling authentication and logging",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\ntype LogGRPC func(method string, request, reply interface{}, err error)\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (c *CSIDriver) Start(l net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.listener = l\n\n\tif interceptor == nil {\n\t\tinterceptor = c.callInterceptor\n\t}\n\tc.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\n\tif c.servers.Controller != nil {\n\t\tcsi.RegisterControllerServer(c.server, c.servers.Controller)\n\t}\n\tif c.servers.Identity != nil {\n\t\tcsi.RegisterIdentityServer(c.server, c.servers.Identity)\n\t}\n\tif c.servers.Node != nil {\n\t\tcsi.RegisterNodeServer(c.server, c.servers.Node)\n\t}\n\n\twaitForServer := make(chan bool)\n\tc.goServe(waitForServer)\n\t<-waitForServer\n\tc.running = true\n\treturn nil\n}\n\nfunc (c *CSIDriver) goServe(started chan<- bool) {\n\tgo func() {\n\t\tc.wg.Add(1)\n\t\tdefer c.wg.Done()\n\t\tstarted <- true\n\t\tc.server.Serve(c.listener)\n\t}()\n}\n\nfunc (c *CSIDriver) Stop() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif !c.running {\n\t\treturn\n\t}\n\n\tc.server.Stop()\n\tc.wg.Wait()\n}\n\nfunc (c *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\terr := authInterceptor(c.creds, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsp, err := handler(ctx, req)\n\tif c.logGRPC != nil {\n\t\tc.logGRPC(info.FullMethod, req, rsp, err)\n\t}\n\treturn rsp, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package csidriver\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype CSIDriver struct {\n\tlistener   net.Listener\n\tserver     *grpc.Server\n\tservers    *CSIDriverServers\n\twg         sync.WaitGroup\n\trunning    bool\n\tlock       sync.Mutex\n\tcreds      *CSICreds\n\tlogGRPC    func(ctx context.Context, method string, req interface{})\n}\n\ntype CSIDriverServers struct {\n\tIdentity *IdentityServer\n\tController *ControllerServer\n\tNode *NodeServer\n}\n\ntype CSICreds struct {\n\t// Add authentication fields as needed\n}\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (c *CSIDriver) Start(listener net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\tc.listener = listener\n\tc.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\tc.servers.Identity.Register(c.server)\n\tc.servers.Controller.Register(c.server)\n\tc.servers.Node.Register(c.server)\n\tc.wg.Add(1)\n\tgo func() {\n\t\tc.server.Serve(c.listener)\n\t\tc.wg.Done()\n\t}()\n\tc.running = true\n\treturn nil\n}\n\nfunc (c *CSIDriver) Stop() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tif !c.running {\n\t\treturn\n\t}\n\tc.running = false\n\tc.server.Stop()\n\tc.wg.Wait()\n}\n\nfunc (c *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t// Authentication\n\tif err := c.creds.Validate(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\t// Logging\n\tc.logGRPC(ctx, info.FullMethod, req)\n\t// Call the next handler\n\treturn handler(ctx, req)\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both unary and bidirectional streaming RPCs for an echo service, with TLS security.\n\nStruct Description: The server struct implements the EchoServer interface generated from the protobuf definition, providing echo functionality for both unary and streaming RPCs.\n\nFields:\n- UnimplementedEchoServer: pb.UnimplementedEchoServer - Embedded type to ensure forward compatibility\n\nMethods:\n- UnaryEcho: (context.Context, *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls by echoing back the received message\n- BidirectionalStreamingEcho: (pb.Echo_BidirectionalStreamingEchoServer) -> error - Handles bidirectional streaming by continuously receiving messages and echoing them back until the stream ends\n\nInput: None (The struct itself doesn't take input parameters, but its methods do as described above)\n\nOutput: None (The struct doesn't return anything directly, but its methods return values as described above)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/examples/data\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(_ context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tfmt.Printf(\"unary echoing message %q\\n\", in.Message)\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tin, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfmt.Printf(\"server: error receiving from stream: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"bidi echoing message %q\\n\", in.Message)\n\t\tstream.Send(&pb.EchoResponse{Message: in.Message})\n\t}\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"the port to serve on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(data.Path(\"x509/server_cert.pem\"), data.Path(\"x509/server_key.pem\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/reflection\"\n\tpb \"github.com/yourusername/echoservice/proto\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(srv pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tmsg, err := srv.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := srv.Send(msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc main() {\n\tcert, _ := tls.LoadX509KeyPair(\"server.crt\", \"server.key\")\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t}\n\tlis, _ := net.Listen(\"tcp\", \":50051\")\n\tgrpcServer := grpc.NewServer(grpc.Creds(credentials.NewTLS(tlsConfig)))\n\tpb.RegisterEchoServer(grpcServer, &server{})\n\treflection.Register(grpcServer)\n\tfmt.Println(\"Server is running on :50051\")\n\t_ = grpcServer.Serve(lis)\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests using ALTS (Application Layer Transport Security) for authentication.\n\nFunction Description: The main function sets up a gRPC server with ALTS credentials, registers an Echo service implementation, and starts listening on a specified TCP port.\n\nInput:\n- port (int): The TCP port number on which the server should listen (passed via command-line flag)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)\n\nMethods:\n- None (this is a function-level implementation, not a struct)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\taltsTC := alts.NewServerCreds(alts.DefaultServerOptions())\n\n\ts := grpc.NewServer(grpc.Creds(altsTC))\n\n\tpb.RegisterEchoServer(s, &ecServer{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n)\n\ntype EchoRequest struct {\n\tMessage string\n}\n\ntype EchoResponse struct {\n\tMessage string\n}\n\ntype EchoServer interface {\n\tEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error)\n}\n\ntype echoServer struct{}\n\nfunc (e *echoServer) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {\n\treturn &EchoResponse{Message: req.Message}, nil\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"port to listen on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds := alts.NewServerCredentials()\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tgrpc.RegisterEchoServer(s, &echoServer{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, optionally with TLS security, and registers a test service for handling RPC calls.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, configures TLS if enabled, creates a new gRPC server instance, registers a test service, and starts serving incoming requests.\n\nInput:\n- port (int): The port number on which the server should listen\n- useTLS (bool): Flag indicating whether to use TLS security\n- certFile (string): Path to the TLS certificate file (required if useTLS is true)\n- keyFile (string): Path to the TLS private key file (required if useTLS is true)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"google.golang.org/grpc/interop\"\n\ttestpb \"google.golang.org/grpc/interop/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tp := strconv.Itoa(*port)\n\tlis, err := net.Listen(\"tcp\", \":\"+p)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tvar opts []grpc.ServerOption\n\tif *useTLS {\n\t\tcreds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)\n\t\tif err != nil {\n\t\t\tgrpclog.Fatalf(\"Failed to generate credentials %v\", err)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tserver := grpc.NewServer(opts...)\n\ttestpb.RegisterTestServiceServer(server, interop.NewTestServer())\n\tserver.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"tls\"\n\t\"google.golang.org/grpc\"\n)\n\ntype TestRequest struct {\n\tName string\n}\n\ntype TestResponse struct {\n\tMessage string\n}\n\ntype TestService struct{}\n\nfunc (s *TestService) Test(ctx context.Context, req *TestRequest) (*TestResponse, error) {\n\treturn &TestResponse{Message: \"Hello, \" + req.Name}, nil\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 8080, \"The port number on which the server should listen\")\n\tuseTLS := flag.Bool(\"useTLS\", false, \"Flag indicating whether to use TLS security\")\n\tcertFile := flag.String(\"certFile\", \"\", \"Path to the TLS certificate file\")\n\tkeyFile := flag.String(\"keyFile\", \"\", \"Path to the TLS private key file\")\n\n\tflag.Parse()\n\n\tif *useTLS && (*certFile == \"\" || *keyFile == \"\") {\n\t\tlog.Fatalf(\"TLS requires both certFile and keyFile\")\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tvar listener net.Listener\n\tvar err error\n\n\tif *useTLS {\n\t\tcert, err := tls.LoadX509KeyPair(*certFile, *keyFile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to load certificate: %v\", err)\n\t\t}\n\t\tconfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t}\n\t\tlistener, err = tls.Listen(\"tcp\", addr, config)\n\t} else {\n\t\tlistener, err = net.Listen(\"tcp\", addr)\n\t}\n\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\ttestService := &TestService{}\n\tgrpc.RegisterTestServiceServer(grpcServer, testService)\n\n\tlog.Printf(\"Server listening on %v\", addr)\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests, supports optional TLS encryption, and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The Start function initializes and runs a gRPC server with configurable network address and TLS settings. It sets up keepalive parameters, registers the service implementation, and handles OS signals for graceful shutdown.\n\nInput:\n- addr: string - The network address (host:port) to listen on\n- enableTLS: bool - Flag to enable/disable TLS encryption\n- certificate: auth.Certificate - Certificate configuration for TLS (when enabled)\n\nOutput: None (the function runs indefinitely until a termination signal is received)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\tpb \"github.com/ouqiang/gocron/internal/modules/rpc/proto\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\nfunc Start(addr string, enableTLS bool, certificate auth.Certificate) {\n\tl, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\topts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(keepAliveParams),\n\t\tgrpc.KeepaliveEnforcementPolicy(keepAlivePolicy),\n\t}\n\tif enableTLS {\n\t\ttlsConfig, err := certificate.GetTLSConfigForServer()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\topt := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\topts = append(opts, opt)\n\t}\n\tserver := grpc.NewServer(opts...)\n\tpb.RegisterTaskServer(server, Server{})\n\tlog.Infof(\"server listen on %s\", addr)\n\n\tgo func() {\n\t\terr = server.Serve(l)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)\n\tfor {\n\t\ts := <-c\n\t\tlog.Infoln(\"\u6536\u5230\u4fe1\u53f7 -- \", s)\n\t\tswitch s {\n\t\tcase syscall.SIGHUP:\n\t\t\tlog.Infoln(\"\u6536\u5230\u7ec8\u7aef\u65ad\u5f00\u4fe1\u53f7, \u5ffd\u7565\")\n\t\tcase syscall.SIGINT, syscall.SIGTERM:\n\t\t\tlog.Info(\"\u5e94\u7528\u51c6\u5907\u9000\u51fa\")\n\t\t\tserver.GracefulStop()\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"auth\"\n)\n\nfunc Start(addr string, enableTLS bool, certificate auth.Certificate) {\n\tkeepaliveOptions := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tMaxConnectionIdle: 15 * time.Minute,\n\t\t\tMaxConnectionAge:  30 * time.Minute,\n\t\t\tTimeBetweenPings: 5 * time.Minute,\n\t\t}),\n\t\tgrpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{\n\t\t\tMinTimeBetweenPings: 5 * time.Minute,\n\t\t\tPermitWithoutStream:  true,\n\t\t}),\n\t}\n\n\tvar lis net.Listener\n\tvar err error\n\n\tif enableTLS {\n\t\tcert, err := tls.X509KeyPair(certificate.Certificate, certificate.Key)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load certificate: %v\", err)\n\t\t}\n\n\t\ttlsConfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t}\n\n\t\tlis, err = net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t\t}\n\n\t\tlis = tls.NewListener(lis, tlsConfig)\n\t} else {\n\t\tlis, err = net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t\t}\n\t}\n\n\tserver := grpc.NewServer(keepaliveOptions...)\n\t// Register service implementation here\n\n\tserverStopChan := make(chan struct{})\n\n\tgo func() {\n\t\tif err := server.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server failed: %v\", err)\n\t\t}\n\t\tclose(serverStopChan)\n\t}()\n\n\tsignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(signalChan, os.Interrupt, os.Kill)\n\n\tfor {\n\t\tsig := <-signalChan\n\t\tlog.Printf(\"Received signal: %v, shutting down...\", sig)\n\t\tserver.GracefulStop()\n\t\t<-serverStopChan\n\t\tlog.Println(\"Server stopped gracefully.\")\n\t\treturn\n\t}\n}"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a mock gRPC server for OpenTelemetry traces receiver that can handle incoming trace data requests, track request metrics, and optionally use TLS for secure communication.\n\nStruct Description: The mockTracesReceiver struct implements a gRPC server for receiving OpenTelemetry trace data, tracking request counts and spans, and handling metadata. It embeds a base mockReceiver struct and implements the ptraceotlp.GRPCServer interface.\n\nFields:\n\nsrv: [*grpc.Server] - The gRPC server instance\nln: [net.Listener] - Network listener for the server\nrequestCount: [*atomic.Int32] - Counter for received requests\ntotalItems: [*atomic.Int32] - Counter for total spans received\nmux: [sync.Mutex] - Mutex for thread-safe operations\nmetadata: [metadata.MD] - Stores metadata from incoming requests\nexportError: [error] - Error to return from export operations\nexportResponse: [func() ptraceotlp.ExportResponse] - Function to generate export responses\nlastRequest: [ptrace.Traces] - Stores the last received trace data\nhasMetadata: [bool] - Flag indicating whether to process metadata\nspanCountByMetadata: [map[string]int] - Tracks span counts by metadata keys\n\nMethods:\n\nExport: [Name](ctx context.Context, req ptraceotlp.ExportRequest) -> (ptraceotlp.ExportResponse, error) - Handles incoming trace export requests, updates counters, and processes metadata\nstart: [Name]() -> () - Starts the gRPC server in a goroutine\n\nAssociated Functions:\n\notelArrowTracesReceiverOnGRPCServer: [Name](ln net.Listener, useTLS bool) -> (*mockTracesReceiver, error) - Creates and configures a new mock traces receiver with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"go.opentelemetry.io/collector/pdata/ptrace\"\n\t\"go.opentelemetry.io/collector/pdata/ptrace/ptraceotlp\"\n)\n\ntype mockReceiver struct {\n\tsrv          *grpc.Server\n\tln           net.Listener\n\trequestCount *atomic.Int32\n\ttotalItems   *atomic.Int32\n\tmux          sync.Mutex\n\tmetadata     metadata.MD\n\texportError  error\n}\n\ntype mockTracesReceiver struct {\n\tptraceotlp.UnimplementedGRPCServer\n\tmockReceiver\n\texportResponse      func() ptraceotlp.ExportResponse\n\tlastRequest         ptrace.Traces\n\thasMetadata         bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (r *mockTracesReceiver) Export(ctx context.Context, req ptraceotlp.ExportRequest) (ptraceotlp.ExportResponse, error) {\n\tr.requestCount.Add(int32(1))\n\ttd := req.Traces()\n\tr.totalItems.Add(int32(td.SpanCount()))\n\tr.mux.Lock()\n\tdefer r.mux.Unlock()\n\tr.metadata, _ = metadata.FromIncomingContext(ctx)\n\tif r.hasMetadata {\n\t\tv1 := r.metadata.Get(\"key1\")\n\t\tv2 := r.metadata.Get(\"key2\")\n\t\thashKey := fmt.Sprintf(\"%s|%s\", v1, v2)\n\t\tr.spanCountByMetadata[hashKey] += (td.SpanCount())\n\t}\n\tr.lastRequest = td\n\treturn r.exportResponse(), r.exportError\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\tsopts := []grpc.ServerOption{}\n\n\tif useTLS {\n\t\t_, currentFile, _, _ := runtime.Caller(0)\n\t\tbasepath := filepath.Dir(currentFile)\n\t\tcertpath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_cert.pem\"))\n\t\tkeypath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_key.pem\"))\n\n\t\tcreds, err := credentials.NewServerTLSFromFile(certpath, keypath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsopts = append(sopts, grpc.Creds(creds))\n\t}\n\n\trcv := &mockTracesReceiver{\n\t\tmockReceiver: mockReceiver{\n\t\t\tsrv:          grpc.NewServer(sopts...),\n\t\t\tln:           ln,\n\t\t\trequestCount: &atomic.Int32{},\n\t\t\ttotalItems:   &atomic.Int32{},\n\t\t},\n\t\texportResponse: ptraceotlp.NewExportResponse,\n\t}\n\n\tptraceotlp.RegisterGRPCServer(rcv.srv, rcv)\n\n\treturn rcv, nil\n}\n\nfunc (r *mockTracesReceiver) start() {\n\tgo func() {\n\t\t_ = r.srv.Serve(r.ln)\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"math/big\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/open-telemetry/opentelemetry-proto/gen/go/ptraceotlp\"\n\t\"sync/atomic\"\n\t\"log\"\n\t\"golang.org/x/crypto/pem\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/grpc/credentials\"\n)\n\ntype mockTracesReceiver struct {\n\tsrv            *grpc.Server\n\tln             net.Listener\n\trequestCount   *atomic.Int32\n\ttotalItems     *atomic.Int32\n\tmux            sync.Mutex\n\tmetadata       metadata.MD\n\texportError    error\n\texportResponse func() ptraceotlp.ExportResponse\n\tlastRequest    ptrace.Traces\n\thasMetadata    bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (m *mockTracesReceiver) Export(ctx context.Context, req ptraceotlp.ExportRequest) (ptraceotlp.ExportResponse, error) {\n\tm.requestCount.Add(1)\n\tm.mux.Lock()\n\tdefer m.mux.Unlock()\n\n\t// Extract metadata from context\n\tmetadata, _ := metadata.FromContext(ctx)\n\tm.metadata = metadata\n\tm.hasMetadata = len(metadata) > 0\n\n\t// Count total items (spans)\n\ttotalSpans := 0\n\tfor _, trace := range req.Traces {\n\t\tfor _, resourceSpans := range trace.ResourceSpans {\n\t\t\tfor _, scopeSpans := range resourceSpans.ScopeSpans {\n\t\t\t\ttotalSpans += len(scopeSpans.Spans)\n\t\t\t}\n\t\t}\n\t}\n\tm.totalItems.Add(int32(totalSpans))\n\n\t// Update spanCountByMetadata\n\tif m.hasMetadata {\n\t\tfor key := range m.metadata {\n\t\t\tm.spanCountByMetadata[key] += totalSpans\n\t\t}\n\t}\n\n\t// Store last request\n\tm.lastRequest = req.Traces\n\n\t// Handle export error\n\tif m.exportError != nil {\n\t\treturn ptraceotlp.ExportResponse{}, m.exportError\n\t}\n\n\t// Use exportResponse if provided\n\tif m.exportResponse != nil {\n\t\treturn m.exportResponse(), nil\n\t}\n\n\t// Default response\n\treturn ptraceotlp.ExportResponse{}, nil\n}\n\nfunc (m *mockTracesReceiver) start() {\n\tgo func() {\n\t\tif err := m.srv.Serve(m.ln); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc generateSelfSignedCert() (tls.Certificate, error) {\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn tls.Certificate{}, err\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Example Inc\"},\n\t\t},\n\t\tNotBefore: time.Now(),\n\t\tNotAfter:  time.Now().Add(24 * time.Hour),\n\t\tDNSNames:  []string{\"localhost\"},\n\t\tIPAddresses: []net.IP{net.ParseIP(\"127.0.0.1\")},\n\t}\n\n\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)\n\tif err != nil {\n\t\treturn tls.Certificate{}, err\n\t}\n\n\tcert, err := x509.ParseCertificate(derBytes)\n\tif err != nil {\n\t\treturn tls.Certificate{}, err\n\t}\n\n\tcertPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: derBytes,\n\t})\n\tkeyPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"EC PRIVATE KEY\",\n\t\tBytes: x509.MarshalECPrivateKey(priv),\n\t})\n\n\tcert, err = tls.X509KeyPair(certPEM, keyPEM)\n\tif err != nil {\n\t\treturn tls.Certificate{}, err\n\t}\n\n\treturn cert, nil\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\t// Generate TLS certificate if needed\n\tvar tlsConfig *tls.Config\n\tif useTLS {\n\t\tcert, err := generateSelfSignedCert()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttlsConfig = &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t}\n\t\tln = tls.NewListener(ln, tlsConfig)\n\t}\n\n\t// Create gRPC server\n\tsrv := grpc.NewServer()\n\n\t// Register the service\n\tmockReceiver := &mockTracesReceiver{\n\t\tsrv:            srv,\n\t\tln:             ln,\n\t\trequestCount:   &atomic.Int32{},\n\t\ttotalItems:     &atomic.Int32{},\n\t\tspanCountByMetadata: make(map[string]int),\n\t}\n\n\tptraceotlp.RegisterGRPCServer(srv, mockReceiver)\n\n\t// Start the server\n\tmockReceiver.start()\n\n\treturn mockReceiver, nil\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the specified gRPC service.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified TCP port, configures keepalive policies, registers the Echo service, and starts serving requests. It handles any errors that occur during setup or serving.\n\nInput: \n- port (string): The port number on which the server should listen, formatted as a string (e.g., \":50051\").\n- kaep (keepalive.EnforcementPolicy): The keepalive enforcement policy for the server.\n- kasp (keepalive.ServerParameters): The keepalive server parameters.\n\nOutput: \n- None (the function runs indefinitely until an error occurs or the server is stopped).\n- Errors during setup or serving are logged and the program exits.\n\nNote: The function assumes the existence of a pre-defined `server` struct that implements the `EchoServer` interface from the generated protobuf code.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\taddress := fmt.Sprintf(\":%v\", *port)\n\tlis, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\nfunc main(port string, kaep keepalive.EnforcementPolicy, kasp keepalive.ServerParameters) {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\topts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(kasp),\n\t\tgrpc.KeepaliveEnforcementPolicy(kaep),\n\t}\n\n\ts := grpc.NewServer(opts...)\n\tEchoServer.RegisterEchoServer(s, &server)\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a gRPC server for a translation service that can handle text translation requests and return mock translations for testing purposes.\n\nStruct Description: The fakeTranslationServer struct implements a mock gRPC server for the TranslationService, providing a simple translation response without requiring an actual translation service.\n\nFields:\n- UnimplementedTranslationServiceServer: embed - Base type from translatepb package that provides default implementations for all service methods\n\nMethods:\n- TranslateText: [Name](ctx context.Context, req *translatepb.TranslateTextRequest) -> (*translatepb.TranslateTextResponse, error) - Handles translation requests by returning a mock response containing \"Hello World\" as the translated text",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\ttranslate \"cloud.google.com/go/translate/apiv3\"\n\t\"cloud.google.com/go/translate/apiv3/translatepb\"\n\t\"google.golang.org/api/option\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (f *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\tresp := &translatepb.TranslateTextResponse{\n\t\tTranslations: []*translatepb.Translation{\n\t\t\t{TranslatedText: \"Hello World\"},\n\t\t},\n\t}\n\treturn resp, nil\n}\n\nfunc TestTranslateTextWithConcreteClient(t *testing.T) {\n\tctx := context.Background()\n\n\tfakeTranslationServer := &fakeTranslationServer{}\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgsrv := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(gsrv, fakeTranslationServer)\n\tfakeServerAddr := l.Addr().String()\n\tgo func() {\n\t\tif err := gsrv.Serve(l); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tclient, err := translate.NewTranslationClient(ctx,\n\t\toption.WithEndpoint(fakeServerAddr),\n\t\toption.WithoutAuthentication(),\n\t\toption.WithGRPCDialOption(grpc.WithInsecure()),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"translatepb\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (s *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\treturn &translatepb.TranslateTextResponse{TranslatedText: \"Hello World\"}, nil\n}\n\nfunc main() {\n\tlis, _ := net.Listen(\"tcp\", \":50051\")\n\ts := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(s, &fakeTranslationServer{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a gRPC server in Go that implements an echo service and health checking functionality. The server should listen on a specified port, handle incoming gRPC requests, and periodically toggle its health status between SERVING and NOT_SERVING states.\n\nFunction Description: The main function sets up a gRPC server with echo service and health check capabilities. It creates a TCP listener, initializes the gRPC server, registers services, and starts serving requests. A background goroutine periodically changes the health status for demonstration purposes.\n\nInput:\n- port (int): The TCP port number on which the server should listen\n- sleep (time.Duration): The interval at which health status should toggle\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Errors are logged if they occur during server setup or operation\n\nNote: The function uses package-level variables for port and sleep duration (typically set via command-line flags) and assumes the existence of an echoServer struct that implements the Echo service interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n\t\"google.golang.org/grpc/health\"\n\thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n\thealthpb \"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\thealthcheck := health.NewServer()\n\thealthgrpc.RegisterHealthServer(s, healthcheck)\n\tpb.RegisterEchoServer(s, &echoServer{})\n\n\tgo func() {\n\t\tnext := healthpb.HealthCheckResponse_SERVING\n\n\t\tfor {\n\t\t\thealthcheck.SetServingStatus(system, next)\n\n\t\t\tif next == healthpb.HealthCheckResponse_SERVING {\n\t\t\t\tnext = healthpb.HealthCheckResponse_NOT_SERVING\n\t\t\t} else {\n\t\t\t\tnext = healthpb.HealthCheckResponse_SERVING\n\t\t\t}\n\n\t\t\ttime.Sleep(*sleep)\n\t\t}\n\t}()\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\n\nvar port int\nvar sleep time.Duration\nvar currentState bool\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\thealthServer := health.NewServer()\n\thealthServer.SetServingStatus(\"Echo\", grpc_health_v1.HealthCheckResponse_SERVING)\n\tgrpc_health_v1.RegisterHealthServer(grpcServer, healthServer)\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\n\tcurrentState = true\n\tgo func() {\n\t\tfor {\n\t\t\tif currentState {\n\t\t\t\thealthServer.SetServingStatus(\"Echo\", grpc_health_v1.HealthCheckResponse_NOT_SERVING)\n\t\t\t} else {\n\t\t\t\thealthServer.SetServingStatus(\"Echo\", grpc_health_v1.HealthCheckResponse_SERVING)\n\t\t\t}\n\t\t\tcurrentState = !currentState\n\t\t\ttime.Sleep(sleep)\n\t\t}\n\t}()\n\n\tselect {}\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Implement a gRPC server in Go that provides a simple key-value store service with various RPC methods for setting, getting, and streaming items.\n\nStruct Description: The intStoreServer struct implements a gRPC server for a key-value store service, handling item storage and retrieval operations through different RPC patterns (unary, server streaming, client streaming, and bidirectional streaming).\n\nFields:\nAddr: string - The network address where the server is listening\nl: net.Listener - The network listener for incoming connections\ngsrv: *grpc.Server - The gRPC server instance\nitems: map[string]int32 - The internal storage for key-value pairs\n\nMethods:\nnewIntStoreServer: () -> *intStoreServer - Creates and starts a new server instance on an available port\nstop: () -> () - Gracefully shuts down the server\nSet: (context.Context, *pb.Item) -> (*pb.SetResponse, error) - Unary RPC to set a key-value pair\nsetItem: (*pb.Item) -> int32 - Internal helper method to store an item\nGet: (context.Context, *pb.GetRequest) -> (*pb.Item, error) - Unary RPC to retrieve a value by key\nListItems: (*pb.ListItemsRequest, pb.IntStore_ListItemsServer) -> error - Server streaming RPC to list items matching criteria\nSetStream: (pb.IntStore_SetStreamServer) -> error - Client streaming RPC to set multiple items\nStreamChat: (pb.IntStore_StreamChatServer) -> error - Bidirectional streaming RPC for chat-like communication",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"cloud.google.com/go/rpcreplay/proto/intstore\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype intStoreServer struct {\n\tpb.IntStoreServer\n\n\tAddr string\n\tl    net.Listener\n\tgsrv *grpc.Server\n\n\titems map[string]int32\n}\n\nfunc newIntStoreServer() *intStoreServer {\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := &intStoreServer{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tgsrv: grpc.NewServer(),\n\t}\n\tpb.RegisterIntStoreServer(s.gsrv, s)\n\tgo s.gsrv.Serve(s.l)\n\treturn s\n}\n\nfunc (s *intStoreServer) stop() {\n\ts.gsrv.Stop()\n\ts.l.Close()\n}\n\nfunc (s *intStoreServer) Set(_ context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\told := s.setItem(item)\n\treturn &pb.SetResponse{PrevValue: old}, nil\n}\n\nfunc (s *intStoreServer) setItem(item *pb.Item) int32 {\n\tif s.items == nil {\n\t\ts.items = map[string]int32{}\n\t}\n\told := s.items[item.Name]\n\ts.items[item.Name] = item.Value\n\treturn old\n}\n\nfunc (s *intStoreServer) Get(_ context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\tval, ok := s.items[req.Name]\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.NotFound, \"%q\", req.Name)\n\t}\n\treturn &pb.Item{Name: req.Name, Value: val}, nil\n}\n\nfunc (s *intStoreServer) ListItems(req *pb.ListItemsRequest, ss pb.IntStore_ListItemsServer) error {\n\tfor name, val := range s.items {\n\t\tif val > req.GreaterThan {\n\t\t\tif err := ss.Send(&pb.Item{Name: name, Value: val}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *intStoreServer) SetStream(ss pb.IntStore_SetStreamServer) error {\n\tn := 0\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.setItem(item)\n\t\tn++\n\t}\n\treturn ss.SendAndClose(&pb.Summary{Count: int32(n)})\n}\n\nfunc (s *intStoreServer) StreamChat(ss pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ss.Send(item); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype intStoreServer struct {\n\tAddr string\n\tl    net.Listener\n\tgsrv *grpc.Server\n\titems map[string]int32\n}\n\nfunc newIntStoreServer() *intStoreServer {\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\taddr := l.Addr().String()\n\ts := &intStoreServer{\n\t\tAddr:  addr,\n\t\tl:     l,\n\t\titems: make(map[string]int32),\n\t}\n\ts.gsrv = grpc.NewServer()\n\tpb.RegisterIntStoreServer(s.gsrv, s)\n\treflection.Register(s.gsrv)\n\tgo func() {\n\t\tif err := s.gsrv.Serve(l); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\treturn s\n}\n\nfunc (s *intStoreServer) stop() {\n\tif s.gsrv != nil {\n\t\ts.gsrv.Stop()\n\t}\n\tif s.l != nil {\n\t\ts.l.Close()\n\t}\n}\n\nfunc (s *intStoreServer) Set(ctx context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\tvalue := s.setItem(item)\n\treturn &pb.SetResponse{Value: value}, nil\n}\n\nfunc (s *intStoreServer) setItem(item *pb.Item) int32 {\n\ts.items[item.Key] = item.Value\n\treturn item.Value\n}\n\nfunc (s *intStoreServer) Get(ctx context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\titem, exists := s.items[req.Key]\n\tif !exists {\n\t\treturn nil, status.Errorf(codes.NotFound, \"key not found\")\n\t}\n\treturn &pb.Item{Key: req.Key, Value: item}, nil\n}\n\nfunc (s *intStoreServer) ListItems(req *pb.ListItemsRequest, stream pb.IntStore_ListItemsServer) error {\n\tfor key, value := range s.items {\n\t\tif err := stream.Send(&pb.Item{Key: key, Value: value}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *intStoreServer) SetStream(stream pb.IntStore_SetStreamServer) error {\n\tfor {\n\t\titem, err := stream.Recv()\n\t\tif err == nil {\n\t\t\ts.setItem(item)\n\t\t} else if err == io.EOF {\n\t\t\tbreak\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn stream.SendAndClose(&pb.SetResponse{Value: 0})\n}\n\nfunc (s *intStoreServer) StreamChat(stream pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := stream.Send(msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tserver := newIntStoreServer()\n\tdefer server.stop()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\n\t<-c\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages to brokers using different modes (Sync, Async, or OneWay) with configurable options.\n\nStruct Description: The Producer struct encapsulates a RocketMQ producer client with methods for starting, closing, and sending messages. It supports configuration options and interceptors.\n\nFields:\n\n- started: bool - Indicates whether the producer has been started\n- Producer: rocketmq.Producer - The underlying RocketMQ producer instance\n- name: string - Name identifier for the producer\n- ProducerConfig: ProducerConfig - Configuration settings for the producer\n- interceptors: []primitive.Interceptor - List of interceptors for message processing\n\nMethods:\n\n- Start() -> error - Initializes and starts the RocketMQ producer with configured options\n- Close() -> error - Shuts down the producer gracefully\n- SendWithContext(ctx context.Context, msg []byte) -> error - Sends a byte array message with context\n- SendWithMsg(ctx context.Context, msg *primitive.Message) -> error - Sends a primitive.Message with context\n- SendWithResult(ctx context.Context, msg []byte, tag string) -> (*primitive.SendResult, error) - Sends a message with tag and returns send result\n- SendMsg(ctx context.Context, msg *primitive.Message) -> (*primitive.SendResult, error) - Sends a message and returns send result",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/douyu/jupiter/pkg/xlog\"\n)\n\ntype Producer struct {\n\tstarted bool\n\n\trocketmq.Producer\n\tname string\n\tProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc (pc *Producer) Start() error {\n\tif pc.started {\n\t\treturn nil\n\t}\n\n\tclient, err := rocketmq.NewProducer(\n\t\tproducer.WithGroupName(pc.Group),\n\t\tproducer.WithNameServer(pc.Addr),\n\t\tproducer.WithRetry(pc.Retry),\n\t\tproducer.WithInterceptor(pc.interceptors...),\n\t\tproducer.WithInstanceName(pc.InstanceName),\n\t\tproducer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: pc.AccessKey,\n\t\t\tSecretKey: pc.SecretKey,\n\t\t}),\n\t)\n\tif err != nil {\n\t\txlog.Jupiter().Panic(\"create producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tif err := client.Start(); err != nil {\n\t\txlog.Jupiter().Panic(\"start producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tpc.started = true\n\tpc.Producer = client\n\treturn nil\n}\n\nfunc (pc *Producer) Close() error {\n\terr := pc.Shutdown()\n\tif err != nil {\n\t\txlog.Jupiter().Warn(\"consumer close fail\", xlog.Any(\"error\", err.Error()))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\t_, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tmsg.Topic = pc.Topic\n\t_, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\tif tag != \"\" {\n\t\tm.WithTag(tag)\n\t}\n\n\tres, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", string(msg)))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}\n\nfunc (pc *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tres, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 127,
    "right_result": "package rocketmq\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/srv\"\n\t\"github.com/apache/rocketmq-client-go/v2/utils\"\n\t\"log\"\n)\n\ntype ProducerConfig struct {\n\tNameServer        string\n\tTopic             string\n\tProducerGroup    string\n\tMaxMessageSize   int\n\tBufferMemory     int64\n\tCompressLevel    int\n\t// Add other configuration options as needed\n}\n\ntype Producer struct {\n\tstarted       bool\n\tProducer      rocketmq.Producer\n\tname          string\n\tProducerConfig *ProducerConfig\n\tinterceptors  []primitive.Interceptor\n}\n\nfunc NewProducer(name string, config *ProducerConfig) *Producer {\n\treturn &Producer{\n\t\tname:          name,\n\t\tProducerConfig: config,\n\t}\n}\n\nfunc (p *Producer) Start() error {\n\tif p.started {\n\t\treturn nil\n\t}\n\t// Initialize the producer with the given configuration\n\tp.Producer, _ = rocketmq.NewProducer(\n\t\trocketmq.WithNameServer(p.ProducerConfig.NameServer),\n\t\trocketmq.WithGroupName(p.ProducerConfig.ProducerGroup),\n\t\trocketmq.WithMaxMsgSize(p.ProducerConfig.MaxMessageSize),\n\t\trocketmq.WithBufferMemory(p.ProducerConfig.BufferMemory),\n\t\trocketmq.WithCompressLevel(p.ProducerConfig.CompressLevel),\n\t)\n\t// Register interceptors\n\tfor _, interceptor := range p.interceptors {\n\t\tp.Producer.RegisterInterceptor(interceptor)\n\t}\n\terr := p.Producer.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.started = true\n\treturn nil\n}\n\nfunc (p *Producer) Close() error {\n\tif !p.started {\n\t\treturn nil\n\t}\n\terr := p.Producer.Shutdown()\n\tp.started = false\n\treturn err\n}\n\nfunc (p *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tm := &primitive.Message{\n\t\tTopic: p.ProducerConfig.Topic,\n\t\tBody:  msg,\n\t}\n\tfor _, interceptor := range p.interceptors {\n\t\tif err := interceptor.Intercept(m); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := p.Producer.SendAsync(m, func(result *primitive.SendResult, e error) {\n\t\tif e != nil {\n\t\t\tlog.Printf(\"Async send error: %v\", e)\n\t\t}\n\t})\n\treturn err\n}\n\nfunc (p *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tfor _, interceptor := range p.interceptors {\n\t\tif err := interceptor.Intercept(msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := p.Producer.SendAsync(msg, func(result *primitive.SendResult, e error) {\n\t\tif e != nil {\n\t\t\tlog.Printf(\"Async send error: %v\", e)\n\t\t}\n\t})\n\treturn err\n}\n\nfunc (p *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tm := &primitive.Message{\n\t\tTopic: p.ProducerConfig.Topic,\n\t\tBody:  msg,\n\t\tTags:  []string{tag},\n\t}\n\tfor _, interceptor := range p.interceptors {\n\t\tif err := interceptor.Intercept(m); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tresult, err := p.Producer.SendSync(m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (p *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tfor _, interceptor := range p.interceptors {\n\t\tif err := interceptor.Intercept(msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tresult, err := p.Producer.SendSync(msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response body as a byte slice or an error if the request fails.\n\nFunction Description: The function makes an HTTP GET request to the provided URL, reads the response body, and returns it as a byte slice. It handles errors during the request or reading process and ensures the response body is properly closed to prevent resource leaks.\n\nInput: \n- url (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- ([]byte, error): A byte slice containing the response body if the request is successful, or an error if the request fails or the response body cannot be read.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.github.com/repos/zyedidia/micro/releases\")\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc getResponseBody(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to retrieve configuration data from a local admin API endpoint and returns the response body as a string.\n\nFunction Description: The function `getEffectiveConfig` makes an HTTP GET request to a specified local port's admin API endpoint (/api/v1/config_dump). It handles the response by checking the status code, reading the response body, and returning it as a string. It includes proper error handling for failed requests or non-200 status codes.\n\nInput: \n- port [uint32] - The local port number where the admin API is running\n\nOutput:\n- [string] - The response body as a string if the request is successful\n- [error] - An error object describing any issues that occurred during the request (connection error, non-200 status code, or body read error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"errors\"\n)\nfunc getEffectiveConfig(port uint32) (string, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"http://localhost:%d/api/v1/config_dump\", port))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"call admin api failed response status: %d, %s\", resp.StatusCode, string(b)))\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getEffectiveConfig(port uint32) (string, error) {\n\turl := fmt.Sprintf(\"http://localhost:%d/api/v1/config_dump\", port)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Implement a function to retrieve a proxy address from a specified HTTP endpoint and return it in a formatted string.\n\nFunction Description: The function `getOneProxy` makes an HTTP GET request to a predefined proxy server endpoint, reads the response body to obtain the proxy address, formats it with an \"http://\" prefix, and returns both the formatted and raw proxy strings. It includes basic error handling for the response reading process.\n\nInput: None (The function takes no input parameters)\n\nOutput: \n1. A string representing the formatted proxy address with \"http://\" prefix\n2. A string representing the raw proxy address from the response body",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc getOneProxy() (string, string) {\n\tresp, _ := http.Get(\"http://45.78.45.70:5015/get/\")\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t}\n\tproxy := \"http://\" + string(body)\n\tfmt.Println(\"\u4f7f\u7528\u9ed8\u8ba4\u4ee3\u7406\uff1a\" + proxy)\n\treturn proxy, string(body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getOneProxy() (string, string) {\n\turl := \"http://example-proxy-server.com/proxy\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", \"\"\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\"\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\"\n\t}\n\n\traw := string(body)\n\tformatted := \"http://\" + raw\n\n\treturn formatted, raw\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a Proxy struct that manages different types of servers (UDS, mTLS, admin, and health) for handling proxy connections with various protocols (HTTP and gRPC).\n\nStruct Description: The Proxy struct provides methods to run different server types with configurable options, including Unix Domain Socket (UDS) servers, mTLS-secured servers, admin servers for metrics and profiling, and health servers for liveness/readiness checks.\n\nMethods:\n\nMethod1: runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a master server using Unix Domain Socket (UDS) for communication. Supports both gRPC and HTTP modes based on configuration. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod2: runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a mTLS-secured master server listening on a TCP port. Supports both gRPC and HTTP modes. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod3: runAdminServer(o *options.ProxyRunOptions) -> void - Starts an admin server for metrics and optional profiling endpoints. Runs on a localhost port specified in options.\n\nMethod4: runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) -> void - Starts a health server providing liveness (/healthz) and readiness (/ready) endpoints. Runs on a port specified in options.\n\nNote: StopFunc is a function type defined as: type StopFunc func()",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Proxy struct {\n}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tif o.DeleteUDSFile {\n\t\tif err := os.Remove(o.UdsName); err != nil && !os.IsNotExist(err) {\n\t\t\tklog.ErrorS(err, \"failed to delete file\", \"file\", o.UdsName)\n\t\t}\n\t}\n\tvar stop StopFunc\n\tif o.Mode == \"grpc\" {\n\t\tgrpcServer := grpc.NewServer()\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := getUDSListener(ctx, o.UdsName)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get uds listener: %v\", err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\tserver := &http.Server{\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tklog.ErrorS(err, \"error shutting down server\")\n\t\t}\n\t\tgo func() {\n\t\t\tudsListener, err := getUDSListener(ctx, o.UdsName)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to get uds listener\")\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\terr := udsListener.Close()\n\t\t\t\tklog.ErrorS(err, \"failed to close uds listener\")\n\t\t\t}()\n\t\t\terr = server.Serve(udsListener)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to serve uds requests\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tvar stop StopFunc\n\n\tvar tlsConfig *tls.Config\n\tvar err error\n\tif tlsConfig, err = p.getTLSConfig(o.ServerCaCert, o.ServerCert, o.ServerKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", o.ServerPort)\n\n\tif o.Mode == grpcMode {\n\t\tserverOption := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\tgrpcServer := grpc.NewServer(serverOption)\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to listen on %s: %v\", addr, err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\thttpServer := &http.Server{\n\t\t\tAddr: \":8088\",\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr:      addr,\n\t\t\tTLSConfig: tlsConfig,\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t\tTLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),\n\t\t}\n\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown server\")\n\t\t\t}\n\t\t\terr = httpServer.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown httpServer\")\n\t\t\t}\n\t\t}\n\t\tgo func() {\n\t\t\terr := server.ListenAndServeTLS(\"\", \"\")\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on master port\")\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\terr := httpServer.ListenAndServe()\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on http master port\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.Handle(\"/metrics\", promhttp.Handler())\n\tif o.EnableProfiling {\n\t\tmuxHandler.HandleFunc(\"/debug/pprof\", util.RedirectTo(\"/debug/pprof/\"))\n\t\tmuxHandler.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\tif o.EnableContentionProfiling {\n\t\t\truntime.SetBlockProfileRate(1)\n\t\t}\n\t}\n\tadminServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\"127.0.0.1:%d\", o.AdminPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := adminServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"admin server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Admin server stopped listening\")\n\t}()\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\tlivenessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\treadinessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tready, msg := server.Readiness.Ready()\n\t\tif ready {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tfmt.Fprintf(w, \"ok\")\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, msg)\n\t})\n\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.HandleFunc(\"/healthz\", livenessHandler)\n\tmuxHandler.HandleFunc(\"/ready\", readinessHandler)\n\thealthServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\":%d\", o.HealthPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := healthServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"health server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Health server stopped listening\")\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "right_result": "package proxy\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype StopFunc func()\n\ntype Proxy struct{}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tlistener, err := net.Listen(\"unix\", o.UnixAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar server *http.Server\n\tif o.HTTPMode {\n\t\tserver = &http.Server{\n\t\t\tAddr:    listener.Addr().String(),\n\t\t\tHandler: s.Handler(),\n\t\t}\n\t} else {\n\t\tgrpcServer := grpc.NewServer()\n\t\ts.RegisterGRPCServer(grpcServer)\n\t\tgo func() {\n\t\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\t\tlog.Fatalf(\"gRPC server exited with error: %v\", err)\n\t\t\t}\n\t\t}()\n\t\treturn func() {\n\t\t\tgrpcServer.Stop()\n\t\t}, nil\n\t}\n\n\tgo func() {\n\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"HTTP server exited with error: %v\", err)\n\t\t}\n\t}()\n\n\treturn func() {\n\t\tserver.Close()\n\t}, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\ttlsConfig := &tls.Config{\n\t\tMinVersion: tls.VersionTLS12,\n\t}\n\tlistener, err := tls.Listen(\"tcp\", o.TCPAddr, tlsConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar server *http.Server\n\tif o.HTTPMode {\n\t\tserver = &http.Server{\n\t\t\tAddr:    listener.Addr().String(),\n\t\t\tHandler: s.Handler(),\n\t\t}\n\t} else {\n\t\tgrpcServer := grpc.NewServer()\n\t\ts.RegisterGRPCServer(grpcServer)\n\t\tgo func() {\n\t\t\tif err := grpcServer.Serve(listener); err != nil {\n\t\t\t\tlog.Fatalf(\"gRPC server exited with error: %v\", err)\n\t\t\t}\n\t\t}()\n\t\treturn func() {\n\t\t\tgrpcServer.Stop()\n\t\t}, nil\n\t}\n\n\tgo func() {\n\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"HTTP server exited with error: %v\", err)\n\t\t}\n\t}()\n\n\treturn func() {\n\t\tserver.Close()\n\t}, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Serve metrics\n\t})\n\tmux.HandleFunc(\"/debug/pprof/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Serve profiling\n\t})\n\thttp.ListenAndServe(o.AdminAddr, mux)\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, s *server.ProxyServer) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\tmux.HandleFunc(\"/ready\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\thttp.ListenAndServe(o.HealthAddr, mux)\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a robust RabbitMQ producer in Go that handles connection management, channel initialization, and message publishing with automatic reconnection capabilities.\n\nStruct Description: The Session struct represents a RabbitMQ producer session that maintains connection state and provides message publishing functionality with automatic reconnection.\n\nFields:\n- name: string - The name of the queue to publish to\n- logger: *log.Logger - Logger for session events\n- connection: *amqp.Connection - RabbitMQ connection object\n- channel: *amqp.Channel - RabbitMQ channel object\n- done: chan bool - Channel to signal shutdown\n- notifyConnClose: chan *amqp.Error - Channel for connection close notifications\n- notifyChanClose: chan *amqp.Error - Channel for channel close notifications\n- notifyConfirm: chan amqp.Confirmation - Channel for publish confirmations\n- isReady: bool - Flag indicating if session is ready to publish\n\nMethods:\n- New(name string, addr string) -> *Session - Creates a new Session instance and starts connection management\n- handleReconnect(addr string) - Manages reconnection logic in a goroutine\n- connect(addr string) -> (*amqp.Connection, error) - Establishes connection to RabbitMQ server\n- handleReInit(conn *amqp.Connection) -> bool - Handles channel reinitialization after connection\n- init(conn *amqp.Connection) -> error - Initializes channel and declares queue\n- changeConnection(connection *amqp.Connection) - Updates connection and sets up close notifications\n- changeChannel(channel *amqp.Channel) - Updates channel and sets up close/confirm notifications\n- Push(data []byte) -> error - Safely publishes message with retry logic\n- UnsafePush(data []byte) -> error - Publishes message without safety checks (used internally)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string) *Session {\n\tsession := Session{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tname:   name,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn &session\n}\n\nfunc (session *Session) handleReconnect(addr string) {\n\tfor {\n\t\tsession.isReady = false\n\t\tlog.Println(\"Attempting to connect\")\n\n\t\tconn, err := session.connect(addr)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to connect. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif done := session.handleReInit(conn); done {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (session *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.changeConnection(conn)\n\tlog.Println(\"Connected!\")\n\treturn conn, nil\n}\n\nfunc (session *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\tsession.isReady = false\n\n\t\terr := session.init(conn)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to initialize channel. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn true\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-session.done:\n\t\t\treturn true\n\t\tcase <-session.notifyConnClose:\n\t\t\tlog.Println(\"Connection closed. Reconnecting...\")\n\t\t\treturn false\n\t\tcase <-session.notifyChanClose:\n\t\t\tlog.Println(\"Channel closed. Re-running init...\")\n\t\t}\n\t}\n}\n\nfunc (session *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = ch.QueueDeclare(\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.changeChannel(ch)\n\tsession.isReady = true\n\tlog.Println(\"Setup!\")\n\n\treturn nil\n}\n\nfunc (session *Session) changeConnection(connection *amqp.Connection) {\n\tsession.connection = connection\n\tsession.notifyConnClose = make(chan *amqp.Error)\n\tsession.connection.NotifyClose(session.notifyConnClose)\n}\n\nfunc (session *Session) changeChannel(channel *amqp.Channel) {\n\tsession.channel = channel\n\tsession.notifyChanClose = make(chan *amqp.Error)\n\tsession.notifyConfirm = make(chan amqp.Confirmation, 1)\n\tsession.channel.NotifyClose(session.notifyChanClose)\n\tsession.channel.NotifyPublish(session.notifyConfirm)\n}\n\nfunc (session *Session) Push(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"failed to push: not connected\")\n\t}\n\tfor {\n\t\terr := session.UnsafePush(data)\n\t\tif err != nil {\n\t\t\tsession.logger.Println(\"Push failed. Retrying...\")\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn errors.New(\"session is shutting down\")\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-session.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\tsession.logger.Println(\"Push confirmed!\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t}\n\t\tsession.logger.Println(\"Push didn't confirm. Retrying...\")\n\t}\n}\n\nfunc (session *Session) UnsafePush(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"not connected to a server\")\n\t}\n\treturn session.channel.Publish(\n\t\t\"\",\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Session struct {\n\tname         string\n\tlogger       *log.Logger\n\tconnection   *amqp.Connection\n\tchannel      *amqp.Channel\n\tdone         chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm  chan amqp.Confirmation\n\tisReady        bool\n}\n\nfunc New(name string, addr string) *Session {\n\tsession := &Session{\n\t\tname:         name,\n\t\tlogger:       log.New(log.Writer(), \"RABBITMQ: \", log.LstdFlags),\n\t\tdone:         make(chan bool),\n\t\tnotifyConnClose: make(chan *amqp.Error),\n\t\tnotifyChanClose: make(chan *amqp.Error),\n\t\tnotifyConfirm:  make(chan amqp.Confirmation),\n\t}\n\n\tgo session.handleReconnect(addr)\n\treturn session\n}\n\nfunc (s *Session) handleReconnect(addr string) {\n\tfor {\n\t\tconn, err := s.connect(addr)\n\t\tif err != nil {\n\t\t\ts.logger.Printf(\"Failed to connect: %v\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\ts.changeConnection(conn)\n\t\tif err := s.init(conn); err != nil {\n\t\t\ts.logger.Printf(\"Failed to initialize: %v\", err)\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\t\ts.logger.Println(\"Connected and initialized\")\n\t\tbreak\n\t}\n}\n\nfunc (s *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn.NotifyClose(s.notifyConnClose)\n\treturn conn, nil\n}\n\nfunc (s *Session) handleReInit(conn *amqp.Connection) bool {\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\ts.logger.Printf(\"Failed to create channel: %v\", err)\n\t\treturn false\n\t}\n\tif err := ch.Confirm(); err != nil {\n\t\ts.logger.Printf(\"Failed to enable confirmations: %v\", err)\n\t\treturn false\n\t}\n\ts.changeChannel(ch)\n\tif err := s.init(conn); err != nil {\n\t\ts.logger.Printf(\"Failed to reinitialize: %v\", err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := ch.Confirm(); err != nil {\n\t\treturn err\n\t}\n\ts.changeChannel(ch)\n\tif err := ch.QueueDeclare(s.name, false, false, false, false, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *Session) changeConnection(conn *amqp.Connection) {\n\ts.connection = conn\n}\n\nfunc (s *Session) changeChannel(ch *amqp.Channel) {\n\ts.channel = ch\n\tch.NotifyClose(s.notifyChanClose)\n\tch.NotifyPublish(s.notifyConfirm)\n}\n\nfunc (s *Session) Push(data []byte) error {\n\tif !s.isReady {\n\t\treturn fmt.Errorf(\"session not ready\")\n\t}\n\tfor {\n\t\tif err := s.UnsafePush(data); err != nil {\n\t\t\ts.logger.Printf(\"Failed to publish: %v\", err)\n\t\t\tif err := s.reconnect(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *Session) UnsafePush(data []byte) error {\n\tif s.channel == nil || s.channel.IsClosed() {\n\t\treturn fmt.Errorf(\"channel closed\")\n\t}\n\treturn s.channel.Publish(\n\t\t\"\", s.name, false, false, amqp.Publishing{\n\t\t\tBody: data,\n\t\t})\n}\n\nfunc (s *Session) reconnect() error {\n\tselect {\n\tcase <-s.done:\n\t\treturn nil\n\tdefault:\n\t\treturn s.handleReconnect(s.connection.RemoteAddr().String())\n\t}\n}"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Implement a RabbitMQ client in Go that handles connection management, queue declaration, and message publishing with retry logic for reliability.\n\nStruct Description: RabbitClient is a struct that encapsulates the functionality for interacting with a RabbitMQ server, including establishing connections, declaring queues, and publishing messages with automatic reconnection attempts on failures.\n\nFields:\n- url: string - The connection URL for the RabbitMQ server\n- queueName: string - The name of the queue to interact with\n- connection: *amqp.Connection - The active RabbitMQ connection\n- channel: *amqp.Channel - The channel for communication with RabbitMQ\n\nMethods:\n- Connect() -> void - Establishes connection to RabbitMQ server, creates a channel, and declares a queue with TTL and priority settings. Implements retry logic on failures.\n- PublishTgMessage(messageBag MessageBag) -> void - Publishes a message to the declared queue after JSON serialization. Implements retry logic on failures and handles reconnection.\n- Close() -> void - Properly closes the channel and connection to RabbitMQ if they exist.\n- NewRabbitClient(url string, queueName string) -> *RabbitClient - Constructor function that initializes and returns a new RabbitClient instance with established connection.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"time\"\n)\n\ntype RabbitClient struct {\n\turl\t\t\tstring\n\tqueueName\tstring\n\tconnection\t*amqp.Connection\n\tchannel\t\t*amqp.Channel\n}\n\nfunc (rc *RabbitClient) Connect() {\n\tfor {\n\t\tvar err error\n\n\t\trc.connection, err = amqp.Dial(rc.url)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't connect to rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\trc.channel, err = rc.connection.Channel()\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't create channel (connect was ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\targs := make(amqp.Table)\n\t\targs[\"x-message-ttl\"] = int32(1000 * 60 * 60 * 24 * 10)\n\t\targs[\"x-max-priority\"] = int32(255)\n\n\t\t_, err = rc.channel.QueueDeclare(\n\t\t\trc.queueName,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\targs,\n\t\t)\n\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't declare queue (connect, channel were ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tfor {\n\t\tbody, err := json.Marshal(messageBag)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error marshaling a message.\")\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Publishing %+v ...\\n\", string(body))\n\n\t\terr = rc.channel.Publish(\n\t\t\t\"\",\n\t\t\trc.queueName,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tamqp.Publishing{\n\t\t\t\tDeliveryMode: amqp.Persistent,\n\t\t\t\tContentType: \"text/plain\",\n\t\t\t\tBody: body,\n\t\t\t\tPriority: messageBag.Priority,\n\t\t\t})\n\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't publish text '%s', will retry in 1 sec: %s\", string(body), err)\n\t\t\trc.Close()\n\t\t\trc.Connect()\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) Close() {\n\tif rc.channel != nil {\n\t\trc.channel.Close()\n\t}\n\tif rc.connection != nil {\n\t\trc.connection.Close()\n\t}\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\trabbit := &RabbitClient{\n\t\turl: url,\n\t\tqueueName: queueName,\n\t}\n\trabbit.Connect()\n\tlog.Println(\"Successfully connected to RabbitMQ\")\n\treturn rabbit\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype MessageBag struct {\n\t// Define your message fields here\n}\n\ntype RabbitClient struct {\n\turl       string\n\tqueueName string\n\tconnection *amqp.Connection\n\tchannel   *amqp.Channel\n}\n\nfunc (c *RabbitClient) Connect() {\n\tvar conn *amqp.Connection\n\tvar ch *amqp.Channel\n\tvar err error\n\n\tfor i := 0; i < 5; i++ {\n\t\tconn, err = amqp.Dial(c.url)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second * time.Duration(i+1))\n\t}\n\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to connect to RabbitMQ: %v\", err))\n\t}\n\n\tc.connection = conn\n\n\tch, err = conn.Channel()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to open a channel: %v\", err))\n\t}\n\n\tc.channel = ch\n\n\targs := amqp.Table{\n\t\t\"x-message-ttl\":  60 * 1000,\n\t\t\"x-max-priority\": 10,\n\t}\n\n\t_, err = c.channel.QueueDeclare(c.queueName, false, false, false, false, args)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to declare queue: %v\", err))\n\t}\n}\n\nfunc (c *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tvar body []byte\n\tvar err error\n\n\tfor i := 0; i < 5; i++ {\n\t\tif c.connection == nil || c.connection.IsClosed() {\n\t\t\tc.Connect()\n\t\t}\n\n\t\tif c.channel == nil || c.channel.IsClosed() {\n\t\t\tch, err := c.connection.Channel()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.channel = ch\n\n\t\t\targs := amqp.Table{\n\t\t\t\t\"x-message-ttl\":  60 * 1000,\n\t\t\t\t\"x-max-priority\": 10,\n\t\t\t}\n\n\t\t\t_, err = c.channel.QueueDeclare(c.queueName, false, false, false, false, args)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tbody, err = json.Marshal(messageBag)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\terr = c.channel.Publish(\n\t\t\t\"\", // exchange\n\t\t\tc.queueName, // routing key\n\t\t\tfalse, // mandatory\n\t\t\tfalse, // immediate\n\t\t\tamqp.Publishing{\n\t\t\t\tContentType: \"application/json\",\n\t\t\t\tBody:        body,\n\t\t\t})\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(time.Second * time.Duration(i+1))\n\t}\n}\n\nfunc (c *RabbitClient) Close() {\n\tif c.channel != nil {\n\t\t_ = c.channel.Close()\n\t}\n\tif c.connection != nil {\n\t\t_ = c.connection.Close()\n\t}\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\tclient := &RabbitClient{\n\t\turl:       url,\n\t\tqueueName: queueName,\n\t}\n\tclient.Connect()\n\treturn client\n}"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a function that handles WebSocket connections by upgrading HTTP connections, reading incoming messages, and forwarding them to a channel for further processing.\n\nFunction Description: The function `makeUpgradeOnConnect` generates and returns an HTTP handler function that upgrades incoming HTTP connections to WebSocket connections. It reads messages from the WebSocket connection and sends them to a provided channel. The WebSocket connection is properly closed when processing is complete.\n\nInput: \n- `ch chan string`: A channel of strings used to forward incoming WebSocket messages for further processing.\n\nOutput: \n- Returns a function of type `func(http.ResponseWriter, *http.Request)` that serves as an HTTP handler for WebSocket connections.\n\nNote: The returned HTTP handler function does not explicitly return any value but handles WebSocket communication and message forwarding internally.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer c.Close()\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tch <- string(message)\n\t\t\t}()\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n)\n\nfunc makeUpgradeOnConnect(ch chan string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t}\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tch <- string(message)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that manages WebSocket connections, including upgrading HTTP connections, reading incoming messages, writing periodic messages, and properly closing the connection.\n\nFunction Description: The `wsHandler` function creates an HTTP handler that upgrades incoming HTTP requests to WebSocket connections. It continuously writes numbered messages to the client while concurrently reading any incoming messages from the client. The function stops after sending a specified number of messages and closes the connection gracefully.\n\nInput:\n- `t *testing.T`: Testing context for error reporting\n- `recvBuffer *bytes.Buffer`: Buffer to store received messages from the WebSocket client\n\nOutput:\n- Returns an `http.HandlerFunc` that implements the WebSocket handling logic\n\nNote: The function doesn't directly return values but rather creates a handler function that manages WebSocket communication through the provided buffer and testing context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\trequire.NoError(t, err)\n\t\tdefer c.Close()\n\t\ti := 0\n\t\tfinish := 5\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\n\t\t\ti++\n\t\t\tdata := struct {\n\t\t\t\tMessage string `json:\"message\"`\n\t\t\t}{\n\t\t\t\tMessage: fmt.Sprintf(\"%d\\n\", i),\n\t\t\t}\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := json.NewEncoder(buf).Encode(data)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = c.WriteMessage(websocket.TextMessage, buf.Bytes())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif i == finish {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\terr = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\trequire.NoError(t, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "import (\n\t\"fmt\"\n\t\"time\"\n\t\"bytes\"\n\t\"testing\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool { return true },\n\t}\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\t// Read messages from client\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, msg, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(msg)\n\t\t\t\trecvBuffer.WriteByte('\\n')\n\t\t\t}\n\t\t}()\n\n\t\t// Send messages\n\t\tcounter := 0\n\t\tfor {\n\t\t\tif counter >= 5 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tmsg := fmt.Sprintf(\"%d\", counter)\n\t\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(msg)); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcounter++\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\tconn.Close()\n\t}\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that handles specific command requests through a web interface. The server should process incoming commands and forward them to a command parser.\n\nFunction Description: The `cmdHandle` function is an HTTP handler that processes POST requests containing a \"cmd\" parameter. It extracts the command and passes it to a command parser. The `InitWeb` function initializes the web server, registers the handler, and starts listening on a specified URL.\n\nInput:\n- For `cmdHandle`:\n  - `w http.ResponseWriter` - Used to write the HTTP response\n  - `r *http.Request` - Contains the incoming HTTP request\n- For `InitWeb`:\n  - None (uses package-level variable `world.Web_Url` for server address)\n\nOutput:\n- For `cmdHandle`:\n  - None (writes response directly to `http.ResponseWriter`)\n- For `InitWeb`:\n  - None (starts server as a side effect, may log errors)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tcmd := r.FormValue(\"cmd\")\n\tif cmd != \"\" {\n\t\tcm.ParseConsole(g_Cmd, (cmd))\n\t}\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/gm\", cmdHandle)\n\terr := http.ListenAndServe(world.Web_Url, nil)\n\tif err != nil {\n\t\tbase.LOG.Println(\"World Web Server : \", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar world struct {\n\tWeb_Url string\n}\n\nfunc parseCommand(cmd string) {\n\t// Placeholder for command parsing logic\n}\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\tif err := r.ParseForm(); err != nil {\n\t\thttp.Error(w, \"Failed to parse form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tcmd := r.FormValue(\"cmd\")\n\tif cmd == \"\" {\n\t\thttp.Error(w, \"Missing 'cmd' parameter\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tparseCommand(cmd)\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"Command received: %s\", cmd)\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/cmd\", cmdHandle)\n\tlog.Println(\"Starting server on\", world.Web_Url)\n\tif err := http.ListenAndServe(world.Web_Url, nil); err != nil {\n\t\tlog.Fatal(\"Server failed to start:\", err)\n\t}\n}"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Implement a WebSocket server for RDP (Remote Desktop Protocol) connections using the Gorilla WebSocket library in Go. The server should handle WebSocket connections, manage RDP sessions through a Guacamole tunnel, and support bidirectional communication between the client and the RDP server.\n\nStruct Description: The RDPServer struct represents an RDP WebSocket server that manages WebSocket connections and RDP sessions via Guacamole tunnels.\n\nFields:\n- Session: *session.SSession - The current user session information\n- Host: string - The RDP server host address\n- Port: int - The RDP server port number\n- Username: string - The username for RDP authentication\n- Password: string - The password for RDP authentication\n- ConnectionId: string - Unique identifier for the RDP connection\n- Width: int - The screen width for the RDP session\n- Height: int - The screen height for the RDP session\n- Dpi: int - The DPI setting for the RDP session\n\nMethods:\n- ServeHTTP: (w http.ResponseWriter, r *http.Request) -> None - Handles HTTP requests by upgrading them to WebSocket connections, establishing a Guacamole tunnel, and managing bidirectional communication between the client and RDP server. This method implements the http.Handler interface.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"yunion.io/x/log\"\n\t\"yunion.io/x/pkg/errors\"\n\n\t\"yunion.io/x/onecloud/pkg/webconsole/guac\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/options\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/session\"\n)\n\ntype RDPServer struct {\n\tSession *session.SSession\n\n\tHost         string\n\tPort         int\n\tUsername     string\n\tPassword     string\n\tConnectionId string\n\n\tWidth  int\n\tHeight int\n\tDpi    int\n}\n\nfunc (s *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar up = websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tws, err := up.Upgrade(w, r, http.Header{\"Sec-Websocket-Protocol\": []string{\n\t\tr.Header.Get(\"Sec-Websocket-Protocol\"),\n\t}})\n\tif err != nil {\n\t\tlog.Errorf(\"upgrade error: %v\", err)\n\t\treturn\n\t}\n\n\tdefer ws.Close()\n\n\ttunnel, err := guac.NewGuacamoleTunnel(\n\t\ts.Host,\n\t\ts.Port,\n\t\ts.Username,\n\t\ts.Password,\n\t\ts.ConnectionId,\n\t\ts.Width,\n\t\ts.Height,\n\t\ts.Dpi,\n\t\ts.Session.GetClientSession().GetUserId(),\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"NewGuacamoleTunnel error: %v\", err)\n\t\treturn\n\t}\n\n\terr = tunnel.Start()\n\tif err != nil {\n\t\tlog.Errorf(\"Start error: %v\", err)\n\t\treturn\n\t}\n\n\tdone := make(chan bool, 4)\n\ttimer := time.NewTimer(time.Microsecond * 100)\n\tsetDone := func() {\n\t\tdone <- true\n\t}\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tins, err := tunnel.ReadOne()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\terr = ws.WriteMessage(websocket.TextMessage, []byte(ins.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd %s: %v\", ins.String(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\t\tdefer tunnel.Stop()\n\n\t\tfor {\n\t\t\t_, p, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Errorf(\"read message error %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\t_, err = tunnel.Write(p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tstop := make(chan bool)\n\tgo func() {\n\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t}\n\t\tdefer timer.Stop()\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tcase <-timer.C:\n\t\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttimer.Reset(time.Microsecond * 100)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\terr = tunnel.Wait()\n\t\tif err != nil && errors.Cause(err) != guac.TunnerClose {\n\t\t\tlog.Errorf(\"wait error: %v\", err)\n\t\t}\n\t}()\n\n\t<-done\n\tstop <- true\n\tlog.Infof(\"rdp %s@%s:%d complete\", s.Username, s.Host, s.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype session struct {\n\tSSession *session.SSession\n}\n\ntype RDPServer struct {\n\tSession     *session.SSession\n\tHost        string\n\tPort        int\n\tUsername    string\n\tPassword    string\n\tConnectionId string\n\tWidth       int\n\tHeight      int\n\tDpi         int\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc (s *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Upgrade error:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tguacConn, err := websocket.Dial(\"ws://guacamole-server:8080/guacamole\", \"\", r.URL.String())\n\tif err != nil {\n\t\tlog.Println(\"Guacamole connection error:\", err)\n\t\treturn\n\t}\n\tdefer guacConn.Close()\n\n\t// Authentication and tunnel setup (placeholder)\n\t// This would depend on Guacamole's API specifics\n\t// Example: sending login command\n\t// This is a simplified example and may require adjustments\n\tloginMsg := []byte(\"{\\\"command\\\":\\\"login\\\",\\\"username\\\":\\\"\" + s.Username + \"\\\",\\\"password\\\":\\\"\" + s.Password + \"\\\"}\")\n\tif err := guacConn.WriteMessage(websocket.TextMessage, loginMsg); err != nil {\n\t\tlog.Println(\"Login error:\", err)\n\t\treturn\n\t}\n\n\t// Relay messages between client and Guacamole\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Read error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := guacConn.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := guacConn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Guacamole read error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := conn.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a WebSocket proxy struct in Go that can handle WebSocket connections by forwarding messages between a client and a backend server.\n\nStruct Description: The `WebsocketProxy` struct is a reverse proxy for WebSocket connections. It upgrades incoming HTTP connections to WebSocket, connects to a backend WebSocket server, and forwards messages bidirectionally between the client and backend.\n\nFields:\n- Director: `func(incoming *http.Request, out http.Header)` - Optional function to modify the request headers before connecting to the backend.\n- Backend: `func(*http.Request) *url.URL` - Required function that returns the backend URL to connect to.\n- Upgrader: `*websocket.Upgrader` - Optional WebSocket upgrader configuration for client connections.\n- Dialer: `*websocket.Dialer` - Optional WebSocket dialer configuration for backend connections.\n\nMethods:\n- ServeHTTP: `(rw http.ResponseWriter, req *http.Request)` -> `None` - Main handler method that implements the http.Handler interface. It upgrades the client connection, connects to the backend, and sets up bidirectional message forwarding.\n  - Input Parameters:\n    - rw: `http.ResponseWriter` - The HTTP response writer\n    - req: `*http.Request` - The HTTP request\n  - Description: Handles the WebSocket proxy logic including connection upgrading, backend dialing, and message replication between client and backend.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n\t\tif prior, ok := req.Header[\"X-Forwarded-For\"]; ok {\n\t\t\tclientIP = strings.Join(prior, \", \") + \", \" + clientIP\n\t\t}\n\t\trequestHeader.Set(\"X-Forwarded-For\", clientIP)\n\t}\n\n\trequestHeader.Set(\"X-Forwarded-Proto\", \"http\")\n\tif req.TLS != nil {\n\t\trequestHeader.Set(\"X-Forwarded-Proto\", \"https\")\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\treplicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) {\n\t\tfor {\n\t\t\tmsgType, msg, err := src.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\t\tif e, ok := err.(*websocket.CloseError); ok {\n\t\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terrc <- err\n\t\t\t\tdst.WriteMessage(websocket.CloseMessage, m)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = dst.WriteMessage(msgType, msg)\n\t\t\tif err != nil {\n\t\t\t\terrc <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\tif e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure {\n\t\tlog.Printf(message, err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(*http.Request, http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tvar upgrader websocket.Upgrader\n\tif p.Upgrader != nil {\n\t\tupgrader = *p.Upgrader\n\t} else {\n\t\tupgrader = websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t}\n\t}\n\twsClient, err := upgrader.Upgrade(rw, req, nil)\n\tif err != nil {\n\t\thttp.Error(rw, \"WebSocket upgrade failed\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer wsClient.Close()\n\n\tbackendURL := p.Backend(req)\n\tif backendURL == nil {\n\t\thttp.Error(rw, \"Backend URL not provided\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar backendReq *http.Request\n\tif p.Director != nil {\n\t\treqCopy := req.Clone(req.Context())\n\t\theaders := http.Header{}\n\t\tp.Director(reqCopy, headers)\n\t\treqCopy.Header = headers\n\t\tbackendReq = reqCopy\n\t} else {\n\t\tbackendReq = req.Clone(req.Context())\n\t}\n\tbackendReq.URL = backendURL\n\n\tvar dialer *websocket.Dialer\n\tif p.Dialer != nil {\n\t\tdialer = p.Dialer\n\t} else {\n\t\tdialer = &websocket.Dialer{}\n\t}\n\twsBackend, _, err := dialer.Dial(backendURL.String(), backendReq.Header)\n\tif err != nil {\n\t\thttp.Error(rw, \"Failed to connect to backend\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer wsBackend.Close()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := wsClient.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := wsBackend.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := wsBackend.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := wsClient.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Implement a WebSocket server function in Go that handles client connections, manages online users, and periodically sends server statistics to connected clients.\n\nFunction Description: The `serverStream` function establishes a WebSocket connection with a client, registers the user in an online user tracking system, and continuously sends server statistics at regular intervals. It handles connection upgrades, user authentication, and graceful connection closure.\n\nInput:\n- `c *gin.Context`: Gin framework context object containing HTTP request information and writer for response\n\nOutput:\n- `any`: Placeholder return value (always nil in this implementation)\n- `error`: Error object indicating connection termination reason (wrapped in custom WsError type)\n\nThe function performs the following operations:\n1. Generates a unique connection ID\n2. Upgrades HTTP connection to WebSocket\n3. Extracts user IP and authentication info\n4. Registers user in online tracking system\n5. Periodically sends server statistics\n6. Handles connection cleanup on exit",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/url\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/nezhahq/nezha/model\"\n\t\"github.com/nezhahq/nezha/service/singleton\"\n)\n\nvar upgrader *websocket.Upgrader\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnId, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\tdefer conn.Close()\n\n\tuserIp := c.GetString(model.CtxKeyRealIPStr)\n\tif userIp == \"\" {\n\t\tuserIp = c.RemoteIP()\n\t}\n\n\tu, isMember := c.Get(model.CtxKeyAuthorizedUser)\n\tvar userId uint64\n\tif isMember {\n\t\tuserId = u.(*model.User).ID\n\t}\n\n\tsingleton.AddOnlineUser(connId, &model.OnlineUser{\n\t\tUserID:      userId,\n\t\tIP:          userIp,\n\t\tConnectedAt: time.Now(),\n\t\tConn:        conn,\n\t})\n\tdefer singleton.RemoveOnlineUser(connId)\n\n\tcount := 0\n\tfor {\n\t\tstat, err := getServerStat(count == 0, isMember)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.WriteMessage(websocket.TextMessage, stat); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tcount += 1\n\t\tif count%4 == 0 {\n\t\t\terr = conn.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\treturn nil, newWsError(\"\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\t\"strings\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WsError struct {\n\terror\n}\n\nfunc (e *WsError) Error() string {\n\treturn e.error.Error()\n}\n\ntype User struct {\n\tIP   string\n\tAuth string\n}\n\nvar onlineUsers = make(map[string]*User)\n\nfunc getServerStats() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"online_users\": len(onlineUsers),\n\t\t\"timestamp\":    time.Now().Unix(),\n\t}\n}\n\nfunc authenticateUser(c *gin.Context) (string, error) {\n\tauthHeader := c.GetHeader(\"Authorization\")\n\tif authHeader == \"\" {\n\t\treturn \"\", errors.New(\"missing authorization header\")\n\t}\n\tparts := strings.Split(authHeader, \" \")\n\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n\t\treturn \"\", errors.New(\"invalid authorization header\")\n\t}\n\ttoken := parts[1]\n\treturn token, nil\n}\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tvar upgrader = websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, &WsError{err}\n\t}\n\tdefer conn.Close()\n\n\tconnID := fmt.Sprintf(\"conn-%d\", time.Now().UnixNano())\n\tuserIP := c.ClientIP()\n\n\tauth, err := authenticateUser(c)\n\tif err != nil {\n\t\treturn nil, &WsError{err}\n\t}\n\n\tonlineUsers[connID] = &User{\n\t\tIP:   userIP,\n\t\tAuth: auth,\n\t}\n\n\tticker := time.NewTicker(5 * time.Second)\n\tgo func(conn *websocket.Conn) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tstats := getServerStats()\n\t\t\t\terr := conn.WriteJSON(stats)\n\t\t\t\tif err != nil {\n\t\t\t\t\tticker.Stop()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-conn.CloseRead():\n\t\t\t\tticker.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}(conn)\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tdelete(onlineUsers, connID)\n\t\t\treturn nil, &WsError{err}\n\t\t}\n\t\t// Process message if needed\n\t}\n\n\treturn nil, nil\n}"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The handler function manages WebSocket connections by upgrading HTTP requests, handling incoming messages, and maintaining the connection until closure. It includes error handling for connection issues and logs key events.\n\nInput:\n- w http.ResponseWriter: The HTTP response writer used to send responses\n- r *http.Request: The HTTP request containing connection details\n\nOutput: None (void function), but it performs the following actions:\n- Upgrades HTTP connection to WebSocket\n- Reads and echoes messages\n- Closes the connection when done or on error\n- Logs connection events and errors",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif netheader.IsKubeletProbe(r) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading websocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tlog.Println(\"Connection upgraded to WebSocket. Entering receive loop.\")\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Println(\"Client disconnected.\")\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Handler exiting on error:\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully received: %q\", message)\n\t\tif err = conn.WriteMessage(messageType, message); err != nil {\n\t\t\tlog.Println(\"Failed to write message:\", err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully wrote: %q\", message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tupgrader := &websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool { return true },\n\t}\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Upgrade error:\", err)\n\t\treturn\n\t}\n\tlog.Println(\"WebSocket connection established\")\n\tdefer conn.Close()\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Read error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tif err := conn.WriteMessage(websocket.TextMessage, message); err != nil {\n\t\t\tlog.Println(\"Write error:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.Println(\"WebSocket connection closed\")"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Implement a WebSocket handler for VNC (Virtual Network Computing) functionality that enables remote desktop interaction through a WebSocket connection, including image transmission, clipboard sharing, and input event handling.\n\nStruct Description: The VNC struct represents a VNC over WebSocket handler that manages the connection between a client and a remote VNC server, facilitating bidirectional communication for remote desktop operations.\n\nFields:\n- link: *network.Link - Represents the network link to the remote VNC server\n- chClipboard: chan string - Channel for transmitting clipboard content between client and server\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages the VNC session lifecycle\n- remoteRead: (ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) -> None - Processes incoming messages from the remote VNC server\n- localRead: (ctx context.Context, local *websocket.Conn, remote *conn.Conn) -> None - Handles messages received from the WebSocket client\n- mouseEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse movement and click events\n- keyboardEvent: (remote *conn.Conn, data []byte) -> None - Handles keyboard input events\n- cadEvent: (remote *conn.Conn) -> None - Manages Ctrl+Alt+Del special key combination\n- scrollEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse scroll wheel events",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/jpeg\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/runtime\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype VNC struct {\n\tlink         *network.Link\n\tchClipboard  chan string\n}\n\nfunc (v *VNC) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer local.Close()\n\tch := conn.ChanRead(id)\n\tdefer conn.SendDisconnect(v.link.target, v.link.id)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.remoteRead(ctx, ch, local)\n\t}()\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.localRead(ctx, local, conn)\n\t}()\n\twg.Wait()\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteRead\")\n\tfor {\n\t\tvar msg *network.Msg\n\t\tselect {\n\t\tcase msg = <-ch:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_vnc_image:\n\t\t\tdata, err := decodeImage(msg.GetVimg())\n\t\t\truntime.Assert(err)\n\t\t\treplyImage(local, msg.GetVimg(), data, len(msg.GetVimg().GetData()))\n\t\tcase network.Msg_vnc_clipboard:\n\t\t\tv.chClipboard <- msg.GetVclipboard()\n\t\tdefault:\n\t\t\tlogging.Error(\"on message: %s\", msg.GetXType().String())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *conn.Conn) {\n\tdefer utils.Recover(\"localRead\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"local read: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg struct {\n\t\t\tAction string `json:\"action\"`\n\t\t}\n\t\terr = json.Unmarshal(data, &msg)\n\t\tif err != nil {\n\t\t\tlogging.Error(\"unmarshal: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch msg.Action {\n\t\tcase \"mouse\":\n\t\t\tv.mouseEvent(remote, data)\n\t\tcase \"keyboard\":\n\t\t\tv.keyboardEvent(remote, data)\n\t\tcase \"cad\":\n\t\t\tv.cadEvent(remote)\n\t\tcase \"scroll\":\n\t\t\tv.scrollEvent(remote, data)\n\t\t}\n\t}\n}\n\nfunc decodeImage(data *network.VncImage) ([]byte, error) {\n\tswitch data.GetEncode() {\n\tcase network.VncImage_raw:\n\t\treturn data.GetData(), nil\n\tcase network.VncImage_jpeg:\n\t\timg, err := jpeg.Decode(bytes.NewReader(data.GetData()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trect := img.Bounds()\n\t\traw := image.NewRGBA(rect)\n\t\tdraw.Draw(raw, rect, img, rect.Min, draw.Src)\n\t\treturn raw.Pix, nil\n\tcase network.VncImage_png:\n\t}\n\treturn nil, errors.New(\"unsupported\")\n}\n\nfunc replyImage(conn *websocket.Conn, msg *network.VncImage, data []byte, srcSize int) {\n\tinfo := msg.GetXInfo()\n\tbuf := make([]byte, len(data)+28)\n\tbinary.BigEndian.PutUint32(buf, info.GetScreenWidth())\n\tbinary.BigEndian.PutUint32(buf[4:], info.GetScreenHeight())\n\tbinary.BigEndian.PutUint32(buf[8:], info.GetRectX())\n\tbinary.BigEndian.PutUint32(buf[12:], info.GetRectY())\n\tbinary.BigEndian.PutUint32(buf[16:], info.GetRectWidth())\n\tbinary.BigEndian.PutUint32(buf[20:], info.GetRectHeight())\n\tbinary.BigEndian.PutUint32(buf[24:], uint32(srcSize))\n\tcopy(buf[28:], data)\n\tconn.WriteMessage(websocket.BinaryMessage, buf)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/yourname/network\"\n)\n\ntype VNC struct {\n\tlink        *network.Link\n\tchClipboard chan string\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool { return true },\n}\n\nfunc (v *VNC) WS(conn *network.Conn, w http.ResponseWriter, r *http.Request) {\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer ws.Close()\n\n\tgo v.remoteRead(context.Background(), v.link.MsgChan(), ws)\n\tgo v.localRead(context.Background(), ws, v.link)\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase msg := <-ch:\n\t\t\tif msg.Type == \"image\" {\n\t\t\t\terr := local.WriteMessage(websocket.BinaryMessage, msg.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\t}\n\t\t\t} else if msg.Type == \"clipboard\" {\n\t\t\t\tv.chClipboard <- string(msg.Data)\n\t\t\t} else if msg.Type == \"mouse\" {\n\t\t\t\tv.mouseEvent(v.link, msg.Data)\n\t\t\t} else if msg.Type == \"keyboard\" {\n\t\t\t\tv.keyboardEvent(v.link, msg.Data)\n\t\t\t} else if msg.Type == \"cad\" {\n\t\t\t\tv.cadEvent(v.link)\n\t\t\t} else if msg.Type == \"scroll\" {\n\t\t\t\tv.scrollEvent(v.link, msg.Data)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *network.Conn) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\t_, message, err := local.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(message) > 0 {\n\t\t\t\tremote.WriteMessage(websocket.BinaryMessage, message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (v *VNC) mouseEvent(remote *network.Conn, data []byte) {\n\tremote.WriteMessage(websocket.BinaryMessage, data)\n}\n\nfunc (v *VNC) keyboardEvent(remote *network.Conn, data []byte) {\n\tremote.WriteMessage(websocket.BinaryMessage, data)\n}\n\nfunc (v *VNC) cadEvent(remote *network.Conn) {\n\tremote.WriteMessage(websocket.BinaryMessage, []byte{0x1d, 0x1c, 0x1b})\n}\n\nfunc (v *VNC) scrollEvent(remote *network.Conn, data []byte) {\n\tremote.WriteMessage(websocket.BinaryMessage, data)\n}"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Implement a WebSocket echo server function in Go that handles WebSocket connections, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The `echo` function upgrades an HTTP connection to a WebSocket connection, continuously reads messages from the client, and echoes them back. It handles connection errors and ensures proper cleanup by closing the connection when done.\n\nInput: \n- `ctx *gin.Context`: A Gin context object containing the HTTP request and response writer needed for WebSocket upgrade.\n\nOutput: \n- None (void function), but it performs the following operations:\n  - Upgrades the HTTP connection to WebSocket\n  - Reads and echoes messages until connection is closed\n  - Handles and logs errors\n  - Closes the WebSocket connection when done",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc echo(ctx *gin.Context) {\n\tw,r := ctx.Writer, ctx.Request\n\tc, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv:%s\", message)\n\t\terr = c.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "import (\n    \"log\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/websocket\"\n)\n\nfunc echo(ctx *gin.Context) {\n    upgrader := websocket.Upgrader{\n        CheckOrigin: func(r *http.Request) bool {\n            return true\n        },\n    }\n    conn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)\n    if err != nil {\n        log.Println(\"upgrade error:\", err)\n        return\n    }\n    defer conn.Close()\n    for {\n        messageType, message, err := conn.ReadMessage()\n        if err != nil {\n            log.Println(\"read error:\", err)\n            break\n        }\n        if err := conn.WriteMessage(messageType, message); err != nil {\n            log.Println(\"write error:\", err)\n            break\n        }\n    }\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests on the root path (\"/\") and returns a welcome message.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path. When accessed, it responds with a welcome message. The server listens on port 8080.\n\nInput: None (The HTTP server handles incoming requests automatically)\n\nOutput: None (The function runs indefinitely, serving HTTP responses to incoming requests)\n\n---\n\nNote: Since the reference code is at the package level (with `main` function) rather than a struct/class level, I've provided the function-level instruction format. The code demonstrates a complete executable program rather than a reusable struct/class component.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\tmyHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to my website!\")\n\t}\n\n\thttp.HandleFunc(\"/\", myHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to the server!\")\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a UDP client in Go that can send data to a specified server address and port using the net package's DialUDP function.\n\nStruct Description: The SocketBee struct represents a UDP client capable of sending data to a server. It embeds a bees.Bee for base functionality and includes a channel for event handling.\n\nFields:\neventChan: chan bees.Event - Channel for handling events within the bee framework.\n\nMethods:\nAction: [Name](action bees.Action) -> []bees.Placeholder - Handles the \"send\" action to transmit data to a UDP server. Takes an action object containing the target address, port, and data to send. Returns a list of placeholders (currently unused). Panics on errors during address resolution, connection establishment, or data transmission.",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/muesli/beehive/bees\"\n)\n\ntype SocketBee struct {\n\tbees.Bee\n\n\teventChan chan bees.Event\n}\n\nfunc (mod *SocketBee) Action(action bees.Action) []bees.Placeholder {\n\touts := []bees.Placeholder{}\n\n\tvar data string\n\tvar addr string\n\tvar port int\n\n\taction.Options.Bind(\"address\", &addr)\n\taction.Options.Bind(\"port\", &port)\n\taction.Options.Bind(\"data\", &data)\n\n\tswitch action.Name {\n\tcase \"send\":\n\t\tsa, err := net.ResolveUDPAddr(\"udp\", addr+\":\"+strconv.Itoa(port))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, sa)\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\t_, err = conn.Write([]byte(data))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\tdefault:\n\t\tpanic(\"Unknown action triggered in \" + mod.Name() + \": \" + action.Name)\n\t}\n\n\treturn outs\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"net\"\n\t\"bees\"\n)\n\ntype SocketBee struct {\n\tbees.Bee\n\teventChan chan bees.Event\n}\n\nfunc (sb *SocketBee) Action(action bees.Action) []bees.Placeholder {\n\thost := action.Address\n\tport := action.Port\n\tdata := action.Data\n\n\tfullAddr := net.JoinHostPort(host, port)\n\taddr, err := net.ResolveUDPAddr(\"udp\", fullAddr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(data))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn []bees.Placeholder{}\n}"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Implement a Go struct that tests the health of an NTP (Network Time Protocol) server by checking its stratum level through UDP communication.\n\nStruct Description: The NtpHealthTester struct is responsible for verifying the health of an NTP server by establishing a UDP connection, sending a query, and validating the server's response based on its stratum level. The struct includes methods for testing the server and providing a string representation of the maximum allowed stratum.\n\nFields:\nmaxStratum: int - The maximum acceptable stratum level for the NTP server to be considered healthy.\n\nMethods:\nTest: (ht *HealthTest) -> bool - Tests the health of an NTP server by sending a UDP packet and validating the response. Returns true if the server's stratum is within the acceptable range, false otherwise.\nString: () -> string - Returns a string representation of the maximum allowed stratum level.\nnewNtpHealthTester: (params map[string]interface{}, htp *HealthTestParameters) -> HealthTester - A constructor function that creates a new NtpHealthTester instance with the specified maximum stratum level.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (t *NtpHealthTester) Test(ht *HealthTest) bool {\n\tudpAddress, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(ht.ipAddress.String(), \"123\"))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdata := make([]byte, 48)\n\tdata[0] = 4<<3 | 3\n\n\tconn, err := net.DialUDP(\"udp\", nil, udpAddress)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(ht.timeout))\n\n\t_, err = conn.Read(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := data[1]\n\n\tif stratum == 0 || stratum > byte(t.maxStratum) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (t *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"%d\", t.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := 3\n\tif v, ok := params[\"max_stratum\"]; ok {\n\t\tmaxStratum = typeutil.ToInt(v)\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "type HealthTestParameters struct {\n    MaxStratum int\n}\n\ntype HealthTester interface {\n    Test() bool\n    String() string\n}\n\ntype NtpHealthTester struct {\n    maxStratum int\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n    return &NtpHealthTester{\n        maxStratum: htp.MaxStratum,\n    }\n}\n\nfunc (ht *NtpHealthTester) Test() bool {\n    conn, err := net.DialUDP(\"udp\", nil, &net.UDPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 123})\n    if err != nil {\n        return false\n    }\n    defer conn.Close()\n\n    packet := make([]byte, 48)\n    packet[0] = 0x1B // Mode 3 (client), version 3\n    _, err = conn.Write(packet)\n    if err != nil {\n        return false\n    }\n\n    buf := make([]byte, 48)\n    n, _, err := conn.ReadFromUDP(buf)\n    if err != nil {\n        return false\n    }\n\n    stratum := int((buf[0] >> 9) & 0x1F)\n    return stratum <= ht.maxStratum\n}\n\nfunc (ht *NtpHealthTester) String() string {\n    return fmt.Sprintf(\"Max Stratum: %d\", ht.maxStratum)\n}"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a function that establishes a UDP connection to a target server, sends a payload, and reads the server's response.\n\nFunction Description: The function `connectUDP` initiates a UDP connection to a specified target address, sends a given payload, and reads the response from the server. It handles local and remote address resolution, connection establishment, and error handling for network operations.\n\nInput: \n- `target` [string] - The target server address in the format \"host:port\" (e.g., \"127.0.0.1:8080\").\n- `payload` [string] - The data to be sent to the server.\n\nOutput: \n- None (prints the server's response to stdout). The function panics on errors during connection setup, sending, or receiving.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc connectUDP(target, payload string) {\n\tLocalAddr, err := net.ResolveUDPAddr(\"udp\", \":54321\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP local address on port 54321 %v\", err))\n\t}\n\tRemoteAddr, err := net.ResolveUDPAddr(\"udp\", target)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP remote address [%s] %v\", target, err))\n\t}\n\tconn, err := net.DialUDP(\"udp\", LocalAddr, RemoteAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to open connection to [%s] %v\", target, err))\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\t_, err = conn.Write([]byte(\"\\n\"))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tpanic(\"Failed to read from socket\")\n\t}\n\tfmt.Print(string(buf[:n]))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"strings\"\n)\n\nfunc connectUDP(target string, payload string) {\n    parts := strings.Split(target, \":\")\n    if len(parts) != 2 {\n        panic(\"invalid target format\")\n    }\n    host := parts[0]\n    port := parts[1]\n\n    addr, err := net.ResolveUDPAddr(\"udp\", host+\":\"+port)\n    if err != nil {\n        panic(err)\n    }\n\n    conn, err := net.DialUDP(\"udp\", nil, addr)\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    _, err = conn.Write([]byte(payload))\n    if err != nil {\n        panic(err)\n    }\n\n    buffer := make([]byte, 1024)\n    n, err := conn.Read(buffer)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Received: %s\\n\", buffer[:n])\n}"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: The task involves creating a DNS bootstrap resolver that can query DNS servers to resolve domain names to IP addresses using UDP protocol. The resolver should handle concurrent operations, retry failed queries, and manage connection lifecycle properly.\n\nStruct Description: The Bootstrap struct represents a DNS bootstrap resolver that maintains state for DNS queries, including target domain, server address, and query status. It handles concurrent resolution requests and manages connection retries.\n\nFields:\nfqdn: [string] - The fully qualified domain name to resolve\nport: [uint16] - The port number of the DNS server\nbootstrap: [*net.UDPAddr] - The UDP address of the DNS bootstrap server\nqt: [uint16] - The DNS query type (e.g., A or AAAA records)\nlogger: [*zap.Logger] - Logger for debugging and error reporting\nupdating: [atomic.Bool] - Atomic flag indicating if an update is in progress\nnextUpdate: [time.Time] - Timestamp for the next scheduled update\nreadyNotify: [chan struct{}] - Channel to notify when resolution is complete\nm: [sync.Mutex] - Mutex for protecting shared state\nready: [bool] - Flag indicating if resolution is complete\naddrStr: [string] - The resolved address string\n\nMethods:\nresolve: [Name](ctx context.Context, qt uint16) -> (netip.Addr, uint32, error) - Resolves the configured domain name to an IP address using the specified query type. Handles UDP communication with retries and timeout management. Returns the resolved address, its TTL, or an error.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/IrineSistiana/mosdns/v5/pkg/dnsutils\"\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn      string\n\tport      uint16\n\tbootstrap *net.UDPAddr\n\tqt        uint16\n\tlogger    *zap.Logger\n\n\tupdating   atomic.Bool\n\tnextUpdate time.Time\n\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (sp *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tconst edns0UdpSize = 1200\n\n\tq := new(dns.Msg)\n\tq.SetQuestion(sp.fqdn, qt)\n\tq.SetEdns0(edns0UdpSize, false)\n\n\tc, err := net.DialUDP(\"udp\", nil, sp.bootstrap)\n\tif err != nil {\n\t\treturn netip.Addr{}, 0, err\n\t}\n\tdefer c.Close()\n\n\twriteErrC := make(chan error, 1)\n\ttype res struct {\n\t\tresp *dns.Msg\n\t\terr  error\n\t}\n\treadResC := make(chan res, 1)\n\n\tcancelWrite := make(chan struct{})\n\tdefer close(cancelWrite)\n\tgo func() {\n\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\twriteErrC <- err\n\t\t\treturn\n\t\t}\n\n\t\tretryTicker := time.NewTicker(time.Second)\n\t\tdefer retryTicker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-cancelWrite:\n\t\t\t\treturn\n\t\t\tcase <-retryTicker.C:\n\t\t\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\t\t\twriteErrC <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tm, _, err := dnsutils.ReadMsgFromUDP(c, edns0UdpSize)\n\t\treadResC <- res{resp: m, err: err}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn netip.Addr{}, 0, context.Cause(ctx)\n\tcase err := <-writeErrC:\n\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to write query, %w\", err)\n\tcase r := <-readResC:\n\t\tresp := r.resp\n\t\terr := r.err\n\t\tif err != nil {\n\t\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to read resp, %w\", err)\n\t\t}\n\n\t\tfor _, v := range resp.Answer {\n\t\t\tvar ip net.IP\n\t\t\tvar ttl uint32\n\t\t\tswitch rr := v.(type) {\n\t\t\tcase *dns.A:\n\t\t\t\tip = rr.A\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tcase *dns.AAAA:\n\t\t\t\tip = rr.AAAA\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr, ok := netip.AddrFromSlice(ip)\n\t\t\tif ok {\n\t\t\t\treturn addr, ttl, nil\n\t\t\t}\n\t\t}\n\n\t\treturn netip.Addr{}, 0, errNoAddrInResp\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/dns\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn       string\n\tport       uint16\n\tbootstrap  *net.UDPAddr\n\tqt         uint16\n\tlogger     *zap.Logger\n\tupdating   atomic.Bool\n\tnextUpdate time.Time\n\treadyNotify chan struct{}\n\tm          sync.Mutex\n\tready      bool\n\taddrStr    string\n}\n\nfunc (b *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tb.m.Lock()\n\tif b.ready {\n\t\tb.m.Unlock()\n\t\treturn netip.AddrFromString(b.addrStr), 0, nil\n\t}\n\tif b.updating.Load() {\n\t\tb.m.Unlock()\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn netip.Addr{}, 0, ctx.Err()\n\t\tcase <-b.readyNotify:\n\t\t\tb.m.Lock()\n\t\t\tdefer b.m.Unlock()\n\t\t\tif b.ready {\n\t\t\t\treturn netip.AddrFromString(b.addrStr), 0, nil\n\t\t\t}\n\t\t}\n\t}\n\tb.updating.Store(true)\n\tb.m.Unlock()\n\n\tvar maxRetries = 3\n\tvar retryDelay = time.Second\n\tvar err error\n\tfor i := 0; i < maxRetries; i++ {\n\t\tconn, err := net.DialUDP(\"udp\", nil, b.bootstrap)\n\t\tif err != nil {\n\t\t\tb.logger.Error(\"Failed to dial UDP\", zap.Error(err))\n\t\t\treturn netip.Addr{}, 0, err\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tdeadline, _ := ctx.Deadline()\n\t\tconn.SetDeadline(deadline)\n\n\t\tmsg := &dns.Msg{\n\t\t\tMsgHdr: dns.MsgHdr{\n\t\t\t\tRecursionDesired: true,\n\t\t\t},\n\t\t\tQd: []dns.Question{\n\t\t\t\t{Name: b.fqdn, Qtype: qt, Qclass: dns.ClassINET},\n\t\t\t},\n\t\t}\n\n\t\tif err := msg.WriteTo(conn); err != nil {\n\t\t\tb.logger.Error(\"Failed to write DNS query\", zap.Error(err))\n\t\t\tif i < maxRetries-1 {\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\tretryDelay *= 2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tresp := &dns.Msg{}\n\t\tif _, _, err := resp.ReadFrom(conn); err != nil {\n\t\t\tb.logger.Error(\"Failed to read DNS response\", zap.Error(err))\n\t\t\tif i < maxRetries-1 {\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\tretryDelay *= 2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(resp.Answer) == 0 {\n\t\t\tb.logger.Error(\"No answer in DNS response\")\n\t\t\tif i < maxRetries-1 {\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\tretryDelay *= 2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tans := resp.Answer[0]\n\t\tif ans.Header().Rrtype != qt {\n\t\t\tb.logger.Error(\"Unexpected record type in response\",\n\t\t\t\tzap.Uint16(\"expected\", qt),\n\t\t\t\tzap.Uint16(\"got\", ans.Header().Rrtype))\n\t\t\tif i < maxRetries-1 {\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\tretryDelay *= 2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch ans := ans.(type) {\n\t\tcase *dns.A:\n\t\t\taddr := netip.AddrFromSlice(ans.A)\n\t\t\tttl := uint32(ans.Header().Ttl)\n\t\t\tb.m.Lock()\n\t\t\tdefer b.m.Unlock()\n\t\t\tb.addrStr = addr.String()\n\t\t\tb.ready = true\n\t\t\tclose(b.readyNotify)\n\t\t\treturn addr, ttl, nil\n\t\tcase *dns.AAAA:\n\t\t\taddr := netip.AddrFromSlice(ans.Addr)\n\t\t\tttl := uint32(ans.Header().Ttl)\n\t\t\tb.m.Lock()\n\t\t\tdefer b.m.Unlock()\n\t\t\tb.addrStr = addr.String()\n\t\t\tb.ready = true\n\t\t\tclose(b.readyNotify)\n\t\t\treturn addr, ttl, nil\n\t\tdefault:\n\t\t\tb.logger.Error(\"Unsupported record type in response\",\n\t\t\t\tzap.Uint16(\"expected\", qt),\n\t\t\t\tzap.Uint16(\"got\", ans.Header().Rrtype))\n\t\t\tif i < maxRetries-1 {\n\t\t\t\ttime.Sleep(retryDelay)\n\t\t\t\tretryDelay *= 2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tb.logger.Error(\"Failed to resolve after retries\")\n\treturn netip.Addr{}, 0, fmt.Errorf(\"resolve failed after retries\")\n}"
  },
  {
    "Task_id": 368,
    "Instruction": "Task Description: Implement a UDP client in Go that communicates with a NAT-PMP (Port Mapping Protocol) gateway, handling retries and timeouts for reliable communication.\n\nStruct Description: The `network` struct represents a network connection to a NAT-PMP gateway, maintaining the gateway IP address and providing a method to send requests and receive responses.\n\nFields:\n- gateway: net.IP - The IP address of the NAT-PMP gateway\n\nMethods:\n- call: (msg []byte, timeout time.Duration) -> ([]byte, error) - Sends a UDP message to the NAT-PMP gateway and waits for a response. Implements exponential backoff retry logic with configurable timeout. Returns the response bytes or an error if communication fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nconst nAT_PMP_PORT = 5351\nconst nAT_TRIES = 9\nconst nAT_INITIAL_MS = 250\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) (result []byte, err error) {\n\tvar server net.UDPAddr\n\tserver.IP = n.gateway\n\tserver.Port = nAT_PMP_PORT\n\tconn, err := net.DialUDP(\"udp\", nil, &server)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tresult = make([]byte, 16)\n\n\tvar finalTimeout time.Time\n\tif timeout != 0 {\n\t\tfinalTimeout = time.Now().Add(timeout)\n\t}\n\n\tneedNewDeadline := true\n\n\tvar tries uint\n\tfor tries = 0; (tries < nAT_TRIES && finalTimeout.IsZero()) || time.Now().Before(finalTimeout); {\n\t\tif needNewDeadline {\n\t\t\tnextDeadline := time.Now().Add((nAT_INITIAL_MS << tries) * time.Millisecond)\n\t\t\terr = conn.SetDeadline(minTime(nextDeadline, finalTimeout))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tneedNewDeadline = false\n\t\t}\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tvar bytesRead int\n\t\tvar remoteAddr *net.UDPAddr\n\t\tbytesRead, remoteAddr, err = conn.ReadFromUDP(result)\n\t\tif err != nil {\n\t\t\tif err.(net.Error).Timeout() {\n\t\t\t\ttries++\n\t\t\t\tneedNewDeadline = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif !remoteAddr.IP.Equal(n.gateway) {\n\t\t\tcontinue\n\t\t}\n\t\tif bytesRead < len(result) {\n\t\t\tresult = result[:bytesRead]\n\t\t}\n\t\treturn\n\t}\n\terr = fmt.Errorf(\"Timed out trying to contact gateway\")\n\treturn\n}\n\nfunc minTime(a, b time.Time) time.Time {\n\tif a.IsZero() {\n\t\treturn b\n\t}\n\tif b.IsZero() {\n\t\treturn a\n\t}\n\tif a.Before(b) {\n\t\treturn a\n\t}\n\treturn b\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) ([]byte, error) {\n\taddr := &net.UDPAddr{\n\t\tIP:   n.gateway,\n\t\tPort: 5351,\n\t}\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tmaxRetries := 5\n\tbackoffDelay := 100 * time.Millisecond\n\tfor i := 0; i < maxRetries; i++ {\n\t\t_, err := conn.Write(msg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconn.SetReadDeadline(time.Now().Add(timeout))\n\t\tbuf := make([]byte, 1024)\n\t\tnRead, _, err := conn.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tif opErr, ok := err.(*net.OpError); ok && opErr.Timeout() {\n\t\t\t\ttime.Sleep(backoffDelay * time.Duration(1<<i))\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn buf[:nRead], nil\n\t}\n\treturn nil, fmt.Errorf(\"exceeded maximum retries\")\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that serves a health check endpoint and starts listening on a specified host and port.\n\nFunction Description: The function `startHTTPServer` initializes and starts an HTTP server with a single `/healthz` endpoint that returns a 200 OK status and \"ok\" response. The server listens on the IP address and port specified by the input parameters.\n\nInput: \n- `argHealthzIP` (string pointer): The IP address on which the server should listen.\n- `argHealthzPort` (int pointer): The port number on which the server should listen.\n\nOutput: \n- None (the function runs indefinitely or until an error occurs, in which case it logs the error and exits).",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc startHTTPServer() {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"ok\"))\n\t})\n\n\tklog.Info(\"Starting eventer http service\")\n\tklog.Fatal(http.ListenAndServe(net.JoinHostPort(*argHealthzIP, strconv.Itoa(int(*argHealthzPort))), nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n)\n\nfunc startHTTPServer(argHealthzIP *string, argHealthzPort *int) {\n    ip := *argHealthzIP\n    port := *argHealthzPort\n    address := fmt.Sprintf(\"%s:%d\", ip, port)\n\n    http.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(\"ok\"))\n    })\n\n    log.Println(\"Starting HTTP server on\", address)\n    if err := http.ListenAndServe(address, nil); err != nil {\n        log.Fatalf(\"Failed to start server: %v\", err)\n    }\n}"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, processes incoming messages using ROT13 cipher, and sends the transformed messages back to the client.\n\nFunction Description: The function initializes a UDP server that continuously listens for incoming datagrams on a specified port. For each received message, it applies the ROT13 cipher transformation and sends the result back to the originating client. The server handles network errors and cleans up resources properly on exit.\n\nInput:\n- port: int - The UDP port number to listen on (passed as a pointer in the original code)\n\nOutput: None (the function runs indefinitely until terminated or an unrecoverable error occurs)\n\nNote: The function uses external packages for logging (github.com/enfein/mieru/v3/pkg/log) and ROT13 transformation (github.com/enfein/mieru/v3/pkg/testtool). The main processing loop includes error handling for network operations and message processing.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n)\nfunc main() {\n\taddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.Itoa(*port))\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ResolveUDPAddr() failed: %v\", err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ListenUDP() failed: %v\", err)\n\t}\n\tlog.Infof(\"UDP server is initialized, listening to %s\", addr.String())\n\tdefer conn.Close()\n\tbuf := make([]byte, 1500)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Read() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tout, err := testtool.TestHelperRot13(buf[:n])\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"rot13() failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err = conn.WriteToUDP(out, addr); err != nil {\n\t\t\tlog.Errorf(\"Write() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n\t\"net\"\n)\n\nfunc StartUDPServer(port *int) {\n\taddr := &net.UDPAddr{Port: *port, IP: net.ParseIP(\"0.0.0.0\")}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Error(\"Failed to start UDP server: %v\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, clientAddr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error reading from UDP: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tmessage := string(buffer[:n])\n\t\ttransformed := testtool.Rot13(message)\n\t\t_, err = conn.WriteToUDP([]byte(transformed), clientAddr)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error writing to UDP: %v\", err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, receives messages from clients, and echoes them back to the sender.\n\nFunction Description: The function sets up a UDP server that binds to a given port, continuously listens for incoming messages, and responds by sending the received message back to the client. It handles network errors gracefully and ensures resources are properly cleaned up.\n\nInput: \n- port [string] - The port number on which the UDP server should listen (e.g., \":10002\")\n\nOutput: \n- None (The function runs indefinitely until interrupted)\n- Error messages are printed to stdout if any occur during setup or operation\n\nNote: The function does not return any values but prints status and error messages to stdout. It runs in an infinite loop to handle continuous incoming UDP messages.\n\nThe function performs the following key operations:\n1. Resolves the UDP address using the provided port\n2. Creates and binds a UDP listener\n3. Sets up deferred cleanup for the connection\n4. Enters a loop to read incoming messages and echo them back\n5. Handles and reports any network errors that occur",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tserverType := strings.ToLower(os.Getenv(\"serverType\"))\n\n\tif serverType == \"udp\" {\n\t\tServerAddr, err := net.ResolveUDPAddr(\"udp\", \":10002\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Started UDP server on port 10002\")\n\n\t\tServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tdefer ServerConn.Close()\n\n\t\tbuf := make([]byte, 1024)\n\n\t\tfor {\n\t\t\tn, addr, err := ServerConn.ReadFromUDP(buf)\n\t\t\tfmt.Printf(\"received: %s from: %s\\n\", string(buf[0:n]), addr)\n\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"error: \", err)\n\t\t\t}\n\n\t\t\tServerConn.WriteTo(buf[0:n], addr)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Fprintf(os.Stderr, \"Usage: %s <port>\\n\", os.Args[0])\n\t\tos.Exit(1)\n\t}\n\tport := os.Args[1]\n\n\taddr, err := net.ResolveUDPAddr(\"udp\", port)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to resolve address: %v\\n\", err)\n\t\treturn\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to listen on port: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfmt.Printf(\"UDP server started on port %s\\n\", port)\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, clientAddr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading from client: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t_, writeErr := conn.WriteToUDP(buffer[:n], clientAddr)\n\t\tif writeErr != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error writing to client: %v\\n\", writeErr)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Implement a WebSocket proxy struct in Go that can handle bidirectional communication between a client and a backend server, including connection upgrading, message replication, and error handling.\n\nStruct Description: The WebsocketProxy struct acts as a reverse proxy for WebSocket connections, forwarding messages between clients and backend servers while handling connection upgrades and error scenarios.\n\nFields:\n\nDirector: func(*http.Request, http.Header) - A function that can modify the outgoing request headers before connecting to the backend.\nBackend: func(*http.Request) *url.URL - A function that returns the backend URL to connect to.\nUpgrader: *websocket.Upgrader - Configures the WebSocket connection upgrade from HTTP.\nDialer: *websocket.Dialer - Configures how to dial the backend WebSocket connection.\n\nMethods:\n\nServeHTTP: (http.ResponseWriter, *http.Request) -> None - The main handler method that:\n  1. Determines the backend URL\n  2. Establishes connection to backend\n  3. Upgrades client connection\n  4. Sets up bidirectional message replication\n  5. Handles ping/pong messages\n  6. Manages connection errors and closures\n\nreplicateWebsocketConn: (*websocket.Conn, *websocket.Conn, chan error) -> None - A helper method that:\n  1. Continuously reads messages from source connection\n  2. Forwards them to destination connection\n  3. Handles connection errors and closure messages\n  4. Reports errors through the provided channel",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/samber/lo\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tconnPub.SetPingHandler(func(appData string) error {\n\t\terr := connBackend.WriteControl(websocket.PingMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = connPub.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif errors.Is(err, websocket.ErrCloseSent) {\n\t\t\treturn nil\n\t\t} else if e, ok := lo.ErrorsAs[net.Error](err); ok && e.Timeout() {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\n\tvar closeError *websocket.CloseError\n\tif ok := errors.As(err, &closeError); !ok || (closeError != nil && closeError.Code == websocket.CloseAbnormalClosure) {\n\t\tlog.Printf(message, err)\n\t}\n}\n\nfunc replicateWebsocketConn(dst, src *websocket.Conn, errc chan error) {\n\tfor {\n\t\tmsgType, msg, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\tif e, ok := lo.ErrorsAs[*websocket.CloseError](err); ok && e != nil {\n\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t\terrc <- err\n\t\t\t_ = dst.WriteMessage(websocket.CloseMessage, m)\n\t\t\tbreak\n\t\t}\n\t\terr = dst.WriteMessage(msgType, msg)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "right_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector  func(*http.Request, http.Header)\n\tBackend   func(*http.Request) *url.URL\n\tUpgrader  *websocket.Upgrader\n\tDialer    *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tbackendURL := p.Backend(r)\n\treq, _ := http.NewRequest(\"GET\", backendURL.String(), nil)\n\tp.Director(r, req.Header)\n\tbackendConn, _, err := p.Dialer.Dial(backendURL.String(), req.Header)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to connect to backend\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer backendConn.Close()\n\tclientConn, err := p.Upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to upgrade client connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer clientConn.Close()\n\terrChan := make(chan error, 2)\n\tgo p.replicateWebsocketConn(clientConn, backendConn, errChan)\n\tgo p.replicateWebsocketConn(backendConn, clientConn, errChan)\n\tfor range errChan {\n\t\t// Handle error\n\t}\n}\n\nfunc (p *WebsocketProxy) replicateWebsocketConn(src *websocket.Conn, dst *websocket.Conn, errChan chan error) {\n\tfor {\n\t\tmessageType, message, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, 1001, 1002, 1008, 1009, 1011) {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == io.EOF {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tif err := dst.WriteMessage(messageType, message); err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and returns a simple text response.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" message to the response writer. The `main` function sets up the HTTP server by registering the handler and starting the server on port 8080.\n\nInput: \n- `w http.ResponseWriter`: Used to write the HTTP response.\n- `r *http.Request`: Contains information about the incoming HTTP request.\n\nOutput: \n- The `handler` function writes \"Hello World, I'm Golang!\" to the response writer (`w`).\n- The `main` function starts an HTTP server that listens on port 8080 and serves the response from the `handler` function.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Go function that securely copies a password to the system clipboard using osascript (AppleScript) via a pipe, ensuring the password is handled safely and the clipboard is cleared after use.\n\nFunction Description: The function `copyViaOsascript` uses an inter-process communication mechanism (pipe) to securely pass a password to the AppleScript command `osascript`, which then sets the password in the system clipboard. The function ensures proper resource cleanup and checks for successful execution.\n\nInput:\n- `ctx context.Context`: Context for managing the command's lifecycle and cancellation.\n- `password string`: The password string to be copied to the clipboard.\n\nOutput:\n- `error`: Returns an error if any step fails (pipe creation, command execution, or clipboard setting). Returns nil on success.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\targs := []string{\n\t\t\"-e\", `use framework \"Foundation\"`,\n\t\t\"-e\", \"use scripting additions\",\n\t\t\"-e\", \"set type to current application's NSPasteboardTypeString\",\n\t\t\"-e\", \"set pb to current application's NSPasteboard's generalPasteboard()\",\n\t\t\"-e\", \"pb's clearContents()\",\n\t\t\"-e\", `pb's setString:\"\" forType:\"org.nspasteboard.ConcealedType\"`,\n\t\t\"-e\", `pb's setString:(do shell script \"cat 0<&3\") forType:type`,\n\t}\n\tcmd := exec.CommandContext(ctx, \"osascript\", args...)\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.ExtraFiles = []*os.File{r}\n\tgo func() {\n\t\tdefer w.Close()\n\t\t_, _ = io.WriteString(w, password)\n\t}()\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(out) != \"true\\n\" {\n\t\treturn fmt.Errorf(\"osascript failed to set password: %s\", string(out))\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "right_result": "func copyViaOsascript(ctx context.Context, password string) error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\tdefer w.Close()\n\n\tcmdSet := exec.CommandContext(ctx, \"osascript\", \"-e\", \"tell application \\\"System Events\\\" to set the clipboard to (read from stdin)\")\n\tcmdSet.Stdin = r\n\tcmdSet.Stdout = os.Stderr\n\tcmdSet.Stderr = os.Stderr\n\n\tif err := cmdSet.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tcmdSet.Process.Kill()\n\t\treturn ctx.Err()\n\tdefault:\n\t}\n\n\tif _, err := w.Write([]byte(password)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := w.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tcmdSet.Process.Kill()\n\t\treturn ctx.Err()\n\tdefault:\n\t}\n\n\tif err := cmdSet.Wait(); err != nil {\n\t\treturn err\n\t}\n\n\tcmdClear := exec.CommandContext(ctx, \"osascript\", \"-e\", \"tell application \\\"System Events\\\" to set the clipboard to \\\"\\\"\")\n\tif err := cmdClear.Run(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Go struct that implements a log retrieval mechanism using pipes for inter-process communication, allowing for reading logs from a file and writing them to a pipe for consumption by another process.\n\nStruct Description: The `logRetriever` struct provides a way to read logs from a file and write them to a pipe, implementing `io.ReadCloser` for standard read and close operations. It also includes methods to manage the pipe's writer and output.\n\nFields:\n- reader: *os.File - The read end of the pipe used to consume log data.\n- writer: *os.File - The write end of the pipe used to send log data.\n- output: *fileCloner - A helper component that clones the writer's output to a log file.\n\nMethods:\n- newlogRetriever: (logFile string) -> (*logRetriever, error) - Initializes a new logRetriever instance, creates a pipe, and sets up file cloning. If the log file exists, copies its contents to the pipe.\n- Read: (p []byte) -> (int, error) - Implements io.Reader to read data from the pipe's reader.\n- CloseWriter: () -> error - Closes the pipe's writer to signal the end of data transmission.\n- Close: () -> error - Implements io.Closer to close the pipe's reader and release resources.\n- Opt: () -> cio.Opt - Returns an option for configuring IO streams, using a null reader and the output cloner.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (l *logRetriever, err error) {\n\tl = &logRetriever{}\n\tif l.reader, l.writer, err = os.Pipe(); err != nil {\n\t\treturn\n\t}\n\n\tif l.output, err = newFileCloner(l.writer, logFile); err != nil {\n\t\treturn\n\t}\n\n\tif util.FileExists(logFile) {\n\t\tvar reader io.ReadCloser\n\t\tif reader, err = os.Open(logFile); err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer util.DeferErr(&err, reader.Close)\n\n\t\tif _, err = io.Copy(l.writer, reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nvar _ io.ReadCloser = &logRetriever{}\n\nfunc (l *logRetriever) Opt() cio.Opt {\n\treturn cio.WithStreams(&nullReader{}, l.output, l.output)\n}\n\nfunc (l *logRetriever) Read(p []byte) (n int, err error) {\n\treturn l.reader.Read(p)\n}\n\nfunc (l *logRetriever) CloseWriter() (err error) {\n\treturn l.writer.Close()\n}\n\nfunc (l *logRetriever) Close() error {\n\treturn l.reader.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "right_result": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype fileCloner struct {\n\twriter *os.File\n}\n\nfunc (fc *fileCloner) Write(p []byte) (int, error) {\n\treturn fc.writer.Write(p)\n}\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (*logRetriever, error) {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err := os.Stat(logFile); err == nil {\n\t\tsrcFile, err := os.Open(logFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer srcFile.Close()\n\t\t_, err = io.Copy(writer, srcFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\toutput := &fileCloner{writer: writer}\n\n\treturn &logRetriever{\n\t\treader:  reader,\n\t\twriter:  writer,\n\t\toutput:  output,\n\t}, nil\n}\n\nfunc (lr *logRetriever) Read(p []byte) (int, error) {\n\treturn lr.reader.Read(p)\n}\n\nfunc (lr *logRetriever) CloseWriter() error {\n\treturn lr.writer.Close()\n}\n\nfunc (lr *logRetriever) Close() error {\n\treturn lr.reader.Close()\n}\n\nfunc (lr *logRetriever) Opt() struct {\n\tReader   io.Reader\n\tCloner   io.Writer\n} {\n\treturn struct {\n\t\tReader   io.Reader\n\t\tCloner   io.Writer\n\t}{\n\t\tReader:   io.NopCloser(nil),\n\t\tCloner:   lr.output,\n\t}\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Go function that implements a basic HTTP server which responds to all requests with a repeated character response of specified size.\n\nFunction Description: The function should start an HTTP server on a specified port that handles all incoming requests by writing a response consisting of a repeated character ('a') with a length determined by the responseSize parameter. The server should log any errors that occur during writing or server startup.\n\nInput: \n- serverPort: string - The port number on which the HTTP server should listen (e.g., \"8080\")\n- responseSize: int - The size/length of the response to be generated (number of 'a' characters to repeat)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are logged to stdout if any occur during server operation\n\nNote: The function doesn't explicitly return values but runs an HTTP server that handles requests and may log errors. The response is written directly to the http.ResponseWriter for each incoming request.\n\nExample usage:\n```go\nfunc main() {\n    startHTTPServer(\"8080\", 1024)  // Starts server on port 8080 with 1024-byte responses\n}\n```",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresponse := bytes.Repeat([]byte(\"a\"), int(*responseSize))\n\taddr := \"localhost:\" + *serverPort\n\tlog.Println(\"Starting HTTP server on:\", addr)\n\tlserr := http.ListenAndServe(addr, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, werr := w.Write(response)\n\t\tif werr != nil {\n\t\t\tlog.Println(werr)\n\t\t}\n\t}))\n\tif lserr != nil {\n\t\tlog.Println(lserr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc startHTTPServer(serverPort string, responseSize int) {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata := strings.Repeat(\"a\", responseSize)\n\t\tif _, err := w.Write([]byte(data)); err != nil {\n\t\t\tlog.Println(\"Error writing response:\", err)\n\t\t}\n\t})\n\terr := http.ListenAndServe(\":\"+serverPort, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error starting server:\", err)\n\t}\n}\n\nfunc main() {\n\tstartHTTPServer(\"8080\", 1024)\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Go HTTP server that handles incoming requests, processes JSON payloads, and returns a modified response with a large body and custom headers.\n\nFunction Description: The main function sets up an HTTP server that listens on port 10000. It defines a handler for the root path (\"/\") that:\n1. Reads and closes the request body\n2. Unmarshals the JSON body into a contextEntity struct\n3. Modifies the response status, headers, and body\n4. Marshals the modified contextEntity back to JSON and sends it as the response\n5. Handles errors appropriately with status codes\n\nInput: \n- HTTP requests with JSON body containing a contextEntity structure\n- The handler expects the request body to be a valid JSON representation of contextEntity\n\nOutput:\n- HTTP responses with:\n  - Status 200 on success with modified JSON payload\n  - Status 400 for bad requests (invalid JSON or read errors)\n  - Status 500 for internal server errors (marshaling failures)\n- Response includes:\n  - Custom header \"X-Remote-Name: G.O.O.D\"\n  - Large body (64KB of '-' characters)\n  - Modified contextEntity structure as JSON",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlargeBodySize := 64 * 1024\n\tlargeBody := bytes.Repeat([]byte(`-`), largeBodySize)\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer r.Body.Close()\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity := &contextEntity{}\n\t\terr = json.Unmarshal(body, ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity.Response.StatusCode = 200\n\t\tctxEntity.Response.Header.Add(\"X-Remote-Name\", \"G.O.O.D\")\n\t\tctxEntity.Response.Body = largeBody\n\n\t\tbuff, err := json.Marshal(ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buff)\n\t})\n\n\thttp.ListenAndServe(\":10000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype contextEntity struct {\n\tName string\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Read request body\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tdefer r.Body.Close()\n\n\t\t// Unmarshal JSON\n\t\tvar ce contextEntity\n\t\tif err := json.Unmarshal(body, &ce); err != nil {\n\t\t\thttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Modify response headers\n\t\tw.Header().Set(\"X-Remote-Name\", \"G.O.O.D\")\n\t\tw.WriteHeader(http.StatusOK)\n\n\t\t// Modify contextEntity\n\t\tce.Name = \"G.O.O.D\"\n\n\t\t// Generate large body of '-' characters (64KB)\n\t\tlargeBody := strings.Repeat(\"-\", 64*1024)\n\n\t\t// Marshal modified contextEntity\n\t\tmodifiedJSON, err := json.Marshal(ce)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write large body and modified JSON to response\n\t\t_, _ = fmt.Fprintf(w, \"%s\\n%s\", largeBody, modifiedJSON)\n\t})\n\n\tlog.Println(\"Server started on :10000\")\n\t_ = http.ListenAndServe(\":10000\", nil)\n}"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a POST request and serves an HTML form for file submission.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it serves an HTML form (rendered from a template). For POST requests, it processes file uploads by saving the uploaded file to the filesystem.\n\nInput:\n- None (The function takes no direct input parameters, but handles HTTP requests with the following characteristics:\n  - GET requests to \"/\" trigger form rendering\n  - POST requests to \"/\" with a \"file\" form field trigger file upload processing)\n\nOutput:\n- None (The function doesn't return any value, but has the following side effects:\n  - Starts an HTTP server on port 9000\n  - Writes responses to http.ResponseWriter\n  - Creates files on the filesystem for successful uploads)",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\ttpl, err := template.ParseFiles(\"form.gohtml\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tif req.Method == \"POST\" {\n\t\t\tsrc, _, err := req.FormFile(\"file\")\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tdefer src.Close()\n\n\t\t\tdst, err := os.Create(filepath.Join(\"./\", \"file.txt\"))\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dst.Close()\n\n\t\t\tio.Copy(dst, src)\n\t\t}\n\n\t\terr = tpl.Execute(res, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"html/template\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\ttmpl := template.Must(template.New(\"form\").Parse(`<html><body><form method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form></body></html>`))\n\t\t\ttmpl.Execute(w, nil)\n\t\t} else {\n\t\t\tr.ParseMultipartForm(10 << 20)\n\t\t\tfile, handler, err := r.FormFile(\"file\")\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tf, err := os.Create(handler.Filename)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Error creating file: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\t_, err = io.Copy(f, file)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Error writing file: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Fprintf(w, \"File uploaded successfully\")\n\t\t}\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a simple HTTP server in Go that sets a cookie when the root path (\"/\") is accessed.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. When a request is made to the root path, it responds by setting a cookie named \"my-cookie\" with the value \"some value\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\thttp.SetCookie(res, &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"some value\",\n\t\t})\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie := &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"some value\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t\tfmt.Fprintf(w, \"Cookie set!\")\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a simple HTTP server in Go that responds to requests with a greeting message containing the value of the \"AUTHOR\" environment variable.\n\nFunction Description: The main function sets up a basic HTTP server with a single route (\"/\") that responds to all HTTP requests. The response is a plain text message combining \"hello \" with the value of the \"AUTHOR\" environment variable. The server listens on a specified port.\n\nInput: \n- *addr (string pointer): A command-line flag specifying the server address and port to listen on (e.g., \":8080\")\n\nOutput: \n- None (The function runs indefinitely, serving HTTP requests until interrupted)\n- For each HTTP request to \"/\", outputs \"hello [AUTHOR]\" as the response body\n\nNote: The function does not explicitly return any values but writes to the http.ResponseWriter for each incoming request. The server continues running until terminated.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\nfunc main() {\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello \"+os.Getenv(\"AUTHOR\"))\n\t})\n\thttp.ListenAndServe(*addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar addr string\n\tflag.StringVar(&addr, \"addr\", \":8080\", \"server address and port\")\n\tflag.Parse()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tauthor := os.Getenv(\"AUTHOR\")\n\t\tfmt.Fprintf(w, \"hello %s\", author)\n\t})\n\n\tfmt.Printf(\"Server started on %s\\n\", addr)\n\thttp.ListenAndServe(addr, nil)"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Go HTTP server that serves as an interface for running and displaying scorecard results for GitHub repositories. The server should handle requests, process repository information, execute scorecard checks, and return results in either JSON or HTML format based on the request's content type.\n\nFunction Description: The `serveCmd` function creates and configures a Cobra command that starts an HTTP server. The server listens for requests, processes GitHub repository URLs, runs scorecard checks on those repositories, and returns the results. The function handles template parsing, route registration, and server startup.\n\nInput: \n- `o *options.Options`: A pointer to an options struct containing configuration settings like log level and commit depth\n\nOutput: \n- `*cobra.Command`: Returns a configured Cobra command that can be executed to start the HTTP server\n\nThe function does not explicitly return any values from its Run method, but it does:\n1. Write HTTP responses to the client (through http.ResponseWriter)\n2. Output logs through the logger\n3. May panic in case of critical errors during template parsing or server startup",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/ossf/scorecard/v5/clients/githubrepo\"\n\t\"github.com/ossf/scorecard/v5/clients/ossfuzz\"\n\t\"github.com/ossf/scorecard/v5/log\"\n\t\"github.com/ossf/scorecard/v5/options\"\n\t\"github.com/ossf/scorecard/v5/pkg/scorecard\"\n)\nfunc serveCmd(o *options.Options) *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve the scorecard program over http\",\n\t\tLong:  ``,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tlogger := log.NewLogger(log.ParseLevel(o.LogLevel))\n\n\t\t\tt, err := template.New(\"webpage\").Parse(tpl)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"parsing webpage template\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\thttp.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\trepoParam := r.URL.Query().Get(\"repo\")\n\t\t\t\tconst length = 3\n\t\t\t\ts := strings.SplitN(repoParam, \"/\", length)\n\t\t\t\tif len(s) != length {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\trepo, err := githubrepo.MakeGithubRepo(repoParam)\n\t\t\t\tif err != nil {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\tctx := r.Context()\n\t\t\t\trepoClient := githubrepo.CreateGithubRepoClient(ctx, logger)\n\t\t\t\tossFuzzRepoClient, err := ossfuzz.CreateOSSFuzzClientEager(ossfuzz.StatusURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"initializing clients\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t\tdefer ossFuzzRepoClient.Close()\n\t\t\t\trepoResult, err := scorecard.Run(ctx, repo,\n\t\t\t\t\tscorecard.WithCommitDepth(o.CommitDepth),\n\t\t\t\t\tscorecard.WithRepoClient(repoClient),\n\t\t\t\t\tscorecard.WithOSSFuzzClient(ossFuzzRepoClient),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"running enabled scorecard checks on repo\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\n\t\t\t\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\t\t\tif err := repoResult.AsJSON(o.ShowDetails, log.ParseLevel(o.LogLevel), rw); err != nil {\n\t\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := t.Execute(rw, repoResult); err != nil {\n\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tport := os.Getenv(\"PORT\")\n\t\t\tif port == \"\" {\n\t\t\t\tport = \"8080\"\n\t\t\t}\n\t\t\tlogger.Info(\"Listening on localhost:\" + port + \"\\n\")\n\t\t\terr = http.ListenAndServe(fmt.Sprintf(\"0.0.0.0:%s\", port), nil)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"listening and serving\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t},\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"github.com/spf13/cobra\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype options struct {\n\tLogLevel string\n\tCommitDepth int\n}\n\nfunc serveCmd(o *options) *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Start the HTTP server\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\t// Initialize logger based on log level\n\t\t\tvar logLevel int\n\t\t\tswitch o.LogLevel {\n\t\t\tcase \"debug\":\n\t\t\t\tlogLevel = 2\n\t\t\tcase \"info\":\n\t\t\t\tlogLevel = 1\n\t\t\tdefault:\n\t\t\t\tlogLevel = 0\n\t\t\t}\n\t\t\t// For simplicity, using standard log\n\t\t\tlog.SetFlags(log.Flags() | log.Lshortfile)\n\t\t\tlog.SetPrefix(\"scorecard-server: \")\n\n\t\t\t// Define route for scorecard\n\t\t\thttp.HandleFunc(\"/scorecard/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t// Extract repository info from URL\n\t\t\t\tpath := r.URL.Path\n\t\t\t\tif len(path) < len(\"/scorecard/\") {\n\t\t\t\t\thttp.Error(w, \"Invalid path\", http.StatusBadRequest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trepoPath := path[len(\"/scorecard/\"):]\n\t\t\t\tparts := strings.Split(repoPath, \"/\")\n\t\t\t\tif len(parts) != 2 {\n\t\t\t\t\thttp.Error(w, \"Invalid repository path\", http.StatusBadRequest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\towner := parts[0]\n\t\t\t\trepo := parts[1]\n\n\t\t\t\t// Make request to GitHub API\n\t\t\t\turl := fmt.Sprintf(\"https://api.github.com/repos/%s/%s/scorecards\", owner, repo)\n\t\t\t\treq, err := http.NewRequest(\"GET\", url, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treq.Header.Set(\"Accept\", \"application/vnd.github.v3+json\")\n\n\t\t\t\tclient := &http.Client{}\n\t\t\t\tresp, err := client.Do(req)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefer resp.Body.Close()\n\n\t\t\t\t// Check if the response is OK\n\t\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\t\t\thttp.Error(w, fmt.Sprintf(\"GitHub API error: %s\", body), resp.StatusCode)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Read the response body\n\t\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Determine content type based on Accept header\n\t\t\t\tcontentType := r.Header.Get(\"Accept\")\n\t\t\t\tif contentType == \"application/json\" || strings.HasPrefix(contentType, \"application/json\") {\n\t\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\t\tio.WriteString(w, string(body))\n\t\t\t\t} else {\n\t\t\t\t\t// For HTML, use a simple template\n\t\t\t\t\t// Assume template is pre-registered\n\t\t\t\t\t// For simplicity, just return JSON\n\t\t\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t\t\tio.WriteString(w, fmt.Sprintf(\"<html><body><pre>%s</pre></body></html>\", string(body)))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Start the server\n\t\t\tlog.Println(\"Starting server on :8080\")\n\t\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\treturn cmd\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Go HTTP server that handles Stripe webhook events, specifically processing billing meter error reports and other event types.\n\nFunction Description: The main function sets up an HTTP server with a \"/webhook\" endpoint that receives and processes Stripe webhook events. It validates the webhook signature, retrieves full event details from Stripe, and handles specific event types (particularly \"v1.billing.meter.error_report_triggered\").\n\nInput:\n- HTTP POST requests to \"/webhook\" endpoint containing:\n  - Request body with Stripe event payload (JSON format)\n  - \"Stripe-Signature\" header for webhook validation\n- Environment variables:\n  - apiKey: Stripe API key for authentication\n  - webhookSecret: Secret for validating webhook signatures\n\nOutput:\n- HTTP responses:\n  - 200 OK for successful processing\n  - 500 Internal Server Error for any processing failures\n- Console output:\n  - Success messages with meter IDs for handled events\n  - Error messages for any processing failures\n  - Notifications for unhandled event types\n\nThe function does not explicitly return values but writes to the HTTP response and console.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/stripe/stripe-go/v81\"\n\tbillingMeters \"github.com/stripe/stripe-go/v81/billing/meter\"\n\t\"github.com/stripe/stripe-go/v81/rawrequest\"\n\twebhook \"github.com/stripe/stripe-go/v81/webhook\"\n)\nfunc main() {\n\tb, err := stripe.GetRawRequestBackend(stripe.APIBackend)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tclient := rawrequest.Client{B: b, Key: apiKey}\n\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) {\n\t\tconst MaxBodyBytes = int64(65536)\n\t\treq.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes)\n\t\tpayload, err := ioutil.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\terr = webhook.ValidatePayload(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar thinEvent map[string]interface{}\n\n\t\tif err := json.Unmarshal(payload, &thinEvent); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse thin event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\teventID := thinEvent[\"id\"].(string)\n\n\t\tvar event map[string]interface{}\n\n\t\tresp, err := client.RawRequest(http.MethodGet, \"/v2/core/events/\"+eventID, \"\", nil)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get pull event: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := json.Unmarshal(resp.RawJSON, &event); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse pull event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tswitch t := event[\"type\"].(string); t {\n\t\tcase \"v1.billing.meter.error_report_triggered\":\n\t\t\trelatedObject := event[\"related_object\"].(map[string]interface{})\n\t\t\tmeter, err := billingMeters.Get(relatedObject[\"id\"].(string), nil)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get related meter object: %v\\n\", err.Error())\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmeterID := meter.ID\n\t\t\tfmt.Printf(\"Success! %s\\n\", meterID)\n\t\t\tfmt.Println(fmt.Sprint(event[\"data\"]))\n\t\tdefault:\n\t\t\tfmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", t)\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\terr = http.ListenAndServe(\":4242\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/json\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"io\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer r.Body.Close()\n\n\t\tsignature := r.Header.Get(\"Stripe-Signature\")\n\t\tif signature == \"\" {\n\t\t\thttp.Error(w, \"Missing Stripe-Signature header\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tsecret := os.Getenv(\"webhookSecret\")\n\t\tif secret == \"\" {\n\t\t\thttp.Error(w, \"Missing webhook secret\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.Split(signature, \"&\")\n\t\tvar sig string\n\t\tfor _, part := range parts {\n\t\t\tif strings.HasPrefix(part, \"sig=\") {\n\t\t\t\tsig = strings.Split(part, \"=\")[1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif sig == \"\" {\n\t\t\thttp.Error(w, \"Invalid Stripe-Signature format\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\thash := hmac.New(sha256.New, []byte(secret))\n\t\thash.Write(body)\n\t\texpectedSig := hex.EncodeToString(hash.Sum(nil))\n\n\t\tif sig != expectedSig {\n\t\t\thttp.Error(w, \"Invalid Stripe signature\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar event map[string]interface{}\n\t\tif err := json.Unmarshal(body, &event); err != nil {\n\t\t\thttp.Error(w, \"Failed to parse event JSON\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\teventType, ok := event[\"type\"].(string)\n\t\tif !ok {\n\t\t\thttp.Error(w, \"Invalid event type\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif eventType == \"v1.billing.meter.error_report_triggered\" {\n\t\t\tdata, ok := event[\"data\"].(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tlog.Println(\"Invalid event data structure\")\n\t\t\t\thttp.Error(w, \"Invalid event data structure\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tobject, ok := data[\"object\"].(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tlog.Println(\"Invalid object structure\")\n\t\t\t\thttp.Error(w, \"Invalid object structure\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmeterID, ok := object[\"meter_id\"].(string)\n\t\t\tif !ok {\n\t\t\t\tlog.Println(\"Missing meter_id in event data\")\n\t\t\t\thttp.Error(w, \"Missing meter_id in event data\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Handled billing meter error report for meter ID: %s\\n\", meterID)\n\t\t} else {\n\t\t\tlog.Printf(\"Unhandled event type: %s\\n\", eventType)\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\tlog.Println(\"Starting HTTP server on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a simple HTTP server in Go that tracks and displays the number of visits by maintaining a cookie-based counter.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles incoming requests. For each request, it checks for a cookie named \"my-cookie\". If the cookie doesn't exist, it creates one with an initial value of \"0\". The function increments the cookie value on each visit and sends it back in the response, effectively maintaining a visit counter.\n\nInput: None (The function takes no direct input parameters. It responds to HTTP requests received on port 9000.)\n\nOutput: None (The function doesn't return any value. It writes the current visit count to the HTTP response and sets/updates the cookie in the response header.)",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"my-cookie\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"my-cookie\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\t\tcount, _ := strconv.Atoi(cookie.Value)\n\t\tcount++\n\t\tcookie.Value = strconv.Itoa(count)\n\n\t\thttp.SetCookie(res, cookie)\n\n\t\tio.WriteString(res, cookie.Value)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"my-cookie\")\n\t\tif err != nil {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"my-cookie\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\t\tcount, _ := strconv.Atoi(cookie.Value)\n\t\tcount++\n\t\tnewCookie := &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: strconv.Itoa(count),\n\t\t}\n\t\thttp.SetCookie(w, newCookie)\n\t\tfmt.Fprintf(w, \"You are visitor number: %d\", count)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server with health check and metrics endpoints using Go's net/http package.\n\nFunction Description: The function `serveMetrics` initializes an HTTP server with two endpoints: `/healthz` for health checks (returns \"OK\" with 200 status) and `/metrics` for Prometheus metrics (handled by promhttp). The server listens on the specified address and runs until terminated.\n\nInput: \n- `address` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput: \n- None (function runs indefinitely until server termination)\n- Logs fatal errors if server fails to start",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc serveMetrics(address string) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tlog.Fatal(http.ListenAndServe(address, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/prometheus/client_golang/promhttp\"\n)\n\nfunc serveMetrics(address string) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\tif err := http.ListenAndServe(address, nil); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebSocket connections at the root path (\"/\"). The server should load configuration from a JSON file and start listening on a specified port.\n\nFunction Description: The main function initializes the server by loading configuration, setting up a WebSocket handler at the root path, and starting the HTTP server on the configured port.\n\nInput: None (configuration is loaded from \"config.json\" file)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics if server fails to start)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"golang.org/x/net/websocket\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tConfig = load(\"config.json\")\n\t\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\ts := websocket.Server{Handler: websocket.Handler(wsHandler)}\n\t\ts.ServeHTTP(w, req)\n\t})\n\n\terr := http.ListenAndServe(\":\"+strconv.Itoa(Config.Port), nil)\n\tif err != nil {\n\t\tpanic(\"Error: \" + err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"encoding/json\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Config struct {\n\tPort int\n}\n\nfunc main() {\n\tdata, err := ioutil.ReadFile(\"config.json\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading config: %v\", err)\n\t}\n\tvar config Config\n\tif err := json.Unmarshal(data, &config); err != nil {\n\t\tlog.Fatalf(\"Error parsing config: %v\", err)\n\t}\n\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool { return true },\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconn.WriteMessage(websocket.TextMessage, message)\n\t\t}\n\t})\n\n\tlog.Printf(\"Starting server on :%d\", config.Port)\n\tif err := http.ListenAndServe(fmt.Sprintf(\":%d\", config.Port), nil); err != nil {\n\t\tlog.Fatalf(\"Server failed to start: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles form submissions and displays a simple HTML form.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form. For POST requests, it reads the form value and prints it to the console while still displaying the form. The server listens on port 9000.\n\nInput: None (The function takes no direct input parameters, but receives HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but writes to the HTTP response and prints to console)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t <input type=\"text\" name=\"q\">\n\t\t <input type=\"submit\">\n\n\t\t</form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        if r.Method == \"GET\" {\n            w.Header().Set(\"Content-Type\", \"text/html\")\n            fmt.Fprintf(w, \"<form method='POST' action='/'> <input type='text' name='userInput'> <input type='submit' value='Submit'> </form>\")\n        } else if r.Method == \"POST\" {\n            r.ParseForm()\n            value := r.FormValue(\"userInput\")\n            fmt.Println(\"Received:\", value)\n            w.Header().Set(\"Content-Type\", \"text/html\")\n            fmt.Fprintf(w, \"<form method='POST' action='/'> <input type='text' name='userInput'> <input type='submit' value='Submit'> </form>\")\n        }\n    })\n    http.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and starts an HTTP server listening on port 8080.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response.\n- `r *http.Request` - Represents the HTTP request received from the client.\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles form submissions and displays the submitted value. The server should respond to both GET and POST requests on the root path (\"/\") and render an HTML form with a checkbox input.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path (\"/\"). The handler processes form submissions, extracts the form value, and returns an HTML response containing the form and the submitted value.\n\nInput: None (The function takes no direct input parameters. Input is received through HTTP requests.)\n\nOutput: None (The function doesn't return any value. Output is sent through the HTTP response writer.)\n\nNote: The function internally uses http.ResponseWriter to send responses and *http.Request to receive requests. The handler checks for a form value with key \"q\" and includes it in the response. The server listens on port 9000.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t<input type=\"checkbox\" name=\"q\">\n\t\t<input type=\"submit\">\n\n\t\t</form>`+val)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"POST\" {\n\t\t\tr.ParseForm()\n\t\t\tq := r.FormValue(\"q\")\n\t\t\tfmt.Fprintf(w, \"<!DOCTYPE html><html><body><form method=\\\"post\\\"><input type=\\\"checkbox\\\" name=\\\"q\\\" value=\\\"1\\\"><input type=\\\"submit\\\" value=\\\"Submit\\\"></form><p>Submitted value: <strong>%s</strong></p></body></html>\", q)\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \"<!DOCTYPE html><html><body><form method=\\\"post\\\"><input type=\\\"checkbox\\\" name=\\\"q\\\" value=\\\"1\\\"><input type=\\\"submit\\\" value=\\\"Submit\\\"></form></body></html>\")\n\t\t}\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that serves Prometheus metrics via an HTTP server, updating custom metrics (uptime and packet count) on each request.\n\nFunction Description: The ServeMetricsAt function starts an HTTP server to expose Prometheus metrics. It registers custom metrics (uptime and packet count), updates them on each request to the metrics endpoint, and serves the metrics using the Prometheus HTTP handler. The function runs the server in a goroutine to avoid blocking the main program.\n\nInput:\n- addr (string): The network address (including port) where the metrics server should listen (e.g., \":8080\")\n- c (*collector.Collector): A pointer to a collector instance used to get the current packet count (can be nil)\n\nOutput: None (the function runs indefinitely in a background goroutine)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n\t\"github.com/dreadl0ck/netcap/collector\"\n)\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tprometheus.MustRegister(upTime)\n\tprometheus.MustRegister(numPackets)\n\n\tfmt.Println(\"starting to serve metrics at:\", addr+metricsRoute)\n\n\tgo func() {\n\t\tmetricsHandler := promhttp.Handler()\n\n\t\thttp.HandleFunc(metricsRoute, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupTime.WithLabelValues().Set(math.RoundToEven(time.Since(startTime).Seconds())\n\n\t\t\tif c != nil {\n\t\t\t\tnumPackets.WithLabelValues().Set(float64(c.GetNumPackets()))\n\t\t\t}\n\n\t\t\tmetricsHandler.ServeHTTP(w, r)\n\t\t})\n\t\tlog.Fatal(\"failed to serve metrics: \", http.ListenAndServe(addr, nil))\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "import (\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tstartTime := time.Now()\n\n\tvar packetCount prometheus.Collector\n\tif c != nil {\n\t\tpacketCount = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\t\tName: \"packet_count\",\n\t\t\tHelp: \"Current packet count from collector\",\n\t\t})\n\t} else {\n\t\tpacketCount = prometheus.NewCounter(prometheus.CounterOpts{\n\t\t\tName: \"packet_count\",\n\t\t\tHelp: \"Number of packets processed\",\n\t\t})\n\t}\n\n\tuptime := prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"uptime_seconds\",\n\t\tHelp: \"Uptime of the server in seconds\",\n\t})\n\n\tprometheus.MustRegister(packetCount, uptime)\n\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif c != nil {\n\t\t\tpacketCount.Set(float64(c.GetPacketCount()))\n\t\t} else {\n\t\t\tpacketCount.Inc()\n\t\t}\n\n\t\tuptime.Set(time.Since(startTime).Seconds())\n\n\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t})\n\n\tgo http.ListenAndServe(addr, nil)\n}"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Go HTTP server that implements WebDAV functionality with custom logging and special handling for specific HTTP headers.\n\nStruct Description: The webdav.Handler struct provides WebDAV server functionality with in-memory storage for files and locks. We'll wrap this with custom request handling.\n\nFields:\n- FileSystem: webdav.FileSystem - In-memory filesystem implementation\n- LockSystem: webdav.LockSystem - In-memory lock system implementation\n- Logger: func(*http.Request, error) - Custom logging function for request tracking\n\nMethods:\n- ServeHTTP: (http.ResponseWriter, *http.Request) -> () - Main handler method that processes HTTP requests\n- NewMemFS: () -> webdav.FileSystem - Creates new in-memory filesystem\n- NewMemLS: () -> webdav.LockSystem - Creates new in-memory lock system\n\nAdditional Functions:\n- main: () -> () - Entry point that sets up the server and routes\n- requestHandler: (http.ResponseWriter, *http.Request) -> () - Custom middleware for special header handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/madneal/webdav\"\n)\n\nfunc main() {\n\tfs := webdav.NewMemFS()\n\tls := webdav.NewMemLS()\n\tlogger := func(r *http.Request, err error) {\n\t\tfmt.Printf(\"Logged request: %s %s\\n\", r.Method, r.URL.Path)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t}\n\t}\n\thandler := &webdav.Handler{\n\t\tFileSystem: fs,\n\t\tLockSystem: ls,\n\t\tLogger:     logger,\n\t}\n\trequestHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tif header := r.Header.Get(\"X-Custom-Header\"); header != \"\" {\n\t\t\tfmt.Printf(\"Custom header received: %s\\n\", header)\n\t\t\thandler.Logger(r, nil)\n\t\t}\n\t\thandler.Logger(r, nil)\n\t}\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestHandler(w, r)\n\t\thandler.ServeHTTP(w, r)\n\t}))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and responds with plain text.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes a plain text response (\"Dog\") to the client. The handler also sets the Content-Type header to \"text/plain\".\n\nInput: None (The function takes no direct input parameters; it handles HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return anything; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tres.Header()[\"Content-Type\"] = []string{\"text/plain\"}\n\t\tfmt.Fprint(res, \"Dog\")\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintf(w, \"Dog\")\n\t})\n\thttp.ListenAndServe(\":9000\", nil)"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server to serve web content, including handling specific routes for examples and serving static files.\n\nFunction Description: The `serve` function initializes an HTTP server that handles multiple routes. It serves a home page, handles requests for WASM execution files, and processes example-related routes with dynamic content generation. The function uses Go's `net/http` package to create routes and serve content, including HTML templates and static files.\n\nInput: \n- `addr` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput:\n- `error`: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nThe function performs these key operations:\n1. Loads example data using `getExamples()`\n2. Sets up template handling for the home page and example pages\n3. Configures route handlers for:\n   - Root path (\"/\") serving the home page\n   - WASM execution file (\"/wasm_exec.js\")\n   - Example paths (\"/example/[type]/[link]/...\")\n4. Starts the HTTP server on the specified address",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\n\thomeTemplate := template.Must(template.ParseFiles(\"index.html\"))\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\turl := r.URL.Path\n\t\tif url == \"/wasm_exec.js\" {\n\t\t\thttp.FileServer(http.Dir(filepath.Join(build.Default.GOROOT, \"misc/wasm/\"))).ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.Split(url, \"/\")\n\t\tif len(parts) > 4 &&\n\t\t\tparts[1] == \"example\" {\n\t\t\texampleType := parts[2]\n\t\t\texampleLink := parts[3]\n\t\t\tfor _, example := range *examples {\n\t\t\t\tif example.Link != exampleLink {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfiddle := filepath.Join(exampleLink, \"jsfiddle\")\n\t\t\t\tif len(parts[4]) != 0 {\n\t\t\t\t\thttp.StripPrefix(\"/example/\"+exampleType+\"/\"+exampleLink+\"/\", http.FileServer(http.Dir(fiddle))).ServeHTTP(w, r)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttemp := template.Must(template.ParseFiles(\"example.html\"))\n\t\t\t\t_, err := temp.ParseFiles(filepath.Join(fiddle, \"demo.html\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\n\t\t\t\tdata := struct {\n\t\t\t\t\t*Example\n\t\t\t\t\tJS bool\n\t\t\t\t}{\n\t\t\t\t\texample,\n\t\t\t\t\texampleType == \"js\",\n\t\t\t\t}\n\n\t\t\t\terr = temp.Execute(w, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\terr := homeTemplate.Execute(w, examples)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"html/template\"\n\t\"strings\"\n)\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\thomeTmpl := template.Must(template.ParseFiles(\"home.html\"))\n\texampleTmpl := template.Must(template.ParseFiles(\"example.html\"))\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thomeTmpl.Execute(w, examples)\n\t})\n\n\thttp.HandleFunc(\"/wasm_exec.js\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"wasm_exec.js\")\n\t})\n\n\thttp.HandleFunc(\"/example/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := strings.TrimPrefix(r.URL.Path, \"/example/\")\n\t\tparts := strings.Split(path, \"/\")\n\t\tif len(parts) < 2 {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\ttypeStr := parts[0]\n\t\tlinkStr := parts[1]\n\t\tvar example Example\n\t\tfor _, e := range examples {\n\t\t\tif e.Type == typeStr && e.Link == linkStr {\n\t\t\t\texample = e\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif example.Type == \"\" {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\texampleTmpl.Execute(w, example)\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Go HTTP server that handles multiple routes with different authentication methods (Basic Auth and Bearer Token) and serves Prometheus metrics on authenticated endpoints.\n\nFunction Description: The main function sets up an HTTP server with three routes:\n1. Root (\"/\") route with a basic handler\n2. \"/metrics\" route protected by Basic Authentication\n3. \"/bearer-metrics\" route protected by Bearer Token authentication\nThe server listens on port 8080 and uses the net/http package for HTTP operations.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The implementation assumes the existence of two helper functions:\n1. checkBasicAuth(w http.ResponseWriter, r *http.Request) bool\n2. checkBearerAuth(w http.ResponseWriter, r *http.Request) bool\nwhich handle the respective authentication methods.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBasicAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\thttp.HandleFunc(\"/bearer-metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBearerAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Bearer realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\taddress := \":8080\"\n\n\t_ = http.ListenAndServe(address, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World\")\n\t})\n\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBasicAuth(w, r) {\n\t\t\tfmt.Fprintf(w, \"Prometheus metrics\")\n\t\t} else {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t})\n\n\thttp.HandleFunc(\"/bearer-metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBearerAuth(w, r) {\n\t\t\tfmt.Fprintf(w, \"Prometheus metrics with Bearer\")\n\t\t} else {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles multiple routes with different functionalities, including a root route, a route to display request headers, and a route to show build information.\n\nFunction Description: The HTTP server will respond to different endpoints with specific behaviors:\n1. Root endpoint (\"/\") returns a greeting message\n2. \"/headers\" endpoint returns all request headers\n3. \"/api/buildstamp\" endpoint returns build information\n\nInput: \n- HTTP requests to specified endpoints (/, /headers, /api/buildstamp)\n- BuildStamp string variable containing build information\n\nOutput: \n- For \"/\": Plain text response \"hello, my name is Go~~\"\n- For \"/headers\": List of all request headers in \"name: value\" format\n- For \"/api/buildstamp\": Current value of BuildStamp variable\n- HTTP responses through the http.ResponseWriter interface",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar BuildStamp = \"No Build Stamp Provided\"\n\nfunc hello(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"hello, my name is Go~~\\n\")\n}\n\nfunc headers(w http.ResponseWriter, req *http.Request) {\n\tfor name, headers := range req.Header {\n\t\tfor _, h := range headers {\n\t\t\tfmt.Fprintf(w, \"%v: %v\\n\", name, h)\n\t\t}\n\t}\n}\n\nfunc buildStamp(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"%s\", BuildStamp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", hello)\n\thttp.HandleFunc(\"/api/buildstamp\", buildStamp)\n\thttp.HandleFunc(\"/headers\", headers)\n\n\thttp.ListenAndServe(\":20219\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar BuildStamp = \"Build: 1.0.0\"\n\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"hello, my name is Go~~\")\n}\n\nfunc headersHandler(w http.ResponseWriter, r *http.Request) {\n\tvar headers []string\n\tfor name, values := range r.Header {\n\t\tfor _, value := range values {\n\t\t\theaders = append(headers, name+\": \"+value)\n\t\t}\n\t}\n\tfmt.Fprintln(w, strings.Join(headers, \"\\n\"))\n}\n\nfunc buildstampHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, BuildStamp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", rootHandler)\n\thttp.HandleFunc(\"/headers\", headersHandler)\n\thttp.HandleFunc(\"/api/buildstamp\", buildstampHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a function that sets up a basic HTTP server to receive SDP (Session Description Protocol) data through HTTP POST requests and forward it through a channel.\n\nFunction Description: The function `httpSDPServer` creates an HTTP server that listens on a specified port. When a POST request is received at the root path (\"/\"), it reads the request body, sends the body content through a channel, and responds with \"done\". The server runs in a separate goroutine to avoid blocking.\n\nInput: \n- port [int] - The port number on which the HTTP server should listen\n\nOutput:\n- [chan string] - A channel that will receive the SDP data from incoming HTTP requests",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tfmt.Fprintf(w, \"done\")\n\t\tsdpChan <- string(body)\n\t})\n\n\tgo func() {\n\t\tpanic(http.ListenAndServe(\":\"+strconv.Itoa(port), nil))\n\t}()\n\n\treturn sdpChan\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "import (\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n)\n\nfunc httpSDPServer(port int) chan string {\n    ch := make(chan string)\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n        if req.Method == \"POST\" {\n            body, _ := ioutil.ReadAll(req.Body)\n            ch <- string(body)\n            w.Write([]byte(\"done\"))\n        }\n    })\n    go func() {\n        http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n    }()\n    return ch\n}"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles requests to the root path (\"/\") and returns a welcome message combined with a predefined string variable and a version string.\n\nFunction Description: The main function sets up a basic HTTP server that listens on port 8080. It registers a handler function for the root path (\"/\") which writes a welcome message concatenated with a local string variable and a package-level version string to the response.\n\nInput: None (The HTTP server listens for incoming requests on the specified port)\n\nOutput: None (The function runs indefinitely, serving HTTP responses. The handler writes output to the http.ResponseWriter)\n\nNote: The reference code is at the package level (main package) rather than being encapsulated in a struct or class. The instruction follows the function-level format as requested.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\ta := \"hello \"\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, \"Welcome to my website! \", a, v)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar version = \"v1.0.0\"\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tlocalVar := \"LocalVar\"\n\t\tmsg := \"Welcome to our service!\" + \" \" + localVar + \" \" + version\n\t\tfmt.Fprintf(w, msg)\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a basic HTTP server in Go that listens on a specified port and responds with \"Hello World!\" to all requests on the root path.\n\nFunction Description: The main function sets up an HTTP server that handles requests to the root path (\"/\") by responding with a \"Hello World!\" message. It uses the net/http package to register a handler function and start the server.\n\nInput: None (The function takes no direct input parameters, but the HTTP server will process incoming HTTP requests)\n\nOutput: None (The function doesn't return anything directly, but it will output \"Hello World!\" as an HTTP response to requests, and may output error messages to the log if the server fails to start)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc helloWorld(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", helloWorld)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests on specified routes, supports HTTPS with TLS certificates, and redirects HTTP traffic to HTTPS.\n\nFunction Description: The code demonstrates setting up a basic HTTP server with HTTPS support. It includes a handler function to process requests, sets up an HTTP-to-HTTPS redirect, and starts both HTTP and HTTPS servers concurrently.\n\nInput:\n- Port numbers for HTTP (9999) and HTTPS (10443) servers\n- TLS certificate files (\"cert.pem\" and \"key.pem\")\n- HTTP request objects (*http.Request) for the handler function\n\nOutput:\n- HTTP responses (through http.ResponseWriter)\n- Server logs indicating server status and errors\n- Automatic HTTP-to-HTTPS redirection (301 Moved Permanently)\n\nMethods:\n1. handler(w http.ResponseWriter, req *http.Request) - Processes incoming requests and writes a plain text response\n2. main() - Configures and starts the HTTP and HTTPS servers, including the redirect handler",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"This is an example server.\\n\"))\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tlog.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\")\n\tgo http.ListenAndServe(\":9999\", http.RedirectHandler(\"https://127.0.0.1:10443/\", 301))\n\terr := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tif req.URL.Scheme == \"http\" {\n\t\thttp.Redirect(w, req, \"https://\"+req.Host+req.URL.Path+req.URL.RawQuery, http.StatusMovedPermanently)\n\t} else {\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tgo func() {\n\t\tif err := http.ListenAndServe(\":9999\", nil); err != nil {\n\t\t\tlog.Printf(\"HTTP server failed: %v\", err)\n\t\t}\n\t}()\n\tif err := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil); err != nil {\n\t\tlog.Printf(\"HTTPS server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when a request is received. The server listens on port 8080.\n\nInput:  \n- `w http.ResponseWriter`: Used to construct the HTTP response.  \n- `r *http.Request`: Contains information about the incoming HTTP request.  \n\nOutput:  \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response body. No explicit return value.  \n\nExample usage:  \n```go\nhttp.HandleFunc(\"/\", handler)  \nhttp.ListenAndServe(\":8080\", nil)  \n```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a multipart form and displays an upload form to the client.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form for file uploads. For POST requests, it processes the uploaded file. The server listens on port 9000.\n\nInput: \n- None (The function takes no direct input parameters, but handles HTTP requests with:\n  - GET requests to \"/\" path\n  - POST requests with multipart/form-data containing a file under the \"q\" field)\n\nOutput:\n- For GET requests: Returns HTML form for file upload (content-type: text/html)\n- For POST requests: Processes the uploaded file (prints file info to console)\n- Server runs continuously on port 9000 until terminated",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tfile, hdr, err := req.FormFile(key)\n\t\tfmt.Println(file, hdr, err)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\" enctype=\"multipart/form-data\">\n      <input type=\"file\" name=\"q\">\n      <input type=\"submit\">\n    </form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\thtml := \"<form action=\\\"/\\\" method=\\\"post\\\" enctype=\\\"multipart/form-data\\\">\\n\"\n\t\t\thtml += \"  <input type=\\\"file\\\" name=\\\"q\\\">\\n\"\n\t\t\thtml += \"  <input type=\\\"submit\\\">\\n\"\n\t\t\thtml += \"</form>\"\n\t\t\tw.Write([]byte(html))\n\t\t} else if r.Method == \"POST\" {\n\t\t\tr.ParseMultipartForm(10 << 20)\n\t\t\tfile, handler, err := r.FormFile(\"q\")\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error uploading file\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tfmt.Printf(\"Uploaded file: %s\\n\", handler.Filename)\n\t\t\tfmt.Printf(\"File size: %d\\n\", handler.Size)\n\t\t\tw.Write([]byte(\"File uploaded successfully\"))\n\t\t}\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server with instrumented handlers for metrics collection using Prometheus. The function should register routes for metrics and a custom endpoint, apply middleware for context handling, and instrument handlers with counters and histograms.\n\nFunction Description: The function ExampleInstrumentHandlerWithLabelResolver demonstrates how to create an HTTP server with Prometheus instrumentation. It sets up counter and histogram metrics, creates handlers for specific routes, applies middleware to extract headers into context, and starts the server on port 3000. The function doesn't take any explicit parameters but relies on package-level configurations.\n\nInput: None (uses package-level constants and variables)\n\nOutput: None (starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\tcounter := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"api_requests_total\",\n\t\t\tHelp: \"A counter for requests to the wrapped handler.\",\n\t\t},\n\t\t[]string{\"code\", \"method\", \"myheader\"},\n\t)\n\n\tduration := prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"request_duration_seconds\",\n\t\t\tHelp:    \"A histogram of latencies for requests.\",\n\t\t\tBuckets: []float64{.25, .5, 1, 2.5, 5, 10},\n\t\t},\n\t\t[]string{\"handler\", \"method\", \"myheader\"},\n\t)\n\n\tpullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Pull\"))\n\t})\n\n\topts := WithLabelFromCtx(\"myheader\",\n\t\tfunc(ctx context.Context) string {\n\t\t\treturn ctx.Value(CtxResolverKey).(string)\n\t\t},\n\t)\n\n\tpullChain := InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"pull\"}),\n\t\tInstrumentHandlerCounter(counter, pullHandler, opts),\n\t\topts,\n\t)\n\n\tmiddleware := func(next http.HandlerFunc) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), CtxResolverKey, r.Header.Get(\"x-my-header\"))\n\n\t\t\tnext(w, r.WithContext(ctx))\n\t\t}\n\t}\n\n\thttp.Handle(\"/metrics\", Handler())\n\thttp.Handle(\"/pull\", middleware(pullChain))\n\n\tif err := http.ListenAndServe(\":3000\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n\tcounter = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"http_requests_total\",\n\t\t\tHelp: \"Total number of HTTP requests.\",\n\t\t},\n\t\t[]string{\"endpoint\"},\n\t)\n\thistogram = prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_duration_seconds\",\n\t\t\tHelp:    \"Duration of HTTP requests.\",\n\t\t\tBuckets: prometheus.ExponentialBuckets(0.001, 2, 10),\n\t\t},\n\t\t[]string{\"endpoint\"},\n\t)\n)\n\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\tprometheus.MustRegister(counter, histogram)\n\n\theaderMiddleware := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), \"headers\", r.Header)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n\n\tcustomMiddleware := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tstart := time.Now()\n\t\t\tcounter.WithLabelValues(\"/custom\").Inc()\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\thistogram.WithLabelValues(\"/custom\").Observe(time.Since(start).Seconds())\n\t\t})\n\t}\n\n\thttp.Handle(\"/custom\", customMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Custom endpoint\"))\n\t})))\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\thttp.ListenAndServe(\":3000\", headerMiddleware(http.DefaultServeMux))\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when the server receives a request to that path.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response back to the client.\n- `r *http.Request` - Contains information about the incoming HTTP request (not used in this simple example).\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the response writer (`w`), which is sent back to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and responds with the requested URL path.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes the requested URL path as plain text in the response.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return any value; it continuously serves HTTP requests until terminated)\n\nNote: The handler function takes two parameters:\n1. res http.ResponseWriter - used to write the HTTP response\n2. req *http.Request - contains information about the incoming request",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprint(res, req.URL.Path)\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Write([]byte(req.URL.Path))\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a basic HTTP server in Go that echoes back the request headers to the client. The server should handle requests on the root path (\"/\") and respond by writing the request headers to the response.\n\nFunction Description: The `ServeHTTP` function is an HTTP handler that writes the request headers to the response writer. It is registered to handle requests on the root path (\"/\") and starts an HTTP server listening on `127.0.0.1:8080`.\n\nInput: \n- `w http.ResponseWriter`: Used to construct the HTTP response.\n- `r *http.Request`: Contains the incoming HTTP request details, including headers.\n\nOutput: None (writes directly to the `http.ResponseWriter`).",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tr.Header.Write(w)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ServeHTTP)\n\thttp.ListenAndServe(\"127.0.0.1:8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfor key, values := range r.Header {\n\t\tfor _, value := range values {\n\t\t\tfmt.Fprintf(w, \"%s: %s\\n\", key, value)\n\t\t}\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ServeHTTP)\n\thttp.ListenAndServe(\"127.0.0.1:8080\", nil)"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a basic HTTP server in Go that serves a template-based web page and handles requests on a configurable port.\n\nFunction Description: The main function sets up an HTTP server with a root route handler that renders a template. It configures the server port from environment variables with a default fallback, then starts the server.\n\nInput: \n- Environment variable \"PORT\" (optional): Specifies the port number to listen on\n- Template file \"todos/index.jet\": The template to be rendered and served\n\nOutput:\n- HTTP server running on the specified port, serving the rendered template at the root path (\"/\")\n- Log output indicating the server's running status and any template errors\n\nNote: The reference code shows the implementation but doesn't explicitly define separate functions for each operation. The main function combines:\n1. Route handling (with template rendering)\n2. Port configuration\n3. Server startup",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tview, err := views.GetTemplate(\"todos/index.jet\")\n\t\tif err != nil {\n\t\t\tlog.Println(\"Unexpected template err:\", err.Error())\n\t\t}\n\t\tview.Execute(w, nil, todos)\n\t})\n\n\tport := os.Getenv(\"PORT\")\n\tif len(port) == 0 {\n\t\tport = \":8080\"\n\t} else if !strings.HasPrefix(\":\", port) {\n\t\tport = \":\" + port\n\t}\n\n\tlog.Println(\"Serving on \" + port)\n\thttp.ListenAndServe(port, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"text/template\"\n)\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\ttmpl, err := template.ParseFiles(\"todos/index.jet\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Template parse error: %v\", err)\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif err := tmpl.Execute(w, nil); err != nil {\n\t\t\tlog.Printf(\"Template execute error: %v\", err)\n\t\t}\n\t})\n\n\tlog.Printf(\"Server starting on :%s\", port)\n\tif err := http.ListenAndServe(\":\"+port, nil); err != nil {\n\t\tlog.Fatalf(\"Server error: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles multiple routes with different response messages.\n\nFunction Description: The code demonstrates how to set up a simple HTTP server with two route handlers. The first handler responds to the root path (\"/\") with a \"doggy\" message, while the second handler responds to the \"/cat/\" path with a \"catty\" message. The server listens on port 9000.\n\nInput: \n- None (HTTP requests are automatically handled by the server)\n\nOutput: \n- None (The server writes responses directly to the http.ResponseWriter)\n\nMethods:\n- upTown: Handles requests to the root path (\"/\") and writes \"doggy doggy doggy\" to the response\n- youUp: Handles requests to the \"/cat/\" path and writes \"catty catty catty\" to the response\n- main: Registers the route handlers and starts the HTTP server on port 9000",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc upTown(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"doggy doggy doggy\")\n}\n\nfunc youUp(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"catty catty catty\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc upTown(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"doggy doggy doggy\")\n}\n\nfunc youUp(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"catty catty catty\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a Go HTTP server that serves PNG images generated by a package function.\n\nFunction Description: The main function sets up a basic HTTP server that responds to requests at the root path (\"/\") by generating a PNG image using an external package function and serving it with the correct content type.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the http.ResponseWriter and *http.Request parameters in the handler function)\n\nOutput: None (The function doesn't return any value but serves HTTP responses with PNG image data)",
    "Canonical_solution": "import (\n    \"fmt\"\n    \"net/http\"\n    \"io\"\n    \"bytes\"\n    \"davidhampgonsalves/lifedashboard/pkg\"\n)\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        png := pkg.Generate();\n        w.Header().Set(\"Content-Type\", \"image/png\")\n        io.Copy(w, bytes.NewBuffer(png))\n    })\n\n    fmt.Println(\"Server listening on http://localhost:8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// External package function to generate PNG image data\nfunc GeneratePNG() []byte {\n\t// This is a placeholder; replace with actual external package function\n\treturn []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A} // PNG signature\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata := GeneratePNG()\n\t\tw.Header().Set(\"Content-Type\", \"image/png\")\n\t\tw.Write(data)\n\t})\n\tfmt.Println(\"Server started on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebDAV requests with custom logging and special handling for certain Litmus test cases.\n\nFunction Description: The main function sets up a WebDAV server with in-memory storage (MemFS) and in-memory locking (MemLS). It includes custom logging for WebDAV operations and special handling for a specific Litmus test case (\"props: 3 (propfind_invalid2)\"). The server listens on a specified port and handles all incoming HTTP requests.\n\nInput: None (though the code uses a command-line flag for port configuration which would be handled by the flag package)\n\nOutput: None (the function runs indefinitely as a server, but may log errors or fatal conditions)\n\nNote: The actual implementation shows the server uses a port flag (not shown in parameters) and produces log output, but these are side effects rather than formal outputs.\n\n---\n\nFor completeness, if we were to describe the webdav.Handler struct being used (though not explicitly defined in this code):\n\nStruct Description: webdav.Handler is a struct from golang.org/x/net/webdav that implements http.Handler for WebDAV protocol operations.\n\nFields:\nFileSystem: webdav.FileSystem - The underlying file system implementation\nLockSystem: webdav.LockSystem - The locking system implementation\nLogger: func(*http.Request, error) - Optional function for logging requests and errors\n\nMethods:\nServeHTTP: ServeHTTP(http.ResponseWriter, *http.Request) -> None - Main handler method that processes HTTP requests according to WebDAV protocol",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"golang.org/x/net/webdav\"\n)\n\nfunc main() {\n\tport := flag.String(\"port\", \"8080\", \"Port to listen on\")\n\tflag.Parse()\n\n\tfs := webdav.NewMemFS()\n\tls := webdav.NewMemLS()\n\n\tlogger := func(r *http.Request, err error) {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[ERROR] %s %s: %v\", r.Method, r.URL.Path, err)\n\t\t} else {\n\t\t\tlog.Printf(\"[INFO] %s %s\", r.Method, r.URL.Path)\n\t\t}\n\t}\n\n\thandler := &webdav.Handler{\n\t\tFileSystem: fs,\n\t\tLockSystem: ls,\n\t\tLogger:     logger,\n\t}\n\n\tlitmusHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"PROPFIND\" && r.URL.Path == \"/props\" && r.Header.Get(\"Depth\") == \"0\" {\n\t\t\tfmt.Fprintf(w, \"<propfind xmlns='DAV:'><prop><invalid-prop/></prop></propfind>\")\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t})\n\n\taddr := fmt.Sprintf(\":%s\", *port)\n\tlog.Printf(\"Starting WebDAV server on %s\", addr)\n\tif err := http.ListenAndServe(addr, litmusHandler); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests with tracing capabilities using OpenCensus. The server should respond to requests with a simple message, perform tracing operations, and make an external HTTP request while propagating the trace context.\n\nFunction Description: The main function sets up an HTTP server with tracing middleware. It registers a root handler (\"/\") that responds with \"hello world\", creates trace spans, adds annotations/attributes, and makes an external HTTP request to example.com while maintaining trace context.\n\nInput: None (The function takes no direct input parameters. HTTP requests come through the server's routing mechanism.)\n\nOutput: None (The function doesn't return anything directly. It starts an HTTP server that listens indefinitely on port 50030 and handles incoming requests by writing responses to http.ResponseWriter.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/plugin/ochttp\"\n)\n\nfunc main() {\n\tclient := &http.Client{Transport: &ochttp.Transport{}}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\n\t\t_, span := trace.StartSpan(req.Context(), \"child\")\n\t\tdefer span.End()\n\t\tspan.Annotate([]trace.Attribute{trace.StringAttribute(\"key\", \"value\")}, \"something happened\")\n\t\tspan.AddAttributes(trace.StringAttribute(\"hello\", \"world\"))\n\t\ttime.Sleep(time.Millisecond * 125)\n\n\t\tr, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\t\tr = r.WithContext(req.Context())\n\t\tresp, err := client.Do(r)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t} else {\n\t\t\tresp.Body.Close()\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":50030\", &ochttp.Handler{}))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/census-instrumentation/opencensus-go/exporter/trace/console\"\n\t\"github.com/census-instrumentation/opencensus-go/trace\"\n)\n\nfunc main() {\n\texporter := console.NewExporter(console.Options{})\n\ttrace.RegisterExporter(exporter)\n\ttrace.SetDefaultSampler(trace.AlwaysSample())\n\ttrace.SetDefaultRecorder(trace.NewInMemoryRecorder())\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\t\tspan := trace.StartSpan(ctx, \"root_handler\")\n\t\tdefer span.End()\n\n\t\tspan.SetAttribute(\"http.method\", r.Method)\n\t\tspan.SetAttribute(\"http.path\", r.URL.Path)\n\n\t\tclient := &http.Client{\n\t\t\tTimeout: 5 * time.Second,\n\t\t}\n\t\treq, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\t\ttrace.Inject(ctx, req.Header, trace.HTTPHeaderFormat())\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to make external request\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tfmt.Fprintf(w, \"hello world\")\n\t})\n\n\thttp.ListenAndServe(\":50030\", nil)\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes middleware for request logging and rate limiting using Sentinel. The server should handle a GET request at the \"/test\" endpoint.\n\nFunction Description: The function sets up an Echo HTTP server with middleware for logging and rate limiting. The rate limiting is implemented using Sentinel middleware, which extracts the client's real IP from the request headers and applies a block fallback response when the rate limit is exceeded. The server listens on port 1323.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 1323.)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\nfunc Example() {\n\tr := echo.New()\n\tr.Use(middleware.Logger())\n\tr.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx echo.Context) string {\n\t\t\t\tif res, ok := ctx.Get(\"X-Real-IP\").(string); ok {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t\treturn \"\"\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx echo.Context) error {\n\t\t\t\treturn ctx.JSON(400, map[string]interface{}{\n\t\t\t\t\t\"err\":  \"too many requests; the quota used up\",\n\t\t\t\t\t\"code\": 10222,\n\t\t\t\t})\n\t\t\t}),\n\t\t),\n\t)\n\n\tr.GET(\"/test\", func(c echo.Context) error {\n\t\treturn nil\n\t})\n\tr.Logger.Fatal(r.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/alibaba/sentinel-gateway/middleware\"\n\t\"github.com/alibaba/sentinel-go/flow\"\n\t\"github.com/alibaba/sentinel-go/core/base\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.SentinelMiddleware())\n\te.GET(\"/test\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Test\")\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes route handling, middleware integration, and JWT-based authentication for restricted routes.\n\nFunction Description: The main function initializes an Echo server, configures middleware (logger and recovery), sets up routes for login and accessible content, and creates a restricted route group with JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger route handlers)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately as they're referenced but not shown in the provided code.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tr.Use(middleware.JWT([]byte(\"secret\")))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo-jwt/v4\"\n\t\"github.com/labstack/echo/middleware\"\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\tjwtMiddleware := echojwt.New(echojwt.Config{\n\t\tSecret: []byte(\"your-secret-key-here\"),\n\t})\n\n\te.POST(\"/login\", loginHandler)\n\te.GET(\"/accessible\", accessibleHandler)\n\n\trestrictedGroup := e.Group(\"/restricted\")\n\trestrictedGroup.Use(jwtMiddleware)\n\trestrictedGroup.GET(\"/data\", restrictedHandler)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc loginHandler(c echo.Context) error {\n\treturn nil\n}\n\nfunc accessibleHandler(c echo.Context) error {\n\treturn nil\n}\n\nfunc restrictedHandler(c echo.Context) error {\n\treturn nil\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using the Echo framework in Go, with basic middleware and a simple route handler.\n\nFunction Description: The function `StartHTTPServer` initializes a new Echo instance, adds logger and recovery middleware, registers a GET route handler for the root path (\"/\"), and starts the HTTP server on the specified address.\n\nInput:  \n- `address` (string): The network address (e.g., \":8080\") on which the HTTP server should listen.\n\nOutput:  \n- `error`: Returns an error if the server fails to start; otherwise, it blocks until the server is stopped.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\treturn e.Start(address)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\treturn e.Start(address)\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that streams JSON-encoded location data with a delay between each transmission.\n\nFunction Description: The main function initializes an Echo server, sets up a GET route handler at the root path (\"/\") that streams location data as JSON with a 1-second delay between each location. The response uses proper HTTP headers for JSON content type and flushes after each location is sent.\n\nInput: None (The function takes no direct input parameters, but relies on a predefined 'locations' collection that should be available in scope)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and handles incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"encoding/json\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSON)\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\tfor _, l := range locations {\n\t\t\tif err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.Response().Flush()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\treturn nil\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar locations = []struct {\n\tLatitude  float64\n\tLongitude float64\n\tTimestamp string\n}{\n\t{37.7749, -122.4194, \"2023-10-01T12:00:00Z\"},\n\t{37.7750, -122.4195, \"2023-10-01T12:01:00Z\"},\n\t{37.7751, -122.4196, \"2023-10-01T12:02:00Z\"},\n}\n\nfunc main() {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tc.Response().SetHeader(\"Content-Type\", \"application/json\")\n\t\tw := c.Response().Writer\n\t\tfor _, loc := range locations {\n\t\t\tif err := json.NewEncoder(w).Encode(loc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif flushErr := w.Flush(); flushErr != nil {\n\t\t\t\treturn flushErr\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\treturn nil\n\t})\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves static files from an embedded filesystem using the go.rice package.\n\nFunction Description: The main function initializes an Echo web server, sets up route handlers for serving static files from an embedded directory (\"app\"), and starts the server on port 1323. The static files are served under the root path (\"/\") and a static prefix path (\"/static/*\").\n\nInput: None (The function takes no explicit parameters)\n\nOutput: None (The function doesn't return anything explicitly but starts an HTTP server that runs indefinitely until interrupted)\n\nNote: The reference code shows the complete implementation at the package level (main function) rather than as an isolated function or struct. The instruction follows the function-level format as the code primarily demonstrates functional behavior rather than object-oriented structure.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\tassetHandler := http.FileServer(rice.MustFindBox(\"app\").HTTPBox())\n\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", assetHandler)))\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo\"\n\t\"github.com/kr/rice\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tbox := rice.MustFindBox(\"app\")\n\tfs := box.HTTPBox()\n\n\te := echo.New()\n\te.GET(\"/\", echo.WrapHandler(http.FileServer(fs)))\n\te.GET(\"/static/*\", echo.WrapHandler(http.FileServer(fs)))\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various routes with authentication middleware and serves different endpoints for application management.\n\nFunction Description: The `serve` function initializes and starts an HTTP server using the Echo framework. It sets up route handlers for various endpoints related to application management, including upload, installation, renaming, and deletion of apps. The function also implements authentication middleware (BasicAuth and KeyAuth) to secure certain endpoints. The server runs on the specified host and port.\n\nInput: \n- `host` (string): The host address where the server will run (e.g., \"localhost\" or \"0.0.0.0\")\n- `port` (uint64): The port number on which the server will listen (e.g., 8080)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error, at which point it logs the error and exits)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc serve(host string, port uint64) {\n\te := echo.New()\n\te.HideBanner = true\n\n\tforcedBasicAuth := middleware.BasicAuth(func(username string, password string, c echo.Context) (bool, error) {\n\t\treturn username == config.Current.BasicAuth.Username && password == config.Current.BasicAuth.Password, nil\n\t})\n\tbasicAuth := func(f echo.HandlerFunc) echo.HandlerFunc {\n\t\tif config.Current.BasicAuth.Enable {\n\t\t\treturn forcedBasicAuth(f)\n\t\t} else {\n\t\t\treturn f\n\t\t}\n\t}\n\tworkflowKeyAuth := middleware.KeyAuth(func(s string, c echo.Context) (bool, error) {\n\t\treturn s == config.Current.BuilderKey, nil\n\t})\n\n\te.GET(\"/\", renderIndex, basicAuth)\n\te.GET(\"/favicon.png\", getFavIcon, basicAuth)\n\te.POST(\"/apps\", uploadUnsignedApp, basicAuth)\n\te.GET(\"/apps/:id/install\", appResolver(renderInstall))\n\te.GET(\"/apps/:id/manifest\", appResolver(getManifest))\n\te.GET(\"/apps/:id/resign\", appResolver(resignApp), basicAuth)\n\te.GET(\"/apps/:id/delete\", appResolver(deleteApp), basicAuth)\n\te.GET(\"/apps/:id/rename\", appResolver(renderRenameApp), basicAuth)\n\te.POST(\"/apps/:id/rename\", appResolver(renameApp), basicAuth)\n\te.GET(\"/apps/:id/2fa\", appResolver(render2FAPage), basicAuth)\n\te.POST(\"/apps/:id/2fa\", appResolver(set2FA), basicAuth)\n\te.GET(\"/jobs\", getLastJob, workflowKeyAuth)\n\te.GET(\"/jobs/:id/2fa\", jobResolver(get2FA), workflowKeyAuth)\n\te.POST(\"/jobs/:id/signed\", jobResolver(uploadSignedApp), workflowKeyAuth)\n\n\tlog.Fatal().Err(e.Start(fmt.Sprintf(\"%s:%d\", host, port))).Send()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"github.com/labstack/echo/v4\"\n)\n\nfunc serve(host string, port uint64) {\n    e := echo.New()\n    e.Logger.SetLevel(e.Logger.Level)\n\n    e.POST(\"/apps/upload\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Upload handled\")\n    }, echo.BasicAuth(func(username, password string, c echo.Context) (bool, error) {\n        if username == \"admin\" && password == \"secret\" {\n            return true, nil\n        }\n        return false, echo.NewHTTPError(http.StatusUnauthorized)\n    }))\n\n    e.POST(\"/apps/:id/install\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Install handled\")\n    }, echo.KeyAuth(func(token string, c echo.Context) (bool, error) {\n        if token == \"mytoken\" {\n            return true, nil\n        }\n        return false, echo.NewHTTPError(http.StatusUnauthorized)\n    }))\n\n    e.PUT(\"/apps/:id/rename\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Rename handled\")\n    }, echo.BasicAuth(func(username, password string, c echo.Context) (bool, error) {\n        if username == \"admin\" && password == \"secret\" {\n            return true, nil\n        }\n        return false, echo.NewHTTPError(http.StatusUnauthorized)\n    }))\n\n    e.DELETE(\"/apps/:id/delete\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Delete handled\")\n    }, echo.KeyAuth(func(token string, c echo.Context) (bool, error) {\n        if token == \"mytoken\" {\n            return true, nil\n        }\n        return false, echo.NewHTTPError(http.StatusUnauthorized)\n    }))\n\n    addr := fmt.Sprintf(\"%s:%d\", host, port)\n    if err := e.Start(addr); err != nil {\n        e.Logger.Fatal(err)\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves basic server information and runs on a configurable address.\n\nFunction Description: The main function initializes an Echo HTTP server, configures middleware for logging and compression, sets up a route handler for server information, and starts the server on the specified address.\n\nInput: \n- Command-line argument (optional): \"--addr\" to specify the server address (default: \"127.0.0.1:9090\")\n\nOutput: \n- Running HTTP server that responds to GET requests at \"/serverinfo\" with server hostname and address\n- No explicit return value (runs indefinitely until interrupted)\n\nNote: The reference code shows a complete implementation at the package level (main function) rather than a standalone function or struct level. The instruction follows the function-level format as the code primarily demonstrates functional behavior through the main function.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo\"\n\tmd \"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:9090\", \"addr for backend\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tserver := echo.New()\n\tserver.Use(md.Logger())\n\tserver.Use(md.Gzip())\n\n\tserver.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thostname, _ := os.Hostname()\n\t\treturn c.String(http.StatusOK, hostname+\"\\n\"+*addr)\n\t})\n\n\tserver.Start(*addr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"flag\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nvar addr string\n\nfunc main() {\n\tflag.StringVar(&addr, \"addr\", \"127.0.0.1:9090\", \"Server address\")\n\tflag.Parse()\n\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Compress())\n\te.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thostname, _ := os.Hostname()\n\t\treturn c.String(200, fmt.Sprintf(\"Hostname: %s, Address: %s\", hostname, addr))\n\t})\n\te.Logger.Fatal(e.Start(addr))\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests on two different endpoints (\"/request\" and \"/stream\") and serves over HTTPS.\n\nFunction Description: The main function initializes an Echo server instance, registers route handlers for two GET endpoints, and starts an HTTPS server using provided TLS certificate files.\n\nInput: None (The function takes no direct input parameters, but relies on external TLS certificate files \"cert.pem\" and \"key.pem\")\n\nOutput: None (The function doesn't return anything but starts a persistent HTTP server process)\n\nNote: The actual route handler functions (request and stream) would need to be implemented separately to handle the respective endpoints. The server will run indefinitely until interrupted, listening on port 1323 with TLS encryption.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/request\", request)\n\te.GET(\"/stream\", stream)\n\te.Logger.Fatal(e.StartTLS(\":1323\", \"cert.pem\", \"key.pem\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc requestHandler(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Hello from request\")\n}\n\nfunc streamHandler(c echo.Context) error {\n\treturn c.String(http.StatusOK, \"Hello from stream\")\n}\n\nfunc main() {\n\te := echo.New()\n\te.GET(\"/request\", requestHandler)\n\te.GET(\"/stream\", streamHandler)\n\n\tcert, err := tls.LoadX509KeyPair(\"cert.pem\", \"key.pem\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading certificates: %v\", err)\n\t}\n\ttlsConfig := &tls.Config{Certificates: []tls.Certificate{cert}}\n\tserver := &http.Server{\n\t\tAddr:      \":1323\",\n\t\tHandler:   e,\n\t\tTLSConfig: tlsConfig,\n\t}\n\n\tlog.Println(\"Starting HTTPS server on :1323\")\n\tif err := server.ListenAndServeTLS(\"\", \"\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic requests and includes middleware for processing statistics.\n\nStruct Description: The Stats struct is used to track and handle statistics for HTTP requests processed by the server.\n\nFields:\n- Count: [int] - Tracks the number of requests processed\n- StartTime: [time.Time] - Records the time when the server started processing requests\n\nMethods:\n- Process: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that increments the request count for each processed request\n- Handle: [func(c echo.Context) error] -> [error] - Handler function that returns the current statistics (request count and uptime) in JSON format\n- NewStats: [func() *Stats] -> [*Stats] - Constructor function that initializes a new Stats instance with default values\n\nAdditional Functions:\n- ServerHeader: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that adds a Server header to responses\n- main: [func()] -> [None] - Entry point that creates the Echo server, registers routes and middleware, and starts the server on port 1323",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Debug = true\n\n\ts := NewStats()\n\te.Use(s.Process)\n\te.GET(\"/stats\", s.Handle)\n\n\te.Use(ServerHeader)\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"time\"\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype Stats struct {\n\tCount    int\n\tStartTime time.Time\n}\n\nfunc NewStats() *Stats {\n\treturn &Stats{\n\t\tCount:    0,\n\t\tStartTime: time.Now(),\n\t}\n}\n\nfunc (s *Stats) Process(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\ts.Count++\n\t\treturn next(c)\n\t}\n}\n\nfunc (s *Stats) Handle(c echo.Context) error {\n\tuptime := time.Since(s.StartTime)\n\treturn c.JSON(200, map[string]interface{}{\n\t\t\"count\": s.Count,\n\t\t\"uptime\": uptime.String(),\n\t})\n}\n\nfunc ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tc.Response().Header().Set(\"Server\", \"Echo-Stats-Server\")\n\t\treturn next(c)\n\t}\n}\n\nfunc main() {\n\tstats := NewStats()\n\te := echo.New()\n\te.Use(stats.Process())\n\te.Use(ServerHeader)\n\te.GET(\"/stats\", stats.Handle)\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests and serves HTML content with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The main function initializes an Echo server, configures middleware for recovery and logging, sets up a route handler for the root path (\"/\") that returns HTML content, and starts the server with automatic TLS on port 443.\n\nInput: None (The function takes no explicit input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Recover())\n\te.Use(middleware.Logger())\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, `\n\t\t\t<h1>Welcome to Echo!</h1>\n\t\t\t<h3>TLS certificates automatically installed from Let's Encrypt :)</h3>\n\t\t`)\n\t})\n\te.Logger.Fatal(e.StartAutoTLS(\":443\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/xenolf/lego\"\n\t\"github.com/xenolf/lego/acme\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(echo.MiddlewareRecovery())\n\te.Use(echo.MiddlewareLogger())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, \"<h1>Hello, World!</h1>\")\n\t})\n\n\tconfig := lego.NewConfig(nil)\n\tconfig.CADirURL = acme.DirURL\n\tclient, _ := lego.NewClient(config)\n\n\tacmeServer := &http.Server{\n\t\tAddr: \":80\",\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// Handle ACME challenges\n\t\t\tif r.URL.Path == \"/.well-known/acme-challenge\" {\n\t\t\t\tw.Write([]byte(\"example_token\"))\n\t\t\t}\n\t\t}),\n\t}\n\n\tgo func() {\n\t\tif err := acmeServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Obtain certificate\n\t_, err := client.Registration.Register(context.Background(), lego.RegisterOptions{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\torder, err := client.Order.NewOrder(context.Background(), lego.ForceRSA2048, \"example.com\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor _, auth := range order.Authorizations {\n\t\tfor _, challenge := range auth.Challenges {\n\t\t\tif challenge.Type == acme.ChallengeHTTP {\n\t\t\t\t// Handle HTTP challenge\n\t\t\t\t// This is a simplified example\n\t\t\t\t// In a real scenario, you'd need to serve the token\n\t\t\t\t// and wait for the challenge to be validated\n\t\t\t\ttime.Sleep(5 * time.Second)\n\t\t\t}\n\t\t}\n\t}\n\n\tcert, _, err := client.Certificate.Obtain(context.Background(), order)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\te.Logger.Fatal(e.StartTLS(\":443\", cert.Cert.Pem, cert.PrivateKey.Pem))\n}"
  }
]