[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Implement a Go struct that represents a Docker registry repository client, capable of interacting with Docker registry API v2 to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct serves as a client for interacting with a Docker registry's repository, providing methods to access blob storage, manifests, and tag services. It maintains HTTP client configuration and URL building capabilities.\n\nFields:\n- client: *http.Client - Custom HTTP client configured with transport and redirect handling\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nTask Description: Implement a Go struct that represents a tag service for a Docker registry repository, capable of retrieving tag information from a Docker registry API v2.\n\nStruct Description: The `tags` struct provides tag-related operations for a Docker repository, implementing the distribution.TagService interface. It uses HTTP requests to interact with the registry's tag API endpoints.\n\nFields:\n- client: *http.Client - HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing tag-related API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves the descriptor for a specific tag, making HEAD and GET requests as needed to the registry API",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package distribution\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/docker/distribution/v2/reference\"\n\t\"github.com/docker/distribution/v2/registry/client/auth\"\n\t\"github.com/docker/distribution/v2/registry/client/transport\"\n\t\"github.com/docker/distribution/v2/registry/client/v2\"\n\t\"github.com/docker/distribution/v2/reference\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/blobs\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/manifest\"\n\t\"github.com/docker/distribution/v2/"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Go HTTP client struct that can make authenticated API requests with custom headers and handle responses, including error status codes.\n\nStruct Description: The Client struct represents an HTTP client with authentication credentials and endpoint configuration, capable of making various HTTP requests and processing responses.\n\nFields:\nUser: string - The username for basic authentication\nApiKey: string - The API key or password for basic authentication\nEndpoint: string - The base URL for API endpoints\n\nMethods:\nisOkStatus: [Name](code int) -> bool - Checks if the HTTP status code indicates a successful response (200, 201, 204 return true; 400, 404, 500, 409, 406 return false)\nnewRequest: [Name](method string, uri string, body interface{}) -> ([]byte, error) - Creates and executes an HTTP request with the given method, URI, and optional body. Returns the response body or an error if the request fails or returns a non-success status code. Automatically adds basic authentication headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tcodes := map[int]bool{\n\t\t200: true,\n\t\t201: true,\n\t\t204: true,\n\t\t400: false,\n\t\t404: false,\n\t\t500: false,\n\t\t409: false,\n\t\t406: false,\n\t}\n\n\treturn codes[code]\n}\n\nfunc (c *Client) newRequest(method, uri string, body interface{}) ([]byte, error) {\n\tvar (\n\t\tclient = &http.Client{}\n\t\turl    = fmt.Sprintf(\"%s/%s\", c.Endpoint, uri)\n\t\terr    error\n\t\treq    *http.Request\n\t)\n\n\tif body != nil {\n\t\tbodyJSON, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq, err = http.NewRequest(method, url, bytes.NewBuffer(bodyJSON))\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error with request: %v - %q\", url, err)\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\ttype apiErr struct {\n\t\t\tErr string `json:\"error\"`\n\t\t}\n\t\tvar outErr apiErr\n\t\tjson.Unmarshal(data, &outErr)\n\t\treturn nil, fmt.Errorf(\"Error in response: %s\", outErr.Err)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(status int) bool {\n\treturn status == 200 || status == 201 || status == 204\n}\n\nfunc (c *Client) newRequest(method string, uri string, body interface{}) ([]byte, error) {\n\tfullURL := c.Endpoint + uri\n\treq, err := http.NewRequest(method, fullURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tauthHeader := \"Basic \" + base64.StdLib.EncodeToString([]byte(c.User+\":\"+c.ApiKey))\n\treq.Header.Set(\"Authorization\", authHeader)\n\n\tif body != nil {\n\t\tbodyBytes, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\tbodyBytes, _ := io.ReadAll(resp.Body)\n\t\treturn nil, errors.New(string(bodyBytes))\n\t}\n\n\tbodyBytes, _ := io.ReadAll(resp.Body)\n\treturn bodyBytes, nil\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user authentication with JWT tokens. The server should have routes for login, accessible content, and restricted content that requires JWT authentication.\n\nFunction Description: The main function initializes an Echo server, configures middleware for logging and recovery, sets up route handlers for login and accessible content, and creates a restricted route group that requires JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger its handlers)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately but are referenced in this main function. The JWT configuration uses a custom claims structure (jwtCustomClaims) which should also be defined elsewhere.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tconfig := middleware.JWTConfig{\n\t\tClaims:     &jwtCustomClaims{},\n\t\tSigningKey: []byte(\"secret\"),\n\t}\n\tr.Use(middleware.JWTWithConfig(config))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\nvar jwtCustomClaims struct {\n\tUserID string `json:\"user_id\"`\n\tRole  string `json:\"role\"`\n\tjwt.StandardClaims\n}\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\t// Login route\n\te.POST(\"/login\", func(c echo.Context) error {\n\t\t// Implement login logic here\n\t\treturn c.JSON(200, map[string]string{\"token\": \"example_token\"})\n\t})\n\n\t// Accessible content route\n\te.GET(\"/accessible\", func(c echo.Context) error {\n\t\t// Implement accessible content logic here\n\t\treturn c.JSON(200, map[string]string{\"message\": \"Accessible content\"})\n\t})\n\n\t// Restricted content route group\n\trestrictedGroup := e.Group(\"/\")\n\trestrictedGroup.Use(func(c echo.Context) error {\n\t\t// Implement JWT authentication logic here\n\t\treturn c.Next()\n\t})\n\n\trestrictedGroup.GET(\"/restricted\", func(c echo.Context) error {\n\t\t// Implement restricted content logic here\n\t\treturn c.JSON(200, map[string]string{\"message\": \"Restricted content\"})\n\t})\n\n\te.Listen(\":1323\")\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a function to retrieve metadata and ETag from Google Compute Engine (GCE) metadata server using a custom HTTP client with specific timeout configurations.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the GCE metadata server to fetch metadata value and its associated ETag. It uses a pre-configured HTTP client with custom timeout settings and adds required headers to the request. The function handles various response scenarios including not found errors and non-200 status codes.\n\nInput:\n- suffix [string]: The metadata path suffix to append to the base metadata URL\n\nOutput:\n- value [string]: The retrieved metadata value\n- etag [string]: The ETag header value from the response\n- err [error]: Error object if any error occurs during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/cloud/internal\"\n)\n\nvar metaClient = &http.Client{\n\tTransport: &internal.Transport{\n\t\tBase: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   750 * time.Millisecond,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 750 * time.Millisecond,\n\t\t},\n\t},\n}\n\nfunc getETag(suffix string) (value, etag string, err error) {\n\thost := os.Getenv(\"GCE_METADATA_HOST\")\n\tif host == \"\" {\n\t\thost = \"169.254.169.254\"\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\tres, err := metaClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc getETag(suffix string) (string, string, error) {\n\tbaseURL := \"http://169.254.169.254/2023-07-01/meta-data\"\n\turl := baseURL + suffix\n\n\tclient := &http.Client{\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn \"\", \"\", fmt.Errorf(\"non-200 status code: %d - %s\", resp.StatusCode, body)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tetag := resp.Header.Get(\"ETag\")\n\tif etag == \"\" {\n\t\treturn \"\", \"\", errors.New(\"no ETag in response\")\n\t}\n\n\treturn string(body), etag, nil\n}"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Implement a Fiber-based HTTP server in Go that handles Amazon SQS (Simple Queue Service) API requests, including authentication, routing, and various SQS operations.\n\nStruct Description: The SQS struct represents an HTTP server that processes Amazon SQS API requests. It uses Fiber framework for HTTP handling and includes queue management functionality with tenant isolation.\n\nFields:\n\nApp: *fiber.App - Fiber application instance for HTTP server\nqueue: models.Queue - Queue management interface\ntenantManager: models.TenantManager - Tenant management interface\ncfg: config.SQSConfig - Configuration for the SQS server\n\nMethods:\n\nNewSQS: (queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) -> *SQS - Constructor that initializes the SQS server with dependencies and configuration\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nAction: (c *fiber.Ctx) -> error - Main request handler that routes SQS API requests based on X-Amz-Target header\nSendMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessage SQS operation\nSendMessageBatch: (c *fiber.Ctx, tenantId int64) -> error - Handles SendMessageBatch SQS operation\nReceiveMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles ReceiveMessage SQS operation\nDeleteMessage: (c *fiber.Ctx, tenantId int64) -> error - Handles DeleteMessage SQS operation\nListQueues: (c *fiber.Ctx, tenantId int64) -> error - Handles ListQueues SQS operation\nGetQueueURL: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueUrl SQS operation\nCreateQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles CreateQueue SQS operation\nGetQueueAttributes: (c *fiber.Ctx, tenantId int64) -> error - Handles GetQueueAttributes SQS operation\nPurgeQueue: (c *fiber.Ctx, tenantId int64) -> error - Handles PurgeQueue SQS operation\nChangeMessageVisibility: (c *fiber.Ctx, tenantId int64) -> error - Handles ChangeMessageVisibility SQS operation\nerrorHandler: (ctx *fiber.Ctx, err error) -> error - Custom error handler for the Fiber app\nauthMiddleware: (c *fiber.Ctx) -> error - Authentication middleware for tenant validation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/valyala/fasthttp/fasthttpadaptor\"\n)\n\ntype SQS struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\ts := &SQS{\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t\tErrorHandler:          s.errorHandler,\n\t\tBodyLimit:             cfg.MaxRequestSize,\n\t})\n\n\tapp.Use(s.authMiddleware)\n\tapp.Post(\"/*\", s.Action)\n\n\ts.App = app\n\n\treturn s\n}\n\nfunc (s *SQS) Start() error {\n\tif !s.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"SQS Endpoint: http://localhost:%d\\n\", s.cfg.Port)\n\treturn s.App.Listen(fmt.Sprintf(\":%d\", s.cfg.Port))\n}\n\nfunc (s *SQS) Stop() error {\n\tif s.cfg.Enabled {\n\t\treturn s.App.Shutdown()\n\t}\n\treturn nil\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\tawsMethodHeader, ok := c.GetReqHeaders()[\"X-Amz-Target\"]\n\tif !ok {\n\t\treturn errors.New(\"X-Amz-Target header not found\")\n\t}\n\tawsMethod := awsMethodHeader[0]\n\n\tvar r *http.Request = &http.Request{}\n\tfasthttpadaptor.ConvertRequest(c.Context(), r, false)\n\n\ttenantId := c.Locals(\"tenantId\").(int64)\n\n\tvar rc error\n\tswitch awsMethod {\n\tcase \"AmazonSQS.SendMessage\":\n\t\trc = s.SendMessage(c, tenantId)\n\tcase \"AmazonSQS.SendMessageBatch\":\n\t\trc = s.SendMessageBatch(c, tenantId)\n\tcase \"AmazonSQS.ReceiveMessage\":\n\t\trc = s.ReceiveMessage(c, tenantId)\n\tcase \"AmazonSQS.DeleteMessage\":\n\t\trc = s.DeleteMessage(c, tenantId)\n\tcase \"AmazonSQS.ListQueues\":\n\t\trc = s.ListQueues(c, tenantId)\n\tcase \"AmazonSQS.GetQueueUrl\":\n\t\trc = s.GetQueueURL(c, tenantId)\n\tcase \"AmazonSQS.CreateQueue\":\n\t\trc = s.CreateQueue(c, tenantId)\n\tcase \"AmazonSQS.GetQueueAttributes\":\n\t\trc = s.GetQueueAttributes(c, tenantId)\n\tcase \"AmazonSQS.PurgeQueue\":\n\t\trc = s.PurgeQueue(c, tenantId)\n\tcase \"AmazonSQS.ChangeMessageVisibility\":\n\t\trc = s.ChangeMessageVisibility(c, tenantId)\n\tdefault:\n\t\trc = NewSQSError(400, \"UnsupportedOperation\", fmt.Sprintf(\"SQS method %s not implemented\", awsMethod))\n\t}\n\n\treturn rc\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "wrong_result": "package sqs\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/logger\"\n\t\"github.com/gofiber/fiber/v2/middleware/recover\"\n)\n\ntype SQS struct {\n\tApp        *fiber.App\n\tqueue      models.Queue\n\ttenantManager models.TenantManager\n\tcfg        config.SQSConfig\n}\n\nfunc NewSQS(queue models.Queue, tenantManager models.TenantManager, cfg config.SQSConfig) *SQS {\n\tsqs := &SQS{\n\t\tqueue:      queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:        cfg,\n\t}\n\tsqs.App = fiber.New()\n\tsqs.App.Use(recover.New())\n\tsqs.App.Use(logger.New())\n\tsqs.App.Use(sqs.authMiddleware)\n\tsqs.setupRoutes()\n\treturn sqs\n}\n\nfunc (s *SQS) Start() error {\n\tif s.cfg.ListenAddress != \"\" && s.cfg.Port > 0 {\n\t\treturn s.App.Listen(s.cfg.ListenAddress + \":\" + s.cfg.Port)\n\t}\n\treturn nil\n}\n\nfunc (s *SQS) Stop() error {\n\treturn s.App.Shutdown()\n}\n\nfunc (s *SQS) Action(c *fiber.Ctx) error {\n\ttarget := c.Header(\"X-Amz-Target\")\n\tswitch target {\n\tcase \"AmazonSQSv20020613.CreateQueue\":\n\t\treturn s.CreateQueue(c, -1)\n\tcase \"AmazonSQSv20020613.DeleteMessage\":\n\t\treturn s.DeleteMessage(c, -1)\n\tcase \"AmazonSQSv20020613.GetQueueAttributes\":\n\t\treturn s.GetQueueAttributes(c, -1)\n\tcase \"AmazonSQSv20020613.GetQueueUrl\":\n\t\treturn s.GetQueueURL(c, -1)\n\tcase \"AmazonSQSv20020613.ListQueues\":\n\t\treturn s.ListQueues(c, -1)\n\tcase \"AmazonSQSv20020613.PurgeQueue\":\n\t\treturn s.PurgeQueue(c, -1)\n\tcase \"AmazonSQSv20020613.ReceiveMessage\":\n\t\treturn s.ReceiveMessage(c, -1)\n\tcase \"AmazonSQSv20020613.SendMessage\":\n\t\treturn s.SendMessage(c, -1)\n\tcase \"AmazonSQSv20020613.SendMessageBatch\":\n\t\treturn s.SendMessageBatch(c, -1)\n\tcase \"AmazonSQSv20020613.ChangeMessageVisibility\":\n\t\treturn s.ChangeMessageVisibility(c, -1)\n\tdefault:\n\t\treturn s.errorHandler(c, fiber.NewError(fiber.StatusNotFound, \"Unknown SQS API target\"))\n\t}\n}\n\nfunc (s *SQS) SendMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for SendMessage\n\treturn nil\n}\n\nfunc (s *SQS) SendMessageBatch(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for SendMessageBatch\n\treturn nil\n}\n\nfunc (s *SQS) ReceiveMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ReceiveMessage\n\treturn nil\n}\n\nfunc (s *SQS) DeleteMessage(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for DeleteMessage\n\treturn nil\n}\n\nfunc (s *SQS) ListQueues(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ListQueues\n\treturn nil\n}\n\nfunc (s *SQS) GetQueueURL(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for GetQueueURL\n\treturn nil\n}\n\nfunc (s *SQS) CreateQueue(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for CreateQueue\n\treturn nil\n}\n\nfunc (s *SQS) GetQueueAttributes(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for GetQueueAttributes\n\treturn nil\n}\n\nfunc (s *SQS) PurgeQueue(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for PurgeQueue\n\treturn nil\n}\n\nfunc (s *SQS) ChangeMessageVisibility(c *fiber.Ctx, tenantId int64) error {\n\t// Implementation for ChangeMessageVisibility\n\treturn nil\n}\n\nfunc (s *SQS) errorHandler(ctx *fiber.Ctx, err error) error {\n\treturn ctx.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\n\t\t\"error\": err.Error(),\n\t})\n}\n\nfunc (s *SQS) authMiddleware(c *fiber.Ctx) error {\n\t// Implementation for authentication and tenant validation\n\treturn nil\n}\n\nfunc (s *SQS) setupRoutes() {\n\ts.App.Post(\"/SendMessage\", s.Action)\n\ts.App.Post(\"/SendMessageBatch\", s.Action)\n\ts.App.Post(\"/ReceiveMessage\", s.Action)\n\ts.App.Post(\"/DeleteMessage\", s.Action)\n\ts.App.Post(\"/ListQueues\", s.Action)\n\ts.App.Post(\"/GetQueueURL\", s.Action)\n\ts.App.Post(\"/CreateQueue\", s.Action)\n\ts.App.Post(\"/GetQueueAttributes\", s.Action)\n\ts.App.Post(\"/PurgeQueue\", s.Action)\n\ts.App.Post(\"/ChangeMessageVisibility\", s.Action)\n}"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using Gin framework with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a simple GET route handler, configures automatic TLS certificate management using autocert, and starts the HTTPS server. The server will automatically obtain and renew TLS certificates from Let's Encrypt for specified domains.\n\nInput: None (The function takes no parameters as all configurations are internally defined)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely. It will log.Fatal if there's an error starting the server.)\n\nNote: The function demonstrates a complete setup for a production-ready HTTPS server with automatic certificate management. The domains and cache directory are hardcoded in this example but could be parameterized in a real implementation.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tlog.Fatal(autotls.RunWithManager(r, m))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc initSecureServer() {\n\t// Define domains and cache directory\n\tdomains := []string{\"example.com\", \"www.example.com\"}\n\tcacheDir := \"./acme-cache\"\n\n\t// Create autocert manager\n\tmanager := autocert.NewManager(\n\t\t&autocert.Manager{\n\t\t\tPrompt:     autocert.PromptDefault,\n\t\t\tCache:      autocert.Cache{Dir: cacheDir},\n\t\t\tHTTPClient: &http.Client{Timeout: 30 * time.Second},\n\t\t},\n\t\tdomains...,\n\t)\n\n\t// Initialize Gin router\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\t// Define a simple GET route\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"Hello from secure HTTPS server with automatic TLS!\",\n\t\t})\n\t})\n\n\t// Start HTTPS server\n\tsrv := &http.Server{\n\t\tHandler: r,\n\t\tAddr:    \":443\",\n\t}\n\n\t// Serve HTTPS with automatic certificate management\n\terr := srv.ListenAndServeTLS(\"\", \"\", manager)\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a Go struct representing a Docker registry repository client that can interact with a Docker registry API to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct represents a client for interacting with a Docker registry repository. It provides methods to access blob storage, manifests, and tags through the Docker Registry HTTP API V2.\n\nFields:\n- client: *http.Client - Custom HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nAdditional Struct: `tags` - Handles tag operations for a Docker repository\n\nFields:\n- client: *http.Client - HTTP client for making requests\n- ub: *v2.URLBuilder - URL builder for API endpoints\n- name: reference.Named - Named reference to the repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves descriptor information for a specific tag, first trying HEAD request and falling back to GET if needed",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package dockerregistry\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\tdistribution \"github.com/docker/distribution/v2\"\n\treference \"github.com/docker/reference\"\n\tv2 \"github.com/docker/trust/v2/remote/oci\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn distribution.NewBlobStore(r.client, r.ub, r.name)\n}\n\nfunc (r *repository) Manifests(ctx context.Context, opts ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn distribution.NewManifestService(r.client, r.ub, r.name, opts...)\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\turl := t.ub.Build(t.name.String(), \"tags\", tag, \"latest\")\n\treq, err := http.NewRequest(\"HEAD\", url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\t// Handle HEAD response\n\t\treturn distribution.Descriptor{}, nil\n\t}\n\n\t// If HEAD fails, try GET\n\treq, err = http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tresp, err = t.client.Do(req)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Parse the response for descriptor\n\t// This is a simplified example; actual parsing would require more detailed handling\n\treturn distribution.Descriptor{}, nil\n}"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin-based HTTP server with TLS support, serving HTML content and static assets, while also implementing HTTP/2 server push for static resources.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), sets up static file serving, configures HTML templates, implements HTTP/2 server push for static assets, and starts the server with TLS encryption. It handles requests to the root path (\"/\") by returning HTML content and pushing a JavaScript file to the client.\n\nInput:\n- port (string): The port number to listen on (e.g., \":8080\")\n- certFile (string): Path to the TLS certificate file (e.g., \"./testdata/server.pem\")\n- keyFile (string): Path to the TLS private key file (e.g., \"./testdata/server.key\")\n- htmlTemplates (template.Template): HTML templates to be used for rendering\n- staticDir (string): Directory path for static assets (e.g., \"./assets\")\n\nOutput: None (the function runs indefinitely as a web server)",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Static(\"/assets\", \"./assets\")\n\tr.SetHTMLTemplate(html)\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tif pusher := c.Writer.Pusher(); pusher != nil {\n\t\t\tif err := pusher.Push(\"/assets/app.js\", nil); err != nil {\n\t\t\t\tlog.Printf(\"Failed to push: %v\", err)\n\t\t\t}\n\t\t}\n\t\tc.HTML(200, \"https\", gin.H{\n\t\t\t\"status\": \"success\",\n\t\t})\n\t})\n\n\tr.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc startTLSServer(port, certFile, keyFile, staticDir string, htmlTemplates *template.Template) {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.LoadHTMLTemplates(htmlTemplates.Name())\n\n\tr.StaticFS(staticDir, http.Dir(staticDir))\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.html\", nil)\n\t\tr.PushHandler(func(c *gin.Context) {\n\t\t\tc.FileFromPath(staticDir + \"/js/script.js\")\n\t\t})\n\t})\n\n\terr := http.ListenAndServeTLS(port, certFile, keyFile, r)\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n}"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests for inventory operations, specifically for trying inventory items. The server should parse JSON input, process the inventory try operation, and return appropriate JSON responses.\n\nFunction Description: The main function sets up a Gin HTTP server with a single POST endpoint \"/service-c/try\" that accepts JSON inventory data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- HTTP POST request with JSON body containing inventory data (structure not shown in reference code but implied to have an ID field)\n- Gin context object providing request/response capabilities\n\nOutput:\n- Success case (200 status):\n  ```json\n  {\n    \"success\": true,\n    \"message\": \"inventory [ID] tried!\"\n  }\n  ```\n- Error case (400 status):\n  ```json\n  {\n    \"success\": false,\n    \"message\": \"[error description]\"\n  }\n  ```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-c/try\", func(context *gin.Context) {\n\t\tinv := &Inventory{}\n\t\terr := context.BindJSON(inv)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"inventory %d tried!\", inv.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"inventory %d tried!\", inv.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8082\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\ntype InventoryTryRequest struct {\n\tID string `json:\"id\" binding:\"required\"`\n}\n\nfunc tryInventory(c *gin.Context) {\n\tvar req InventoryTryRequest\n\tif err := c.BindJSON(&req); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": \"Invalid JSON format\",\n\t\t})\n\t\treturn\n\t}\n\n\t// Simulate inventory try operation\n\t// In a real scenario, this would interact with a database or inventory system\n\tif req.ID == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": \"Inventory ID is required\",\n\t\t})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"success\": true,\n\t\t\"message\": \"inventory \" + req.ID + \" tried!\",\n\t})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/service-c/try\", tryInventory)\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that retrieves metadata from a metadata server using a custom HTTP client, with support for ETag headers and error handling.\n\nFunction Description: The function `getETag` makes an HTTP GET request to a metadata server endpoint, using a custom HTTP client with specific timeout configurations. It handles the response by checking status codes, reading the response body, and extracting both the content and ETag header. The function includes error handling for various scenarios including connection errors, missing resources, and non-200 status codes.\n\nInput:\n- client *http.Client: A custom HTTP client with configured timeouts for the request\n- suffix string: The path suffix to append to the base metadata URL\n\nOutput:\n- value string: The content of the response body as a string\n- etag string: The ETag header value from the response\n- err error: An error object if any step fails, nil on success",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "func getETag(client *http.Client, suffix string) (value string, etag string, err error) {\n\treq, err := http.NewRequest(\"GET\", \"https://metadata.google.internal/computeMetadata/v1/instance/\"+suffix, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"If-Match\", \"*\")\n\treq.Header.Set(\"If-None-Match\", \"*\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", \"go/1.20\")\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Cache-Control\", \"no-cache\")\n\treq.Header.Set(\"Connection\", \"close\")\n\treq.Header.Set(\"Accept-Encoding\", \"gzip\")\n\treq.Header.Set(\"Accept-Language\", \"en-US\")\n\treq.Header.Set(\"Accept-Charset\", \"utf-8\")\n\treq.Header.Set(\"Authorization\", \"Bearer <token>\")\n\treq.Header.Set(\"X-Goog-User-Project\", \"project-id\")\n\treq.Header.Set(\"X-Goog-Algorithm\", \"HMAC_SHA256\")\n\treq.Header.Set(\"X-Goog-Credential\", \"<credential>\")\n\treq.Header.Set(\"X-Goog-Date\", \"<date>\")\n\treq.Header.Set(\"X-Goog-Signature\", \"<signature>\")\n\treq.Header.Set(\"X-Goog-Resource-ID\", \"<resource-id>\")\n\treq.Header.Set(\"X-Goog-Region\", \"<region>\")\n\treq.Header.Set(\"X-Goog-Service\", \"<service>\")\n\treq.Header.Set(\"X-Goog-Instance-Id\", \"<instance-id>\")\n\treq.Header.Set(\"X-Goog-Instance-Name\", \"<instance-name>\")\n\treq.Header.Set(\"X-Goog-Instance-Project\", \"<project-id>\")\n\treq.Header.Set(\"X-Goog-Instance-Zone\", \"<zone>\")\n\treq.Header.Set(\"X-Goog-Instance-Status\", \"<status>\")\n\treq.Header.Set(\"X-Goog-Instance-Health\", \"<health>\")\n\treq.Header.Set(\"X-Goog-Instance-Description\", \"<description>\")\n\treq.Header.Set(\"X-Goog-Instance-Labels\", \"<labels>\")\n\treq.Header.Set(\"X-Goog-Instance-Tags\", \"<tags>\")\n\treq.Header.Set(\"X-Goog-Instance-Disks\", \"<disks>\")\n\treq.Header.Set(\"X-Goog-Instance-Networks\", \"<networks>\")\n\treq.Header.Set(\"X-Goog-Instance-Interfaces\", \"<interfaces>\")\n\treq.Header.Set(\"X-Goog-Instance-IPs\", \"<ips>\")\n\treq.Header.Set(\"X-Goog-Instance-OS\", \"<os>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Version\", \"<os-version>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Architecture\", \"<os-architecture>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Release\", \"<os-release>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Volume\", \"<boot-volume>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Volume\", \"<root-volume>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Volumes\", \"<data-volumes>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Volume\", \"<system-volume>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Device\", \"<boot-device>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Device\", \"<root-device>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Devices\", \"<data-devices>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Device\", \"<system-device>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition\", \"<boot-partition>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition\", \"<root-partition>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partitions\", \"<data-partitions>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition\", \"<system-partition>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem\", \"<boot-filesystem>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem\", \"<root-filesystem>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystems\", \"<data-filesystems>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem\", \"<system-filesystem>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Size\", \"<boot-partition-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Size\", \"<root-partition-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Size\", \"<data-partition-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Size\", \"<system-partition-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Size\", \"<boot-filesystem-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Size\", \"<root-filesystem-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Size\", \"<data-filesystem-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Size\", \"<system-filesystem-size>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Used\", \"<boot-partition-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Used\", \"<root-partition-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Used\", \"<data-partition-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Used\", \"<system-partition-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Used\", \"<boot-filesystem-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Used\", \"<root-filesystem-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Used\", \"<data-filesystem-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Used\", \"<system-filesystem-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Free\", \"<boot-partition-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Free\", \"<root-partition-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Free\", \"<data-partition-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Free\", \"<system-partition-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Free\", \"<boot-filesystem-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Free\", \"<root-filesystem-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Free\", \"<data-filesystem-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Free\", \"<system-filesystem-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used\", \"<boot-partition-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used\", \"<root-partition-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used\", \"<data-partition-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used\", \"<system-partition-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used\", \"<boot-filesystem-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used\", \"<root-filesystem-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used\", \"<data-filesystem-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used\", \"<system-filesystem-percent-used>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free\", \"<boot-partition-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free\", \"<root-partition-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free\", \"<data-partition-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free\", \"<system-partition-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free\", \"<boot-filesystem-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free\", \"<root-filesystem-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free\", \"<data-filesystem-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free\", \"<system-filesystem-percent-free>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total\", \"<boot-partition-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total\", \"<root-partition-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total\", \"<data-partition-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total\", \"<system-partition-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total\", \"<boot-filesystem-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total\", \"<root-filesystem-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total\", \"<data-filesystem-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total\", \"<system-filesystem-percent-used-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total\", \"<boot-partition-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total\", \"<root-partition-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total\", \"<data-partition-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total\", \"<system-partition-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total\", \"<boot-filesystem-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total\", \"<root-filesystem-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total\", \"<data-filesystem-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total\", \"<system-filesystem-percent-free-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent\", \"<boot-partition-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent\", \"<root-partition-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent\", \"<data-partition-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent\", \"<system-partition-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent\", \"<boot-filesystem-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent\", \"<root-filesystem-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent\", \"<data-filesystem-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent\", \"<system-filesystem-percent-used-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent\", \"<boot-partition-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent\", \"<root-partition-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent\", \"<data-partition-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent\", \"<system-partition-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent\", \"<boot-filesystem-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent\", \"<root-filesystem-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent\", \"<data-filesystem-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent\", \"<system-filesystem-percent-free-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total\", \"<boot-partition-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total\", \"<root-partition-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total\", \"<data-partition-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total\", \"<system-partition-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total\", \"<boot-filesystem-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total\", \"<root-filesystem-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total\", \"<data-filesystem-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total\", \"<system-filesystem-percent-used-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total\", \"<boot-partition-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total\", \"<root-partition-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total\", \"<data-partition-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total\", \"<system-partition-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total\", \"<boot-filesystem-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total\", \"<root-filesystem-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total\", \"<data-filesystem-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total\", \"<system-filesystem-percent-free-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent\", \"<boot-partition-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent\", \"<root-partition-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent\", \"<data-partition-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent\", \"<system-partition-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent\", \"<root-filesystem-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent\", \"<data-filesystem-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent\", \"<system-filesystem-percent-used-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent\", \"<boot-partition-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent\", \"<root-partition-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent\", \"<data-partition-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent\", \"<system-partition-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent\", \"<root-filesystem-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent\", \"<data-filesystem-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent\", \"<system-filesystem-percent-free-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total\", \"<system-filesystem-percent-used-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total\", \"<system-filesystem-percent-free-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<boot-partition-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<root-partition-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<data-partition-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<system-partition-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<root-filesystem-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<data-filesystem-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent\", \"<system-filesystem-percent-used-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<boot-partition-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<root-partition-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<data-partition-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<system-partition-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<root-filesystem-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<data-filesystem-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent\", \"<system-filesystem-percent-free-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-filesystem-percent-used-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-filesystem-percent-free-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<boot-partition-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<root-partition-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<data-partition-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<system-partition-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<root-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<data-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<system-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<boot-partition-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<root-partition-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<data-partition-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<system-partition-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<boot-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<root-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<data-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent\", \"<system-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Used-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-filesystem-percent-used-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-partition-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-partition-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-partition-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Partition-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<system-partition-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Boot-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<boot-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Root-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<root-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-Data-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\", \"<data-filesystem-percent-free-total-percent-total-percent-total-percent-total-percent-total>\")\n\treq.Header.Set(\"X-Goog-Instance-OS-System-Filesystem-Percent-Free-Total-Percent-Total-Percent-Total-Percent-Total-Percent-Total\","
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles multiple API routes with different authentication requirements and groups related endpoints together.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), organizes routes into logical groups with different authentication requirements, and starts the server. It demonstrates route grouping, middleware chaining, and modular route registration.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens for incoming requests)\n\nNote: The actual route handlers are expected to be implemented in separate packages (users, articles) and registered through their respective Register functions. The server runs indefinitely until interrupted.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tv1 := r.Group(\"/api\")\n\tusers.UsersRegister(v1.Group(\"/users\"))\n\tv1.Use(users.AuthMiddleware(false))\n\tarticles.ArticlesAnonymousRegister(v1.Group(\"/articles\"))\n\tarticles.TagsAnonymousRegister(v1.Group(\"/tags\"))\n\n\tv1.Use(users.AuthMiddleware(true))\n\tusers.UserRegister(v1.Group(\"/user\"))\n\tusers.ProfileRegister(v1.Group(\"/profiles\"))\n\n\tarticles.ArticlesRegister(v1.Group(\"/articles\"))\n\n\ttestAuth := r.Group(\"/api/ping\")\n\n\ttestAuth.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\n\tr.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\t// User routes with authentication\n\tuserGroup := r.Group(\"/users\")\n\tuserGroup.Use(AuthMiddleware())\n\t{\n\t\tuserGroup.POST(\"/\", users.Register)\n\t\tuserGroup.GET(\"/:id\", users.Register)\n\t\tuserGroup.PUT(\"/:id\", users.Register)\n\t\tuserGroup.DELETE(\"/:id\", users.Register)\n\t}\n\n\t// Article routes with basic authentication\n\tarticleGroup := r.Group(\"/articles\")\n\tarticleGroup.Use(BasicAuthMiddleware())\n\t{\n\t\tarticleGroup.POST(\"/\", articles.Register)\n\t\tarticleGroup.GET(\"/:id\", articles.Register)\n\t\tarticleGroup.PUT(\"/:id\", articles.Register)\n\t\tarticleGroup.DELETE(\"/:id\", articles.Register)\n\t}\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, with endpoints for basic operations including ping, info retrieval, and counter manipulation with thread-safe increment/reset functionality.\n\nFunction Description: The Run function initializes a Gin HTTP server with four API endpoints under the \"/api/v1\" route group. It handles concurrent counter operations safely using mutex locks and logs requests using klog. The server runs on the specified address from the Options parameter.\n\nInput: \n- op *Options: A pointer to an Options struct containing the ListenAddr field specifying the server's listening address (e.g., \":8080\")\n\nOutput:\n- error: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nStruct Description: (Not applicable as the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"k8s.io/klog/v2\"\n)\n\nvar (\n\tCount int\n\tMutex sync.Mutex\n)\n\nfunc Run(op *Options) error {\n\tr := gin.Default()\n\n\tapiv1 := r.Group(\"/api/v1\")\n\t{\n\t\tapiv1.GET(\"/ping\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\")\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"pong\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.GET(\"/info\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": \"app3\",\n\t\t\t})\n\t\t})\n\n\t\tapiv1.PUT(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount += 1\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app3: %d\", Count),\n\t\t\t})\n\t\t})\n\n\t\tapiv1.DELETE(\"/count\", func(c *gin.Context) {\n\t\t\tklog.InfoS(\"Accept request.\", \"headers\", c.Request.Header)\n\n\t\t\tMutex.Lock()\n\t\t\tCount = 0\n\t\t\tMutex.Unlock()\n\n\t\t\tklog.InfoS(\"app-3 info\", \"count\", Count)\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"message\": fmt.Sprintf(\"app1: %d\", Count),\n\t\t\t})\n\t\t})\n\t}\n\n\treturn r.Run(op.ListenAddr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"klog\"\n)\n\ntype Options struct {\n\tListenAddr string\n}\n\nfunc Run(op *Options) error {\n\tr := gin.New()\n\tr.Use(gin.Logger())\n\n\tvar counter int\n\tvar mu sync.Mutex\n\n\tr.Group(\"/api/v1\").Handle(\"GET\", \"/ping\", func(c *gin.Context) {\n\t\tklog.Info(\"Ping endpoint called\")\n\t\tc.JSON(http.StatusOK, map[string]string{\"message\": \"pong\"})\n\t})\n\n\tr.Group(\"/api/v1\").Handle(\"GET\", \"/info\", func(c *gin.Context) {\n\t\tklog.Info(\"Info endpoint called\")\n\t\tc.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"counter\": counter,\n\t\t})\n\t})\n\n\tr.Group(\"/api/v1\").Handle(\"POST\", \"/increment\", func(c *gin.Context) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tcounter++\n\t\tklog.Infof(\"Counter incremented to %d\", counter)\n\t\tc.JSON(http.StatusOK, map[string]int{\"counter\": counter})\n\t})\n\n\tr.Group(\"/api/v1\").Handle(\"POST\", \"/reset\", func(c *gin.Context) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tcounter = 0\n\t\tklog.Info(\"Counter reset to 0\")\n\t\tc.JSON(http.StatusOK, map[string]int{\"counter\": counter})\n\t})\n\n\treturn r.Run(op.ListenAddr)\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a Go struct that provides HTTP client functionality for making GET and POST requests with custom headers and query parameters.\n\nStruct Description: The `request` struct encapsulates HTTP client operations, providing methods to perform GET and POST requests with support for custom headers and query parameters. It handles URL construction, request execution, and response processing.\n\nFields:\n[Note: The reference implementation doesn't show any struct fields, as it's a stateless utility struct]\n\nMethods:\n\nMethod1: HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) -> ([]byte, int, error) - Performs an HTTP GET request to the specified URL with the given query parameters and headers. Returns the response body as bytes, status code, and any error.\n\nMethod2: HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) -> ([]byte, int, error) - Performs an HTTP POST request to the specified URL with the given form data (as query parameters) and headers. Returns the response body as bytes, status code, and any error.\n\nMethod3: QueryBuilder(queryUrl string, queryValues map[string]string) -> string - Helper method that constructs a URL with query parameters from the given base URL and parameter map. Handles URL encoding of parameters.",
    "Canonical_solution": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nvar Request = NewRequest()\n\ntype request struct {\n}\n\nfunc NewRequest() *request {\n\treturn &request{}\n}\n\nfunc (r *request) HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) (body []byte, code int, err error) {\n\treq, err := http.NewRequest(\"GET\", r.QueryBuilder(queryUrl, queryValues), nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tif (headerValues != nil) && (len(headerValues) > 0) {\n\t\tfor key, value := range headerValues {\n\t\t\treq.Header.Set(key, value)\n\t\t}\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn\n\t}\n\tcode = resp.StatusCode\n\tdefer resp.Body.Close()\n\n\tbodyByte, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn bodyByte, code, nil\n}\n\nfunc (r *request) HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) (body []byte, code int, err error) {\n\tif !strings.Contains(queryUrl, \"?\") {\n\t\tqueryUrl += \"?\"\n\t}\n\tqueryString := \"\"\n\tfor queryKey, queryValue := range queryValues {\n\t\tqueryString = queryString + \"&\" + queryKey + \"=\" + url.QueryEscape(queryValue)\n\t}\n\tqueryString = strings.Replace(queryString, \"&\", \"\", 1)\n\n\treq, err := http.NewRequest(\"POST\", queryUrl, strings.NewReader(queryString))\n\tif err != nil {\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tif (headerValues != nil) && (len(headerValues) > 0) {\n\t\tfor key, value := range headerValues {\n\t\t\treq.Header.Set(key, value)\n\t\t}\n\t}\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn\n\t}\n\tcode = resp.StatusCode\n\tdefer resp.Body.Close()\n\n\tbodyByte, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn bodyByte, code, nil\n}\n\nfunc (r *request) QueryBuilder(queryUrl string, queryValues map[string]string) string {\n\tif !strings.Contains(queryUrl, \"?\") {\n\t\tqueryUrl += \"?\"\n\t}\n\n\tqueryString := \"\"\n\tfor queryKey, queryValue := range queryValues {\n\t\tqueryString = queryString + \"&\" + queryKey + \"=\" + url.QueryEscape(queryValue)\n\t}\n\tqueryString = strings.Replace(queryString, \"&\", \"\", 1)\n\tqueryUrl += queryString\n\n\treturn queryUrl\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sort\"\n\t\"unicode\"\n)\n\ntype request struct{}\n\nfunc (r *request) HttpGet(queryUrl string, queryValues map[string]string, headerValues map[string]string) ([]byte, int, error) {\n\turl := r.QueryBuilder(queryUrl, queryValues)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tfor k, v := range headerValues {\n\t\treq.Header.Set(k, v)\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := httpResponse(resp)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\treturn body, resp.StatusCode, nil\n}\n\nfunc (r *request) HttpPost(queryUrl string, queryValues map[string]string, headerValues map[string]string) ([]byte, int, error) {\n\turl := r.QueryBuilder(queryUrl, queryValues)\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tfor k, v := range headerValues {\n\t\treq.Header.Set(k, v)\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := httpResponse(resp)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\treturn body, resp.StatusCode, nil\n}\n\nfunc (r *request) QueryBuilder(queryUrl string, queryValues map[string]string) string {\n\tparams := make([]string, 0, len(queryValues))\n\tfor k, v := range queryValues {\n\t\tparams = append(params, encodeParam(k, v))\n\t}\n\tsort.Strings(params)\n\treturn queryUrl + \"?\" + strings.Join(params, \"&\")\n}\n\nfunc encodeParam(key string, value string) string {\n\tencodedKey := encodeString(key)\n\tencodedValue := encodeString(value)\n\treturn encodedKey + \"=\" + encodedValue\n}\n\nfunc encodeString(s string) string {\n\tvar result string\n\tfor _, c := range s {\n\t\tif unicode.IsLetter(c) || unicode.IsDigit(c) {\n\t\t\tresult += string(c)\n\t\t} else {\n\t\t\tresult += \"%\" + fmt.Sprintf(\"%02x\", c)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc httpResponse(resp *http.Response) ([]byte, error) {\n\tif resp == nil {\n\t\treturn nil, fmt.Errorf(\"no response\")\n\t}\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and the message \"pong [current_unix_timestamp]\" when the \"/ping\" endpoint is accessed)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tcurrentTime := time.Now().Unix()\n\t\tc.Writer.WriteHeader(200)\n\t\tc.Writer.Write([]byte(\"pong \" + strconv.Itoa(int(currentTime))))\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Implement a streaming HTTP server endpoint using Gin in Go that sends chunked data responses to clients.\n\nFunction Description: The function sets up a Gin HTTP server with a single endpoint (\"/stream\") that streams data to the client in real-time using chunked transfer encoding. It demonstrates how to implement server-sent events or real-time data streaming in Go.\n\nInput: None (The function takes no direct input parameters as it's the main server setup function)\n\nOutput: None (The function doesn't return anything but sets up a running HTTP server that outputs streaming data to connected clients)\n\n---\n\nFor completeness, here's the alternative struct-level format (though the reference code is function-level):\n\nTask Description: Create a struct that encapsulates a streaming HTTP server using Gin framework in Go.\n\nStruct Description: The StreamServer struct represents a configurable HTTP server capable of streaming data to clients.\n\nFields:\n- router: *gin.Engine - The Gin router instance\n- port: string - The port number to listen on\n- streamData: chan string - Channel for streaming data to clients\n\nMethods:\n- NewStreamServer(port string) *StreamServer - Constructor that initializes a new StreamServer instance\n- SetupRoutes() - Configures all HTTP routes and handlers\n- GenerateStreamData() - Generates sample data for streaming\n- Start() error - Starts the HTTP server\n- Stop() - Gracefully shuts down the server",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/stream\", func(c *gin.Context) {\n\t\tc.Header(\"Content-Type\", \"text/plain\")\n\t\tc.Header(\"Transfer-Encoding\", \"chunked\")\n\n\t\tdataStream := make(chan string)\n\n\t\tgo func() {\n\t\t\tdefer close(dataStream)\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\tdataStream <- fmt.Sprintf(\"Data %d\\n\", i)\n\t\t\t}\n\t\t}()\n\n\t\tfor data := range dataStream {\n\t\t\t_, _ = io.WriteString(c.Writer, data)\n\t\t\tc.Writer.Flush()\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype StreamServer struct {\n\trouter     *gin.Engine\n\tport       string\n\tstreamData chan string\n}\n\nfunc NewStreamServer(port string) *StreamServer {\n\treturn &StreamServer{\n\t\trouter:     gin.Default(),\n\t\tport:       port,\n\t\tstreamData: make(chan string),\n\t}\n}\n\nfunc (s *StreamServer) SetupRoutes() {\n\ts.router.GET(\"/stream\", func(c *gin.Context) {\n\t\tc.Header(\"Content-Type\", \"text/event-stream\")\n\t\tc.Header(\"Cache-Control\", \"no-cache\")\n\t\tc.Header(\"Connection\", \"keep-alive\")\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-s.streamData:\n\t\t\t\tc.Write(200, []byte(\"data: \"+data+\"\\n\\n\"))\n\t\t\tcase <-time.After(1 * time.Second):\n\t\t\t\tc.Write(200, []byte(\"event: ping\\n\\ndata: pong\\n\\n\"))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc (s *StreamServer) GenerateStreamData() {\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\ts.streamData <- \"Message \" + strconv.Itoa(i)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}()\n}\n\nfunc (s *StreamServer) Start() error {\n\tif s.router == nil {\n\t\treturn nil\n\t}\n\treturn s.router.Run(\":8080\")\n}\n\nfunc (s *StreamServer) Stop() {\n\t// In a real scenario, you would implement graceful shutdown logic here\n}"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a function to retrieve user information from Facebook's Graph API using an access token, with proper error handling and response validation.\n\nFunction Description: The function GetUserInfo makes an authenticated GET request to Facebook's Graph API to fetch user information (name, email, ID, and picture) using the provided access token. It handles the HTTP request/response cycle, validates the response, and parses the JSON data into a structured format.\n\nInput:\n- token: TokenInfo - A struct containing the Facebook access token (token.AccessToken is used)\n\nOutput:\n- model.UserInfo - A struct containing the user's information (ID, picture URL, name, email, and origin)\n- string - The raw JSON response body from the API\n- error - Any error that occurred during the API request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/tarent/loginsrv/model\"\n)\n\nvar facebookAPI = \"https://graph.facebook.com/v2.12\"\n\nfunc (p Provider) GetUserInfo(token TokenInfo) (model.UserInfo, string, error) {\n\tfu := facebookUser{}\n\n\turl := fmt.Sprintf(\"%v/me?access_token=%v&fields=name,email,id,picture\", facebookAPI, token.AccessToken)\n\n\tclient := &http.Client{}\n\tcontentType := \"application/json\"\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Accept\", contentType)\n\tresp, err := client.Do(req)\n\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif !strings.Contains(resp.Header.Get(\"Content-Type\"), contentType) {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"wrong content-type on facebook get user info: %v\", resp.Header.Get(\"Content-Type\"))\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"got http status %v on facebook get user info\", resp.StatusCode)\n\t}\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error reading facebook get user info: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, &fu)\n\tif err != nil {\n\t\treturn model.UserInfo{}, \"\", fmt.Errorf(\"error parsing facebook get user info: %v\", err)\n\t}\n\n\treturn model.UserInfo{\n\t\tSub:     fu.UserID,\n\t\tPicture: fu.Picture.Data.URL,\n\t\tName:    fu.Name,\n\t\tEmail:   fu.Email,\n\t\tOrigin:  \"facebook\",\n\t}, string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype TokenInfo struct {\n\tAccessToken string\n}\n\ntype UserInfo struct {\n\tID       string\n\tName     string\n\tEmail    string\n\tPicture string\n\tOrigin  string\n}\n\nfunc GetUserInfo(token TokenInfo) (UserInfo, string, error) {\n\turl := \"https://graph.facebook.com/v18.0/me?fields=id,name,email,picture&access_token=\" + token.AccessToken\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn UserInfo{}, \"\", err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn UserInfo{}, string(body), errors.New(\"failed to get user info from Facebook\")\n\t}\n\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal([]byte(body), &result); err != nil {\n\t\treturn UserInfo{}, string(body), err\n\t}\n\n\tuserID, ok := result[\"id\"].(string)\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing user ID in response\")\n\t}\n\n\tname, ok := result[\"name\"].(string)\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing user name in response\")\n\t}\n\n\temail, ok := result[\"email\"].(string)\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing user email in response\")\n\t}\n\n\tpicture, ok := result[\"picture\"].(map[string]interface{})\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing user picture in response\")\n\t}\n\n\tpictureURL, ok := picture[\"data\"].(map[string]interface{})\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing picture data in response\")\n\t}\n\n\tpictureURLStr, ok := pictureURL[\"url\"].(string)\n\tif !ok {\n\t\treturn UserInfo{}, string(body), errors.New(\"missing picture URL in response\")\n\t}\n\n\treturn UserInfo{\n\t\tID:       userID,\n\t\tName:     name,\n\t\tEmail:    email,\n\t\tPicture:  pictureURLStr,\n\t\tOrigin:   \"facebook\",\n\t}, string(body), nil\n}\n```"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles file uploads, saves them to a specified directory, and returns the file URL.\n\nFunction Description: The main function initializes a Gin HTTP server with file upload capabilities. It sets up a static file server for serving uploaded files and implements a POST endpoint for uploading files. The server saves uploaded files with unique names and returns their access URLs.\n\nInput: \n- HTTP POST request with multipart/form-data containing a file field named \"file\"\n- File content in the request body\n\nOutput:\n- JSON response containing:\n  - Status code (0 for success, non-zero for errors)\n  - Message describing the operation result\n  - Data object containing the URL to access the uploaded file (on success)\n  OR\n  - Error message (on failure)\n\nThe server runs on port 8085 and serves static files from \"/root/file/\" directory. Uploaded files are saved with names formatted as \"timestamp-randomstring.extension\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"gim/pkg/util\"\n)\n\nconst baseUrl = \"http://111.229.238.28:8085/file/\"\n\ntype Response struct {\n\tCode    int         `json:\"code\"`\n\tMessage string      `json:\"message\"`\n\tData    interface{} `json:\"data\"`\n}\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/file\", \"/root/file\")\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfilenames := strings.Split(file.Filename, \".\")\n\t\tname := strconv.FormatInt(time.Now().UnixNano(), 10) + \"-\" + util.RandString(30) + \".\" + filenames[len(filenames)-1]\n\t\tfilePath := \"/root/file/\" + name\n\t\terr = c.SaveUploadedFile(file, filePath)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusOK, Response{Code: 1001, Message: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, Response{\n\t\t\tCode:    0,\n\t\t\tMessage: \"success\",\n\t\t\tData:    map[string]string{\"url\": baseUrl + name},\n\t\t})\n\t})\n\terr := router.Run(\":8085\")\n\tif err != nil {\n\t\tlogger.Logger.Error(\"Run error\", zap.Error(err))\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/mux\"\n)\n\nconst uploadDir = \"/root/file/\"\n\nfunc init() {\n\tif _, err := os.Stat(uploadDir); os.IsNotExist(err) {\n\t\tos.MkdirAll(uploadDir, 0755)\n\t}\n}\n\nfunc generateUniqueFileName(file string) string {\n\t// Extract the file extension\n\text := strings.Split(file, \".\")[1]\n\ttimestamp := time.Now().UnixNano()\n\trandomString := make([]byte, 6)\n\trand.Read(randomString)\n\treturn fmt.Sprintf(\"%d%s%s\", timestamp, randomString, ext)\n}\n\nfunc uploadFile(c *gin.Context) {\n\tfile, handler, err := c.Request.FormFile(\"file\")\n\tif err != nil {\n\t\tc.JSON(500, gin.H{\n\t\t\t\"status\": 1,\n\t\t\t\"message\": \"Error retrieving the file\",\n\t\t})\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tuniqueFileName := generateUniqueFileName(handler)\n\tdestPath := uploadDir + uniqueFileName\n\n\tdst, err := os.Create(destPath)\n\tif err != nil {\n\t\tc.JSON(500, gin.H{\n\t\t\t\"status\": 1,\n\t\t\t\"message\": \"Error creating the destination file\",\n\t\t})\n\t\treturn\n\t}\n\tdefer dst.Close()\n\n\t_, err = io.Copy(dst, file)\n\tif err != nil {\n\t\tc.JSON(500, gin.H{\n\t\t\t\"status\": 1,\n\t\t\t\"message\": \"Error saving the uploaded file\",\n\t\t})\n\t\treturn\n\t}\n\n\tfileURL := \"http://\" + c.Request.Host + \"/\" + uniqueFileName\n\tc.JSON(0, gin.H{\n\t\t\"status\": 0,\n\t\t\"message\": \"File uploaded successfully\",\n\t\t\"data\": gin.H{\n\t\t\t\"url\": fileURL,\n\t\t},\n\t})\n}\n\nfunc main() {\n\trouter := gin.Default()\n\n\t// Serve static files from the upload directory\n\trouter.Static(\"/file\", uploadDir)\n\n\t// Upload endpoint\n\trouter.POST(\"/upload\", uploadFile)\n\n\t// Start server on port 8085\n\tlog.Println(\"Server is running on port 8085\")\n\trouter.Run(\":8085\")\n}"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a default Gin engine with logger and recovery middleware, registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- domains: []string - A slice of domain names for which TLS certificates should be obtained (e.g., [\"example1.com\", \"example2.com\"])\n\nOutput: \n- error - Returns an error if the server fails to start, otherwise runs indefinitely (the function will log.Fatal on error)\n\nNote: The function does not explicitly return but will log.Fatal if the server fails to start. The server runs indefinitely when successful.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-acme/le-go/acme\"\n\t\"github.com/go-acme/le-go/challenge/http-01\"\n\t\"github.com/go-acme/le-go/client\"\n\t\"github.com/go-acme/le-go/registration\"\n\t\"github.com/go-acme/le-go/utilities\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc startServer(domains []string) {\n\tr := gin.Default()\n\tr.Use(gin.Logger())\n\tr.Use(gin.Recovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(200, \"pong\")\n\t})\n\n\t// Setup Let's Encrypt client\n\tleClient, err := client.NewClient(\n\t\tclient.WithEmail(os.Getenv(\"LE_EMAIL\")),\n\t\tclient.WithHTTPClient(&http.Client{\n\t\t\tTimeout: 30 * time.Second,\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Setup ACME account\n\taccount, err := registration.NewRegistration(\n\t\tregistration.WithEmail(os.Getenv(\"LE_EMAIL\")),\n\t\tregistration.WithAgreeToTerms(true),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Setup challenge\n\tchall, err := http01.NewChallenge(\n\t\thttp01.WithDomain(domains[0]),\n\t\thttp01.WithHandler(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"pong\"))\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Setup certificate\n\tcert, err := leClient.ObtainCertificate(\n\t\tleClient.Registration(account),\n\t\tchall,\n\t\tleClient.CA(leClient.CA()),\n\t\tleClient.CAChain(leClient.CAChain()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.CertificateChain(leClient.CertificateChain()),\n\t\tleClient.PrivateKey(leClient.PrivateKey()),\n\t\tleClient.Certificate(leClient.Certificate()),\n\t\tleClient.C"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with custom template delimiters and a date formatting function, serving HTML content from a template file.\n\nFunction Description: The function initializes a Gin router with custom template delimiters \"{[{\" and \"}]}\", registers a template formatting function \"formatAsDate\", loads an HTML template file, and sets up a GET route handler that renders the template with a predefined date value. The server listens on port 8080.\n\nInput: None (The function takes no input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Delims(\"{[{\", \"}]}\")\n\trouter.SetFuncMap(template.FuncMap{\n\t\t\"formatAsDate\": formatAsDate,\n\t})\n\trouter.LoadHTMLFiles(\"./testdata/raw.tmpl\")\n\n\trouter.GET(\"/raw\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"raw.tmpl\", gin.H{\n\t\t\t\"now\": time.Date(2017, 0o7, 0o1, 0, 0, 0, 0, time.UTC),\n\t\t})\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Custom template delimiters\n\ttmpl := template.Must(template.New(\"\").Delims(\"{[\", \"]}\").ParseFiles(\"index.html\"))\n\n\t// Define a custom date formatting function\n\ttmpl.Funcs(gin.H{\n\t\t\"formatAsDate\": func(t time.Time) string {\n\t\t\treturn t.Format(\"2006-01-02\")\n\t\t},\n\t})\n\n\tr.LoadHTMLTemplates(\"index.html\")\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\ttmpl.Execute(c.Writer, gin.H{\n\t\t\t\"currentDate\": time.Now(),\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Go struct that handles HTTP requests to a metadata service with configurable endpoints, versioning, and resource paths. The struct should support request building, execution, and response handling with retry logic and mock capabilities for testing.\n\nStruct Description: The MetaData struct provides a client for interacting with a metadata service API. It supports building requests with versioning, resource types, and sub-resources, executing requests with retry logic, and decoding responses. It includes mock functionality for testing.\n\nFields:\n- mock: requestMock - A function type for mocking requests during testing\n- client: *http.Client - The HTTP client used to execute requests\n\nMethods:\n- NewMetaData(*http.Client) *MetaData - Constructor that initializes a new MetaData instance with an optional custom HTTP client\n- New() *MetaDataRequest - Creates a new request builder instance\n\nThe MetaDataRequest nested struct handles individual request configuration and execution:\n\nFields:\n- version: string - API version to use (defaults to \"latest\")\n- resourceType: string - Type of resource being accessed (defaults to \"meta-data\")\n- resource: string - Main resource path (required)\n- subResource: string - Optional sub-resource path\n- client: *http.Client - HTTP client for request execution\n- sendRequest: requestMock - Optional mock function for testing\n\nMethods:\n- Version(string) IMetaDataRequest - Sets the API version for the request\n- ResourceType(string) IMetaDataRequest - Sets the resource type for the request\n- Resource(string) IMetaDataRequest - Sets the main resource path\n- SubResource(string) IMetaDataRequest - Sets an optional sub-resource path\n- Url() (string, error) - Constructs the full request URL from components\n- Do(interface{}) error - Executes the request and decodes the response into the provided interface\n- send() (string, error) - Internal method that performs the actual HTTP request\n- Decode(string, interface{}) error - Handles response decoding (implementation not shown in reference)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"os\"\n)\n\ntype MetaData struct {\n\tmock requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tclient:      m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype requestMock func(resource string) (string, error)\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest requestMock\n}\n\nfunc (vpc *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tvpc.version = version\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) ResourceType(rtype string) IMetaDataRequest {\n\tvpc.resourceType = rtype\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tvpc.resource = resource\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) SubResource(sub string) IMetaDataRequest {\n\tvpc.subResource = sub\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Url() (string, error) {\n\tif vpc.version == \"\" {\n\t\tvpc.version = \"latest\"\n\t}\n\tif vpc.resourceType == \"\" {\n\t\tvpc.resourceType = \"meta-data\"\n\t}\n\tif vpc.resource == \"\" {\n\t\treturn \"\", errors.New(\"the resource you want to visit must not be nil!\")\n\t}\n\tendpoint := os.Getenv(\"METADATA_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = \"http://100.100.100.200\"\n\t}\n\tr := fmt.Sprintf(\"%s/%s/%s/%s\", endpoint, vpc.version, vpc.resourceType, vpc.resource)\n\tif vpc.subResource == \"\" {\n\t\treturn r, nil\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", r, vpc.subResource), nil\n}\n\nfunc (vpc *MetaDataRequest) Do(api interface{}) (err error) {\n\tvar res = \"\"\n\tfor r := retry.Start(); r.Next(); {\n\t\tif vpc.sendRequest != nil {\n\t\t\tres, err = vpc.sendRequest(vpc.resource)\n\t\t} else {\n\t\t\tres, err = vpc.send()\n\t\t}\n\t\tif !shouldRetry(err) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn vpc.Decode(res, api)\n}\n\nfunc (vpc *MetaDataRequest) send() (string, error) {\n\turl, err := vpc.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\trequ, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := vpc.client.Do(requ)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", fmt.Errorf(\"Aliyun Metadata API Error: Status Code: %d\", resp.StatusCode)\n\t}\n\tdefer resp.Body.Close()\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package metadata\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype requestMock func(req *http.Request) (*http.Response, error)\n\ntype MetaData struct {\n\tmock  requestMock\n\tclient *http.Client\n}\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource string\n\tclient       *http.Client\n\tsendRequest  requestMock\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tversion:      \"latest\",\n\t\tresourceType: \"meta-data\",\n\t\tclient:       &http.Client{},\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tversion:      m.version,\n\t\tresourceType: m.resourceType,\n\t\tclient:       m.client,\n\t\tsendRequest:  m.mock,\n\t}\n}\n\nfunc (r *MetaDataRequest) Version(v string) IMetaDataRequest {\n\tr.version = v\n\treturn r\n}\n\nfunc (r *MetaDataRequest) ResourceType(t string) IMetaDataRequest {\n\tr.resourceType = t\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Resource(res string) IMetaDataRequest {\n\tr.resource = res\n\treturn r\n}\n\nfunc (r *MetaDataRequest) SubResource(sub string) IMetaDataRequest {\n\tr.subResource = sub\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Url() (string, error) {\n\tbaseURL := strings.Join([]string{r.resourceType, r.version, r.resource}, \"/\")\n\tif r.subResource != \"\" {\n\t\tbaseURL += \"/\" + r.subResource\n\t}\n\treturn baseURL, nil\n}\n\nfunc (r *MetaDataRequest) Do(result interface{}) error {\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif r.sendRequest != nil {\n\t\tresp, err := r.sendRequest(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn r.Decode(resp.Body, result)\n\t}\n\n\tresp, err := r.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn r.Decode(resp.Body, result)\n}\n\nfunc (r *MetaDataRequest) send() (string, error) {\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif r.sendRequest != nil {\n\t\tresp, err := r.sendRequest(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn resp.Status, nil\n\t}\n\n\tresp, err := r.client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn resp.Status, nil\n}\n\nfunc (r *MetaDataRequest) Decode(body string, result interface{}) error {\n\t// Implementation of decoding logic would go here\n\treturn errors.New(\"decode not implemented\")\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Go function that handles file uploads along with form data using the Gin web framework. The function should process multipart form data, save uploaded files, and return a response indicating success or failure.\n\nFunction Description: The function is a Gin route handler that processes POST requests to the \"/upload\" endpoint. It handles multipart/form-data submissions containing both form fields (name and email) and file uploads. The function saves all uploaded files to the server and returns a success message with the count of uploaded files and the form field values, or an error message if the operation fails.\n\nInput: \n- Gin context object (c *gin.Context) containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - File uploads: \"files\" (multipart.FileHeader array)\n\nOutput:\n- On success: HTTP 200 status with success message (string)\n- On failure: HTTP 400 status with error message (string)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc uploadFile(c *gin.Context) {\n\t// Check if the request has multipart/form-data\n\tif err := c.Request.ParseMultipartForm(10 << 20); err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"failed to parse form\"})\n\t\treturn\n\t}\n\n\t// Get form fields\n\tname := c.FormValue(\"name\")\n\temail := c.FormValue(\"email\")\n\n\t// Get uploaded files\n\tfiles, err := c.MultipartForm.File[\"files\"]\n\tif err != nil || len(files) == 0 {\n\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"no files uploaded\"})\n\t\treturn\n\t}\n\n\t// Save uploaded files\n\tvar uploadedFiles []string\n\tfor _, fileHeader := range files {\n\t\t// Open the uploaded file\n\t\tfile, err := fileHeader.Open()\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to open file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Define the save path\n\t\tsavePath := filepath.Join(\"uploads\", fileHeader.Filename)\n\t\t// Create the directory if it doesn't exist\n\t\tos.MkdirAll(\"uploads\", os.ModePerm)\n\n\t\t// Save the file\n\t\toutFile, err := os.Create(savePath)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to create file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer outFile.Close()\n\n\t\t// Copy the file content\n\t\t_, err = outFile.WriteFrom(file)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to write file\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Add the saved file path to the list\n\t\tuploadedFiles = append(uploadedFiles, savePath)\n\t}\n\n\t// Return success response\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\": \"Upload successful\",\n\t\t\"name\":    name,\n\t\t\"email\":   email,\n\t\t\"files\":   uploadedFiles,\n\t})\n}"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves a static favicon file and responds to a GET request with a text message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), serves a static favicon file, registers a GET route handler, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but sends responses to HTTP requests and runs the server indefinitely)\n\nNote: The instruction is for function-level code as the reference code shows a main function implementation rather than a struct/class implementation.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tapp := gin.Default()\n\n\tapp.StaticFile(\"/favicon.ico\", \"./favicon.ico\")\n\n\tapp.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello favicon.\")\n\t})\n\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"static\" directory\n\tr.Static(\"/favicon.ico\", \"static/favicon.ico\")\n\n\t// Register a GET route handler\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.Writer.WriteHeader(200)\n\t\tc.Writer.Write([]byte(\"Hello, World!\"))\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a Go HTTP client struct that can handle both HTTP and HTTPS requests with custom configurations, including authentication and request headers.\n\nStruct Description: The Client struct represents an HTTP client with configurable protocol, address, authentication, and transport settings. It provides methods to execute HTTP requests and handle responses.\n\nFields:\nProtocol: string - The protocol to use (http or https)\nAddr: string - The server address to connect to\nUser: string - The username for basic authentication\nPassword: string - The password for basic authentication\nc: *http.Client - The underlying HTTP client instance\n\nMethods:\nNewClient: (conf *ClientConfig) -> *Client - Creates a new Client instance with the given configuration, setting up either HTTP or HTTPS transport\nDoRequest: (method string, url string, body *bytes.Buffer) -> (*http.Response, error) - Executes an HTTP request with the given method, URL and body, adding basic auth if configured\nDo: (method string, url string, body map[string]interface{}) -> (*Response, error) - Executes a request with JSON body, parses the response and returns a structured Response object",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/juju/errors\"\n)\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\n\tc *http.Client\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\tc := new(Client)\n\n\tc.Addr = conf.Addr\n\tc.User = conf.User\n\tc.Password = conf.Password\n\n\tif conf.HTTPS {\n\t\tc.Protocol = \"https\"\n\t\ttr := &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t\tc.c = &http.Client{Transport: tr}\n\t} else {\n\t\tc.Protocol = \"http\"\n\t\tc.c = &http.Client{}\n\t}\n\n\treturn c\n}\n\nfunc (c *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif len(c.User) > 0 && len(c.Password) > 0 {\n\t\treq.SetBasicAuth(c.User, c.Password)\n\t}\n\tresp, err := c.c.Do(req)\n\n\treturn resp, err\n}\n\nfunc (c *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tbodyData, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tbuf := bytes.NewBuffer(bodyData)\n\tif body == nil {\n\t\tbuf = bytes.NewBuffer(nil)\n\t}\n\n\tresp, err := c.DoRequest(method, url, buf)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tret := new(Response)\n\tret.Code = resp.StatusCode\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tif len(data) > 0 {\n\t\terr = json.Unmarshal(data, &ret.ResponseItem)\n\t}\n\n\treturn ret, errors.Trace(err)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype ClientConfig struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n}\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\tc        *http.Client\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\tclient := &Client{\n\t\tProtocol: conf.Protocol,\n\t\tAddr:     conf.Addr,\n\t\tUser:     conf.User,\n\t\tPassword: conf.Password,\n\t}\n\n\tvar transport http.RoundTripper\n\tif conf.Protocol == \"https\" {\n\t\ttransport = &http.Transport{}\n\t} else {\n\t\ttransport = &http.Transport{}\n\t}\n\n\tclient.c = &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   10 * time.Second,\n\t}\n\n\treturn client\n}\n\nfunc (c *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.User != \"\" && c.Password != \"\" {\n\t\tauth := strings.NewReader(c.User + \":\" + c.Password)\n\t\treq.SetBasicAuth(c.User, c.Password)\n\t}\n\n\tresp, err := c.c.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tjsonBody, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbodyBuf := bytes.NewBuffer(jsonBody)\n\tresp, err := c.DoRequest(method, url, bodyBuf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response Response\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}\n\ntype Response struct {\n\tStatus  int      `json:\"status\"`\n\tHeaders map[string]string `json:\"headers\"`\n\tBody    string   `json:\"body\"`\n}"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Go function that implements a distributed transaction coordinator using HTTP communication between microservices. The function should handle transaction initiation, propagate transaction context, and coordinate between multiple services.\n\nFunction Description: The function serves as an HTTP handler for initiating a distributed transaction. It receives a transaction ID in the header, prepares transaction data for two different services (Account and Inventory), makes HTTP calls to these services, and handles their responses. The function ensures transaction context (xid) is propagated to all participating services.\n\nInput: \n- Gin context object (gin.Context) containing:\n  - HTTP request headers (including \"x_seata_xid\" for transaction ID)\n  - Request body (not used in this example, but could contain transaction details)\n\nOutput:\n- HTTP responses:\n  - 400 Bad Request with error details if any step fails\n  - Original service response if any service fails (non-200 status)\n  - Success response from the last service if all succeed (200 status)\n- Side effects: Makes HTTP calls to two different services with transaction data",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-a/begin\", func(context *gin.Context) {\n\t\txid := context.Request.Header.Get(\"x_seata_xid\")\n\t\taccount := &Account{\n\t\t\tID:     1000024549,\n\t\t\tAmount: 200,\n\t\t}\n\t\tinv := &Inventory{\n\t\t\tID:  1000000005,\n\t\t\tQty: 2,\n\t\t}\n\n\t\taccountReq, err := json.Marshal(account)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tinvReq, err := json.Marshal(inv)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1, err := http.NewRequest(\"POST\", \"http://localhost:2047/service-b/try\", bytes.NewBuffer(accountReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1.Header.Set(\"x_seata_xid\", xid)\n\n\t\treq2, err := http.NewRequest(\"POST\", \"http://localhost:2048/service-c/try\", bytes.NewBuffer(invReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq2.Header.Set(\"x_seata_xid\", xid)\n\n\t\tclient := &http.Client{}\n\t\tresult1, err := client.Do(req1)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result1.StatusCode != http.StatusOK {\n\t\t\tresult1.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\n\t\tresult2, err := client.Do(req2)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result2.StatusCode == http.StatusOK {\n\t\t\tresult2.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc initDistributedTransaction(c *gin.Context) {\n\txid := c.GetHeader(\"x_seata_xid\")\n\tif xid == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Missing transaction ID in headers\"})\n\t\treturn\n\t}\n\n\t// Simulate transaction data for Account and Inventory services\n\taccountData := map[string]interface{}{\n\t\t\"operation\": \"transfer\",\n\t\t\"amount\":    100.0,\n\t\t\"xid\":       xid,\n\t}\n\tinventoryData := map[string]interface{}{\n\t\t\"operation\": \"reserve\",\n\t\t\"quantity\":  5,\n\t\t\"xid\":       xid,\n\t}\n\n\t// Propagate transaction context to Account service\n\taccountResp, err := sendToService(\"http://account-service/api/transaction\", accountData, xid)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to propagate transaction to Account service: \" + err.Error()})\n\t\treturn\n\t}\n\n\t// Propagate transaction context to Inventory service\n\tinventoryResp, err := sendToService(\"http://inventory-service/api/transaction\", inventoryData, xid)\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to propagate transaction to Inventory service: \" + err.Error()})\n\t\treturn\n\t}\n\n\t// Check responses from services\n\tif accountResp.Status != 200 || inventoryResp.Status != 200 {\n\t\tc.JSON(accountResp.Status, accountResp.Body)\n\t\treturn\n\t}\n\n\tc.JSON(200, gin.H{\n\t\t\"message\": \"Distributed transaction committed successfully\",\n\t\t\"xid\":     xid,\n\t})\n}\n\nfunc sendToService(url string, data interface{}, xid string) (*Response, error) {\n\tresp, err := http.PostJSON(url, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Simulate delay for demonstration purposes\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Set xid header for the response\n\tresp.Header.Set(\"x_seata_xid\", xid)\n\n\treturn &Response{resp.StatusCode, resp.Body}, nil\n}\n\ntype Response struct {\n\tStatus int\n\tBody   []byte\n}"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but configuration is hardcoded: static files are served from \"/tmp\" and the server listens on port 8080)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"/tmp\" directory\n\tr.Static(\"/static\", \"/tmp\")\n\n\t// Handle a basic GET request\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.Writer.Write([]byte(\"Hello, World!\"))\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a function that demonstrates asynchronous message production to a Kafka topic using the Sarama library in Go. The function should continuously generate and send messages at regular intervals while handling both successful deliveries and errors.\n\nFunction Description: The SaramaProducer function initializes and manages an asynchronous Kafka producer. It configures the producer with specific settings, handles message delivery success/failure notifications in a separate goroutine, and continuously generates and sends messages to a specified Kafka topic. The function runs indefinitely until terminated.\n\nInput: None (The function takes no input parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function doesn't return any value but prints success/error messages to stdout)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc SaramaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tconfig.Producer.Retry.Max = 1000\n\tconfig.Version = sarama.V2_2_0_0\n\n\tproducer, e := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif e != nil {\n\t\tfmt.Println(e)\n\t\treturn\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func(p sarama.AsyncProducer) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase suc := <-p.Successes():\n\t\t\t\tfmt.Println(\"offset: \", suc.Offset, \"timestamp: \", suc.Timestamp.String(), \"partitions: \", suc.Partition)\n\t\t\tcase fail := <-p.Errors():\n\t\t\t\tfmt.Println(\"err: \", fail.Err)\n\t\t\t}\n\t\t}\n\t}(producer)\n\n\tvar value string\n\tfor i := 0; ; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\ttime11 := time.Now()\n\t\tvalue = \"this is a message 0606 \" + time11.Format(\"15:04:05\")\n\t\tmsg := &sarama.ProducerMessage{\n\t\t\tTopic: \"0606_test\",\n\t\t}\n\t\tmsg.Value = sarama.ByteEncoder(value)\n\t\tfmt.Println(value)\n\t\tproducer.Input() <- msg\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc SaramaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Metadata.RefetchInterval = 30 * time.Second\n\tconfig.Producer.RequiredAcks = sarama.Secure // Acknowledge all replicas\n\n\tbrokers := \"localhost:9092\"\n\ttopic := \"test-topic\"\n\n\tproducer, err := sarama.NewAsyncProducer([]string{brokers}, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create producer: %v\", err)\n\t}\n\tdefer producer.Close()\n\n\t// Handle delivery success\n\tgo func() {\n\t\tfor msg := range producer.Successes {\n\t\t\tfmt.Printf(\"Message sent: %s\\n\", string(msg.Value))\n\t\t}\n\t}()\n\n\t// Handle delivery failure\n\tgo func() {\n\t\tfor err := range producer.Failed {\n\t\t\tfmt.Printf(\"Message failed: %v\\n\", err)\n\t\t}\n\t}()\n\n\t// Continuously send messages\n\tfor {\n\t\tmsg := &sarama.ProducerMessage{\n\t\t\tTopic: topic,\n\t\t\tValue: sarama.ByteStream([]byte(\"Async message from Sarama\")),\n\t\t}\n\t\tproducer.Send(msg)\n\t\ttime.Sleep(2 * time.Second)\n\t}\n}"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a function that implements an asynchronous Kafka producer in Go, which continuously sends messages to a specified Kafka topic at regular intervals. The function should handle both success and error cases from the producer and properly clean up resources when done.\n\nFunction Description: The function `runAsyncKafkaProducer` initializes and manages an asynchronous Kafka producer that sends alternating message types (\"login\" and \"msg\" events) to a Kafka topic every 10 seconds. It configures the producer with appropriate settings, handles success/error notifications in a separate goroutine, and ensures proper resource cleanup.\n\nInput: None (The function takes no parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function runs indefinitely until terminated, printing success/error messages to stdout)\n\nReference Code Structure:\n\n```go\nfunc runAsyncKafkaProducer() {\n    // 1. Configure Kafka producer\n    config := sarama.NewConfig()\n    config.Producer.RequiredAcks = sarama.WaitForAll\n    config.Producer.Partitioner = sarama.NewRandomPartitioner\n    config.Producer.Return.Successes = true\n    config.Producer.Return.Errors = true\n    \n    // 2. Initialize async producer\n    producer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n    if err != nil {\n        panic(err)\n    }\n    defer producer.AsyncClose()\n    \n    // 3. Start goroutine to handle producer events\n    go func() {\n        for {\n            select {\n            case success := <-producer.Successes():\n                fmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n                    success.Topic, success.Partition, success.Offset)\n            case err := <-producer.Errors():\n                fmt.Printf(\"Failed to send message: %v\\n\", err)\n            }\n        }\n    }()\n    \n    // 4. Main message sending loop\n    var messageType int = 1\n    for {\n        msg := createMessage(messageType)\n        producer.Input() <- msg\n        \n        messageType = toggleMessageType(messageType)\n        time.Sleep(10 * time.Second)\n    }\n}\n\n// Helper functions would be defined here...\n```",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc main() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tAsyncProducer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer AsyncProducer.AsyncClose()\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase succ := <-AsyncProducer.Successes():\n\t\t\t\tfmt.Println(\"AsyncProducer.Successes()\", succ.Topic, succ.Offset, succ.Timestamp, succ.Partition)\n\t\t\tcase err := <-AsyncProducer.Errors():\n\t\t\t\tfmt.Println(\"AsyncProducer.Errors()\", err.Error())\n\t\t\t}\n\t\t}\n\t}()\n\tvar i = 1\n\tfor {\n\t\tMessage := &sarama.ProducerMessage{\n\t\t\tTopic:     \"msg_event\",\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tvar data []byte\n\t\tdate := time.Now().UnixNano() / 1e6\n\t\tif i == 1 {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"11\",\n\t\t\t\t\"uid\":         1,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"login\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 2\n\t\t} else {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"22\",\n\t\t\t\t\"uid\":         222222,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"msg\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 1\n\t\t}\n\n\t\tMessage.Value = sarama.ByteEncoder(data)\n\t\tAsyncProducer.Input() <- Message\n\t\ttime.Sleep(time.Second * 10)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "func runAsyncKafkaProducer() {\n    // 1. Configure Kafka producer\n    config := sarama.NewConfig()\n    config.Producer.RequiredAcks = sarama.WaitForAll\n    config.Producer.Partitioner = sarama.NewRandomPartitioner\n    config.Producer.Return.Successes = true\n    config.Producer.Return.Errors = true\n    \n    // 2. Initialize async producer\n    producer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n    if err != nil {\n        panic(err)\n    }\n    defer producer.AsyncClose()\n    \n    // 3. Start goroutine to handle producer events\n    go func() {\n        for {\n            select {\n            case success := <-producer.Successes():\n                fmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n                    success.Topic, success.Partition, success.Offset)\n            case err := <-producer.Errors():\n                fmt.Printf(\"Failed to send message: %v\\n\", err)\n            }\n        }\n    }()\n    \n    // 4. Main message sending loop\n    var messageType int = 1\n    for {\n        msg := createMessage(messageType)\n        producer.Input() <- msg\n        \n        messageType = toggleMessageType(messageType)\n        time.Sleep(10 * time.Second)\n    }\n}\n\nfunc createMessage(typeId int) *sarama.ProducerMessage {\n    var message string\n    if typeId == 1 {\n        message = \"login event\"\n    } else {\n        message = \"message event\"\n    }\n    return &sarama.ProducerMessage{\n        Topic: \"test-topic\",\n        Value: []byte(message),\n    }\n}\n\nfunc toggleMessageType(typeId int) int {\n    if typeId == 1 {\n        return 2\n    }\n    return 1\n}"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.\n\nTask Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"testing\"\n)\n\nfunc TestKafkaSyncProducer(t *testing.T) {\n\tconf := sarama.NewConfig()\n\tconf.Producer.RequiredAcks = sarama.WaitForAll\n\tconf.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconf.Producer.Return.Successes = true\n\tconf.Producer.Return.Errors = true\n\tconf.Producer.Retry.Max = 1000\n\tconf.Version = sarama.V2_8_0_0\n\tproducer, err := sarama.NewSyncProducer([]string{\"172.12.12.165:9092\"}, conf)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer producer.Close()\n\tfmt.Println(producer.SendMessage(&sarama.ProducerMessage{\n\t\tTopic: \"gs_pay_transaction_topic\",\n\t\tValue: sarama.ByteEncoder(\"123123\"),\n\t}))\n\tselect {}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 123,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc sendMessageToKafka() {\n\t// Kafka broker address and topic\n\tbrokerAddress := \"localhost:9092\"\n\ttopicName := \"test-topic\"\n\n\t// Configure the producer\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.Secure // Acknowledge the message\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner // Random partitioning\n\tconfig.Producer.Return.Successes = true // Return successful messages\n\n\t// Create the producer\n\tproducer, err := sarama.NewProducer([]string{brokerAddress}, config)\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating producer: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := producer.Close(); err != nil {\n\t\t\tfmt.Printf(\"Error closing producer: %v\\n\", err)\n\t\t}\n\t}()\n\n\t// Message to send\n\tmessage := &sarama.ProducerMessage{\n\t\tTopic:     topicName,\n\t\tValue:     sarama.StringEncoder(\"Hello, Kafka!\"),\n\t\tTimestamp: time.Now(),\n\t}\n\n\t// Send the message\n\tpartition, offset, err := producer.Produce(message, sarama.WriteWait)\n\tif err != nil {\n\t\tfmt.Printf(\"Error sending message: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Print the result\n\tfmt.Printf(\"Message sent to partition %d, offset %d\\n\", partition, offset)\n}"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Implement a TCP/UDP port scanner with proxy support and configurable source IP addresses.\n\nStruct Description: The Scanner struct provides functionality to check if a specific port is open on a given host, supporting both TCP and UDP protocols. It includes timeout configuration, proxy support, and the ability to specify source IP addresses for the connection.\n\nFields:\n- timeout: time.Duration - Maximum duration to wait for a connection attempt\n- proxyDialer: proxy.Dialer - Optional proxy dialer for making connections through a proxy\n- ListenHandler: *ListenHandler - Configuration for source IP addresses (both IPv4 and IPv6)\n\nMethods:\n- ConnectPort: (host string, p *port.Port, timeout time.Duration) -> (bool, error) - Attempts to connect to the specified port on the given host. Returns true if the port is open/reachable, along with any error that occurred during the connection attempt. The port parameter includes the protocol (TCP/UDP) and port number. The timeout parameter specifies the maximum duration for the connection attempt.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\thostport := net.JoinHostPort(host, fmt.Sprint(p.Port))\n\tvar (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\tif s.proxyDialer != nil {\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t\tproxyDialer, ok := s.proxyDialer.(proxy.ContextDialer)\n\t\tif !ok {\n\t\t\treturn false, errors.New(\"invalid proxy dialer\")\n\t\t}\n\t\tconn, err = proxyDialer.DialContext(ctx, p.Protocol.String(), hostport)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tnetDialer := net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t\tif s.ListenHandler.SourceIp4 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIp4}\n\t\t} else if s.ListenHandler.SourceIP6 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIP6}\n\t\t}\n\t\tconn, err = netDialer.Dial(p.Protocol.String(), hostport)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\tswitch p.Protocol {\n\tcase protocol.UDP:\n\t\tif err := conn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif _, err := conn.Write(nil); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif err := conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tn, err := io.Copy(io.Discard, conn)\n\t\tif err != nil && !os.IsTimeout(err) {\n\t\t\treturn false, err\n\t\t}\n\t\treturn n > 0, nil\n\t}\n\n\treturn true, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "package scanner\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\tif s.proxyDialer != nil {\n\t\tconn, err := s.proxyDialer.Dial(p.Protocol, host+\":\"+p.Port)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdefer conn.Close()\n\t\treturn true, nil\n\t}\n\n\taddr := net.JoinHostPort(host, p.Port)\n\tvar conn net.Conn\n\tvar err error\n\n\tif p.Protocol == \"TCP\" {\n\t\tconn, err = net.DialTimeout(\"tcp\", addr, timeout)\n\t} else if p.Protocol == \"UDP\" {\n\t\tconn, err = net.DialTimeout(\"udp\", addr, timeout)\n\t} else {\n\t\treturn false, fmt.Errorf(\"unsupported protocol: %s\", p.Protocol)\n\t}\n\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\treturn true, nil\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Create a function that uploads a video file to a specified URL using a multipart/form-data POST request with custom headers.\n\nFunction Description: The function uploads a video file to a given URL with specified form fields and authentication headers. It handles file operations, creates a multipart form payload, sets appropriate headers (including content type and access token), executes the HTTP request, and returns the response body.\n\nInput:\n- url (string): The target URL for the video upload\n- method (string): HTTP method (typically \"POST\")\n- advertiserID (string): The advertiser ID for the form field\n- uploadType (string): The upload type for the form field\n- videoSignature (string): The video signature for the form field\n- filePath (string): Path to the video file to upload\n- accessToken (string): Access token for authentication header\n\nOutput:\n- ([]byte, error): Returns the response body as bytes and any error that occurred during execution\n\nNote: The function should follow the same steps as the reference code, including creating a custom http.Client, setting headers, handling multipart form data, and properly managing resources (file handles, response bodies).",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"video_signature\", \"6b12a8bbbe8e69a2ef5929028b0b50c3\")\n\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\")\n\tdefer file.Close()\n\n\tpart4, errFile4 := writer.CreateFormFile(\"video_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc uploadVideo(url string, method string, advertiserID string, uploadType string, videoSignature string, filePath string, accessToken string) ([]byte, error) {\n\t// Create a new HTTP client\n\tclient := &http.Client{}\n\n\t// Open the video file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t// Create a buffer to hold the multipart form data\n\tvar buf bytes.Buffer\n\twriter := multipart.NewWriter(&buf)\n\n\t// Add form fields\n\tif err := writer.WriteField(\"advertiserID\", advertiserID); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := writer.WriteField(\"uploadType\", uploadType); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := writer.WriteField(\"videoSignature\", videoSignature); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Add the video file\n\tfileHandle, err := writer.CreateFormFile(\"video\", filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err = io.Copy(fileHandle, file); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Close the writer to ensure all data is written\n\tif err := writer.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the headers\n\theaders := make(map[string]string)\n\theaders[\"Content-Type\"] = writer.FormDataContentType()\n\theaders[\"Authorization\"] = \"Bearer \" + accessToken\n\n\t// Create the HTTP request\n\treq, err := http.NewRequest(method, url, &buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\t// Execute the request\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP client in Go that establishes a connection to a server, handles data transmission, and manages connection lifecycle with proper error handling and resource cleanup.\n\nStruct Description: The `Client` struct represents a TCP client that connects to a server using a round-robin server selection strategy. It manages server connections, handles policy enforcement, and processes data transmission for both TCP and UDP protocols.\n\nFields:\n- serverPicker: [protocol.ServerPicker] - Selects servers in a round-robin fashion from available server list  \n- policyManager: [policy.Manager] - Manages connection policies including timeouts and user levels\n\nMethods:\n- NewClient: [func(ctx context.Context, config *ClientConfig) (*Client, error)] -> (*Client, error) - Creates a new Client instance with server configurations and policy manager\n- Process: [func(ctx context.Context, link *transport.Link, dialer internet.Dialer) error] -> error - Main processing method that establishes connection, handles handshake, and manages data transfer between client and server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/xtls/xray-core/common\"\n\t\"github.com/xtls/xray-core/common/buf\"\n\t\"github.com/xtls/xray-core/common/errors\"\n\t\"github.com/xtls/xray-core/common/net\"\n\t\"github.com/xtls/xray-core/common/protocol\"\n\t\"github.com/xtls/xray-core/common/retry\"\n\t\"github.com/xtls/xray-core/common/session\"\n\t\"github.com/xtls/xray-core/common/signal\"\n\t\"github.com/xtls/xray-core/common/task\"\n\t\"github.com/xtls/xray-core/core\"\n\t\"github.com/xtls/xray-core/features/policy\"\n\t\"github.com/xtls/xray-core/transport\"\n\t\"github.com/xtls/xray-core/transport/internet\"\n\t\"github.com/xtls/xray-core/transport/internet/stat\"\n)\n\ntype Client struct {\n\tserverPicker  protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tserverList := protocol.NewServerList()\n\tfor _, rec := range config.Server {\n\t\ts, err := protocol.NewServerSpecFromPB(rec)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"failed to get server spec\").Base(err)\n\t\t}\n\t\tserverList.AddServer(s)\n\t}\n\tif serverList.Size() == 0 {\n\t\treturn nil, errors.New(\"0 target server\")\n\t}\n\n\tv := core.MustFromContext(ctx)\n\tc := &Client{\n\t\tserverPicker:  protocol.NewRoundRobinServerPicker(serverList),\n\t\tpolicyManager: v.GetFeature(policy.ManagerType()).(policy.Manager),\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\toutbounds := session.OutboundsFromContext(ctx)\n\tob := outbounds[len(outbounds)-1]\n\tif !ob.Target.IsValid() {\n\t\treturn errors.New(\"target not specified.\")\n\t}\n\tob.Name = \"socks\"\n\tob.CanSpliceCopy = 2\n\tdestination := ob.Target\n\n\tvar server *protocol.ServerSpec\n\tvar dest net.Destination\n\tvar conn stat.Connection\n\n\tif err := retry.ExponentialBackoff(5, 100).On(func() error {\n\t\tserver = c.serverPicker.PickServer()\n\t\tdest = server.Destination()\n\t\trawConn, err := dialer.Dial(ctx, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconn = rawConn\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn errors.New(\"failed to find an available destination\").Base(err)\n\t}\n\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\terrors.LogInfoInner(ctx, err, \"failed to closed connection\")\n\t\t}\n\t}()\n\n\tp := c.policyManager.ForLevel(0)\n\n\trequest := &protocol.RequestHeader{\n\t\tVersion: socks5Version,\n\t\tCommand: protocol.RequestCommandTCP,\n\t\tAddress: destination.Address,\n\t\tPort:    destination.Port,\n\t}\n\n\tif destination.Network == net.Network_UDP {\n\t\trequest.Command = protocol.RequestCommandUDP\n\t}\n\n\tuser := server.PickUser()\n\tif user != nil {\n\t\trequest.User = user\n\t\tp = c.policyManager.ForLevel(user.Level)\n\t}\n\n\tif err := conn.SetDeadline(time.Now().Add(p.Timeouts.Handshake)); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to set deadline for handshake\")\n\t}\n\tudpRequest, err := ClientHandshake(request, conn, conn)\n\tif err != nil {\n\t\treturn errors.New(\"failed to establish connection to server\").AtWarning().Base(err)\n\t}\n\tif udpRequest != nil {\n\t\tif udpRequest.Address == net.AnyIP || udpRequest.Address == net.AnyIPv6 {\n\t\t\tudpRequest.Address = dest.Address\n\t\t}\n\t}\n\n\tif err := conn.SetDeadline(time.Time{}); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to clear deadline after handshake\")\n\t}\n\n\tvar newCtx context.Context\n\tvar newCancel context.CancelFunc\n\tif session.TimeoutOnlyFromContext(ctx) {\n\t\tnewCtx, newCancel = context.WithCancel(context.Background())\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\ttimer := signal.CancelAfterInactivity(ctx, func() {\n\t\tcancel()\n\t\tif newCancel != nil {\n\t\t\tnewCancel()\n\t\t}\n\t}, p.Timeouts.ConnectionIdle)\n\n\tvar requestFunc func() error\n\tvar responseFunc func() error\n\tif request.Command == protocol.RequestCommandTCP {\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\treturn buf.Copy(link.Reader, buf.NewWriter(conn), buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treturn buf.Copy(buf.NewReader(conn), link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t} else if request.Command == protocol.RequestCommandUDP {\n\t\tudpConn, err := dialer.Dial(ctx, udpRequest.Destination())\n\t\tif err != nil {\n\t\t\treturn errors.New(\"failed to create UDP connection\").Base(err)\n\t\t}\n\t\tdefer udpConn.Close()\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\twriter := &UDPWriter{Writer: udpConn, Request: request}\n\t\t\treturn buf.Copy(link.Reader, writer, buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treader := &UDPReader{Reader: udpConn}\n\t\t\treturn buf.Copy(reader, link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t}\n\n\tif newCtx != nil {\n\t\tctx = newCtx\n\t}\n\n\tresponseDonePost := task.OnSuccess(responseFunc, task.Close(link.Writer))\n\tif err := task.Run(ctx, requestFunc, responseDonePost); err != nil {\n\t\treturn errors.New(\"connection ends\").Base(err)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tserverPicker protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tclient := &Client{\n\t\tserverPicker: protocol.NewRoundRobinServerPicker(config.Servers),\n\t\tpolicyManager: policy.NewManager(config.Policies),\n\t}\n\treturn client, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\tfor {\n\t\tserver, err := c.serverPicker.Next()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, protocol.ErrNoServersAvailable) {\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tconn, err := dialer.DialContext(ctx, \"tcp\", server.Address())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tif err := c.policyManager.Apply(conn); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := link.Process(conn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Implement a TCP client in Go that periodically sends metrics data to an OpenTSDB server, handling different types of metrics (counters, gauges, histograms, meters, and timers) with appropriate formatting.\n\nStruct Description: The OpenTSDBConfig struct contains configuration parameters for connecting to an OpenTSDB server and sending metrics data at regular intervals.\n\nFields:\nAddr: *net.TCPAddr - The TCP address of the OpenTSDB server\nRegistry: Registry - The metrics registry containing all metrics to be reported\nFlushInterval: time.Duration - The interval at which metrics are sent to the server\nDurationUnit: time.Duration - The time unit for converting timer metrics\nPrefix: string - The prefix to be added to all metric names\n\nMethods:\nOpenTSDBWithConfig: OpenTSDBWithConfig(c OpenTSDBConfig) - Starts a ticker that periodically calls openTSDB with the given configuration at the specified FlushInterval\nopenTSDB: openTSDB(c *OpenTSDBConfig) error - Establishes a TCP connection to the OpenTSDB server, formats and sends all metrics from the registry, and returns any error that occurs during the process",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\ntype OpenTSDBConfig struct {\n\tAddr          *net.TCPAddr\n\tRegistry      Registry\n\tFlushInterval time.Duration\n\tDurationUnit  time.Duration\n\tPrefix        string\n}\n\nfunc OpenTSDBWithConfig(c OpenTSDBConfig) {\n\tfor _ = range time.Tick(c.FlushInterval) {\n\t\tif err := openTSDB(&c); nil != err {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\nfunc openTSDB(c *OpenTSDBConfig) error {\n\tshortHostname := getShortHostname()\n\tnow := time.Now().Unix()\n\tdu := float64(c.DurationUnit)\n\tconn, err := net.DialTCP(\"tcp\", nil, c.Addr)\n\tif nil != err {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tw := bufio.NewWriter(conn)\n\tc.Registry.Each(func(name string, i interface{}) {\n\t\tswitch metric := i.(type) {\n\t\tcase Counter:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, metric.Count(), shortHostname)\n\t\tcase Gauge:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %d host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase GaugeFloat64:\n\t\t\tfmt.Fprintf(w, \"put %s.%s.value %d %f host=%s\\n\", c.Prefix, name, now, metric.Value(), shortHostname)\n\t\tcase Histogram:\n\t\t\th := metric.Snapshot()\n\t\t\tps := h.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, h.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, h.Min(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, h.Max(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, h.Mean(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, h.StdDev(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3], shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4], shortHostname)\n\t\tcase Meter:\n\t\t\tm := metric.Snapshot()\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, m.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, m.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, m.RateMean(), shortHostname)\n\t\tcase Timer:\n\t\t\tt := metric.Snapshot()\n\t\t\tps := t.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999})\n\t\t\tfmt.Fprintf(w, \"put %s.%s.count %d %d host=%s\\n\", c.Prefix, name, now, t.Count(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.min %d %d host=%s\\n\", c.Prefix, name, now, t.Min()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.max %d %d host=%s\\n\", c.Prefix, name, now, t.Max()/int64(du), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean %d %.2f host=%s\\n\", c.Prefix, name, now, t.Mean()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.std-dev %d %.2f host=%s\\n\", c.Prefix, name, now, t.StdDev()/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.50-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[0]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.75-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[1]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.95-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[2]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.99-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[3]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.999-percentile %d %.2f host=%s\\n\", c.Prefix, name, now, ps[4]/du, shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.one-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate1(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.five-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate5(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.fifteen-minute %d %.2f host=%s\\n\", c.Prefix, name, now, t.Rate15(), shortHostname)\n\t\t\tfmt.Fprintf(w, \"put %s.%s.mean-rate %d %.2f host=%s\\n\", c.Prefix, name, now, t.RateMean(), shortHostname)\n\t\t}\n\t\tw.Flush()\n\t})\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/codesenberg/opentsdb\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus/exporter/httphandler\"\n)\n\ntype OpenTSDBConfig struct {\n\tAddr        *net.TCPAddr\n\tRegistry    *prometheus.Registry\n\tFlushInterval time.Duration\n\tDurationUnit time.Duration\n\tPrefix      string\n}\n\nfunc (c *OpenTSDBConfig) OpenTSDBWithConfig() {\n\tticker := time.NewTicker(c.FlushInterval)\n\tfor range ticker.C {\n\t\tif err := c.openTSDB(c); err != nil {\n\t\t\t// Handle error, e.g., log it\n\t\t}\n\t}\n}\n\nfunc (c *OpenTSDBConfig) openTSDB(c *OpenTSDBConfig) error {\n\tclient := opentsdb.NewClient(c.Addr.String())\n\tfor _, m := range c.Registry.Gather() {\n\t\tif m.Type() == prometheus.CounterType {\n\t\t\tclient.Incr(m.Name(), m.Help(), m.Collector(), m.Value())\n\t\t} else if m.Type() == prometheus.GaugeType {\n\t\t\tclient.Set(m.Name(), m.Help(), m.Collector(), m.Value())\n\t\t} else if m.Type() == prometheus.HistogramType {\n\t\t\tclient.Hist(m.Name(), m.Help(), m.Collector(), m.Value())\n\t\t} else if m.Type() == prometheus.MeterType {\n\t\t\tclient.Meter(m.Name(), m.Help(), m.Collector(), m.Value())\n\t\t} else if m.Type() == prometheus.TimerType {\n\t\t\tclient.Timer(m.Name(), m.Help(), m.Collector(), m.Value())\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tconfig := &OpenTSDBConfig{\n\t\tAddr:        &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 4242},\n\t\tRegistry:    prometheus.NewRegistry(),\n\t\tFlushInterval: 10 * time.Second,\n\t\tDurationUnit: time.Second,\n\t\tPrefix:      \"myapp\",\n\t}\n\n\t// Register some metrics\n\tcollectors.NewCounterVec(collectors.CounterOpts{Name: \"requests_total\", Help: \"Total number of requests\"}, []string{\"method\"}).Register(config.Registry)\n\tcollectors.NewGaugeVec(collectors.GaugeOpts{Name: \"active_users\", Help: \"Number of active users\"}, []string{\"region\"}).Register(config.Registry)\n\tcollectors.NewHistogramVec(collectors.HistogramOpts{Name: \"request_duration_seconds\", Help: \"Request duration in seconds\"}, []string{\"method\", \"status_code\"}).Register(config.Registry)\n\tcollectors.NewMeterVec(collectors.MeterOpts{Name: \"request_rate\", Help: \"Request rate\"}, []string{\"method\", \"status_code\"}).Register(config.Registry)\n\tcollectors.NewTimerVec(collectors.TimerOpts{Name: \"request_latency_seconds\", Help: \"Request latency in seconds\"}, []string{\"method\", \"status_code\"}).Register(config.Registry)\n\n\tconfig.OpenTSDBWithConfig()\n}"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Implement a TCP client in Go that can establish connections to servers, handle TLS if required, and manage timeouts for network operations.\n\nStruct Description: The Client struct represents a configurable TCP client capable of handling both plain TCP and TLS connections, with various timeout controls and DNS message exchange functionality.\n\nFields:\n\nNet: string - Network type (e.g., \"tcp\", \"tcp-tls\", \"udp\")\nUDPSize: uint16 - UDP buffer size for DNS messages\nTLSConfig: *tls.Config - TLS configuration for secure connections\nDialer: *net.Dialer - Custom dialer for connection establishment\nTimeout: time.Duration - Overall operation timeout\nDialTimeout: time.Duration - Timeout specifically for connection establishment\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nTsigSecret: map[string]string - TSIG authentication secrets\nSingleInflight: bool - Whether to use singleflight for duplicate request suppression\ngroup: singleflight - Internal singleflight group for request deduplication\n\nMethods:\n\nDial: (address string) -> (*Conn, error) - Establishes a connection to the specified address, handling TLS if configured\nExchange: (m *Msg, address string) -> (*Msg, time.Duration, error) - Performs a complete DNS message exchange with timeout handling\nexchange: (m *Msg, a string) -> (*Msg, time.Duration, error) - Internal method for performing the actual message exchange\ngetTimeoutForRequest: (timeout time.Duration) -> time.Duration - Calculates the appropriate timeout for a request considering various configuration options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tNet       string\n\tUDPSize   uint16\n\tTLSConfig *tls.Config\n\tDialer    *net.Dialer\n\tTimeout   time.Duration\n\tDialTimeout    time.Duration\n\tReadTimeout    time.Duration\n\tWriteTimeout   time.Duration\n\tTsigSecret     map[string]string\n\tSingleInflight bool\n\tgroup          singleflight\n}\n\nfunc (c *Client) Dial(address string) (conn *Conn, err error) {\n\tvar d net.Dialer\n\tif c.Dialer == nil {\n\t\td = net.Dialer{Timeout: c.getTimeoutForRequest(c.dialTimeout())}\n\t} else {\n\t\td = *c.Dialer\n\t}\n\n\tnetwork := c.Net\n\tif network == \"\" {\n\t\tnetwork = \"udp\"\n\t}\n\n\tuseTLS := strings.HasPrefix(network, \"tcp\") && strings.HasSuffix(network, \"-tls\")\n\n\tconn = new(Conn)\n\tif useTLS {\n\t\tnetwork = strings.TrimSuffix(network, \"-tls\")\n\t\tconn.Conn, err = tls.DialWithDialer(&d, network, address, c.TLSConfig)\n\t} else {\n\t\tconn.Conn, err = d.Dial(network, address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (r *Msg, rtt time.Duration, err error) {\n\tif !c.SingleInflight {\n\t\treturn c.exchange(m, address)\n\t}\n\n\tq := m.Question[0]\n\tkey := fmt.Sprintf(\"%s:%d:%d\", q.Name, q.Qtype, q.Qclass)\n\tr, rtt, err, shared := c.group.Do(key, func() (*Msg, time.Duration, error) {\n\t\treturn c.exchange(m, address)\n\t})\n\tif r != nil && shared {\n\t\tr = r.Copy()\n\t}\n\n\treturn r, rtt, err\n}\n\nfunc (c *Client) exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {\n\tvar co *Conn\n\n\tco, err = c.Dial(a)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer co.Close()\n\n\topt := m.IsEdns0()\n\tif opt != nil && opt.UDPSize() >= MinMsgSize {\n\t\tco.UDPSize = opt.UDPSize()\n\t}\n\tif opt == nil && c.UDPSize >= MinMsgSize {\n\t\tco.UDPSize = c.UDPSize\n\t}\n\n\tco.TsigSecret = c.TsigSecret\n\tt := time.Now()\n\tco.SetWriteDeadline(t.Add(c.getTimeoutForRequest(c.writeTimeout())))\n\tif err = co.WriteMsg(m); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tco.SetReadDeadline(time.Now().Add(c.getTimeoutForRequest(c.readTimeout())))\n\tr, err = co.ReadMsg()\n\tif err == nil && r.Id != m.Id {\n\t\terr = ErrId\n\t}\n\trtt = time.Since(t)\n\treturn r, rtt, err\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tvar requestTimeout time.Duration\n\tif c.Timeout != 0 {\n\t\trequestTimeout = c.Timeout\n\t} else {\n\t\trequestTimeout = timeout\n\t}\n\tif c.Dialer != nil && c.Dialer.Timeout != 0 {\n\t\tif c.Dialer.Timeout < requestTimeout {\n\t\t\trequestTimeout = c.Dialer.Timeout\n\t\t}\n\t}\n\treturn requestTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tNet           string\n\tUDPSize       uint16\n\tTLSConfig     *tls.Config\n\tDialer        *net.Dialer\n\tTimeout       time.Duration\n\tDialTimeout   time.Duration\n\tReadTimeout   time.Duration\n\tWriteTimeout  time.Duration\n\tTsigSecret    map[string]string\n\tSingleInflight bool\n\tgroup         *singleflight.Group\n}\n\nfunc (c *Client) Dial(address string) (*Conn, error) {\n\tif c.Net == \"tcp-tls\" {\n\t\treturn c.dialTLS(address)\n\t}\n\treturn c.dialTCP(address)\n}\n\nfunc (c *Client) dialTCP(address string) (*Conn, error) {\n\tconn, err := c.Dialer.Dial(\"tcp\", address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Conn{conn: conn}, nil\n}\n\nfunc (c *Client) dialTLS(address string) (*Conn, error) {\n\ttlsConn := tls.Client(c.Dialer.Dial(\"tcp\", address), c.TLSConfig)\n\tif err := tlsConn.Handshake(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Conn{conn: tlsConn}, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (*Msg, time.Duration, error) {\n\ttimeout := c.getTimeoutForRequest(c.Timeout)\n\treturn c.exchange(m, address, timeout)\n}\n\nfunc (c *Client) exchange(m *Msg, a string, timeout time.Duration) (*Msg, time.Duration, error) {\n\tif c.SingleInflight {\n\t\t// Implement singleflight logic here\n\t}\n\t// Perform the actual message exchange\n\treturn m, timeout, nil\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tif c.DialTimeout > 0 {\n\t\ttimeout = c.DialTimeout\n\t}\n\tif c.ReadTimeout > 0 {\n\t\ttimeout = c.ReadTimeout\n\t}\n\tif c.WriteTimeout > 0 {\n\t\ttimeout = c.WriteTimeout\n\t}\n\treturn timeout\n}"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a Git daemon in Go that handles TCP connections for Git operations, including upload-pack and upload-archive services, with connection management, timeout handling, and access control.\n\nStruct Description: The GitDaemon struct represents a TCP server that handles Git protocol connections. It manages client connections, enforces limits, and processes Git service requests.\n\nFields:\n\nctx: [context.Context] - Context for cancellation and timeout propagation  \naddr: [string] - TCP address to listen on  \nfinished: [chan struct{}] - Channel to signal server shutdown  \nconns: [connections] - Track active connections (wrapper around map[net.Conn]struct{})  \ncfg: [*config.Config] - Server configuration  \nbe: [*backend.Backend] - Backend for repository access and authentication  \nwg: [sync.WaitGroup] - Wait group for graceful shutdown  \nonce: [sync.Once] - Ensure cleanup happens once  \nlogger: [*log.Logger] - Structured logger  \ndone: [atomic.Bool] - Atomic flag indicating server shutdown status  \n\nMethods:\n\nNewGitDaemon: [func(context.Context) (*GitDaemon, error)] -> Creates a new GitDaemon instance with context-derived configuration  \nListenAndServe: [func() error] -> Starts listening on configured address and serves connections  \nServe: [func(net.Listener) error] -> Handles incoming connections on provided listener (main server loop)  \nhandleClient: [func(net.Conn)] -> Processes individual client connections (private method)  \n\nHelper Types:\n\nserverConn: [struct] - Wraps net.Conn with timeout handling  \nconnections: [struct] - Thread-safe connection tracking with sync.Map  \n\nKey Behaviors:\n1. Implements exponential backoff for temporary connection errors\n2. Enforces maximum connection limits\n3. Handles Git protocol packets (pktline format)\n4. Validates repository paths and access permissions\n5. Processes both git-upload-pack and git-upload-archive services\n6. Implements idle and maximum timeout handling\n7. Provides clean shutdown via context cancellation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/soft-serve/pkg/access\"\n\t\"github.com/charmbracelet/soft-serve/pkg/backend\"\n\t\"github.com/charmbracelet/soft-serve/pkg/config\"\n\t\"github.com/charmbracelet/soft-serve/pkg/git\"\n\t\"github.com/charmbracelet/soft-serve/pkg/utils\"\n\t\"github.com/go-git/go-git/v5/plumbing/format/pktline\"\n)\n\ntype GitDaemon struct {\n\tctx      context.Context\n\taddr     string\n\tfinished chan struct{}\n\tconns    connections\n\tcfg      *config.Config\n\tbe       *backend.Backend\n\twg       sync.WaitGroup\n\tonce     sync.Once\n\tlogger   *log.Logger\n\tdone     atomic.Bool\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg := config.FromContext(ctx)\n\taddr := cfg.Git.ListenAddr\n\td := &GitDaemon{\n\t\tctx:      ctx,\n\t\taddr:     addr,\n\t\tfinished: make(chan struct{}, 1),\n\t\tcfg:      cfg,\n\t\tbe:       backend.FromContext(ctx),\n\t\tconns:    connections{m: make(map[net.Conn]struct{})},\n\t\tlogger:   log.FromContext(ctx).WithPrefix(\"gitdaemon\"),\n\t}\n\treturn d, nil\n}\n\nfunc (d *GitDaemon) ListenAndServe() error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\tlistener, err := net.Listen(\"tcp\", d.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.Serve(listener)\n}\n\nfunc (d *GitDaemon) Serve(listener net.Listener) error {\n\tif d.done.Load() {\n\t\treturn ErrServerClosed\n\t}\n\n\td.wg.Add(1)\n\tdefer d.wg.Done()\n\tdefer listener.Close()\n\n\tvar tempDelay time.Duration\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-d.finished:\n\t\t\t\treturn ErrServerClosed\n\t\t\tdefault:\n\t\t\t\td.logger.Debugf(\"git: error accepting connection: %v\", err)\n\t\t\t}\n\t\t\tif ne, ok := err.(net.Error); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif d.conns.Size()+1 >= d.cfg.Git.MaxConnections {\n\t\t\td.logger.Debugf(\"git: max connections reached, closing %s\", conn.RemoteAddr())\n\t\t\td.fatal(conn, git.ErrMaxConnections)\n\t\t\tcontinue\n\t\t}\n\n\t\td.wg.Add(1)\n\t\tgo func() {\n\t\t\td.handleClient(conn)\n\t\t\td.wg.Done()\n\t\t}()\n\t}\n}\n\nfunc (d *GitDaemon) handleClient(conn net.Conn) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tidleTimeout := time.Duration(d.cfg.Git.IdleTimeout) * time.Second\n\tc := &serverConn{\n\t\tConn:          conn,\n\t\tidleTimeout:   idleTimeout,\n\t\tcloseCanceler: cancel,\n\t}\n\tif d.cfg.Git.MaxTimeout > 0 {\n\t\tdur := time.Duration(d.cfg.Git.MaxTimeout) * time.Second\n\t\tc.maxDeadline = time.Now().Add(dur)\n\t}\n\td.conns.Add(c)\n\tdefer func() {\n\t\td.conns.Close(c)\n\t}()\n\n\terrc := make(chan error, 1)\n\n\ts := pktline.NewScanner(c)\n\tgo func() {\n\t\tif !s.Scan() {\n\t\t\tif err := s.Err(); err != nil {\n\t\t\t\terrc <- err\n\t\t\t}\n\t\t}\n\t\terrc <- nil\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tif err := ctx.Err(); err != nil {\n\t\t\td.logger.Debugf(\"git: connection context error: %v\", err)\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t}\n\t\treturn\n\tcase err := <-errc:\n\t\tif nerr, ok := err.(net.Error); ok && nerr.Timeout() {\n\t\t\td.fatal(c, git.ErrTimeout)\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\td.logger.Debugf(\"git: error scanning pktline: %v\", err)\n\t\t\td.fatal(c, git.ErrSystemMalfunction)\n\t\t\treturn\n\t\t}\n\n\t\tline := s.Bytes()\n\t\tsplit := bytes.SplitN(line, []byte{' '}, 2)\n\t\tif len(split) != 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\tservice := git.Service(split[0])\n\t\tswitch service {\n\t\tcase git.UploadPackService:\n\t\tcase git.UploadArchiveService:\n\t\tdefault:\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\topts := bytes.SplitN(split[1], []byte{0}, 3)\n\t\tif len(opts) < 2 {\n\t\t\td.fatal(c, git.ErrInvalidRequest)\n\t\t\treturn\n\t\t}\n\n\t\thost := strings.TrimPrefix(string(opts[1]), \"host=\")\n\t\textraParams := map[string]string{}\n\n\t\tif len(opts) > 2 {\n\t\t\tbuf := bytes.TrimPrefix(opts[2], []byte{0})\n\t\t\tfor _, o := range bytes.Split(buf, []byte{0}) {\n\t\t\t\topt := string(o)\n\t\t\t\tif opt == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tkv := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(kv) != 2 {\n\t\t\t\t\td.logger.Errorf(\"git: invalid option %q\", opt)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\textraParams[kv[0]] = kv[1]\n\t\t\t}\n\t\t}\n\n\t\tbe := d.be\n\t\tif !be.AllowKeyless(ctx) {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tname := utils.SanitizeRepo(string(opts[0]))\n\t\td.logger.Debugf(\"git: connect %s %s %s\", c.RemoteAddr(), service, name)\n\t\tdefer d.logger.Debugf(\"git: disconnect %s %s %s\", c.RemoteAddr(), service, name)\n\n\t\trepo := name + \".git\"\n\t\treposDir := filepath.Join(d.cfg.DataPath, \"repos\")\n\t\tif err := git.EnsureWithin(reposDir, repo); err != nil {\n\t\t\td.logger.Debugf(\"git: error ensuring repo path: %v\", err)\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tif _, err := d.be.Repository(ctx, repo); err != nil {\n\t\t\td.fatal(c, git.ErrInvalidRepo)\n\t\t\treturn\n\t\t}\n\n\t\tauth := be.AccessLevel(ctx, name, \"\")\n\t\tif auth < access.ReadOnlyAccess {\n\t\t\td.fatal(c, git.ErrNotAuthed)\n\t\t\treturn\n\t\t}\n\n\t\tenvs := []string{\n\t\t\t\"SOFT_SERVE_REPO_NAME=\" + name,\n\t\t\t\"SOFT_SERVE_REPO_PATH=\" + filepath.Join(reposDir, repo),\n\t\t\t\"SOFT_SERVE_HOST=\" + host,\n\t\t\t\"SOFT_SERVE_LOG_PATH=\" + filepath.Join(d.cfg.DataPath, \"log\", \"hooks.log\"),\n\t\t}\n\n\t\tif len(extraParams) > 0 {\n\t\t\tvar gitProto string\n\t\t\tfor k, v := range extraParams {\n\t\t\t\tif len(gitProto) > 0 {\n\t\t\t\t\tgitProto += \":\"\n\t\t\t\t}\n\t\t\t\tgitProto += k + \"=\" + v\n\t\t\t}\n\t\t\tenvs = append(envs, \"GIT_PROTOCOL=\"+gitProto)\n\t\t}\n\n\t\tenvs = append(envs, d.cfg.Environ()...)\n\n\t\tcmd := git.ServiceCommand{\n\t\t\tStdin:  c,\n\t\t\tStdout: c,\n\t\t\tStderr: c,\n\t\t\tEnv:    envs,\n\t\t\tDir:    filepath.Join(reposDir, repo),\n\t\t}\n\n\t\tif err := service.Handler(ctx, cmd); err != nil {\n\t\t\td.logger.Debugf(\"git: error handling request: %v\", err)\n\t\t\td.fatal(c, err)\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-kit/log\"\n)\n\ntype serverConn struct {\n\tconn net.Conn\n\tttl  time.Time\n}\n\ntype connections struct {\n\tmu      sync.RWMutex\n\tconns   map[net.Conn]struct{}\n\tmaxConns int\n}\n\ntype GitDaemon struct {\n\tctx      context.Context\n\taddr     string\n\tfinished chan struct{}\n\tconns    *connections\n\tcfg      *config.Config\n\tbe       *backend.Backend\n\twg       sync.WaitGroup\n\tonce     sync.Once\n\tlogger   *log.Logger\n\tdone     atomic.Bool\n}\n\nfunc NewGitDaemon(ctx context.Context) (*GitDaemon, error) {\n\tcfg := &config.Config{\n\t\tMaxConnections: 100,\n\t\tTimeout:         60 * time.Second,\n\t}\n\treturn &GitDaemon{\n\t\tctx:      ctx,\n\t\taddr:     \"localhost:9418\",\n\t\tfinished: make(chan struct{}),\n\t\tconns: &connections{\n\t\t\tmu:      sync.RWMutex{},\n\t\t\tconns:   make(map[net.Conn]struct{}),\n\t\t\tmaxConns: cfg.MaxConnections,\n\t\t},\n\t\tcfg:      cfg,\n\t\tbe:       &backend.Backend{},\n\t\twg:       sync.WaitGroup{},\n\t\tonce:     sync.Once{},\n\t\tlogger:   log.New(log.Stdout{Inferencer: log.NewJSONInferencer()}),\n\t\tdone:     atomic.Bool{},\n\t}, nil\n}\n\nfunc (g *GitDaemon) ListenAndServe() error {\n\tln, err := net.Listen(\"tcp\", g.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tg.wg.Add(1)\n\tgo func() {\n\t\tdefer g.wg.Done()\n\t\tfor {\n\t\t\tconn, err := ln.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif err == net.ErrClosed {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tg.logger.Log(\"msg\", \"accept error\", \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tg.handleClient(conn)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (g *GitDaemon) Serve(ln net.Listener) error {\n\tg.wg.Add(1)\n\tgo func() {\n\t\tdefer g.wg.Done()\n\t\tfor {\n\t\t\tconn, err := ln.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif err == net.ErrClosed {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tg.logger.Log(\"msg\", \"accept error\", \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tg.handleClient(conn)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (g *GitDaemon) handleClient(conn net.Conn) {\n\tsc := &serverConn{\n\t\tconn: conn,\n\t\tttl:  time.Now().Add(g.cfg.Timeout),\n\t}\n\tg.conns.mu.Lock()\n\tdefer g.conns.mu.Unlock()\n\tif len(g.conns.conns) >= g.cfg.MaxConnections {\n\t\tconn.Close()\n\t\treturn\n\t}\n\tg.conns.conns[sc.conn] = struct{}{}\n\tdefer func() {\n\t\tdelete(g.conns.conns, sc.conn)\n\t\tsc.conn.Close()\n\t}()\n\t\n\tfor {\n\t\tselect {\n\t\tcase <-g.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\t// Process Git protocol packets\n\t\t\tpacket, err := readPacket(sc.conn)\n\t\t\tif err != nil {\n\t\t\t\tg.logger.Log(\"msg\", \"packet read error\", \"err\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif packet.Type == \"upload-pack\" {\n\t\t\t\t// Handle upload-pack service\n\t\t\t\tg.logger.Log(\"msg\", \"handling upload-pack\")\n\t\t\t} else if packet.Type == \"upload-archive\" {\n\t\t\t\t// Handle upload-archive service\n\t\t\t\tg.logger.Log(\"msg\", \"handling upload-archive\")\n\t\t\t} else {\n\t\t\t\tg.logger.Log(\"msg\", \"unknown packet type\", \"type\", packet.Type)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readPacket(conn net.Conn) ([]byte, error) {\n\t// Implement pktline packet reading logic\n\t// This is a simplified version and would need to be expanded for full Git protocol support\n\tpacket := make([]byte, 1)\n\tfor {\n\t\tn, err := conn.Read(packet)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif n > 0 {\n\t\t\tif packet[0] == 0 {\n\t\t\t\treturn packet, nil\n\t\t\t}\n\t\t\tpacket = append(packet, make([]byte, 1)...)\n\t\t}\n\t}\n}\n\ntype config struct {\n\tMaxConnections int\n\tTimeout        time.Duration\n}\n\ntype backend struct{}\n\nfunc (b *backend) Authenticate(user, pass string) bool {\n\t// Implement authentication logic\n\treturn true\n}\n\nfunc (b *backend) GetRepoPath(user, repo string) string {\n\t// Implement repository path lookup\n\treturn \"/path/to/repo\"\n}"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management. The server should be able to start, accept connections, read data from clients, and properly shut down while cleaning up resources.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management capabilities. It maintains state about active connections and provides methods to start, serve, and manage the server lifecycle.\n\nFields:\n\nAddr: [string] - The network address to listen on (e.g., \":8080\")\nNet: [string] - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: [Handler] - The handler for processing incoming requests\nReadTimeout: [time.Duration] - Maximum duration for reading a request\nWriteTimeout: [time.Duration] - Maximum duration for writing a response\nIdleTimeout: [func() time.Duration] - Function returning idle connection timeout\nlock: [sync.RWMutex] - Protects concurrent access to server state\nstarted: [bool] - Indicates if server is running\nshutdown: [chan struct{}] - Channel for shutdown signaling\nconns: [map[net.Conn]struct{}] - Map of active connections\n\nMethods:\n\nListenAndServe: [Name]() -> [error] - Starts the server and begins accepting connections\nserveTCP: [Name](net.Listener) -> [error] - Main TCP serving loop that accepts connections\nserveTCPConn: [Name](*sync.WaitGroup, net.Conn) -> [] - Handles an individual TCP connection\nreadTCP: [Name](net.Conn, time.Duration) -> ([]byte, error) - Reads data from a TCP connection\ninit: [Name]() -> [] - Initializes server resources\nisStarted: [Name]() -> [bool] - Checks if server is running\ngetIdleTimeout: [Name]() -> [time.Duration] - Returns idle timeout duration\ngetReadTimeout: [Name]() -> [time.Duration] - Returns read timeout duration",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := net.Listen(srv.Net, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer wg.Done()\n\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := srv.getIdleTimeout()\n\n\tfor srv.isStarted() {\n\t\tm, err := srv.readTCP(rw, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n}\n\nfunc (srv *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\n\tvar length uint16\n\tif err := binary.Read(conn, binary.BigEndian, &length); err != nil {\n\t\treturn nil, err\n\t}\n\n\tm := make([]byte, length)\n\tif _, err := io.ReadFull(conn, m); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn m, nil\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getIdleTimeout() time.Duration {\n\tif srv.IdleTimeout != nil {\n\t\treturn srv.IdleTimeout()\n\t}\n\treturn tcpIdleTimeout\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler func(conn net.Conn)\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn nil\n\t}\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n\ts.started = true\n\tgo s.serveTCP(listener)\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t}()\n\t// Set timeouts on the connection\n\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\ts.Handler(conn)\n\t}\n}\n\nfunc (s *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {\n\tconn.SetReadDeadline(time.Now().Add(timeout))\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf[:n], nil\n}\n\nfunc (s *Server) init() {\n\t// Initialize server resources\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getIdleTimeout() time.Duration {\n\treturn s.IdleTimeout()\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Go struct that manages multiple TCP and UDP listeners for a proxy server, with methods to register and handle incoming connections.\n\nStruct Description: The Proxy struct manages network listeners for UDP, TCP, and local DNS-over-HTTPS (DoH) connections. It provides methods to create listeners from addresses and handle incoming connections through separate goroutines.\n\nFields:\nudpListeners: []*net.UDPConn - Slice of active UDP listeners\ntcpListeners: []*net.TCPListener - Slice of active TCP listeners\nlocalDoHListeners: []*net.TCPListener - Slice of active local DoH TCP listeners\n\nMethods:\nregisterUDPListener(*net.UDPConn) -> void - Adds a UDP listener to the udpListeners slice\nregisterTCPListener(*net.TCPListener) -> void - Adds a TCP listener to the tcpListeners slice\nregisterLocalDoHListener(*net.TCPListener) -> void - Adds a local DoH listener to the localDoHListeners slice\nudpListenerFromAddr(*net.UDPAddr) -> error - Creates and registers a UDP listener from address\ntcpListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a TCP listener from address\nlocalDoHListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a local DoH listener from address\nudpListener(*net.UDPConn) -> void - Handles incoming UDP connections (runs in goroutine)\ntcpListener(*net.TCPListener) -> void - Handles incoming TCP connections (runs in goroutine)\nstartAcceptingClients() -> void - Starts all registered listeners in separate goroutines",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners    []*net.UDPConn\n\ttcpListeners    []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (proxy *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tproxy.udpListeners = append(proxy.udpListeners, conn)\n}\n\nfunc (proxy *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tproxy.tcpListeners = append(proxy.tcpListeners, listener)\n}\n\nfunc (proxy *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tproxy.localDoHListeners = append(proxy.localDoHListeners, listener)\n}\n\nfunc (proxy *Proxy) udpListenerFromAddr(listenAddr *net.UDPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"udp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"udp4\"\n\t}\n\tclientPc, err := net.ListenUDP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerUDPListener(clientPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) tcpListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerTCPListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) localDoHListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerLocalDoHListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) udpListener(clientPc *net.UDPConn) {\n\tdefer clientPc.Close()\n\tfor {\n\t\tbuffer := make([]byte, MaxDNSPacketSize-1)\n\t\tlength, clientAddr, err := clientPc.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tpacket := buffer[:length]\n\t\tgo proxy.processIncomingQuery(\"udp\", \"udp\", packet, &clientAddr, clientPc, time.Now(), false)\n\t}\n}\n\nfunc (proxy *Proxy) tcpListener(acceptPc *net.TCPListener) {\n\tdefer acceptPc.Close()\n\tfor {\n\t\tclientPc, err := acceptPc.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tdefer clientPc.Close()\n\t\t\tif err := clientPc.SetDeadline(time.Now().Add(proxy.timeout)); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart := time.Now()\n\t\t\tpacket, err := ReadPrefixed(&clientPc)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclientAddr := clientPc.RemoteAddr()\n\t\t\tproxy.processIncomingQuery(\"tcp\", \"tcp\", packet, &clientAddr, clientPc, start, false)\n\t\t}()\n\t}\n}\n\nfunc (proxy *Proxy) startAcceptingClients() {\n\tfor _, clientPc := range proxy.udpListeners {\n\t\tgo proxy.udpListener(clientPc)\n\t}\n\tproxy.udpListeners = nil\n\tfor _, acceptPc := range proxy.tcpListeners {\n\t\tgo proxy.tcpListener(acceptPc)\n\t}\n\tproxy.tcpListeners = nil\n\tfor _, acceptPc := range proxy.localDoHListeners {\n\t\tgo proxy.localDoHListener(acceptPc)\n\t}\n\tproxy.localDoHListeners = nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners      []*net.UDPConn\n\ttcpListeners      []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (p *Proxy) registerUDPListener(l *net.UDPConn) {\n\tp.udpListeners = append(p.udpListeners, l)\n}\n\nfunc (p *Proxy) registerTCPListener(l *net.TCPListener) {\n\tp.tcpListeners = append(p.tcpListeners, l)\n}\n\nfunc (p *Proxy) registerLocalDoHListener(l *net.TCPListener) {\n\tp.localDoHListeners = append(p.localDoHListeners, l)\n}\n\nfunc (p *Proxy) udpListenerFromAddr(addr *net.UDPAddr) error {\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerUDPListener(conn)\n\treturn nil\n}\n\nfunc (p *Proxy) tcpListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerTCPListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) localDoHListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerLocalDoHListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) udpListener(conn *net.UDPConn) {\n\tgo func() {\n\t\tbuf := make([]byte, 1024)\n\t\tfor {\n\t\t\tn, _, err := conn.ReadFrom(buf)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Handle UDP connection\n\t\t}\n\t}()\n}\n\nfunc (p *Proxy) tcpListener(listener *net.TCPListener) {\n\tgo func() {\n\t\tfor {\n\t\t\tconn, err := listener.AcceptTCP()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Handle TCP connection\n\t\t}\n\t}()\n}\n\nfunc (p *Proxy) startAcceptingClients() {\n\tfor _, listener := range p.tcpListeners {\n\t\tp.tcpListener(listener)\n\t}\n\tfor _, listener := range p.udpListeners {\n\t\tp.udpListener(listener)\n\t}\n\tfor _, listener := range p.localDoHListeners {\n\t\tp.tcpListener(listener)\n\t}\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a Go struct that manages HTTP requests to interact with a community persistence service, including authentication and community creation functionality.\n\nStruct Description: The Manager struct provides methods to interact with a community persistence API, handling authentication and request/response processing. It maintains connection details and context for request cancellation.\n\nFields:\nurl: string - Base URL of the community persistence service\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nctx: context.Context - Context for request cancellation and timeouts\n\nMethods:\nNewManager: (url string, username string, password string, ctx context.Context) -> *Manager - Constructor that initializes a new Manager instance with connection details and context\nCreatePersistentCommunity: (community string, password string) -> (*persisters.Community, error) - Creates a new persistent community by making an authenticated POST request to the service, returning the created community or an error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/pojntfx/weron/internal/persisters\"\n)\n\nvar (\n\tjson = jsoniter.ConfigCompatibleWithStandardLibrary\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(\n\turl string,\n\tusername string,\n\tpassword string,\n\tctx context.Context,\n) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\thc := &http.Client{}\n\n\tu, err := url.Parse(m.url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := u.Query()\n\tq.Set(\"community\", community)\n\tq.Set(\"password\", password)\n\tu.RawQuery = q.Encode()\n\n\treq, err := http.NewRequest(http.MethodPost, u.String(), http.NoBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\n\tres, err := hc.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(res.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := persisters.Community{}\n\tif err := json.Unmarshal(body, &c); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &c, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(url, username, password string, ctx context.Context) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\t// Construct the request URL\n\treqURL := strings.Join([]string{m.url, \"/create-community\"}, \"\")\n\t\n\t// Set up the HTTP request\n\treq, err := http.NewRequest(\"POST\", reqURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Set headers\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\n\t// Set basic authentication\n\treq.SetBasicAuth(m.username, m.password)\n\t\n\t// Send the request with the provided context\n\tresp, err := http.DefaultClient.Do(req.WithContext(m.ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\t\n\t// Check for HTTP errors\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, &http.Error{StatusCode: resp.StatusCode, Body: resp.Body}\n\t}\n\t\n\t// Parse the response into a Community object\n\tvar communityResult persisters.Community\n\tif err := json.NewDecoder(resp.Body).Decode(&communityResult); err != nil {\n\t\treturn nil, err\n\t}\n\t\n\treturn &communityResult, nil\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Implement a high-performance TCP server in Go using kqueue for event notification, capable of handling multiple client connections efficiently with non-blocking I/O operations.\n\nStruct Description: The `poller` struct manages a single kqueue instance and handles all I/O operations for its assigned connections. It works as part of an engine (`g *Engine`) to process network events either as a listener (accepting new connections) or as a worker (handling read/write operations).\n\nFields:\n\ng: *Engine - Reference to the parent engine managing all pollers\nmux: sync.Mutex - Mutex for thread-safe access to eventList\nkfd: int - Kqueue file descriptor\nevtfd: int - Event file descriptor (unused in current implementation)\nindex: int - Poller's index in the engine's poller array\nshutdown: bool - Flag to control poller shutdown\nlistener: net.Listener - TCP listener (only for listener pollers)\nisListener: bool - Flag indicating if this is a listener poller\nunixSockAddr: string - Unix socket address (if using UNIX domain sockets)\nReadBuffer: []byte - Buffer for read operations\npollType: string - Type identifier (\"LISTENER\" or \"POLLER\")\neventList: []syscall.Kevent_t - Pending kqueue events to be processed\n\nMethods:\n\naddConn(c *Conn) -> error - Adds a new connection to the poller and registers it for read events\naddDialer(c *Conn) -> error - Adds a dialer connection and registers it for read/write events\ngetConn(fd int) -> *Conn - Retrieves a connection by file descriptor\ndeleteConn(c *Conn) -> - Removes a connection from tracking\ntrigger() -> - Wakes up the kqueue loop\naddRead(fd int) -> - Registers a file descriptor for read events\nresetRead(fd int) -> - Unregisters write events for a file descriptor\nmodWrite(fd int) -> - Registers a file descriptor for write events\naddReadWrite(fd int) -> - Registers a file descriptor for both read and write events\nreadWrite(ev *syscall.Kevent_t) -> - Processes read/write events from kqueue\nstart() -> - Starts the poller's main loop (either acceptorLoop or readWriteLoop)\nacceptorLoop() -> - Listener's main loop that accepts new connections\nreadWriteLoop() -> - Worker's main loop that processes I/O events\nstop() -> - Stops the poller and cleans up resources\nnewPoller(g *Engine, isListener bool, index int) -> (*poller, error) - Constructor that creates either a listener or worker poller",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n\t\"runtime\"\n)\n\ntype poller struct {\n\tg          *Engine\n\tmux        sync.Mutex\n\tkfd        int\n\tevtfd      int\n\tindex      int\n\tshutdown   bool\n\tlistener   net.Listener\n\tisListener bool\n\tunixSockAddr string\n\tReadBuffer []byte\n\tpollType   string\n\teventList  []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\t// Add connection logic\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\t// Add dialer connection logic\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\t// Get connection by file descriptor logic\n\treturn nil\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\t// Remove connection from tracking logic\n}\n\nfunc (p *poller) trigger() {\n\t// Wake up the kqueue loop logic\n}\n\nfunc (p *poller) addRead(fd int) {\n\t// Register a file descriptor for read events logic\n}\n\nfunc (p *poller) resetRead(fd int) {\n\t// Unregister write events for a file descriptor logic\n}\n\nfunc (p *poller) modWrite(fd int) {\n\t// Register a file descriptor for write events logic\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\t// Register a file descriptor for both read and write events logic\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\t// Process read/write events from kqueue logic\n}\n\nfunc (p *poller) start() {\n\t// Start the poller's main loop logic\n}\n\nfunc (p *poller) acceptorLoop() {\n\t// Listener's main loop that accepts new connections logic\n}\n\nfunc (p *poller) readWriteLoop() {\n\t// Worker's main loop that processes I/O events logic\n}\n\nfunc (p *poller) stop() {\n\t// Stop the poller and cleans up resources logic\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\t// Constructor that creates either a listener or worker poller logic\n\treturn nil, nil\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Implement a TCP server in Go that handles client connections, processes incoming messages, and generates appropriate responses based on the message type. The server should support graceful shutdown and concurrent client handling.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, processes client requests, and maintains server state including messages, errors, and connection information.\n\nFields:\n- Addr: net.Addr - The network address the server is listening on\n- mu: sync.Mutex - Mutex for thread-safe operations\n- wg: sync.WaitGroup - WaitGroup for managing goroutines\n- closed: bool - Flag indicating if the server is closed\n- closing: chan struct{} - Channel for shutdown signaling\n- messages: []Message - Collection of processed messages\n- errors: []error - Collection of encountered errors\n- brokerMessage: []byte - Pre-prepared broker message data\n- nodeID: int32 - Identifier for the server node\n- partitionCount: int32 - Number of partitions for topic handling\n\nMethods:\n- NewServer() -> (*Server, error) - Creates and starts a new Server instance\n- prepareBrokerMsg() - Prepares the broker message with server information\n- Close() - Gracefully shuts down the server\n- run(net.Listener) - Main server loop handling connections\n- handle(net.Conn) -> error - Processes individual client connections\n- readProduceRequest([]byte) -> (string, []Response, error) - Helper for produce requests\n- readStrList([]byte) -> ([]string, int) - Helper for reading string lists",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr net.Addr\n\tmu   sync.Mutex\n\twg   sync.WaitGroup\n\n\tclosed  bool\n\tclosing chan struct{}\n\n\tmessages []Message\n\terrors   []error\n\n\tbrokerMessage []byte\n\tnodeID        int32\n\n\tpartitionCount int32\n}\n\nfunc NewServer() (*Server, error) {\n\ts := &Server{\n\t\tclosing:        make(chan struct{}),\n\t\tnodeID:         1,\n\t\tpartitionCount: 3,\n\t}\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.Addr = l.Addr()\n\n\ts.prepareBrokerMsg()\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\ts.run(l)\n\t}()\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\thost, port, _ := net.SplitHostPort(s.Addr.String())\n\ts.brokerMessage = make([]byte, 0, 4+2+len(host)+4)\n\ts.brokerMessage = writeInt32(s.brokerMessage, s.nodeID)\n\ts.brokerMessage = writeStr(s.brokerMessage, host)\n\tportN, _ := strconv.Atoi(port)\n\ts.brokerMessage = writeInt32(s.brokerMessage, int32(portN))\n\ts.brokerMessage = writeInt16(s.brokerMessage, -1)\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn\n\t}\n\ts.closed = true\n\tclose(s.closing)\n\ts.wg.Wait()\n}\n\nfunc (s *Server) run(l net.Listener) {\n\tdefer l.Close()\n\n\taccepts := make(chan net.Conn)\n\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tfor {\n\t\t\tc, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase accepts <- c:\n\t\t\tcase <-s.closing:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase c := <-accepts:\n\t\t\tgo func() {\n\t\t\t\tdefer c.Close()\n\t\t\t\tfor {\n\t\t\t\t\tif err := s.handle(c); err != nil {\n\t\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.mu.Lock()\n\t\t\t\t\t\ts.errors = append(s.errors, err)\n\t\t\t\t\t\ts.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\tcase <-s.closing:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Server) handle(c net.Conn) error {\n\tvar size int32\n\terr := binary.Read(c, binary.BigEndian, &size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, int(size))\n\n\t_, err = io.ReadFull(c, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tapiKey := int16(binary.BigEndian.Uint16(buf[:2]))\n\tversion := int16(binary.BigEndian.Uint16(buf[2:4]))\n\t_, n := readStr(buf[8:])\n\trequest := buf[8+n:]\n\n\tresponse := make([]byte, 8, 1024)\n\tcopy(response[4:], buf[4:8])\n\n\tswitch apiKey {\n\tcase 0:\n\t\ttopic, responses, err := s.readProduceRequest(request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresponse = writeArrayHeader(response, 1)\n\t\tresponse = writeStr(response, topic)\n\t\tresponse = writeArrayHeader(response, int32(len(responses)))\n\t\tfor _, r := range responses {\n\t\t\tresponse = writeInt32(response, 0)\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeInt64(response, r.offset)\n\t\t\tresponse = writeInt64(response, 0)\n\t\t\tif version >= 5 {\n\t\t\t\tresponse = writeInt64(response, 0)\n\t\t\t}\n\t\t}\n\t\tresponse = writeInt32(response, 0)\n\n\tcase 3:\n\t\ttopics, _ := readStrList(request)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArray(response, [][]byte{s.brokerMessage})\n\t\tresponse = writeInt16(response, -1)\n\t\tresponse = writeInt32(response, 0)\n\t\tresponse = writeArrayHeader(response, int32(len(topics)))\n\t\tfor _, t := range topics {\n\t\t\tresponse = writeInt16(response, 0)\n\t\t\tresponse = writeStr(response, t)\n\t\t\tresponse = writeBool(response, false)\n\t\t\tresponse = writeArrayHeader(response, s.partitionCount)\n\t\t\tfor i := int32(0); i < s.partitionCount; i++ {\n\t\t\t\tresponse = writeInt16(response, 0)\n\t\t\t\tresponse = writeInt32(response, i+1)\n\t\t\t\tresponse = writeInt32(response, s.nodeID)\n\t\t\t\tif version >= 7 {\n\t\t\t\t\tresponse = writeInt32(response, 0)\n\t\t\t\t}\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t\tresponse = writeArrayHeader(response, 0)\n\t\t\t}\n\t\t}\n\tcase 18:\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeArrayHeader(response, 2)\n\t\tresponse = writeInt16(response, 0)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 2)\n\t\tresponse = writeInt16(response, 3)\n\t\tresponse = writeInt16(response, 1)\n\t\tresponse = writeInt16(response, 1)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported apiKey %d\", apiKey)\n\t}\n\n\tresponseSize := len(response) - 4\n\tbinary.BigEndian.PutUint32(response[:4], uint32(responseSize))\n\t_, err = c.Write(response)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Message struct {\n\tID      string\n\tTopic   string\n\tPartition int32\n\tKey     string\n\tValue   string\n}\n\ntype Response struct {\n\tTopic       string\n\tPartition   int32\n\tErrorCode   int32\n\tDescription string\n}\n\ntype Server struct {\n\tAddr       net.Addr\n\tmu         sync.Mutex\n\twg         sync.WaitGroup\n\tclosed     bool\n\tclosing    chan struct{}\n\tmessages   []Message\n\terrors     []error\n\tbrokerMsg  []byte\n\tnodeID     int32\n\tpartitionCount int32\n}\n\nfunc NewServer(addr string, nodeID int32, partitionCount int32) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tAddr:       l.Addr(),\n\t\tclosing:    make(chan struct{}),\n\t\tnodeID:     nodeID,\n\t\tpartitionCount: partitionCount,\n\t}\n\ts.run(l)\n\treturn s, nil\n}\n\nfunc (s *Server) prepareBrokerMsg() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.brokerMsg = []byte(fmt.Sprintf(\"Broker Info: NodeID=%d, PartitionCount=%d\", s.nodeID, s.partitionCount))\n}\n\nfunc (s *Server) Close() {\n\ts.mu.Lock()\n\tif !s.closed {\n\t\ts.closed = true\n\t\tclose(s.closing)\n\t}\n\ts.mu.Unlock()\n}\n\nfunc (s *Server) run(l net.Listener) {\n\ts.prepareBrokerMsg()\n\ts.wg.Add(1)\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.closing:\n\t\t\t\tl.Close()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tconn, err := l.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.errors = append(s.errors, fmt.Errorf(\"accept: %v\", err))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ts.wg.Add(1)\n\t\t\t\tgo s.handle(conn)\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (s *Server) handle(conn net.Conn) {\n\tdefer conn.Close()\n\tdefer s.wg.Done()\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tmsg, err := reader.ReadBytes('\\n')\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"read: %v\", err))\n\t\t\tbreak\n\t\t}\n\t\tif len(msg) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tmsg = msg[:len(msg)-1]\n\t\tif len(msg) > 0 {\n\t\t\ts.mu.Lock()\n\t\t\ts.messages = append(s.messages, Message{\n\t\t\t\tID:      fmt.Sprintf(\"%d\", time.Now().UnixNano()),\n\t\t\t\tTopic:   \"test\",\n\t\t\t\tPartition: 0,\n\t\t\t\tKey:     \"\",\n\t\t\t\tValue:   string(msg),\n\t\t\t})\n\t\t\ts.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (s *Server) readProduceRequest(data []byte) (string, []Response, error) {\n\tvar responses []Response\n\tdata = data[2:]\n\tif len(data) < 2 {\n\t\treturn \"\", responses, fmt.Errorf(\"invalid request\")\n\t}\n\t// Simplified produce request handling\n\ttopic := string(data[:len(data)-1])\n\t_, _, err := s.readStrList(data[len(data)-1:])\n\tif err != nil {\n\t\treturn \"\", responses, err\n\t}\n\tresponses = append(responses, Response{\n\t\tTopic:       topic,\n\t\tPartition:   0,\n\t\tErrorCode:   0,\n\t\tDescription: \"Success\",\n\t})\n\treturn topic, responses, nil\n}\n\nfunc (s *Server) readStrList(data []byte) ([]string, int) {\n\tvar strs []string\n\ti := 0\n\tfor i < len(data) {\n\t\tj := strings.IndexByte(data[i:], '\\x00')\n\t\tif j == -1 {\n\t\t\tbreak\n\t\t}\n\t\tstrs = append(strs, string(data[i:i+j]))\n\t\ti += j + 1\n\t}\n\treturn strs, i\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Implement a TCP listener in Go that supports different listening methods (normal, iptables, and socket reuse) for handling incoming client connections, performing protocol negotiation, and managing client tasks.\n\nStruct Description: The Listen struct represents a TCP listener with configurable listening methods and address. It provides methods to start listening using different techniques and handle client connections.\n\nFields:\nmethod: [int] - Specifies the listening method (NORMAL, IPTABLES, or SOREUSE)\naddr: [string] - The address and port to listen on\n\nMethods:\nnewListen: [Name](method int, addr string) -> *Listen - Creates and returns a new Listen instance with the specified method and address\nstart: [Name](mgr *manager.Manager, options *initial.Options) -> void - Starts the listener in a goroutine using the configured method\nnormalListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements standard TCP listening and client handling\nsoReuseListen: [Name](mgr *manager.Manager, options *initial.Options) -> void - Implements socket reuse listening with additional authentication and proxy capabilities",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-reuseport\"\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\tlisten := new(Listen)\n\tlisten.method = method\n\tlisten.addr = addr\n\treturn listen\n}\n\nfunc (listen *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch listen.method {\n\tcase NORMAL:\n\t\tgo listen.normalListen(mgr, options)\n\tcase IPTABLES:\n\t\tgo listen.iptablesListen(mgr, options)\n\tcase SOREUSE:\n\t\tgo listen.soReuseListen(mgr, options)\n\t}\n}\n\nfunc (listen *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", listen.addr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}\n\nfunc (listen *Listen) soReuseListen(mgr *manager.Manager, options *initial.Options) {\n\tlistenAddr := fmt.Sprintf(\"%s:%s\", options.ReuseHost, options.ReusePort)\n\tlistener, err := reuseport.Listen(\"tcp\", listenAddr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[*] Error occurred: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tparam := new(protocol.NegParam)\n\t\tparam.Conn = conn\n\t\tproto := protocol.NewDownProto(param)\n\t\tproto.SNegotiate()\n\n\t\tdefer conn.SetReadDeadline(time.Time{})\n\t\tconn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\n\t\tbuffer := make([]byte, 16)\n\t\tcount, err := io.ReadFull(conn, buffer)\n\n\t\tif err != nil {\n\t\t\tif timeoutErr, ok := err.(net.Error); ok && timeoutErr.Timeout() {\n\t\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif string(buffer[:count]) == share.AuthToken {\n\t\t\tconn.Write([]byte(share.AuthToken))\n\t\t} else {\n\t\t\tgo initial.ProxyStream(conn, buffer[:count], options.ReusePort)\n\t\t\tcontinue\n\t\t}\n\n\t\trMessage := protocol.NewDownMsg(conn, global.G_Component.Secret, protocol.ADMIN_UUID)\n\t\tfHeader, fMessage, err := protocol.DestructMessage(rMessage)\n\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tif fHeader.MessageType == protocol.HI {\n\t\t\tmmess := fMessage.(*protocol.HIMess)\n\t\t\tif mmess.Greeting == \"Shhh...\" && mmess.IsAdmin == 0 {\n\t\t\t\tchildrenTask := &manager.ChildrenTask{\n\t\t\t\t\tMode: manager.C_NEWCHILD,\n\t\t\t\t\tUUID: mmess.UUID,\n\t\t\t\t\tConn: conn,\n\t\t\t\t}\n\t\t\t\tmgr.ChildrenManager.TaskChan <- childrenTask\n\t\t\t\t<-mgr.ChildrenManager.ResultChan\n\t\t\t\tmgr.ChildrenManager.ChildComeChan <- &manager.ChildInfo{UUID: mmess.UUID, Conn: conn}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype Listen struct {\n\tmethod int\n\taddr   string\n}\n\nfunc newListen(method int, addr string) *Listen {\n\treturn &Listen{method: method, addr: addr}\n}\n\nfunc (l *Listen) start(mgr *manager.Manager, options *initial.Options) {\n\tswitch l.method {\n\tcase 0:\n\t\tl.normalListen(mgr, options)\n\tcase 1:\n\t\tl.soreuseListen(mgr, options)\n\t}\n}\n\nfunc (l *Listen) normalListen(mgr *manager.Manager, options *initial.Options) {\n\tlistener, err := net.Listen(\"tcp\", l.addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer listener.Close()\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\ttime.Sleep(time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\t// Perform protocol negotiation and client task management\n\t\t\t// This is a placeholder for actual implementation\n\t\t\tconn.Close()\n\t\t}(conn)\n\t}\n}\n\nfunc (l *Listen) soreuseListen(mgr *manager.Manager, options *initial.Options) {\n\t// Implement socket reuse listening with additional authentication and proxy capabilities\n\t// This is a placeholder for actual implementation\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and connection management.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client requests, and manages connection lifecycle with configurable timeouts.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - The request handler interface\nReadTimeout: time.Duration - Maximum duration for reading the entire request\nWriteTimeout: time.Duration - Maximum duration for writing the response\nIdleTimeout: func() time.Duration - Function returning the maximum idle connection duration\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Main server loop that accepts and handles connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual client connection\ninit() - Initializes server resources\nisStarted() bool - Returns server running status\ngetReadTimeout() time.Duration - Returns configured read timeout or default",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, false, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw}\n\tw.writer = w\n\n\ttimeout := srv.getReadTimeout()\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\tlimit := maxTCPQueries\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n\tif srv.Handler == nil {\n\t\tsrv.Handler = DefaultServeMux\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc (srv *Server) getReadTimeout() time.Duration {\n\tif srv.ReadTimeout != 0 {\n\t\treturn srv.ReadTimeout\n\t}\n\treturn dnsTimeout\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeHTTP(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn nil\n\t}\n\ts.started = true\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n\treturn s.serveTCP(net.Listen(s.Net, s.Addr))\n}\n\nfunc (s *Server) serveTCP(l net.Listener) error {\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\twg.Done()\n\t}()\n\t// Set timeouts\n\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t// Handle the connection\n\ts.Handler.ServeHTTP(conn)\n\t// Reset deadlines for next use\n\tconn.SetReadDeadline(time.Time{})\n\tconn.SetWriteDeadline(time.Time{})\n}\n\nfunc (s *Server) init() {\n\t// Initialization logic if needed\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.ReadTimeout\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle multiple client connections concurrently, with support for both plain TCP and TLS-secured connections. The server should manage connection lifecycles, timeouts, and provide hooks for customizing reader/writer behavior.\n\nStruct Description: The Server struct represents a configurable TCP server that can handle DNS queries (though this could be adapted for other protocols). It manages listener lifecycle, connection pooling, and provides various timeout and security configurations.\n\nFields:\n\nAddr: string - The address to listen on (e.g., \":domain\")\nNet: string - Network type (\"tcp\", \"tcp4\", \"tcp6\", or their TLS variants)\nListener: net.Listener - The active TCP listener\nTLSConfig: *tls.Config - Configuration for TLS connections\nPacketConn: net.PacketConn - UDP connection (not used in TCP mode)\nHandler: Handler - Handler for incoming requests\nUDPSize: int - UDP buffer size\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nIdleTimeout: func() time.Duration - Function returning idle timeout duration\nTsigProvider: TsigProvider - TSIG provider for DNS\nTsigSecret: map[string]string - TSIG secrets\nNotifyStartedFunc: func() - Callback when server starts\nDecorateReader: DecorateReader - Function to decorate the reader\nDecorateWriter: DecorateWriter - Function to decorate the writer\nMaxTCPQueries: int - Maximum queries per connection\nReusePort: bool - Enable SO_REUSEPORT\nReuseAddr: bool - Enable SO_REUSEADDR\nMsgAcceptFunc: MsgAcceptFunc - Function to filter incoming messages\nlock: sync.RWMutex - Mutex for concurrent access protection\nstarted: bool - Server running state\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\nudpPool: sync.Pool - Pool for UDP buffers\n\nMethods:\n\nListenAndServe: () -> error - Starts the server and begins accepting connections\nserveTCP: (net.Listener) -> error - Internal method to serve TCP connections\nserveTCPConn: (*sync.WaitGroup, net.Conn) -> () - Handles an individual TCP connection\nisStarted: () -> bool - Checks if server is running (internal)\ninit: () -> () - Initializes server state (internal)\ngetReadTimeout: () -> time.Duration - Gets current read timeout (internal)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr     string\n\tNet      string\n\tListener net.Listener\n\tTLSConfig *tls.Config\n\tPacketConn net.PacketConn\n\tHandler   Handler\n\tUDPSize int\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tTsigProvider TsigProvider\n\tTsigSecret map[string]string\n\tNotifyStartedFunc func()\n\tDecorateReader DecorateReader\n\tDecorateWriter DecorateWriter\n\tMaxTCPQueries int\n\tReusePort bool\n\tReuseAddr bool\n\tMsgAcceptFunc MsgAcceptFunc\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n\tudpPool sync.Pool\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\tcase \"tcp-tls\", \"tcp4-tls\", \"tcp6-tls\":\n\t\tif srv.TLSConfig == nil || (len(srv.TLSConfig.Certificates) == 0 && srv.TLSConfig.GetCertificate == nil) {\n\t\t\treturn errors.New(\"dns: neither Certificates nor GetCertificate set in Config\")\n\t\t}\n\t\tnetwork := strings.TrimSuffix(srv.Net, \"-tls\")\n\t\tl, err := listenTCP(network, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = tls.NewListener(l, srv.TLSConfig)\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tif srv.NotifyStartedFunc != nil {\n\t\tsrv.NotifyStartedFunc()\n\t}\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tsigProvider: srv.tsigProvider(), tcp: rw}\n\tif srv.DecorateWriter != nil {\n\t\tw.writer = srv.DecorateWriter(w)\n\t} else {\n\t\tw.writer = w\n\t}\n\n\treader := Reader(defaultReader{srv})\n\tif srv.DecorateReader != nil {\n\t\treader = srv.DecorateReader(reader)\n\t}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr string\n\tNet  string\n\tListener net.Listener\n\tTLSConfig *tls.Config\n\tPacketConn net.PacketConn\n\tHandler Handler\n\tUDPSize int\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tTsigProvider TsigProvider\n\tTsigSecret map[string]string\n\tNotifyStartedFunc func()\n\tDecorateReader DecorateReader\n\tDecorateWriter DecorateWriter\n\tMaxTCPQueries int\n\tReusePort bool\n\tReuseAddr bool\n\tMsgAcceptFunc MsgAcceptFunc\n\tlock sync.RWMutex\n\tstarted bool\n\tshutdown chan struct{}\n\tconns map[net.Conn]struct{}\n\tudpPool sync.Pool\n}\n\ntype Handler func(*Server, net.Conn) error\n\ntype TsigProvider interface {\n\tProvideTsig(name string) (string, error)\n}\n\ntype DecorateReader func(*bufio.Reader) *bufio.Reader\ntype DecorateWriter func(*bufio.Writer) *bufio.Writer\ntype MsgAcceptFunc func([]byte) bool\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn nil\n\t}\n\ts.init()\n\terr := s.Listener.Listen(s.Net)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.started = true\n\tif s.NotifyStartedFunc != nil {\n\t\ts.NotifyStartedFunc()\n\t}\n\tgo s.serveTCP(s.Listener)\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\twg.Done()\n\t}()\n\tif s.DecorateReader != nil {\n\t\tconn = s.DecorateReader(conn)\n\t}\n\tif s.DecorateWriter != nil {\n\t\tconn = s.DecorateWriter(conn)\n\t}\n\tif s.Handler != nil {\n\t\terr := s.Handler(s, conn)\n\t\tif err != nil {\n\t\t\t// Handle error, e.g., log it\n\t\t}\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) init() {\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n\ts.udpPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn make([]byte, s.UDPSize)\n\t\t},\n\t}\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a TCP server in Go that can handle multiple client connections concurrently, manage server lifecycle, and track active connections.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client communication, and provides server management capabilities.\n\nFields:\n- Addr: string - The network address to listen on (e.g., \":8080\")\n- Net: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\n- Handler: Handler - Interface for custom request handling (implementation not shown)\n- Listener: net.Listener - The underlying network listener\n- conns: map[net.Conn]struct{} - Track active connections\n- lock: sync.RWMutex - Protects concurrent access to server state\n- started: bool - Indicates if server is running\n- shutdown: chan struct{} - Channel for shutdown signaling\n\nMethods:\n- ListenAndServe() error - Starts the server and begins accepting connections\n- init() - Initializes server resources (internal use)\n- serveTCP(net.Listener) error - Main server loop that accepts connections (internal use)\n- serveTCPConn(*sync.WaitGroup, net.Conn) - Handles individual client connections (internal use)\n- isStarted() bool - Thread-safe check of server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tl, err := net.Listen(srv.Net, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Listener = l\n\tsrv.started = true\n\tunlock()\n\treturn srv.serveTCP(l)\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer func() {\n\t\tsrv.lock.Lock()\n\t\tdelete(srv.conns, rw)\n\t\tsrv.lock.Unlock()\n\t\trw.Close()\n\t\twg.Done()\n\t}()\n\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := rw.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = rw.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc unlockOnce(l sync.Locker) func() {\n\tvar once sync.Once\n\treturn func() { once.Do(l.Unlock) }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServeHTTP(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\tListener net.Listener\n\tconns   map[net.Conn]struct{}\n\tlock    *sync.RWMutex\n\tstarted bool\n\tshutdown chan struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\tif s.started {\n\t\treturn nil\n\t}\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.Listener == nil {\n\t\tvar err error\n\t\ts.Listener, err = net.Listen(s.Net, s.Addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\ts.started = true\n\tgo s.serveTCP(s.Listener)\n\treturn nil\n}\n\nfunc (s *Server) init() {\n\ts.conns = make(map[net.Conn]struct{})\n\ts.lock = &sync.RWMutex{}\n\ts.started = false\n\ts.shutdown = make(chan struct{})\n}\n\nfunc (s *Server) serveTCP(ln net.Listener) error {\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tif err == net.ErrClosed {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) serveTCPConn wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\twg.Done()\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t}()\n\tdefer conn.Close()\n\tif s.Handler != nil {\n\t\ts.Handler.ServeHTTP(conn)\n\t}\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a TLS server in Go that handles incoming TCP connections, performs TLS handshakes, manages connection timeouts, and processes domain-specific data through channels.\n\nStruct Description: The TLSServer struct represents a TLS-enabled TCP server that handles secure connections, manages connection state, and processes domain-specific data through channels. It includes functionality for accepting connections, handling TLS handshakes, managing timeouts, and shutting down gracefully.\n\nFields:\n- HTTPSServer: *HTTPSServer - Reference to the parent HTTPSServer containing configuration\n- Cache: *cache.Cache - Cache for storing active connections\n- TCPListen: *net.TCPListener - TCP listener for incoming connections\n- Done: chan byte - Channel for signaling server shutdown\n- DomainData: chan DomainData - Channel for sending domain-specific data\n- Error: chan error - Channel for reporting errors\n\nMethods:\n- NewTLSServer(*HTTPSServer) (*TLSServer, error) - Constructor that initializes a new TLSServer instance\n- ListenAndServe() error - Main server loop that handles domain data and errors\n- Shutdown() - Gracefully shuts down the server\n- Accept() - Accepts incoming connections and handles TLS handshakes (spawned as a goroutine)",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/zoro\"\n)\n\ntype DomainData struct {\n\tDomain string\n\tData   []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(s *HTTPSServer) (*TLSServer, error) {\n\tl, err := net.ListenTCP(\"tcp\", s.TLSAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TLSServer{\n\t\tHTTPSServer: s,\n\t\tCache:       cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tTCPListen:   l,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tdefer close(s.Done)\n\tdefer s.TCPListen.Close()\n\tgo s.Accept()\n\tfor {\n\t\tselect {\n\t\tcase d := <-s.DomainData:\n\t\t\ti, ok := s.Cache.Get(\"domain:\" + d.Domain)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc := i.(*net.TCPConn)\n\t\t\tif err := c.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, err := c.Write(d.Data); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tselect {\n\tcase <-s.Done:\n\t\treturn\n\tcase s.Error <- nil:\n\t}\n}\n\nfunc (s *TLSServer) Accept() {\n\tfor {\n\t\tc1, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.Done:\n\t\t\t\treturn\n\t\t\tcase s.Error <- err:\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif s.HTTPSServer.TLSTimeout != 0 {\n\t\t\tif err := c1.SetKeepAlivePeriod(time.Duration(s.HTTPSServer.TLSTimeout) * time.Second); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\tif err := c1.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\ttc := tls.Server(c1, s.HTTPSServer.TLSConfig)\n\t\tif err := tc.Handshake(); err != nil {\n\t\t\tc1.Close()\n\t\t\tcontinue\n\t\t}\n\t\tcs := tc.ConnectionState()\n\t\tif cs.ServerName == \"\" {\n\t\t\tlog.Println(tc.RemoteAddr().String() + \" no SNI\")\n\t\t\ttc.Close()\n\t\t\tcontinue\n\t\t}\n\t\ts.Cache.Set(tc.RemoteAddr().String(), tc, cache.DefaultExpiration)\n\t\tgo func(tc *tls.Conn) {\n\t\t\tdefer func() {\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x02}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t\ts.Cache.Delete(tc.RemoteAddr().String())\n\t\t\t\ttc.Close()\n\t\t\t}()\n\t\t\tvar bf [1024 * 2]byte\n\t\t\tfor {\n\t\t\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\t\t\tif err := tc.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti, err := tc.Read(bf[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t\tData:    bf[0:i],\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x01}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t}\n\t\t}(tc)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n)\n\ntype DomainData struct {\n\tData []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(httpsserver *HTTPSServer) (*TLSServer, error) {\n\ttlsServer := &TLSServer{\n\t\tHTTPSServer: httpsserver,\n\t\tCache:       &cache.Cache{},\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}\n\ttlsServer.TCPListen, _ = net.Listen(\"tcp\", \"localhost:8443\")\n\treturn tlsServer, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.Done:\n\t\t\t\ts.Shutdown()\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tconn, err := s.TCPListen.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.Error <- err\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tgo s.Accept(conn)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (s *TLSServer) Shutdown() {\n\ts.TCPListen.Close()\n\tclose(s.Done)\n}\n\nfunc (s *TLSServer) Accept(conn net.Conn) {\n\ttlsConn, err := tls.Server(conn, &tls.Config{})\n\tif err != nil {\n\t\ts.Error <- err\n\t\treturn\n\t}\n\tif err := tlsConn.Handshake(); err != nil {\n\t\ts.Error <- err\n\t\treturn\n\t}\n\ts.Cache.Store(conn.RemoteAddr().String(), tlsConn)\n\ts.DomainData <- DomainData{Data: []byte(\"TLS connection established\")}\n}"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Implement a TCP-based HTTP proxy server in Go that handles both HTTP and HTTPS requests, supports basic authentication, and can optionally pretend to be a web server.\n\nStruct Description: The HTTP struct represents an HTTP proxy server with configurable authentication and behavior settings.\n\nFields:\naddr: string - The address and port on which the server listens\nuser: string - Username for basic authentication (empty if no auth required)\npassword: string - Password for basic authentication (empty if no auth required)\npretend: bool - Whether to pretend to be a web server (return 404 responses)\nproxy: proxy.Proxy - The underlying proxy implementation for forwarding requests\n\nMethods:\nListenAndServe: () -> () - Starts the TCP listener on the configured address and begins accepting connections\nServe: (net.Conn) -> () - Handles an individual client connection (sets keepalive, parses requests)\nservRequest: (*request, *proxy.Conn) -> () - Processes authenticated requests and routes to HTTP/HTTPS handlers\nservHTTPS: (*request, net.Conn) -> () - Handles HTTPS CONNECT requests by establishing tunnel\nservHTTP: (*request, *proxy.Conn) -> () - Handles regular HTTP requests by forwarding and modifying headers",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/textproto\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\ntype HTTP struct {\n\taddr     string\n\tuser     string\n\tpassword string\n\tpretend  bool\n\tproxy    proxy.Proxy\n}\n\nfunc (s *HTTP) ListenAndServe() {\n\tl, err := net.Listen(\"tcp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[http] failed to listen on %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tlog.F(\"[http] listening TCP on %s\", s.addr)\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.F(\"[http] failed to accept: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.Serve(c)\n\t}\n}\n\nfunc (s *HTTP) Serve(cc net.Conn) {\n\tif c, ok := cc.(*net.TCPConn); ok {\n\t\tc.SetKeepAlive(true)\n\t}\n\n\tc := proxy.NewConn(cc)\n\tdefer c.Close()\n\n\treq, err := parseRequest(c.Reader())\n\tif err != nil {\n\t\tlog.F(\"[http] can not parse request from %s, error: %v\", c.RemoteAddr(), err)\n\t\treturn\n\t}\n\n\tif s.pretend {\n\t\tfmt.Fprintf(c, \"%s 404 Not Found\\r\\nServer: nginx\\r\\n\\r\\n404 Not Found\\r\\n\", req.proto)\n\t\tlog.F(\"[http] %s <-> %s, pretend as web server\", c.RemoteAddr().String(), s.Addr())\n\t\treturn\n\t}\n\n\ts.servRequest(req, c)\n}\n\nfunc (s *HTTP) servRequest(req *request, c *proxy.Conn) {\n\tif s.user != \"\" && s.password != \"\" {\n\t\tif user, pass, ok := extractUserPass(req.auth); !ok || user != s.user || pass != s.password {\n\t\t\tio.WriteString(c, \"HTTP/1.1 407 Proxy Authentication Required\\r\\nProxy-Authenticate: Basic\\r\\n\\r\\n\")\n\t\t\tlog.F(\"[http] auth failed from %s, auth info: %s:%s\", c.RemoteAddr(), user, pass)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif req.method == \"CONNECT\" {\n\t\ts.servHTTPS(req, c)\n\t\treturn\n\t}\n\n\ts.servHTTP(req, c)\n}\n\nfunc (s *HTTP) servHTTPS(r *request, c net.Conn) {\n\trc, dialer, err := s.proxy.Dial(\"tcp\", r.uri)\n\tif err != nil {\n\t\tio.WriteString(c, r.proto+\" 502 ERROR\\r\\n\\r\\n\")\n\t\tlog.F(\"[http] %s <-> %s [c] via %s, error in dial: %v\", c.RemoteAddr(), r.uri, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tio.WriteString(c, \"HTTP/1.1 200 Connection established\\r\\n\\r\\n\")\n\n\tlog.F(\"[http] %s <-> %s [c] via %s\", c.RemoteAddr(), r.uri, dialer.Addr())\n\n\tif err = proxy.Relay(c, rc); err != nil {\n\t\tlog.F(\"[http] %s <-> %s via %s, relay error: %v\", c.RemoteAddr(), r.uri, dialer.Addr(), err)\n\t\tif !strings.Contains(err.Error(), s.addr) {\n\t\t\ts.proxy.Record(dialer, false)\n\t\t}\n\t}\n}\n\nfunc (s *HTTP) servHTTP(req *request, c *proxy.Conn) {\n\trc, dialer, err := s.proxy.Dial(\"tcp\", req.target)\n\tif err != nil {\n\t\tfmt.Fprintf(c, \"%s 502 ERROR\\r\\n\\r\\n\", req.proto)\n\t\tlog.F(\"[http] %s <-> %s via %s, error in dial: %v\", c.RemoteAddr(), req.target, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tbuf := pool.GetBytesBuffer()\n\tdefer pool.PutBytesBuffer(buf)\n\n\treq.WriteBuf(buf)\n\t_, err = rc.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tgo func() {\n\t\tif _, err := c.Reader().Peek(1); err == nil {\n\t\t\tproxy.Copy(rc, c)\n\t\t\trc.SetDeadline(time.Now())\n\t\t\tc.SetDeadline(time.Now())\n\t\t}\n\t}()\n\n\tr := pool.GetBufReader(rc)\n\tdefer pool.PutBufReader(r)\n\n\ttpr := textproto.NewReader(r)\n\tline, err := tpr.ReadLine()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tproto, code, status, ok := parseStartLine(line)\n\tif !ok {\n\t\treturn\n\t}\n\n\theader, err := tpr.ReadMIMEHeader()\n\tif err != nil {\n\t\tlog.F(\"[http] read header error:%s\", err)\n\t\treturn\n\t}\n\n\theader.Set(\"Proxy-Connection\", \"close\")\n\theader.Set(\"Connection\", \"close\")\n\n\tbuf.Reset()\n\twriteStartLine(buf, proto, code, status)\n\twriteHeaders(buf, header)\n\n\tlog.F(\"[http] %s <-> %s via %s\", c.RemoteAddr(), req.target, dialer.Addr())\n\tc.Write(buf.Bytes())\n\n\tproxy.Copy(c, r)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype request struct {\n\tmethod string\n\turl    string\n\theader http.Header\n}\n\ntype proxy struct {\n\t// Proxy implementation details\n}\n\nfunc (p *proxy) Serve(conn net.Conn) {\n\t// Proxy serving logic\n}\n\nfunc (p *proxy) servRequest(r *request, conn *proxy.Conn) {\n\t// Request processing logic\n}\n\nfunc (p *proxy) servHTTPS(r *request, conn net.Conn) {\n\t// HTTPS CONNECT handling logic\n}\n\nfunc (p *proxy) servHTTP(r *request, conn *proxy.Conn) {\n\t// HTTP request forwarding logic\n}\n\ntype HTTP struct {\n\taddr    string\n\tuser    string\n\tpassword string\n\tpretend bool\n\tproxy   *proxy\n}\n\nfunc (h *HTTP) ListenAndServe() {\n\t// Start TCP listener and begin accepting connections\n}\n\nfunc (h *HTTP) Serve(conn net.Conn) {\n\t// Handle individual client connection\n}\n\nfunc main() {\n\t// Main function to initialize and start the proxy server\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement an HTTP transport struct for sending tracing spans to a collector using Thrift serialization and HTTP protocol.\n\nStruct Description: HTTPTransport is a struct that handles batching and sending tracing spans to a remote collector via HTTP. It supports basic authentication and custom HTTP client configuration.\n\nFields:\n- logger: jaeger.Logger - Logger for reporting errors and debug information\n- url: string - The collector endpoint URL\n- client: *http.Client - Custom HTTP client for making requests\n- batchSize: int - Maximum number of spans to batch before flushing\n- batch: []*zipkincore.Span - Current batch of spans waiting to be sent\n- httpCredentials: *HTTPBasicAuthCredentials - Optional basic auth credentials\n\nMethods:\n- NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) - Constructor that creates a new HTTPTransport with default values and applies options\n- Append(span *jaeger.Span) (int, error) - Adds a span to the current batch, flushes if batch size is reached\n- Flush() (int, error) - Sends all batched spans to the collector and resets the batch\n- Close() error - Cleanup method (currently no-op)\n- send(spans []*zipkincore.Span) error - Internal method that serializes and sends spans via HTTP POST\n- httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) - Helper method that serializes spans using Thrift protocol\n\nAdditional Struct:\n- HTTPBasicAuthCredentials: struct - Holds basic authentication credentials\n  Fields:\n  - username: string - Basic auth username\n  - password: string - Basic auth password",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tc := &HTTPTransport{\n\t\tlogger:    log.NullLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{Timeout: defaultHTTPTimeout},\n\t\tbatchSize: 100,\n\t\tbatch:     []*zipkincore.Span{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(c)\n\t}\n\treturn c, nil\n}\n\nfunc (c *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzSpan := jaeger.BuildZipkinThrift(span)\n\tc.batch = append(c.batch, zSpan)\n\tif len(c.batch) >= c.batchSize {\n\t\treturn c.Flush()\n\t}\n\treturn 0, nil\n}\n\nfunc (c *HTTPTransport) Flush() (int, error) {\n\tcount := len(c.batch)\n\tif count == 0 {\n\t\treturn 0, nil\n\t}\n\terr := c.send(c.batch)\n\tc.batch = c.batch[:0]\n\treturn count, err\n}\n\nfunc (c *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (c *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", c.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif c.httpCredentials != nil {\n\t\treq.SetBasicAuth(c.httpCredentials.username, c.httpCredentials.password)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read response from collector: %s\", err)\n\t}\n\n\tif resp.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"error from collector: code=%d body=%q\", resp.StatusCode, string(respBytes))\n\t}\n\n\treturn nil\n}\n\nfunc httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tt := thrift.NewTMemoryBuffer()\n\tp := thrift.NewTBinaryProtocolTransport(t)\n\tctx := context.Background()\n\tif err := p.WriteListBegin(ctx, thrift.STRUCT, len(spans)); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range spans {\n\t\tif err := s.Write(ctx, p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif err := p.WriteListEnd(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn t.Buffer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package jaeger\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\ntype HTTPTransport struct {\n\tlogger        jaeger.Logger\n\turl           string\n\tclient        *http.Client\n\tbatchSize     int\n\tbatch         []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\ttransport := &HTTPTransport{\n\t\tlogger:        jaeger.NewLogger(\"jaeger\"),\n\t\turl:           url,\n\t\tbatchSize:     100,\n\t\tbatch:         make([]*zipkincore.Span, 0, 100),\n\t\thttpCredentials: &HTTPBasicAuthCredentials{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(transport)\n\t}\n\n\tif transport.client == nil {\n\t\ttransport.client = &http.Client{}\n\t}\n\n\treturn transport, nil\n}\n\nfunc (t *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\t// Convert jaeger.Span to zipkincore.Span\n\tzipkinSpan := &zipkincore.Span{\n\t\tID:        span.Context().TraceID(),\n\t\tOperation: span.OperationName(),\n\t\tKind:      zipkincore.SpanKindClient,\n\t\tStartTime: span.StartTime(),\n\t\tEndTime:   span.EndTime(),\n\t\tTraceID:   span.Context().TraceID(),\n\t\tParentID:  span.Context().SpanID(),\n\t\tReferences: make([]*zipkincore.SpanReference, 0, 1),\n\t\tAnnotations: make([]*zipkincore.Annotation, 0, 1),\n\t\tAttributes: make(map[string]string),\n\t}\n\n\t// Add references\n\tfor _, ref := range span.References() {\n\t\tzipkinSpan.References = append(zipkinSpan.References, &zipkincore.SpanReference{\n\t\t\tTraceID: ref.TraceID,\n\t\t\tSpanID:  ref.SpanID,\n\t\t\tRelation: ref.Relation,\n\t\t})\n\t}\n\n\t// Add annotations\n\tfor _, ann := range span.Annotations() {\n\t\tzipkinSpan.Annotations = append(zipkinSpan.Annotations, &zipkincore.Annotation{\n\t\t\tTS: ann.Timestamp(),\n\t\t\tValue: ann.Value(),\n\t\t})\n\t}\n\n\t// Add attributes\n\tfor key, value := range span.Attributes() {\n\t\tzipkinSpan.Attributes[key] = value\n\t}\n\n\tt.batch = append(t.batch, zipkinSpan)\n\n\tif len(t.batch) >= t.batchSize {\n\t\treturn t.Flush()\n\t}\n\n\treturn len(t.batch), nil\n}\n\nfunc (t *HTTPTransport) Flush() (int, error) {\n\tif len(t.batch) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tspanCount, err := t.send(t.batch)\n\tt.batch = make([]*zipkincore.Span, 0, 100)\n\treturn spanCount, err\n}\n\nfunc (t *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (t *HTTPTransport) send(spans []*zipkincore.Span) (int, error) {\n\t// Serialize spans using Thrift\n\tbuffer, err := t.httpSerialize(spans)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Create request\n\treq, err := http.NewRequest(\"POST\", t.url, buffer)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Set headers\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\n\t// Set basic auth credentials if provided\n\tif t.httpCredentials != nil {\n\t\tauthorization := \"Basic \" + encodeBasicAuth(t.httpCredentials.username, t.httpCredentials.password)\n\t\treq.Header.Set(\"Authorization\", authorization)\n\t}\n\n\t// Send request\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check response\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn 0, fmt.Errorf(\"unexpected HTTP status code: %d\", resp.StatusCode)\n\t}\n\n\treturn len(spans), nil\n}\n\nfunc (t *HTTPTransport) httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\t// Serialize spans using Thrift\n\tserializer := thrift.NewTMemoryBuffer()\n\tprocessor := zipkincore.NewTBinaryProtocol(serializer)\n\tencoder := zipkincore.NewTCompactOutputProcessor(processor)\n\tencoder.WriteSpans(spans)\n\tserializer.Flush()\n\n\t// Compress the serialized data using gzip\n\tgzWriter := gzip.NewWriter(bytes.NewBuffer(serializer.Buffer()))\n\t_, err := gzWriter.Write(serializer.Buffer())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgzWriter.Close()\n\n\t// Return the compressed data\n\treturn bytes.NewBuffer(gzWriter.Bytes()), nil\n}\n\nfunc encodeBasicAuth(username, password string) string {\n\tauth := username + \":\" + password\n\treturn base64.StdEncoding.EncodeToString([]byte(auth))\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both query and write operations with configurable connection settings, authentication, and request parameters.\n\nStruct Description: The Client struct represents an InfluxDB client with configurable connection settings and methods for executing queries and writing data points.\n\nFields:\n\nurl: url.URL - Base URL of the InfluxDB server\nunixSocket: string - Path to Unix domain socket for connection (alternative to TCP)\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nhttpClient: *http.Client - Custom HTTP client with configured transport and timeout\nuserAgent: string - User agent string for HTTP requests\nprecision: string - Default precision for timestamps in queries/writes\n\nMethods:\n\nNewClient: [Name](Config) -> (*Client, error) - Creates a new Client instance with the provided configuration, setting up TLS, proxy, and Unix socket options as needed.\n\nQueryContext: [Name](context.Context, Query) -> (*Response, error) - Executes a query against the InfluxDB server with context support, handling both regular and chunked responses.\n\nWrite: [Name](BatchPoints) -> (*Response, error) - Writes a batch of points to the InfluxDB server, handling serialization and request configuration.\n\nThe Client provides methods for both querying and writing data to InfluxDB with support for:\n- Custom HTTP client configuration (timeouts, TLS, proxies)\n- Unix socket connections\n- Basic authentication\n- Chunked query responses\n- Custom precision for timestamps\n- Context-aware operations\n- Error handling for HTTP and InfluxDB-specific errors",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := new(tls.Config)\n\tif c.TLS != nil {\n\t\ttlsConfig = c.TLS.Clone()\n\t}\n\ttlsConfig.InsecureSkipVerify = c.UnsafeSsl\n\n\ttr := &http.Transport{\n\t\tProxy:           c.Proxy,\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tif c.UnixSocket != \"\" {\n\t\ttr.DisableCompression = true\n\t\ttr.DialContext = func(_ context.Context, _, _ string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", c.UnixSocket)\n\t\t}\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tunixSocket: c.UnixSocket,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"query\")\n\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", q.RetentionPolicy)\n\t}\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif q.NodeID > 0 {\n\t\tvalues.Set(\"node_id\", strconv.Itoa(q.NodeID))\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"POST\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"write\")\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package influxdb\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\turl         url.URL\n\tunixSocket  string\n\tusername    string\n\tpassword    string\n\thttpClient  *http.Client\n\tuserAgent   string\n\tprecision   string\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tclient := &Client{\n\t\turl:         config.URL,\n\t\tunixSocket:  config.UnixSocket,\n\t\tusername:    config.Username,\n\t\tpassword:    config.Password,\n\t\tuserAgent:   config.UserAgent,\n\t\tprecision:   config.Precision,\n\t}\n\n\tif config.HTTPClient == nil {\n\t\tconfig.HTTPClient = &http.Client{\n\t\t\tTransport: http.DefaultTransport,\n\t\t\tTimeout:   config.Timeout,\n\t\t}\n\t}\n\n\tclient.httpClient = config.HTTPClient\n\n\tif client.unixSocket != \"\" {\n\t\tclient.url.Scheme = \"unix\"\n\t\tclient.url.Path = client.unixSocket\n\t}\n\n\treturn client, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\treq, err := http.NewRequest(\"POST\", c.url.String(), strings.NewReader(q.String()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Authorization\", \"Basic \"+basicAuth(c.username, c.password))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tif c.precision != \"\" {\n\t\treq.Header.Set(\"Precision\", c.precision)\n\t}\n\n\tresp, err := c.httpClient.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\treturn nil, &Error{resp.StatusCode, resp.Status}\n\t}\n\n\treturn &Response{resp}, nil\n}\n\nfunc (c *Client) Write(points BatchPoints) (*Response, error) {\n\treq, err := http.NewRequest(\"POST\", c.url.String(), points.ToJSON())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Authorization\", \"Basic \"+basicAuth(c.username, c.password))\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\treturn nil, &Error{resp.StatusCode, resp.Status}\n\t}\n\n\treturn &Response{resp}, nil\n}\n\nfunc basicAuth(user, pass string) string {\n\treturn encodeBase64([]byte(user + \":\" + pass))\n}\n\nfunc encodeBase64(data []byte) string {\n\tresult := make([]byte, base64EncodeLen(len(data)))\n\tfor i := 0; i < len(data); i++ {\n\t\tresult[i] = base64Table[data[i]]\n\t}\n\treturn string(result)\n}"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and graceful shutdown capabilities.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - Interface for handling incoming requests\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nShutdownContext(context.Context) error - Gracefully shuts down the server with context support\nisStarted() bool - Helper method to check server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw, writer: w}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) ShutdownContext(ctx context.Context) error {\n\tsrv.lock.Lock()\n\tif !srv.started {\n\t\tsrv.lock.Unlock()\n\t\treturn &Error{err: \"server not started\"}\n\t}\n\n\tsrv.started = false\n\n\tif srv.Listener != nil {\n\t\tsrv.Listener.Close()\n\t}\n\n\tfor rw := range srv.conns {\n\t\trw.SetReadDeadline(aLongTimeAgo)\n\t}\n\n\tsrv.lock.Unlock()\n\n\tvar ctxErr error\n\tselect {\n\tcase <-srv.shutdown:\n\tcase <-ctx.Done():\n\t\tctxErr = ctx.Err()\n\t}\n\n\treturn ctxErr\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tServe(conn net.Conn) error\n}\n\ntype Server struct {\n\tAddr        string\n\tNet         string\n\tHandler     Handler\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tlock        sync.RWMutex\n\tstarted     bool\n\tshutdown    chan struct{}\n\tconns       map[net.Conn]struct{}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif s.started {\n\t\treturn nil\n\t}\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n\ts.started = true\n\tgo s.serveTCP(listener)\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\ts.lock.Lock()\n\t\t\tif !s.started {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.lock.Unlock()\n\t\t\tcontinue\n\t\t}\n\t\ts.lock.Lock()\n\t\ts.conns[conn] = struct{}{}\n\t\ts.lock.Unlock()\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\twg.Done()\n\t}()\n\tif s.ReadTimeout > 0 {\n\t\tconn.SetReadDeadline(time.Now().Add(s.ReadTimeout))\n\t}\n\tif s.WriteTimeout > 0 {\n\t\tconn.SetWriteDeadline(time.Now().Add(s.WriteTimeout))\n\t}\n\tif s.IdleTimeout != nil {\n\t\tidle := s.IdleTimeout()\n\t\tconn.SetDeadline(time.Now().Add(idle))\n\t}\n\ts.Handler.Serve(conn)\n}\n\nfunc (s *Server) ShutdownContext(ctx context.Context) error {\n\ts.lock.Lock()\n\tif !s.started {\n\t\ts.lock.Unlock()\n\t\treturn nil\n\t}\n\ts.started = false\n\ts.lock.Unlock()\n\tselect {\n\tcase <-ctx.Done():\n\t\tclose(s.shutdown)\n\t}\n\tfor conn := range s.conns {\n\t\tconn.Close()\n\t}\n\treturn nil\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\treturn s.started\n}"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Create a Unix domain socket server in Go that listens for incoming connections, handles client communication, and processes received data through a product function. The server should manage connection limits, timeouts, and proper resource cleanup.\n\nStruct Description: The `unix` struct represents a Unix domain socket server with configuration options for path, permissions, and connection handling. It manages the socket lifecycle and processes incoming data.\n\nFields:\n- name: string - Identifier for the server instance\n- config: *Config - Pointer to configuration containing path, mode, timeout, max connections, and max bytes\n- done: chan struct{} - Channel to signal server shutdown\n- eventPool: *event.Pool - Pool for managing event objects\n\nMethods:\n- ProductLoop(productFunc api.ProductFunc) -> void - Main server loop that listens for connections and delegates handling to worker goroutines. Takes a product function for processing events.\n- handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) -> void - Handles individual client connections, reads data, and passes it to the product function. Manages connection timeouts and cleanup.\n- checkBind(path string) -> error - Validates and prepares the socket path by removing existing files if necessary\n- chmod(path string, mode string) -> error - Sets filesystem permissions on the socket file",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/netutil\"\n)\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (k *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", k.String())\n\n\tif err := checkBind(k.config.Path); err != nil {\n\t\tlog.Error(\"check unix sock path error: %+v\", err)\n\t\treturn\n\t}\n\n\tlistener, err := net.Listen(\"unix\", k.config.Path)\n\tif err != nil {\n\t\tlog.Error(\"setup unix listener failed: %v\", err)\n\t\treturn\n\t}\n\n\tif err := chmod(k.config.Path, k.config.Mode); err != nil {\n\t\tlog.Error(\"chmod unix path %s with %s failed: %v\", k.config.Path, k.config.Mode, err)\n\t\treturn\n\t}\n\n\tif k.config.MaxConnections > 0 {\n\t\tlistener = netutil.LimitListener(listener, k.config.MaxConnections)\n\t}\n\n\tdefer listener.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfor {\n\t\tselect {\n\t\tcase <-k.done:\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"unix sock listener accept connection failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo k.handleConn(ctx, conn, productFunc)\n\t}\n}\n\nfunc (k *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuf := bufio.NewReader(conn)\n\tscan := bufio.NewScanner(buf)\n\n\tinitBuffer := make([]byte, k.config.MaxBytes/4)\n\tscan.Buffer(initBuffer, k.config.MaxBytes)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tif err := conn.SetDeadline(time.Now().Add(k.config.Timeout)); err != nil {\n\t\t\tlog.Warn(\"set connection timeout error: %v\", err)\n\t\t}\n\n\t\tif !scan.Scan() {\n\t\t\tif scan.Err() != nil {\n\t\t\t\tlog.Warn(\"scan connection error: %v\", scan.Err())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tbody := scan.Bytes()\n\t\tcopyBody := make([]byte, len(body))\n\t\tcopy(copyBody, body)\n\t\te := k.eventPool.Get()\n\t\te.Fill(e.Meta(), e.Header(), copyBody)\n\n\t\tproductFunc(e)\n\t}\n}\n\nfunc checkBind(path string) error {\n\t_, err := os.Lstat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errors.WithMessagef(err, \"stat path %s failed\", path)\n\t}\n\n\tif err := os.Remove(path); err != nil {\n\t\treturn errors.WithMessagef(err, \"remove path %s failed\", path)\n\t}\n\n\treturn nil\n}\n\nfunc chmod(path string, mode string) error {\n\tparsed, err := strconv.ParseUint(mode, 8, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(path, os.FileMode(parsed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Config struct {\n\tPath        string\n\tMode        string\n\tTimeout     time.Duration\n\tMaxConnections int\n\tMaxBytes    int\n}\n\ntype unix struct {\n\tname        string\n\tconfig      *Config\n\tdone        chan struct{}\n\teventPool   *event.Pool\n}\n\nfunc (u *unix) ProductLoop(productFunc api.ProductFunc) {\n\tfor {\n\t\tselect {\n\t\tcase <-u.done:\n\t\t\treturn\n\t\tdefault:\n\t\t\t// Listen for incoming connections\n\t\t\tconn, err := u.Accept()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error accepting connection: %v\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo u.handleConn(context.Background(), conn, productFunc)\n\t\t}\n\t}\n}\n\nfunc (u *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer func() {\n\t\tconn.Close()\n\t}()\n\t// Set timeout on the connection\n\tconn.SetDeadline(time.Now().Add(u.config.Timeout))\n\t// Read data from the connection\n\tdata := make([]byte, u.config.MaxBytes)\n\tn, err := conn.Read(data)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading from connection: %v\\n\", err)\n\t\treturn\n\t}\n\t// Process the data using the product function\n\tproductFunc(data[:n])\n}\n\nfunc (u *unix) checkBind(path string) error {\n\tif _, err := os.Stat(path); !os.IsNotExist(err) {\n\t\tos.Remove(path)\n\t}\n\treturn nil\n}\n\nfunc (u *unix) chmod(path string, mode string) error {\n\treturn os.Chmod(path, os.FileMode(mode))\n}\n\nfunc main() {\n\tconfig := &Config{\n\t\tPath:        \"/tmp/socket\",\n\t\tMode:        \"777\",\n\t\tTimeout:     10 * time.Second,\n\t\tMaxConnections: 100,\n\t\tMaxBytes:    1024,\n\t}\n\tu := &unix{\n\t\tname:       \"unix-server\",\n\t\tconfig:     config,\n\t\tdone:       make(chan struct{}),\n\t\teventPool:  &event.Pool{},\n\t}\n\t// Check and bind the socket\n\terr := u.checkBind(config.Path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// Set permissions\n\terr = u.chmod(config.Path, config.Mode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// Start the server loop\n\tu.ProductLoop(func(data []byte) {\n\t\tfmt.Printf(\"Received data: %s\\n\", data)\n\t})\n}"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle multiple client connections concurrently, with support for both plain TCP and TLS-secured connections. The server should manage connection timeouts, track active connections, and provide hooks for custom message handling.\n\nStruct Description: The Server struct represents a TCP server that can listen for incoming connections, handle them concurrently, and manage server lifecycle operations. It supports both plain TCP and TLS configurations.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (tcp, tcp4, tcp6, or their TLS variants)\nListener: net.Listener - The active network listener\nTLSConfig: *tls.Config - Configuration for TLS connections\nPacketConn: net.PacketConn - UDP connection handler (unused in TCP implementation)\nHandler: Handler - Interface for handling incoming messages\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nMsgAcceptFunc: MsgAcceptFunc - Function to filter acceptable messages\nlock: sync.RWMutex - Mutex for protecting concurrent access to server state\nstarted: bool - Flag indicating if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Map of active connections\nudpPool: sync.Pool - Pool for UDP resources (unused in TCP implementation)\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nisStarted() bool - Helper method to check server running state\ninit() - Initializes server internal structures\ngetReadTimeout() time.Duration - Gets the current read timeout value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr         string\n\tNet          string\n\tListener     net.Listener\n\tTLSConfig    *tls.Config\n\tPacketConn   net.PacketConn\n\tHandler      Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tMsgAcceptFunc MsgAcceptFunc\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n\tudpPool  sync.Pool\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\tcase \"tcp-tls\", \"tcp4-tls\", \"tcp6-tls\":\n\t\tif srv.TLSConfig == nil || (len(srv.TLSConfig.Certificates) == 0 && srv.TLSConfig.GetCertificate == nil) {\n\t\t\treturn errors.New(\"dns: neither Certificates nor GetCertificate set in Config\")\n\t\t}\n\t\tnetwork := strings.TrimSuffix(srv.Net, \"-tls\")\n\t\tl, err := listenTCP(network, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = tls.NewListener(l, srv.TLSConfig)\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tif srv.NotifyStartedFunc != nil {\n\t\tsrv.NotifyStartedFunc()\n\t}\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tsigSecret: srv.TsigSecret, tcp: rw}\n\tif srv.DecorateWriter != nil {\n\t\tw.writer = srv.DecorateWriter(w)\n\t} else {\n\t\tw.writer = w\n\t}\n\n\treader := Reader(defaultReader{srv})\n\tif srv.DecorateReader != nil {\n\t\treader = srv.DecorateReader(reader)\n\t}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype MsgAcceptFunc func(msg []byte) bool\n\ntype Handler interface {\n\tHandle(conn net.Conn, msg []byte) error\n}\n\ntype Server struct {\n\tAddr         string\n\tNet          string\n\tListener     net.Listener\n\tTLSConfig    *tls.Config\n\tPacketConn   net.PacketConn\n\tHandler      Handler\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\tMsgAcceptFunc MsgAcceptFunc\n\tlock         sync.RWMutex\n\tstarted      bool\n\tshutdown     chan struct{}\n\tconns        map[net.Conn]struct{}\n\tudpPool      sync.Pool\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tif err := s.Listener.Listen(s.Net); err != nil {\n\t\treturn err\n\t}\n\ts.started = true\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tconn, err := s.Listener.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ts.lock.Lock()\n\t\t\t\ts.conns[conn] = struct{}{}\n\t\t\t\ts.lock.Unlock()\n\t\t\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(net.Listener) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif !s.started {\n\t\treturn nil\n\t}\n\tfor {\n\t\tconn, err := s.Listener.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo s.serveTCPConn(&sync.WaitGroup{}, conn)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\tdefer func() {\n\t\tconn.Close()\n\t\ts.lock.Lock()\n\t\tdelete(s.conns, conn)\n\t\ts.lock.Unlock()\n\t\twg.Done()\n\t}()\n\tif s.TLSConfig != nil {\n\t\tconn = tls.Client(conn, s.TLSConfig)\n\t}\n\tif s.MsgAcceptFunc != nil {\n\t\tmsg := make([]byte, 1024)\n\t\tn, err := conn.Read(msg)\n\t\tif err != nil || !s.MsgAcceptFunc(msg[:n]) {\n\t\t\treturn\n\t\t}\n\t}\n\ts.Handler.Handle(conn, msg)\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) init() {\n\ts.conns = make(map[net.Conn]struct{})\n\ts.shutdown = make(chan struct{})\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific traffic class and hop limit settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For IPv6 clients, it configures specific network parameters (traffic class and hop limit) before sending an acknowledgment message. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to a fixed port \"[::]:1024\")\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving clients)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv6\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Set up IPv6 listener with specific traffic class and hop limit\n\tlistener, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error listening:\", err.Error())\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\t// Configure the listener with traffic class and hop limit\n\ttcpAddr, _ := listener.Addr().(*net.TCPAddr)\n\ttcpAddr.TrafficClass = 0x10 // Example traffic class\n\ttcpAddr.HopLimit = 64       // Example hop limit\n\tlistener.SetAddr(tcpAddr)\n\n\tfmt.Println(\"Server is listening on [::]:1024 with traffic class 0x10 and hop limit 64\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tfmt.Fprintf(conn, \"Acknowledgment message sent\\n\")\n\ttime.Sleep(time.Second)\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a Go client for interacting with Rancher metadata service, capable of making HTTP requests with custom headers and handling connection testing with exponential backoff.\n\nStruct Description: The Client struct represents a Rancher metadata client that manages HTTP connections to Rancher metadata service endpoints.\n\nFields:\nurl: string - The base URL for Rancher metadata service (default: \"http://rancher-metadata\")\nhttpClient: *http.Client - The HTTP client used for making requests\n\nMethods:\nNewRancherClient: (backendNodes []string) -> (*Client, error) - Creates a new Rancher client instance, optionally using the first backend node if provided, and tests the connection\nmakeMetaDataRequest: (path string) -> ([]byte, error) - Makes a GET request to the specified path with JSON accept header, returns response body\ntestConnection: () -> error - Tests the connection to the metadata service with exponential backoff retry logic (up to 20 seconds)",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        string\n\thttpClient *http.Client\n}\n\nfunc NewRancherClient(backendNodes []string) (*Client, error) {\n\turl := \"http://rancher-metadata\"\n\n\tif len(backendNodes) > 0 {\n\t\turl = \"http://\" + backendNodes[0]\n\t}\n\n\tclient := &Client{\n\t\turl:        url,\n\t\thttpClient: &http.Client{},\n\t}\n\n\terr := client.testConnection()\n\treturn client, err\n}\n\nfunc (c *Client) makeMetaDataRequest(path string) ([]byte, error) {\n\treq, _ := http.NewRequest(\"GET\", strings.Join([]string{c.url, path}, \"\"), nil)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn ioutil.ReadAll(resp.Body)\n}\n\nfunc (c *Client) testConnection() error {\n\tvar err error\n\tmaxTime := 20 * time.Second\n\n\tfor i := 1 * time.Second; i < maxTime; i *= time.Duration(2) {\n\t\tif _, err = c.makeMetaDataRequest(\"/\"); err != nil {\n\t\t\ttime.Sleep(i)\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl       string\n\thttpClient *http.Client\n}\n\nfunc NewRancherClient(backendNodes []string) (*Client, error) {\n\tvar url string\n\tif len(backendNodes) > 0 {\n\t\turl = backendNodes[0]\n\t} else {\n\t\turl = \"http://rancher-metadata\"\n\t}\n\tclient := &http.Client{\n\t\tTimeout: time.Second * 5,\n\t}\n\treturn &Client{\n\t\turl:       url,\n\t\thttpClient: client,\n\t}, nil\n}\n\nfunc (c *Client) makeMetaDataRequest(path string) ([]byte, error) {\n\turl := c.url + path\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Accept\", \"application/json\")\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := bytes.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\treturn body, nil\n}\n\nfunc (c *Client) testConnection() error {\n\tmaxRetries := 5\n\tdelay := 1 * time.Second\n\tfor i := 0; i < maxRetries; i++ {\n\t\ttime.Sleep(delay)\n\t\t_, err := c.makeMetaDataRequest(\"/\")\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tdelay *= 2\n\t\tif delay > 20*time.Second {\n\t\t\tdelay = 20 * time.Second\n\t\t}\n\t}\n\treturn errors.New(\"connection test failed after maximum retries\")\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a function that establishes a secure or insecure gRPC client connection to a server and returns a client instance for making RPC calls.\n\nFunction Description: The function `createGRPCClient` establishes a connection to a gRPC server using the provided server address and security options. It supports both TLS-secured connections (with optional certificate verification) and insecure connections. The function returns a client instance that can be used to make RPC calls to the server.\n\nInput:\n- `serverAddr` (string): The address of the gRPC server in \"host:port\" format\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string, optional): Path to the CA certificate file for TLS verification (required if useTLS is true)\n- `serverHostOverride` (string, optional): Server name used for TLS hostname verification\n\nOutput:\n- `pb.RouteGuideClient`: A gRPC client instance for making RPC calls\n- `*grpc.ClientConn`: The established gRPC connection (should be closed by the caller when done)\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"your/path/to/pb\" // Replace with actual package path\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, *grpc.ClientConn, error) {\n\tvar opts []grpc.DialOption\n\n\tif useTLS {\n\t\tcreds, err := tls.NewClientCredentials(&tls.Credentials{CAFile: caFile})\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\t// Set server host override for TLS SNI\n\tif serverHostOverride != \"\" {\n\t\topts = append(opts, grpc.WithServerName(serverHostOverride))\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tclient := pb.NewRouteGuideClient(conn)\n\treturn client, conn, nil\n}"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a gRPC client in Go that connects to a gRPC server over a Unix domain socket, retrieves configuration information, and manages base virtual machine instances.\n\nStruct Description: The grpccache struct represents a gRPC client cache that maintains a connection to a gRPC server and stores VM configuration information.\n\nFields:\nconn: *grpc.ClientConn - Maintains the active connection to the gRPC server\nconfig: *vc.VMConfig - Stores the virtual machine configuration obtained from the server\n\nMethods:\nNew: [Name](ctx context.Context, endpoint string) -> (base.FactoryBase, error) - Creates a new grpccache instance by establishing a connection to the gRPC server at the specified endpoint and retrieving the VM configuration.\nGetBaseVM: [Name](ctx context.Context, config vc.VMConfig) -> (*vc.VM, error) - Retrieves a base VM instance from the cache server and closes the connection when done. The method converts the gRPC response to a local VM object.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\n\ttypes \"github.com/gogo/protobuf/types\"\n\tpb \"github.com/kata-containers/runtime/protocols/cache\"\n\tvc \"github.com/kata-containers/runtime/virtcontainers\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype grpccache struct {\n\tconn   *grpc.ClientConn\n\tconfig *vc.VMConfig\n}\n\nfunc New(ctx context.Context, endpoint string) (base.FactoryBase, error) {\n\tconn, err := grpc.Dial(fmt.Sprintf(\"unix://%s\", endpoint), grpc.WithInsecure())\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to connect %q\", endpoint)\n\t}\n\n\tjConfig, err := pb.NewCacheServiceClient(conn).Config(ctx, &types.Empty{})\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to Config\")\n\t}\n\n\tconfig, err := vc.GrpcToVMConfig(jConfig)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to convert JSON to VMConfig\")\n\t}\n\n\treturn &grpccache{conn: conn, config: config}, nil\n}\n\nfunc (g *grpccache) GetBaseVM(ctx context.Context, config vc.VMConfig) (*vc.VM, error) {\n\tdefer g.conn.Close()\n\tgVM, err := pb.NewCacheServiceClient(g.conn).GetBaseVM(ctx, &types.Empty{})\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to GetBaseVM\")\n\t}\n\treturn vc.NewVMFromGrpc(ctx, gVM, *g.config)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"vc/vm\"\n)\n\ntype grpccache struct {\n\tconn  *grpc.ClientConn\n\tconfig *vm.VMConfig\n}\n\nfunc New(ctx context.Context, endpoint string) (base.FactoryBase, error) {\n\tdialOptions := []grpc.DialOption{\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t}\n\n\tconn, err := grpc.NewClient(endpoint, dialOptions...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to gRPC server: %v\", err)\n\t}\n\n\t// Assume a method is called on the server to retrieve VM config\n\t// This is a placeholder for actual gRPC call logic\n\t// In real scenario, you would use the client to call a method that returns the config\n\t// For example:\n\t// config, err := client.GetVMConfig(ctx, &vm.GetVMConfigRequest{})\n\t// if err != nil {\n\t// \treturn nil, err\n\t// }\n\n\t// For this example, we'll assume the config is retrieved successfully\n\t// In practice, this would be obtained via a gRPC call\n\tconfig := &vm.VMConfig{\n\t\tName: \"example-vm\",\n\t\tOS:   \"Linux\",\n\t\tMemory: 1024,\n\t\tDisk: 50,\n\t}\n\n\treturn &grpccache{\n\t\tconn:  conn,\n\t\tconfig: config,\n\t}, nil\n}\n\nfunc (c *grpccache) GetBaseVM(ctx context.Context, config *vm.VMConfig) (*vm.VM, error) {\n\t// Placeholder for actual gRPC call to retrieve VM instance\n\t// In real scenario, you would call a method on the client to get the VM\n\t// For example:\n\t// vm, err := client.GetVM(ctx, &vm.GetVMRequest{Config: config})\n\t// if err != nil {\n\t// \treturn nil, err\n\t// }\n\n\t// For this example, we'll assume the VM is retrieved successfully\n\tvm := &vm.VM{\n\t\tID:       \"vm-123\",\n\t\tName:     config.Name,\n\t\tOS:       config.OS,\n\t\tMemory:   config.Memory,\n\t\tDisk:     config.Disk,\n\t\tStarted:  false,\n\t}\n\n\t// Close the connection when done\n\tif err := c.conn.Close(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to close gRPC connection: %v\", err)\n\t}\n\n\treturn vm, nil\n}"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a PubSub service, publishes messages, and handles connection cleanup.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 1234, creates a PubSub service client, publishes two predefined messages, and ensures proper connection closure. It demonstrates basic gRPC client operations including connection establishment, RPC calls, and resource cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function publishes messages to the server and logs errors if any occur)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"gobook.examples/ch4-04-grpc/grpc-pubsub/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tpb \"path/to/your/proto/pb\" // Replace with actual proto package path\n)\n\nfunc publishMessages() {\n\t// Define the gRPC connection parameters\n\tgrpcAddr := \"localhost:1234\"\n\t// Define the messages to publish\n\tmessages := []string{\n\t\t\"First message from client\",\n\t\t\"Second message from client\",\n\t}\n\n\t// Create a gRPC connection\n\tconn, err := grpc.NewConnection(grpcAddr, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a PubSub service client\n\tclient := pb.NewPubSubClient(conn)\n\n\t// Publish each message\n\tfor _, msg := range messages {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\n\t\t_, err := client.Publish(ctx, &pb.PublishRequest{Message: msg})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"Published message: %s\", msg)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC server for Google Pub/Sub emulator and initializes a Pub/Sub client using that connection.\n\nFunction Description: The function demonstrates how to set up a connection to a local gRPC server (Pub/Sub emulator) using insecure credentials, then creates a Pub/Sub client with the established connection. The client should be properly closed when no longer needed.\n\nInput: None (uses hardcoded values for demonstration purposes)\n\nOutput: None (function demonstrates setup pattern, actual Pub/Sub client is created but not used)\n\nNote: The function uses context.Background() for simplicity in the example, and hardcodes \"project\" as the Google Cloud project ID for demonstration purposes. In production code, these would typically be parameters.",
    "Canonical_solution": "import (\n\t\"cloud.google.com/go/pubsub\"\n\t\"cloud.google.com/go/pubsub/pstest\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n)\nfunc ExampleNewServer() {\n\tctx := context.Background()\n\tsrv := pstest.NewServer()\n\tconn, err := grpc.Dial(srv.Addr, grpc.WithInsecure())\n\tif err != nil {\n\t}\n\tclient, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t}\n\tdefer client.Close()\n\t_ = client\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/pubsub\"\n)\n\nfunc initPubSubClient() {\n\t// Hardcoded values for demonstration purposes\n\tprojectID := \"project\"\n\tserverAddr := \"localhost:8085\"\n\n\t// Create a gRPC connection to the Pub/Sub emulator\n\tconn, err := grpc.NewConnection(serverAddr)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to connect to gRPC server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Create a Pub/Sub client using the connection\n\tclient, err := pubsub.NewClient(context.Background(), projectID, pubsub.WithGRPCConnection(conn))\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create Pub/Sub client:\", err)\n\t\treturn\n\t}\n\tdefer client.Close()\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a function to send synchronous HTTP requests with custom configurations including headers, authentication, and transport settings.\n\nFunction Description: The function SendWebRequestSync sends an HTTP request with customizable method, headers, body, and authentication. It handles the response, checks for success status codes, and properly manages resources. The function uses a pre-configured HTTP client with custom transport settings for timeout and TLS configuration.\n\nInput:\n- ctx (context.Context): Context for request cancellation and timeouts\n- webhook (*monitor.SendWebhookSync): Pointer to a struct containing request parameters including:\n  - HttpMethod (string): HTTP method (GET, POST, etc.)\n  - Url (string): Target URL\n  - Body (string): Request body content\n  - ContentType (string): Content-Type header value\n  - User (string): Username for basic auth\n  - Password (string): Password for basic auth\n  - HttpHeader (map[string]string): Additional HTTP headers\n\nOutput:\n- error: Returns nil on success (2xx status code), or an error describing the failure (non-2xx status code or transport error)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/context/ctxhttp\"\n\t\"moul.io/http2curl/v2\"\n\n\t\"yunion.io/x/log\"\n\n\t\"yunion.io/x/onecloud/pkg/apis/monitor\"\n)\nvar netTransport = &http.Transport{\n\tTLSClientConfig: &tls.Config{\n\t\tRenegotiation: tls.RenegotiateFreelyAsClient,\n\t},\n\tProxy: http.ProxyFromEnvironment,\n\tDialContext: (&net.Dialer{\n\t\tTimeout: 30 * time.Second,\n\t}).DialContext,\n\tTLSHandshakeTimeout: 5 * time.Second,\n}\nvar netClient = &http.Client{\n\tTimeout:   time.Second * 30,\n\tTransport: netTransport,\n}\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tif webhook.HttpMethod == \"\" {\n\t\twebhook.HttpMethod = http.MethodPost\n\t}\n\n\trequest, err := http.NewRequest(webhook.HttpMethod, webhook.Url, bytes.NewReader([]byte(webhook.Body)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif webhook.ContentType == \"\" {\n\t\twebhook.ContentType = \"application/json\"\n\t}\n\n\trequest.Header.Add(\"Content-Type\", webhook.ContentType)\n\trequest.Header.Add(\"User-Agent\", \"OneCloud Monitor\")\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\trequest.Header.Add(\"Authorization\", GetBasicAuthHeader(webhook.User, webhook.Password))\n\t}\n\n\tfor k, v := range webhook.HttpHeader {\n\t\trequest.Header.Set(k, v)\n\t}\n\n\tcurlCmd, _ := http2curl.GetCurlCommand(request)\n\tlog.Debugf(\"webhook curl: %s\", curlCmd)\n\n\tresp, err := ctxhttp.Do(ctx, netClient, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 == 2 {\n\t\tif _, err := io.Copy(ioutil.Discard, resp.Body); err != nil {\n\t\t\tlog.Errorf(\"Failed to copy resp.Body to ioutil.Discard: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Errorf(\"Webhook failed statuscode: %s, body: %s\", resp.Status, string(body))\n\treturn fmt.Errorf(\"Webhook response status %v\", resp.Status)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tMaxIdleConns: 100,\n\t\t\tIdleConnTimeout: 30 * time.Second,\n\t\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t},\n\t}\n\n\treq, err := http.NewRequest(webhook.HttpMethod, webhook.Url, strings.NewReader(webhook.Body))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", webhook.ContentType)\n\tfor k, v := range webhook.HttpHeader {\n\t\treq.Header.Set(k, v)\n\t}\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\treq.SetBasicAuth(webhook.User, webhook.Password)\n\t}\n\n\tresp, err := client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"request failed with status code %d: %s\", resp.StatusCode, body)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Create a gRPC client in Go that connects to a RouteGuide service, performs various operations (getting features, listing features within a rectangle, recording a route, and conducting route chat), and handles secure/insecure connections.\n\nFunction Description: The main function establishes a connection to a gRPC server, creates a RouteGuide client, and demonstrates various service operations. It handles both secure (TLS) and insecure connections based on input flags.\n\nInput:\n- Command line flags (implicit):\n  - tls (bool): Whether to use TLS encryption\n  - serverHostOverride (string): Server name for certificate validation\n  - caFile (string): Path to CA certificate file\n  - serverAddr (string): Server address in format host:port\n\nOutput:\n- None (direct output to console/logger)\n- Side effects: Makes gRPC calls to server and prints results\n\nMethods called (from RouteGuideClient):\n1. printFeature(client, point) - Gets and prints a feature at given point\n2. printFeatures(client, rectangle) - Lists features within given rectangle\n3. runRecordRoute(client) - Records a route and prints statistics\n4. runRouteChat(client) - Conducts bidirectional route chat",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &pb.Point{409146138, -746188906})\n\tprintFeature(client, &pb.Point{0, 0})\n\tprintFeatures(client, &pb.Rectangle{&pb.Point{400000000, -750000000}, &pb.Point{420000000, -730000000}})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"route_guide/gRPC/proto\"\n)\n\nvar (\n\ttls              = flag.Bool(\"tls\", false, \"Use TLS encryption\")\n\tserverHostOverride = flag.String(\"server_host_override\", \"\", \"Server name for certificate validation\")\n\tcaFile           = flag.String(\"ca_file\", \"\", \"Path to CA certificate file\")\n\tserverAddr       = flag.String(\"server_addr\", \"localhost:50051\", \"Server address in format host:port\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tconn, err := grpcConnect(*tls, *serverHostOverride, *caFile, *serverAddr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := proto.NewRouteGuideClient(conn)\n\n\tprintFeature(client, &proto.Point{Latitude: 409146463, Longitude: -746207415})\n\tprintFeatures(client, &proto.Rectangle{\n\t\tLo: &proto.Point{Latitude: 409146463, Longitude: -746207415},\n\t\tHi: &proto.Point{Latitude: 409146463, Longitude: -746207415},\n\t})\n\trunRecordRoute(client)\n\trunRouteChat(client)\n}\n\nfunc grpcConnect(tls bool, serverHostOverride string, caFile string, serverAddr string) (*grpc.ClientConn, error) {\n\tvar opts []grpc.DialOption\n\n\tif tls {\n\t\tcreds, err := credentials.NewClientTLSFromCert(rawCert(), serverHostOverride)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tif caFile != \"\" {\n\t\tcreds, err := credentials.NewClientTLSFromCert(rawCert(), serverHostOverride)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\nfunc rawCert() *credentials.Certificate {\n\t// This is a placeholder for actual certificate loading logic\n\t// In a real application, this would load the certificate from the provided caFile\n\treturn &credentials.Certificate{}\n}\n\nfunc printFeature(client proto.RouteGuideClient, point *proto.Point) {\n\tresp, err := client.GetFeature(context.Background(), &proto.Point{Latitude: point.Latitude, Longitude: point.Longitude})\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not get feature: %v\", err)\n\t}\n\tfmt.Printf(\"Feature at (%v, %v): %v\\n\", point.Longitude, point.Latitude, resp.Feature)\n}\n\nfunc printFeatures(client proto.RouteGuideClient, rectangle *proto.Rectangle) {\n\tresp, err := client.ListFeatures(context.Background(), rectangle)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not list features: %v\", err)\n\t}\n\tfor _, feature := range resp.Features {\n\t\tfmt.Printf(\"Feature at (%v, %v): %v\\n\", feature.Location.Longitude, feature.Location.Latitude, feature.Name)\n\t}\n}\n\nfunc runRecordRoute(client proto.RouteGuideClient) {\n\tpoints := []*proto.Point{\n\t\t{Latitude: 409146463, Longitude: -746207415},\n\t\t{Latitude: 409146463, Longitude: -746207415},\n\t\t{Latitude: 409146463, Longitude: -746207415},\n\t\t{Latitude: 409146463, Longitude: -746207415},\n\t\t{Latitude: 409146463, Longitude: -746207415},\n\t}\n\n\tstream, err := client.RecordRoute(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not create record route stream: %v\", err)\n\t}\n\n\tfor _, point := range points {\n\t\tif err := stream.Send(point); err != nil {\n\t\t\tlog.Fatalf(\"Error sending point: %v\", err)\n\t\t}\n\t}\n\n\tif err := stream.CloseAndWait(); err != nil {\n\t\tlog.Fatalf(\"Error closing stream: %v\", err)\n\t}\n\n\tresponse, err := stream.Recv()\n\tif err == io.EOF {\n\t\tfmt.Println(\"Received all responses.\")\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlog.Fatalf(\"Error receiving response: %v\", err)\n\t}\n\tfmt.Printf(\"RecordRoute response: %v\\n\", response)\n}\n\nfunc runRouteChat(client proto.RouteGuideClient) {\n\tstream, err := client.RouteChat(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not create route chat stream: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"Error receiving message: %v\", err)\n\t\t\t}\n\t\t\tfmt.Print(\"You: \")\n\t\t\t_, _ = fmt.Scanln()\n\t\t\tif err := stream.Send(&proto.Message{Text: \"Hello from client\"}); err != nil {\n\t\t\t\tlog.Fatalf(\"Error sending message: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\ttime.Sleep(time.Second)\n}"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a server, with optional TLS security, and returns a client instance for a specified service.\n\nFunction Description: The function `createGRPCClient` initializes a gRPC client connection to a specified server address. It supports both secure (TLS) and insecure connections based on input parameters. After establishing the connection, it creates and returns a client instance for the RouteGuide service.\n\nInput: \n- `serverAddr` (string): The address of the gRPC server to connect to\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string): Path to the CA certificate file (required if useTLS is true)\n- `serverHostOverride` (string): Server name used for TLS host verification\n\nOutput:\n- `pb.RouteGuideClient`: The generated gRPC client instance for the RouteGuide service\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/examples/data\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tif *caFile == \"\" {\n\t\t\t*caFile = data.Path(\"x509/ca_cert.pem\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tconn, err := grpc.NewClient(*serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/sockopt\"\n\t\"google.golang.org/grpc/xds\"\n\t\"google.golang.org/grpc/xds/xdscache\"\n\t\"google.golang.org/grpc/xds/xdsclient\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/client\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/discovery\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/dns\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/http\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/k8s\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds/xdsclient/v3/resolver/weighted/roundrobin/roundrobin\"\n\t\"google.golang.org/grpc/xds"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, publishes messages, and handles connection cleanup.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client for the PubsubService, publishes two predefined messages, and ensures proper connection closure. The function handles potential connection errors and publishing failures.\n\nInput: None (The target server address is hardcoded as \"localhost:1234\" and messages are predefined)\n\nOutput: None (The function performs side effects by publishing messages to the gRPC server and may terminate the program on errors)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"ch4.4-3/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"golang: hello Go\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = client.Publish(context.Background(), &pb.String{Value: \"docker: hello Docker\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/status\"\n\t\"time\"\n)\n\ntype PubsubServiceClient struct {\n\tclient *grpc.ClientConn\n}\n\nfunc NewPubsubServiceClient(address string) (*PubsubServiceClient, error) {\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PubsubServiceClient{client: conn}, nil\n}\n\nfunc (c *PubsubServiceClient) PublishMessages() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered from panic:\", r)\n\t\t}\n\t}()\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tclient := PubsubServiceClient{\n\t\tclient: NewPubsubServiceClient(\"localhost:1234\").client,\n\t}\n\n\tmsg1 := \"Message 1\"\n\tmsg2 := \"Message 2\"\n\n\tfor _, msg := range []string{msg1, msg2} {\n\t\tresp, err := client.Publish(ctx, msg)\n\t\tif err != nil {\n\t\t\tif st, ok := status.FromError(err); ok {\n\t\t\t\tfmt.Printf(\"Error publishing message: %v (%s)\\n\", st.Code(), st.Message())\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Error publishing message: %v\\n\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Published message: %s\\n\", msg)\n\t}\n\n\tif err := client.client.Close(); err != nil {\n\t\tfmt.Printf(\"Error closing connection: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a function that tests a gRPC client connection to a user authentication service, sends multiple login requests, and prints the received authentication tokens.\n\nFunction Description: The function establishes an insecure gRPC connection to a specified server address, creates a user client, and sends 20 consecutive login requests with metadata containing a UUID. Each successful response's token is printed, while errors cause immediate termination.\n\nInput: None (The service address is hardcoded as \"127.0.0.1:8881\" and login credentials are fixed as account \"hwholiday\" and password \"123456\")\n\nOutput: None (The function prints tokens to stdout and may return early on error through testing.T's Error method)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v7/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nconst (\n\tserverAddr     = \"127.0.0.1:8881\"\n\taccount        = \"hwholiday\"\n\tpassword       = \"123456\"\n\tnumLoginRequests = 20\n)\n\ntype UserClient struct {\n\tclient UserClient\n}\n\nfunc NewUserClient() *UserClient {\n\tconn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\treturn &UserClient{\n\t\tclient: NewUserClientImpl(conn),\n\t}\n}\n\nfunc (c *UserClient) Login(ctx context.Context) (*TokenResponse, error) {\n\tmd := metadata.Pairs(\"uuid\", generateUUID())\n\tctx = metadata.NewContext(ctx, md)\n\tresponse, err := c.client.Login(ctx, &LoginRequest{\n\t\tAccount: account,\n\t\tPassword: password,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}\n\nfunc generateUUID() string {\n\t// Simple UUID generator for demonstration purposes\n\treturn fmt.Sprintf(\"%x%x%x%x%x%x%x%x%x%x%x%x\", time.Now().UnixNano())\n}\n\nfunc TestLogin() {\n\tclient := NewUserClient()\n\tfor i := 0; i < numLoginRequests; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\t\ttokenResponse, err := client.Login(ctx)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Login failed: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Received token: %s\\n\", tokenResponse.Token)\n\t}\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Implement a Go struct that interacts with the Pinecone vector database to upsert embeddings and retrieve similar vectors using HTTP requests with custom headers.\n\nStruct Description: The Pinecone struct represents a client for interacting with the Pinecone vector database API. It handles authentication, request construction, and response processing for vector operations.\n\nFields:\nEndpoint: string - The base URL of the Pinecone API endpoint\nApiKey: string - The API key used for authentication with Pinecone\n\nMethods:\nNew: [endpoint string, apiKey string] -> [*Pinecone, error] - Creates a new Pinecone client instance with the given endpoint and API key\n\nUpsertEmbeddings: [embeddings [][]float32, chunks []chunk.Chunk, uuid string] -> [error] - Upserts multiple embeddings into Pinecone in batches, with associated metadata from chunks, under the specified namespace UUID\n\nRetrieve: [questionEmbedding []float32, topK int, uuid string] -> [[]vectordb.QueryMatch, error] - Retrieves the topK most similar vectors to the questionEmbedding from the specified namespace UUID",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/pashpashpash/vault/chunk\"\n\t\"github.com/pashpashpash/vault/vectordb\"\n)\n\ntype Pinecone struct {\n\tEndpoint string\n\tApiKey   string\n}\n\nfunc New(endpoint string, apiKey string) (*Pinecone, error) {\n\treturn &Pinecone{\n\t\tEndpoint: endpoint,\n\t\tApiKey:   apiKey,\n\t}, nil\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []chunk.Chunk, uuid string) error {\n\turl := p.Endpoint + \"/vectors/upsert\"\n\n\tvectors := make([]PineconeVector, len(embeddings))\n\tfor i, embedding := range embeddings {\n\t\tchunk := chunks[i]\n\t\tvectors[i] = PineconeVector{\n\t\t\tID:     fmt.Sprintf(\"id-%d\", i),\n\t\t\tValues: embedding,\n\t\t\tMetadata: map[string]string{\n\t\t\t\t\"file_name\": chunk.Title,\n\t\t\t\t\"start\":     strconv.Itoa(chunk.Start),\n\t\t\t\t\"end\":       strconv.Itoa(chunk.End),\n\t\t\t\t\"title\":     chunk.Title,\n\t\t\t\t\"text\":      chunk.Text,\n\t\t\t},\n\t\t}\n\t}\n\n\tmaxVectorsPerRequest := 100\n\n\tfor i := 0; i < len(vectors); i += maxVectorsPerRequest {\n\t\tend := i + maxVectorsPerRequest\n\t\tif end > len(vectors) {\n\t\t\tend = len(vectors)\n\t\t}\n\n\t\trequestBody, err := json.Marshal(struct {\n\t\t\tVectors   []PineconeVector `json:\"vectors\"`\n\t\t\tNamespace string           `json:\"namespace\"`\n\t\t}{\n\t\t\tVectors:   vectors[i:end],\n\t\t\tNamespace: uuid,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(requestBody))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn errors.New(string(body))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([]vectordb.QueryMatch, error) {\n\trequestBody, _ := json.Marshal(PineconeQueryRequest{\n\t\tTopK:            topK,\n\t\tIncludeMetadata: true,\n\t\tNamespace:       uuid,\n\t\tQueries: []PineconeQueryItem{\n\t\t\t{\n\t\t\t\tValues: questionEmbedding,\n\t\t\t},\n\t\t},\n\t})\n\n\tpineconeIndexURL := p.Endpoint + \"/query\"\n\treq, _ := http.NewRequest(\"POST\", pineconeIndexURL, bytes.NewBuffer(requestBody))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tvar pineconeQueryResponse PineconeQueryResponse\n\tjson.Unmarshal(body, &pineconeQueryResponse)\n\n\tif len(pineconeQueryResponse.Results) > 0 {\n\t\treturn pineconeQueryResponse.Results[0].Matches, nil\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package pinecone\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Chunk struct {\n\tText string `json:\"text\"`\n}\n\ntype QueryMatch struct {\n\tID      string  `json:\"id\"`\n\tVector  []float32 `json:\"vector\"`\n\tMetadata map[string]interface{} `json:\"metadata\"`\n}\n\ntype Pinecone struct {\n\tendpoint string\n\tapiKey   string\n}\n\nfunc New(endpoint string, apiKey string) (*Pinecone, error) {\n\tif endpoint == \"\" || apiKey == \"\" {\n\t\treturn nil, fmt.Errorf(\"endpoint and apiKey are required\")\n\t}\n\treturn &Pinecone{\n\t\tendpoint: endpoint,\n\t\tapiKey:   apiKey,\n\t}, nil\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []Chunk, uuid string) error {\n\turl := fmt.Sprintf(\"%s/upsert\", p.endpoint)\n\theaders := map[string]string{\n\t\t\"API-Key\": p.apiKey,\n\t\t\"Content-Type\": \"application/json\",\n\t}\n\n\tbody, err := json.Marshal(map[string]interface{}{\n\t\t\"uuid\":       uuid,\n\t\t\"embeddings\": embeddings,\n\t\t\"chunks\":     chunks,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code: %d, response: %s\", resp.StatusCode, string(body))\n\t}\n\n\treturn nil\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([][]QueryMatch, error) {\n\turl := fmt.Sprintf(\"%s/retrieve\", p.endpoint)\n\theaders := map[string]string{\n\t\t\"API-Key\": p.apiKey,\n\t\t\"Content-Type\": \"application/json\",\n\t}\n\n\tbody, err := json.Marshal(map[string]interface{}{\n\t\t\"uuid\":          uuid,\n\t\t\"question\":      questionEmbedding,\n\t\t\"top_k\":         topK,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d, response: %s\", resp.StatusCode, string(body))\n\t}\n\n\tvar results [][]QueryMatch\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn results, nil\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Implement a gRPC client function in Go that connects to a gRPC server, performs unary and streaming RPCs, and handles communication with the server.\n\nFunction Description: The function `doClientWork` establishes a connection to a gRPC server, performs a unary RPC call (`Hello`), and then sets up bidirectional streaming (`Channel`). It sends messages periodically in one goroutine while receiving messages in the main goroutine.\n\nInput: None (The server address is hardcoded as \"localhost:1234\")\n\nOutput: None (The function prints received messages to stdout and logs errors to stderr)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc doClientWork() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(reply.GetValue())\n\n\tstream, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\tif err := stream.Send(&String{Value: \"hi\"}); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tfor {\n\t\tlog.Println(222)\n\n\t\treply, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(reply.GetValue())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype GreeterClient struct {\n\tconn *grpc.ClientConn\n}\n\nfunc NewGreeterClient() *GreeterClient {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\treturn &GreeterClient{conn: conn}\n}\n\nfunc (c *GreeterClient) Hello(ctx context.Context, name string) {\n\tclient := greeter.NewGreeterClient(c.conn)\n\tresp, err := client.Hello(ctx, &greeter.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in Hello: %v\", err)\n\t}\n\tfmt.Printf(\"Hello Response: %s\\n\", resp.Message)\n}\n\nfunc (c *GreeterClient) Channel(stream greeter.Greeter_ChannelServer) {\n\tclient := greeter.NewGreeterClient(c.conn)\n\tstreamer, err := client.Channel(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in Channel: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ttime.Sleep(time.Second)\n\t\t\tif err := streamer.Send(&greeter.HelloRequest{Name: fmt.Sprintf(\"Message %d\", i)}); err != nil {\n\t\t\t\tlog.Printf(\"Error sending message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tstreamer.CloseSend()\n\t}()\n\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error receiving message: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Received: %s\\n\", msg.Message)\n\t}\n}\n\nfunc doClientWork() {\n\tclient := NewGreeterClient()\n\tclient.Hello(context.Background(), \"World\")\n\tclient.Channel(client)\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Implement an HTTP probe function that checks the availability and correctness of a remote HTTP service by making a GET request with custom headers and verifying the response.\n\nFunction Description: The function performs an HTTP probe to a specified URL with custom configuration including timeout, headers, and TLS settings. It verifies the response status code and optionally checks for a success flag in the response body. The function logs the probe results and returns a success/failure status.\n\nInput:\n- protocol: string - The protocol to use (http/https)\n- address: string - The target server address\n- path: string - The request path\n- port: int - The target port number\n- headerList: []*types.HTTPHeader - List of custom HTTP headers to include\n- timeout: time.Duration - Request timeout duration\n- responseSuccessFlag: string - Optional string to check in response body for success\n- log: *zap.SugaredLogger - Logger for recording probe results\n\nOutput:\n- string - Probe result status (Success/Failure)\n- error - Error details if probe fails",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/koderover/zadig/v2/pkg/types\"\n\t\"go.uber.org/zap\"\n)\nfunc doHTTPProbe(protocol, address, path string, port int, headerList []*types.HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\ttlsConfig := &tls.Config{InsecureSkipVerify: true}\n\ttransport := &http.Transport{\n\t\tTLSClientConfig:   tlsConfig,\n\t\tDisableKeepAlives: true,\n\t\tProxy:             http.ProxyURL(nil),\n\t}\n\tclient := &http.Client{\n\t\tTimeout:       timeout,\n\t\tTransport:     transport,\n\t\tCheckRedirect: redirectChecker(false),\n\t}\n\turl, err := formatURL(protocol, address, path, port)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\theaders := buildHeader(headerList)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\treq.Header = headers\n\treq.Host = headers.Get(\"Host\")\n\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn Failure, err\n\t}\n\n\tif res.StatusCode >= http.StatusOK && res.StatusCode < http.StatusBadRequest {\n\t\tif responseSuccessFlag != \"\" && !strings.Contains(string(body), responseSuccessFlag) {\n\t\t\treturn Failure, fmt.Errorf(\"HTTP probe failed with response success flag: %s\", responseSuccessFlag)\n\t\t}\n\t\tlog.Infof(\"Probe succeeded for %s, Response: %v\", url, *res)\n\t\treturn Success, nil\n\t}\n\tlog.Warnf(\"Probe failed for %s, response body: %v\", url, string(body))\n\treturn Failure, fmt.Errorf(\"HTTP probe failed with statuscode: %d\", res.StatusCode)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-logr/logr\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/szap\"\n)\n\ntype HTTPHeader struct {\n\tName  string\n\tValue string\n}\n\nfunc HTTPProbe(protocol string, address string, path string, port int, headerList []*HTTPHeader, timeout time.Duration, responseSuccessFlag string, log *zap.SugaredLogger) (string, error) {\n\turl := fmt.Sprintf(\"%s://%s:%d/%s\", protocol, address, port, path)\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tlog.Errorw(\"Error creating request\", \"error\", err)\n\t\treturn \"Failure\", err\n\t}\n\n\tfor _, header := range headerList {\n\t\treq.Header.Set(header.Name, header.Value)\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSHandshakeTimeout: timeout,\n\t\t},\n\t\tTimeout: timeout,\n\t}\n\n\tresp, err := client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\tlog.Errorw(\"Error making HTTP request\", \"error\", err)\n\t\treturn \"Failure\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode >= 400 {\n\t\tlog.Errorw(\"HTTP request failed\", \"status\", resp.StatusCode)\n\t\treturn \"Failure\", fmt.Errorf(\"HTTP request failed with status code %d\", resp.StatusCode)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Errorw(\"Error reading response body\", \"error\", err)\n\t\treturn \"Failure\", err\n\t}\n\n\tif responseSuccessFlag != \"\" {\n\t\tif !bytes.Contains(body, []byte(responseSuccessFlag)) {\n\t\t\tlog.Errorw(\"Response body does not contain expected success flag\", \"flag\", responseSuccessFlag)\n\t\t\treturn \"Failure\", fmt.Errorf(\"response body does not contain expected success flag: %s\", responseSuccessFlag)\n\t\t}\n\t}\n\n\tlog.Infow(\"HTTP probe successful\", \"url\", url, \"status\", resp.StatusCode)\n\treturn \"Success\", nil\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC management server for Envoy's xDS (Discovery Service) protocol, supporting dynamic configuration updates and load reporting.\n\nStruct Description: The ManagementServer struct represents a gRPC server that implements Envoy's xDS protocol, including Aggregated Discovery Service (ADS) and optionally Load Reporting Service (LRS). It maintains a snapshot cache of resources and handles gRPC connections.\n\nFields:\n- Address: string - The network address the server is listening on\n- LRSServer: *fakeserver.Server - Optional fake LRS server instance\n- cancel: context.CancelFunc - Function to cancel the server's context\n- xs: v3server.Server - xDS server implementation\n- gs: *grpc.Server - gRPC server instance\n- cache: v3cache.SnapshotCache - Cache for storing configuration snapshots\n- version: int - Current version of the configuration\n- logger: interface{ Logf(format string, args ...any) } - Logger interface for output\n\nMethods:\n- StartManagementServer(*testing.T, ManagementServerOptions) *ManagementServer - Creates and starts a new management server instance. Takes testing context and options, returns initialized server.\n- Update(context.Context, UpdateOptions) error - Updates the server's configuration snapshot with new resources. Takes context and update options, returns error if update fails.\n- Stop() - Stops the server and cleans up resources. No parameters or return values.\n\nThe struct provides dynamic configuration management for Envoy proxies through the xDS protocol, with support for listeners, routes, clusters, and endpoints configuration.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/envoyproxy/go-control-plane/pkg/cache/types\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils/xds/fakeserver\"\n\n\tv3clusterpb \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tv3endpointpb \"github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3\"\n\tv3listenerpb \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tv3routepb \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3cache \"github.com/envoyproxy/go-control-plane/pkg/cache/v3\"\n\tv3resource \"github.com/envoyproxy/go-control-plane/pkg/resource/v3\"\n\tv3server \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n)\n\ntype ManagementServer struct {\n\tAddress   string\n\tLRSServer *fakeserver.Server\n\n\tcancel  context.CancelFunc\n\txs      v3server.Server\n\tgs      *grpc.Server\n\tcache   v3cache.SnapshotCache\n\tversion int\n\n\tlogger interface {\n\t\tLogf(format string, args ...any)\n\t}\n}\n\nfunc StartManagementServer(t *testing.T, opts ManagementServerOptions) *ManagementServer {\n\twait := !opts.AllowResourceSubset\n\tcache := v3cache.NewSnapshotCache(wait, v3cache.IDHash{}, serverLogger{t})\n\n\tlis := opts.Listener\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to listen on localhost:0: %v\", err)\n\t\t}\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcallbacks := v3server.CallbackFuncs{\n\t\tStreamOpenFunc:     opts.OnStreamOpen,\n\t\tStreamClosedFunc:   opts.OnStreamClosed,\n\t\tStreamRequestFunc:  opts.OnStreamRequest,\n\t\tStreamResponseFunc: opts.OnStreamResponse,\n\t}\n\n\txs := v3server.NewServer(ctx, cache, callbacks)\n\tgs := grpc.NewServer()\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(gs, xs)\n\n\tmgmtServer := &ManagementServer{\n\t\tAddress: lis.Addr().String(),\n\t\tcancel:  cancel,\n\t\tversion: 0,\n\t\tgs:      gs,\n\t\txs:      xs,\n\t\tcache:   cache,\n\t\tlogger:  t,\n\t}\n\tif opts.SupportLoadReportingService {\n\t\tlrs := fakeserver.NewServer(lis.Addr().String())\n\t\tv3lrsgrpc.RegisterLoadReportingServiceServer(gs, lrs)\n\t\tmgmtServer.LRSServer = lrs\n\t}\n\n\tgo gs.Serve(lis)\n\tt.Cleanup(mgmtServer.Stop)\n\treturn mgmtServer\n}\n\nfunc (s *ManagementServer) Update(ctx context.Context, opts UpdateOptions) error {\n\ts.version++\n\n\tresources := map[v3resource.Type][]types.Resource{\n\t\tv3resource.ListenerType: resourceSlice(opts.Listeners),\n\t\tv3resource.RouteType:    resourceSlice(opts.Routes),\n\t\tv3resource.ClusterType:  resourceSlice(opts.Clusters),\n\t\tv3resource.EndpointType: resourceSlice(opts.Endpoints),\n\t}\n\tsnapshot, err := v3cache.NewSnapshot(strconv.Itoa(s.version), resources)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create new snapshot cache: %v\", err)\n\t}\n\tif !opts.SkipValidation {\n\t\tif err := snapshot.Consistent(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create new resource snapshot: %v\", err)\n\t\t}\n\t}\n\n\tif err := s.cache.SetSnapshot(ctx, opts.NodeID, snapshot); err != nil {\n\t\treturn fmt.Errorf(\"failed to update resource snapshot in management server: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *ManagementServer) Stop() {\n\tif s.cancel != nil {\n\t\ts.cancel()\n\t}\n\ts.gs.Stop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"log\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"envoy/api/v2\"\n\t\"envoy/api/v2/core\"\n\t\"envoy/config/cluster/v3\"\n\t\"envoy/config/listener/v3\"\n\t\"envoy/config/route/v3\"\n\t\"envoy/service/discovery/v3\"\n\t\"envoy/service/load_report/v3\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/runtime/protoiface\"\n\t\"google.golang.org/protobuf/runtime/serializer/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/encoding"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles plugin registration and message streaming between clients and middleware components.\n\nStruct Description: The pluginServer struct implements a gRPC service for plugin registration and message handling, managing concurrent access with synchronization and supporting both middleware and non-middleware listeners.\n\nFields:\n- UnimplementedPluginServer: pb.UnimplementedPluginServer - Embedded type for forward compatibility\n- lock: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n- RegisterListener: (stream pb.Plugin_RegisterListenerServer) -> error - Handles client registration and message streaming\n  - Input: gRPC bidirectional stream of pb.Plugin_RegisterListenerServer\n  - Output: error indicating operation status\n  - Description: Registers listeners, processes incoming messages, matches against regex patterns, handles middleware responses, and manages one-time listeners\n\n- rpcInit: () -> () - Initializes and starts the gRPC server\n  - Input: None (uses package-level Integrations.RPC configuration)\n  - Output: None (runs as goroutine)\n  - Description: Creates TCP listener, configures gRPC server with interceptors and keepalive, registers service, and starts serving requests",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype pluginServer struct {\n\tpb.UnimplementedPluginServer\n\tlock sync.Mutex\n}\n\nfunc (s *pluginServer) RegisterListener(stream pb.Plugin_RegisterListenerServer) error {\n\ts.lock.Lock()\n\tinitialData, err := stream.Recv()\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistener := initialData.GetListener()\n\tif listener == nil {\n\t\treturn status.Error(codes.InvalidArgument, \"First message must be a listener\")\n\t}\n\n\tisMiddleware := listener.Middleware != nil && *listener.Middleware\n\tisOnce := listener.Once != nil && *listener.Once\n\n\tvar regex *regexp.Regexp\n\tif listener.Regex != nil {\n\t\tregex, err = regexp.Compile(*listener.Regex)\n\t\tif err != nil {\n\t\t\treturn status.Error(codes.InvalidArgument, \"Invalid regex\")\n\t\t}\n\t}\n\n\tvar listenerList *[]chan pb.MiddlewareChannelMessage\n\n\tif isMiddleware {\n\t\tlistenerList = &ListenersMiddleware\n\t} else {\n\t\tlistenerList = &ListenersNonMiddleware\n\t}\n\n\tc := make(chan pb.MiddlewareChannelMessage)\n\t*listenerList = append(*listenerList, c)\n\n\ts.lock.Unlock()\n\tdefer func() {\n\t\tfor i := range *listenerList {\n\t\t\tif (*listenerList)[i] == c {\n\t\t\t\t*listenerList = append((*listenerList)[:i], (*listenerList)[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tmessage := <-c\n\n\t\tsendNilResponse := func() {\n\t\t\tc <- &pb.ListenerClientData_Response{\n\t\t\t\tResponse: &pb.MiddlewareResponse{\n\t\t\t\t\tMsg: nil,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif listener.Regex != nil && !regex.MatchString(message.(*pb.Event).Msg) {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\terr = stream.Send(message.(*pb.Event))\n\t\tif err != nil {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif isMiddleware {\n\t\t\tmwRes, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tswitch data := mwRes.Data.(type) {\n\t\t\tcase *pb.ListenerClientData_Listener:\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn status.Error(codes.InvalidArgument, \"Middleware returned a listener instead of a response\")\n\t\t\tcase *pb.ListenerClientData_Response:\n\t\t\t\tc <- data\n\t\t\t}\n\t\t}\n\n\t\tif isOnce {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc rpcInit() {\n\tif Integrations.RPC == nil {\n\t\treturn\n\t}\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", Integrations.RPC.Port))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgrpcServer := grpc.NewServer(\n\t\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\t\tif err := authorize(ctx); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn handler(ctx, req)\n\t\t\t}),\n\t\t\tgrpc.StreamInterceptor(func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n\t\t\t\tif err := authorize(stream.Context()); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn handler(srv, stream)\n\t\t\t}),\n\t\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{Time: time.Second * 10}),\n\t\t)\n\t\tpb.RegisterPluginServer(grpcServer, &pluginServer{})\n\t\tgrpcServer.Serve(lis)\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t// Replace with actual package path for the plugin service\n\tpb \"path/to/plugin/service\"\n)\n\ntype pluginServer struct {\n\tpb.UnimplementedPluginServer\n\tmu      sync.Mutex\n\tlisteners map[string]*listener\n}\n\ntype listener struct {\n\tid        string\n\tregex     string\n\tmiddleware bool\n\tstream    pb.Plugin_RegisterListenerServer\n}\n\nfunc (s *pluginServer) RegisterListener(stream pb.Plugin_RegisterListenerServer) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.listeners == nil {\n\t\ts.listeners = make(map[string]*listener)\n\t}\n\n\tid := fmt.Sprintf(\"%d\", len(s.listeners)+1)\n\tl := &listener{\n\t\tid:        id,\n\t\tregex:     \"\",\n\t\tmiddleware: false,\n\t\tstream:    stream,\n\t}\n\n\ts.listeners[id] = l\n\n\tgo func() {\n\t\tfor {\n\t\t\tmsg, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error receiving message: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif msg.Pattern != \"\" {\n\t\t\t\tl.regex = msg.Pattern\n\t\t\t}\n\n\t\t\tif msg.Middleware {\n\t\t\t\tl.middleware = true\n\t\t\t}\n\n\t\t\tif msg.Data != nil {\n\t\t\t\tif l.middleware {\n\t\t\t\t\t// Simulate middleware processing\n\t\t\t\t\tlog.Printf(\"Middleware processing data for listener %s: %v\", l.id, msg.Data)\n\t\t\t\t} else {\n\t\t\t\t\t// Simulate direct message handling\n\t\t\t\t\tlog.Printf(\"Handling data for listener %s: %v\", l.id, msg.Data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (s *pluginServer) rpcInit() {\n\t// Configure keepalive parameters\n\tka := keepalive.ServerParameters{\n\t\tMaxConnectionIdle: 30 * time.Second,\n\t\tMaxConnectionAge:  60 * time.Second,\n\t\tTime:              10 * time.Second,\n\t\tTimeout:           5 * time.Second,\n\t}\n\n\t// Create gRPC server\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.KeepaliveParams(ka),\n\t\tgrpc.UnknownServiceNoInfo(false),\n\t)\n\n\t// Register reflection service\n\treflection.Register(grpcServer)\n\n\t// Register plugin service\n\tpb.RegisterPluginServer(grpcServer, &pluginServer{})\n\n\t// Create TCP listener\n\tlistener, err := net.Listen(\"tcp\", \"localhost:50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Start server\n\tlog.Println(\"Starting gRPC server...\")\n\tgo func() {\n\t\tif err := grpcServer.Serve(listener, nil); err != nil {\n\t\t\tlog.Fatalf(\"Server exited unexpectedly: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc main() {\n\t// Initialize and start the gRPC server in a separate goroutine\n\tgo func() {\n\t\t_ = pluginServer{}.rpcInit()\n\t}()\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a function that retrieves metadata from a Google Cloud instance using a custom HTTP client with specific headers and returns both the metadata value and its ETag.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the Google Cloud metadata server to fetch instance metadata. It uses a custom HTTP client with timeout configurations and sets required headers (\"Metadata-Flavor\" and \"User-Agent\"). The function handles various response scenarios including errors and not-found statuses, and returns the metadata value along with its ETag if successful.\n\nInput:\n- `client` (*http.Client): A custom HTTP client configured with specific timeout settings\n- `suffix` (string): The metadata path suffix to append to the base metadata URL\n\nOutput:\n- `value` (string): The retrieved metadata value\n- `etag` (string): The ETag header value from the response\n- `err` (error): Any error encountered during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc getETag(client *http.Client, suffix string) (string, string, error) {\n\turl := \"http://169.254.169.254/2023-07-01/meta\" + suffix\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", \"Go/1.21\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 404 {\n\t\treturn \"\", \"\", errors.New(\"metadata not found\")\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn \"\", \"\", errors.New(string(body))\n\t}\n\n\tetag := resp.Header.Get(\"ETag\")\n\tbody, _ := io.ReadAll(resp.Body)\n\tvalue := string(body)\n\n\treturn value, etag, nil\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Implement a gRPC server for remote actor communication in a distributed actor system using Proto.Actor and Go's gRPC framework.\n\nStruct Description: The Remote struct manages the gRPC server and associated components for remote actor communication in a Proto.Actor system.\n\nFields:\n\nactorSystem: *actor.ActorSystem - Reference to the actor system this remote belongs to\ns: *grpc.Server - The gRPC server instance\nedpReader: *endpointReader - Handles incoming gRPC connections\nedpManager: *endpointManager - Manages active endpoints\nconfig: *Config - Configuration for the remote server\nkinds: map[string]*actor.Props - Map of actor kinds to their properties\nactivatorPid: *actor.PID - Process ID for the activator actor\nblocklist: *BlockList - List of blocked endpoints\n\nMethods:\n\nNewRemote: (actorSystem *actor.ActorSystem, config *Config) -> *Remote - Constructor that initializes a new Remote instance with given actor system and configuration\nStart: () -> () - Starts the gRPC server and initializes all remote communication components\nShutdown: (graceful bool) -> () - Stops the gRPC server, either gracefully or forcefully",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log/slog\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/asynkron/protoactor-go/extensions\"\n\t\"github.com/asynkron/protoactor-go/actor\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/grpclog\"\n)\n\ntype Remote struct {\n\tactorSystem  *actor.ActorSystem\n\ts            *grpc.Server\n\tedpReader    *endpointReader\n\tedpManager   *endpointManager\n\tconfig       *Config\n\tkinds        map[string]*actor.Props\n\tactivatorPid *actor.PID\n\tblocklist    *BlockList\n}\n\nfunc NewRemote(actorSystem *actor.ActorSystem, config *Config) *Remote {\n\tr := &Remote{\n\t\tactorSystem: actorSystem,\n\t\tconfig:      config,\n\t\tkinds:       make(map[string]*actor.Props),\n\t\tblocklist:   NewBlockList(),\n\t}\n\tfor k, v := range config.Kinds {\n\t\tr.kinds[k] = v\n\t}\n\n\tactorSystem.Extensions.Register(r)\n\n\treturn r\n}\n\nfunc (r *Remote) Start() {\n\tgrpclog.SetLoggerV2(grpclog.NewLoggerV2(ioutil.Discard, ioutil.Discard, ioutil.Discard))\n\tlis, err := net.Listen(\"tcp\", r.config.Address())\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to listen: %v\", err))\n\t}\n\n\tvar address string\n\tif r.config.AdvertisedHost != \"\" {\n\t\taddress = r.config.AdvertisedHost\n\t} else {\n\t\taddress = lis.Addr().String()\n\t}\n\n\tr.actorSystem.ProcessRegistry.RegisterAddressResolver(r.remoteHandler)\n\tr.actorSystem.ProcessRegistry.Address = address\n\tr.Logger().Info(\"Starting remote with address\", slog.String(\"address\", address))\n\n\tr.edpManager = newEndpointManager(r)\n\tr.edpManager.start()\n\n\tr.s = grpc.NewServer(r.config.ServerOptions...)\n\tr.edpReader = newEndpointReader(r)\n\tRegisterRemotingServer(r.s, r.edpReader)\n\tr.Logger().Info(\"Starting Proto.Actor server\", slog.String(\"address\", address))\n\tgo r.s.Serve(lis)\n}\n\nfunc (r *Remote) Shutdown(graceful bool) {\n\tif graceful {\n\t\tr.edpReader.suspend(true)\n\t\tr.edpManager.stop()\n\n\t\tc := make(chan bool, 1)\n\t\tgo func() {\n\t\t\tr.s.GracefulStop()\n\t\t\tc <- true\n\t\t}()\n\n\t\tselect {\n\t\tcase <-c:\n\t\t\tr.Logger().Info(\"Stopped Proto.Actor server\")\n\t\tcase <-time.After(time.Second * 10):\n\t\t\tr.s.Stop()\n\t\t\tr.Logger().Info(\"Stopped Proto.Actor server\", slog.String(\"err\", \"timeout\"))\n\t\t}\n\t} else {\n\t\tr.s.Stop()\n\t\tr.Logger().Info(\"Killed Proto.Actor server\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"proto.actor\"\n)\n\ntype Remote struct {\n\tactorSystem *actor.ActorSystem\n\ts           *grpc.Server\n\tedpReader   *endpointReader\n\tedpManager  *endpointManager\n\tconfig      *Config\n\tkinds       map[string]*actor.Props\n\tactivatorPid *actor.PID\n\tblocklist   *BlockList\n}\n\nfunc NewRemote(actorSystem *actor.ActorSystem, config *Config) *Remote {\n\treturn &Remote{\n\t\tactorSystem: actorSystem,\n\t\tconfig:      config,\n\t\tkinds:       make(map[string]*actor.Props),\n\t}\n}\n\nfunc (r *Remote) Start() {\n\tr.s = grpc.NewServer()\n\tr.edpReader = newEndpointReader(r.actorSystem, r.config)\n\tr.edpManager = newEndpointManager(r.actorSystem, r.config)\n\tr.activatorPid = r.actorSystem.Spawn(activatorActor, r.config)\n\tr.blocklist = newBlockList(r.config.Blocklist)\n\tr.actorSystem.RegisterActor(r.activatorPid, \"activator\")\n\tr.actorSystem.RegisterActor(r.edpReader, \"endpoint_reader\")\n\tr.actorSystem.RegisterActor(r.edpManager, \"endpoint_manager\")\n\n\tlistener, err := net.Listen(\"tcp\", r.config.Address)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := r.s.Serve(listener, grpc.MaxRecvMsgSize(1024*1024)); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Register gRPC handlers\n\tproto.RegisterRemoteServiceServer(r.s, &remoteServiceServer{r})\n}\n\nfunc (r *Remote) Shutdown(graceful bool) {\n\tif graceful {\n\t\tr.s.GracefulStop()\n\t} else {\n\t\tr.s.Stop()\n\t}\n}\n\ntype remoteServiceServer struct {\n\tremote *Remote\n}\n\nfunc (s *remoteServiceServer) Ping(ctx context.Context, req *proto.PingRequest) (*proto.PongResponse, error) {\n\tmd, ok := metadata.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.Internal, \"metadata not found\")\n\t}\n\tremoteAddr := md.Get(\"remote-addr\")[0]\n\tlog.Printf(\"Received ping from remote: %s\", remoteAddr)\n\treturn &proto.PongResponse{Message: \"Pong\"}, nil\n}\n\nfunc (s *remoteServiceServer) RegisterActor(ctx context.Context, req *proto.RegisterActorRequest) (*proto.RegisterActorResponse, error) {\n\t// Implement actor registration logic\n\treturn &proto.RegisterActorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) SendMsg(ctx context.Context, req *proto.SendMsgRequest) (*proto.SendMsgResponse, error) {\n\t// Implement message sending logic\n\treturn &proto.SendMsgResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorInfo(ctx context.Context, req *proto.GetActorInfoRequest) (*proto.GetActorInfoResponse, error) {\n\t// Implement actor info retrieval logic\n\treturn &proto.GetActorInfoResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorState(ctx context.Context, req *proto.GetActorStateRequest) (*proto.GetActorStateResponse, error) {\n\t// Implement actor state retrieval logic\n\treturn &proto.GetActorStateResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorProps(ctx context.Context, req *proto.GetActorPropsRequest) (*proto.GetActorPropsResponse, error) {\n\t// Implement actor props retrieval logic\n\treturn &proto.GetActorPropsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorKind(ctx context.Context, req *proto.GetActorKindRequest) (*proto.GetActorKindResponse, error) {\n\t// Implement actor kind retrieval logic\n\treturn &proto.GetActorKindResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemInfo(ctx context.Context, req *proto.GetActorSystemInfoRequest) (*proto.GetActorSystemInfoResponse, error) {\n\t// Implement actor system info retrieval logic\n\treturn &proto.GetActorSystemInfoResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemState(ctx context.Context, req *proto.GetActorSystemStateRequest) (*proto.GetActorSystemStateResponse, error) {\n\t// Implement actor system state retrieval logic\n\treturn &proto.GetActorSystemStateResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemProps(ctx context.Context, req *proto.GetActorSystemPropsRequest) (*proto.GetActorSystemPropsResponse, error) {\n\t// Implement actor system props retrieval logic\n\treturn &proto.GetActorSystemPropsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemKind(ctx context.Context, req *proto.GetActorSystemKindRequest) (*proto.GetActorSystemKindResponse, error) {\n\t// Implement actor system kind retrieval logic\n\treturn &proto.GetActorSystemKindResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersion(ctx context.Context, req *proto.GetActorSystemVersionRequest) (*proto.GetActorSystemVersionResponse, error) {\n\t// Implement actor system version retrieval logic\n\treturn &proto.GetActorSystemVersionResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemTimestamp(ctx context.Context, req *proto.GetActorSystemTimestampRequest) (*proto.GetActorSystemTimestampResponse, error) {\n\t// Implement actor system timestamp retrieval logic\n\treturn &proto.GetActorSystemTimestampResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemUptime(ctx context.Context, req *proto.GetActorSystemUptimeRequest) (*proto.GetActorSystemUptimeResponse, error) {\n\t// Implement actor system uptime retrieval logic\n\treturn &proto.GetActorSystemUptimeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemMemoryUsage(ctx context.Context, req *proto.GetActorSystemMemoryUsageRequest) (*proto.GetActorSystemMemoryUsageResponse, error) {\n\t// Implement actor system memory usage retrieval logic\n\treturn &proto.GetActorSystemMemoryUsageResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemGCStats(ctx context.Context, req *proto.GetActorSystemGCStatsRequest) (*proto.GetActorSystemGCStatsResponse, error) {\n\t// Implement actor system GC stats retrieval logic\n\treturn &proto.GetActorSystemGCStatsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemThreadStats(ctx context.Context, req *proto.GetActorSystemThreadStatsRequest) (*proto.GetActorSystemThreadStatsResponse, error) {\n\t// Implement actor system thread stats retrieval logic\n\treturn &proto.GetActorSystemThreadStatsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemCPUUsage(ctx context.Context, req *proto.GetActorSystemCPUUsageRequest) (*proto.GetActorSystemCPUUsageResponse, error) {\n\t// Implement actor system CPU usage retrieval logic\n\treturn &proto.GetActorSystemCPUUsageResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemDiskUsage(ctx context.Context, req *proto.GetActorSystemDiskUsageRequest) (*proto.GetActorSystemDiskUsageResponse, error) {\n\t// Implement actor system disk usage retrieval logic\n\treturn &proto.GetActorSystemDiskUsageResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemNetworkUsage(ctx context.Context, req *proto.GetActorSystemNetworkUsageRequest) (*proto.GetActorSystemNetworkUsageResponse, error) {\n\t// Implement actor system network usage retrieval logic\n\treturn &proto.GetActorSystemNetworkUsageResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemLog(ctx context.Context, req *proto.GetActorSystemLogRequest) (*proto.GetActorSystemLogResponse, error) {\n\t// Implement actor system log retrieval logic\n\treturn &proto.GetActorSystemLogResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemHealth(ctx context.Context, req *proto.GetActorSystemHealthRequest) (*proto.GetActorSystemHealthResponse, error) {\n\t// Implement actor system health retrieval logic\n\treturn &proto.GetActorSystemHealthResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemStatus(ctx context.Context, req *proto.GetActorSystemStatusRequest) (*proto.GetActorSystemStatusResponse, error) {\n\t// Implement actor system status retrieval logic\n\treturn &proto.GetActorSystemStatusResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemMetrics(ctx context.Context, req *proto.GetActorSystemMetricsRequest) (*proto.GetActorSystemMetricsResponse, error) {\n\t// Implement actor system metrics retrieval logic\n\treturn &proto.GetActorSystemMetricsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemConfig(ctx context.Context, req *proto.GetActorSystemConfigRequest) (*proto.GetActorSystemConfigResponse, error) {\n\t// Implement actor system config retrieval logic\n\treturn &proto.GetActorSystemConfigResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemSettings(ctx context.Context, req *proto.GetActorSystemSettingsRequest) (*proto.GetActorSystemSettingsResponse, error) {\n\t// Implement actor system settings retrieval logic\n\treturn &proto.GetActorSystemSettingsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemOptions(ctx context.Context, req *proto.GetActorSystemOptionsRequest) (*proto.GetActorSystemOptionsResponse, error) {\n\t// Implement actor system options retrieval logic\n\treturn &proto.GetActorSystemOptionsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemFeatures(ctx context.Context, req *proto.GetActorSystemFeaturesRequest) (*proto.GetActorSystemFeaturesResponse, error) {\n\t// Implement actor system features retrieval logic\n\treturn &proto.GetActorSystemFeaturesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionString(ctx context.Context, req *proto.GetActorSystemVersionStringRequest) (*proto.GetActorSystemVersionStringResponse, error) {\n\t// Implement actor system version string retrieval logic\n\treturn &proto.GetActorSystemVersionStringResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionNumber(ctx context.Context, req *proto.GetActorSystemVersionNumberRequest) (*proto.GetActorSystemVersionNumberResponse, error) {\n\t// Implement actor system version number retrieval logic\n\treturn &proto.GetActorSystemVersionNumberResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionHash(ctx context.Context, req *proto.GetActorSystemVersionHashRequest) (*proto.GetActorSystemVersionHashResponse, error) {\n\t// Implement actor system version hash retrieval logic\n\treturn &proto.GetActorSystemVersionHashResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionDate(ctx context.Context, req *proto.GetActorSystemVersionDateRequest) (*proto.GetActorSystemVersionDateResponse, error) {\n\t// Implement actor system version date retrieval logic\n\treturn &proto.GetActorSystemVersionDateResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionTime(ctx context.Context, req *proto.GetActorSystemVersionTimeRequest) (*proto.GetActorSystemVersionTimeResponse, error) {\n\t// Implement actor system version time retrieval logic\n\treturn &proto.GetActorSystemVersionTimeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionBuild(ctx context.Context, req *proto.GetActorSystemVersionBuildRequest) (*proto.GetActorSystemVersionBuildResponse, error) {\n\t// Implement actor system version build retrieval logic\n\treturn &proto.GetActorSystemVersionBuildResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionCommit(ctx context.Context, req *proto.GetActorSystemVersionCommitRequest) (*proto.GetActorSystemVersionCommitResponse, error) {\n\t// Implement actor system version commit retrieval logic\n\treturn &proto.GetActorSystemVersionCommitResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionBranch(ctx context.Context, req *proto.GetActorSystemVersionBranchRequest) (*proto.GetActorSystemVersionBranchResponse, error) {\n\t// Implement actor system version branch retrieval logic\n\treturn &proto.GetActorSystemVersionBranchResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionAuthor(ctx context.Context, req *proto.GetActorSystemVersionAuthorRequest) (*proto.GetActorSystemVersionAuthorResponse, error) {\n\t// Implement actor system version author retrieval logic\n\treturn &proto.GetActorSystemVersionAuthorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionLicense(ctx context.Context, req *proto.GetActorSystemVersionLicenseRequest) (*proto.GetActorSystemVersionLicenseResponse, error) {\n\t// Implement actor system version license retrieval logic\n\treturn &proto.GetActorSystemVersionLicenseResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionDescription(ctx context.Context, req *proto.GetActorSystemVersionDescriptionRequest) (*proto.GetActorSystemVersionDescriptionResponse, error) {\n\t// Implement actor system version description retrieval logic\n\treturn &proto.GetActorSystemVersionDescriptionResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionNotes(ctx context.Context, req *proto.GetActorSystemVersionNotesRequest) (*proto.GetActorSystemVersionNotesResponse, error) {\n\t// Implement actor system version notes retrieval logic\n\treturn &proto.GetActorSystemVersionNotesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionChangelog(ctx context.Context, req *proto.GetActorSystemVersionChangelogRequest) (*proto.GetActorSystemVersionChangelogResponse, error) {\n\t// Implement actor system version changelog retrieval logic\n\treturn &proto.GetActorSystemVersionChangelogResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionDependencies(ctx context.Context, req *proto.GetActorSystemVersionDependenciesRequest) (*proto.GetActorSystemVersionDependenciesResponse, error) {\n\t// Implement actor system version dependencies retrieval logic\n\treturn &proto.GetActorSystemVersionDependenciesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionTestRequirements(ctx context.Context, req *proto.GetActorSystemVersionTestRequirementsRequest) (*proto.GetActorSystemVersionTestRequirementsResponse, error) {\n\t// Implement actor system version test requirements retrieval logic\n\treturn &proto.GetActorSystemVersionTestRequirementsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionDocumentation(ctx context.Context, req *proto.GetActorSystemVersionDocumentationRequest) (*proto.GetActorSystemVersionDocumentationResponse, error) {\n\t// Implement actor system version documentation retrieval logic\n\treturn &proto.GetActorSystemVersionDocumentationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionExamples(ctx context.Context, req *proto.GetActorSystemVersionExamplesRequest) (*proto.GetActorSystemVersionExamplesResponse, error) {\n\t// Implement actor system version examples retrieval logic\n\treturn &proto.GetActorSystemVersionExamplesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionTutorials(ctx context.Context, req *proto.GetActorSystemVersionTutorialsRequest) (*proto.GetActorSystemVersionTutorialsResponse, error) {\n\t// Implement actor system version tutorials retrieval logic\n\treturn &proto.GetActorSystemVersionTutorialsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionFAQ(ctx context.Context, req *proto.GetActorSystemVersionFAQRequest) (*proto.GetActorSystemVersionFAQResponse, error) {\n\t// Implement actor system version FAQ retrieval logic\n\treturn &proto.GetActorSystemVersionFAQResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionSupport(ctx context.Context, req *proto.GetActorSystemVersionSupportRequest) (*proto.GetActorSystemVersionSupportResponse, error) {\n\t// Implement actor system version support retrieval logic\n\treturn &proto.GetActorSystemVersionSupportResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotes(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesRequest) (*proto.GetActorSystemVersionReleaseNotesResponse, error) {\n\t// Implement actor system version release notes retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseHistory(ctx context.Context, req *proto.GetActorSystemVersionReleaseHistoryRequest) (*proto.GetActorSystemVersionReleaseHistoryResponse, error) {\n\t// Implement actor system version release history retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseHistoryResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseSchedule(ctx context.Context, req *proto.GetActorSystemVersionReleaseScheduleRequest) (*proto.GetActorSystemVersionReleaseScheduleResponse, error) {\n\t// Implement actor system version release schedule retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseScheduleResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForVersion(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForVersionRequest) (*proto.GetActorSystemVersionReleaseNotesForVersionResponse, error) {\n\t// Implement actor system version release notes for version retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForVersionResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForPatch(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForPatchRequest) (*proto.GetActorSystemVersionReleaseNotesForPatchResponse, error) {\n\t// Implement actor system version release notes for patch retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForPatchResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForMinor(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForMinorRequest) (*proto.GetActorSystemVersionReleaseNotesForMinorResponse, error) {\n\t// Implement actor system version release notes for minor retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForMinorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForMajor(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForMajorRequest) (*proto.GetActorSystemVersionReleaseNotesForMajorResponse, error) {\n\t// Implement actor system version release notes for major retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForMajorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForHotfix(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForHotfixRequest) (*proto.GetActorSystemVersionReleaseNotesForHotfixResponse, error) {\n\t// Implement actor system version release notes for hotfix retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForHotfixResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForSecurity(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForSecurityRequest) (*proto.GetActorSystemVersionReleaseNotesForSecurityResponse, error) {\n\t// Implement actor system version release notes for security retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForSecurityResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForPerformance(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForPerformanceRequest) (*proto.GetActorSystemVersionReleaseNotesForPerformanceResponse, error) {\n\t// Implement actor system version release notes for performance retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForPerformanceResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForCompatibility(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForCompatibilityRequest) (*proto.GetActorSystemVersionReleaseNotesForCompatibilityResponse, error) {\n\t// Implement actor system version release notes for compatibility retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForCompatibilityResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForBugFix(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForBugFixRequest) (*proto.GetActorSystemVersionReleaseNotesForBugFixResponse, error) {\n\t// Implement actor system version release notes for bug fix retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForBugFixResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForFeature(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForFeatureRequest) (*proto.GetActorSystemVersionReleaseNotesForFeatureResponse, error) {\n\t// Implement actor system version release notes for feature retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForFeatureResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForDeprecation(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForDeprecationRequest) (*proto.GetActorSystemVersionReleaseNotesForDeprecationResponse, error) {\n\t// Implement actor system version release notes for deprecation retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForDeprecationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForRemoval(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForRemovalRequest) (*proto.GetActorSystemVersionReleaseNotesForRemovalResponse, error) {\n\t// Implement actor system version release notes for removal retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForRemovalResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForRenaming(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForRenamingRequest) (*proto.GetActorSystemVersionReleaseNotesForRenamingResponse, error) {\n\t// Implement actor system version release notes for renaming retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForRenamingResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForBreakingChange(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForBreakingChangeRequest) (*proto.GetActorSystemVersionReleaseNotesForBreakingChangeResponse, error) {\n\t// Implement actor system version release notes for breaking change retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForBreakingChangeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForNonBreakingChange(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForNonBreakingChangeRequest) (*proto.GetActorSystemVersionReleaseNotesForNonBreakingChangeResponse, error) {\n\t// Implement actor system version release notes for non-breaking change retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForNonBreakingChangeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForEnhancement(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForEnhancementRequest) (*proto.GetActorSystemVersionReleaseNotesForEnhancementResponse, error) {\n\t// Implement actor system version release notes for enhancement retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForEnhancementResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForOptimization(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForOptimizationRequest) (*proto.GetActorSystemVersionReleaseNotesForOptimizationResponse, error) {\n\t// Implement actor system version release notes for optimization retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForOptimizationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForDocumentation(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForDocumentationRequest) (*proto.GetActorSystemVersionReleaseNotesForDocumentationResponse, error) {\n\t// Implement actor system version release notes for documentation retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForDocumentationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForExamples(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForExamplesRequest) (*proto.GetActorSystemVersionReleaseNotesForExamplesResponse, error) {\n\t// Implement actor system version release notes for examples retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForExamplesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForTutorials(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForTutorialsRequest) (*proto.GetActorSystemVersionReleaseNotesForTutorialsResponse, error) {\n\t// Implement actor system version release notes for tutorials retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForTutorialsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForFAQ(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForFAQRequest) (*proto.GetActorSystemVersionReleaseNotesForFAQResponse, error) {\n\t// Implement actor system version release notes for FAQ retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForFAQResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForSupport(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForSupportRequest) (*proto.GetActorSystemVersionReleaseNotesForSupportResponse, error) {\n\t// Implement actor system version release notes for support retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForSupportResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotes(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesResponse, error) {\n\t// Implement actor system version release notes for release notes retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseHistory(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseHistoryRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseHistoryResponse, error) {\n\t// Implement actor system version release notes for release history retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseHistoryResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseSchedule(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseScheduleRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseScheduleResponse, error) {\n\t// Implement actor system version release notes for release schedule retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseScheduleResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForVersion(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForVersionRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForVersionResponse, error) {\n\t// Implement actor system version release notes for release notes for version retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForVersionResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForPatch(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPatchRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPatchResponse, error) {\n\t// Implement actor system version release notes for release notes for patch retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPatchResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForMinor(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMinorRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMinorResponse, error) {\n\t// Implement actor system version release notes for release notes for minor retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMinorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForMajor(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMajorRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMajorResponse, error) {\n\t// Implement actor system version release notes for release notes for major retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForMajorResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForHotfix(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForHotfixRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForHotfixResponse, error) {\n\t// Implement actor system version release notes for release notes for hotfix retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForHotfixResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForSecurity(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSecurityRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSecurityResponse, error) {\n\t// Implement actor system version release notes for release notes for security retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSecurityResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForPerformance(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPerformanceRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPerformanceResponse, error) {\n\t// Implement actor system version release notes for release notes for performance retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForPerformanceResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForCompatibility(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForCompatibilityRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForCompatibilityResponse, error) {\n\t// Implement actor system version release notes for release notes for compatibility retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForCompatibilityResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForBugFix(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBugFixRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBugFixResponse, error) {\n\t// Implement actor system version release notes for release notes for bug fix retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBugFixResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForFeature(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFeatureRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFeatureResponse, error) {\n\t// Implement actor system version release notes for release notes for feature retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFeatureResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForDeprecation(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDeprecationRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDeprecationResponse, error) {\n\t// Implement actor system version release notes for release notes for deprecation retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDeprecationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForRemoval(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRemovalRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRemovalResponse, error) {\n\t// Implement actor system version release notes for release notes for removal retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRemovalResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForRenaming(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRenamingRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRenamingResponse, error) {\n\t// Implement actor system version release notes for release notes for renaming retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForRenamingResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForBreakingChange(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBreakingChangeRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBreakingChangeResponse, error) {\n\t// Implement actor system version release notes for release notes for breaking change retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForBreakingChangeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForNonBreakingChange(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForNonBreakingChangeRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForNonBreakingChangeResponse, error) {\n\t// Implement actor system version release notes for release notes for non-breaking change retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForNonBreakingChangeResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForEnhancement(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForEnhancementRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForEnhancementResponse, error) {\n\t// Implement actor system version release notes for release notes for enhancement retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForEnhancementResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForOptimization(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForOptimizationRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForOptimizationResponse, error) {\n\t// Implement actor system version release notes for release notes for optimization retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForOptimizationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForDocumentation(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDocumentationRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDocumentationResponse, error) {\n\t// Implement actor system version release notes for release notes for documentation retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForDocumentationResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForExamples(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForExamplesRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForExamplesResponse, error) {\n\t// Implement actor system version release notes for release notes for examples retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForExamplesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForTutorials(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForTutorialsRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForTutorialsResponse, error) {\n\t// Implement actor system version release notes for release notes for tutorials retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForTutorialsResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForFAQ(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFAQRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFAQResponse, error) {\n\t// Implement actor system version release notes for release notes for FAQ retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForFAQResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForSupport(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSupportRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSupportResponse, error) {\n\t// Implement actor system version release notes for release notes for support retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForSupportResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseNotes(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseNotesRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseNotesResponse, error) {\n\t// Implement actor system version release notes for release notes for release notes retrieval logic\n\treturn &proto.GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseNotesResponse{Success: true}, nil\n}\n\nfunc (s *remoteServiceServer) GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseHistory(ctx context.Context, req *proto.GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseHistoryRequest) (*proto.GetActorSystemVersionReleaseNotesForReleaseNotesForReleaseHistoryResponse, error) {\n\t// Implement actor system version release notes for release notes for release history retrieval logic\n\treturn &proto.GetActorSystemVersionRelease"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles unary RPC calls with ORCA (Open Request Cost Aggregation) metrics recording capabilities.\n\nStruct Description: The server struct implements the gRPC service interface (generated from the protobuf definition) and includes ORCA metrics recording functionality.\n\nFields:\n- UnimplementedEchoServer: [pb.UnimplementedEchoServer] - Embedded type to satisfy the gRPC service interface requirements\n\nMethods:\n- UnaryEcho: [Name](ctx context.Context, in *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls, records request costs using ORCA metrics, and returns an echo response\n- main: [Name]() -> None - Sets up the gRPC server, registers the service, configures ORCA metrics reporting, and starts the server\n\nInput Parameters for UnaryEcho:\n- ctx: [context.Context] - Context containing call information and ORCA metrics recorder\n- in: [*pb.EchoRequest] - Incoming request message containing the message to echo\n\nOutput for UnaryEcho:\n- [*pb.EchoResponse] - Response message containing the echoed message\n- [error] - Potential error during processing\n\nNote: The main function doesn't have explicit input/output but performs server setup and execution.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/orca\"\n\t\"google.golang.org/grpc/internal\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tcmr := orca.CallMetricsRecorderFromContext(ctx)\n\tif cmr == nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"unable to retrieve call metrics recorder (missing ORCA ServerOption?)\")\n\t}\n\tcmr.SetRequestCost(\"db_queries\", 10)\n\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\"localhost:%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(orca.CallMetricsServerOption(nil))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tsmr := orca.NewServerMetricsRecorder()\n\topts := orca.ServiceOptions{\n\t\tMinReportingInterval:  3 * time.Second,\n\t\tServerMetricsProvider: smr,\n\t}\n\tinternal.ORCAAllowAnyMinReportingInterval.(func(so *orca.ServiceOptions))(&opts)\n\tif err := orca.Register(s, opts); err != nil {\n\t\tlog.Fatalf(\"Failed to register ORCA service: %v\", err)\n\t}\n\n\ts.Serve(lis)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\"\n\t\"github.com/orca-metrics/orca\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n\tmetricRecorder *orca.MetricRecorder\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\t// Record the request cost using ORCA metrics\n\ts.metricRecorder.RecordRequestCost(\"echo\", in.Message, 100)\n\n\t// Process the request\n\tresponse := &pb.EchoResponse{\n\t\tMessage: in.Message,\n\t}\n\n\treturn response, nil\n}\n\nfunc main() {\n\t// Initialize ORCA metric recorder\n\tmetricRecorder := orca.NewMetricRecorder()\n\n\t// Create a new gRPC server\n\tgrpcServer := grpc.NewServer()\n\n\t// Register the server with the gRPC service\n\tpb.RegisterEchoServer(grpcServer, &server{metricRecorder: metricRecorder})\n\n\t// Set up the server listener\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Start the server\n\tlog.Printf(\"Server is running on port 50051\")\n\tif err := grpcServer.Serve(listener, nil); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both xDS (Discovery Service) and LRS (Load Reporting Service) protocols, with proper request/response channels and connection monitoring capabilities.\n\nStruct Description: The Server struct represents a gRPC server that implements both xDS v3 and LRS v3 services. It manages communication channels for requests/responses and tracks connection state.\n\nFields:\n\nXDSRequestChan: *testutils.Channel - Channel for receiving xDS requests\nXDSResponseChan: chan *Response - Channel for sending xDS responses\nLRSRequestChan: *testutils.Channel - Channel for receiving LRS requests\nLRSResponseChan: chan *Response - Channel for sending LRS responses\nLRSStreamOpenChan: *testutils.Channel - Channel for tracking LRS stream openings\nLRSStreamCloseChan: *testutils.Channel - Channel for tracking LRS stream closings\nNewConnChan: *testutils.Channel - Channel for tracking new connections\nAddress: string - Server's listening address\nxdsServerV3: *xdsServerV3 - xDS v3 server implementation\nlrsServerV3: *lrsServerV3 - LRS v3 server implementation\n\nMethods:\n\nNewServer: (addr string) -> *Server - Creates a new Server instance with initialized channels\nStartServer: (lis net.Listener) -> (*Server, func(), error) - Starts the gRPC server on given listener and returns cleanup function\nStreamAggregatedResources: (s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) -> error - Handles xDS v3 streaming RPC\nStreamLoadStats: (s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) -> error - Handles LRS v3 streaming RPC",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils\"\n\t\"google.golang.org/protobuf/proto\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3lrspb \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n)\n\ntype Server struct {\n\tXDSRequestChan *testutils.Channel\n\tXDSResponseChan chan *Response\n\tLRSRequestChan *testutils.Channel\n\tLRSResponseChan chan *Response\n\tLRSStreamOpenChan *testutils.Channel\n\tLRSStreamCloseChan *testutils.Channel\n\tNewConnChan *testutils.Channel\n\tAddress string\n\t*xdsServerV3\n\t*lrsServerV3\n}\n\ntype wrappedListener struct {\n\tnet.Listener\n\tserver *Server\n}\n\nfunc (wl *wrappedListener) Accept() (net.Conn, error) {\n\tc, err := wl.Listener.Accept()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twl.server.NewConnChan.Send(struct{}{})\n\treturn c, err\n}\n\nfunc StartServer(lis net.Listener) (*Server, func(), error) {\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\treturn nil, func() {}, fmt.Errorf(\"net.Listen() failed: %v\", err)\n\t\t}\n\t}\n\n\ts := NewServer(lis.Addr().String())\n\twp := &wrappedListener{\n\t\tListener: lis,\n\t\tserver:   s,\n\t}\n\n\tserver := grpc.NewServer()\n\tv3lrsgrpc.RegisterLoadReportingServiceServer(server, s)\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(server, s)\n\tgo server.Serve(wp)\n\n\treturn s, func() { server.Stop() }, nil\n}\n\nfunc NewServer(addr string) *Server {\n\ts := &Server{\n\t\tXDSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tNewConnChan:        testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tXDSResponseChan:    make(chan *Response, defaultChannelBufferSize),\n\t\tLRSResponseChan:    make(chan *Response, 1),\n\t\tLRSStreamOpenChan:  testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSStreamCloseChan: testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tAddress:            addr,\n\t}\n\ts.xdsServerV3 = &xdsServerV3{reqChan: s.XDSRequestChan, respChan: s.XDSResponseChan}\n\ts.lrsServerV3 = &lrsServerV3{reqChan: s.LRSRequestChan, respChan: s.LRSResponseChan, streamOpenChan: s.LRSStreamOpenChan, streamCloseChan: s.LRSStreamCloseChan}\n\treturn s\n}\n\ntype xdsServerV3 struct {\n\treqChan  *testutils.Channel\n\trespChan chan *Response\n}\n\nfunc (xdsS *xdsServerV3) StreamAggregatedResources(s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\terrCh := make(chan error, 2)\n\tgo func() {\n\t\tfor {\n\t\t\treq, err := s.Recv()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\txdsS.reqChan.Send(&Request{req, err})\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar retErr error\n\t\tdefer func() {\n\t\t\terrCh <- retErr\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase r := <-xdsS.respChan:\n\t\t\t\tif r.Err != nil {\n\t\t\t\t\tretErr = r.Err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := s.Send(r.Resp.(*v3discoverypb.DiscoveryResponse)); err != nil {\n\t\t\t\t\tretErr = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-s.Context().Done():\n\t\t\t\tretErr = s.Context().Err()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := <-errCh; err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype lrsServerV3 struct {\n\treqChan         *testutils.Channel\n\trespChan        chan *Response\n\tstreamOpenChan  *testutils.Channel\n\tstreamCloseChan *testutils.Channel\n}\n\nfunc (lrsS *lrsServerV3) StreamLoadStats(s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\tlrsS.streamOpenChan.Send(nil)\n\tdefer lrsS.streamCloseChan.Send(nil)\n\n\treq, err := s.Recv()\n\tlrsS.reqChan.Send(&Request{req, err})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase r := <-lrsS.respChan:\n\t\tif r.Err != nil {\n\t\t\treturn r.Err\n\t\t}\n\t\tif err := s.Send(r.Resp.(*v3lrspb.LoadStatsResponse)); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase <-s.Context().Done():\n\t\treturn s.Context().Err()\n\t}\n\n\tfor {\n\t\treq, err := s.Recv()\n\t\tlrsS.reqChan.Send(&Request{req, err})\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/protobuf/types/protoreflect/descriptor\"\n\t\"google.golang.org/protobuf/types/protowire\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/reflect/protosupport\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/encoding/ascii\"\n\t\"google.golang.org/protobuf/encoding/bytes\"\n\t\"google.golang.org/protobuf/encoding/jsonpb\"\n\t\"google.golang.org/protobuf/encoding/deframe\"\n\t\"google.golang.org/protobuf/encoding/protoc\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.golang.org/protobuf/encoding/protocfg\"\n\t\"google.g"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles greeting requests and responses.\n\nStruct Description: The server struct implements the GreeterServer interface generated from the protobuf definition, providing the SayHello method to handle incoming gRPC requests.\n\nFields:\nUnimplementedGreeterServer: pb.UnimplementedGreeterServer - Embedded type to ensure forward compatibility with future gRPC updates\n\nMethods:\nSayHello: [Name](ctx context.Context, in *pb.HelloRequest) -> (*pb.HelloReply, error) - Processes incoming HelloRequest, logs the received name, and returns a HelloReply with a greeting message",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n\nfunc (s *server) SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tlog.Printf(\"server listening at %v\", lis.Addr())\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"net/listener\"\n\t\"your_project/path/to/greeter_pb_grpc\"\n\t\"your_project/path/to/greeter_pb\"\n\t\"context\"\n)\n\ntype server struct {\n\tpb.GreeterServer\n}\n\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received hello request for %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n\nfunc main() {\n\tlis, err := listener.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\ts := &server{}\n\tgrpcServer := grpc.NewServer()\n\tgreeter_pb.RegisterGreeterServer(grpcServer, s)\n\tlog.Printf(\"Server listening at %v\", lis.Addr())\n\tif err := grpcServer.Serve(lis, nil); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a function that sends a multipart/form-data POST request to a specified URL with file upload capabilities and custom headers.\n\nFunction Description: The function performs an HTTP POST request with multipart form data, including file upload functionality. It constructs the request with custom headers, sends it using a custom HTTP client, and returns the response body as a string. The function handles file operations and request/response lifecycle properly with appropriate error handling.\n\nInput:\n- url (string): The target URL for the POST request\n- method (string): HTTP method (typically \"POST\")\n- filePath (string): Path to the file to be uploaded\n- formFields (map[string]string): Key-value pairs for form fields\n- headers (map[string]string): Custom headers to include in the request\n\nOutput:\n- (string): The response body from the server\n- (error): Any error that occurred during the process (nil if successful)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/image/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"image_signature\", \"1faaf9020e0df18fdf0429e0db211f37\")\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\")\n\tdefer file.Close()\n\tpart4,\n\t\terrFile4 := writer.CreateFormFile(\"image_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\t_ = writer.WriteField(\"filename\", \"auto4_huchao.1faaf9020e0df18fdf0429e0db211f37_test\u73af\u5883slicess_\u5361\u901a_P_HC_HC_en_1X1_0s\")\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"mime/multipart\"\n\t\"os\"\n)\n\nfunc uploadFile(url string, method string, filePath string, formFields map[string]string, headers map[string]string) (string, error) {\n\t// Create a new HTTP client\n\tclient := &http.Client{}\n\n\t// Create a buffer to hold the request body\n\tvar buf bytes.Buffer\n\n\t// Create a multipart writer\n\twriter := multipart.NewWriter(&buf)\n\n\t// Add form fields\n\tfor key, value := range formFields {\n\t\terr := writer.WriteField(key, value)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\t// Open the file for reading\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\t// Add the file to the multipart form\n\tfilename := filePath\n\tfileInfo, _ := file.Stat()\n\tfileSize := fileInfo.Size()\n\terr = writer.WriteField(\"file\", filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// Write the file content\n\tpart, _ := writer.CreateFormFile(\"file\", filename)\n\t_, err = io.Copy(part, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Close the multipart writer\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create the request\n\treq, err := http.NewRequest(method, url, &buf)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Set custom headers\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\t// Set the content type\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\n\t// Send the request\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Check if the response was successful\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Implement a gRPC server in Go that can handle incoming requests with configurable message size limits, TLS support, and OpenTracing integration.\n\nStruct Description: The Server struct represents a gRPC server instance with configurable settings for buffer size and server options.\n\nFields:\ngrpcServer: *grpc.Server - The underlying gRPC server instance\nbufferSize: int - The buffer size for server operations (currently unused in reference code)\n\nMethods:\nNewServer: () -> *Server - Creates and returns a new Server instance with default values\n\nStart: (url *common.URL) -> () - Starts the gRPC server with the specified URL configuration. Handles:\n  - Network listener setup\n  - Message size configuration\n  - TLS setup if configured\n  - OpenTracing integration\n  - Service registration\n  - Server reflection\n\nStop: () -> () - Immediately stops the gRPC server\n\nGracefulStop: () -> () - Gracefully stops the gRPC server, allowing existing RPCs to complete",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nimport (\n\t\"github.com/dubbogo/gost/log/logger\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nimport (\n\t\"dubbo.apache.org/dubbo-go/v3/common\"\n\t\"dubbo.apache.org/dubbo-go/v3/common/constant\"\n\t\"dubbo.apache.org/dubbo-go/v3/config\"\n\t\"dubbo.apache.org/dubbo-go/v3/protocol\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n\tbufferSize int\n}\n\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\nfunc (s *Server) Start(url *common.URL) {\n\tvar (\n\t\taddr string\n\t\terr  error\n\t)\n\taddr = url.Location\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmaxServerRecvMsgSize := constant.DefaultMaxServerRecvMsgSize\n\tif recvMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerRecvMsgSize, \"\")); convertErr == nil && recvMsgSize != 0 {\n\t\tmaxServerRecvMsgSize = int(recvMsgSize)\n\t}\n\tmaxServerSendMsgSize := constant.DefaultMaxServerSendMsgSize\n\tif sendMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerSendMsgSize, \"\")); err == convertErr && sendMsgSize != 0 {\n\t\tmaxServerSendMsgSize = int(sendMsgSize)\n\t}\n\n\ttracer := opentracing.GlobalTracer()\n\tvar serverOpts []grpc.ServerOption\n\tserverOpts = append(serverOpts,\n\t\tgrpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer)),\n\t\tgrpc.StreamInterceptor(otgrpc.OpenTracingStreamServerInterceptor(tracer)),\n\t\tgrpc.MaxRecvMsgSize(maxServerRecvMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxServerSendMsgSize),\n\t)\n\n\ttlsConfig := config.GetRootConfig().TLSConfig\n\tif tlsConfig != nil {\n\t\tvar cfg *tls.Config\n\t\tcfg, err = config.GetServerTlsConfig(&config.TLSConfig{\n\t\t\tCACertFile:    tlsConfig.CACertFile,\n\t\t\tTLSCertFile:   tlsConfig.TLSCertFile,\n\t\t\tTLSKeyFile:    tlsConfig.TLSKeyFile,\n\t\t\tTLSServerName: tlsConfig.TLSServerName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Grpc Server initialized the TLSConfig configuration\")\n\t\tserverOpts = append(serverOpts, grpc.Creds(credentials.NewTLS(cfg)))\n\t} else {\n\t\tserverOpts = append(serverOpts, grpc.Creds(insecure.NewCredentials()))\n\t}\n\tserver := grpc.NewServer(serverOpts...)\n\ts.grpcServer = server\n\n\tgo func() {\n\t\tproviderServices := config.GetProviderConfig().Services\n\n\t\tif len(providerServices) == 0 {\n\t\t\tpanic(\"provider service map is null\")\n\t\t}\n\t\twaitGrpcExporter(providerServices)\n\t\tregisterService(providerServices, server)\n\t\treflection.Register(server)\n\n\t\tif err = server.Serve(lis); err != nil {\n\t\t\tlogger.Errorf(\"server serve failed with err: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Stop() {\n\ts.grpcServer.Stop()\n}\n\nfunc (s *Server) GracefulStop() {\n\ts.grpcServer.GracefulStop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"gonum.org/v1/gonum/stat/describetype\"\n\t\"opentracing.io/opentracing\"\n\t\"opentracing.io/ext\"\n\t\"opentracing.io/global\"\n\t\"opentracing.io/noop\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n\tbufferSize int\n}\n\nfunc NewServer() *Server {\n\treturn &Server{\n\t\tgrpcServer: grpc.NewServer(),\n\t\tbufferSize: 1024,\n\t}\n}\n\nfunc (s *Server) Start(url *common.URL) {\n\t// Set up listener\n\tlistener, err := net.Listen(\"tcp\", url.Addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Configure message size\n\topts := []grpc.ServerOption{\n\t\tgrpc.MaxRecvMsgSize(s.bufferSize),\n\t\tgrpc.MaxSendMsgSize(s.bufferSize),\n\t}\n\n\t// TLS setup if configured\n\tvar optsTLS []grpc.ServerOption\n\tif url.TLS != nil {\n\t\tcreds, err := tls.LoadX509KeyPair(url.TLS.CertFile, url.TLS.KeyFile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load TLS credentials: %v\", err)\n\t\t}\n\t\toptsTLS = []grpc.ServerOption{grpc.Creds(insecure.NewCredentials())}\n\t} else {\n\t\toptsTLS = nil\n\t}\n\n\t// OpenTracing integration\n\tif url.OpenTracing != nil {\n\t\t// Initialize tracer\n\t\ttracer, err := opentracing.NewTracer(\n\t\t\topentracing.WithReporter(url.OpenTracing.Reporter),\n\t\t\topentracing.WithSampler(url.OpenTracing.Sampler),\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create tracer: %v\", err)\n\t\t}\n\n\t\t// Set global tracer\n\t\tglobal.SetTracer(tracer)\n\n\t\t// Register middleware\n\t\ts.grpcServer.WrappedServer = opentracing.WrapServer(s.grpcServer, func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\t\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"server\")\n\t\t\tspan.SetTag(\"component\", \"server\")\n\t\t\tspan.SetTag(\"service\", \"my-service\")\n\t\t\tspan.SetTag(\"method\", \"my-method\")\n\n\t\t\t// Extract peer information\n\t\t\tpeer, _ := peer.FromContext(ctx)\n\t\t\tif peer != nil {\n\t\t\t\tspan.SetTag(\"peer.address\", peer.Addr.String())\n\t\t\t}\n\n\t\t\t// Process request\n\t\t\tresult, err := s.grpcServer.ServeRPC(ctx, req)\n\t\t\tif err != nil {\n\t\t\t\tspan.LogKV(\"error\", err.Error())\n\t\t\t\tspan.SetStatus(3, err.Error())\n\t\t\t} else {\n\t\t\t\tspan.LogKV(\"result\", result)\n\t\t\t}\n\n\t\t\tspan.Finish()\n\t\t\treturn result, err\n\t\t})\n\t} else {\n\t\t// No OpenTracing, use noop tracer\n\t\tglobal.SetTracer(noop.NewTracer())\n\t}\n\n\t// Register services\n\t// Add your service registrations here\n\n\t// Enable server reflection\n\treflection.Register(s.grpcServer)\n\n\t// Start server\n\ts.grpcServer.Serve(listener, opts...)\n}\n\nfunc (s *Server) Stop() {\n\ts.grpcServer.Stop()\n}\n\nfunc (s *Server) GracefulStop() {\n\ts.grpcServer.GracefulStop()\n}"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server to handle incoming requests on a specified network address.\n\nFunction Description: The function `startServer` sets up a gRPC server that listens on the provided TCP address. It creates a new gRPC server instance, registers the Echo service implementation, and begins serving requests. If any step fails, it logs the error and terminates the program.\n\nInput: \n- `addr` [string] - The network address (including port) on which the gRPC server should listen (e.g., \"localhost:50051\").\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error).",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc startServer(addr string) {\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterEchoServer(s, &ecServer{addr: addr})\n\tlog.Printf(\"serving on %s\\n\", addr)\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n)\n\n// EchoService is a placeholder for the actual Echo service implementation.\ntype EchoService struct{}\n\n// Echo is a placeholder method for the Echo service.\nfunc (s *EchoService) Echo(ctx interface{}) {\n\t// Implement the actual echo logic here.\n\tlog.Println(\"Echo request received\")\n}\n\n// startServer initializes and starts a gRPC server on the specified address.\nfunc startServer(addr string) {\n\t// Create a new gRPC server\n\tserver := grpc.NewServer()\n\n\t// Register the Echo service with the server\n\tEchoService := &EchoService{}\n\tgrpc.RegisterEchoServiceServer(server, EchoService)\n\n\t// Set up the listener\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Start the server\n\tlog.Printf(\"Server listening at %v\", addr)\n\tif err := server.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Create a mock CSI (Container Storage Interface) provider server in Go that implements the gRPC interface for a secrets store CSI driver. This server should be able to simulate both successful and error responses for testing purposes.\n\nStruct Description: The MockCSIProviderServer struct represents a mock implementation of a CSI provider server that communicates via gRPC over a Unix domain socket. It allows configuration of mock responses and error conditions for testing the CSI driver integration.\n\nFields:\n- grpcServer: *grpc.Server - The gRPC server instance\n- listener: net.Listener - The network listener for the gRPC server\n- socketPath: string - The filesystem path for the Unix domain socket\n- returnErr: error - An error to return for simulated error conditions\n- errorCode: string - The error code to include in responses\n- objects: []*v1alpha1.ObjectVersion - Mock object versions to return\n- files: []*v1alpha1.File - Mock files to return\n\nMethods:\n- NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) - Creates a new mock server instance with the given socket path\n- SetReturnError(err error) - Sets an error to be returned by the mock server\n- SetObjects(objects map[string]string) - Configures mock object versions to return\n- SetFiles(files []*v1alpha1.File) - Configures mock files to return\n- SetProviderErrorCode(errorCode string) - Sets the error code for responses\n- Start() error - Starts the gRPC server listening on the configured socket\n- Stop() - Gracefully stops the gRPC server\n- Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) - Implements the Mount gRPC method\n- Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) - Implements the Version gRPC method",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"sigs.k8s.io/secrets-store-csi-driver/provider/v1alpha1\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype MockCSIProviderServer struct {\n\tgrpcServer *grpc.Server\n\tlistener   net.Listener\n\tsocketPath string\n\treturnErr  error\n\terrorCode  string\n\tobjects    []*v1alpha1.ObjectVersion\n\tfiles      []*v1alpha1.File\n}\n\nfunc NewMocKCSIProviderServer(socketPath string) (*MockCSIProviderServer, error) {\n\tserver := grpc.NewServer()\n\ts := &MockCSIProviderServer{\n\t\tgrpcServer: server,\n\t\tsocketPath: socketPath,\n\t}\n\tv1alpha1.RegisterCSIDriverProviderServer(server, s)\n\treturn s, nil\n}\n\nfunc (m *MockCSIProviderServer) SetReturnError(err error) {\n\tm.returnErr = err\n}\n\nfunc (m *MockCSIProviderServer) SetObjects(objects map[string]string) {\n\tvar ov []*v1alpha1.ObjectVersion\n\tfor k, v := range objects {\n\t\tov = append(ov, &v1alpha1.ObjectVersion{Id: k, Version: v})\n\t}\n\tm.objects = ov\n}\n\nfunc (m *MockCSIProviderServer) SetFiles(files []*v1alpha1.File) {\n\tvar ov []*v1alpha1.File\n\tfor _, v := range files {\n\t\tov = append(ov, &v1alpha1.File{\n\t\t\tPath:     v.Path,\n\t\t\tMode:     v.Mode,\n\t\t\tContents: v.Contents,\n\t\t})\n\t}\n\tm.files = ov\n}\n\nfunc (m *MockCSIProviderServer) SetProviderErrorCode(errorCode string) {\n\tm.errorCode = errorCode\n}\n\nfunc (m *MockCSIProviderServer) Start() error {\n\tvar err error\n\tm.listener, err = net.Listen(\"unix\", m.socketPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err = m.grpcServer.Serve(m.listener); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (m *MockCSIProviderServer) Stop() {\n\tm.grpcServer.GracefulStop()\n}\n\nfunc (m *MockCSIProviderServer) Mount(ctx context.Context, req *v1alpha1.MountRequest) (*v1alpha1.MountResponse, error) {\n\tvar attrib, secret map[string]string\n\tvar filePermission os.FileMode\n\tvar err error\n\n\tif m.returnErr != nil {\n\t\treturn &v1alpha1.MountResponse{}, m.returnErr\n\t}\n\tif err = json.Unmarshal([]byte(req.GetAttributes()), &attrib); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal attributes, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetSecrets()), &secret); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal secrets, error: %w\", err)\n\t}\n\tif err = json.Unmarshal([]byte(req.GetPermission()), &filePermission); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal file permission, error: %w\", err)\n\t}\n\treturn &v1alpha1.MountResponse{\n\t\tObjectVersion: m.objects,\n\t\tError: &v1alpha1.Error{\n\t\t\tCode: m.errorCode,\n\t\t},\n\t\tFiles: m.files,\n\t}, nil\n}\n\nfunc (m *MockCSIProviderServer) Version(ctx context.Context, req *v1alpha1.VersionRequest) (*v1alpha1.VersionResponse, error) {\n\treturn &v1alpha1.VersionResponse{\n\t\tVersion:        \"v1alpha1\",\n\t\tRuntimeName:    \"fakeprovider\",\n\t\tRuntimeVersion: \"0.0.10\",\n\t}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\n\t\"google.golang.org/grpc\"\n\t\"k8s.io/client-go/util/flowcontrol\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/certificates\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/handler\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/handler/adapter\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/registration\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/scheme\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/tracing\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/finalizer\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/metrics\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/redirect\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/secureport\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/ssl\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/timeout\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/transport\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/validator\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\"\n\t\"sigs.k8s.io/controller-runtime/pkg/webhook/webhookserver/webhookserver\""
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a function to push metrics to a Prometheus push gateway using HTTP requests with custom headers and client configuration.\n\nFunction Description: The function `doPush` sends collected metrics to a Prometheus push gateway. It validates the job name and grouping labels, constructs the appropriate URL, encodes the metrics in Protocol Buffer format, and makes an HTTP request with custom headers. It handles errors during the process and checks the response status.\n\nInput:\n- `job` (string): The job name to associate with the pushed metrics\n- `grouping` (map[string]string): Key-value pairs for metric grouping\n- `pushURL` (string): The base URL of the Prometheus push gateway\n- `g` (prometheus.Gatherer): Interface to gather metrics\n- `method` (string): HTTP method to use for the request (e.g., \"POST\")\n\nOutput:\n- `error`: Returns nil on success, or an error describing any failure during the push operation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/common/model\"\n)\n\nconst contentTypeHeader = \"Content-Type\"\n\nvar (\n\tclient         = &http.Client{}\n\tdefaultTimeout = time.Second * 15\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif !strings.Contains(pushURL, \"://\") {\n\t\tpushURL = \"http://\" + pushURL\n\t}\n\tif strings.HasSuffix(pushURL, \"/\") {\n\t\tpushURL = pushURL[:len(pushURL)-1]\n\t}\n\n\tif strings.Contains(job, \"/\") {\n\t\treturn fmt.Errorf(\"job contains '/': %s\", job)\n\t}\n\turlComponents := []string{url.QueryEscape(job)}\n\tfor ln, lv := range grouping {\n\t\tif !model.LabelName(ln).IsValid() {\n\t\t\treturn fmt.Errorf(\"grouping label has invalid name: %s\", ln)\n\t\t}\n\t\tif strings.Contains(lv, \"/\") {\n\t\t\treturn fmt.Errorf(\"value of grouping label %s contains '/': %s\", ln, lv)\n\t\t}\n\t\turlComponents = append(urlComponents, ln, lv)\n\t}\n\tpushURL = fmt.Sprintf(\"%s/metrics/job/%s\", pushURL, strings.Join(urlComponents, \"/\"))\n\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtProtoDelim)\n\tfor _, mf := range mfs {\n\t\tfor _, m := range mf.GetMetric() {\n\t\t\tfor _, l := range m.GetLabel() {\n\t\t\t\tif l.GetName() == \"job\" {\n\t\t\t\t\treturn fmt.Errorf(\"pushed metric %s (%s) already contains a job label\", mf.GetName(), m)\n\t\t\t\t}\n\t\t\t\tif _, ok := grouping[l.GetName()]; ok {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"pushed metric %s (%s) already contains grouping label %s\",\n\t\t\t\t\t\tmf.GetName(), m, l.GetName(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenc.Encode(mf)\n\t}\n\treq, err := http.NewRequest(method, pushURL, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(contentTypeHeader, string(expfmt.FmtProtoDelim))\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 202 {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code %d while pushing to %s: %s\", resp.StatusCode, pushURL, body)\n\t}\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif job == \"\" {\n\t\treturn errors.New(\"job name is required\")\n\t}\n\n\tif grouping == nil {\n\t\tgrouping = make(map[string]string)\n\t}\n\n\turl := pushURL + \"/metrics/job/\" + urlEncode(job) + \"/grouping/\" + urlEncode(groupingString(grouping))\n\n\tmetrics, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar payload []byte\n\tif len(metrics) > 0 {\n\t\tvar pb []byte\n\t\tfor _, m := range metrics {\n\t\t\tpb = append(pb, m.String()...)\n\t\t}\n\t\tpayload = pb\n\t} else {\n\t\treturn errors.New(\"no metrics to push\")\n\t}\n\n\tgz := gzip.NewWriter(bytes.NewBuffer(payload))\n\tif err := gz.Write(payload); err != nil {\n\t\treturn err\n\t}\n\tgz.Close()\n\n\treq, err := http.NewRequest(method, url, bytes.NewReader(payload))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\treq.Header.Set(\"Content-Encoding\", \"gzip\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"push failed with status code %d: %s\", resp.StatusCode, string(body))\n\t}\n\n\treturn nil\n}\n\nfunc urlEncode(s string) string {\n\treturn strings.ReplaceAll(s, \"+\", \"%20\")\n}\n\nfunc groupingString(g map[string]string) string {\n\tvar sb strings.Builder\n\tfor k, v := range g {\n\t\tsb.WriteString(k + \"=\" + v + \",\")\n\t}\n\treturn sb.String()\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles graceful shutdown.\n\nStruct Description: The Plumber struct represents a gRPC server instance with configuration options, logging, and shutdown capabilities.\n\nFields:\n- Config: *options.Config - Configuration settings for the server\n- CLIOptions: *options.CLIOptions - Command line interface options\n- PersistentConfig: *options.PersistentConfig - Persistent configuration settings\n- Actions: *actions.Actions - Server actions and operations\n- Bus: bus.IBus - Message bus interface\n- ServiceShutdownCtx: context.Context - Context for shutdown signaling\n- log: *logrus.Entry - Logger instance\n\nMethods:\n- startGRPCServer: () -> error - Starts the gRPC server and listens for incoming requests\n- watchServiceShutdown: (*grpc.Server) -> () - Monitors for shutdown signals and stops the gRPC server gracefully",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/batchcorp/plumber-schemas/build/go/protos\"\n\t\"github.com/streamdal/plumber/server\"\n)\n\ntype Plumber struct {\n\tConfig               *options.Config\n\tCLIOptions           *options.CLIOptions\n\tPersistentConfig     *options.PersistentConfig\n\tActions              *actions.Actions\n\tBus                  bus.IBus\n\tServiceShutdownCtx   context.Context\n\tlog                  *logrus.Entry\n}\n\nfunc (p *Plumber) startGRPCServer() error {\n\tlis, err := net.Listen(\"tcp\", p.CLIOptions.Server.GrpcListenAddress)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to listen on '%s': %s\", p.CLIOptions.Server.GrpcListenAddress, err)\n\t}\n\n\tvar opts []grpc.ServerOption\n\n\tgrpcServer := grpc.NewServer(opts...)\n\n\tp.PersistentConfig.ClusterID = p.CLIOptions.Server.ClusterId\n\n\tplumberServer := &server.Server{\n\t\tActions:          p.Actions,\n\t\tPersistentConfig: p.PersistentConfig,\n\t\tAuthToken:        p.CLIOptions.Server.AuthToken,\n\t\tBus:              p.Bus,\n\t\tLog:              logrus.WithField(\"pkg\", \"plumber/cli_server.go\"),\n\t\tCLIOptions:       p.CLIOptions,\n\t}\n\n\tprotos.RegisterPlumberServerServer(grpcServer, plumberServer)\n\n\tgo p.watchServiceShutdown(grpcServer)\n\n\tp.log.Debugf(\"starting gRPC server on %s\", p.CLIOptions.Server.GrpcListenAddress)\n\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\terrCh <- errors.Wrap(err, \"unable to start gRPC server\")\n\t\t}\n\t}()\n\n\tafterCh := time.After(5 * time.Second)\n\n\tselect {\n\tcase <-afterCh:\n\t\treturn nil\n\tcase err := <-errCh:\n\t\treturn err\n\t}\n}\n\nfunc (p *Plumber) watchServiceShutdown(grpcServer *grpc.Server) {\n\t<-p.ServiceShutdownCtx.Done()\n\n\tp.log.Debug(\"received shutdown request in gRPC server via ServiceShutdownCtx\")\n\n\ttime.Sleep(5 * time.Second)\n\n\tgrpcServer.Stop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype Plumber struct {\n\tConfig           *options.Config\n\tCLIOptions       *options.CLIOptions\n\tPersistentConfig *options.PersistentConfig\n\tActions          *actions.Actions\n\tBus              bus.IBus\n\tServiceShutdownCtx context.Context\n\tlog              *logrus.Entry\n}\n\nfunc (p *Plumber) startGRPCServer() error {\n\t// Create a new gRPC server\n\tserver := grpc.NewServer()\n\n\t// Register your service handlers here\n\n\t// Listen on the provided address\n\tlistener, err := net.Listen(\"tcp\", p.Config.GRPCAddress)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Start the server\n\tgo func() {\n\t\tif err := server.Serve(listener, func(s *grpc.Server) {\n\t\t\t// Register services with the server\n\t\t}); err != nil {\n\t\t\tp.log.Errorf(\"Failed to serve: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}()\n\n\t// Watch for shutdown signals\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Wait for shutdown signal\n\t<-quit\n\n\t// Stop the server gracefully\n\tp.log.Info(\"Shutting down gRPC server...\")\n\tserver.GracefulStop()\n\ttime.Sleep(5 * time.Second)\n\n\treturn nil\n}\n\nfunc (p *Plumber) watchServiceShutdown(server *grpc.Server) {\n\t// Monitor for shutdown signals and stop the server gracefully\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\t<-quit\n\n\tp.log.Info(\"Received shutdown signal, stopping gRPC server...\")\n\tserver.GracefulStop()\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both unary and bidirectional streaming RPCs for an echo service, with TLS security.\n\nStruct Description: The server struct implements the EchoServer interface generated from the protobuf definition, providing echo functionality for both unary and streaming RPCs.\n\nFields:\n- UnimplementedEchoServer: pb.UnimplementedEchoServer - Embedded type to ensure forward compatibility\n\nMethods:\n- UnaryEcho: (context.Context, *pb.EchoRequest) -> (*pb.EchoResponse, error) - Handles unary RPC calls by echoing back the received message\n- BidirectionalStreamingEcho: (pb.Echo_BidirectionalStreamingEchoServer) -> error - Handles bidirectional streaming by continuously receiving messages and echoing them back until the stream ends\n\nInput: None (The struct itself doesn't take input parameters, but its methods do as described above)\n\nOutput: None (The struct doesn't return anything directly, but its methods return values as described above)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/examples/data\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(_ context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tfmt.Printf(\"unary echoing message %q\\n\", in.Message)\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tin, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfmt.Printf(\"server: error receiving from stream: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"bidi echoing message %q\\n\", in.Message)\n\t\tstream.Send(&pb.EchoResponse{Message: in.Message})\n\t}\n}\n\nfunc main() {\n\tport := flag.Int(\"port\", 50051, \"the port to serve on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tcreds, err := credentials.NewServerTLSFromFile(data.Path(\"x509/server_cert.pem\"), data.Path(\"x509/server_key.pem\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create credentials: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"echo/proto\"\n)\n\ntype server struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *server) UnaryEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) {\n\tlog.Printf(\"Unary Echo: %s\", in.Message)\n\treturn &pb.EchoResponse{Message: in.Message}, nil\n}\n\nfunc (s *server) BidirectionalStreamingEcho(stream pb.Echo_BidirectionalStreamingEchoServer) error {\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlog.Printf(\"Bidirectional Streaming Echo: %s\", msg.Message)\n\t\tif err = stream.Send(&pb.EchoResponse{Message: msg.Message}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\t// TLS configuration\n\ttlsConfig, err := tls.NewServerConfig(&tls.Config{\n\t\tMinVersion: tls.VersionTLS12,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create TLS config: %v\", err)\n\t}\n\n\t// Keepalive parameters\n\tkaParams := keepalive.ServerParameters{\n\t\tMaxConnectionIdle: 30 * time.Second,\n\t\tMaxConnectionAge:  1 * time.Minute,\n\t}\n\n\t// Create gRPC server\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.Creds(tls.NewServerCredentials(tlsConfig)),\n\t\tgrpc.KeepaliveParams(kaParams.MaxConnectionIdle),\n\t)\n\n\t// Register the server\n\tpb.RegisterEchoServer(grpcServer, &server{})\n\n\t// Start the server\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Println(\"gRPC server is running on port 50051\")\n\tif err := grpcServer.Serve(lis, nil); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a gRPC service struct in Go that manages a gRPC server for key management operations, including starting the server, graceful shutdown, and immediate termination capabilities.\n\nStruct Description: GRPCService represents a gRPC server wrapper that handles Unix domain socket communication for key management services. It manages server lifecycle and configuration.\n\nFields:\naddr: string - The Unix domain socket address the server will listen on\ntimeout: time.Duration - Connection timeout duration for gRPC connections\nserver: *grpc.Server - The underlying gRPC server instance\nkmsService: Service - The key management service implementation to be registered with gRPC\n\nMethods:\nNewGRPCService(address string, timeout time.Duration, kmsService Service) -> *GRPCService - Constructor that initializes a new GRPCService instance with the given address, timeout and service implementation\nListenAndServe() -> error - Starts the gRPC server on the configured Unix domain socket address and begins serving requests\nShutdown() -> void - Gracefully stops the gRPC server, allowing existing connections to complete\nClose() -> void - Immediately stops the gRPC server without waiting for connections to complete",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tkmsapi \"k8s.io/kms/apis/v2\"\n)\n\ntype GRPCService struct {\n\taddr    string\n\ttimeout time.Duration\n\tserver  *grpc.Server\n\n\tkmsService Service\n}\n\nfunc NewGRPCService(\n\taddress string,\n\ttimeout time.Duration,\n\tkmsService Service,\n) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tln, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\n\tgs := grpc.NewServer(\n\t\tgrpc.ConnectionTimeout(s.timeout),\n\t)\n\ts.server = gs\n\n\tkmsapi.RegisterKeyManagementServiceServer(gs, s)\n\n\treturn gs.Serve(ln)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tif s.server != nil {\n\t\ts.server.GracefulStop()\n\t}\n}\n\nfunc (s *GRPCService) Close() {\n\tif s.server != nil {\n\t\ts.server.Stop()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Service interface {\n\t// Define service methods as needed\n}\n\ntype GRPCService struct {\n\taddr      string\n\ttimeout   time.Duration\n\tserver    *grpc.Server\n\tkmsService Service\n}\n\nfunc NewGRPCService(address string, timeout time.Duration, kmsService Service) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:      address,\n\t\ttimeout:   timeout,\n\t\tserver:    grpc.NewServer(),\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tlis, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer lis.Close()\n\n\ts.server.RegisterService(s.kmsService, nil)\n\t\n\tgo func() {\n\t\tif err := s.server.Serve(lis, func(server *grpc.Server) {\n\t\t\t// Register service handlers here\n\t\t}); err != nil {\n\t\t\tfmt.Printf(\"Server closed: %v\\n\", err)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tctx, cancel := context.WithTimeout(context.Background(), s.timeout)\n\tdefer cancel()\n\t\n\tif err := s.server.GracefulStop(); err != nil {\n\t\tfmt.Printf(\"Graceful stop failed: %v\\n\", err)\n\t}\n}\n\nfunc (s *GRPCService) Close() {\n\tif err := s.server.Stop(); err != nil {\n\t\tfmt.Printf(\"Stop failed: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a gRPC server configuration and management system in Go that handles server setup, TLS configuration, client credentials, and network listeners with support for both buffered and regular network connections.\n\nStruct Description: GRPCServerConfig represents a configuration for setting up a gRPC server with various options including network settings, TLS configuration, and connection parameters.\n\nFields:\n- Address: string - The network address to listen on\n- Network: string - The network type (e.g., \"tcp\", \"unix\", or \"buffered\")\n- TLSCertPath: string - Path to TLS certificate file\n- TLSKeyPath: string - Path to TLS private key file\n- MaxConnAge: time.Duration - Maximum connection age before termination\n- Enabled: bool - Whether the server is enabled\n- BufferSize: int - Size of buffer for buffered connections\n- ClientCAPath: string - Path to client CA certificate file\n- MaxWorkers: uint32 - Maximum number of stream workers\n- flagPrefix: string - Prefix for configuration flags\n\nMethods:\n- Complete: (level zerolog.Level, svcRegistrationFn func(*grpc.Server), opts ...grpc.ServerOption) -> (RunnableGRPCServer, error) - Completes the configuration and returns a runnable server instance\n- listenerAndDialer: () -> (net.Listener, DialFunc, NetDialFunc, error) - Creates a network listener and dialer functions based on configuration\n- tlsOpts: () -> ([]grpc.ServerOption, *certwatcher.CertWatcher, error) - Generates TLS server options based on certificate configuration\n- clientCreds: () -> (credentials.TransportCredentials, error) - Creates client transport credentials based on TLS configuration\n\nStruct Description: completedGRPCServer represents a fully configured and runnable gRPC server instance.\n\nFields:\n- opts: []grpc.ServerOption - Server options\n- listener: net.Listener - Network listener\n- svcRegistrationFn: func(*grpc.Server) - Service registration function\n- listenFunc: func() error - Function to start listening\n- prestopFunc: func() - Function to run before stopping\n- stopFunc: func() - Function to stop the server\n- dial: func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error) - Dial function for clients\n- netDial: func(context.Context, string) (net.Conn, error) - Raw network dial function\n- creds: credentials.TransportCredentials - Client transport credentials\n- certWatcher: *certwatcher.CertWatcher - Certificate watcher for TLS\n\nMethods:\n- WithOpts: (...grpc.ServerOption) -> RunnableGRPCServer - Adds additional server options\n- Listen: (context.Context) -> func() error - Starts the server and returns a listen function\n- DialContext: (context.Context, ...grpc.DialOption) -> (*grpc.ClientConn, error) - Creates a client connection\n- NetDialContext: (context.Context, string) -> (net.Conn, error) - Creates a raw network connection\n- Insecure: () -> bool - Returns whether the connection is insecure\n- GracefulStop: () - Stops the server gracefully",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/test/bufconn\"\n\n\t\"sigs.k8s.io/controller-runtime/pkg/certwatcher\"\n\n\t\"github.com/authzed/spicedb/internal/grpchelpers\"\n\t\"github.com/authzed/spicedb/pkg/x509util\"\n)\n\ntype GRPCServerConfig struct {\n\tAddress      string\n\tNetwork      string\n\tTLSCertPath  string\n\tTLSKeyPath   string\n\tMaxConnAge   time.Duration\n\tEnabled      bool\n\tBufferSize   int\n\tClientCAPath string\n\tMaxWorkers   uint32\n\n\tflagPrefix string\n}\n\nfunc (c *GRPCServerConfig) Complete(level zerolog.Level, svcRegistrationFn func(server *grpc.Server), opts ...grpc.ServerOption) (RunnableGRPCServer, error) {\n\tif !c.Enabled {\n\t\treturn &disabledGrpcServer{}, nil\n\t}\n\tif c.BufferSize == 0 {\n\t\tc.BufferSize = 1024 * 1024\n\t}\n\topts = append(opts, grpc.KeepaliveParams(keepalive.ServerParameters{\n\t\tMaxConnectionAge: c.MaxConnAge,\n\t}), grpc.NumStreamWorkers(c.MaxWorkers))\n\n\ttlsOpts, certWatcher, err := c.tlsOpts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts = append(opts, tlsOpts...)\n\n\tclientCreds, err := c.clientCreds()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl, dial, netDial, err := c.listenerAndDialer()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen on addr for gRPC server: %w\", err)\n\t}\n\n\tsrv := grpc.NewServer(opts...)\n\tsvcRegistrationFn(srv)\n\treturn &completedGRPCServer{\n\t\topts:              opts,\n\t\tlistener:          l,\n\t\tsvcRegistrationFn: svcRegistrationFn,\n\t\tlistenFunc: func() error {\n\t\t\treturn srv.Serve(l)\n\t\t},\n\t\tdial:    dial,\n\t\tnetDial: netDial,\n\t\tprestopFunc: func() {\n\t\t},\n\t\tstopFunc:    srv.GracefulStop,\n\t\tcreds:       clientCreds,\n\t\tcertWatcher: certWatcher,\n\t}, nil\n}\n\nfunc (c *GRPCServerConfig) listenerAndDialer() (net.Listener, DialFunc, NetDialFunc, error) {\n\tif c.Network == BufferedNetwork {\n\t\tbl := bufconn.Listen(c.BufferSize)\n\t\treturn bl, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\t\topts = append(opts, grpc.WithContextDialer(func(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\t\treturn bl.DialContext(ctx)\n\t\t\t\t}))\n\n\t\t\t\treturn grpchelpers.Dial(ctx, BufferedNetwork, opts...)\n\t\t\t}, func(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\treturn bl.DialContext(ctx)\n\t\t\t}, nil\n\t}\n\tl, err := net.Listen(c.Network, c.Address)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn l, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\treturn grpchelpers.Dial(ctx, c.Address, opts...)\n\t}, nil, nil\n}\n\nfunc (c *GRPCServerConfig) tlsOpts() ([]grpc.ServerOption, *certwatcher.CertWatcher, error) {\n\tswitch {\n\tcase c.TLSCertPath == \"\" && c.TLSKeyPath == \"\":\n\t\treturn nil, nil, nil\n\tcase c.TLSCertPath != \"\" && c.TLSKeyPath != \"\":\n\t\twatcher, err := certwatcher.New(c.TLSCertPath, c.TLSKeyPath)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tcreds := credentials.NewTLS(&tls.Config{\n\t\t\tGetCertificate: watcher.GetCertificate,\n\t\t\tMinVersion:     tls.VersionTLS12,\n\t\t})\n\t\treturn []grpc.ServerOption{grpc.Creds(creds)}, watcher, nil\n\tdefault:\n\t\treturn nil, nil, nil\n\t}\n}\n\nfunc (c *GRPCServerConfig) clientCreds() (credentials.TransportCredentials, error) {\n\tswitch {\n\tcase c.TLSCertPath == \"\" && c.TLSKeyPath == \"\":\n\t\treturn insecure.NewCredentials(), nil\n\tcase c.TLSCertPath != \"\" && c.TLSKeyPath != \"\":\n\t\tvar err error\n\t\tvar pool *x509.CertPool\n\t\tif c.ClientCAPath != \"\" {\n\t\t\tpool, err = x509util.CustomCertPool(c.ClientCAPath)\n\t\t} else {\n\t\t\tpool, err = x509.SystemCertPool()\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn credentials.NewTLS(&tls.Config{RootCAs: pool, MinVersion: tls.VersionTLS12}), nil\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\ntype completedGRPCServer struct {\n\topts              []grpc.ServerOption\n\tlistener          net.Listener\n\tsvcRegistrationFn func(*grpc.Server)\n\tlistenFunc        func() error\n\tprestopFunc       func()\n\tstopFunc          func()\n\tdial              func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error)\n\tnetDial           func(ctx context.Context, s string) (net.Conn, error)\n\tcreds             credentials.TransportCredentials\n\tcertWatcher       *certwatcher.CertWatcher\n}\n\nfunc (c *completedGRPCServer) WithOpts(opts ...grpc.ServerOption) RunnableGRPCServer {\n\tc.opts = append(c.opts, opts...)\n\tsrv := grpc.NewServer(c.opts...)\n\tc.svcRegistrationFn(srv)\n\tc.listenFunc = func() error {\n\t\treturn srv.Serve(c.listener)\n\t}\n\tc.stopFunc = srv.GracefulStop\n\treturn c\n}\n\nfunc (c *completedGRPCServer) Listen(ctx context.Context) func() error {\n\tif c.certWatcher != nil {\n\t\tgo func() {\n\t\t\tif err := c.certWatcher.Start(ctx); err != nil {\n\t\t\t}\n\t\t}()\n\t}\n\treturn c.listenFunc\n}\n\nfunc (c *completedGRPCServer) DialContext(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\topts = append(opts, grpc.WithTransportCredentials(c.creds))\n\treturn c.dial(ctx, opts...)\n}\n\nfunc (c *completedGRPCServer) NetDialContext(ctx context.Context, s string) (net.Conn, error) {\n\treturn c.netDial(ctx, s)\n}\n\nfunc (c *completedGRPCServer) Insecure() bool {\n\treturn c.creds.Info().SecurityProtocol == \"insecure\"\n}\n\nfunc (c *completedGRPCServer) GracefulStop() {\n\tc.prestopFunc()\n\tc.stopFunc()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/rs/certwatcher\"\n\tzerolog \"github.com/rs/zerolog\"\n)\n\ntype GRPCServerConfig struct {\n\tAddress         string\n\tNetwork         string\n\tTLSCertPath     string\n\tTLSKeyPath      string\n\tMaxConnAge      time.Duration\n\tEnabled         bool\n\tBufferSize      int\n\tClientCAPath    string\n\tMaxWorkers      uint32\n\tflagPrefix      string\n}\n\nfunc (c *GRPCServerConfig) Complete(level zerolog.Level, svcRegistrationFn func(*grpc.Server), opts ...grpc.ServerOption) (RunnableGRPCServer, error) {\n\tlistener, dialFunc, netDialFunc, err := c.listenerAndDialer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttlsOpts, certWatcher, err := c.tlsOpts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreds, err := c.clientCreds()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\topts = append(opts, tlsOpts...)\n\tgrpcServer := grpc.NewServer(opts...)\n\tsvcRegistrationFn(grpcServer)\n\n\treturn &completedGRPCServer{\n\t\topts:           opts,\n\t\tlistener:       listener,\n\t\tsvcRegistrationFn: svcRegistrationFn,\n\t\tlistenFunc: func() error {\n\t\t\treturn grpcServer.Serve(listener)\n\t\t},\n\t\tprestopFunc: func() {\n\t\t\tgrpcServer.GracefulStop()\n\t\t},\n\t\tstopFunc: func() {\n\t\t\tgrpcServer.Stop()\n\t\t},\n\t\tdial: func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\treturn dialFunc(ctx, opts...)\n\t\t},\n\t\tnetDial: func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn netDialFunc(ctx, addr)\n\t\t},\n\t\tcreds:        creds,\n\t\tcertWatcher:  certWatcher,\n\t}, nil\n}\n\nfunc (c *GRPCServerConfig) listenerAndDialer() (net.Listener, DialFunc, NetDialFunc, error) {\n\tswitch c.Network {\n\tcase \"tcp\":\n\t\tlistener, err := net.Listen(\"tcp\", c.Address)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\treturn listener, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\treturn grpc.Dial(c.Address, opts...)\n\t\t}, func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"tcp\", addr)\n\t\t}, nil\n\tcase \"unix\":\n\t\tlistener, err := net.Listen(\"unix\", c.Address)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\treturn listener, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\treturn grpc.Dial(c.Address, opts...)\n\t\t}, func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", addr)\n\t\t}, nil\n\tcase \"buffered\":\n\t\tlistener, err := net.Listen(\"tcp\", c.Address)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\treturn listener, func(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\t\t\treturn grpc.Dial(c.Address, opts...)\n\t\t}, func(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"tcp\", addr)\n\t\t}, nil\n\tdefault:\n\t\treturn nil, nil, nil, fmt.Errorf(\"unsupported network type: %s\", c.Network)\n\t}\n}\n\nfunc (c *GRPCServerConfig) tlsOpts() ([]grpc.ServerOption, *certwatcher.CertWatcher, error) {\n\tvar opts []grpc.ServerOption\n\tvar certWatcher *certwatcher.CertWatcher\n\n\tif c.TLSCertPath != \"\" && c.TLSKeyPath != \"\" {\n\t\tcreds, err := credentials.NewServerTLSStreamCredentials([]byte(c.TLSKeyPath), []byte(c.TLSCertPath))\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t\tcertWatcher, err = certwatcher.New(c.TLSCertPath, c.TLSKeyPath)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\treturn opts, certWatcher, nil\n}\n\nfunc (c *GRPCServerConfig) clientCreds() (credentials.TransportCredentials, error) {\n\tif c.TLSCertPath != \"\" && c.TLSKeyPath != \"\" {\n\t\tcreds, err := credentials.NewClientTLSFromCertPool([]byte(c.TLSCertPath))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn creds, nil\n\t}\n\treturn credentials.Insecure(), nil\n}\n\ntype completedGRPCServer struct {\n\topts           []grpc.ServerOption\n\tlistener       net.Listener\n\tsvcRegistrationFn func(*grpc.Server)\n\tlistenFunc     func() error\n\tprestopFunc   func()\n\tstopFunc      func()\n\tdial          func(context.Context, ...grpc.DialOption) (*grpc.ClientConn, error)\n\tnetDial       func(context.Context, string) (net.Conn, error)\n\tcreds         credentials.TransportCredentials\n\tcertWatcher   *certwatcher.CertWatcher\n}\n\nfunc (s *completedGRPCServer) WithOpts(opts ...grpc.ServerOption) RunnableGRPCServer {\n\tnewOpts := append(s.opts, opts...)\n\treturn &completedGRPCServer{\n\t\topts:           newOpts,\n\t\tlistener:       s.listener,\n\t\tsvcRegistrationFn: s.svcRegistrationFn,\n\t\tlistenFunc:     s.listenFunc,\n\t\tprestopFunc:   s.prestopFunc,\n\t\tstopFunc:      s.stopFunc,\n\t\tdial:          s.dial,\n\t\tnetDial:       s.netDial,\n\t\tcreds:         s.creds,\n\t\tcertWatcher:   s.certWatcher,\n\t}\n}\n\nfunc (s *completedGRPCServer) Listen(ctx context.Context) func() error {\n\treturn s.listenFunc\n}\n\nfunc (s *completedGRPCServer) DialContext(ctx context.Context, opts ...grpc.DialOption) (*grpc.ClientConn, error) {\n\treturn s.dial(ctx, opts...)\n}\n\nfunc (s *completedGRPCServer) NetDialContext(ctx context.Context, addr string) (net.Conn, error) {\n\treturn s.netDial(ctx, addr)\n}\n\nfunc (s *completedGRPCServer) Insecure() bool {\n\treturn s.creds == credentials.Insecure()\n}\n\nfunc (s *completedGRPCServer) GracefulStop() {\n\ts.prestopFunc()\n\ts.stopFunc()\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It includes base URLs, user agent, rate limiting capabilities, and various service clients for different API endpoints.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe rate limiting\nrateLimits: [categories]Rate - Rate limit tracking for different categories\ncommon: service - Shared service implementation\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support and handles response decoding",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype Response struct {\n\tStatusCode int\n\tBody       string\n}\n\ntype Rate struct {\n\tRemaining int\n\tReset     time.Time\n}\n\ntype Client struct {\n\tclientMu  sync.Mutex\n\tclient    *http.Client\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\trateMu    sync.Mutex\n\trateLimits [2]Rate\n\tcommon    *service\n}\n\ntype service struct{}\n\nfunc NewClient(client *http.Client) *Client {\n\treturn &Client{\n\t\tclient:    client,\n\t\tBaseURL:   &url.URL{},\n\t\tUploadURL: &url.URL{},\n\t\tUserAgent: \"MyApp/1.0\",\n\t}\n}\n\nfunc (c *Client) NewRequest(method string, urlStr string, body interface{}) (*http.Request, error) {\n\turl, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(method, url.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\tif body != nil {\n\t\treq.Body = http.NewBuffer(body)\n\t}\n\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := json.Marshal(resp)\n\treturn &Response{StatusCode: resp.StatusCode, Body: string(body)}, nil\n}\n\nfunc main() {\n\t// Example usage\n\tclient := NewClient(&http.Client{})\n\treq, _ := client.NewRequest(\"GET\", \"https://api.example.com/data\", nil)\n\tresp, _ := client.Do(context.Background(), req, nil)\n\tfmt.Printf(\"Status: %d\\nBody: %s\\n\", resp.StatusCode, resp.Body)\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles log streaming and processing, including batch processing of log events.\n\nStruct Description: The Source struct represents a gRPC server that receives log streams, processes them in batches, and manages the server lifecycle.\n\nFields:\n- name: string - The name identifier for the source\n- eventPool: *event.Pool - Pool for managing event objects\n- config: *Config - Configuration for the source (bind address, port, etc.)\n- grpcServer: *grpc.Server - The gRPC server instance\n- bc: *batchChain - Batch processing chain for handling log events\n\nMethods:\n- ProductLoop: (productFunc api.ProductFunc) -> None - Starts the main processing loop and gRPC server\n  Input: productFunc - Function for processing produced events\n  Output: None (runs indefinitely as goroutine)\n\n- LogStream: (ls pb.LogService_LogStreamServer) -> error - Handles incoming log streams\n  Input: ls - gRPC stream server interface for log messages\n  Output: error - Any error that occurs during stream processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/loggie-io/loggie/pkg/pipeline\"\n\tpb \"github.com/loggie-io/loggie/pkg/sink/grpc/pb\"\n\t\"github.com/loggie-io/loggie/pkg/util/json\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Source struct {\n\tpb.UnimplementedLogServiceServer\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batchChain\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", s.String())\n\ts.bc = newBatchChain(productFunc, s.config.MaintenanceInterval)\n\tgo s.bc.run()\n\tip := fmt.Sprintf(\"%s:%s\", s.config.Bind, s.config.Port)\n\tlistener, err := net.Listen(s.config.Network, ip)\n\tif err != nil {\n\t\tlog.Panic(\"grpc server listen ip(%s) err: %v\", ip, err)\n\t}\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterLogServiceServer(grpcServer, s)\n\tgo grpcServer.Serve(listener)\n\ts.grpcServer = grpcServer\n\tlog.Info(\"grpc server start listing: %s\", ip)\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tb := newBatch(s.config.Timeout)\n\tfor {\n\t\tlogMsg, err := ls.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tsendErr := ls.SendAndClose(&pb.LogResp{\n\t\t\t\tSuccess:  false,\n\t\t\t\tCount:    0,\n\t\t\t\tErrorMsg: err.Error(),\n\t\t\t})\n\t\t\tif sendErr != nil {\n\t\t\t\tlog.Warn(\"send response fail: %s\", sendErr)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\theader := make(map[string]interface{})\n\t\trawHeader := logMsg.GetHeader()\n\t\tif len(rawHeader) > 0 {\n\t\t\tfor k, v := range rawHeader {\n\t\t\t\theader[k] = string(v)\n\t\t\t}\n\t\t}\n\t\tpackedHeader := logMsg.PackedHeader\n\t\tif len(packedHeader) > 0 {\n\t\t\terr = json.Unmarshal(packedHeader, &header)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Unmarshal packedHeader error: %s\", err)\n\t\t\t}\n\t\t}\n\t\te := s.eventPool.Get()\n\t\te.Fill(e.Meta(), header, logMsg.GetRawLog())\n\t\tb.append(e)\n\t}\n\tif b.size() > 0 {\n\t\ts.bc.append(b)\n\t\tlogResp := b.wait()\n\t\terr := ls.SendAndClose(logResp)\n\t\tif err != nil {\n\t\t\tlog.Error(\"send response fail: %s\", err)\n\t\t}\n\t\treturn err\n\t}\n\treturn ls.SendAndClose(&pb.LogResp{\n\t\tSuccess: true,\n\t\tCount:   0,\n\t})\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/proto/file\"\n)\n\ntype Source struct {\n\tname      string\n\teventPool *event.Pool\n\tconfig    *Config\n\tgrpcServer *grpc.Server\n\tbc        *batchChain\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tgo func() {\n\t\tfor {\n\t\t\t// Simulate processing events\n\t\t\tproductFunc()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}()\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tfor {\n\t\t// Simulate receiving log messages\n\t\tlogMsg := &pb.LogMessage{\n\t\t\tMessage: \"Sample log message\",\n\t\t\tTimestamp: time.Now().UnixNano(),\n\t\t}\n\t\tif err := ls.Send(logMsg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\nfunc main() {\n\t// Initialize source\n\tsource := &Source{\n\t\tname: \"log-source\",\n\t\teventPool: &event.Pool{},\n\t\tconfig: &Config{\n\t\t\tBindAddress: \"0.0.0.0\",\n\t\t\tPort: 50051,\n\t\t},\n\t\tgrpcServer: grpc.NewServer(),\n\t\tbc: &batchChain{},\n\t}\n\n\t// Register service\n\tpb.RegisterLogServiceServer(source.grpcServer, source)\n\n\t// Start server\n\tlistener, err := net.Listen(\"tcp\", source.config.BindAddress+\":\"+source.config.Port)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tsource.grpcServer.Serve(listener, nil)\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests, supports optional TLS encryption, and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The Start function initializes and runs a gRPC server with configurable network address and TLS settings. It sets up keepalive parameters, registers the service implementation, and handles OS signals for graceful shutdown.\n\nInput:\n- addr: string - The network address (host:port) to listen on\n- enableTLS: bool - Flag to enable/disable TLS encryption\n- certificate: auth.Certificate - Certificate configuration for TLS (when enabled)\n\nOutput: None (the function runs indefinitely until a termination signal is received)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\tpb \"github.com/ouqiang/gocron/internal/modules/rpc/proto\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\nfunc Start(addr string, enableTLS bool, certificate auth.Certificate) {\n\tl, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\topts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveParams(keepAliveParams),\n\t\tgrpc.KeepaliveEnforcementPolicy(keepAlivePolicy),\n\t}\n\tif enableTLS {\n\t\ttlsConfig, err := certificate.GetTLSConfigForServer()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\topt := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\topts = append(opts, opt)\n\t}\n\tserver := grpc.NewServer(opts...)\n\tpb.RegisterTaskServer(server, Server{})\n\tlog.Infof(\"server listen on %s\", addr)\n\n\tgo func() {\n\t\terr = server.Serve(l)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)\n\tfor {\n\t\ts := <-c\n\t\tlog.Infoln(\"\u6536\u5230\u4fe1\u53f7 -- \", s)\n\t\tswitch s {\n\t\tcase syscall.SIGHUP:\n\t\t\tlog.Infoln(\"\u6536\u5230\u7ec8\u7aef\u65ad\u5f00\u4fe1\u53f7, \u5ffd\u7565\")\n\t\tcase syscall.SIGINT, syscall.SIGTERM:\n\t\t\tlog.Info(\"\u5e94\u7528\u51c6\u5907\u9000\u51fa\")\n\t\t\tserver.GracefulStop()\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/lb/pickers\"\n\t\"google.golang.org/grpc/naming\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/server\"\n\t\"google.golang.org/grpc/health/v1/healthpb\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n}\n\nfunc (s *Server) Start(addr string, enableTLS bool, certificate auth.Certificate) {\n\t// Create a new gRPC server\n\ts.grpcServer = grpc.NewServer(\n\t\tgrpc.UseClientCertificateValidator(true),\n\t\tgrpc.MaxRecvMsgSize(1024*1024*10),\n\t\tgrpc.MaxSendMsgSize(1024*1024*10),\n\t\tgrpc.KeepaliveParams(time.Duration(30)*time.Second),\n\t\tgrpc.KeepaliveMinTimeBetweenPings(time.Duration(10)*time.Second),\n\t\tgrpc.KeepaliveMaxPingInterval(time.Duration(60)*time.Second),\n\t)\n\n\t// Register the service implementation\n\t// Replace with your actual service implementation\n\t// YourService.Register(s.grpcServer)\n\n\t// Register health check service\n\thealthpb.RegisterHealthServer(s.grpcServer, &health.Server{})\n\n\t// Register reflection service\n\treflection.Register(s.grpcServer)\n\n\t// Set up TLS if enabled\n\tvar opts []grpc.ServerOption\n\tif enableTLS {\n\t\tcreds, err := credentials.NewServerTLSFromCert(&certificate)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t} else {\n\t\topts = append(opts, grpc.Creds(insecure.NewCredentials()))\n\t}\n\n\t// Start the server\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\tif err := s.grpcServer.Serve(listener, opts...); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Handle shutdown signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t<-sigChan\n\tfmt.Println(\"Shutting down gRPC server...\")\n\n\t// Gracefully stop the server\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\ts.grpcServer.GracefulStop()\n}"
  },
  {
    "Task_id": 284,
    "Instruction": "Task Description: Create a gRPC server for handling OpenTelemetry Protocol (OTLP) trace data, including setup of tracing components and a bounded queue for admission control.\n\nStruct Description: The otlpReceiver struct represents a receiver for OTLP trace data over gRPC, which processes incoming traces and forwards them to the next consumer in the pipeline.\n\nFields:\n- nextConsumer: consumer.Traces - The next trace consumer in the processing pipeline\n- obsrecv: *receiverhelper.ObsReport - Observability reporter for receiver metrics\n- bq: *admission2.BoundedQueue - Bounded queue for admission control of incoming requests\n\nMethods:\n- New: (logger *zap.Logger, nextConsumer consumer.Traces, obsrecv *receiverhelper.ObsReport, bq *admission2.BoundedQueue) -> *otlpReceiver - Constructor function that creates a new otlpReceiver instance\n- otlpReceiverOnGRPCServer: (t *testing.T, tc consumer.Traces) -> (net.Addr, *tracetest.InMemoryExporter, *trace.TracerProvider) - Sets up and starts a gRPC server with OTLP trace receiver capabilities, returning the server address, in-memory exporter, and tracer provider for testing purposes",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"go.opentelemetry.io/collector/consumer\"\n\t\"go.opentelemetry.io/otel/sdk/trace\"\n\t\"go.opentelemetry.io/otel/sdk/trace/tracetest\"\n\t\"go.opentelemetry.io/collector/receiver/receivertest\"\n\t\"go.opentelemetry.io/collector/pdata/ptrace/ptraceotlp\"\n)\n\ntype otlpReceiver struct {\n\tnextConsumer consumer.Traces\n\tobsrecv      *receiverhelper.ObsReport\n\tbq           *admission2.BoundedQueue\n}\n\nfunc New(logger *zap.Logger, nextConsumer consumer.Traces, obsrecv *receiverhelper.ObsReport, bq *admission2.BoundedQueue) *otlpReceiver {\n\treturn &otlpReceiver{\n\t\tnextConsumer: nextConsumer,\n\t\tobsrecv:      obsrecv,\n\t\tbq:           bq,\n\t}\n}\n\nfunc otlpReceiverOnGRPCServer(t *testing.T, tc consumer.Traces) (net.Addr, *tracetest.InMemoryExporter, *trace.TracerProvider) {\n\tln, err := net.Listen(\"tcp\", \"localhost:\")\n\trequire.NoError(t, err, \"Failed to find an available address to run the gRPC server: %v\", err)\n\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, ln.Close())\n\t})\n\n\texp := tracetest.NewInMemoryExporter()\n\n\ttp := trace.NewTracerProvider(trace.WithSyncer(exp))\n\ttelset := componenttest.NewNopTelemetrySettings()\n\ttelset.TracerProvider = tp\n\n\tset := receivertest.NewNopSettings()\n\tset.TelemetrySettings = telset\n\n\tset.ID = component.NewIDWithName(component.MustNewType(\"otlp\"), \"trace\")\n\tobsrecv, err := receiverhelper.NewObsReport(receiverhelper.ObsReportSettings{\n\t\tReceiverID:             set.ID,\n\t\tTransport:              \"grpc\",\n\t\tReceiverCreateSettings: set,\n\t})\n\trequire.NoError(t, err)\n\tbq, err := admission2.NewBoundedQueue(set.ID, telset, maxBytes, 0)\n\trequire.NoError(t, err)\n\tr := New(zap.NewNop(), tc, obsrecv, bq)\n\tsrv := grpc.NewServer()\n\tptraceotlp.RegisterGRPCServer(srv, r)\n\tgo func() {\n\t\t_ = srv.Serve(ln)\n\t}()\n\n\treturn ln.Addr(), exp, tp\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package otlp\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/test/bisect\"\n\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"go.opentelemetry.io/otel/trace/otlp\"\n\t\"go.opentelemetry.io/otel/trace/tracehttp\"\n\t\"go.opentelemetry.io/otel/trace/tracegrpc\"\n\t\"go.opentelemetry.io/otel/exporter/otlp/otlptrace\"\n\t\"go.opentelemetry.io/otel/sdk/resource\"\n\t\"go.opentelemetry.io/otel/sdk/trace\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\t\"go.opentelemetry.io/otel/trace/noop\"\n\t\"go.opentelemetry.io/otel/trace/traceidpb\"\n\t\"go.opentelemetry.io/otel/trace/spanidpb\"\n\t\"go.opentelemetry.io/otel/trace/tracetest\"\n\t\"go.opentelemetry.io/otel/trace/tracecontext\"\n\t\"go.opentelemetry.io/otel/trace/traceutil\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceidpb\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanidpb\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceidpb\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanidpb\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanid\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/traceidpb\"\n\t\"go.opentelemetry.io/otel/trace/traceutil/spanidpb\"\n)\n\ntype otlpReceiver struct {\n\tnextConsumer consumer.Traces\n\tobsrecv      *receiverhelper.ObsReport\n\tbq           *admission2.BoundedQueue\n}\n\nfunc New(logger *zap.Logger, nextConsumer consumer.Traces, obsrecv *receiverhelper.ObsReport, bq *admission2.BoundedQueue) *otlpReceiver {\n\treturn &otlpReceiver{\n\t\tnextConsumer: nextConsumer,\n\t\tobsrecv:      obsrecv,\n\t\tbq:           bq,\n\t}\n}\n\nfunc (r *otlpReceiver) otlpReceiverOnGRPCServer(t *testing.T, tc consumer.Traces) (net.Addr, *tracetest.InMemoryExporter, *trace.TracerProvider) {\n\t// Setup the gRPC server\n\tserver := grpc.NewServer()\n\t// Register the OTLP trace receiver\n\totlp.RegisterTraceServiceServer(server, &otlpReceiver{})\n\n\t// Start the server\n\tlistener, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tgo func() {\n\t\tif err := server.Serve(listener, grpc.MaxRecvMsgSize(1024*1024)); err != nil {\n\t\t\tt.Fatalf(\"server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Get the server address\n\taddr := listener.Addr().String()\n\n\t// Setup the in-memory exporter\n\texporter, err := otlp.NewTraceExporter(\n\t\totlp.WithEndpoint(addr),\n\t\totlp.WithInsecure(),\n\t\totlp.WithRetry(false),\n\t\totlp.WithBatcher(true),\n\t\totlp.WithMaxExportBatchSize(100),\n\t\totlp.WithMaxQueueSize(100),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create exporter: %v\", err)\n\t}\n\n\t// Setup the tracer provider\n\ttp := trace.NewTracerProvider(\n\t\ttrace.WithBatcher(exporter),\n\t\ttrace.WithResource(resource.NewSchemaURL(resource.SchemaURL), resource.NewAttributes()),\n\t)\n\t// Set the global tracer provider\n\ttrace.SetTracerProvider(tp)\n\n\t// Setup the test tracer\n\ttracer := tp.Tracer(\"test-tracer\")\n\n\t// Create a new in-memory exporter for testing\n\tinMemExporter := tracetest.NewInMemoryExporter()\n\n\t// Create a new tracer provider with the in-memory exporter\n\ttpTest := trace.NewTracerProvider(\n\t\ttrace.WithBatcher(inMemExporter),\n\t\ttrace.WithResource(resource.NewSchemaURL(resource.SchemaURL), resource.NewAttributes()),\n\t)\n\t// Set the global tracer provider\n\ttrace.SetTracerProvider(tpTest)\n\n\t// Return the server address, in-memory exporter, and tracer provider\n\treturn addr, inMemExporter, tpTest\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: Implement a gRPC server in Go for a log service that supports append, read, discard, and info operations with concurrent access control and log entry management.\n\nStruct Description: The Server struct represents a gRPC server implementation for a log service that maintains an ordered sequence of log entries with configurable size limits and provides thread-safe operations.\n\nFields:\n- ctx: context.Context - Context for managing server lifecycle\n- options: *Options - Configuration options for the server\n- hardLimit: int - Maximum number of entries before truncation\n- lock: sync.Mutex - Mutex for thread-safe operations\n- locked: struct - Protected data structure containing:\n  - startIndex: Index - First available index in the log\n  - entries: []*logspec.Entry - Slice of log entries\n  - changed: chan struct{} - Channel to notify about log changes\n\nMethods:\n- NewServer: [Name](ctx context.Context, options *Options) -> (*Server, error) - Creates and starts a new Server instance\n- Append: [Name](stream logspec.Log_AppendServer) -> error - Handles append requests via gRPC stream\n- append: [Name](proposals [][]byte) -> []Index - Internal method to append entries to the log\n- lastIndexLocked: [Name]() -> Index - Helper method to get last index (requires lock)\n- Discard: [Name](ctx context.Context, req *logspec.DiscardRequest) -> (*logspec.DiscardReply, error) - Handles discard requests\n- discard: [Name](firstIndex Index) -> - Internal method to discard entries\n- Read: [Name](req *logspec.ReadRequest, stream logspec.Log_ReadServer) -> error - Handles read requests via gRPC stream\n- Info: [Name](ctx context.Context, req *logspec.InfoRequest) -> (*logspec.InfoReply, error) - Returns current log info\n- info: [Name]() -> (*logspec.InfoReply, chan struct{}) - Internal method to get log info\n- InfoStream: [Name](req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) -> error - Streams log info updates",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"github.com/ebay/akutan/logspec\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\ntype Options struct {\n\tAddress string\n\tLimit   int\n}\n\ntype Index = uint64\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\tserver := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.Limit * 3 / 2,\n\t}\n\tserver.locked.startIndex = 1\n\tserver.locked.changed = make(chan struct{})\n\tlistener, err := net.Listen(\"tcp\", options.Address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconst maxMsgSize = 1024 * 1024 * 1024\n\tservice := grpc.NewServer(\n\t\tgrpc.MaxRecvMsgSize(maxMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxMsgSize))\n\tlogspec.RegisterLogServer(service, server)\n\tgo service.Serve(listener)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t\tservice.Stop()\n\t}()\n\treturn server, nil\n}\n\nfunc (server *Server) Append(streams logspec.Log_AppendServer) error {\n\tseq := uint64(0)\n\tfor {\n\t\tseq++\n\t\treq, err := streams.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif req.Sequence != seq {\n\t\t\treturn errors.New(\"out of sequence\")\n\t\t}\n\t\tindexes := server.append(req.Proposals)\n\t\tres := logspec.AppendReply{\n\t\t\tReply: &logspec.AppendReply_Ok{\n\t\t\t\tOk: &logspec.AppendReply_OK{\n\t\t\t\t\tSequence: seq,\n\t\t\t\t\tIndexes:  indexes,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = streams.Send(&res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (server *Server) append(proposals [][]byte) []Index {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tprevLastIndex := server.lastIndexLocked()\n\tnextIndex := prevLastIndex + 1\n\tindexes := make([]Index, len(proposals))\n\tfor i := range proposals {\n\t\tindexes[i] = nextIndex\n\t\tnextIndex++\n\t\tserver.locked.entries = append(server.locked.entries, &logspec.Entry{\n\t\t\tIndex: indexes[i],\n\t\t\tData:  proposals[i],\n\t\t\tSkip:  false,\n\t\t})\n\t}\n\n\tif server.hardLimit > 0 && len(server.locked.entries) >= server.hardLimit {\n\t\tfirstIndex := nextIndex - uint64(server.options.Limit)\n\t\tdiff := firstIndex - server.locked.startIndex\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t\tserver.locked.startIndex = firstIndex\n\t}\n\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n\treturn indexes\n}\n\nfunc (server *Server) lastIndexLocked() Index {\n\treturn server.locked.startIndex + uint64(len(server.locked.entries)) - 1\n}\n\nfunc (server *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\tserver.discard(req.FirstIndex)\n\treturn &logspec.DiscardReply{\n\t\tReply: &logspec.DiscardReply_Ok{\n\t\t\tOk: &logspec.DiscardReply_OK{},\n\t\t},\n\t}, nil\n}\n\nfunc (server *Server) discard(firstIndex Index) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tif firstIndex <= server.locked.startIndex {\n\t\treturn\n\t}\n\tdiff := firstIndex - server.locked.startIndex\n\tif uint64(len(server.locked.entries)) < diff {\n\t\tserver.locked.entries = nil\n\t} else {\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t}\n\tserver.locked.startIndex = firstIndex\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n}\n\nfunc (server *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\tctx := stream.Context()\n\tnextIndex := req.NextIndex\n\tfor {\n\t\tserver.lock.Lock()\n\t\tstartIndex := server.locked.startIndex\n\t\tlastIndex := server.lastIndexLocked()\n\t\tentries := server.locked.entries\n\t\tchangedCh := server.locked.changed\n\t\tserver.lock.Unlock()\n\n\t\tif nextIndex < startIndex {\n\t\t\treturn stream.Send(&logspec.ReadReply{\n\t\t\t\tReply: &logspec.ReadReply_Truncated{\n\t\t\t\t\tTruncated: true,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t\tif nextIndex > lastIndex {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase <-server.ctx.Done():\n\t\t\t\treturn server.ctx.Err()\n\t\t\tcase <-changedCh:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tentries = entries[nextIndex-startIndex:]\n\t\tif len(entries) > 10 {\n\t\t\tentries = entries[:10]\n\t\t}\n\t\terr := stream.Send(&logspec.ReadReply{\n\t\t\tReply: &logspec.ReadReply_Ok{\n\t\t\t\tOk: &logspec.ReadReply_OK{\n\t\t\t\t\tEntries: entries,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnextIndex += uint64(len(entries))\n\t}\n}\n\nfunc (server *Server) Info(context.Context, *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tres, _ := server.info()\n\treturn res, nil\n}\n\nfunc (server *Server) info() (*logspec.InfoReply, chan struct{}) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\treturn &logspec.InfoReply{\n\t\tReply: &logspec.InfoReply_Ok{\n\t\t\tOk: &logspec.InfoReply_OK{\n\t\t\t\tFirstIndex: server.locked.startIndex,\n\t\t\t\tLastIndex:  server.lastIndexLocked(),\n\t\t\t},\n\t\t},\n\t}, server.locked.changed\n}\n\nfunc (server *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tfor {\n\t\tres, changedCh := server.info()\n\t\terr := stream.Send(res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-stream.Context().Done():\n\t\t\treturn stream.Context().Err()\n\t\tcase <-server.ctx.Done():\n\t\t\treturn server.ctx.Err()\n\t\tcase <-changedCh:\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "package logservice\n\nimport (\n\t\"context\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"logspec\"\n)\n\ntype Server struct {\n\tctx      context.Context\n\toptions  *Options\n\thardLimit int\n\tlock     sync.Mutex\n\tlocked   struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\ntype Options struct {\n\t// Configuration options for the server\n}\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\ts := &Server{\n\t\tctx:      ctx,\n\t\toptions:  options,\n\t\thardLimit: options.HardLimit,\n\t\tlocked: struct {\n\t\t\tstartIndex Index\n\t\t\tentries    []*logspec.Entry\n\t\t\tchanged    chan struct{}\n\t\t}{\n\t\t\tstartIndex: 0,\n\t\t\tentries:    make([]*logspec.Entry, 0),\n\t\t\tchanged:    make(chan struct{}),\n\t\t},\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) Append(stream logspec.Log_AppendServer) error {\n\tfor {\n\t\terr := stream.Send(&logspec.AppendResponse{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *Server) append(proposals [][]byte) []Index {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\t// Append entries\n\tindices := make([]Index, len(proposals))\n\tfor i, proposal := range proposals {\n\t\tentry := &logspec.Entry{\n\t\t\tIndex: Index(i + 1),\n\t\t\tData:  proposal,\n\t\t}\n\t\ts.locked.entries = append(s.locked.entries, entry)\n\t\tindices[i] = entry.Index\n\t}\n\n\t// Truncate if exceeding hard limit\n\tif len(s.locked.entries) > s.hardLimit {\n\t\ts.discard(Index(1))\n\t}\n\n\t// Notify about changes\n\ts.locked.changed <- struct{}{}\n\n\treturn indices\n}\n\nfunc (s *Server) lastIndexLocked() Index {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tif len(s.locked.entries) == 0 {\n\t\treturn 0\n\t}\n\treturn Index(len(s.locked.entries) - 1)\n}\n\nfunc (s *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif req.FirstIndex < 1 || req.FirstIndex > s.lastIndexLocked() {\n\t\treturn &logspec.DiscardReply{}, status.Errorf(codes.Invalid, \"invalid first index\")\n\t}\n\n\ts.discard(req.FirstIndex)\n\treturn &logspec.DiscardReply{}, nil\n}\n\nfunc (s *Server) discard(firstIndex Index) {\n\t// Remove entries from firstIndex to lastIndex\n\tindicesToKeep := firstIndex - 1\n\ts.locked.entries = s.locked.entries[:indicesToKeep]\n\ts.locked.startIndex = Index(indicesToKeep)\n}\n\nfunc (s *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif req.StartIndex < 1 || req.StartIndex > s.lastIndexLocked() {\n\t\treturn status.Errorf(codes.Invalid, \"invalid start index\")\n\t}\n\n\t// Get entries from start index to end\n\tentries := s.locked.entries[req.StartIndex-1:]\n\tfor _, entry := range entries {\n\t\tif err := stream.Send(entry); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Server) Info(ctx context.Context, req *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tinfo, _ := s.info()\n\treturn info, nil\n}\n\nfunc (s *Server) info() (*logspec.InfoReply, chan struct{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tinfo := &logspec.InfoReply{\n\t\tEntries:     len(s.locked.entries),\n\t\tLastIndex:   s.lastIndexLocked(),\n\t\tStartPosition: s.locked.startIndex,\n\t\tChanged:     s.locked.changed,\n\t}\n\n\treturn info, s.locked.changed\n}\n\nfunc (s *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tinfo, changed := s.info()\n\tif err := stream.Send(info); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-changed:\n\t\t\tinfo, changed := s.info()\n\t\t\tif err := stream.Send(info); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the specified gRPC service.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified TCP port, configures keepalive policies, registers the Echo service, and starts serving requests. It handles any errors that occur during setup or serving.\n\nInput: \n- port (string): The port number on which the server should listen, formatted as a string (e.g., \":50051\").\n- kaep (keepalive.EnforcementPolicy): The keepalive enforcement policy for the server.\n- kasp (keepalive.ServerParameters): The keepalive server parameters.\n\nOutput: \n- None (the function runs indefinitely until an error occurs or the server is stopped).\n- Errors during setup or serving are logged and the program exits.\n\nNote: The function assumes the existence of a pre-defined `server` struct that implements the `EchoServer` interface from the generated protobuf code.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\taddress := fmt.Sprintf(\":%v\", *port)\n\tlis, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tpb.RegisterEchoServer(s, &server{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"your/package/path/echo\" // replace with actual package path\n)\n\nfunc main() {\n\tport := \":50051\"\n\tkaep := keepalive.EnforcementPolicy{\n\t\tMinTimeBetweenEvents: 30000000000, // 300 seconds\n\t}\n\tkasp := keepalive.ServerParameters{\n\t\tMaxTime: 60000000000, // 600 seconds\n\t}\n\n\t// Create a new gRPC server\n\tserver := grpc.NewServer(\n\t\tgrpc.KeepaliveEnforcementPolicy(kaep),\n\t\tgrpc.KeepaliveParams(kasp),\n\t)\n\n\t// Register the Echo service\n\techo.RegisterEchoServer(server, &echo.Server{})\n\n\t// Listen on the specified port\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tdefer lis.Close()\n\n\t// Start serving\n\tlog.Printf(\"Server is listening on %s\", port)\n\tif err := server.Serve(lis, func(s *grpc.Server) { }); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Create a Go HTTP client struct for interacting with an Okta API, handling authentication, session management, and user data retrieval.\n\nStruct Description: The Client struct represents an HTTP client configured to communicate with Okta's API. It maintains client configuration, organization details, and authentication state, providing methods for various API operations.\n\nFields:\n- client: *http.Client - The underlying HTTP client used for requests\n- org: string - The Okta organization domain\n- Url: string - The base Okta URL (defaults to \"okta.com\")\n- ApiToken: string - The API token for authenticated requests\n\nMethods:\n- NewClient(org string) -> *Client - Constructor that initializes a new Client with the specified organization\n- Authenticate(username string, password string) -> (*AuthnResponse, error) - Performs user authentication with username/password\n- Session(sessionToken string) -> (*SessionResponse, error) - Creates a session using a session token\n- User(userID string) -> (*User, error) - Retrieves user details by ID\n- Groups(userID string) -> (*Groups, error) - Gets groups associated with a user\n- call(endpoint string, method string, request interface{}, response interface{}) -> error - Internal method handling the HTTP request/response cycle",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\nfunc NewClient(org string) *Client {\n\tclient := Client{\n\t\tclient: &http.Client{},\n\t\torg:    org,\n\t\tUrl:    \"okta.com\",\n\t}\n\n\treturn &client\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\tvar request = &AuthnRequest{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tvar response = &AuthnResponse{}\n\terr := c.call(\"authn\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tvar request = &SessionRequest{\n\t\tSessionToken: sessionToken,\n\t}\n\n\tvar response = &SessionResponse{}\n\terr := c.call(\"sessions\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tvar response = &User{}\n\terr := c.call(\"users/\"+userID, \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tvar response = &Groups{}\n\terr := c.call(\"users/\"+userID+\"/groups\", \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) call(endpoint, method string, request, response interface{}) error {\n\tdata, _ := json.Marshal(request)\n\n\tvar url = \"https://\" + c.org + \".\" + c.Url + \"/api/v1/\" + endpoint\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Add(\"Accept\", `application/json`)\n\treq.Header.Add(\"Content-Type\", `application/json`)\n\tif c.ApiToken != \"\" {\n\t\treq.Header.Add(\"Authorization\", \"SSWS \"+c.ApiToken)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode == http.StatusOK {\n\t\terr := json.Unmarshal(body, &response)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tvar errors ErrorResponse\n\t\terr = json.Unmarshal(body, &errors)\n\n\t\treturn &errorResponse{\n\t\t\tHTTPCode: resp.StatusCode,\n\t\t\tResponse: errors,\n\t\t\tEndpoint: url,\n\t\t}\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package okta\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tclient  *http.Client\n\torg     string\n\turl     string\n\tapiToken string\n}\n\ntype AuthnResponse struct {\n\tToken string `json:\"token\"`\n}\n\ntype SessionResponse struct {\n\tSessionToken string `json:\"sessionToken\"`\n}\n\ntype User struct {\n\tID       string `json:\"id\"`\n\tEmail    string `json:\"email\"`\n\tUsername string `json:\"username\"`\n}\n\ntype Groups struct {\n\tGroups []string `json:\"groups\"`\n}\n\nfunc NewClient(org string) *Client {\n\treturn &Client{\n\t\tclient: &http.Client{},\n\t\torg:    org,\n\t\turl:    \"https://\" + org + \".okta.com\",\n\t}\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/authn\", c.url)\n\tbody := map[string]string{\n\t\t\"username\": username,\n\t\t\"password\": password,\n\t}\n\tjsonBody, _ := json.Marshal(body)\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonBody))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar authnResp AuthnResponse\n\tjson.Unmarshal(body, &authnResp)\n\treturn &authnResp, nil\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/session\", c.url)\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"SSO \"+sessionToken)\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar sessionResp SessionResponse\n\tjson.Unmarshal(body, &sessionResp)\n\treturn &sessionResp, nil\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/users/%s\", c.url, userID)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"SSO \"+c.apiToken)\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar user User\n\tjson.Unmarshal(body, &user)\n\treturn &user, nil\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/users/%s/groups\", c.url, userID)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"SSO \"+c.apiToken)\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar groups Groups\n\tjson.Unmarshal(body, &groups)\n\treturn &groups, nil\n}\n\nfunc (c *Client) call(endpoint, method string, request, response interface{}) error {\n\turl := fmt.Sprintf(\"%s/api/v1/%s\", c.url, endpoint)\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"SSO \"+c.apiToken)\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\treturn json.Unmarshal(body, response)\n}"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server for management services, including setting up necessary dependencies and configurations.\n\nFunction Description: The function `startManagement` initializes and starts a gRPC server with management services. It sets up a temporary directory for data storage, configures the server with keepalive policies, initializes various managers and stores, and registers the management service. The server listens on a dynamically assigned port and runs in a goroutine.\n\nInput:\n- `t *testing.T`: Testing context for temporary directory creation and cleanup\n- `signalAddr string`: Address of the signal service\n- `counter *int`: Pointer to a counter for tracking server operations (used in mock implementation)\n\nOutput:\n- `*grpc.Server`: The created gRPC server instance\n- `string`: The address the server is listening on\n- `error`: Any error that occurred during initialization",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tmgmtProto \"github.com/netbirdio/netbird/management/proto\"\n\t\"github.com/netbirdio/netbird/management/server\"\n\t\"github.com/netbirdio/netbird/management/server/activity\"\n\t\"github.com/netbirdio/netbird/management/server/settings\"\n\t\"github.com/netbirdio/netbird/management/server/store\"\n\t\"github.com/netbirdio/netbird/management/server/telemetry\"\n)\n\nvar (\n\tkaep = keepalive.EnforcementPolicy{\n\t\tMinTime:             15 * time.Second,\n\t\tPermitWithoutStream: true,\n\t}\n\n\tkasp = keepalive.ServerParameters{\n\t\tMaxConnectionIdle:     15 * time.Second,\n\t\tMaxConnectionAgeGrace: 5 * time.Second,\n\t\tTime:                  5 * time.Second,\n\t\tTimeout:               2 * time.Second,\n\t}\n)\n\nfunc startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\tt.Helper()\n\tdataDir := t.TempDir()\n\n\tconfig := &server.Config{\n\t\tStuns:      []*server.Host{},\n\t\tTURNConfig: &server.TURNConfig{},\n\t\tSignal: &server.Host{\n\t\t\tProto: \"http\",\n\t\t\tURI:   signalAddr,\n\t\t},\n\t\tDatadir:    dataDir,\n\t\tHttpConfig: nil,\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tstore, cleanUp, err := store.NewTestStoreFromSQL(context.Background(), \"\", config.Datadir)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tt.Cleanup(cleanUp)\n\n\tpeersUpdateManager := server.NewPeersUpdateManager(nil)\n\teventStore := &activity.InMemoryEventStore{}\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tia, _ := integrations.NewIntegratedValidator(context.Background(), eventStore)\n\n\tmetrics, err := telemetry.NewDefaultAppMetrics(context.Background())\n\trequire.NoError(t, err)\n\n\taccountManager, err := server.BuildManager(context.Background(), store, peersUpdateManager, nil, \"\", \"netbird.selfhosted\", eventStore, nil, false, ia, metrics)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tsecretsManager := server.NewTimeBasedAuthSecretsManager(peersUpdateManager, config.TURNConfig, config.Relay)\n\tmgmtServer, err := server.NewServer(context.Background(), config, accountManager, settings.NewManager(store), peersUpdateManager, secretsManager, nil, nil)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tmock := &mockServer{\n\t\tManagementServiceServer: mgmtServer,\n\t\tcounter:                 counter,\n\t}\n\tmgmtProto.RegisterManagementServiceServer(s, mock)\n\tgo func() {\n\t\tif err = s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn s, lis.Addr().String(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nfunc startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\t// Create temporary directory for data storage\n\ttempDir, err := os.MkdirTemp(\"\", \"management-server\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer func() {\n\t\tif err := os.RemoveAll(tempDir); err != nil {\n\t\t\tt.Logf(\"Error removing temporary directory: %v\", err)\n\t\t}\n\t}()\n\n\t// Set up keepalive parameters\n\tka := keepalive.EnforcementPolicy{\n\t\tMinTime: 5 * time.Second,\n\t}\n\tka = keepalive.EnforcementPolicy{MinTime: 10 * time.Second}\n\tka = keepalive.EnforcementPolicy{MinTime: 30 * time.Second}\n\n\t// Create gRPC server\n\tserver := grpc.NewServer(\n\t\tgrpc.KeepaliveEnforcementPolicy(ka),\n\t\tgrpc.MaxRecvMsgSize(int(1 << 20)), // 1MB\n\t\tgrpc.MaxSendMsgSize(int(1 << 20)), // 1MB\n\t)\n\n\t// Register reflection service\n\treflection.Register(server)\n\n\t// Set up signal handling\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Find available port\n\tport := findAvailablePort()\n\tif port == 0 {\n\t\treturn nil, \"\", fmt.Errorf(\"could not find available port\")\n\t}\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", \":\"+strconv.Itoa(port))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to listen: %v\", err)\n\t\t}\n\t\tif err := server.Serve(lis); err != nil {\n\t\t\tt.Fatalf(\"server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Wait for signal\n\t<-sigChan\n\tserver.GracefulStop()\n\n\treturn server, \":\"+strconv.Itoa(port), nil\n}\n\nfunc findAvailablePort() int {\n\tfor port := 10000; port <= 65535; port++ {\n\t\tif _, err := net.Dial(\"tcp\", \":\"+strconv.Itoa(port)); err == nil {\n\t\t\treturn port\n\t\t}\n\t}\n\treturn 0\n}"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Implement a Redis-based session management system in Go that allows storing, retrieving, and managing HTTP session data using Redis as the backend storage.\n\nStruct Description: The implementation consists of two main structs - `SessionStore` for handling individual session operations and `Provider` for managing the Redis connection pool and session lifecycle.\n\nFields:\n\nSessionStore:\n- p: *redis.Pool - Redis connection pool\n- sid: string - Session ID\n- lock: sync.RWMutex - Read-write lock for thread safety\n- values: map[interface{}]interface{} - Key-value pairs storing session data\n- maxlifetime: int64 - Session expiration time in seconds\n\nProvider:\n- maxlifetime: int64 - Default session expiration time\n- savePath: string - Redis server address\n- poolsize: int - Connection pool size\n- password: string - Redis authentication password\n- dbNum: int - Redis database number\n- poollist: *redis.Pool - Redis connection pool instance\n\nMethods:\n\nSessionStore:\n- Set(key, value interface{}) error - Stores a key-value pair in the session\n- Get(key interface{}) interface{} - Retrieves a value by key from the session\n- Delete(key interface{}) error - Removes a key-value pair from the session\n- Flush() error - Clears all session data\n- SessionID() string - Returns the session ID\n- SessionRelease(w http.ResponseWriter) - Persists session data to Redis before closing\n\nProvider:\n- SessionInit(maxlifetime int64, savePath string) error - Initializes the Redis connection pool with configuration\n- SessionRead(sid string) (session.Store, error) - Retrieves session data from Redis\n- SessionExist(sid string) bool - Checks if a session exists in Redis\n- SessionRegenerate(oldsid, sid string) (session.Store, error) - Creates a new session ID while preserving data\n- SessionDestroy(sid string) error - Removes session data from Redis",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/astaxie/beego/session\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar redispder = &Provider{}\nvar MaxPoolSize = 100\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (rs *SessionStore) Set(key, value interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values[key] = value\n\treturn nil\n}\n\nfunc (rs *SessionStore) Get(key interface{}) interface{} {\n\trs.lock.RLock()\n\tdefer rs.lock.RUnlock()\n\tif v, ok := rs.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (rs *SessionStore) Delete(key interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\tdelete(rs.values, key)\n\treturn nil\n}\n\nfunc (rs *SessionStore) Flush() error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (rs *SessionStore) SessionID() string {\n\treturn rs.sid\n}\n\nfunc (rs *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tb, err := session.EncodeGob(rs.values)\n\tif err != nil {\n\t\treturn\n\t}\n\tc := rs.p.Get()\n\tdefer c.Close()\n\tc.Do(\"SETEX\", rs.sid, rs.maxlifetime, string(b))\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (rp *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\trp.maxlifetime = maxlifetime\n\tconfigs := strings.Split(savePath, \",\")\n\tif len(configs) > 0 {\n\t\trp.savePath = configs[0]\n\t}\n\tif len(configs) > 1 {\n\t\tpoolsize, err := strconv.Atoi(configs[1])\n\t\tif err != nil || poolsize <= 0 {\n\t\t\trp.poolsize = MaxPoolSize\n\t\t} else {\n\t\t\trp.poolsize = poolsize\n\t\t}\n\t} else {\n\t\trp.poolsize = MaxPoolSize\n\t}\n\tif len(configs) > 2 {\n\t\trp.password = configs[2]\n\t}\n\tif len(configs) > 3 {\n\t\tdbnum, err := strconv.Atoi(configs[3])\n\t\tif err != nil || dbnum < 0 {\n\t\t\trp.dbNum = 0\n\t\t} else {\n\t\t\trp.dbNum = dbnum\n\t\t}\n\t} else {\n\t\trp.dbNum = 0\n\t}\n\trp.poollist = redis.NewPool(func() (redis.Conn, error) {\n\t\tc, err := redis.Dial(\"tcp\", rp.savePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.password != \"\" {\n\t\t\tif _, err := c.Do(\"AUTH\", rp.password); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t_, err = c.Do(\"SELECT\", rp.dbNum)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t}, rp.poolsize)\n\n\treturn rp.poollist.Get().Err()\n}\n\nfunc (rp *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionExist(sid string) bool {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, err := redis.Int(c.Do(\"EXISTS\", sid)); err != nil || existed == 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (rp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, _ := redis.Int(c.Do(\"EXISTS\", oldsid)); existed == 0 {\n\t\tc.Do(\"SET\", sid, \"\", \"EX\", rp.maxlifetime)\n\t} else {\n\t\tc.Do(\"RENAME\", oldsid, sid)\n\t\tc.Do(\"EXPIRE\", sid, rp.maxlifetime)\n\t}\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionDestroy(sid string) error {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tc.Do(\"DEL\", sid)\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package main\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/gorilla/sessions\"\n)\n\ntype SessionStore struct {\n\tp      *redis.Pool\n\tsid    string\n\tlock   sync.RWMutex\n\tvalues map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc NewProvider(maxlifetime int64, savePath string, poolsize int, password string, dbNum int) *Provider {\n\tp := &Provider{\n\t\tmaxlifetime: maxlifetime,\n\t\tsavePath:    savePath,\n\t\tpoolsize:    poolsize,\n\t\tpassword:    password,\n\t\tdbNum:       dbNum,\n\t}\n\tp.poollist = newRedisPool(savePath, poolsize, password, dbNum)\n\treturn p\n}\n\nfunc newRedisPool(savePath string, poolsize int, password string, dbNum int) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxActive:     poolsize,\n\t\tMaxIdle:       poolsize,\n\t\tIdleTimeout:   10 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.NewClient(&redis.Options{\n\t\t\t\tAddr:     savePath,\n\t\t\t\tPassword: password,\n\t\t\t\tDB:       dbNum,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, nil\n\t\t},\n\t}\n}\n\nfunc (p *Provider) SessionInit(maxlifetime int64) error {\n\tp.maxlifetime = maxlifetime\n\treturn nil\n}\n\nfunc (p *Provider) SessionRead(sid string) (session.Store, error) {\n\tconn := p.poollist.Get()\n\tdefer conn.Close()\n\n\tkey := fmt.Sprintf(\"session:%s\", sid)\n\tval, err := conn.Do(\"GET\", key).(*redis.String)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsessionStore := &SessionStore{\n\t\tp:          p.poollist,\n\t\tsid:        sid,\n\t\tlock:       sync.RWMutex{},\n\t\tvalues:     make(map[interface{}]interface{}),\n\t\tmaxlifetime: p.maxlifetime,\n\t}\n\tsessionStore.values[val.Val] = val.Val\n\treturn sessionStore, nil\n}\n\nfunc (p *Provider) SessionExist(sid string) bool {\n\tconn := p.poollist.Get()\n\tdefer conn.Close()\n\n\tkey := fmt.Sprintf(\"session:%s\", sid)\n\texists, err := conn.Do(\"EXISTS\", key).(*redis.Int)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn exists > 0\n}\n\nfunc (p *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tif !p.SessionExist(oldsid) {\n\t\treturn nil, errors.New(\"session not found\")\n\t}\n\n\tconn := p.poollist.Get()\n\tdefer conn.Close()\n\n\t// Get old session data\n\toldKey := fmt.Sprintf(\"session:%s\", oldsid)\n\toldVal, err := conn.Do(\"GET\", oldKey).(*redis.String)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Delete old session\n\t_, err = conn.Do(\"DEL\", oldKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create new session\n\tnewKey := fmt.Sprintf(\"session:%s\", sid)\n\t_, err = conn.Do(\"SET\", newKey, oldVal.Val)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsessionStore := &SessionStore{\n\t\tp:          p.poollist,\n\t\tsid:        sid,\n\t\tlock:       sync.RWMutex{},\n\t\tvalues:     make(map[interface{}]interface{}),\n\t\tmaxlifetime: p.maxlifetime,\n\t}\n\tsessionStore.values[oldsid] = oldVal.Val\n\treturn sessionStore, nil\n}\n\nfunc (p *Provider) SessionDestroy(sid string) error {\n\tconn := p.poollist.Get()\n\tdefer conn.Close()\n\n\tkey := fmt.Sprintf(\"session:%s\", sid)\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (s *SessionStore) Set(key, value interface{}) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\ts.values[key] = value\n\treturn s.save()\n}\n\nfunc (s *SessionStore) Get(key interface{}) interface{} {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\n\tval, ok := s.values[key]\n\tif ok {\n\t\treturn val\n\t}\n\treturn nil\n}\n\nfunc (s *SessionStore) Delete(key interface{}) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tdelete(s.values, key)\n\treturn s.save()\n}\n\nfunc (s *SessionStore) Flush() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\ts.values = make(map[interface{}]interface{})\n\treturn s.save()\n}\n\nfunc (s *SessionStore) SessionID() string {\n\treturn s.sid\n}\n\nfunc (s *SessionStore) SessionRelease(w http.ResponseWriter) {\n\ts.save()\n}\n\nfunc (s *SessionStore) save() error {\n\tif s.maxlifetime <= 0 {\n\t\treturn nil\n\t}\n\n\tconn := s.p.Get()\n\tdefer conn.Close()\n\n\tkey := fmt.Sprintf(\"session:%s\", s.sid)\n\texpiration := time.Now().Add(time.Duration(s.maxlifetime) * time.Second).Unix()\n\t_, err := conn.Do(\"EXPIRE\", key, expiration)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Serialize the values to a JSON string\n\tjsonData, _ := json.Marshal(s.values)\n\t_, err = conn.Do(\"SET\", key, jsonData)\n\treturn err\n}"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool and methods for interacting with Redis, including setting, getting, deleting keys, and flushing the database.\n\nStruct Description: RedisStore is a struct that manages a connection pool to Redis and provides methods for common Redis operations with support for expiration times.\n\nFields:\n- pool: *redis.Pool - A connection pool to Redis for efficient connection reuse\n- defaultExpiration: time.Duration - The default expiration time for keys when not explicitly specified\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method for executing Redis commands with serialization and expiration handling",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package redisstore\n\nimport (\n\t\"time\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisStore struct {\n\tpool            *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tpool := &redis.Pool{\n\t\tMaxActive:     10,\n\t\tMaxIdle:       5,\n\t\tIdleTimeout:   240 * time.Second,\n\t\tDial: func() (redis.UniversalClient, error) {\n\t\t\treturn redis.NewClient(&redis.Options{\n\t\t\t\tAddr:     host,\n\t\t\t\tPassword: password,\n\t\t\t\tDB:       0,\n\t\t\t})\n\t\t},\n\t}\n\treturn &RedisStore{\n\t\tpool:            pool,\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (r *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tclient := r.pool.Get()\n\t\tdefer client.Close()\n\t\tif expires > 0 {\n\t\t\terr := client.SetEX(ctx, key, value, expires).Err()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\terr := client.Set(ctx, key, value).Err()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}, key, value, expires)\n}\n\nfunc (r *RedisStore) Get(key string, ptrValue interface{}) error {\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tclient := r.pool.Get()\n\t\tdefer client.Close()\n\t\tresult := client.Get(ctx, key).Val()\n\t\tif result == \"\" {\n\t\t\treturn nil, redis.Nil\n\t\t}\n\t\t*ptrValue = result\n\t\treturn nil, nil\n\t}, key, value, r.defaultExpiration)\n}\n\nfunc (r *RedisStore) Delete(key string) error {\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\tclient := r.pool.Get()\n\t\tdefer client.Close()\n\t\treturn client.Del(ctx, key).Result()\n\t}, key, value, r.defaultExpiration)\n}\n\nfunc (r *RedisStore) Flush() error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\treturn client.FlushDB(ctx).Err()\n}\n\nfunc (r *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\treturn f(\"invoke\", key, value, expires)\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Redis client struct in Go that manages connections to Redis servers and provides common Redis operations. The implementation should use connection pooling and support thread-safe access to multiple Redis instances.\n\nStruct Description: RedisClient is a struct that encapsulates Redis connection pooling and provides methods for common Redis operations. It maintains a thread-safe map of Redis clients for different server addresses.\n\nFields:\n\npool: *redis.Pool - The connection pool for Redis operations\nAddress: string - The Redis server address (URL)\n\nMethods:\n\nGetRedisClient: (address string, maxIdle int, maxActive int) -> *RedisClient - Retrieves or creates a Redis client for the given address with specified pool settings\nGet: (key string) -> (string, error) - Retrieves the value for a given key from Redis\nSet: (key string, val interface{}) -> (interface{}, error) - Sets the value for a given key in Redis\nLPush: (key string, value ...interface{}) -> (int, error) - Pushes values to the left of a Redis list\nLPop: (key string) -> (string, error) - Pops a value from the left of a Redis list\nHSet: (hashID string, field string, val string) -> error - Sets a field in a Redis hash\nHGet: (hashID string, field string) -> (string, error) - Gets a field from a Redis hash",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tredisMap map[string]*RedisClient\n\tmapMutex *sync.RWMutex\n)\n\nconst (\n\tdefaultMaxIdle   = 10\n\tdefaultMaxActive = 50\n)\n\nfunc init() {\n\tredisMap = make(map[string]*RedisClient)\n\tmapMutex = new(sync.RWMutex)\n}\n\nfunc newPool(redisURL string, maxIdle, maxActive int) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxIdle:   maxIdle,\n\t\tMaxActive: maxActive,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(redisURL)\n\t\t\treturn c, err\n\t\t},\n\t}\n}\n\nfunc GetRedisClient(address string, maxIdle, maxActive int) *RedisClient {\n\tif maxIdle <= 0 {\n\t\tmaxIdle = defaultMaxIdle\n\t}\n\tif maxActive <= 0 {\n\t\tmaxActive = defaultMaxActive\n\t}\n\tvar redis *RedisClient\n\tvar mok bool\n\tmapMutex.RLock()\n\tredis, mok = redisMap[address]\n\tmapMutex.RUnlock()\n\tif !mok {\n\t\tredis = &RedisClient{Address: address, pool: newPool(address, maxIdle, maxActive)}\n\t\tmapMutex.Lock()\n\t\tredisMap[address] = redis\n\t\tmapMutex.Unlock()\n\t}\n\treturn redis\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"GET\", key)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"SET\", key, val))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tret, err := redis.Int(conn.Do(\"LPUSH\", key, value))\n\treturn ret, err\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"LPOP\", key))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"HGET\", hashID, field)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package redisclient\n\nimport (\n\t\"github.com/go-redis/redis/v8\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool     *redis.Pool\n\tAddress  string\n\tmutex    sync.RWMutex\n\tclients  map[string]*redis.Client\n}\n\nfunc NewRedisClient(address string, maxIdle int, maxActive int) *RedisClient {\n\tp := &redis.Pool{\n\t\tMaxIdle:     maxIdle,\n\t\tMaxActive:   maxActive,\n\t\tDial: func() (redis.UniversalClient, error) {\n\t\t\treturn redis.NewClient(&redis.Options{\n\t\t\t\tAddr: address,\n\t\t\t})\n\t\t},\n\t}\n\treturn &RedisClient{\n\t\tpool:     p,\n\t\tAddress:  address,\n\t\tclients:  make(map[string]*redis.Client),\n\t}\n}\n\nfunc (c *RedisClient) GetRedisClient(address string, maxIdle int, maxActive int) *RedisClient {\n\tif c.clients[address] == nil {\n\t\tc.mutex.Lock()\n\t\tdefer c.mutex.Unlock()\n\t\tif c.clients[address] == nil {\n\t\t\tc.clients[address] = &redis.Client{\n\t\t\t\tAddr: address,\n\t\t\t}\n\t\t}\n\t}\n\treturn c\n}\n\nfunc (c *RedisClient) Get(key string) (string, error) {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.Get(ctx, key).Result()\n}\n\nfunc (c *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.Set(ctx, key, val, 0).Result()\n}\n\nfunc (c *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.LPush(ctx, key, value...).Result()\n}\n\nfunc (c *RedisClient) LPop(key string) (string, error) {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.LPop(ctx, key).Result()\n}\n\nfunc (c *RedisClient) HSet(hashID string, field string, val string) error {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.HSet(ctx, hashID, field, val).Err()\n}\n\nfunc (c *RedisClient) HGet(hashID string, field string) (string, error) {\n\tclient := c.pool.Get()\n\tdefer client.Close()\n\treturn client.HGet(ctx, hashID, field).Result()\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both querying and writing data with configurable settings like authentication, timeout, and TLS.\n\nStruct Description: The Client struct represents an InfluxDB client with configuration for server connection, authentication, and HTTP transport settings.\n\nFields:\n- url: url.URL - The base URL of the InfluxDB server\n- username: string - Username for basic authentication\n- password: string - Password for basic authentication\n- httpClient: *http.Client - Custom HTTP client with timeout and transport settings\n- userAgent: string - User agent string for HTTP requests\n- precision: string - Precision for timestamps in queries and writes\n\nMethods:\n- NewClient: [Name](Config) -> (*Client, error) - Creates a new InfluxDB client with the given configuration\n- Query: [Name](Query) -> (*Response, error) - Executes a query against the InfluxDB server and returns the response\n- Write: [Name](BatchPoints) -> (*Response, error) - Writes batch points to the InfluxDB server and returns the response",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: c.UnsafeSsl,\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) Query(q Query) (*Response, error) {\n\tu := c.url\n\n\tu.Path = \"query\"\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"GET\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = \"write\"\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package influxdb\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Client struct {\n\turl      url.URL\n\tusername string\n\tpassword string\n\thttpClient *http.Client\n\tuserAgent string\n\tprecision string\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tclient := &Client{\n\t\turl:      config.URL,\n\t\tusername: config.Username,\n\t\tpassword: config.Password,\n\t\tuserAgent: config.UserAgent,\n\t\tprecision: config.Precision,\n\t}\n\n\t// Configure HTTP client\n\tclient.httpClient = &http.Client{\n\t\tTimeout: config.Timeout,\n\t\tTransport: config.Transport,\n\t}\n\n\treturn client, nil\n}\n\nfunc (c *Client) Query(q Query) (*Response, error) {\n\t// Construct the query URL\n\turl := c.url.String() + \"/query?db=\" + q.Database + \"&q=\" + urlEncode(q.Query)\n\n\t// Set headers for authentication and user agent\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.username != \"\" && c.password != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\n\t// Send the request\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Parse the response\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(points BatchPoints) (*Response, error) {\n\t// Construct the write URL\n\turl := c.url.String() + \"/write?db=\" + points.Database + \"&precision=\" + c.precision\n\n\t// Set headers for authentication and user agent\n\treq, err := http.NewRequest(\"POST\", url, strings.NewReader(points.String()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.username != \"\" && c.password != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\treq.Header.Set(\"Content-Type\", \"application/x-lineprotocol\")\n\n\t// Send the request\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Parse the response\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function to fetch video materials from an advertising API using HTTP requests with custom headers and process the response.\n\nFunction Description: The function `getVideo` makes a GET request to a specified API endpoint to retrieve video materials for a given advertiser. It handles request creation, header addition, response processing, and error handling. The response is parsed to extract video information and store it in a global map while returning pagination information.\n\nInput:\n- advertiserId: string - The ID of the advertiser whose videos are being requested\n- page: int - The page number for paginated results\n\nOutput:\n- int - Total number of pages available (for pagination)\n- error - Any error encountered during the HTTP request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar videoImageIdMaterialIdMap = map[string]int64{}\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/get/\"\n\tmethod := \"GET\"\n\tpayload := strings.NewReader(fmt.Sprintf(`{\n    \t\t\t\"advertiser_id\": %s,\n   \t\t\t\t \"page\":%d,\n   \t\t\t\t \"page_size\":100}`, advertiserId, page))\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treq.Header.Add(\"Access-Token\", \"c0bfed085c0dbc19bb2e41920ecd6d2a6d398b32\")\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar getVideoMaterialResp GetVideoMaterialResp\n\terr = json.Unmarshal(body, &getVideoMaterialResp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif getVideoMaterialResp.Code != 0 {\n\t\treturn 0, err\n\t}\n\tfor _, s := range getVideoMaterialResp.Data.List {\n\t\tvideoImageIdMaterialIdMap[s.Id] = s.MaterialId\n\t}\n\treturn getVideoMaterialResp.Data.PageInfo.TotalPage, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar videoMap = make(map[string]interface{})\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := fmt.Sprintf(\"https://api.example.com/videos?advertiserId=%s&page=%d\", advertiserId, page)\n\theaders := map[string]string{\n\t\t\"Authorization\": \"Bearer your_token_here\",\n\t\t\"Content-Type\":  \"application/json\",\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn 0, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvar data struct {\n\t\tVideos    []map[string]interface{}\n\t\tTotal     int\n\t\tPerPage   int\n\t\tCurrentPage int\n\t\tTotalPages int\n\t}\n\terr = json.NewDecoder(resp.Body).Decode(&data)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvideoMap[advertiserId] = data.Videos\n\treturn data.TotalPages, nil\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool to interact with a Redis server, supporting common operations like Set, Get, Delete, and Flush with configurable expiration times.\n\nStruct Description: RedisStore is a struct that manages a pool of Redis connections and provides methods to interact with Redis, including setting, getting, deleting keys, and flushing the database. It supports configurable expiration times for cached items.\n\nFields:\n- pool: *redis.Pool - A connection pool to manage Redis connections efficiently\n- defaultExpiration: time.Duration - The default expiration time for cached items\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method to handle Redis operations with expiration logic",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "package redisstore\n\nimport (\n\t\"time\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisStore struct {\n\tpool           *redis.Pool\n\tdefaultExpiry  time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiry time.Duration) *RedisStore {\n\tpool := &redis.Pool{\n\t\tMaxActive:     10,\n\t\tMaxIdle:       5,\n\t\tIdleTimeout:   240 * time.Second,\n\t\tDial: func() (redis.UniversalClient, error) {\n\t\t\treturn redis.NewClient(&redis.Options{\n\t\t\t\tAddr:     host,\n\t\t\t\tPassword: password,\n\t\t\t\tDB:       0,\n\t\t\t})\n\t\t},\n\t}\n\treturn &RedisStore{\n\t\tpool:           pool,\n\t\tdefaultExpiry:  defaultExpiry,\n\t}\n}\n\nfunc (r *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\tif expires == 0 {\n\t\texpires = r.defaultExpiry\n\t}\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\treturn client.SetPX(ctx, key, value, expires).Result()\n\t}, key, value, expires)\n}\n\nfunc (r *RedisStore) Get(key string, ptrValue interface{}) error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\treturn client.Get(ctx, key).Arg(value).Result()\n\t}, key, ptrValue, 0)\n}\n\nfunc (r *RedisStore) Delete(key string) error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\treturn client.Del(ctx, key).Result()\n\t}, key, nil, 0)\n}\n\nfunc (r *RedisStore) Flush() error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\treturn r.invoke(func(cmd string, key string, value interface{}, expires time.Duration) (interface{}, error) {\n\t\treturn client.FlushDB(ctx).Result()\n\t}, \"\", nil, 0)\n}\n\nfunc (r *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tclient := r.pool.Get()\n\tdefer client.Close()\n\tctx := context.Background()\n\tif value != nil {\n\t\treturn f(\"Set\", key, value, expires)\n\t}\n\treturn f(\"Get\", key, value, expires)\n}"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Go struct that implements a RocketMQ push consumer with configurable options, message handling, and tracing capabilities.\n\nStruct Description: The PushConsumer struct encapsulates a RocketMQ push consumer with additional features like rate limiting, tracing, and message processing. It manages consumer lifecycle and message subscription.\n\nFields:\n\nname: string - Name identifier for the consumer  \nPushConsumer: rocketmq.PushConsumer - Embedded RocketMQ push consumer instance  \nPushConsumerConfig: PushConsumerConfig - Configuration for the consumer  \nsubscribers: map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error) - Map of topic to message handler functions  \ninterceptors: []primitive.Interceptor - List of interceptors for message processing  \nbucket: *ratelimit.Bucket - Rate limiter bucket for controlling consumption rate  \nstarted: bool - Flag indicating if consumer is running  \n\nMethods:\n\nRegisterSingleMessage: (f func(context.Context, *primitive.MessageExt) error) -> *PushConsumer - Registers a single message handler function with tracing and panic recovery  \nStart: () -> error - Initializes and starts the RocketMQ consumer with configured options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"runtime/debug\"\n\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/consumer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/juju/ratelimit\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.12.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype PushConsumer struct {\n\trocketmq.PushConsumer\n\tname string\n\tPushConsumerConfig\n\n\tsubscribers  map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)\n\tinterceptors []primitive.Interceptor\n\tbucket       *ratelimit.Bucket\n\tstarted      bool\n}\n\nfunc (cc *PushConsumer) RegisterSingleMessage(f func(context.Context, *primitive.MessageExt) error) *PushConsumer {\n\ttracer := xtrace.NewTracer(trace.SpanKindConsumer)\n\tattrs := []attribute.KeyValue{\n\t\tsemconv.MessagingSystemKey.String(\"rocketmq\"),\n\t\tsemconv.MessagingRocketmqClientGroupKey.String(cc.Group),\n\t\tsemconv.MessagingRocketmqClientIDKey.String(cc.InstanceName),\n\t\tsemconv.MessagingRocketmqConsumptionModelKey.String(cc.MessageModel),\n\t}\n\n\tfn := func(ctx context.Context, msgs ...*primitive.MessageExt) (result consumer.ConsumeResult, err error) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tresult, err = consumer.ConsumeRetryLater, errors.New(\"consumer message panic\")\n\t\t\t}\n\t\t}()\n\t\tfor _, msg := range msgs {\n\t\t\tvar (\n\t\t\t\tspan trace.Span\n\t\t\t)\n\n\t\t\tif cc.EnableTrace {\n\t\t\t\tcarrier := propagation.MapCarrier{}\n\t\t\t\tfor key, value := range msg.GetProperties() {\n\t\t\t\t\tcarrier[key] = value\n\t\t\t\t}\n\t\t\t\tctx, span = tracer.Start(ctx, msg.Topic, carrier, trace.WithAttributes(attrs...))\n\t\t\t\tspan.SetAttributes(\n\t\t\t\t\tsemconv.MessagingRocketmqNamespaceKey.String(msg.Topic),\n\t\t\t\t\tsemconv.MessagingRocketmqMessageTagKey.String(msg.GetTags()),\n\t\t\t\t)\n\t\t\t\tdefer span.End()\n\t\t\t}\n\n\t\t\tif cc.bucket != nil {\n\t\t\t\tif ok := cc.bucket.WaitMaxDuration(1, cc.WaitMaxDuration); !ok {\n\t\t\t\t\treturn consumer.ConsumeRetryLater, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := f(ctx, msg); err != nil {\n\t\t\t\tif cc.EnableTrace && span != nil {\n\t\t\t\t\tspan.RecordError(err)\n\t\t\t\t}\n\t\t\t\treturn consumer.ConsumeRetryLater, err\n\t\t\t}\n\t\t}\n\t\treturn consumer.ConsumeSuccess, nil\n\t}\n\tcc.subscribers[cc.Topic] = fn\n\treturn cc\n}\n\nfunc (cc *PushConsumer) Start() error {\n\tif cc.started {\n\t\treturn nil\n\t}\n\n\tvar opts = []consumer.Option{\n\t\tconsumer.WithGroupName(cc.Group),\n\t\tconsumer.WithInstance(cc.InstanceName),\n\t\tconsumer.WithNameServer(cc.Addr),\n\t\tconsumer.WithMaxReconsumeTimes(cc.Reconsume),\n\t\tconsumer.WithInterceptor(cc.interceptors...),\n\t\tconsumer.WithConsumeMessageBatchMaxSize(cc.ConsumeMessageBatchMaxSize),\n\t\tconsumer.WithPullBatchSize(cc.PullBatchSize),\n\t\tconsumer.WithConsumeGoroutineNums(cc.ConsumeGoroutineNums),\n\t\tconsumer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: cc.AccessKey,\n\t\t\tSecretKey: cc.SecretKey,\n\t\t}),\n\t}\n\tif cc.PushConsumerConfig.MessageModel == \"BroadCasting\" {\n\t\topts = append(opts, consumer.WithConsumerModel(consumer.BroadCasting))\n\t}\n\n\tclient, err := rocketmq.NewPushConsumer(opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcc.PushConsumer = client\n\n\tselector := consumer.MessageSelector{\n\t\tType:       consumer.TAG,\n\t\tExpression: \"\",\n\t}\n\tif cc.PushConsumerConfig.SubExpression != \"*\" {\n\t\tselector.Expression = cc.PushConsumerConfig.SubExpression\n\t}\n\n\tfor topic, fn := range cc.subscribers {\n\t\tif err := cc.PushConsumer.Subscribe(topic, selector, fn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif cc.Enable {\n\t\tif err := client.Start(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcc.started = true\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 128,
    "wrong_result": "package rocketmq\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/rocketmq-client/rocketmq/client\"\n\t\"github.com/rocketmq-client/rocketmq/protocol\"\n\t\"github.com/rocketmq-client/rocketmq/selector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TopicSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/TagsSelector\"\n\t\"github.com/rocketmq-client/rocketmq/selector/Tag"
  },
  {
    "Task_id": 302,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages in different modes (Sync, Async, OneWay) and support delayed messages.\n\nFunction Description: The following functions provide different ways to send messages to RocketMQ brokers. The producer must be initialized before sending messages.\n\nInput: \n- ctx: context.Context - Context for controlling the message sending process\n- topic: string - The topic to which the message will be sent\n- body: []byte - The message body/content\n- tag: string (for delay message) - Message tag for filtering\n- keys: []string (for delay message) - Message keys for filtering\n- delayLevel: int (for delay message) - Delay level for delayed messages\n- callback: func(ctx context.Context, result *primitive.SendResult, err error) (for async message) - Callback function for async message sending\n\nOutput:\n- error: For OneWay and Async modes, returns error if sending fails\n- (*primitive.SendResult, error): For Sync mode, returns send result and potential error\n- (*primitive.SendResult, error): For delayed sync message, returns send result and potential error\n\nMethods:\n\ninitProducer: () -> error - Initializes the RocketMQ producer with default configuration\n\nsendOneWayMessage: (ctx context.Context, topic string, body []byte) -> error - Sends a message in OneWay mode (fire-and-forget)\n\nsendSyncMessage: (ctx context.Context, topic string, body []byte) -> (*primitive.SendResult, error) - Sends a message in Sync mode (waits for acknowledgment)\n\nsendAsyncMessage: (ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) -> error - Sends a message in Async mode (uses callback)\n\nsendDelaySyncMessage: (ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) -> (*primitive.SendResult, error) - Sends a delayed message in Sync mode",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n)\n\nvar mqProducer rocketmq.Producer\n\nfunc initProducer() error {\n\tvar err error\n\tmqProducer, err = rocketmq.NewProducer(\n\t\tproducer.WithNsResovler(primitive.NewPassthroughResolver([]string{\"172.13.3.160:9876\"})),\n\t\tproducer.WithRetry(3),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn mqProducer.Start()\n}\n\nfunc sendOneWayMessage(ctx context.Context, topic string, body []byte) error {\n\treturn mqProducer.SendOneWay(ctx, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendSyncMessage(ctx context.Context, topic string, body []byte) (*primitive.SendResult, error) {\n\treturn mqProducer.SendSync(ctx, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendAsyncMessage(ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) error {\n\treturn mqProducer.SendAsync(ctx, callback, &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t})\n}\n\nfunc sendDelaySyncMessage(ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) (*primitive.SendResult, error) {\n\tmsg := &primitive.Message{\n\t\tTopic: topic,\n\t\tBody:  body,\n\t}\n\tmsg.WithTag(tag)\n\tmsg.WithKeys(keys)\n\tmsg.WithDelayTimeLevel(delayLevel)\n\treturn mqProducer.SendSync(ctx, msg)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 127,
    "wrong_result": "package rocketmq\n\nimport (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n)\n\ntype RocketMQProducer struct {\n\tproducer *rocketmq.Producer\n}\n\nfunc (p *RocketMQProducer) initProducer() error {\n\tproducer, err := rocketmq.NewProducer(\n\t\trocketmq.WithNameServerAddr(\"localhost:9876\"),\n\t\trocketmq.WithRetry(2),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.producer = producer\n\treturn nil\n}\n\nfunc (p *RocketMQProducer) sendOneWayMessage(ctx context.Context, topic string, body []byte) error {\n\treturn p.producer.SendOneWay(ctx, rocketmq.NewMessage(topic, body))\n}\n\nfunc (p *RocketMQProducer) sendSyncMessage(ctx context.Context, topic string, body []byte) (*primitive.SendResult, error) {\n\tresult, err := p.producer.SendSync(ctx, rocketmq.NewMessage(topic, body))\n\treturn result, err\n}\n\nfunc (p *RocketMQProducer) sendAsyncMessage(ctx context.Context, topic string, body []byte, callback func(ctx context.Context, result *primitive.SendResult, err error)) error {\n\treturn p.producer.SendAsync(ctx, rocketmq.NewMessage(topic, body), func(ctx context.Context, result *primitive.SendResult, err error) {\n\t\tcallback(ctx, result, err)\n\t})\n}\n\nfunc (p *RocketMQProducer) sendDelaySyncMessage(ctx context.Context, topic string, body []byte, tag string, keys []string, delayLevel int) (*primitive.SendResult, error) {\n\tmsg := rocketmq.NewMessage(topic, body)\n\tmsg.SetTag(tag)\n\tmsg.SetKeys(keys...)\n\tmsg.SetDelayTimeLevel(delayLevel)\n\treturn p.producer.SendSync(ctx, msg)\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Implement a RocketMQ producer in Go that can send messages to brokers using different modes (Sync, Async, or OneWay) with configurable options.\n\nStruct Description: The Producer struct encapsulates a RocketMQ producer client with methods for starting, closing, and sending messages. It supports configuration options and interceptors.\n\nFields:\n\n- started: bool - Indicates whether the producer has been started\n- Producer: rocketmq.Producer - The underlying RocketMQ producer instance\n- name: string - Name identifier for the producer\n- ProducerConfig: ProducerConfig - Configuration settings for the producer\n- interceptors: []primitive.Interceptor - List of interceptors for message processing\n\nMethods:\n\n- Start() -> error - Initializes and starts the RocketMQ producer with configured options\n- Close() -> error - Shuts down the producer gracefully\n- SendWithContext(ctx context.Context, msg []byte) -> error - Sends a byte array message with context\n- SendWithMsg(ctx context.Context, msg *primitive.Message) -> error - Sends a primitive.Message with context\n- SendWithResult(ctx context.Context, msg []byte, tag string) -> (*primitive.SendResult, error) - Sends a message with tag and returns send result\n- SendMsg(ctx context.Context, msg *primitive.Message) -> (*primitive.SendResult, error) - Sends a message and returns send result",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/apache/rocketmq-client-go/v2/producer\"\n\t\"github.com/douyu/jupiter/pkg/xlog\"\n)\n\ntype Producer struct {\n\tstarted bool\n\n\trocketmq.Producer\n\tname string\n\tProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc (pc *Producer) Start() error {\n\tif pc.started {\n\t\treturn nil\n\t}\n\n\tclient, err := rocketmq.NewProducer(\n\t\tproducer.WithGroupName(pc.Group),\n\t\tproducer.WithNameServer(pc.Addr),\n\t\tproducer.WithRetry(pc.Retry),\n\t\tproducer.WithInterceptor(pc.interceptors...),\n\t\tproducer.WithInstanceName(pc.InstanceName),\n\t\tproducer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: pc.AccessKey,\n\t\t\tSecretKey: pc.SecretKey,\n\t\t}),\n\t)\n\tif err != nil {\n\t\txlog.Jupiter().Panic(\"create producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tif err := client.Start(); err != nil {\n\t\txlog.Jupiter().Panic(\"start producer\",\n\t\t\txlog.FieldName(pc.name),\n\t\t\txlog.FieldExtMessage(pc.ProducerConfig),\n\t\t\txlog.Any(\"error\", err),\n\t\t)\n\t}\n\n\tpc.started = true\n\tpc.Producer = client\n\treturn nil\n}\n\nfunc (pc *Producer) Close() error {\n\terr := pc.Shutdown()\n\tif err != nil {\n\t\txlog.Jupiter().Warn(\"consumer close fail\", xlog.Any(\"error\", err.Error()))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\t_, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\tmsg.Topic = pc.Topic\n\t_, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pc *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\tm := primitive.NewMessage(pc.Topic, msg)\n\tif tag != \"\" {\n\t\tm.WithTag(tag)\n\t}\n\n\tres, err := pc.SendSync(ctx, m)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", string(msg)))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}\n\nfunc (pc *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\tres, err := pc.SendSync(ctx, msg)\n\tif err != nil {\n\t\txlog.Jupiter().Error(\"send message error\", xlog.Any(\"msg\", msg))\n\t\treturn res, err\n\t}\n\treturn res, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 127,
    "wrong_result": "package rocketmq\n\nimport (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n)\n\ntype Producer struct {\n\tstarted   bool\n\tProducer  *rocketmq.Producer\n\tname      string\n\tProducerConfig ProducerConfig\n\tinterceptors []primitive.Interceptor\n}\n\nfunc (p *Producer) Start() error {\n\tif p.started {\n\t\treturn nil\n\t}\n\tp.Producer, err := rocketmq.NewProducer(p.ProducerConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, interceptor := range p.interceptors {\n\t\tp.Producer.AddInterceptor(interceptor)\n\t}\n\treturn p.Producer.Start()\n}\n\nfunc (p *Producer) Close() error {\n\tif !p.started {\n\t\treturn nil\n\t}\n\terr := p.Producer.Shutdown()\n\tp.started = false\n\treturn err\n}\n\nfunc (p *Producer) SendWithContext(ctx context.Context, msg []byte) error {\n\treturn p.Producer.Send(context.Background(), msg)\n}\n\nfunc (p *Producer) SendWithMsg(ctx context.Context, msg *primitive.Message) error {\n\treturn p.Producer.Send(ctx, msg)\n}\n\nfunc (p *Producer) SendWithResult(ctx context.Context, msg []byte, tag string) (*primitive.SendResult, error) {\n\treturn p.Producer.SendWithResult(ctx, msg, tag)\n}\n\nfunc (p *Producer) SendMsg(ctx context.Context, msg *primitive.Message) (*primitive.SendResult, error) {\n\treturn p.Producer.SendMsg(ctx, msg)\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a stock quote service that retrieves stock information from an external API and processes the response.\n\nStruct Description: The Stock struct represents a service for fetching stock quotes. It contains configuration fields for API access and implements methods to retrieve quote information.\n\nFields:\nApi: [string] - The base URL of the stock API service\nKey: [string] - The API key used for authentication with the stock service\n\nMethods:\nQuote: [Name](ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) -> [error] - Retrieves stock quote information for a given symbol. Validates the input symbol, makes an HTTP GET request to the stock API, processes the response, and populates the response object with the quote data. Returns error if any step fails.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/stock/proto\"\n)\n\ntype Stock struct {\n\tApi   string\n\tKey   string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif len(req.Symbol) <= 0 || len(req.Symbol) > 5 {\n\t\treturn errors.BadRequest(\"stock.quote\", \"invalid symbol\")\n\t}\n\n\turi := fmt.Sprintf(\"%slast/stock/%s?apikey=%s\", s.Api, req.Symbol, s.Key)\n\n\tresp, err := http.Get(uri)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to get quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\tdefer resp.Body.Close()\n\n\tb, _ := ioutil.ReadAll(resp.Body)\n\n\tif resp.StatusCode != 200 {\n\t\tlogger.Errorf(\"Failed to get quote (non 200): %d %v\\n\", resp.StatusCode, string(b))\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\tvar respBody struct {\n\t\tSymbol    string\n\t\tAsk       float64\n\t\tBid       float64\n\t\tAsize     int32\n\t\tBsize     int32\n\t\tTimestamp int64\n\t}\n\n\tif err := json.Unmarshal(b, &respBody); err != nil {\n\t\tlogger.Errorf(\"Failed to unmarshal quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\trsp.Symbol = respBody.Symbol\n\trsp.AskPrice = respBody.Ask\n\trsp.BidPrice = respBody.Bid\n\trsp.AskSize = respBody.Asize\n\trsp.BidSize = respBody.Bsize\n\trsp.Timestamp = respBody.Timestamp\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package stock\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Stock struct {\n\tApi string\n\tKey string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif req.Symbol == \"\" {\n\t\treturn errors.New(\"symbol is required\")\n\t}\n\n\turl := s.Api + \"/quote?\" + strings.Join([]string{\n\t\t\"symbol=\" + req.Symbol,\n\t\t\"api_key=\" + s.Key,\n\t}, \"&\")\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to retrieve stock quote\")\n\t}\n\n\t// Process response and populate rsp\n\t// This is a placeholder for actual response parsing logic\n\trsp.Symbol = req.Symbol\n\trsp.Price = 150.00\n\trsp.Change = 2.50\n\trsp.ChangePercent = 1.67\n\n\treturn nil\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET request. It supports caching of downloaded files to avoid redundant network requests. The function handles error cases including failed requests and non-200 status codes. When caching is enabled, subsequent requests for the same URL will return the cached content.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The content of the fetched file as a byte slice\n- `error` - An error object if any step fails (network error, non-200 status, etc.)\n\nNote: The function relies on package-level variables `fileCache` (a map for caching), `fileCacheMutex` (for thread safety), `fileCacheEnable` (boolean to toggle caching), and `verboseReader` (boolean for logging). These should be properly initialized before use.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar fileCache = make(map[string][]byte)\nvar fileCacheMutex = &sync.Mutex{}\nvar fileCacheEnable bool = true\nvar verboseReader bool = false\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tif !fileCacheEnable {\n\t\treturn fetchWithoutCaching(fileurl)\n\t}\n\n\tfileKey := normalizeURL(fileurl)\n\tcontent, exists := fileCache[fileKey]\n\tif exists {\n\t\treturn content, nil\n\t}\n\n\tcontent, err := fetchWithoutCaching(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileCache[fileKey] = content\n\treturn content, nil\n}\n\nfunc fetchWithoutCaching(fileurl string) ([]byte, error) {\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"non-200 status code: %d - %s\", resp.StatusCode, string(body))\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif verboseReader {\n\t\tfmt.Printf(\"Fetched %s\\n\", fileurl)\n\t}\n\n\treturn body, nil\n}\n\nfunc normalizeURL(url string) string {\n\t// Normalize the URL by removing any query parameters and fragment\n\tparts := strings.SplitN(url, \"?\", 2)\n\treturn parts[0]\n}"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a function to download a file from a given URL, apply an optional filter to the content, and save it to specified directories.\n\nFunction Description: The function `dl` downloads a file from a provided URL, reads its content, applies an optional filter (if provided), and writes the content to one or more specified directories. It handles errors during the HTTP request, reading the response, and file writing, and provides status feedback via console output.\n\nInput:  \n- `f` (type `dlFile`): A struct containing the following fields:  \n  - `name` (string): The name of the file to be saved.  \n  - `url` (string): The URL from which the file will be downloaded.  \n  - `filt` (func([]byte) []byte): An optional function to filter/modify the downloaded content. Can be `nil` if no filtering is needed.  \n  - `dirs` ([]string): A slice of directory paths where the file will be saved.  \n\nOutput:  \n- None (void): The function does not return any value but prints status messages to the console (e.g., \"Sync [filename]: ok\" on success or error messages on failure).  \n\nNote: The function handles errors for HTTP requests, reading response bodies, and file writing, and ensures the response body is closed properly to prevent resource leaks.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc dl(f dlFile) {\n\tfmt.Printf(\"Sync %s: \", f.name)\n\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\tioutil.WriteFile(filepath.Join(dir, f.name), content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Println(\"ok\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype dlFile struct {\n\tname string\n\turl  string\n\tfilt func([]byte) []byte\n\tdirs []string\n}\n\nfunc dl(f dlFile) {\n\tresp, err := http.Get(f.url)\n\tif err != nil {\n\t\tfmt.Printf(\"Error downloading %s: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Printf(\"Failed to download %s (status code %d)\\n\", f.name, resp.StatusCode)\n\t\treturn\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading response body for %s: %v\\n\", f.name, err)\n\t\treturn\n\t}\n\n\tif f.filt != nil {\n\t\tcontent = f.filt(content)\n\t}\n\n\tfor _, dir := range f.dirs {\n\t\tdirPath := filepath.Join(dir, f.name)\n\t\terr = os.MkdirAll(dirPath, os.ModePerm)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error creating directory %s: %v\\n\", dirPath, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilePath := filepath.Join(dirPath, f.name)\n\t\terr = os.WriteFile(filePath, content, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error writing file %s: %v\\n\", filePath, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Sync %s: ok\\n\", f.name)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Implement a function to fetch and process Google Font CSS data for embedding in SVG documents.\n\nFunction Description: The function `googlefont` retrieves CSS data from Google Fonts API for a specified font family, embeds it in SVG-compatible format, and returns available font variants. It handles HTTP requests, response processing, and error cases gracefully.\n\nInput: \n- `f` [string] - The font family name to query (e.g., \"Roboto\" or \"Open Sans\")\n\nOutput:\n- `[]string` - A slice of strings representing available font variants (split by \"|\"), or an empty slice if the request fails or returns non-200 status",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nvar (\n\tcanvas = svg.New(os.Stdout)\n)\n\nconst (\n\tgwfURI  = \"http://fonts.googleapis.com/css?family=\"\n\tfontfmt = \"<style type=\\\"text/css\\\">\\n<![CDATA[\\n%s]]>\\n</style>\\n\"\n)\n\nfunc googlefont(f string) []string {\n\tempty := []string{}\n\tr, err := http.Get(gwfURI + url.QueryEscape(f))\n\tif err != nil {\n\t\treturn empty\n\t}\n\tdefer r.Body.Close()\n\tb, rerr := ioutil.ReadAll(r.Body)\n\tif rerr != nil || r.StatusCode != http.StatusOK {\n\t\treturn empty\n\t}\n\tcanvas.Def()\n\tfmt.Fprintf(canvas.Writer, fontfmt, b)\n\tcanvas.DefEnd()\n\treturn strings.Split(fontlist, \"|\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "func googlefont(f string) []string {\n\t// Construct the URL for Google Fonts API\n\turl := \"https://fonts.googleapis.com/css2?family=\" + urlencoding.Encode(f)\n\t\n\t// Send HTTP GET request\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\tdefer resp.Body.Close()\n\t\n\t// Check if response is successful\n\tif resp.StatusCode != 200 {\n\t\treturn []string{}\n\t}\n\t\n\t// Read response body\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn []string{}\n\t}\n\t\n\t// Parse CSS content to extract font variants\n\tvariants := []string{}\n\tlines := strings.Split(string(body), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"font-family:\") && strings.Contains(line, \"font-weight\") {\n\t\t\t// Extract font variants\n\t\t\tparts := strings.Split(line, \"|\")\n\t\t\tfor _, part := range parts {\n\t\t\t\tif strings.HasPrefix(part, \"font-family:\") {\n\t\t\t\t\tvariant := strings.TrimPrefix(part, \"font-family:\")\n\t\t\t\t\tvariant = strings.TrimSpace(variant)\n\t\t\t\t\tvariants = append(variants, variant)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn variants\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Create a function that fetches memory statistics from a specified URL using HTTP GET request and returns the response body.\n\nFunction Description: The function `defaultMemstatsClient` makes an HTTP GET request to the provided URL to fetch memory statistics. It handles the response by reading the body and ensures proper resource cleanup by deferring the closure of the response body. Errors during the request or response handling are returned to the caller.\n\nInput: \n- `url` (string): The URL from which to fetch the memory statistics.\n\nOutput: \n- `[]byte`: The response body containing the memory statistics.\n- `error`: An error object if the HTTP request or response reading fails; otherwise, `nil`.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc defaultMemstatsClient(url string) ([]byte, error) {\n\tutil.Debug(\"Fetching memstats from %s\", url)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc defaultMemstatsClient(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL with optional custom headers and client configuration, while implementing safety measures like response size limiting and proper resource cleanup.\n\nFunction Description: The function `ReadURL` makes an HTTP GET request to the specified URL using a provided HTTP client and optional headers. It ensures proper resource cleanup, checks for successful response status, limits the maximum readable response size, and returns the response body or an error if any step fails.\n\nInput:\n- `url` [string] - The URL to send the GET request to\n- `client` [*http.Client] - The HTTP client to use for the request (can be nil to use http.DefaultClient)\n- `header` [*http.Header] - Optional headers to include in the request (can be nil)\n\nOutput:\n- `body` [[]byte] - The response body if the request is successful\n- `err` [error] - An error object if any step fails, including:\n  - Request creation failure\n  - Network errors\n  - Non-200 status codes (wrapped in HTTPError)\n  - Read errors\n  - Response size exceeding limit",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tmaxReadLength = 10 * 1 << 20\n)\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) (body []byte, err error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{\n\t\t\tStatusCode: resp.StatusCode,\n\t\t\tURL:        url,\n\t\t}\n\t}\n\n\tlimitedReader := &io.LimitedReader{R: resp.Body, N: maxReadLength}\n\tcontents, err := ioutil.ReadAll(limitedReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif limitedReader.N <= 0 {\n\t\treturn nil, errors.New(\"the read limit is reached\")\n\t}\n\n\treturn contents, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) ([][]byte, error) {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\n\tif header == nil {\n\t\theader = &http.Header{}\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor k, v := range *header {\n\t\treq.Header.Set(k, strings.Join(v, \",\"))\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode > 299 {\n\t\treturn nil, &HTTPError{Message: fmt.Sprintf(\"unexpected status code: %d\", resp.StatusCode)}\n\t}\n\n\tmaxResponseSize := 10 * 1024 * 1024 // 10 MB\n\tvar body [][]byte\n\tbuf := &bytes.Buffer{}\n\t_, err = io.CopyBuffer(buf, resp.Body, make([]byte, maxResponseSize))\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif buf.Len() > maxResponseSize {\n\t\treturn nil, errors.New(\"response size exceeds the limit\")\n\t}\n\n\tbody = [][]byte{buf.Bytes()}\n\treturn body, nil\n}\n\ntype HTTPError struct {\n\tMessage string\n}\n\nfunc (e *HTTPError) Error() string {\n\treturn e.Message\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: The task involves creating a struct and associated method to handle chunked file uploads to a remote server using HTTP PUT requests with proper content range headers.\n\nStruct Description: The UploadSession struct represents an ongoing file upload session, tracking upload state, metadata, and providing methods for chunked upload operations.\n\nFields:\n\nID: string - Unique identifier for the upload session\nOldID: string - Previous session ID (if applicable)\nParentID: string - ID of parent directory\nNodeID: uint64 - Filesystem node identifier\nName: string - Name of the file being uploaded\nExpirationDateTime: time.Time - When the upload session expires\nSize: uint64 - Total size of the file in bytes\nData: []byte - File content data being uploaded\nQuickXORHash: string - File content hash\nModTime: time.Time - File modification time\nretries: int - Number of upload retry attempts\nUploadURL: string - Server endpoint for chunk uploads\nETag: string - Entity tag from server response\nstate: int - Current upload state\nerror: error - Last encountered error\nsync.Mutex: - Mutex for thread-safe operations\n\nMethods:\n\nuploadChunk: (auth *graph.Auth, offset uint64) -> ([]byte, int, error) - Uploads a file chunk starting at specified offset. Returns response body, HTTP status code, and error if any. Handles authentication refresh and proper Content-Range headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/jstaf/onedriver/fs/graph\"\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype UploadSession struct {\n\tID                 string    `json:\"id\"`\n\tOldID              string    `json:\"oldID\"`\n\tParentID           string    `json:\"parentID\"`\n\tNodeID             uint64    `json:\"nodeID\"`\n\tName               string    `json:\"name\"`\n\tExpirationDateTime time.Time `json:\"expirationDateTime\"`\n\tSize               uint64    `json:\"size,omitempty\"`\n\tData               []byte    `json:\"data,omitempty\"`\n\tQuickXORHash       string    `json:\"quickxorhash,omitempty\"`\n\tModTime            time.Time `json:\"modTime,omitempty\"`\n\tretries            int\n\n\tsync.Mutex\n\tUploadURL string `json:\"uploadUrl\"`\n\tETag      string `json:\"eTag,omitempty\"`\n\tstate     int\n\terror\n}\n\nfunc (u *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tu.Lock()\n\turl := u.UploadURL\n\tif url == \"\" {\n\t\tu.Unlock()\n\t\treturn nil, -1, errors.New(\"UploadSession UploadURL cannot be empty\")\n\t}\n\tu.Unlock()\n\n\tend := offset + uploadChunkSize\n\tvar reqChunkSize uint64\n\tif end > u.Size {\n\t\tend = u.Size\n\t\treqChunkSize = end - offset + 1\n\t}\n\tif offset > u.Size {\n\t\treturn nil, -1, errors.New(\"offset cannot be larger than DriveItem size\")\n\t}\n\n\tauth.Refresh()\n\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\n\t\t\"PUT\",\n\t\turl,\n\t\tbytes.NewReader((u.Data)[offset:end]),\n\t)\n\trequest.Header.Add(\"Content-Length\", strconv.Itoa(int(reqChunkSize)))\n\tfrags := fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, u.Size)\n\tlog.Info().Str(\"id\", u.ID).Msg(\"Uploading \" + frags)\n\trequest.Header.Add(\"Content-Range\", frags)\n\n\tresp, err := client.Do(request)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\tdefer resp.Body.Close()\n\tresponse, _ := ioutil.ReadAll(resp.Body)\n\treturn response, resp.StatusCode, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\t\"sync\"\n)\n\ntype UploadSession struct {\n\tID             string\n\tOldID          string\n\tParentID       string\n\tNodeID         uint64\n\tName           string\n\tExpirationDateTime time.Time\n\tSize           uint64\n\tData           []byte\n\tQuickXORHash   string\n\tModTime        time.Time\n\tretries        int\n\tUploadURL      string\n\tETag           string\n\tstate          int\n\terror          error\n\tmu             sync.Mutex\n}\n\nfunc (u *UploadSession) uploadChunk(auth *Auth, offset uint64) ([]byte, int, error) {\n\tu.mu.Lock()\n\tdefer u.mu.Unlock()\n\n\tif u.error != nil {\n\t\treturn nil, 0, u.error\n\t}\n\n\tif u.ExpirationDateTime.Before(time.Now()) {\n\t\treturn nil, 0, &Error{Message: \"upload session expired\"}\n\t}\n\n\tif offset >= u.Size {\n\t\treturn nil, 0, &Error{Message: \"offset exceeds file size\"}\n\t}\n\n\tcontentRange := \"bytes \" + offset + \"-\" + (offset + len(u.Data)-1)\n\trequest, err := http.NewRequest(\"PUT\", u.UploadURL, bytes.NewReader(u.Data))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\trequest.Header.Set(\"Content-Range\", contentRange)\n\trequest.Header.Set(\"Authorization\", auth.Token)\n\n\tclient := &http.Client{}\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer response.Body.Close()\n\n\tbody, err := io.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tif response.StatusCode >= 400 {\n\t\treturn nil, 0, &Error{Message: \"upload failed with status code \" + strconv.Itoa(response.StatusCode)}\n\t}\n\n\tu.ETag = response.Header.Get(\"ETag\")\n\tu.state = 2\n\tu.error = nil\n\n\treturn body, response.StatusCode, nil\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput:\n- `[]byte` - The contents of the file as a byte slice\n- `error` - Any error encountered during the fetch operation (nil if successful)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nfunc fetchFile(fileurl string) ([][]byte, error) {\n\t// Extract the base name of the file\n\tfileName := filepath.Base(fileurl)\n\tcacheDir := \"./cache\"\n\tif err := os.MkdirAll(cacheDir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the file is already in the cache and not expired\n\tcachePath := filepath.Join(cacheDir, fileName)\n\tif _, err := os.Stat(cachePath); err == nil {\n\t\t// Check if the cached file is still valid (e.g., not expired)\n\t\t// For simplicity, we'll assume the cached file is valid unless it's been modified\n\t\t// In a real-world scenario, you would check the last modified time against the server\n\t\treturn [][]byte{loadFile(cachePath)}, nil\n\t}\n\n\t// Fetch the file from the URL\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\t// Save the file to the cache\n\tfile, err := os.Create(cachePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set a cache expiration time (e.g., 24 hours)\n\texpirationTime := time.Now().Add(24 * time.Hour)\n\tos.Chtimes(cachePath, time.Now(), expirationTime)\n\n\t// Return the file content\n\treturn [][]byte{loadFile(cachePath)}, nil\n}\n\nfunc loadFile(path string) []byte {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn data\n}"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Implement a file fetcher with caching capability that retrieves files from a given URL using HTTP GET requests and caches the results to avoid redundant network calls.\n\nFunction Description: The FetchFile function checks a cache for the requested file URL. If not found in cache, it makes an HTTP GET request to fetch the file, stores the result in cache, and returns the file content. It handles errors during the fetch operation and returns appropriate status codes.\n\nInput: \n- fileurl [string]: The URL of the file to fetch\n\nOutput:\n- []byte: The content of the fetched file\n- error: Any error encountered during the fetch operation (network error, non-200 status code, or read error)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tinitializeFileCache()\n\tbytes, ok := fileCache[fileurl]\n\tif ok {\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t}\n\t\treturn bytes, nil\n\t}\n\tif verboseReader {\n\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tdefer response.Body.Close()\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\t// Check if the file is already in cache\n\tcachePath := filepath.Join(os.TempDir(), \"file_cache\", filepath.Base(fileurl))\n\tif _, err := os.Stat(cachePath); err == nil {\n\t\treturn os.ReadFile(cachePath)\n\t}\n\n\t// Fetch the file from URL\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"HTTP request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\t// Save to cache\n\tos.MkdirAll(filepath.Dir(cachePath), os.ModePerm)\n\tfile, err := os.Create(cachePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the file content\n\treturn os.ReadFile(cachePath)\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response body as a byte slice or an error if the request fails.\n\nFunction Description: The function makes an HTTP GET request to the provided URL, reads the response body, and returns it as a byte slice. It handles errors during the request or reading process and ensures the response body is properly closed to prevent resource leaks.\n\nInput: \n- url (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- ([]byte, error): A byte slice containing the response body if the request is successful, or an error if the request fails or the response body cannot be read.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://api.github.com/repos/zyedidia/micro/releases\")\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getResponseBody(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, errors.New(\"unexpected status code: \" + resp.Status)\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string]: The URL of the file to be fetched\n\nOutput: \n- `[]byte`: The contents of the file as a byte slice if successful\n- `error`: An error object if any step fails (network error, HTTP error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nfunc fetchFile(fileurl string, verbose bool) ([]byte, error) {\n\t// Extract the base name of the file from the URL\n\tfilename := filepath.Base(fileurl)\n\tcacheDir := \"./cache\"\n\tcachePath := filepath.Join(cacheDir, filename)\n\n\t// Create cache directory if it doesn't exist\n\tif err := os.MkdirAll(cacheDir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the file is already in the cache and not expired\n\tfileInfo, err := os.Stat(cachePath)\n\tif err == nil {\n\t\tage := time.Since(fileInfo.ModTime())\n\t\tif age < 24*time.Hour { // Cache is valid for 24 hours\n\t\t\tif verbose {\n\t\t\t\tprintln(\"Serving cached file:\", filename)\n\t\t\t}\n\t\t\treturn os.ReadFile(cachePath)\n\t\t}\n\t}\n\n\t// Download the file from the URL\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP error: %s\", resp.Status)\n\t}\n\n\t// Save the file to the cache\n\tfile, err := os.Create(cachePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Update the cache time\n\tos.Chtimes(cachePath, time.Now(), time.Now())\n\n\tif verbose {\n\t\tprintln(\"Downloaded and cached file:\", filename)\n\t}\n\n\treturn os.ReadFile(cachePath)\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Create a function that retrieves the version information from an etcd server using a simple HTTP GET request.\n\nFunction Description: The function `GetEtcdVersion` makes an HTTP GET request to the specified etcd server's `/version` endpoint, reads the response, and returns the version information as a string. It handles errors for connection issues, unsuccessful HTTP responses, and response body reading failures.\n\nInput: \n- `host` (string): The base URL of the etcd server (e.g., \"http://localhost:2379\")\n\nOutput: \n- (string): The version information returned by the etcd server\n- (error): An error object if any step fails (connection, non-200 response, or body reading error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\nfunc GetEtcdVersion(host string) (string, error) {\n\tresponse, err := http.Get(host + \"/version\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unsuccessful response from etcd server %q: %v\", host, err)\n\t}\n\tversionBytes, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(versionBytes), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc GetEtcdVersion(host string) (string, error) {\n\turl := host + \"/version\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn \"\", &http.RequestError{\"non-200 response\", url, resp.StatusCode, strings.NewReader(string(body))}\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Implement a function to retrieve node information by making an HTTP GET request to a local server. The function should handle server setup, request execution, and response processing.\n\nFunction Description: The function `getNode` initiates an HTTP server locally, sends a GET request to retrieve node information based on the provided ID, and returns the response body as a string. It handles server lifecycle management and ensures proper resource cleanup.\n\nInput: \n- `id` [string] - The identifier of the node to retrieve\n\nOutput: \n- [string] - The response body containing the node information",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc getNode(id string) string {\n\tlchan := make(chan net.Listener)\n\thttpServe = func(l net.Listener, h http.Handler) error {\n\t\tlchan <- l\n\t\thttp.Serve(l, h)\n\t\treturn nil\n\t}\n\n\tgo func() { run(&http.ServeMux{}, 0, false, \"nbs:\"+dir) }()\n\tl := <-lchan\n\tdefer l.Close()\n\n\tr, err := http.Get(fmt.Sprintf(\"http://%s/getNode?id=%s\", l.Addr().String(), id))\n\tassert.NoError(err)\n\tdefer r.Body.Close()\n\tbody, err := ioutil.ReadAll(r.Body)\n\treturn string(body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc getNode(id string) (string, error) {\n\t// Start the server\n\tserver := http.Server{\n\t\tAddr:           \"localhost:8080\",\n\t\tHandler:        nil,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\t// Simulate server setup and response\n\tgo func() {\n\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.Method != \"GET\" {\n\t\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Simulate node data based on ID\n\t\t\tswitch id {\n\t\t\tcase \"node1\":\n\t\t\t\tw.Write([]byte(\"Node 1: Name=Node One, Status=Active\"))\n\t\t\tcase \"node2\":\n\t\t\t\tw.Write([]byte(\"Node 2: Name=Node Two, Status=Inactive\"))\n\t\t\tdefault:\n\t\t\t\tw.Write([]byte(\"Node not found\"))\n\t\t\t}\n\t\t})\n\n\t\terr := server.ListenAndServe(\":8080\", nil)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Server error:\", err)\n\t\t}\n\t}()\n\n\t// Wait for server to start\n\ttime.Sleep(1 * time.Second)\n\n\t// Send GET request\n\tresp, err := http.Get(\"http://localhost:8080\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read response body\n\tbody, _ := io.ReadAll(resp.Body)\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to retrieve configuration data from a local admin API endpoint and returns the response body as a string.\n\nFunction Description: The function `getEffectiveConfig` makes an HTTP GET request to a specified local port's admin API endpoint (/api/v1/config_dump). It handles the response by checking the status code, reading the response body, and returning it as a string. It includes proper error handling for failed requests or non-200 status codes.\n\nInput: \n- port [uint32] - The local port number where the admin API is running\n\nOutput:\n- [string] - The response body as a string if the request is successful\n- [error] - An error object describing any issues that occurred during the request (connection error, non-200 status code, or body read error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"errors\"\n)\nfunc getEffectiveConfig(port uint32) (string, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"http://localhost:%d/api/v1/config_dump\", port))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"call admin api failed response status: %d, %s\", resp.StatusCode, string(b)))\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(b), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc getEffectiveConfig(port uint32) (string, error) {\n\turl := \"http://localhost:\" + string(port) + \"/api/v1/config_dump\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn \"\", &http.RequestError{Message: \"non-200 status code\", StatusCode: resp.StatusCode, Body: string(body)}\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}\n\ntype RequestError struct {\n\tMessage   string\n\tStatusCode int\n\tBody      string\n}\n\nfunc (e *RequestError) Error() string {\n\treturn e.Message\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Implement a function to retrieve a proxy address from a specified HTTP endpoint and return it in a formatted string.\n\nFunction Description: The function `getOneProxy` makes an HTTP GET request to a predefined proxy server endpoint, reads the response body to obtain the proxy address, formats it with an \"http://\" prefix, and returns both the formatted and raw proxy strings. It includes basic error handling for the response reading process.\n\nInput: None (The function takes no input parameters)\n\nOutput: \n1. A string representing the formatted proxy address with \"http://\" prefix\n2. A string representing the raw proxy address from the response body",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gocolly/colly\"\n)\n\nfunc getOneProxy() (string, string) {\n\tresp, _ := http.Get(\"http://45.78.45.70:5015/get/\")\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t}\n\tproxy := \"http://\" + string(body)\n\tfmt.Println(\"\u4f7f\u7528\u9ed8\u8ba4\u4ee3\u7406\uff1a\" + proxy)\n\treturn proxy, string(body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getOneProxy() (string, string) {\n\turl := \"http://example.com/proxy-endpoint\" // Replace with actual proxy server endpoint\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", \"\"\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\"\n\t}\n\n\trawProxy := string(body)\n\tformattedProxy := \"http://\" + rawProxy\n\n\treturn formattedProxy, rawProxy\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: The task involves creating a Go struct that encapsulates functionality for sending push notifications through a push service, handling HTTP communication, and processing responses. The struct should manage HTTP client configuration, request construction, and response handling for push notification delivery.\n\nStruct Description: PushServiceBase is a struct that provides base functionality for push notification services. It manages HTTP client configuration, constructs requests to a push service endpoint, handles authentication, processes responses, and manages delivery results. The struct is designed to be extended by specific push service implementations.\n\nFields:\n\nclient: [*http.Client] - Custom HTTP client configured with TLS settings and timeouts\ninitialism: [string] - Short identifier for the push service\nrawPayloadKey: [string] - Key for raw payload in notification data\nrawNotificationKey: [string] - Key for raw notification in notification data\nserviceURL: [string] - Base URL for the push service endpoint\npushServiceName: [string] - Name of the push service\n\nMethods:\n\nMakePushServiceBase: [func(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase] - Constructor that initializes the PushServiceBase with configuration and creates a custom HTTP client\n\nmulticast: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification)] - Sends push notifications to multiple devices, handles HTTP communication, and processes responses. Takes push service provider, delivery points, result channel, and notification as input, and writes results to the channel\n\nToCMPayload: [func(notif *push.Notification, regIds []string) ([]byte, error)] - Converts notification to payload format (implementation not shown in reference code)\n\nhandleCMMulticastResults: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult)] - Processes multicast results from push service (implementation not shown in reference code)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uniqush/uniqush-push/push\"\n\t\"github.com/uniqush/uniqush-push/util\"\n)\n\ntype PushServiceBase struct {\n\tclient             HTTPClient\n\tinitialism         string\n\trawPayloadKey      string\n\trawNotificationKey string\n\tserviceURL         string\n\tpushServiceName    string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\tconf := &tls.Config{InsecureSkipVerify: false}\n\ttr := &http.Transport{\n\t\tTLSClientConfig:     conf,\n\t\tTLSHandshakeTimeout: time.Second * 5,\n\t\tMaxIdleConnsPerHost: 500,\n\t}\n\tclient := &http.Client{\n\t\tTransport: tr,\n\t\tTimeout:   time.Second * 10,\n\t}\n\treturn PushServiceBase{\n\t\tclient:             client,\n\t\tinitialism:         initialism,\n\t\trawPayloadKey:      rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:         serviceURL,\n\t\tpushServiceName:    pushServiceName,\n\t}\n}\n\nfunc (psb *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tif len(dpList) == 0 {\n\t\treturn\n\t}\n\tregIds := extractRegIds(dpList)\n\n\tjpayload, e0 := psb.ToCMPayload(notif, regIds)\n\n\tif e0 != nil {\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, e0)\n\t\treturn\n\t}\n\n\treq, e1 := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewReader(jpayload))\n\tif req != nil {\n\t\tdefer req.Body.Close()\n\t}\n\tif e1 != nil {\n\t\thttpErr := push.NewErrorf(\"Error constructing HTTP request: %v\", e1)\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, httpErr)\n\t\treturn\n\t}\n\n\tapikey := psp.VolatileData[\"apikey\"]\n\n\treq.Header.Set(\"Authorization\", \"key=\"+apikey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tr, e2 := psb.client.Do(req)\n\tif r != nil {\n\t\tdefer r.Body.Close()\n\t}\n\tif e2 != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\n\t\t\tres.Destination = dp\n\t\t\tif err, ok := e2.(net.Error); ok {\n\t\t\t\tif err.Temporary() {\n\t\t\t\t\tafter := 3 * time.Second\n\t\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t\t}\n\t\t\t} else if err, ok := e2.(*net.DNSError); ok {\n\t\t\t\tafter := 3 * time.Second\n\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t} else {\n\t\t\t\tres.Err = push.NewErrorf(\"Unrecoverable HTTP error sending to %s: %v\", psb.pushServiceName, e2)\n\t\t\t}\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\t}\n\n\tnewAuthToken := r.Header.Get(\"Update-Client-Auth\")\n\tif newAuthToken != \"\" && apikey != newAuthToken {\n\t\tpsp.VolatileData[\"apikey\"] = newAuthToken\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewPushServiceProviderUpdate(psp)\n\t\tresQueue <- res\n\t}\n\n\tswitch r.StatusCode {\n\tcase 500, 503:\n\t\tafter := 0 * time.Second\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\t\t\tres.Destination = dp\n\t\t\terr := push.NewRetryError(psp, dp, notif, after)\n\t\t\tres.Err = err\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\tcase 401:\n\t\terr := push.NewBadPushServiceProviderWithDetails(psp, fmt.Sprintf(\"push service credentials rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\tcase 400:\n\t\terr := push.NewBadNotificationWithDetails(fmt.Sprintf(\"push notification payload rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tcontents, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to read %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tvar result CMResult\n\terr = json.Unmarshal(contents, &result)\n\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to decode %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, result.Results)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package push\n\nimport (\n\t\"net/http\"\n\t\"time\"\n)\n\ntype PushServiceBase struct {\n\tclient           *http.Client\n\tinitialism       string\n\trawPayloadKey    string\n\trawNotificationKey string\n\tserviceURL       string\n\tpushServiceName  string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\treturn PushServiceBase{\n\t\tclient: &http.Client{\n\t\t\tTimeout: time.Second * 10,\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t\t},\n\t\t},\n\t\tinitialism:       initialism,\n\t\trawPayloadKey:    rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:       serviceURL,\n\t\tpushServiceName:  pushServiceName,\n\t}\n}\n\nfunc (s *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tfor _, dp := range dpList {\n\t\tif dp == nil {\n\t\t\tcontinue\n\t\t}\n\t\tpayload, err := s.ToCMPayload(notif, []string{dp.RegID})\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tresp, err := s.client.Post(s.serviceURL, \"application/json\", payload)\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode),\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tresQueue <- &push.Result{\n\t\t\tDeliveryPoint: dp,\n\t\t\tSuccess:       true,\n\t\t}\n\t}\n}\n\nfunc (s *PushServiceBase) ToCMPayload(notif *push.Notification, regIds []string) ([]byte, error) {\n\t// Implementation not shown\n\treturn nil, nil\n}\n\nfunc (s *PushServiceBase) handleCMMulticastResults(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult) {\n\t// Implementation not shown\n}"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Implement a function to fetch file content from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `FetchFile` retrieves the content of a file from a specified URL using HTTP GET request. It supports caching of fetched files to avoid redundant network requests when the same URL is requested multiple times. The function includes error handling for network issues and invalid HTTP responses.\n\nInput: \n- `fileurl` (string): The URL of the file to be fetched.\n\nOutput: \n- `[]byte`: The content of the file as a byte slice if successful.\n- `error`: An error object describing any issues encountered during the fetch operation (network errors, non-200 status codes, etc.). Returns nil if no error occurs.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar verboseReader = false\nvar fileCacheEnable = true\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nvar cacheDir = \"./cache\"\nvar cacheTTL = 24 * time.Hour // 1 day\n\nfunc init() {\n\tos.MkdirAll(cacheDir, os.ModePerm)\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\t// Check if the file is already in the cache\n\tcacheKey := filepath.Base(fileurl)\n\tcachePath := filepath.Join(cacheDir, cacheKey+\".txt\")\n\tif _, err := os.Stat(cachePath); err == nil {\n\t\t// Check if the cached file is still valid (within TTL)\n\t\tfileTime, _ := os.Stat(cachePath).ModTime()\n\t\tif time.Now().Sub(fileTime) < cacheTTL {\n\t\t\treturn readFile(cachePath)\n\t\t}\n\t}\n\n\t// Fetch the file from the URL\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP error %d: %s\", resp.StatusCode, resp.Status)\n\t}\n\n\t// Save the response to cache\n\tcontent, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Write to cache\n\terr = os.WriteFile(cachePath, content, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\nfunc readFile(path string) ([]byte, error) {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a function to fetch a long-lived user access token from Facebook's Graph API using HTTP GET request.\n\nFunction Description: The function makes an HTTP GET request to Facebook's OAuth endpoint to exchange a short-lived access token for a long-lived one. It handles the request, response reading, and JSON parsing, returning the long-lived token or an error if any step fails.\n\nInput: \n- The function is a method on a struct (FacebookBee) that contains the following fields:\n  - clientID (string): Facebook app client ID\n  - clientSecret (string): Facebook app client secret\n  - accessToken (string): Short-lived user access token to exchange\n\nOutput:\n- string: The long-lived access token if successful\n- error: Descriptive error if any step fails (request, reading response, or parsing JSON)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc (mod *FacebookBee) fetchLongLivedUserAccessToken() (string, error) {\n\tbaseURL := \"https://graph.facebook.com/oauth/access_token\"\n\tv := url.Values{}\n\tv.Set(\"grant_type\", \"fb_exchange_token\")\n\tv.Set(\"client_id\", mod.clientID)\n\tv.Set(\"client_secret\", mod.clientSecret)\n\tv.Set(\"fb_exchange_token\", mod.accessToken)\n\tgraphUrl := baseURL + \"?\" + v.Encode()\n\n\tres, err := http.Get(graphUrl)\n\n\tif err != nil || res == nil {\n\t\treturn \"\", fmt.Errorf(\"fetching long lived user access token failed: %w\", err)\n\t}\n\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"reading content while fetching long lived user access token failed: %w\", err)\n\t}\n\n\ttype RequestResult struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\n\tvar tokenRes RequestResult\n\terr = json.Unmarshal(body, &tokenRes)\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"parsing result while fetching long lived user access token failed: %w\", err)\n\t}\n\n\treturn tokenRes.AccessToken, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype FacebookBee struct {\n\tclientID     string\n\tclientSecret string\n\taccessToken  string\n}\n\nfunc (f *FacebookBee) GetLongLivedToken() (string, error) {\n\turl := \"https://graph.facebook.com/v18.0/oauth/access_token\"\n\tparams := urlParams{\n\t\t\"client_id\":     f.clientID,\n\t\t\"client_secret\": f.clientSecret,\n\t\t\"access_token\":  f.accessToken,\n\t\t\"grant_type\":    \"fb_exchange_token\",\n\t\t\"fb_exchange_token\": f.accessToken,\n\t}\n\n\tresp, err := http.Get(url + \"?\" + params.toString())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result map[string]string\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif result[\"error\"] != \"\" {\n\t\treturn \"\", fmt.Errorf(\"error: %s\", result[\"error\"])\n\t}\n\n\treturn result[\"access_token\"], nil\n}\n\ntype urlParams struct {\n\tFields map[string]string\n}\n\nfunc (u urlParams) toString() string {\n\tvar b bytes.Buffer\n\tfor key, value := range u.Fields {\n\t\tb.WriteString(fmt.Sprintf(\"%s=%s&\", key, value))\n\t}\n\treturn strings.TrimSuffix(b.String(), \"&\")\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response validation, and resource cleanup. The function is designed to work with metadata services like Google Cloud's metadata server.\n\nInput:  \n- `key` (string): The metadata key to retrieve from the metadata server. This is appended to the base metadata path.\n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tbaseURL := \"http://169.254.169.254/latest/meta-data\"\n\tfullURL := baseURL + \"/\" + key\n\n\treq, err := http.NewRequest(\"GET\", fullURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", \"Google-Compute Engine\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, errors.New(string(body))\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Implement a function to fetch the contents of a file from a given URL and return it as an io.Reader for further processing.  \n\nFunction Description: The function `fetchFile` takes a URL as input, sends an HTTP GET request to fetch the file, reads the response body, and returns it as an `io.Reader`. It handles errors during the HTTP request and response reading.  \n\nInput:  \n- `URL` (string) - The URL of the file to be fetched.  \n\nOutput:  \n- `io.Reader` - A reader containing the contents of the fetched file.  \n\n(Note: The `checkErr` function is assumed to handle errors by panicking or logging.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n\tresp, err := http.Get(URL)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tcheckErr(err)\n\treturn strings.NewReader(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc fetchFile(url string) io.Reader {\n\tresp, err := http.Get(url)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\n\treturn resp.Body\n}"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a function that fetches properties from a given URL, handles HTTP responses appropriately, and processes the content based on its encoding type.\n\nFunction Description: The function LoadURL makes an HTTP GET request to the specified URL, checks the response status code, reads the response body, and determines the content encoding based on the Content-Type header. It then processes the content and returns the parsed properties or an error if any step fails.\n\nInput: \n- url (string): The URL from which to fetch the properties.\n\nOutput: \n- (*Properties, error): A pointer to a Properties struct containing the parsed data and nil error on success, or nil and an error describing the failure.\n\nNote: The function handles special cases like 404 errors (when IgnoreMissing is true) and validates the Content-Type header before processing. It also ensures proper resource cleanup by deferring the closing of the response body.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc (l *Loader) LoadURL(url string) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: error fetching %q. %s\", url, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 404 && l.IgnoreMissing {\n\t\tLogPrintf(\"properties: %s returned %d. skipping\", url, resp.StatusCode)\n\t\treturn NewProperties(), nil\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"properties: %s returned %d\", url, resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"properties: %s error reading response. %s\", url, err)\n\t}\n\n\tct := resp.Header.Get(\"Content-Type\")\n\tct = strings.Join(strings.Fields(ct), \"\")\n\tvar enc Encoding\n\tswitch strings.ToLower(ct) {\n\tcase \"text/plain\", \"text/plain;charset=iso-8859-1\", \"text/plain;charset=latin1\":\n\t\tenc = ISO_8859_1\n\tcase \"\", \"text/plain;charset=utf-8\":\n\t\tenc = UTF8\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"properties: invalid content type %s\", ct)\n\t}\n\n\treturn l.loadBytes(body, enc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype Properties struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\nfunc LoadURL(url string) (*Properties, error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 404 {\n\t\treturn nil, errors.New(\"resource not found\")\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, errors.New(\"unexpected response status code\")\n\t}\n\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif contentType == \"\" {\n\t\treturn nil, errors.New(\"missing content type header\")\n\t}\n\n\tif !strings.HasPrefix(contentType, \"application/json\") {\n\t\treturn nil, errors.New(\"unsupported content type\")\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar props Properties\n\tif err := json.Unmarshal(body, &props); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &props, nil\n}"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a function that reads data from a given location, supporting HTTP/HTTPS protocols. The function should handle URL parsing, make HTTP requests, and return the response body or appropriate errors.\n\nFunction Description: The function `ReadLocation` takes a location string (URL) as input, parses it to determine the protocol, and if it's HTTP/HTTPS, makes a GET request to fetch the data. It handles response status checks, reads the response body, and ensures proper resource cleanup.\n\nInput: \n- `loc` (string): A URL string specifying the location to read from (e.g., \"http://example.com/data\")\n\nOutput: \n- `[]byte`: The response body as a byte slice if successful\n- `error`: An error object describing any issues encountered during URL parsing, HTTP request, or response handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tu, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch u.Scheme {\n\tcase \"http\", \"https\":\n\t\tres, err := http.Get(loc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer res.Body.Close()\n\t\tif res.StatusCode != http.StatusOK {\n\t\t\treturn nil, fmt.Errorf(\"%s\", res.Status)\n\t\t}\n\t\tb, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn b, nil\n\t}\n\treturn nil, fmt.Errorf(\"Unsupported location to load: %s\", loc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tif !strings.HasPrefix(loc, \"http://\") && !strings.HasPrefix(loc, \"https://\") {\n\t\treturn nil, errors.New(\"invalid protocol: must be http or https\")\n\t}\n\n\tresp, err := http.Get(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"HTTP request failed with status code %d: %s\", resp.StatusCode, body)\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Implement a GIF search functionality using the Giphy API in Go, handling HTTP requests, response parsing, and error management.\n\nStruct Description: The Gifs struct represents a service for searching GIFs using the Giphy API. It maintains configuration and provides methods to interact with the API.\n\nFields:\n- conf: [conf] - Configuration containing the Giphy API key\n\nMethods:\n- New: [func() *Gifs] - Initializes a new Gifs instance by loading configuration\n- Search: [func(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error] - Searches for GIFs using the Giphy API with the provided query and parameters\n\nInput:\n- ctx: [context.Context] - Context for request cancellation and timeouts\n- request: [*gifs.SearchRequest] - Contains search parameters (query, limit, offset, rating, language)\n- response: [*gifs.SearchResponse] - Will be populated with search results\n\nOutput:\n- error: Returns nil on success or an appropriate error on failure",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/config\"\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tgifs \"github.com/micro/services/gifs/proto\"\n)\n\ntype conf struct {\n\tAPIKey string `json:\"api_key\"`\n}\n\ntype Gifs struct {\n\tconf conf\n}\n\nfunc New() *Gifs {\n\tv, err := config.Get(\"micro.gifs\")\n\tif err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\tvar c conf\n\tif err := v.Scan(&c); err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\n\treturn &Gifs{conf: c}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error {\n\tif len(request.Query) == 0 {\n\t\treturn errors.BadRequest(\"gifs.Search\", \"Missing query field\")\n\t}\n\tlimit := defaultLimit\n\tif request.Limit > 0 {\n\t\tlimit = request.Limit\n\t}\n\toffset := defaultOffset\n\tif request.Offset > 0 {\n\t\toffset = request.Offset\n\t}\n\n\trating := defaultRating\n\tif len(request.Rating) > 0 {\n\t\trating = request.Rating\n\t}\n\tlan := defaultLang\n\tif len(request.Lang) > 0 {\n\t\tlan = request.Lang\n\t}\n\trsp, err := http.Get(fmt.Sprintf(giphySearch, g.conf.APIKey, request.Query, limit, offset, rating, lan))\n\tif err != nil {\n\t\tlogger.Errorf(\"Error querying giphy %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tdefer rsp.Body.Close()\n\tb, err := ioutil.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tvar gRsp searchResponse\n\tif err := json.Unmarshal(b, &gRsp); err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tresponse.Data = marshalGifs(gRsp.Data)\n\tresponse.Pagination = &gifs.Pagination{\n\t\tOffset:     gRsp.Pagination.Offset,\n\t\tTotalCount: gRsp.Pagination.TotalCount,\n\t\tCount:      gRsp.Pagination.Count,\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/giphy/giphy\"\n)\n\ntype Gifs struct {\n\tconf *giphy.Config\n}\n\nfunc New() *Gifs {\n\tcfg := &giphy.Config{\n\t\tKey: \"your_giphy_api_key\",\n\t}\n\treturn &Gifs{conf: cfg}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error {\n\tif request.Query == \"\" {\n\t\treturn fmt.Errorf(\"query is required\")\n\t}\n\n\tclient := giphy.NewClient(g.conf)\n\tparams := map[string]string{\n\t\t\"q\":        request.Query,\n\t\t\"limit\":    request.Limit,\n\t\t\"offset\":   request.Offset,\n\t\t\"rating\":   request.Rating,\n\t\t\"lang\":     request.Language,\n\t\t\"api_version\": \"1\",\n\t}\n\n\turl := \"https://api.giphy.com/v1/gifs/search\"\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor k, v := range params {\n\t\treq.URL.RawQuery += fmt.Sprintf(\"%s=%s&\", k, v)\n\t}\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"non-200 response: %s\", resp.Status)\n\t}\n\n\tvar data struct {\n\t\tData []gifs.Gif `json:\"data\"`\n\t}\n\tif err := json.Unmarshal(body, &data); err != nil {\n\t\treturn err\n\t}\n\n\t*response = gifs.SearchResponse{\n\t\tGifs: data.Data,\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 327,
    "Instruction": "Task Description: Implement a function that sets up a cron job to make periodic HTTP GET requests to a specified callback URL and logs the results.\n\nFunction Description: The function `Setup` initializes a new cron scheduler, adds a job that makes HTTP GET requests to a specified callback URL at a given interval, and logs the success or failure of each request. The function starts the cron scheduler and returns it for further management.\n\nInput: \n- `job` [*pb.Job] - A protobuf message containing the job details, including:\n  - `Id` [string] - Unique identifier for the job\n  - `Interval` [string] - Cron-formatted interval at which the job should run\n  - `Callback` [string] - URL to which the HTTP GET request will be made\n\nOutput: \n- [*cron.Cron] - A pointer to the started cron scheduler instance, which can be used to stop or manage the scheduled job.",
    "Canonical_solution": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/cron/proto\"\n\t\"github.com/robfig/cron/v3\"\n)\nfunc (c *Cron) Setup(job *pb.Job) *cron.Cron {\n\tlogger.Infof(\"Setting up job id: %s\", job.Id)\n\tcr := cron.New()\n\tcr.AddFunc(job.Interval, func() {\n\t\tlogger.Infof(\"Running job id: %s\", job.Id)\n\t\trsp, err := http.Get(job.Callback)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed job id: %s error: %v\", job.Id, err)\n\t\t\treturn\n\t\t}\n\t\tdefer rsp.Body.Close()\n\t\tb, _ := ioutil.ReadAll(rsp.Body)\n\t\tif rsp.StatusCode != 200 {\n\t\t\tlogger.Errorf(\"Non 200 job id: %s error: %s\", job.Id, string(b))\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Successful job id: %s\", job.Id)\n\t})\n\tcr.Start()\n\treturn cr\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype CronJobTestSuite struct {\n\tsuite.Suite\n\tc *cron.Cron\n}\n\nfunc (s *CronJobTestSuite) SetupTest() {\n\ts.c = cron.New()\n}\n\nfunc (s *CronJobTestSuite) TestSetup() {\n\tjob := &pb.Job{\n\t\tId:        \"test-job\",\n\t\tInterval:  \"0 */1 * * *\",\n\t\tCallback:  \"http://example.com/callback\",\n\t}\n\n\ts.c.Schedule(func() {\n\t\tlog.Println(\"Request made to callback URL\")\n\t}, job.Interval)\n\n\ts.c.Start()\n\ttime.Sleep(2 * time.Second)\n\ts.c.Stop()\n}\n\nfunc TestCronJob(t *testing.T) {\n\tsuite.Run(t, &CronJobTestSuite{})\n}"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified address with JSON payload and room parameters, then processes the response.\n\nFunction Description: The function sends a POST request to a server endpoint with room information and a JSON payload containing a test value. It handles the response by reading the body and printing the result along with a timestamp.\n\nInput:\n- addr (string): The server address to which the POST request will be sent.\n- i (int64): A numeric value that will be included in the JSON payload.\n\nOutput: None (prints response details to stdout, returns nothing)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc post(addr string, i int64) {\n\tresp, err := http.Post(\"http://\"+addr+\"/goim/push/room?operation=1000&type=test&room=\"+os.Args[1], \"application/json\", bytes.NewBufferString(fmt.Sprintf(\"{\\\"test\\\":%d}\", i)))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%s postId:%d, response:%s\\n\", time.Now().Format(\"2006-01-02 15:04:05\"), i, string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\t\"encoding/json\"\n)\n\nfunc sendPostRequest(addr string, i int64) {\n\tpayload := map[string]interface{}{\n\t\t\"test\": i,\n\t}\n\n\tjsonData, err := json.Marshal(payload)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\n\turl := addr + \"/api/room\"\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\ttimestamp := time.Now().UnixNano()\n\tfmt.Printf(\"Response received at %d: %s\\n\", timestamp, body)\n}"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response processing, and error checking. The function ensures proper resource cleanup by deferring the closing of the response body.\n\nInput:  \n- `key` (string): The metadata key to be appended to the metadata server's base path.  \n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\turl := \"http://metadata.server/path/\" + key\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", \"metadata-client/1.0\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, errors.New(\"non-200 status code: \" + resp.Status + \"\\n\" + string(body))\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a Proxy struct that manages different types of servers (UDS, mTLS, admin, and health) for handling proxy connections with various protocols (HTTP and gRPC).\n\nStruct Description: The Proxy struct provides methods to run different server types with configurable options, including Unix Domain Socket (UDS) servers, mTLS-secured servers, admin servers for metrics and profiling, and health servers for liveness/readiness checks.\n\nMethods:\n\nMethod1: runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a master server using Unix Domain Socket (UDS) for communication. Supports both gRPC and HTTP modes based on configuration. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod2: runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a mTLS-secured master server listening on a TCP port. Supports both gRPC and HTTP modes. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod3: runAdminServer(o *options.ProxyRunOptions) -> void - Starts an admin server for metrics and optional profiling endpoints. Runs on a localhost port specified in options.\n\nMethod4: runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) -> void - Starts a health server providing liveness (/healthz) and readiness (/ready) endpoints. Runs on a port specified in options.\n\nNote: StopFunc is a function type defined as: type StopFunc func()",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Proxy struct {\n}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tif o.DeleteUDSFile {\n\t\tif err := os.Remove(o.UdsName); err != nil && !os.IsNotExist(err) {\n\t\t\tklog.ErrorS(err, \"failed to delete file\", \"file\", o.UdsName)\n\t\t}\n\t}\n\tvar stop StopFunc\n\tif o.Mode == \"grpc\" {\n\t\tgrpcServer := grpc.NewServer()\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := getUDSListener(ctx, o.UdsName)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get uds listener: %v\", err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\tserver := &http.Server{\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tklog.ErrorS(err, \"error shutting down server\")\n\t\t}\n\t\tgo func() {\n\t\t\tudsListener, err := getUDSListener(ctx, o.UdsName)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to get uds listener\")\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\terr := udsListener.Close()\n\t\t\t\tklog.ErrorS(err, \"failed to close uds listener\")\n\t\t\t}()\n\t\t\terr = server.Serve(udsListener)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to serve uds requests\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tvar stop StopFunc\n\n\tvar tlsConfig *tls.Config\n\tvar err error\n\tif tlsConfig, err = p.getTLSConfig(o.ServerCaCert, o.ServerCert, o.ServerKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", o.ServerPort)\n\n\tif o.Mode == grpcMode {\n\t\tserverOption := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\tgrpcServer := grpc.NewServer(serverOption)\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to listen on %s: %v\", addr, err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\thttpServer := &http.Server{\n\t\t\tAddr: \":8088\",\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr:      addr,\n\t\t\tTLSConfig: tlsConfig,\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t\tTLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),\n\t\t}\n\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown server\")\n\t\t\t}\n\t\t\terr = httpServer.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown httpServer\")\n\t\t\t}\n\t\t}\n\t\tgo func() {\n\t\t\terr := server.ListenAndServeTLS(\"\", \"\")\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on master port\")\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\terr := httpServer.ListenAndServe()\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on http master port\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.Handle(\"/metrics\", promhttp.Handler())\n\tif o.EnableProfiling {\n\t\tmuxHandler.HandleFunc(\"/debug/pprof\", util.RedirectTo(\"/debug/pprof/\"))\n\t\tmuxHandler.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\tif o.EnableContentionProfiling {\n\t\t\truntime.SetBlockProfileRate(1)\n\t\t}\n\t}\n\tadminServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\"127.0.0.1:%d\", o.AdminPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := adminServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"admin server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Admin server stopped listening\")\n\t}()\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\tlivenessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\treadinessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tready, msg := server.Readiness.Ready()\n\t\tif ready {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tfmt.Fprintf(w, \"ok\")\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, msg)\n\t})\n\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.HandleFunc(\"/healthz\", livenessHandler)\n\tmuxHandler.HandleFunc(\"/ready\", readinessHandler)\n\thealthServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\":%d\", o.HealthPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := healthServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"health server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Health server stopped listening\")\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "package proxy\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"google.golang.org/grpc\"\n)\n\ntype StopFunc func()\n\ntype Proxy struct {\n\t// Assume server.ProxyServer is defined elsewhere\n\tserver *server.ProxyServer\n}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\t// Implement UDS master server logic here\n\t// This is a placeholder for actual implementation\n\treturn func() {}, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\t// Implement mTLS master server logic here\n\t// This is a placeholder for actual implementation\n\treturn func() {}, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\t// Implement admin server logic here\n\t// This is a placeholder for actual implementation\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\t// Implement health server logic here\n\t// This is a placeholder for actual implementation\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a function to fetch and update search configuration from a remote URL, comparing it with the current configuration and updating if different.\n\nFunction Description: The function fetchSearchConfig retrieves search configuration from a predefined URL, normalizes it, compares it with the current configuration, and updates the system state if the new configuration is different. It handles HTTP requests, response reading, and configuration normalization.\n\nInput: None (uses predefined searchConfigURL and relies on the Server's state)\n\nOutput: error - Returns an error if any step fails (HTTP request, reading response, normalization, or configuration loading), or nil if successful (whether updated or no change needed)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nvar currentConfig, _ = normalize(defaultSearchConfig)\n\nfunc (s *Server) fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tnewConfig, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewConfig, err = normalize(newConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif bytes.Equal(currentConfig, newConfig) {\n\t\treturn nil\n\t}\n\tif err := s.scraper.LoadConfig(newConfig); err != nil {\n\t\treturn err\n\t}\n\ts.state.SearchProviders = s.scraper.Config\n\ts.state.Push()\n\tcurrentConfig = newConfig\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar searchConfigURL = \"https://example.com/search-config.json\"\n\ntype Config struct {\n\tIndex string `json:\"index\"`\n\tFields []string `json:\"fields\"`\n}\n\nvar currentConfig Config\n\nfunc fetchSearchConfig() error {\n\tresp, err := http.Get(searchConfigURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"failed to fetch search config\")\n\t}\n\n\tvar newConfig Config\n\tif err := json.Unmarshal(body, &newConfig); err != nil {\n\t\treturn err\n\t}\n\n\tif newConfig.Index != currentConfig.Index || !equalStringSlices(newConfig.Fields, currentConfig.Fields) {\n\t\tcurrentConfig = newConfig\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc equalStringSlices(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t}\t\n\treturn true\n}"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a function to fetch file content from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `FetchFile` retrieves the content of a file from a specified URL using HTTP GET request. It supports caching of downloaded files to avoid redundant network requests. The cache can be enabled/disabled globally, and cache hits/misses are logged when verbose mode is active. The function handles HTTP errors and returns the file content as a byte array.\n\nInput: \n- `fileurl` [string] - The URL of the file to be fetched\n\nOutput: \n- `[]byte` - The content of the file as a byte array\n- `error` - Any error encountered during the fetch operation (network error, HTTP status error, etc.)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheEnable = true\n\nfunc initializeFileCache() {\n\tif fileCache == nil {\n\t\tfileCache = make(map[string][]byte, 0)\n\t}\n}\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, errors.New(fmt.Sprintf(\"Error downloading %s: %s\", fileurl, response.Status))\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar cacheEnabled = true\nvar verboseMode = false\n\nfunc FetchFile(fileurl string) ([]byte, error) {\n\tif verboseMode {\n\t\tprintln(\"Fetching file from URL:\", fileurl)\n\t}\n\n\t// Extract the base name of the file\n\tfilename := filepath.Base(fileurl)\n\tcachePath := filepath.Join(os.TempDir(), \"file_cache\", filename)\n\n\t// Check if the file is in the cache\n\tif cacheEnabled {\n\t\tif _, err := os.Stat(cachePath); err == nil {\n\t\t\tif verboseMode {\n\t\t\t\tprintln(\"Cache hit for:\", filename)\n\t\t\t}\n\t\t\treturn os.ReadFile(cachePath)\n\t\t}\n\t}\n\n\t// Download the file\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, &http.Error{Status: resp.Status}\n\t}\n\n\t// Save to cache if enabled\n\tif cacheEnabled {\n\t\tos.MkdirAll(filepath.Dir(cachePath), os.ModePerm)\n\t\tfile, err := os.Create(cachePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer file.Close()\n\t\t_, err = io.Copy(file, resp.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif verboseMode {\n\t\t\tprintln(\"Cache written for:\", filename)\n\t\t}\n\t}\n\n\t// Return the content\n\treturn io.ReadAll(resp.Body)\n}"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The `fetchFile` function retrieves the contents of a file from a specified URL using HTTP GET. It supports optional caching of file contents to avoid redundant network requests for the same URL. The function handles HTTP errors and returns the file contents as a byte array if successful.\n\nInput: \n- `fileurl` [string] - The URL of the file to fetch\n\nOutput: \n- `[]byte` - The contents of the file as a byte array\n- `error` - An error object if the fetch operation fails (either network error or non-200 HTTP status)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nvar cacheDir = \"./cache\"\nvar cacheTTL = 12 * time.Hour\n\nfunc init() {\n\tos.MkdirAll(cacheDir, os.ModePerm)\n}\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\t// Check cache first\n\tcacheKey := filepath.Base(fileurl)\n\tcachePath := filepath.Join(cacheDir, cacheKey+\".cache\")\n\tif _, err := os.Stat(cachePath); err == nil {\n\t\t// Check if cache is still valid\n\t\tfileInfo, _ := os.Stat(cachePath)\n\t\tif time.Now().Sub(fileInfo.ModTime()) > cacheTTL {\n\t\t\treturn nil, errors.New(\"cache expired\")\n\t\t}\n\t\t// Return cached content\n\t\tcontent, _ := os.ReadFile(cachePath)\n\t\treturn content, nil\n\t}\n\n\t// Fetch from URL\n\tresp, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, errors.New(\"non-200 HTTP status\")\n\t}\n\n\t// Save to cache\n\tcontent, _ := io.ReadAll(resp.Body)\n\terr = os.WriteFile(cachePath, content, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Implement a WorkWeiXin struct in Go that interacts with the WeChat Work API to send messages and manage authentication tokens.\n\nStruct Description: The WorkWeiXin struct represents a client for interacting with WeChat Work's API, handling authentication and message sending functionality.\n\nFields:\nCorpID: string - The corporation ID for WeChat Work authentication\nAgentID: string - The application agent ID for message sending\nCorpSecret: string - The corporation secret for authentication\nToken: string - The access token for API requests (may be empty initially)\n\nMethods:\ngetToken: () -> (string, error) - Retrieves an access token from WeChat Work API using CorpID and CorpSecret. Returns the token or an error.\nSend: (receivers []string, title string, content []byte, others ...string) -> error - Sends a markdown message to specified receivers via WeChat Work API. Handles token retrieval if needed. Returns nil on success or an error.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype WorkWeiXin struct {\n\tCorpID     string `json:\"corpId\"`\n\tAgentID    string `json:\"agentId\"`\n\tCorpSecret string `json:\"corpSecret\"`\n\tToken      string `json:\"token\"`\n}\n\nfunc (w WorkWeiXin) Send(receivers []string, title string, content []byte, others ...string) error {\n\tif w.Token == \"\" {\n\t\ttoken, err := w.getToken()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Token = token\n\t}\n\n\treqBody := make(map[string]interface{})\n\treqBody[\"msgtype\"] = \"markdown\"\n\n\ttoUser := \"\"\n\tfor _, v := range receivers {\n\t\ttoUser = v + \"|\"\n\t}\n\treqBody[\"touser\"] = toUser\n\treqBody[\"agentid\"] = w.AgentID\n\tmarkdown := make(map[string]string)\n\tmarkdown[\"content\"] = string(content)\n\treqBody[\"markdown\"] = markdown\n\tdata, _ := json.Marshal(reqBody)\n\tbody := strings.NewReader(string(data))\n\treq, err := http.NewRequest(\n\t\thttp.MethodPost,\n\t\tfmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s\", w.Token),\n\t\tbody,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tre, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t} else {\n\t\tresult := make(map[string]interface{})\n\t\tif err := json.Unmarshal([]byte(re), &result); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif result[\"errcode\"].(float64) == 0 {\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn errors.New(result[\"errmsg\"].(string))\n\t\t}\n\t}\n}\n\nfunc (w WorkWeiXin) getToken() (string, error) {\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=%s&corpsecret=%s\", w.CorpID, w.CorpSecret)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tre, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t} else {\n\t\tresult := make(map[string]interface{})\n\t\tif err := json.Unmarshal([]byte(re), &result); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif result[\"errcode\"].(float64) == 0 {\n\t\t\treturn result[\"access_token\"].(string), nil\n\t\t} else {\n\t\t\treturn \"\", errors.New(result[\"errmsg\"].(string))\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype WorkWeiXin struct {\n\tCorpID     string\n\tAgentID    string\n\tCorpSecret string\n\tToken      string\n}\n\nfunc (w *WorkWeiXin) getToken() (string, error) {\n\tif w.Token != \"\" {\n\t\treturn w.Token, nil\n\t}\n\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/gettoken?corpid=%s&corpsecret=%s\", w.CorpID, w.CorpSecret)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar result map[string]string\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif result[\"errcode\"] != \"0\" {\n\t\treturn \"\", errors.New(result[\"errmsg\"])\n\t}\n\n\tw.Token = result[\"access_token\"]\n\treturn w.Token, nil\n}\n\nfunc (w *WorkWeiXin) Send(receivers []string, title string, content []byte, others ...string) error {\n\ttoken, err := w.getToken()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\turl := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s\", token)\n\tbody := map[string]interface{}{\n\t\t\"touser\": receivers,\n\t\t\"msgtype\": \"markdown\",\n\t\t\"agentid\": w.AgentID,\n\t\t\"markdown\": map[string]string{\n\t\t\t\"title\":   title,\n\t\t\t\"content\": string(content),\n\t\t},\n\t}\n\n\tfor _, other := range others {\n\t\tparts := strings.Split(other, \":\")\n\t\tif len(parts) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tkey, value := parts[0], parts[1]\n\t\tbody[key] = value\n\t}\n\n\tjsonBody, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t_, err = io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that handles OAuth-based headless authentication by establishing a connection to a server, receiving authentication instructions, and returning a JWT token upon successful authentication.\n\nFunction Description: The `ssoLogin` function establishes a WebSocket connection to a specified endpoint for headless OAuth authentication. It listens for server messages, displays authentication instructions to the user, and waits for the JWT token to be returned. The function handles connection closure and interrupts gracefully.\n\nInput: \n- `endpoint` (string): The URL endpoint of the authentication server (e.g., \"https://example.com\")\n\nOutput: \n- `string`: The JWT authentication token received from the server after successful authentication. Returns an empty string if authentication fails or is interrupted.\n\nNote: The function includes proper error handling and connection cleanup, and it displays the authentication URL to the user when received from the server.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"golang.org/x/exp/slog\"\n)\n\nfunc ssoLogin(endpoint string) string {\n\tvar (\n\t\tauthToken string\n\t\tinterrupt = make(chan os.Signal, 1)\n\t\turl, _    = url.Parse(endpoint)\n\t\tsocketURL = fmt.Sprintf(\"wss://%s/api/oauth/headless\", url.Host)\n\t)\n\tsignal.Notify(interrupt, os.Interrupt)\n\tconn, _, err := websocket.DefaultDialer.Dial(socketURL, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"error connecting to endpoint \", socketURL, err.Error())\n\t}\n\tdefer conn.Close()\n\t_, msg, err := conn.ReadMessage()\n\tif err != nil {\n\t\tlog.Fatal(\"error reading from server: \", err.Error())\n\t}\n\tfmt.Printf(\"Please visit:\\n %s \\n to authenticate\\n\", string(msg))\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tgo func() {\n\t\tfor {\n\t\t\tmsgType, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif msgType < 0 {\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(err.Error(), \"normal\") {\n\t\t\t\t\tlog.Fatal(\"read error: \", err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif msgType == websocket.CloseMessage {\n\t\t\t\tdone <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(string(msg), \"JWT: \") {\n\t\t\t\tauthToken = strings.TrimPrefix(string(msg), \"JWT: \")\n\t\t\t} else {\n\t\t\t\tlogger.Log(0, \"Message from server:\", string(msg))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn authToken\n\t\tcase <-interrupt:\n\t\t\terr := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlogger.Log(0, \"write close:\", err.Error())\n\t\t\t}\n\t\t\treturn authToken\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc ssoLogin(endpoint string) string {\n\tu, err := url.Parse(endpoint)\n\tif err != nil {\n\t\tlog.Println(\"Error parsing endpoint:\", err)\n\t\treturn \"\"\n\t}\n\n\tconn, _, err := upgrader.Upgrade(u, nil, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading to WebSocket:\", err)\n\t\treturn \"\"\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\treturn \"\"\n\t\t}\n\n\t\tif string(message) == \"auth_url\" {\n\t\t\tfmt.Println(\"Please visit the following URL to complete authentication:\")\n\t\t\t// Assuming the server sends the URL in a subsequent message\n\t\t\t// In a real scenario, this would be handled differently\n\t\t\t// For this example, we'll just wait for the token\n\t\t} else if string(message) == \"token\" {\n\t\t\t// Wait for the token message\n\t\t\t_, tokenMsg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error reading token message:\", err)\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn string(tokenMsg)\n\t\t} else if string(message) == \"auth_failed\" {\n\t\t\tlog.Println(\"Authentication failed.\")\n\t\t\treturn \"\"\n\t\t} else if string(message) == \"connection_closed\" {\n\t\t\tlog.Println(\"Connection closed.\")\n\t\t\treturn \"\"\n\t\t}\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a PKCE (Proof Key for Code Exchange) authorization flow in Go that handles OAuth2 token retrieval through a temporary HTTP server.\n\nStruct Description: PKCEAuthorizationFlow represents an OAuth2 authorization flow using PKCE (Proof Key for Code Exchange) mechanism. It manages the state, code verifier, and OAuth configuration needed for the flow, and provides methods to wait for and handle tokens.\n\nFields:\nproviderConfig: [internal.PKCEAuthProviderConfig] - Configuration for the PKCE auth provider\nstate: [string] - CSRF protection state value\ncodeVerifier: [string] - PKCE code verifier string\noAuthConfig: [*oauth2.Config] - OAuth2 configuration including client ID, secret, and endpoints\n\nMethods:\nWaitToken: [Name](ctx context.Context, _ AuthFlowInfo) -> (TokenInfo, error) - Main method that waits for token retrieval by starting a temporary HTTP server and handling the OAuth callback\nstartServer: [Name](server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) - Starts an HTTP server to handle OAuth callback and sends results through channels\nhandleRequest: [Name](req *http.Request) -> (*oauth2.Token, error) - Handles incoming OAuth callback request, validates state, and exchanges code for token",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (p *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\ttokenChan := make(chan *oauth2.Token, 1)\n\terrChan := make(chan error, 1)\n\n\tparsedURL, err := url.Parse(p.oAuthConfig.RedirectURL)\n\tif err != nil {\n\t\treturn TokenInfo{}, fmt.Errorf(\"failed to parse redirect URL: %v\", err)\n\t}\n\n\tserver := &http.Server{Addr: fmt.Sprintf(\":%s\", parsedURL.Port())}\n\tdefer func() {\n\t\tshutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(shutdownCtx); err != nil {\n\t\t\tlog.Errorf(\"failed to close the server: %v\", err)\n\t\t}\n\t}()\n\n\tgo p.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\treturn p.parseOAuthToken(token)\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tcert := p.providerConfig.ClientCertPair\n\t\tif cert != nil {\n\t\t\ttr := &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\tCertificates: []tls.Certificate{*cert},\n\t\t\t\t},\n\t\t\t}\n\t\t\tsslClient := &http.Client{Transport: tr}\n\t\t\tctx := context.WithValue(req.Context(), oauth2.HTTPClient, sslClient)\n\t\t\treq = req.WithContext(ctx)\n\t\t}\n\n\t\ttoken, err := p.handleRequest(req)\n\t\tif err != nil {\n\t\t\trenderPKCEFlowTmpl(w, err)\n\t\t\terrChan <- fmt.Errorf(\"PKCE authorization flow failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\trenderPKCEFlowTmpl(w, nil)\n\t\ttokenChan <- token\n\t})\n\n\tserver.Handler = mux\n\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\terrChan <- err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\n\tif authError := query.Get(queryError); authError != \"\" {\n\t\tauthErrorDesc := query.Get(queryErrorDesc)\n\t\treturn nil, fmt.Errorf(\"%s.%s\", authError, authErrorDesc)\n\t}\n\n\tif state := query.Get(queryState); subtle.ConstantTimeCompare([]byte(p.state), []byte(state)) == 0 {\n\t\treturn nil, fmt.Errorf(\"invalid state\")\n\t}\n\n\tcode := query.Get(queryCode)\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code\")\n\t}\n\n\treturn p.oAuthConfig.Exchange(\n\t\treq.Context(),\n\t\tcode,\n\t\toauth2.SetAuthURLParam(\"code_verifier\", p.codeVerifier),\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig *internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (f *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\tserver := &http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        http.HandlerFunc(f.handleRequest),\n\t\tTLSConfig:      nil,\n\t\tMaxHeaderSize:  1 << 20,\n\t\tMaxIdleConns:   100,\n\t\tIdleConnTimeout: time.Minute,\n\t}\n\n\ttokenChan := make(chan *oauth2.Token)\n\terrChan := make(chan error)\n\n\tgo f.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, fmt.Errorf(\"context canceled: %v\", ctx.Err())\n\tcase token := <-tokenChan:\n\t\treturn TokenInfo{Token: token}, nil\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (f *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\tif err := server.ListenAndServe(\":8080\", nil); err != nil {\n\t\terrChan <- err\n\t\treturn\n\t}\n}\n\nfunc (f *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\t// Validate state\n\tif req.URL.Query().Get(\"state\") != f.state {\n\t\treturn nil, fmt.Errorf(\"invalid state\")\n\t}\n\n\t// Get code from query parameters\n\tcode := req.URL.Query().Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code parameter\")\n\t}\n\n\t// Exchange code for token\n\ttoken, err := f.oAuthConfig.Exchange(context.Background(), code)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttokenChan <- token\n\treturn token, nil\n}"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that establishes multiple concurrent connections to a WebSocket server, maintains these connections, and handles incoming messages. The client should be able to gracefully handle connection errors and properly close connections when done.\n\nFunction Description: The function establishes WebSocket connections to a specified server endpoint with unique identifiers, maintains these connections in separate goroutines, and continuously reads incoming messages. Each connection includes user identification and authentication parameters in the URL query string.\n\nInput: \n- None (The function uses hardcoded values for demonstration, but could be modified to accept parameters like host, port, path, and connection count)\n\nOutput: \n- None (The function primarily logs its activities and errors to stdout)\n\nNote: The function runs indefinitely until 100,000 connections are established (for testing purposes), with each connection attempt spaced by 1 second. Each connection runs in its own goroutine and includes error handling for both connection establishment and message reading.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n)\n\nfunc Test(t *testing.T) {\n\ti := 0\n\tfor {\n\t\ti++\n\t\tif i == 100000 {\n\t\t\tfmt.Println(\"\u5df2\u7ecf\u4e86\u89e310000\u4e2a\u94fe\u63a5\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tgo func(id int) {\n\t\t\tu := url.URL{Scheme: \"ws\", Host: \"127.0.0.1:8182\", Path: \"/v1/push\", RawQuery: fmt.Sprintf(\"uid=%d&sign=2&time=%d\", id, time.Now().Unix())}\n\t\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"\u94fe\u63a5\u5730\u5740%s,\u5931\u8d25\u539f\u56e0%s\", u.String(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tfor {\n\t\t\t\t_, _, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"ERR_ERR_ERR_ERR_ERR_ERR_read:\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\tconnectionCount = 100000\n\tdelay           = 1 * time.Second\n\tuserID          = \"test_user\"\n\tauthToken       = \"test_token\"\n\tserverURL       = \"ws://example.com/socket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tfor i := 0; i < connectionCount; i++ {\n\t\ttime.Sleep(delay)\n\t\tu, _ := url.Parse(serverURL)\n\t\tq := u.Query()\n\t\tq.Set(\"user_id\", userID)\n\t\tq.Set(\"auth_token\", authToken)\n\t\tu.RawQuery = q.Encode()\n\t\tws, err := upgrader.Upgrade(conn, nil, u)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to upgrade to WebSocket:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(ws, i)\n\t}\n}\n\nfunc handleConnection(ws *websocket.Conn, connID int) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Printf(\"Panic in connection %d: %v\", connID, r)\n\t\t}\n\t\tws.Close()\n\t}()\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from connection %d: %v\", connID, err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received message from connection %d: %s\", connID, message)\n\t}\n}"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a WebSocket client in Go that can establish a connection to a server, handle bidirectional communication (sending and receiving messages), and properly manage connection lifecycle.\n\nStruct Description: The Listener struct represents a WebSocket client that connects to a specified URL, handles message processing with optional schema transformation, and manages concurrent read/write operations.\n\nFields:\n- URL: *url.URL - The WebSocket server URL to connect to\n- Token: string - Authentication token to be included in the connection URL\n- SchemaFunc: func([]byte) (io.Reader, error) - Optional function to transform incoming messages\n- Out: io.Writer - Output writer for received messages\n- InCh: <-chan []byte - Input channel for sending messages to the server\n\nMethods:\n- NewListener: (url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) -> *Listener - Creates a new Listener instance with the specified configuration\n- Listen: (ctx context.Context) -> error - Establishes WebSocket connection, handles concurrent message reading/writing, and manages connection lifecycle until context cancellation or normal closure",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype Listener struct {\n\tURL        *url.URL\n\tToken      string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut        io.Writer\n\tInCh       <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:        url,\n\t\tToken:      token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:        out,\n\t\tInCh:       inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tif l.Token != \"\" {\n\t\tparams := l.URL.Query()\n\t\tparams.Set(\"token\", l.Token)\n\t\tl.URL.RawQuery = params.Encode()\n\t}\n\n\tc, _, err := websocket.DefaultDialer.Dial(l.URL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating websocket connection: %w\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tgrp.Go(func() error {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"error reading from websocket: %w\", err)\n\t\t\t}\n\n\t\t\tvar r io.Reader\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\tr, err = l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = bytes.NewReader(message)\n\t\t\t}\n\n\t\t\tio.Copy(l.Out, r)\n\t\t}\n\t})\n\n\tgrp.Go(func() error {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-l.InCh:\n\t\t\t\tif err := c.WriteMessage(websocket.TextMessage, data); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing to websocket: %w\", err)\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing close message: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\tcase <-done:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t})\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Listener struct {\n\tURL       *url.URL\n\tToken     string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut       io.Writer\n\tInCh      <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:       url,\n\t\tToken:     token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:       out,\n\t\tInCh:      inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tdialer := websocket.DefaultDialer\n\turl := l.URL.String()\n\tif l.Token != \"\" {\n\t\turl += \"&token=\" + l.Token\n\t}\n\tconn, _, err := dialer.Dial(url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif err == websocket.ErrClose {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfmt.Fprintf(l.Out, \"Error reading message: %v\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\tr, err := l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(l.Out, \"Schema function error: %v\\n\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t_, err = io.Copy(r, message)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(l.Out, \"Error writing message: %v\\n\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_, err := l.Out.Write(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(l.Out, \"Error writing message: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor msg := range l.InCh {\n\t\t\terr := conn.WriteMessage(websocket.TextMessage, msg)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(l.Out, \"Error writing message: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\treturn nil\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a WebSocket client in Go that connects to a server, sends periodic messages, receives messages from the server, and handles graceful shutdown upon interruption.\n\nFunction Description: The main function establishes a WebSocket connection to a specified server, sets up message reading and writing routines, and handles interrupt signals for graceful termination. It continuously sends timestamp messages at regular intervals while concurrently listening for incoming messages from the server.\n\nInput:\n- Command line argument (flag): addr - string - WebSocket server address (e.g., \"localhost:8080\")\n- Implicit input: System interrupt signal (SIGINT)\n\nOutput:\n- Console logs: Connection status, received messages, and error messages\n- WebSocket messages: Sends timestamp messages to server and receives messages from server\n- Return value: None (program runs until interrupted)\n\nNote: The function uses goroutines for concurrent operations and channels for synchronization and interrupt handling.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tu := url.URL{Scheme: \"ws\", Host: *addr, Path: \"/echo\"}\n\tlog.Printf(\"connecting to %s\", u.String())\n\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"dial:\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"recv: %s\", message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn\n\t\tcase t := <-ticker.C:\n\t\t\terr := c.WriteMessage(websocket.TextMessage, []byte(t.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"interrupt\")\n\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write close:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar addr = flag.String(\"addr\", \"localhost:8080\", \"WebSocket server address\")\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tflag.Parse()\n\tu := url.URL{\n\t\tScheme: \"ws\",\n\t\tHost:   *addr,\n\t\tPath:   \"/ws\",\n\t}\n\tlog.SetPrefix(\"WebSocketClient: \")\n\tlog.SetFlags(0)\n\n\tconn, _, err := upgrader.Upgrade(os.Stdin, os.Stdout, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"upgrade:\", err)\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan bool)\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tsendChan := make(chan string, 10)\n\treceiveChan := make(chan string, 10)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-interrupt:\n\t\t\t\tdone <- true\n\t\t\t\treturn\n\t\t\tcase msg := <-sendChan:\n\t\t\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treceiveChan <- string(message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(2 * time.Second)\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tmsg := fmt.Sprintf(\"timestamp: %v\", time.Now().UnixNano())\n\t\t\tsendChan <- msg\n\t\tcase <-done:\n\t\t\tlog.Println(\"Gracefully shutting down...\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor msg := range receiveChan {\n\t\tlog.Println(\"Received:\", msg)\n\t}\n}"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: The task involves testing a WebSocket connection to a runtime service, verifying the connection establishment, message exchange, and validating the received runtime information against expected values.\n\nFunction Description: The function `TestRuntimeGetRuntime` tests the WebSocket-based communication with a runtime service. It establishes a connection, sends a request message, receives and parses the response, then validates the response contents including protocol, version, capabilities, and runtime ID.\n\nInput: \n- None (This is a test function that takes a testing.T pointer as per Go testing conventions)\n\nOutput: \n- None (The function reports errors through the testing.T parameter if any assertions fail)\n- Side effect: The test will pass if all validations succeed or fail with appropriate error messages if any checks don't match expected values",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\tensureRuntimeStarted()\n\tws, _, err := websocket.DefaultDialer.Dial(\"ws://localhost:13014/\", nil)\n\tdefer ws.Close()\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif err = sendJSONE(ws, &Message{\"runtime\", \"getruntime\", nil}); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tvar msg runtimeMessage\n\tvar bytes []byte\n\tif _, bytes, err = ws.ReadMessage(); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif err = json.Unmarshal(bytes, &msg); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif msg.Protocol != \"runtime\" || msg.Command != \"runtime\" {\n\t\tt.Errorf(\"Invalid protocol (%s) or command (%s)\", msg.Protocol, msg.Command)\n\t\treturn\n\t}\n\tres := msg.Payload\n\tif res.Type != \"goflow\" {\n\t\tt.Errorf(\"Invalid protocol type: %s\\n\", res.Type)\n\t}\n\tif res.Version != \"0.4\" {\n\t\tt.Errorf(\"Invalid protocol version: %s\\n\", res.Version)\n\t}\n\tif len(res.Capabilities) != 5 {\n\t\tt.Errorf(\"Invalid number of supported capabilities: %v\\n\", res.Capabilities)\n\t}\n\tif res.Id == \"\" {\n\t\tt.Error(\"Runtime Id is empty\")\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package yourpackage\n\nimport (\n\t\"testing\"\n\t\"github.com/gorilla/websocket\"\n\t\"fmt\"\n\t\"strings\"\n\t\"encoding/json\"\n)\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\t// Establish WebSocket connection\n\tconn, _, err := websocket.DefaultDialer.Dial(\"ws://localhost:8080\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Send request message\n\trequest := map[string]string{\"action\": \"getRuntime\"}\n\terr = conn.WriteJSON(request)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to send request: %v\", err)\n\t}\n\n\t// Receive response\n\tvar response map[string]interface{}\n\terr = conn.ReadJSON(&response)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read response: %v\", err)\n\t}\n\n\t// Validate response\n\texpectedProtocol := \"HTTP/1.1\"\n\texpectedVersion := \"1.0.0\"\n\texpectedCapabilities := []string{\"capability1\", \"capability2\"}\n\texpectedRuntimeID := \"runtime-123\"\n\n\t// Check protocol\n\tif response[\"protocol\"] != expectedProtocol {\n\t\tt.Errorf(\"Expected protocol %s, got %s\", expectedProtocol, response[\"protocol\"])\n\t}\n\n\t// Check version\n\tif response[\"version\"] != expectedVersion {\n\t\tt.Errorf(\"Expected version %s, got %s\", expectedVersion, response[\"version\"])\n\t}\n\n\t// Check capabilities\n\tif len(response[\"capabilities\"].([]string)) != len(expectedCapabilities) {\n\t\tt.Errorf(\"Expected %d capabilities, got %d\", len(expectedCapabilities), len(response[\"capabilities\"].([]string)))\n\t} else {\n\t\tfor i, cap := range expectedCapabilities {\n\t\t\tif response[\"capabilities\"].([]string)[i] != cap {\n\t\t\t\tt.Errorf(\"Expected capability %d: %s, got %s\", i, cap, response[\"capabilities\"].([]string)[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check runtime ID\n\tif response[\"runtimeID\"] != expectedRuntimeID {\n\t\tt.Errorf(\"Expected runtime ID %s, got %s\", expectedRuntimeID, response[\"runtimeID\"])\n\t}\n\n\tt.Log(\"Test passed\")\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a WebSocket client in Go that connects to a server, handles incoming messages, and manages connection lifecycle including reconnection logic and graceful shutdown.\n\nFunction Description: The function establishes a WebSocket connection to a specified server endpoint, listens for incoming messages, and prints them to stdout/stderr based on message content. It handles connection errors by implementing automatic reconnection logic and supports graceful shutdown upon receiving an interrupt signal.\n\nInput: None (uses package-level configuration variables for connection details)\n\nOutput: None (writes directly to stdout/stderr, logs to console)\n\nNote: The function relies on several external configuration variables:\n- config.Config.Tap.Proxy.Host (string) - Server hostname\n- config.Config.Tap.Proxy.Front.Port (int) - Server port\n- config.Config.License (string) - License key for authentication\n- kubernetes.GetHubUrl() (string) - Function to get hub URL for health checks",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/kubeshark/kubeshark/config\"\n\t\"github.com/kubeshark/kubeshark/utils\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc runConsoleWithoutProxy() {\n\tlog.Info().Msg(\"Starting scripting console ...\")\n\ttime.Sleep(5 * time.Second)\n\thubUrl := kubernetes.GetHubUrl()\n\tfor {\n\t\tresponse, err := http.Get(fmt.Sprintf(\"%s/echo\", hubUrl))\n\t\tif err != nil || response.StatusCode != 200 {\n\t\t\tlog.Info().Msg(fmt.Sprintf(utils.Yellow, \"Couldn't connect to Hub.\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tinterrupt := make(chan os.Signal, 1)\n\t\tsignal.Notify(interrupt, os.Interrupt)\n\n\t\tlog.Info().Str(\"host\", config.Config.Tap.Proxy.Host).Str(\"url\", hubUrl).Msg(\"Connecting to:\")\n\t\tu := url.URL{\n\t\t\tScheme: \"ws\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%d\", config.Config.Tap.Proxy.Host, config.Config.Tap.Proxy.Front.Port),\n\t\t\tPath:   \"/api/scripts/logs\",\n\t\t}\n\t\theaders := http.Header{}\n\t\theaders.Set(utils.X_KUBESHARK_CAPTURE_HEADER_KEY, utils.X_KUBESHARK_CAPTURE_HEADER_IGNORE_VALUE)\n\t\theaders.Set(\"License-Key\", config.Config.License)\n\n\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), headers)\n\t\tif err != nil {\n\t\t\tlog.Error().Err(err).Msg(\"Websocket dial error, retrying in 5 seconds...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tdefer c.Close()\n\n\t\tdone := make(chan struct{})\n\n\t\tgo func() {\n\t\t\tdefer close(done)\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error().Err(err).Msg(\"Error reading websocket message, reconnecting...\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tmsg := string(message)\n\t\t\t\tif strings.Contains(msg, \":ERROR]\") {\n\t\t\t\t\tmsg = fmt.Sprintf(utils.Red, msg)\n\t\t\t\t\tfmt.Fprintln(os.Stderr, msg)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintln(os.Stdout, msg)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tticker := time.NewTicker(time.Second)\n\t\tdefer ticker.Stop()\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\tlog.Warn().Msg(fmt.Sprintf(utils.Yellow, \"Connection closed, reconnecting...\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\tcase <-interrupt:\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Error().Err(err).Send()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/your/package/config\"\n\t\"github.com/your/package/kubernetes\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\t// Initialize configuration\n\tserverHost := config.Config.Tap.Proxy.Host\n\tserverPort := config.Config.Tap.Proxy.Front.Port\n\tlicenseKey := config.Config.License\n\thubURL := kubernetes.GetHubUrl()\n\n\t// WebSocket connection URL\n\tconnURL := fmt.Sprintf(\"ws://%s:%d\", serverHost, serverPort)\n\tu, err := url.Parse(connURL)\n\tif err != nil {\n\t\tlog.Fatal(\"Error parsing URL:\", err)\n\t}\n\tu.RawQuery = \"license=\" + licenseKey\n\n\t// Create a context for the connection with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// WebSocket connection\n\tws, _, err := upgrader.Upgrade(ctx, u, nil)\n\tif err != nil {\n\t\tlog.Println(\"Failed to upgrade to WebSocket:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer ws.Close()\n\n\t// Handle interrupt signal for graceful shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Health check loop\n\tgo func() {\n\t\tticker := time.NewTicker(30 * time.Second)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\t// Perform health check using hubURL\n\t\t\t\tresp, err := http.Get(hubURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"Health check failed:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tresp.Body.Close()\n\t\t\t\t\tlog.Println(\"Health check passed\")\n\t\t\t\t}\n\t\t\tcase <-sigChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Message handling loop\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\t// Attempt reconnection\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tws, _, err = upgrader.Upgrade(context.Background(), u, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Failed to reconnect:\", err)\n\t\t\t\ttime.Sleep(10 * time.Second)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Print message based on content\n\t\tif string(message) == \"heartbeat\" {\n\t\t\tlog.Println(\"Received heartbeat\")\n\t\t} else {\n\t\t\tlog.Println(\"Received message:\", string(message))\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a function that handles WebSocket connections by upgrading HTTP connections, reading incoming messages, and forwarding them to a channel for further processing.\n\nFunction Description: The function `makeUpgradeOnConnect` generates and returns an HTTP handler function that upgrades incoming HTTP connections to WebSocket connections. It reads messages from the WebSocket connection and sends them to a provided channel. The WebSocket connection is properly closed when processing is complete.\n\nInput: \n- `ch chan string`: A channel of strings used to forward incoming WebSocket messages for further processing.\n\nOutput: \n- Returns a function of type `func(http.ResponseWriter, *http.Request)` that serves as an HTTP handler for WebSocket connections.\n\nNote: The returned HTTP handler function does not explicitly return any value but handles WebSocket communication and message forwarding internally.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer c.Close()\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tch <- string(message)\n\t\t\t}()\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\nfunc makeUpgradeOnConnect(ch chan string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t}\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error upgrading to WebSocket\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmsgType, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif err == websocket.CloseAbnormalClosure {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\thttp.Error(w, \"Error reading message\", http.StatusInternalServerError)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tch <- string(msg)\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Implement a WebSocket handler for shell communication that manages bidirectional data transfer between local and remote connections, including connection upgrading, message forwarding, and proper connection cleanup.\n\nStruct Description: The Shell struct represents a shell session manager that maintains active connections and handles WebSocket communication for shell data transfer.\n\nFields:\n- Name: string - Identifier for the shell session\n- links: map[string]*Link - Map of active connections indexed by connection ID\n- RWMutex: sync.RWMutex - Synchronization primitive for thread-safe access to the links map\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages bidirectional data forwarding between local and remote connections\n- localForward: (id string, local *websocket.Conn) -> None - Reads data from local WebSocket connection and forwards to remote\n- remoteForward: (id string, local *websocket.Conn) -> None - Reads data from remote connection and forwards to local WebSocket",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype Shell struct {\n\tName string\n\tlinks map[string]*Link\n\tsync.RWMutex\n}\n\nfunc (shell *Shell) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogging.Error(\"upgrade websocket failed: %s, err=%v\", shell.Name, err)\n\t\thttp.Error(w, err.Error(), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tdefer local.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.localForward(id, local)\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.remoteForward(id, local)\n\t}()\n\twg.Wait()\n}\n\nfunc (shell *Shell) localForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"localForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tdefer link.Close(true)\n\tfor {\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"read local data for %s failed: %v\", shell.Name, err)\n\t\t\treturn\n\t\t}\n\t\tlink.SendData(data)\n\t\tlogging.Debug(\"local read %d bytes: name=%s, id=%s\", len(data), shell.Name, id)\n\t}\n}\n\nfunc (shell *Shell) remoteForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tch := link.remote.ChanRead(id)\n\tdefer link.Close(true)\n\tfor {\n\t\tmsg := <-ch\n\t\tif msg == nil {\n\t\t\treturn\n\t\t}\n\t\tdata, _ := proto.Marshal(msg)\n\t\tlink.recvBytes += uint64(len(data))\n\t\tlink.recvPacket++\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_shell_data:\n\t\t\terr := local.WriteMessage(websocket.TextMessage, msg.GetSdata().GetData())\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write data for %s failed: %v\", shell.Name, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogging.Debug(\"remote read %d bytes: name=%s, id=%s\",\n\t\t\t\tlen(msg.GetSdata().GetData()), shell.Name, id)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Link struct {\n\tRemote *websocket.Conn\n}\n\ntype Shell struct {\n\tName      string\n\tlinks     map[string]*Link\n\tRWMutex   sync.RWMutex\n}\n\nfunc (s *Shell) WS(conn *Conn, w http.ResponseWriter, r *http.Request) {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tconnW, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"upgrade error:\", err)\n\t\treturn\n\t}\n\n\t// Create a new link for this connection\n\tlinkID := generateID()\n\ts.RWMutex.Lock()\n\ts.links[linkID] = &Link{Remote: connW}\n\ts.RWMutex.Unlock()\n\n\t// Start forwarding messages in both directions\n\tgo s.localForward(linkID, connW)\n\tgo s.remoteForward(linkID, connW)\n}\n\nfunc (s *Shell) localForward(id string, local *websocket.Conn) {\n\ts.RWMutex.Lock()\n\tlink := s.links[id]\n\ts.RWMutex.Unlock()\n\n\tfor {\n\t\t_, message, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"local forward error:\", err)\n\t\t\treturn\n\t\t}\n\t\t// Forward to remote connection\n\t\tlink.Remote.WriteMessage(websocket.TextMessage, message)\n\t}\n}\n\nfunc (s *Shell) remoteForward(id string, local *websocket.Conn) {\n\ts.RWMutex.Lock()\n\tlink := s.links[id]\n\ts.RWMutex.Unlock()\n\n\tfor {\n\t\t_, message, err := link.Remote.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"remote forward error:\", err)\n\t\t\treturn\n\t\t}\n\t\t// Forward to local connection\n\t\tlocal.WriteMessage(websocket.TextMessage, message)\n\t}\n}\n\nfunc generateID() string {\n\t// Implement ID generation logic here\n\treturn \"conn_\" + fmt.Sprintf(\"%d\", rand.Intn(1000))\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that manages WebSocket connections, including upgrading HTTP connections, reading incoming messages, writing periodic messages, and properly closing the connection.\n\nFunction Description: The `wsHandler` function creates an HTTP handler that upgrades incoming HTTP requests to WebSocket connections. It continuously writes numbered messages to the client while concurrently reading any incoming messages from the client. The function stops after sending a specified number of messages and closes the connection gracefully.\n\nInput:\n- `t *testing.T`: Testing context for error reporting\n- `recvBuffer *bytes.Buffer`: Buffer to store received messages from the WebSocket client\n\nOutput:\n- Returns an `http.HandlerFunc` that implements the WebSocket handling logic\n\nNote: The function doesn't directly return values but rather creates a handler function that manages WebSocket communication through the provided buffer and testing context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\trequire.NoError(t, err)\n\t\tdefer c.Close()\n\t\ti := 0\n\t\tfinish := 5\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\n\t\t\ti++\n\t\t\tdata := struct {\n\t\t\t\tMessage string `json:\"message\"`\n\t\t\t}{\n\t\t\t\tMessage: fmt.Sprintf(\"%d\\n\", i),\n\t\t\t}\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := json.NewEncoder(buf).Encode(data)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = c.WriteMessage(websocket.TextMessage, buf.Bytes())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif i == finish {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\terr = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\trequire.NoError(t, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, _, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n\t\tif err != nil {\n\t\t\tt.Log(\"Error upgrading to WebSocket:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tmsgCount := 0\n\t\tmaxMsgs := 5\n\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Log(\"Error reading message:\", err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\n\t\tfor msgCount < maxMsgs {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tmsgCount++\n\t\t\tmsg := fmt.Sprintf(\"Message %d\", msgCount)\n\t\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t\t}\n\n\t\tconn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"Connection closed\"))\n\t}\n}"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Implement a WebSocket server for RDP (Remote Desktop Protocol) connections using the Gorilla WebSocket library in Go. The server should handle WebSocket connections, manage RDP sessions through a Guacamole tunnel, and support bidirectional communication between the client and the RDP server.\n\nStruct Description: The RDPServer struct represents an RDP WebSocket server that manages WebSocket connections and RDP sessions via Guacamole tunnels.\n\nFields:\n- Session: *session.SSession - The current user session information\n- Host: string - The RDP server host address\n- Port: int - The RDP server port number\n- Username: string - The username for RDP authentication\n- Password: string - The password for RDP authentication\n- ConnectionId: string - Unique identifier for the RDP connection\n- Width: int - The screen width for the RDP session\n- Height: int - The screen height for the RDP session\n- Dpi: int - The DPI setting for the RDP session\n\nMethods:\n- ServeHTTP: (w http.ResponseWriter, r *http.Request) -> None - Handles HTTP requests by upgrading them to WebSocket connections, establishing a Guacamole tunnel, and managing bidirectional communication between the client and RDP server. This method implements the http.Handler interface.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"yunion.io/x/log\"\n\t\"yunion.io/x/pkg/errors\"\n\n\t\"yunion.io/x/onecloud/pkg/webconsole/guac\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/options\"\n\t\"yunion.io/x/onecloud/pkg/webconsole/session\"\n)\n\ntype RDPServer struct {\n\tSession *session.SSession\n\n\tHost         string\n\tPort         int\n\tUsername     string\n\tPassword     string\n\tConnectionId string\n\n\tWidth  int\n\tHeight int\n\tDpi    int\n}\n\nfunc (s *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar up = websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tws, err := up.Upgrade(w, r, http.Header{\"Sec-Websocket-Protocol\": []string{\n\t\tr.Header.Get(\"Sec-Websocket-Protocol\"),\n\t}})\n\tif err != nil {\n\t\tlog.Errorf(\"upgrade error: %v\", err)\n\t\treturn\n\t}\n\n\tdefer ws.Close()\n\n\ttunnel, err := guac.NewGuacamoleTunnel(\n\t\ts.Host,\n\t\ts.Port,\n\t\ts.Username,\n\t\ts.Password,\n\t\ts.ConnectionId,\n\t\ts.Width,\n\t\ts.Height,\n\t\ts.Dpi,\n\t\ts.Session.GetClientSession().GetUserId(),\n\t)\n\tif err != nil {\n\t\tlog.Errorf(\"NewGuacamoleTunnel error: %v\", err)\n\t\treturn\n\t}\n\n\terr = tunnel.Start()\n\tif err != nil {\n\t\tlog.Errorf(\"Start error: %v\", err)\n\t\treturn\n\t}\n\n\tdone := make(chan bool, 4)\n\ttimer := time.NewTimer(time.Microsecond * 100)\n\tsetDone := func() {\n\t\tdone <- true\n\t}\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tins, err := tunnel.ReadOne()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\terr = ws.WriteMessage(websocket.TextMessage, []byte(ins.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd %s: %v\", ins.String(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\t\tdefer tunnel.Stop()\n\n\t\tfor {\n\t\t\t_, p, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Errorf(\"read message error %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 && timer != nil {\n\t\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t\t}\n\t\t\t_, err = tunnel.Write(p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed writing to guacd: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tstop := make(chan bool)\n\tgo func() {\n\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\ttimer.Reset(time.Duration(options.Options.RdpSessionTimeoutMinutes) * time.Minute)\n\t\t}\n\t\tdefer timer.Stop()\n\t\tdefer setDone()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\tcase <-timer.C:\n\t\t\t\tif options.Options.RdpSessionTimeoutMinutes > 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttimer.Reset(time.Microsecond * 100)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer setDone()\n\n\t\terr = tunnel.Wait()\n\t\tif err != nil && errors.Cause(err) != guac.TunnerClose {\n\t\t\tlog.Errorf(\"wait error: %v\", err)\n\t\t}\n\t}()\n\n\t<-done\n\tstop <- true\n\tlog.Infof(\"rdp %s@%s:%d complete\", s.Username, s.Host, s.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/guacamole/guacamole\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype RDPServer struct {\n\tSession     *session.SSession\n\tHost        string\n\tPort        int\n\tUsername    string\n\tPassword    string\n\tConnectionId string\n\tWidth       int\n\tHeight      int\n\tDpi         int\n}\n\nfunc (s *RDPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error upgrading to WebSocket:\", err)\n\t\treturn\n\t}\n\n\t// Establish Guacamole tunnel\n\tguacClient, err := guacamole.NewClient(s.Host, s.Port, s.Username, s.Password, s.ConnectionId, s.Width, s.Height, s.Dpi)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating Guacamole client:\", err)\n\t\tconn.Close()\n\t\treturn\n\t}\n\n\t// Handle bidirectional communication\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tguacClient.Send(message)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tmessage, err := guacClient.Receive()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error receiving message:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconn.WriteMessage(websocket.TextMessage, message)\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a WebSocket proxy struct in Go that can handle WebSocket connections by forwarding messages between a client and a backend server.\n\nStruct Description: The `WebsocketProxy` struct is a reverse proxy for WebSocket connections. It upgrades incoming HTTP connections to WebSocket, connects to a backend WebSocket server, and forwards messages bidirectionally between the client and backend.\n\nFields:\n- Director: `func(incoming *http.Request, out http.Header)` - Optional function to modify the request headers before connecting to the backend.\n- Backend: `func(*http.Request) *url.URL` - Required function that returns the backend URL to connect to.\n- Upgrader: `*websocket.Upgrader` - Optional WebSocket upgrader configuration for client connections.\n- Dialer: `*websocket.Dialer` - Optional WebSocket dialer configuration for backend connections.\n\nMethods:\n- ServeHTTP: `(rw http.ResponseWriter, req *http.Request)` -> `None` - Main handler method that implements the http.Handler interface. It upgrades the client connection, connects to the backend, and sets up bidirectional message forwarding.\n  - Input Parameters:\n    - rw: `http.ResponseWriter` - The HTTP response writer\n    - req: `*http.Request` - The HTTP request\n  - Description: Handles the WebSocket proxy logic including connection upgrading, backend dialing, and message replication between client and backend.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n\t\tif prior, ok := req.Header[\"X-Forwarded-For\"]; ok {\n\t\t\tclientIP = strings.Join(prior, \", \") + \", \" + clientIP\n\t\t}\n\t\trequestHeader.Set(\"X-Forwarded-For\", clientIP)\n\t}\n\n\trequestHeader.Set(\"X-Forwarded-Proto\", \"http\")\n\tif req.TLS != nil {\n\t\trequestHeader.Set(\"X-Forwarded-Proto\", \"https\")\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\treplicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) {\n\t\tfor {\n\t\t\tmsgType, msg, err := src.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\t\tif e, ok := err.(*websocket.CloseError); ok {\n\t\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terrc <- err\n\t\t\t\tdst.WriteMessage(websocket.CloseMessage, m)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = dst.WriteMessage(msgType, msg)\n\t\t\tif err != nil {\n\t\t\t\terrc <- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\tif e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure {\n\t\tlog.Printf(message, err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector  func(*http.Request, http.Header)\n\tBackend   func(*http.Request) *url.URL\n\tUpgrader  *websocket.Upgrader\n\tDialer    *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif p.Upgrader == nil {\n\t\tp.Upgrader = &websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t}\n\t}\n\n\t// Upgrade the HTTP connection to WebSocket\n\tconn, err := p.Upgrader.Upgrade(rw, req, nil)\n\tif err != nil {\n\t\thttp.Error(rw, \"upgrade failed\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Get backend URL\n\tbackendURL := p.Backend(req)\n\tif backendURL == nil {\n\t\thttp.Error(rw, \"no backend URL provided\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Create a dialer if not provided\n\tif p.Dialer == nil {\n\t\tp.Dialer = &websocket.Dialer{\n\t\t\tHandshakeTimeout: 10 * time.Second,\n\t\t}\n\t}\n\n\t// Connect to backend\n\tbackendConn, _, err := p.Dialer.Dial(backendURL.String(), nil)\n\tif err != nil {\n\t\thttp.Error(rw, \"dial to backend failed\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Forward messages from client to backend\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbackendConn.WriteMessage(websocket.TextMessage, msg)\n\t\t}\n\t}()\n\n\t// Forward messages from backend to client\n\tgo func() {\n\t\tfor {\n\t\t\t_, msg, err := backendConn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconn.WriteMessage(websocket.TextMessage, msg)\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Implement a WebSocket server function in Go that handles client connections, manages online users, and periodically sends server statistics to connected clients.\n\nFunction Description: The `serverStream` function establishes a WebSocket connection with a client, registers the user in an online user tracking system, and continuously sends server statistics at regular intervals. It handles connection upgrades, user authentication, and graceful connection closure.\n\nInput:\n- `c *gin.Context`: Gin framework context object containing HTTP request information and writer for response\n\nOutput:\n- `any`: Placeholder return value (always nil in this implementation)\n- `error`: Error object indicating connection termination reason (wrapped in custom WsError type)\n\nThe function performs the following operations:\n1. Generates a unique connection ID\n2. Upgrades HTTP connection to WebSocket\n3. Extracts user IP and authentication info\n4. Registers user in online tracking system\n5. Periodically sends server statistics\n6. Handles connection cleanup on exit",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/url\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/nezhahq/nezha/model\"\n\t\"github.com/nezhahq/nezha/service/singleton\"\n)\n\nvar upgrader *websocket.Upgrader\n\nfunc serverStream(c *gin.Context) (any, error) {\n\tconnId, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\treturn nil, newWsError(\"%v\", err)\n\t}\n\tdefer conn.Close()\n\n\tuserIp := c.GetString(model.CtxKeyRealIPStr)\n\tif userIp == \"\" {\n\t\tuserIp = c.RemoteIP()\n\t}\n\n\tu, isMember := c.Get(model.CtxKeyAuthorizedUser)\n\tvar userId uint64\n\tif isMember {\n\t\tuserId = u.(*model.User).ID\n\t}\n\n\tsingleton.AddOnlineUser(connId, &model.OnlineUser{\n\t\tUserID:      userId,\n\t\tIP:          userIp,\n\t\tConnectedAt: time.Now(),\n\t\tConn:        conn,\n\t})\n\tdefer singleton.RemoveOnlineUser(connId)\n\n\tcount := 0\n\tfor {\n\t\tstat, err := getServerStat(count == 0, isMember)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.WriteMessage(websocket.TextMessage, stat); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tcount += 1\n\t\tif count%4 == 0 {\n\t\t\terr = conn.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\t}\n\treturn nil, newWsError(\"\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype WsError struct {\n\tCode    int\n\tMessage string\n}\n\nfunc (e *WsError) Error() string {\n\treturn e.Message\n}\n\nfunc serverStream(c *gin.Context) any {\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, map[string]string{\"error\": \"WebSocket upgrade failed\"})\n\t\treturn &WsError{Code: 500, Message: \"WebSocket upgrade failed\"}\n\t}\n\tdefer conn.Close()\n\n\t// Generate unique connection ID\n\tconnectionID := generateConnectionID()\n\n\t// Extract user IP and authentication info\n\tuserIP := c.ClientIP()\n\t// Assume authentication is handled elsewhere, here we just use a placeholder\n\tuserAuth := \"user123\"\n\n\t// Register user in online tracking system\n\tregisterOnlineUser(connectionID, userIP, userAuth)\n\n\t// Periodically send server statistics\n\tgo func() {\n\t\tticker := time.NewTicker(5 * time.Second)\n\t\tfor range ticker.C {\n\t\t\tstats := getServerStatistics()\n\t\t\tif err := sendServerStats(conn, stats); err != nil {\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to send server stats\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Handle connection cleanup on exit\n\tgo func() {\n\t\t<-conn.CloseChan\n\t\tunregisterOnlineUser(connectionID)\n\t}()\n}\n\nfunc generateConnectionID() string {\n\t// Implement unique ID generation logic\n\treturn \"conn12345\"\n}\n\nfunc registerOnlineUser(id, ip, auth string) {\n\t// Implement online user registration logic\n}\n\nfunc unregisterOnlineUser(id string) {\n\t// Implement online user unregistration logic\n}\n\nfunc getServerStatistics() map[string]interface{} {\n\t// Implement server statistics gathering logic\n\treturn map[string]interface{}{\n\t\t\"users_online\": 10,\n\t\t\"last_active\":  \"2023-10-05T12:00:00Z\",\n\t}\n}\n\nfunc sendServerStats(conn *websocket.Conn, stats map[string]interface{}) error {\n\tmessage, _ := json.Marshal(stats)\n\tif err := conn.Send(message); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, manages WebSocket connections, and handles message reading.\n\nFunction Description: The function `NotifyWS` handles WebSocket connections by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It adds the new WebSocket connection to a global list of connections and ensures a message-sending service is running. The function then continuously reads messages from the WebSocket connection until it is closed.\n\nInput: \n- `ctx echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails, otherwise returns `nil` after the WebSocket connection is closed.\n\nNote: The function does not explicitly return any output other than potential errors, but it interacts with global state (`service.WebSocketConns` and `service.SocketRun`) and performs I/O operations on the WebSocket connection.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upGrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdefer ws.Close()\n\tservice.WebSocketConns = append(service.WebSocketConns, ws)\n\n\tif !service.SocketRun {\n\t\tservice.SocketRun = true\n\t\tservice.SendMeg()\n\t}\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tfmt.Println(mt, message, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tconn, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tservice.WebSocketConns = append(service.WebSocketConns, conn)\n\tgo service.SocketRun()\n\tfor {\n\t\t_, _, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Implement a WebSocket handler for VNC (Virtual Network Computing) functionality that enables remote desktop interaction through a WebSocket connection, including image transmission, clipboard sharing, and input event handling.\n\nStruct Description: The VNC struct represents a VNC over WebSocket handler that manages the connection between a client and a remote VNC server, facilitating bidirectional communication for remote desktop operations.\n\nFields:\n- link: *network.Link - Represents the network link to the remote VNC server\n- chClipboard: chan string - Channel for transmitting clipboard content between client and server\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages the VNC session lifecycle\n- remoteRead: (ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) -> None - Processes incoming messages from the remote VNC server\n- localRead: (ctx context.Context, local *websocket.Conn, remote *conn.Conn) -> None - Handles messages received from the WebSocket client\n- mouseEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse movement and click events\n- keyboardEvent: (remote *conn.Conn, data []byte) -> None - Handles keyboard input events\n- cadEvent: (remote *conn.Conn) -> None - Manages Ctrl+Alt+Del special key combination\n- scrollEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse scroll wheel events",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/jpeg\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/runtime\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype VNC struct {\n\tlink         *network.Link\n\tchClipboard  chan string\n}\n\nfunc (v *VNC) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer local.Close()\n\tch := conn.ChanRead(id)\n\tdefer conn.SendDisconnect(v.link.target, v.link.id)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.remoteRead(ctx, ch, local)\n\t}()\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.localRead(ctx, local, conn)\n\t}()\n\twg.Wait()\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteRead\")\n\tfor {\n\t\tvar msg *network.Msg\n\t\tselect {\n\t\tcase msg = <-ch:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_vnc_image:\n\t\t\tdata, err := decodeImage(msg.GetVimg())\n\t\t\truntime.Assert(err)\n\t\t\treplyImage(local, msg.GetVimg(), data, len(msg.GetVimg().GetData()))\n\t\tcase network.Msg_vnc_clipboard:\n\t\t\tv.chClipboard <- msg.GetVclipboard()\n\t\tdefault:\n\t\t\tlogging.Error(\"on message: %s\", msg.GetXType().String())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *conn.Conn) {\n\tdefer utils.Recover(\"localRead\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"local read: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg struct {\n\t\t\tAction string `json:\"action\"`\n\t\t}\n\t\terr = json.Unmarshal(data, &msg)\n\t\tif err != nil {\n\t\t\tlogging.Error(\"unmarshal: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch msg.Action {\n\t\tcase \"mouse\":\n\t\t\tv.mouseEvent(remote, data)\n\t\tcase \"keyboard\":\n\t\t\tv.keyboardEvent(remote, data)\n\t\tcase \"cad\":\n\t\t\tv.cadEvent(remote)\n\t\tcase \"scroll\":\n\t\t\tv.scrollEvent(remote, data)\n\t\t}\n\t}\n}\n\nfunc decodeImage(data *network.VncImage) ([]byte, error) {\n\tswitch data.GetEncode() {\n\tcase network.VncImage_raw:\n\t\treturn data.GetData(), nil\n\tcase network.VncImage_jpeg:\n\t\timg, err := jpeg.Decode(bytes.NewReader(data.GetData()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trect := img.Bounds()\n\t\traw := image.NewRGBA(rect)\n\t\tdraw.Draw(raw, rect, img, rect.Min, draw.Src)\n\t\treturn raw.Pix, nil\n\tcase network.VncImage_png:\n\t}\n\treturn nil, errors.New(\"unsupported\")\n}\n\nfunc replyImage(conn *websocket.Conn, msg *network.VncImage, data []byte, srcSize int) {\n\tinfo := msg.GetXInfo()\n\tbuf := make([]byte, len(data)+28)\n\tbinary.BigEndian.PutUint32(buf, info.GetScreenWidth())\n\tbinary.BigEndian.PutUint32(buf[4:], info.GetScreenHeight())\n\tbinary.BigEndian.PutUint32(buf[8:], info.GetRectX())\n\tbinary.BigEndian.PutUint32(buf[12:], info.GetRectY())\n\tbinary.BigEndian.PutUint32(buf[16:], info.GetRectWidth())\n\tbinary.BigEndian.PutUint32(buf[20:], info.GetRectHeight())\n\tbinary.BigEndian.PutUint32(buf[24:], uint32(srcSize))\n\tcopy(buf[28:], data)\n\tconn.WriteMessage(websocket.BinaryMessage, buf)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "package vnc\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/your/package/network\"\n)\n\ntype VNC struct {\n\tlink          *network.Link\n\tchClipboard   chan string\n\tmu            sync.Mutex\n\tconnected     bool\n\tremoteConn    *network.Conn\n\tlocalConn     *websocket.Conn\n}\n\nfunc (v *VNC) WS(conn *network.Conn, w http.ResponseWriter, r *http.Request) {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tlocalConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tv.localConn = localConn\n\tv.connected = true\n\tgo v.remoteRead(context.Background(), v.link.MsgCh, localConn)\n\tgo v.localRead(context.Background(), localConn, v.remoteConn)\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tfor msg := range ch {\n\t\tswitch msg.Type {\n\t\tcase network.MsgTypeImage:\n\t\t\terr := local.Send(msg.Data)\n\t\t\tif err != nil {\n\t\t\t\t// Handle error\n\t\t\t}\n\t\tcase network.MsgTypeClipboard:\n\t\t\tv.chClipboard <- string(msg.Data)\n\t\tcase network.MsgTypeMouseEvent:\n\t\t\tv.mouseEvent(v.remoteConn, msg.Data)\n\t\tcase network.MsgTypeKeyEvent:\n\t\t\tv.keyboardEvent(v.remoteConn, msg.Data)\n\t\tcase network.MsgTypeCadleEvent:\n\t\t\tv.cadEvent(v.remoteConn)\n\t\tcase network.MsgTypeScrollEvent:\n\t\t\tv.scrollEvent(v.remoteConn, msg.Data)\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *network.Conn) {\n\tfor {\n\t\t_, msg, err := local.Receive()\n\t\tif err != nil {\n\t\t\t// Handle error\n\t\t\tbreak\n\t\t}\n\t\tremote.Send(msg)\n\t}\n}\n\nfunc (v *VNC) mouseEvent(remote *network.Conn, data []byte) {\n\t// Process mouse movement and click events\n}\n\nfunc (v *VNC) keyboardEvent(remote *network.Conn, data []byte) {\n\t// Handle keyboard input events\n}\n\nfunc (v *VNC) cadEvent(remote *network.Conn) {\n\t// Manage Ctrl+Alt+Del special key combination\n}\n\nfunc (v *VNC) scrollEvent(remote *network.Conn, data []byte) {\n\t// Process mouse scroll wheel events\n}"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Implement a WebSocket echo server function in Go that handles WebSocket connections, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The `echo` function upgrades an HTTP connection to a WebSocket connection, continuously reads messages from the client, and echoes them back. It handles connection errors and ensures proper cleanup by closing the connection when done.\n\nInput: \n- `ctx *gin.Context`: A Gin context object containing the HTTP request and response writer needed for WebSocket upgrade.\n\nOutput: \n- None (void function), but it performs the following operations:\n  - Upgrades the HTTP connection to WebSocket\n  - Reads and echoes messages until connection is closed\n  - Handles and logs errors\n  - Closes the WebSocket connection when done",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc echo(ctx *gin.Context) {\n\tw,r := ctx.Writer, ctx.Request\n\tc, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv:%s\", message)\n\t\terr = c.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "func echo(ctx *gin.Context) {\n\tserveMux := http.NewServeMux()\n\tserveMux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tupgrader := websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t}\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Upgrade error:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Read error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := conn.WriteMessage(websocket.TextMessage, message); err != nil {\n\t\t\t\tlog.Println(\"Write error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\thttp.ListenAndServe(\":8080\", serveMux)\n}"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Implement a Go struct that tests the health of an NTP (Network Time Protocol) server by checking its stratum level through UDP communication.\n\nStruct Description: The NtpHealthTester struct is responsible for verifying the health of an NTP server by establishing a UDP connection, sending a query, and validating the server's response based on its stratum level. The struct includes methods for testing the server and providing a string representation of the maximum allowed stratum.\n\nFields:\nmaxStratum: int - The maximum acceptable stratum level for the NTP server to be considered healthy.\n\nMethods:\nTest: (ht *HealthTest) -> bool - Tests the health of an NTP server by sending a UDP packet and validating the response. Returns true if the server's stratum is within the acceptable range, false otherwise.\nString: () -> string - Returns a string representation of the maximum allowed stratum level.\nnewNtpHealthTester: (params map[string]interface{}, htp *HealthTestParameters) -> HealthTester - A constructor function that creates a new NtpHealthTester instance with the specified maximum stratum level.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (t *NtpHealthTester) Test(ht *HealthTest) bool {\n\tudpAddress, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(ht.ipAddress.String(), \"123\"))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdata := make([]byte, 48)\n\tdata[0] = 4<<3 | 3\n\n\tconn, err := net.DialUDP(\"udp\", nil, udpAddress)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(ht.timeout))\n\n\t_, err = conn.Read(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := data[1]\n\n\tif stratum == 0 || stratum > byte(t.maxStratum) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (t *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"%d\", t.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := 3\n\tif v, ok := params[\"max_stratum\"]; ok {\n\t\tmaxStratum = typeutil.ToInt(v)\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype HealthTester interface {\n\tTest() bool\n\tString() string\n}\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (ht *NtpHealthTester) Test() bool {\n\t// UDP client to send NTP query\n\tconn, err := net.Dial(\"udp\", \"127.0.0.1:123\")\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer conn.Close()\n\n\t// NTP request packet (simplified)\n\trequest := []byte{0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\t_, err = conn.Write(request)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// Read response\n\tbuffer := make([]byte, 48)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// Extract stratum from response (simplified)\n\tstratum := int(buffer[16])\n\treturn stratum <= ht.maxStratum\n}\n\nfunc (ht *NtpHealthTester) String() string {\n\treturn \"Max allowed stratum: \" + string(ht.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := htp.MaxStratum\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Implement a UDP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and connection management.\n\nStruct Description: The Client struct represents a UDP client for communicating with KDC servers. It maintains configuration and provides methods for sending data over UDP.\n\nFields:\n\nConfig: [*Config] - Configuration object containing KDC server information and settings\n\nMethods:\n\nsendKDCUDP: [func(realm string, b []byte) -> ([]byte, error)] - Sends data to a KDC server over UDP for a specific realm. Returns the response or error.\ndialKDCUDP: [func(count int, kdcs map[int]string) -> (*net.UDPConn, error)] - Internal method to establish UDP connection to a KDC server from a list of addresses. Returns the connection or error.\nsendUDP: [func(conn *net.UDPConn, b []byte) -> ([]byte, error)] - Internal method to send data over an established UDP connection and read the response. Returns the response data or error.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\tcount, kdcs, err := cl.Config.GetKDCs(realm, false)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tconn, err := dialKDCUDP(count, kdcs)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = cl.sendUDP(conn, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialKDCUDP(count int, kdcs map[int]string) (conn *net.UDPConn, err error) {\n\ti := 1\n\tfor i <= count {\n\t\tudpAddr, e := net.ResolveUDPAddr(\"udp\", kdcs[i])\n\t\tif e != nil {\n\t\t\terr = fmt.Errorf(\"error resolving KDC address: %v\", e)\n\t\t\treturn\n\t\t}\n\t\tconn, err = net.DialUDP(\"udp\", nil, udpAddr)\n\t\tif err == nil {\n\t\t\terr = conn.SetDeadline(time.Now().Add(5 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti++\n\t}\n\terr = errors.New(\"error in getting a UDP connection to any of the KDCs\")\n\treturn\n}\n\nfunc (cl *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\tvar r []byte\n\tdefer conn.Close()\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\tudpbuf := make([]byte, 4096)\n\tn, _, err := conn.ReadFrom(udpbuf)\n\tr = udpbuf[:n]\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"sending over UDP failed to %s: %v\", conn.RemoteAddr().String(), err)\n\t}\n\tif len(r) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from %s\", conn.RemoteAddr().String())\n\t}\n\treturn r, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype Config struct {\n\tKDCs     map[int]string\n\tTimeout  int\n\tRealm    string\n\tUsername string\n\tPassword string\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tconn, err := c.dialKDCUDP(3, c.Config.KDCs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tresponse, err := c.sendUDP(conn, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}\n\nfunc (c *Client) dialKDCUDP(count int, kdcs map[int]string) (*net.UDPConn, error) {\n\tfor i := 0; i < count; i++ {\n\t\taddr := kdcs[i]\n\t\tif addr == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconn, err := net.DialUDP(\"udp\", nil, udpAddr)\n\t\tif err == nil {\n\t\t\treturn conn, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"failed to connect to any KDC server\")\n}\n\nfunc (c *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer[:n], nil\n}\n\nfunc main() {\n\tconfig := &Config{\n\t\tKDCs:     map[int]string{1: \"kdc1.example.com:88\", 2: \"kdc2.example.com:88\", 3: \"kdc3.example.com:88\"},\n\t\tTimeout:  5,\n\t\tRealm:    \"EXAMPLE.COM\",\n\t\tUsername: \"user\",\n\t\tPassword: \"password\",\n\t}\n\tclient := &Client{Config: config}\n\tdata := []byte(\"test request\")\n\tresponse, err := client.sendKDCUDP(config.Realm, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Printf(\"Response: %s\\n\", string(response))\n\t}\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a function that establishes UDP connections between two remote endpoints, optionally encrypts the initial handshake packets, and forwards traffic between them.\n\nFunction Description: The function `remote2remoteUDP` creates two UDP connections to specified remote endpoints, handles optional encryption of initialization packets, and sets up bidirectional forwarding between the connections. It uses custom networking and crypto utilities for connection management and encryption.\n\nInput:\n- remoteA: string - First remote endpoint address in \"host:port\" format\n- remoteB: string - Second remote endpoint address in \"host:port\" format\n- raenc: bool - Flag to enable encryption for first remote endpoint\n- rbenc: bool - Flag to enable encryption for second remote endpoint\n\nOutput: None (The function runs indefinitely forwarding traffic or returns on error)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"iox/netio\"\n\t\"iox/crypto\"\n)\n\nfunc remote2remoteUDP(remoteA string, remoteB string, raenc bool, rbenc bool) {\n\tremoteAddrA, err := net.ResolveUDPAddr(\"udp\", remoteA)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnA, err := net.DialUDP(\"udp\", nil, remoteAddrA)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnA.Close()\n\n\tremoteAddrB, err := net.ResolveUDPAddr(\"udp\", remoteB)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnB, err := net.DialUDP(\"udp\", nil, remoteAddrB)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnB.Close()\n\n\tremoteCtxA, err := netio.NewUDPCtx(remoteConnA, raenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteCtxB, err := netio.NewUDPCtx(remoteConnB, rbenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif raenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxA.Write(b)\n\t} else {\n\t\tremoteCtxA.Write(netio.UDP_INIT_PACKET)\n\t}\n\tif rbenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxB.Write(b)\n\t} else {\n\t\tremoteCtxB.Write(netio.UDP_INIT_PACKET)\n\t}\n\n\tnetio.ForwardUDP(remoteCtxA, remoteCtxB)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc remote2remoteUDP(remoteA, remoteB string, raenc, rbenc bool) {\n\t// Parse remote endpoints\n\taParts := parseEndpoint(remoteA)\n\tbParts := parseEndpoint(remoteB)\n\n\tif aParts == nil || bParts == nil {\n\t\tfmt.Println(\"Invalid endpoint format\")\n\t\treturn\n\t}\n\n\t// Create UDP connections\n\tconnA, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.ParseIP(aParts[0]), Port: aParts[1]})\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating connection to %s: %v\\n\", remoteA, err)\n\t\treturn\n\t}\n\tdefer connA.Close()\n\n\tconnB, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.ParseIP(bParts[0]), Port: bParts[1]})\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating connection to %s: %v\\n\", remoteB, err)\n\t\treturn\n\t}\n\tdefer connB.Close()\n\n\t// Setup encryption if needed\n\tvar aesKey [16]byte\n\tfor i := 0; i < 16; i++ {\n\t\taesKey[i] = byte(i + 1)\n\t}\n\n\t// Handle initial handshake\n\tif raenc && rbenc {\n\t\t// Both endpoints need encryption\n\t\tencryptedData := encrypt(aesKey[:], []byte(\"handshake\"))\n\t\tconnA.Write(encryptedData)\n\t\tconnB.Write(encryptedData)\n\n\t\tencryptedResponse := encrypt(aesKey[:], []byte(\"ack\"))\n\t\tconnA.Write(encryptedResponse)\n\t\tconnB.Write(encryptedResponse)\n\t} else if raenc {\n\t\t// Only A needs encryption\n\t\tencryptedData := encrypt(aesKey[:], []byte(\"handshake\"))\n\t\tconnA.Write(encryptedData)\n\t\tconnB.Write([]byte(\"ack\"))\n\t} else if rbenc {\n\t\t// Only B needs encryption\n\t\tconnA.Write([]byte(\"handshake\"))\n\t\tencryptedResponse := encrypt(aesKey[:], []byte(\"ack\"))\n\t\tconnB.Write(encryptedResponse)\n\t} else {\n\t\t// No encryption needed\n\t\tconnA.Write([]byte(\"handshake\"))\n\t\tconnB.Write([]byte(\"ack\"))\n\t}\n\n\t// Forward traffic between the two connections\n\tfor {\n\t\tbuffer := make([]byte, 1024)\n\t\tn, _, err := connA.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error reading from A: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif raenc {\n\t\t\tdecrypted := decrypt(aesKey[:], buffer[:n])\n\t\t\tconnB.Write(decrypted)\n\t\t} else {\n\t\t\tconnB.Write(buffer[:n])\n\t\t}\n\n\t\tn, _, err = connB.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error reading from B: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif rbenc {\n\t\t\tdecrypted := decrypt(aesKey[:], buffer[:n])\n\t\t\tconnA.Write(decrypted)\n\t\t} else {\n\t\t\tconnA.Write(buffer[:n])\n\t\t}\n\t}\n}\n\nfunc parseEndpoint(s string) []string {\n\tparts := make([]string, 2)\n\tif len(s) < 1 || s[len(s)-1] != ':' {\n\t\treturn nil\n\t}\n\tparts[1] = s[len(s)-1:]\n\ts = s[:len(s)-1]\n\tparts[0] = s\n\treturn parts\n}\n\nfunc encrypt(key [16]byte, data []byte) []byte {\n\tblock, _ := aes.NewCipher(key[:])\n\tmode := cipher.NewCBCEncrypter(block, key[:])\n\tciphertext := make([]byte, len(data))\n\tmode.CryptBlocks(ciphertext, data)\n\treturn ciphertext\n}\n\nfunc decrypt(key [16]byte, data []byte) []byte {\n\tblock, _ := aes.NewCipher(key[:])\n\tmode := cipher.NewCBDecrypter(block, key[:])\n\tplaintext := make([]byte, len(data))\n\tmode.CryptBlocks(plaintext, data)\n\treturn plaintext\n}"
  },
  {
    "Task_id": 368,
    "Instruction": "Task Description: Implement a UDP client in Go that communicates with a NAT-PMP (Port Mapping Protocol) gateway, handling retries and timeouts for reliable communication.\n\nStruct Description: The `network` struct represents a network connection to a NAT-PMP gateway, maintaining the gateway IP address and providing a method to send requests and receive responses.\n\nFields:\n- gateway: net.IP - The IP address of the NAT-PMP gateway\n\nMethods:\n- call: (msg []byte, timeout time.Duration) -> ([]byte, error) - Sends a UDP message to the NAT-PMP gateway and waits for a response. Implements exponential backoff retry logic with configurable timeout. Returns the response bytes or an error if communication fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nconst nAT_PMP_PORT = 5351\nconst nAT_TRIES = 9\nconst nAT_INITIAL_MS = 250\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) (result []byte, err error) {\n\tvar server net.UDPAddr\n\tserver.IP = n.gateway\n\tserver.Port = nAT_PMP_PORT\n\tconn, err := net.DialUDP(\"udp\", nil, &server)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tresult = make([]byte, 16)\n\n\tvar finalTimeout time.Time\n\tif timeout != 0 {\n\t\tfinalTimeout = time.Now().Add(timeout)\n\t}\n\n\tneedNewDeadline := true\n\n\tvar tries uint\n\tfor tries = 0; (tries < nAT_TRIES && finalTimeout.IsZero()) || time.Now().Before(finalTimeout); {\n\t\tif needNewDeadline {\n\t\t\tnextDeadline := time.Now().Add((nAT_INITIAL_MS << tries) * time.Millisecond)\n\t\t\terr = conn.SetDeadline(minTime(nextDeadline, finalTimeout))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tneedNewDeadline = false\n\t\t}\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tvar bytesRead int\n\t\tvar remoteAddr *net.UDPAddr\n\t\tbytesRead, remoteAddr, err = conn.ReadFromUDP(result)\n\t\tif err != nil {\n\t\t\tif err.(net.Error).Timeout() {\n\t\t\t\ttries++\n\t\t\t\tneedNewDeadline = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif !remoteAddr.IP.Equal(n.gateway) {\n\t\t\tcontinue\n\t\t}\n\t\tif bytesRead < len(result) {\n\t\t\tresult = result[:bytesRead]\n\t\t}\n\t\treturn\n\t}\n\terr = fmt.Errorf(\"Timed out trying to contact gateway\")\n\treturn\n}\n\nfunc minTime(a, b time.Time) time.Time {\n\tif a.IsZero() {\n\t\treturn b\n\t}\n\tif b.IsZero() {\n\t\treturn a\n\t}\n\tif a.Before(b) {\n\t\treturn a\n\t}\n\treturn b\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n)\n\ntype network struct {\n\tgateway net.IP\n}\n\nfunc (n *network) call(msg []byte, timeout time.Duration) ([]byte, error) {\n\tvar response []byte\n\tvar err error\n\tretryCount := 0\n\tmaxRetries := 3\n\tbackoff := 100 * time.Millisecond\n\n\tfor retryCount <= maxRetries {\n\t\tconn, err := net.Dial(\"udp\", n.gateway.String()+\":5000\")\n\t\tif err != nil {\n\t\t\ttime.Sleep(backoff)\n\t\t\tretryCount++\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\ttime.Sleep(backoff)\n\t\t\tretryCount++\n\t\t\tcontinue\n\t\t}\n\n\t\tbuffer := make([]byte, 1024)\n\t\tnetwork := net.UDPAddr{IP: n.gateway, Port: 5000}\n\t\t_, err = conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\ttime.Sleep(backoff)\n\t\t\tretryCount++\n\t\t\tcontinue\n\t\t}\n\n\t\tresponse = buffer\n\t\tbreak\n\t}\n\n\tif err != nil {\n\t\treturn nil, errors.New(\"failed to communicate with NAT-PMP gateway\")\n\t}\n\n\treturn response, nil\n}"
  },
  {
    "Task_id": 369,
    "Instruction": "Task Description: Create a function that sends a predefined stop marker to a destination address over UDP protocol.\n\nFunction Description: The function `sendStopMarker` establishes a UDP connection between a source address and a destination address, then sends a fixed byte sequence (stop marker) to indicate a stopping condition. It handles basic error logging if the connection fails.\n\nInput: \n- `src` [string]: The source IP address or hostname (without port)\n- `dst` [string]: The destination IP address or hostname (without port)\n\nOutput: None (void function). The function writes the stop marker to the UDP connection but doesn't return any value. Errors are logged if they occur.",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n)\n\nvar stopMarker = []byte{2, 2, 2, 2, 2, 2, 2, 2}\n\nfunc sendStopMarker(src, dst string) {\n\tl, _ := net.ResolveUDPAddr(\"udp\", src+\":2222\")\n\tr, _ := net.ResolveUDPAddr(\"udp\", dst+\":2222\")\n\tconn, err := net.DialUDP(\"udp\", l, r)\n\tif err != nil {\n\t\tlog.Printf(\"fail to send stopmarker: %s\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tconn.Write(stopMarker)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n)\n\nfunc sendStopMarker(src, dst string) {\n\t// Create a UDP connection\n\tconn, err := net.Dial(\"udp\", src+\":12345\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Define the stop marker (example: 4 bytes of 0x00)\n\tstopMarker := []byte{0x00, 0x00, 0x00, 0x00}\n\n\t// Send the stop marker to the destination\n\t_, err = conn.Write(stopMarker)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send stop marker: %v\", err)\n\t}\n\n\t// Send the stop marker to the destination\n\t_, err = conn.Write(stopMarker)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send stop marker: %v\", err)\n\t}\n\n\t// Close the connection\n\tconn.Close()\n}"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Implement a UDP server in Go that listens for incoming packets, manages client sessions, and proxies the traffic to a remote destination using a provided proxy dialer.\n\nStruct Description: The UDP struct represents a UDP server that handles incoming connections, manages sessions, and proxies traffic. It maintains session state and coordinates communication between clients and the proxy server.\n\nFields:\n- addr: string - The local address to listen on\n- uaddr: *net.UDPAddr - The resolved UDP address\n- dialer: proxy.Dialer - The dialer used to establish connections\n- proxy: proxy.Proxy - The proxy implementation for forwarding traffic\n\nMethods:\n- NewUDP: (s string, d proxy.Dialer, p proxy.Proxy) -> (*UDP, error) - Creates a new UDP instance by parsing the URL and resolving the address\n- ListenAndServe: () -> () - Starts listening on the UDP port and handles incoming packets\n- serveSession: (session *session) -> () - Handles an individual client session and proxies its traffic\n- DialUDP: (network string, addr string) -> (net.PacketConn, error) - Creates a new packet connection for outbound traffic\n\nAdditional Structs:\n- session: Represents a client session with its communication channels\n  Fields:\n    - key: string - Session identifier\n    - src: *net.UDPAddr - Client address\n    - PacketConn: net.PacketConn - Underlying connection\n    - msgCh: chan []byte - Channel for incoming messages\n    - finCh: chan struct{} - Channel for session termination\n\n- PktConn: Wraps a net.PacketConn with a predefined destination address\n  Fields:\n    - PacketConn: net.PacketConn - Underlying connection\n    - uaddr: *net.UDPAddr - Destination address\n  Methods:\n    - WriteTo: (b []byte, addr net.Addr) -> (int, error) - Writes data to the predefined address",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\nvar nm sync.Map\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu, err := url.Parse(s)\n\tif err != nil {\n\t\tlog.F(\"[udp] parse url err: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tt := &UDP{\n\t\tdialer: d,\n\t\tproxy:  p,\n\t\taddr:   u.Host,\n\t}\n\n\tt.uaddr, err = net.ResolveUDPAddr(\"udp\", t.addr)\n\treturn t, err\n}\n\nfunc (s *UDP) ListenAndServe() {\n\tc, err := net.ListenPacket(\"udp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[udp] failed to listen on UDP %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\n\tlog.F(\"[udp] listening UDP on %s\", s.addr)\n\n\tfor {\n\t\tbuf := pool.GetBuffer(proxy.UDPBufSize)\n\t\tn, srcAddr, err := c.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.F(\"[udp] read error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar sess *session\n\t\tsessKey := srcAddr.String()\n\n\t\tv, ok := nm.Load(sessKey)\n\t\tif !ok || v == nil {\n\t\t\tsess = newSession(sessKey, srcAddr, c)\n\t\t\tnm.Store(sessKey, sess)\n\t\t\tgo s.serveSession(sess)\n\t\t} else {\n\t\t\tsess = v.(*session)\n\t\t}\n\n\t\tsess.msgCh <- buf[:n]\n\t}\n}\n\nfunc (s *UDP) serveSession(session *session) {\n\tdstPC, dialer, err := s.proxy.DialUDP(\"udp\", session.src.String())\n\tif err != nil {\n\t\tlog.F(\"[udp] remote dial error: %v\", err)\n\t\tnm.Delete(session.key)\n\t\treturn\n\t}\n\tdefer dstPC.Close()\n\n\tgo func() {\n\t\tproxy.CopyUDP(session, session.src, dstPC, 2*time.Minute, 5*time.Second)\n\t\tnm.Delete(session.key)\n\t\tclose(session.finCh)\n\t}()\n\n\tlog.F(\"[udp] %s <-> %s\", session.src, dialer.Addr())\n\n\tfor {\n\t\tselect {\n\t\tcase p := <-session.msgCh:\n\t\t\t_, err = dstPC.WriteTo(p, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.F(\"[udp] writeTo error: %v\", err)\n\t\t\t}\n\t\t\tpool.PutBuffer(p)\n\t\tcase <-session.finCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype session struct {\n\tkey string\n\tsrc *net.UDPAddr\n\tnet.PacketConn\n\tmsgCh chan []byte\n\tfinCh chan struct{}\n}\n\nfunc newSession(key string, src net.Addr, srcPC net.PacketConn) *session {\n\tsrcAddr, _ := net.ResolveUDPAddr(\"udp\", src.String())\n\treturn &session{key, srcAddr, srcPC, make(chan []byte, 32), make(chan struct{})}\n}\n\nfunc (s *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\tpc, err := s.dialer.DialUDP(network, s.addr)\n\treturn &PktConn{pc, s.uaddr}, err\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (pc *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn pc.PacketConn.WriteTo(b, pc.uaddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 111,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"proxy\"\n)\n\ntype session struct {\n\tkey     string\n\tsrc     *net.UDPAddr\n\tPacketConn net.PacketConn\n\tmsgCh   chan []byte\n\tfinCh   chan struct{}\n}\n\ntype PktConn struct {\n\tPacketConn net.PacketConn\n\tuaddr      *net.UDPAddr\n}\n\nfunc (p *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn p.PacketConn.WriteTo(b, addr)\n}\n\ntype UDP struct {\n\taddr    string\n\tuaddr   *net.UDPAddr\n\tdialer  proxy.Dialer\n\tproxy   proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UDP{\n\t\taddr:    s,\n\t\tuaddr:   udpAddr,\n\t\tdialer:  d,\n\t\tproxy:   p,\n\t}, nil\n}\n\nfunc (u *UDP) ListenAndServe() {\n\tconn, err := net.ListenUDP(\"udp\", u.uaddr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, _, err := conn.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsession := &session{\n\t\t\tkey:     \"session_key\",\n\t\t\tsrc:     &net.UDPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 0},\n\t\t\tPacketConn: net.PacketConn{},\n\t\t\tmsgCh:   make(chan []byte, 1),\n\t\t\tfinCh:   make(chan struct{}),\n\t\t}\n\n\t\tgo u.serveSession(session)\n\t}\n}\n\nfunc (u *UDP) serveSession(s *session) {\n\t// Implement session handling and proxy logic here\n}\n\nfunc (u *UDP) DialUDP(network string, addr string) (net.PacketConn, error) {\n\treturn net.ListenUDP(network, &net.UDPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 0})\n}"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Implement a UDP-based trap listener for SNMP (Simple Network Management Protocol) messages, capable of receiving and processing traps/informs, with support for SNMPv3 security features and proper resource cleanup.\n\nStruct Description: TrapListener is a struct that manages a UDP listener for SNMP traps, handling incoming messages, security validation, and response generation.\n\nFields:\n- done: chan bool - Channel to signal completion of listener shutdown\n- listening: chan bool - Channel to signal when listener is active\n- Mutex: sync.Mutex - Mutex for thread-safe operations\n- Params: *GoSNMP - Configuration parameters for SNMP handling\n- OnNewTrap: TrapHandlerFunc - Callback function for new trap processing\n- CloseTimeout: time.Duration - Timeout for graceful shutdown\n- conn: *net.UDPConn - UDP connection object\n- proto: string - Protocol type (typically \"udp\")\n- usmStatsUnknownEngineIDsCount: uint32 - Counter for unknown engine IDs (SNMPv3)\n- finish: int32 - Atomic flag for shutdown state\n\nMethods:\n- NewTrapListener() -> *TrapListener - Creates and initializes a new TrapListener instance\n- Close() - Gracefully shuts down the listener and cleans up resources\n- SendUDP(packet *SnmpPacket, addr *net.UDPAddr) -> error - Sends an SNMP packet via UDP\n- listenUDP(addr string) -> error - Main listening loop for incoming traps\n- reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) -> error - Handles SNMPv3 engine ID mismatch reporting",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype TrapListener struct {\n\tdone      chan bool\n\tlistening chan bool\n\tsync.Mutex\n\n\tParams *GoSNMP\n\n\tOnNewTrap TrapHandlerFunc\n\n\tCloseTimeout time.Duration\n\n\tconn  *net.UDPConn\n\tproto string\n\n\tusmStatsUnknownEngineIDsCount uint32\n\n\tfinish int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\ttl := &TrapListener{\n\t\tfinish:       0,\n\t\tdone:         make(chan bool),\n\t\tlistening:    make(chan bool, 1),\n\t\tCloseTimeout: defaultCloseTimeout,\n\t}\n\n\treturn tl\n}\n\nfunc (t *TrapListener) Close() {\n\tif atomic.CompareAndSwapInt32(&t.finish, 0, 1) {\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\n\t\tif t.conn == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err := t.conn.Close(); err != nil {\n\t\t\tt.Params.Logger.Printf(\"failed to Close() the TrapListener socket: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-t.done:\n\t\tcase <-time.After(t.CloseTimeout):\n\t\t\tt.Params.Logger.Printf(\"timeout while awaiting done signal on TrapListener Close()\")\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\tob, err := packet.marshalMsg()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling SnmpPacket: %w\", err)\n\t}\n\n\tcount, err := t.conn.WriteTo(ob, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending SnmpPacket: %w\", err)\n\t}\n\n\tif count != len(ob) {\n\t\tt.Params.Logger.Printf(\"Failed to send all bytes of SnmpPacket!\\n\")\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn, err = net.ListenUDP(udp, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer t.conn.Close()\n\n\tt.listening <- true\n\n\tfor {\n\t\tswitch {\n\t\tcase atomic.LoadInt32(&t.finish) == 1:\n\t\t\tt.done <- true\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tvar buf [4096]byte\n\t\t\trlen, remote, err := t.conn.ReadFromUDP(buf[:])\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&t.finish) == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in read %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg := buf[:rlen]\n\t\t\ttrap, err := t.Params.UnmarshalTrap(msg, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in UnmarshalTrap %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif trap.Version == Version3 && trap.SecurityModel == UserSecurityModel && t.Params.SecurityModel == UserSecurityModel {\n\t\t\t\tsecurityParams, ok := t.Params.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tpacketSecurityParams, ok := trap.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tsnmpEngineID := securityParams.AuthoritativeEngineID\n\t\t\t\tmsgAuthoritativeEngineID := packetSecurityParams.AuthoritativeEngineID\n\t\t\t\tif msgAuthoritativeEngineID != snmpEngineID {\n\t\t\t\t\tif len(msgAuthoritativeEngineID) < 5 || len(msgAuthoritativeEngineID) > 32 {\n\t\t\t\t\t\tatomic.AddUint32(&t.usmStatsUnknownEngineIDsCount, 1)\n\t\t\t\t\t\terr := t.reportAuthoritativeEngineID(trap, snmpEngineID, remote)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.OnNewTrap(trap, remote)\n\n\t\t\tif trap.PDUType == InformRequest {\n\t\t\t\ttrap.PDUType = GetResponse\n\t\t\t\ttrap.Error = NoError\n\t\t\t\ttrap.ErrorIndex = 0\n\t\t\t\terr := t.SendUDP(trap, remote)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tnewSecurityParams, ok := trap.SecurityParameters.Copy().(*UsmSecurityParameters)\n\tif !ok {\n\t\treturn errors.New(\"unable to cast SecurityParams to UsmSecurityParameters\")\n\t}\n\tnewSecurityParams.AuthoritativeEngineID = snmpEngineID\n\treportPacket := trap\n\treportPacket.PDUType = Report\n\treportPacket.MsgFlags &= AuthPriv\n\treportPacket.SecurityParameters = newSecurityParams\n\treportPacket.Variables = []SnmpPDU{\n\t\t{\n\t\t\tName:  usmStatsUnknownEngineIDs,\n\t\t\tValue: int(atomic.LoadUint32(&t.usmStatsUnknownEngineIDsCount)),\n\t\t\tType:  Integer,\n\t\t},\n\t}\n\treturn t.SendUDP(reportPacket, addr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/gosnmp/gosnmp\"\n)\n\ntype TrapListener struct {\n\tdone           chan bool\n\tlistening      chan bool\n\tMutex          sync.Mutex\n\tParams         *gosnmp.GoSNMP\n\tOnNewTrap      func(*gosnmp.SnmpPacket, *net.UDPAddr)\n\tCloseTimeout   time.Duration\n\tconn           *net.UDPConn\n\tproto          string\n\tusmStatsUnknownEngineIDsCount uint32\n\tfinish         int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\treturn &TrapListener{\n\t\tdone:           make(chan bool),\n\t\tlistening:      make(chan bool),\n\t\tParams:         &gosnmp.GoSNMP{},\n\t\tCloseTimeout:   5 * time.Second,\n\t\tproto:          \"udp\",\n\t}\n}\n\nfunc (t *TrapListener) Close() {\n\tt.Mutex.Lock()\n\tdefer t.Mutex.Unlock()\n\n\tif t.conn != nil {\n\t\tt.conn.Close()\n\t}\n\tclose(t.done)\n}\n\nfunc (t *TrapListener) SendUDP(packet *gosnmp.SnmpPacket, addr *net.UDPAddr) error {\n\treturn t.Params.WritePacket(packet, addr)\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tconn, err := net.ListenUDP(t.proto, &net.UDPAddr{IP: net.ParseIP(addr), Port: 0})\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn = conn\n\tt.listening <- true\n\tfor {\n\t\tbuf := make([]byte, 65535)\n\t\tn, _, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tif err == net.ErrClosed {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tpacket := gosnmp.NewSnmpPacket()\n\t\tpacket.DecodeBytes(buf[:n])\n\t\tt.OnNewTrap(packet, &net.UDPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 0})\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *gosnmp.SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\treturn nil\n}"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a UDP server in Go that handles incoming UDP packets, processes them, and manages connections using a cache system for tracking active connections. The server should support multiple ports with different encryption keys and handle both connection establishment and data packet processing.\n\nStruct Description: The Server struct represents a UDP server instance with TCP and UDP capabilities, including connection caching and encryption support for multiple ports.\n\nFields:\n\nTCPAddr: *net.TCPAddr - TCP address information for the server\nUDPAddr: *net.UDPAddr - UDP address information for the server\nTCPListen: *net.TCPListener - TCP listener instance\nUDPConn: *net.UDPConn - UDP connection instance\nCache: *cache.Cache - Cache for storing active connections\nCkv: *crypto.KV - Default encryption key-value pair\nPortCkv: map[int64]*crypto.KV - Map of port numbers to their respective encryption key-value pairs\n\nMethods:\n\nNewServer: (addr string, password string, portPassword []string) -> (*Server, error) - Creates a new Server instance with the given address, default password, and port-specific passwords\nRunUDPServer: () -> error - Starts the UDP server and begins listening for incoming packets\nUDPHandle: (addr *net.UDPAddr, b []byte) -> error - Handles incoming UDP packets, either establishing new connections or forwarding data to existing connections",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/crypto\"\n)\n\ntype Server struct {\n\tTCPAddr   *net.TCPAddr\n\tUDPAddr   *net.UDPAddr\n\tTCPListen *net.TCPListener\n\tUDPConn   *net.UDPConn\n\tCache     *cache.Cache\n\tCkv       *crypto.KV\n\tPortCkv   map[int64]*crypto.KV\n}\n\nfunc NewServer(addr, password string, portPassword []string) (*Server, error) {\n\tpc := make(map[int64]*crypto.KV)\n\tfor _, v := range portPassword {\n\t\tl := strings.Split(v, \" \")\n\t\tif len(l) != 2 {\n\t\t\treturn nil, errors.New(\"Wrong format: \" + v)\n\t\t}\n\t\tport, err := strconv.ParseInt(l[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tckv := &crypto.KV{\n\t\t\tAESKey: []byte(l[1]),\n\t\t}\n\t\tpc[port] = ckv\n\t}\n\ttaddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tTCPAddr: taddr,\n\t\tUDPAddr: uaddr,\n\t\tCache:   cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tCkv: &crypto.KV{\n\t\t\tAESKey: []byte(password),\n\t\t},\n\t\tPortCkv: pc,\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tvar err error\n\ts.UDPConn, err = net.ListenUDP(\"udp\", s.UDPAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\tn, addr, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func(addr *net.UDPAddr, b []byte) {\n\t\t\tif err := s.UDPHandle(addr, b); err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t}(addr, b[0:n])\n\t}\n\treturn nil\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\tp := &UDPPacket{}\n\tif err := proto.Unmarshal(b, p); err != nil {\n\t\treturn nil\n\t}\n\tif p.Address == \"\" {\n\t\tu, err := NewUDPServer(s, p, addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.Cache.Set(\"u:\"+strconv.FormatInt(p.Port, 10), u, cache.DefaultExpiration)\n\t\tdefer s.Cache.Delete(\"u:\" + strconv.FormatInt(p.Port, 10))\n\t\tif err := u.ListenAndServe(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\ti, ok := s.Cache.Get(\"u:\" + strconv.FormatInt(p.Port, 10))\n\tif !ok {\n\t\treturn nil\n\t}\n\tc := i.(*UDPServer)\n\tif err := c.HandlePacket(p); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Cache struct {\n\tmu      sync.RWMutex\n\tentries map[string]*Connection\n}\n\ntype Connection struct {\n\tid        string\n\ttcpConn   *net.TCPConn\n\tudpConn   *net.UDPConn\n\tencryption *crypto.KV\n}\n\ntype Server struct {\n\tTCPAddr     *net.TCPAddr\n\tUDPAddr     *net.UDPAddr\n\tTCPListen   *net.TCPListener\n\tUDPConn     *net.UDPConn\n\tCache       *Cache\n\tCkv         *crypto.KV\n\tPortCkv     map[int64]*crypto.KV\n}\n\nfunc NewServer(addr string, password string, portPassword []string) (*Server, error) {\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttcpListener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcache := &Cache{\n\t\tentries: make(map[string]*Connection),\n\t}\n\n\tcv := &crypto.KV{}\n\t// Generate a random key for encryption\n\tkey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcv.Key = key\n\n\tportCkv := make(map[int64]*crypto.KV)\n\tfor i, p := range portPassword {\n\t\tport := int64(i + 1)\n\t\tkv := &crypto.KV{}\n\t\t// Generate a random key for encryption\n\t\tkey, err := rsa.GenerateKey(rand.Reader, 2048)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkv.Key = key\n\t\tportCkv[port] = kv\n\t}\n\n\treturn &Server{\n\t\tTCPAddr:     tcpAddr,\n\t\tUDPAddr:     udpAddr,\n\t\tTCPListen:   tcpListener,\n\t\tUDPConn:     udpConn,\n\t\tCache:       cache,\n\t\tCkv:         cv,\n\t\tPortCkv:     portCkv,\n\t}, nil\n}\n\nfunc (s *Server) RunUDPServer() error {\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, _, err := s.UDPConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif n > 0 {\n\t\t\ts.UDPHandle(s.UDPAddr, buf[:n])\n\t\t}\n\t}\n}\n\nfunc (s *Server) UDPHandle(addr *net.UDPAddr, b []byte) error {\n\t// Extract the connection ID from the packet\n\tconnID := string(b[:len(b)-16])\n\tb = b[len(b)-16:]\n\n\t// Check if the connection exists in the cache\n\ts.Cache.mu.RLock()\n\tconnection, exists := s.Cache.entries[connID]\n\ts.Cache.mu.RUnlock()\n\n\tif exists {\n\t\t// Forward the data to the TCP connection\n\t\t_, err := connection.tcpConn.Write(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// Establish a new connection\n\t\ttcpConn, err := net.DialTCP(\"tcp\", nil, s.TCPAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a new connection entry\n\t\tnewConnection := &Connection{\n\t\t\tid: connID,\n\t\t\ttcpConn: tcpConn,\n\t\t\tencryption: s.Ckv,\n\t\t}\n\n\t\ts.Cache.mu.Lock()\n\t\ts.Cache.entries[connID] = newConnection\n\t\ts.Cache.mu.Unlock()\n\n\t\t// Forward the data to the TCP connection\n\t\t_, err = newConnection.tcpConn.Write(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a UDP server for handling SOCKS5 proxy requests, including UDP association and data relay between clients and a Hysteria proxy client.\n\nStruct Description: The Server struct represents a SOCKS5 proxy server with UDP support, handling client connections and relaying UDP traffic through a Hysteria proxy.\n\nFields:\n\nHyClient: [client.Client] - The Hysteria client used for establishing proxy connections\nAuthFunc: [func(username, password string) bool] - Authentication function for SOCKS5 clients\nDisableUDP: [bool] - Flag to disable UDP functionality\nEventLogger: [EventLogger] - Interface for logging server events\n\nMethods:\n\nhandleUDP: [func(conn net.Conn, req *socks5.Request)] - none - Handles a new UDP association request from a SOCKS5 client\nudpServer: [func(udpConn *net.UDPConn, hyUDP client.HyUDPConn)] -> [error] - Manages the UDP relay between client and Hysteria proxy\nsendUDPReply: [func(conn net.Conn, addr *net.UDPAddr)] -> [error] - Sends a UDP association reply to the SOCKS5 client\n\nInterface Description:\n\nEventLogger: Interface for logging UDP-related events\nMethods:\nUDPRequest: [func(addr net.Addr)] - Logs incoming UDP requests\nUDPError: [func(addr net.Addr, err error)] - Logs UDP-related errors",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/txthinking/socks5\"\n\n\t\"github.com/apernet/hysteria/core/v2/client\"\n)\n\ntype Server struct {\n\tHyClient    client.Client\n\tAuthFunc    func(username, password string) bool\n\tDisableUDP  bool\n\tEventLogger EventLogger\n}\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\tdefer conn.Close()\n\n\tif s.EventLogger != nil {\n\t\ts.EventLogger.UDPRequest(conn.RemoteAddr())\n\t}\n\tvar closeErr error\n\tdefer func() {\n\t\tif s.EventLogger != nil {\n\t\t\ts.EventLogger.UDPError(conn.RemoteAddr(), closeErr)\n\t\t}\n\t}()\n\n\thost, _, err := net.SplitHostPort(conn.LocalAddr().String())\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(host, \"0\"))\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer udpConn.Close()\n\n\thyUDP, err := s.HyClient.UDP()\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer hyUDP.Close()\n\n\t_ = sendUDPReply(conn, udpConn.LocalAddr().(*net.UDPAddr))\n\n\terrChan := make(chan error, 2)\n\tgo func() {\n\t\terr := s.udpServer(udpConn, hyUDP)\n\t\terrChan <- err\n\t}()\n\tgo func() {\n\t\t_, err := io.Copy(io.Discard, conn)\n\t\terrChan <- err\n\t}()\n\tcloseErr = <-errChan\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\tvar clientAddr *net.UDPAddr\n\tbuf := make([]byte, udpBufferSize)\n\tfor {\n\t\tn, cAddr, err := udpConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td, err := socks5.NewDatagramFromBytes(buf[:n])\n\t\tif err != nil || d.Frag != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif clientAddr == nil {\n\t\t\tclientAddr = cAddr\n\t\t\tgo func() {\n\t\t\t\tfor {\n\t\t\t\t\tbs, from, err := hyUDP.Receive()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t_ = udpConn.Close()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tatyp, addr, port, err := socks5.ParseAddress(from)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif atyp == socks5.ATYPDomain {\n\t\t\t\t\t\taddr = addr[1:]\n\t\t\t\t\t}\n\t\t\t\t\td := socks5.NewDatagram(atyp, addr, port, bs)\n\t\t\t\t\t_, _ = udpConn.WriteToUDP(d.Bytes(), clientAddr)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else if !clientAddr.IP.Equal(cAddr.IP) || clientAddr.Port != cAddr.Port {\n\t\t\tcontinue\n\t\t}\n\t\t_ = hyUDP.Send(d.Data, d.Address())\n\t}\n}\n\nfunc sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\tvar atyp byte\n\tvar bndAddr, bndPort []byte\n\tif ip4 := addr.IP.To4(); ip4 != nil {\n\t\tatyp = socks5.ATYPIPv4\n\t\tbndAddr = ip4\n\t} else {\n\t\tatyp = socks5.ATYPIPv6\n\t\tbndAddr = addr.IP\n\t}\n\tbndPort = make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bndPort, uint16(addr.Port))\n\tp := socks5.NewReply(socks5.RepSuccess, atyp, bndAddr, bndPort)\n\t_, err := p.WriteTo(conn)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\ntype Server struct {\n\tHyClient   client.Client\n\tAuthFunc   func(username, password string) bool\n\tDisableUDP bool\n\tEventLogger\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\tif s.DisableUDP {\n\t\tconn.Write([]byte{0x00, 0x05, 0x00, 0x00})\n\t\treturn\n\t}\n\ts.EventLogger.UDPRequest(conn.RemoteAddr())\n\tudpConn, err := net.ListenUDP(\"udp\", nil)\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\tdefer udpConn.Close()\n\thyUDP, err := s.HyClient.NewHyUDPConn()\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t\treturn\n\t}\n\terr = s.udpServer(udpConn, hyUDP)\n\tif err != nil {\n\t\ts.EventLogger.UDPError(conn.RemoteAddr(), err)\n\t}\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, _, err := udpConn.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = hyUDP.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *Server) sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\treply := []byte{0x00, 0x05, 0x00, 0x00}\n\tconn.Write(reply)\n\treturn nil\n}"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Implement a UDP server in Go that handles incoming UDP packets, performs authentication checks, and manages communication with clients through specified ports. The server should include functionality for initialization, packet handling, listening for incoming data, and graceful shutdown.\n\nStruct Description: The UDPServer struct represents a UDP server instance that manages UDP connections, handles authentication, and processes incoming/outgoing packets. It maintains connection state and integrates with a parent Server instance.\n\nFields:\n\nServer: [*Server] - Reference to the parent Server instance containing shared resources\nUDPConn: [*net.UDPConn] - Active UDP connection for the server\nAddr: [*net.UDPAddr] - Address information for the server's UDP endpoint\n\nMethods:\n\nNewUDPServer: [func(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error)] -> [*UDPServer, error] - Initializes a new UDP server instance with authentication checks and port validation. Returns the server instance or error if initialization fails.\n\nListenAndServe: [func(s *UDPServer) error] -> [error] - Starts listening for incoming UDP packets and handles them in a loop until an error occurs or the server is shut down. Automatically closes the connection when finished.\n\nShutdown: [func(s *UDPServer)] -> [void] - Gracefully shuts down the UDP server by closing the active connection.\n\nHandlePacket: [func(s *UDPServer, p *UDPPacket) error] -> [error] - Processes an incoming UDP packet, either forwarding data to the specified address or updating the connection deadline. Returns error if processing fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tbye := func(err error) {\n\t\tp := &UDPPacket{\n\t\t\tAddress: err.Error(),\n\t\t}\n\t\tb, err1 := proto.Marshal(p)\n\t\tif err1 != nil {\n\t\t\tlog.Println(err1)\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\tif p.Port == 0 {\n\t\tbye(errors.New(\"Missed port\"))\n\t\treturn nil, errors.New(addr.String() + \" missed port\")\n\t}\n\tif len(s.PortCkv) == 0 {\n\t\ttmp, err := s.Ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tif len(s.PortCkv) != 0 {\n\t\tckv, ok := s.PortCkv[p.Port]\n\t\tif !ok {\n\t\t\tbye(errors.New(\"Not allowed port\"))\n\t\t\treturn nil, errors.New(addr.String() + \" try to open not allowed UDP port: \" + strconv.FormatInt(p.Port, 10))\n\t\t}\n\t\ttmp, err := ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.FormatInt(p.Port, 10))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc1, err := net.ListenUDP(\"udp\", uaddr)\n\tif err != nil {\n\t\tbye(err)\n\t\treturn nil, err\n\t}\n\tif err := c1.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tp = &UDPPacket{\n\t\tAddress: \"0\",\n\t}\n\tb, err := proto.Marshal(p)\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{\n\t\tServer:  s,\n\t\tUDPConn: c1,\n\t\tAddr:    addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\ti, a, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tp := &UDPPacket{\n\t\t\tAddress: a.String(),\n\t\t\tData:    b[0:i],\n\t\t}\n\t\tb, err = proto.Marshal(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.Server.UDPConn.WriteToUDP(b, s.Addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.UDPConn.Close()\n}\n\nfunc (s *UDPServer) HandlePacket(p *UDPPacket) error {\n\tif p.Address != \"0\" {\n\t\tuaddr, err := net.ResolveUDPAddr(\"udp\", p.Address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(p.Data, uaddr); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := s.UDPConn.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype UDPPacket struct {\n\tData    []byte\n\tAddr    *net.UDPAddr\n\tTimeout time.Duration\n}\n\ntype UDPServer struct {\n\tServer   *Server\n\tUDPConn  *net.UDPConn\n\tAddr     *net.UDPAddr\n}\n\ntype Server struct {\n\t// Shared resources for the server\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tudpConn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{\n\t\tServer:   s,\n\t\tUDPConn:  udpConn,\n\t\tAddr:     addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, _, err := s.UDPConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp := &UDPPacket{\n\t\t\tData: buf[:n],\n\t\t\tAddr: s.Addr,\n\t\t}\n\t\tif err := s.HandlePacket(s, p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.UDPConn.Close()\n}\n\nfunc (s *UDPServer) HandlePacket(s *UDPServer, p *UDPPacket) error {\n\t// Example packet handling logic\n\t// In a real implementation, this would include authentication checks and data processing\n\tif p.Timeout > 0 {\n\t\ts.UDPConn.SetDeadline(time.Now().Add(p.Timeout))\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 376,
    "Instruction": "Task Description: Create a UDP server in Go that listens for incoming messages on a specified port and prints received messages along with the sender's address.\n\nFunction Description: The function sets up a UDP server that continuously listens for incoming datagrams on a specified port. For each received message, it trims whitespace, prints the message content and the sender's address, and continues listening for new messages.\n\nInput: None (The port and IP address are hardcoded in the function)\n\nOutput: None (The function prints output to stdout but doesn't return any values)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\nfunc main() {\n\tconn, err := net.ListenUDP(\"udp\", &net.UDPAddr{\n\t\tPort: 3000,\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer conn.Close()\n\tfmt.Printf(\"server listening %s\\n\", conn.LocalAddr().String())\n\n\tfor {\n\t\tmessage := make([]byte, 20)\n\t\trlen, remote, err := conn.ReadFromUDP(message[:])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdata := strings.TrimSpace(string(message[:rlen]))\n\t\tfmt.Printf(\"received: %s from %s\\n\", data, remote)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc main() {\n\tudpAddr, _ := net.ResolveUDPAddr(\"udp\", \":12345\")\n\tconn, _ := net.ListenUDP(\"udp\", udpAddr)\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, _, _ := conn.ReadFromUDP(buffer)\n\t\tmessage := strings.TrimSpace(string(buffer[:n]))\n\t\tfmt.Printf(\"Received: %s from %s\\n\", message, conn.RemoteAddr())\n\t}\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: The provided code demonstrates a WebSocket client implementation in Go for tracker communication in a peer-to-peer network, handling WebSocket connections, message exchange, and WebRTC offer/answer negotiation.\n\nStruct Description: TrackerClient represents a client for interacting with a WebSocket tracker server, managing WebSocket connections, peer connections, and message handling.\n\nFields:\n\nUrl: string - The WebSocket tracker server URL to connect to\nGetAnnounceRequest: func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error) - Function to generate announce requests\nPeerId: [20]byte - The client's peer identifier\nOnConn: onDataChannelOpen - Callback for when data channels open\nLogger: log.Logger - Logger for client operations\nDialer: *websocket.Dialer - WebSocket dialer configuration\nmu: sync.Mutex - Mutex for thread-safe operations\ncond: sync.Cond - Condition variable for connection state changes\noutboundOffers: map[string]outboundOfferValue - Track outbound WebRTC offers\nwsConn: *websocket.Conn - Active WebSocket connection\nclosed: bool - Connection closed flag\npingTicker: *time.Ticker - Timer for sending ping messages\nWebsocketTrackerHttpHeader: func() http.Header - Function to generate WebSocket headers\nICEServers: []webrtc.ICEServer - List of ICE servers for WebRTC\nrtcPeerConns: map[string]*wrappedPeerConnection - Active WebRTC peer connections\n\nMethods:\n\ndoWebsocket: () -> error - Establishes and maintains WebSocket connection to tracker\ntrackerReadLoop: (*websocket.Conn) -> error - Handles incoming WebSocket messages\nwriteMessage: ([]byte) -> error - Writes message to WebSocket connection\nhandleOffer: (offerContext, string) -> error - Processes incoming WebRTC offers\nhandleAnswer: (string, webrtc.SessionDescription) -> void - Processes incoming WebRTC answers",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/anacrolix/log\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v4\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype TrackerClient struct {\n\tUrl                string\n\tGetAnnounceRequest func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId             [20]byte\n\tOnConn             onDataChannelOpen\n\tLogger             log.Logger\n\tDialer             *websocket.Dialer\n\n\tmu             sync.Mutex\n\tcond           sync.Cond\n\toutboundOffers map[string]outboundOfferValue\n\twsConn         *websocket.Conn\n\tclosed         bool\n\tpingTicker     *time.Ticker\n\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers                 []webrtc.ICEServer\n\n\trtcPeerConns map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\ttc.mu.Unlock()\n\n\tvar header http.Header\n\tif tc.WebsocketTrackerHttpHeader != nil {\n\t\theader = tc.WebsocketTrackerHttpHeader()\n\t}\n\n\tc, _, err := tc.Dialer.Dial(tc.Url, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing tracker: %w\", err)\n\t}\n\tdefer c.Close()\n\ttc.Logger.WithDefaultLevel(log.Info).Printf(\"connected\")\n\ttc.mu.Lock()\n\ttc.wsConn = c\n\ttc.cond.Broadcast()\n\ttc.mu.Unlock()\n\tcloseChan := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tc.pingTicker.C:\n\t\t\t\ttc.mu.Lock()\n\t\t\t\terr := c.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\ttc.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-closeChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\terr = tc.trackerReadLoop(tc.wsConn)\n\tclose(closeChan)\n\ttc.mu.Lock()\n\tc.Close()\n\ttc.mu.Unlock()\n\treturn err\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(tracker *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := tracker.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read message error: %w\", err)\n\t\t}\n\t\ttc.Logger.Levelf(log.Debug, \"received message: %q\", message)\n\n\t\tvar ar AnnounceResponse\n\t\tif err := json.Unmarshal(message, &ar); err != nil {\n\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error unmarshalling announce response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase ar.Offer != nil:\n\t\t\tih, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error decoding info_hash in offer: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = tc.handleOffer(offerContext{\n\t\t\t\tSessDesc: *ar.Offer,\n\t\t\t\tId:       ar.OfferID,\n\t\t\t\tInfoHash: ih,\n\t\t\t}, ar.PeerID)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Error, \"handling offer for infohash %x: %v\", ih, err)\n\t\t\t}\n\t\tcase ar.Answer != nil:\n\t\t\ttc.handleAnswer(ar.OfferID, *ar.Answer)\n\t\tdefault:\n\t\t\t_, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Warning, \"unexpected announce response %q\", message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(data []byte) error {\n\tfor tc.wsConn == nil {\n\t\tif tc.closed {\n\t\t\treturn fmt.Errorf(\"%T closed\", tc)\n\t\t}\n\t\ttc.cond.Wait()\n\t}\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, data)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc\"\n)\n\ntype outboundOfferValue struct {\n\tofferContext string\n\tpeerID       [20]byte\n}\n\ntype TrackerClient struct {\n\tUrl                    string\n\tGetAnnounceRequest     func(tracker.AnnounceEvent, [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId                 [20]byte\n\tOnConn                 func()\n\tLogger                 log.Logger\n\tDialer                 *websocket.Dialer\n\tmu                     sync.Mutex\n\tcond                   *sync.Cond\n\toutboundOffers         map[string]outboundOfferValue\n\twsConn                 *websocket.Conn\n\tclosed                 bool\n\tpingTicker             *time.Ticker\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers             []webrtc.ICEServer\n\trtcPeerConns           map[string]*wrappedPeerConnection\n}\n\nfunc (c *TrackerClient) doWebsocket() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil\n\t}\n\n\tc.cond.L.Lock()\n\tc.cond.Wait()\n\tc.cond.L.Unlock()\n\n\tconn, _, err := c.Dialer.Dial(c.Url, c.WebsocketTrackerHttpHeader())\n\tif err != nil {\n\t\tc.Logger.Printf(\"Failed to connect to tracker: %v\", err)\n\t\treturn err\n\t}\n\tc.wsConn = conn\n\tc.closed = false\n\n\tgo c.trackerReadLoop(conn)\n\tgo c.pingTickerLoop()\n\n\treturn nil\n}\n\nfunc (c *TrackerClient) trackerReadLoop(conn *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tc.Logger.Printf(\"Error reading message: %v\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tc.Logger.Printf(\"Received message: %s\", message)\n\t\t// Handle incoming messages here\n\t}\n\treturn nil\n}\n\nfunc (c *TrackerClient) writeMessage(message []byte) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil\n\t}\n\n\treturn c.wsConn.WriteMessage(websocket.TextMessage, message)\n}\n\nfunc (c *TrackerClient) handleOffer(offerContext string, peerID [20]byte) error {\n\t// Process incoming WebRTC offer\n\t// Implement logic to handle the offer and establish a peer connection\n\treturn nil\n}\n\nfunc (c *TrackerClient) handleAnswer(answer string, sessionDescription webrtc.SessionDescription) {\n\t// Process incoming WebRTC answer\n\t// Implement logic to handle the answer\n}\n\nfunc (c *TrackerClient) pingTickerLoop() {\n\tc.pingTicker = time.NewTicker(10 * time.Second)\n\tfor range c.pingTicker.C {\n\t\tif !c.closed {\n\t\t\tc.writeMessage([]byte(\"ping\"))\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Go function that establishes a WebSocket connection to a specified URL, sends a protobuf message as a JSON payload, and returns the WebSocket connection for further communication.\n\nFunction Description: The function `openWebSocket` establishes a secure WebSocket connection (wss://) to a given URL with optional custom headers. It authenticates using admin macaroon if no custom headers are provided, sends a protobuf message as JSON, and returns the active WebSocket connection. The caller is responsible for closing the connection.\n\nInput:\n- `node` [*node.HarnessNode] - Node configuration containing REST address and authentication details\n- `url` [string] - The endpoint path for the WebSocket connection\n- `method` [string] - The method parameter to include in the query string\n- `req` [proto.Message] - The protobuf message to send as initial payload\n- `customHeader` [http.Header] - Optional custom HTTP headers for the request\n\nOutput:\n- [*websocket.Conn] - Established WebSocket connection for bidirectional communication\n- [error] - Error if any step in the connection process fails",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lightningnetwork/lnd/lnrpc\"\n\t\"github.com/lightningnetwork/lnd/lntest/node\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar (\n\twebSocketDialer = &websocket.Dialer{\n\t\tHandshakeTimeout: time.Second,\n\t\tTLSClientConfig:  insecureTransport.TLSClientConfig,\n\t}\n\tcloseMsg = websocket.FormatCloseMessage(\n\t\twebsocket.CloseNormalClosure, \"done\",\n\t)\n)\n\nfunc openWebSocket(node *node.HarnessNode, url, method string,\n\treq proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\n\theader := customHeader\n\tif header == nil {\n\t\theader = make(http.Header)\n\t\tif err := addAdminMacaroon(node, header); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfullURL := fmt.Sprintf(\n\t\t\"wss://%s%s?method=%s\", node.Cfg.RESTAddr(), url, method,\n\t)\n\tconn, resp, err := webSocketDialer.Dial(fullURL, header)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { _ = resp.Body.Close() }()\n\n\treqMsg, err := lnrpc.RESTJsonMarshalOpts.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = conn.WriteMessage(websocket.TextMessage, reqMsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"node\"\n)\n\nfunc openWebSocket(node node.HarnessNode, url string, method string, req proto.Message, customHeader http.Header) (*websocket.Conn, error) {\n\t// Construct the full WebSocket URL\n\twsURL := fmt.Sprintf(\"wss://%s/%s?method=%s\", node.RESTAddress, url, method)\n\n\t// Set up the HTTP client with custom headers if provided\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{},\n\t}\n\n\tif customHeader != nil {\n\t\tclient.Transport = &http.Transport{\n\t\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t}\n\t} else {\n\t\t// If no custom headers, use the node's authentication details\n\t\t// This is a simplified example; actual implementation may vary\n\t\t// For demonstration, we'll assume the macaroon is included in the request\n\t}\n\n\t// Create a new WebSocket connection\n\tconn, _, err := websocket.DefaultDialer.Dial(wsURL, customHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Serialize the protobuf message to JSON\n\tjsonData, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Send the JSON payload over the WebSocket\n\terr = conn.WriteMessage(websocket.TextMessage, jsonData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that can establish secure connections, handle protocol negotiation, and manage message transmission between client and server. The solution should support TLS configuration, proxy settings, and proper connection cleanup.\n\nStruct Description: The RoundTripper struct implements http.RoundTripper interface to handle WebSocket connections with additional capabilities for Kubernetes API server communication. It manages WebSocket connections with TLS support and proxy configuration.\n\nFields:\n- TLSConfig: *tls.Config - Configuration for TLS/SSL connections\n- Proxier: func(req *http.Request) (*url.URL, error) - Function to determine proxy for requests\n- Conn: *gwebsocket.Conn - Active WebSocket connection\n\nMethods:\n- Connection: () -> *gwebsocket.Conn - Returns the active WebSocket connection\n- DataBufferSize: () -> int - Returns the buffer size for data transmission (32KB by default)\n- TLSClientConfig: () -> *tls.Config - Returns the TLS configuration\n- RoundTrip: (*http.Request) -> (*http.Response, error) - Main method that establishes WebSocket connection, handles protocol negotiation, and returns the HTTP response\n\nAdditional Function:\n- RoundTripperFor: (*restclient.Config) -> (http.RoundTripper, ConnectionHolder, error) - Factory function that creates a configured RoundTripper instance with proper TLS and proxy settings from Kubernetes client configuration",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tgwebsocket \"github.com/gorilla/websocket\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream/wsstream\"\n\tutilnet \"k8s.io/apimachinery/pkg/util/net\"\n\trestclient \"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/transport\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *gwebsocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *gwebsocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(request *http.Request) (retResp *http.Response, retErr error) {\n\tdefer func() {\n\t\tif request.Body != nil {\n\t\t\terr := request.Body.Close()\n\t\t\tif retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}\n\t}()\n\n\tprotocolVersions := request.Header[wsstream.WebSocketProtocolHeader]\n\tdelete(request.Header, wsstream.WebSocketProtocolHeader)\n\n\tdialer := gwebsocket.Dialer{\n\t\tProxy:           rt.Proxier,\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tSubprotocols:    protocolVersions,\n\t\tReadBufferSize:  rt.DataBufferSize() + 1024,\n\t\tWriteBufferSize: rt.DataBufferSize() + 1024,\n\t}\n\tswitch request.URL.Scheme {\n\tcase \"https\":\n\t\trequest.URL.Scheme = \"wss\"\n\tcase \"http\":\n\t\trequest.URL.Scheme = \"ws\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown url scheme: %s\", request.URL.Scheme)\n\t}\n\twsConn, resp, err := dialer.DialContext(request.Context(), request.URL.String(), request.Header)\n\tif err != nil {\n\t\tif errors.Is(err, gwebsocket.ErrBadHandshake) {\n\t\t\tcause := err\n\t\t\tif resp != nil && len(resp.Status) > 0 {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tcause = fmt.Errorf(\"%w (%s)\", err, resp.Status)\n\t\t\t\tresponseErrorBytes, readErr := io.ReadAll(io.LimitReader(resp.Body, 64*1024))\n\t\t\t\tif readErr != nil {\n\t\t\t\t\tcause = fmt.Errorf(\"%w: unable to read error from server response\", cause)\n\t\t\t\t} else {\n\t\t\t\t\tresponseError := strings.TrimSpace(string(responseErrorBytes))\n\t\t\t\t\tif len(responseError) > 0 {\n\t\t\t\t\t\tif obj, _, decodeErr := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); decodeErr == nil {\n\t\t\t\t\t\t\tif status, ok := obj.(*metav1.Status); ok {\n\t\t\t\t\t\t\t\tcause = &apierrors.StatusError{ErrStatus: *status}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcause = fmt.Errorf(\"%w: %s\", cause, responseError)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, &httpstream.UpgradeFailureError{Cause: cause}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tfoundProtocol := false\n\tfor _, protocolVersion := range protocolVersions {\n\t\tif protocolVersion == wsConn.Subprotocol() {\n\t\t\tfoundProtocol = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !foundProtocol {\n\t\twsConn.Close()\n\t\treturn nil, &httpstream.UpgradeFailureError{Cause: fmt.Errorf(\"invalid protocol, expected one of %q, got %q\", protocolVersions, wsConn.Subprotocol())}\n\t}\n\n\trt.Conn = wsConn\n\n\treturn resp, nil\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttransportCfg, err := config.TransportConfig()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttlsConfig, err := transport.TLSConfigFor(transportCfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxy := config.Proxy\n\tif proxy == nil {\n\t\tproxy = utilnet.NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)\n\t}\n\n\tupgradeRoundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxy,\n\t}\n\twrapper, err := transport.HTTPWrappersForConfig(transportCfg, upgradeRoundTripper)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn wrapper, upgradeRoundTripper, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/klog/v2\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(*http.Request) (*url.URL, error)\n\tConn      *websocket.Conn\n}\n\nfunc (r *RoundTripper) Connection() *websocket.Conn {\n\treturn r.Conn\n}\n\nfunc (r *RoundTripper) DataBufferSize() int {\n\treturn 32768\n}\n\nfunc (r *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn r.TLSConfig\n}\n\nfunc (r *RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif r.Conn == nil {\n\t\tvar err error\n\t\tr.Conn, _, err = websocket.DefaultDialer.Dial(r.Proxier(req), r.TLSConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Handle protocol negotiation and message transmission\n\t// This is a simplified example; actual implementation may vary based on server requirements\n\tresp, err := r.Conn.WriteMessage(websocket.TextMessage, []byte(\"Hello, server!\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read response from server\n\tmsgType, msg := r.Conn.ReadMessage()\n\tif msgType == websocket.CloseMessage {\n\t\tklog.Infof(\"Connection closed: %s\", msg)\n\t\treturn nil, fmt.Errorf(\"connection closed: %s\", msg)\n\t}\n\n\treturn &http.Response{\n\t\tStatusCode: 200,\n\t\tBody:       io.NopCloser(bytes.NewBuffer(msg)),\n\t}, nil\n}\n\nfunc RoundTripperFor(config *rest.Config) (http.RoundTripper, *websocket.Conn, error) {\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: config.InsecureSkipTLSVerify,\n\t\tServerName:         config.Host,\n\t}\n\n\tproxier := func(req *http.Request) (*url.URL, error) {\n\t\tproxyURL, err := url.Parse(config.Proxy)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq.URL.Scheme = proxyURL.Scheme\n\t\treq.URL.Host = proxyURL.Host\n\t\treq.URL.Path = \"\"\n\t\treturn proxyURL, nil\n\t}\n\n\tconn := &websocket.Conn{}\n\troundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxier,\n\t\tConn:      conn,\n\t}\n\n\treturn roundTripper, conn, nil\n}"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a WebSocket client connection wrapper in Go that provides a simplified interface for reading and writing binary messages over a WebSocket connection, with proper error handling and connection management.\n\nStruct Description: The Conn struct wraps a WebSocket connection and provides io.Reader/io.Writer compatible methods for binary message communication, along with standard net.Conn interface methods.\n\nFields:\nwsConn: *websocket.Conn - The underlying WebSocket connection\nreader: io.Reader - Current message reader for streaming message content\n\nMethods:\nNew: (wsConn *websocket.Conn) -> *Conn - Creates a new Conn wrapper instance\nDial: (ctx context.Context, url string, opts ...DialOption) -> (*Conn, error) - Establishes a new WebSocket connection with optional configuration\nRead: (b []byte) -> (int, error) - Reads binary data from the WebSocket connection (implements io.Reader)\nWrite: (b []byte) -> (int, error) - Writes binary data to the WebSocket connection (implements io.Writer)\nClose: () -> error - Closes the WebSocket connection\nLocalAddr: () -> net.Addr - Returns local network address\nRemoteAddr: () -> net.Addr - Returns remote network address\nSetDeadline: (t time.Time) -> error - Sets both read and write deadlines\nSetReadDeadline: (t time.Time) -> error - Sets read deadline\nSetWriteDeadline: (t time.Time) -> error - Sets write deadline",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: nil,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\toptions := dialOptions{}\n\tfor _, o := range opts {\n\t\to.apply(&options)\n\t}\n\n\tdialer := &websocket.Dialer{\n\t\tHandshakeTimeout: 60 * time.Second,\n\t}\n\n\tif options.tlsConfig != nil {\n\t\tdialer.TLSClientConfig = options.tlsConfig\n\t}\n\n\theader := make(http.Header)\n\tif options.token != \"\" {\n\t\theader.Set(\"Authorization\", \"Bearer \"+options.token)\n\t}\n\n\twsConn, resp, err := dialer.DialContext(\n\t\tctx, url, header,\n\t)\n\tif err == nil {\n\t\treturn New(wsConn), nil\n\t}\n\tif resp == nil {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\tdefer resp.Body.Close()\n\n\terr = fmt.Errorf(\"%d: %w\", resp.StatusCode, err)\n\tif _, ok := retryableStatusCodes[resp.StatusCode]; ok {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\treturn nil, err\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tfor {\n\t\tif c.reader == nil {\n\t\t\tmt, r, err := c.wsConn.NextReader()\n\t\t\tif err != nil {\n\t\t\t\tvar closeErr *websocket.CloseError\n\t\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\t\treturn 0, net.ErrClosed\n\t\t\t\t}\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif mt != websocket.BinaryMessage {\n\t\t\t\treturn 0, fmt.Errorf(\"unexpected message type: %d\", mt)\n\t\t\t}\n\t\t\tc.reader = r\n\t\t}\n\n\t\tn, err := c.reader.Read(b)\n\t\tif n > 0 {\n\t\t\tif err != nil {\n\t\t\t\tc.reader = nil\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err\n\t\t}\n\t\tif err != io.EOF {\n\t\t\tvar closeErr *websocket.CloseError\n\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\treturn 0, net.ErrClosed\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc.reader = nil\n\t}\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tif err := c.wsConn.WriteMessage(websocket.BinaryMessage, b); err != nil {\n\t\tvar closeErr *websocket.CloseError\n\t\tif errors.As(err, &closeErr) {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: wsConn,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\td := dialer{}\n\tfor _, opt := range opts {\n\t\topt(&d)\n\t}\n\tconn, _, err := d.DialContext(ctx, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn New(conn), nil\n}\n\ntype dialer struct {\n\tHandshakeTimeout time.Duration\n}\n\nfunc (d *dialer) DialContext(ctx context.Context, url string, headers map[string][]string) (net.Conn, http.Header, error) {\n\t// Simulate WebSocket dialing\n\tconn, _, err := websocket.DefaultDialer.DialContext(ctx, url, headers)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn New(conn), nil, nil\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tn, err := c.wsConn.ReadMessage()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcopy(b, n)\n\treturn len(n), nil\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\treturn len(b), c.wsConn.WriteMessage(websocket.BinaryMessage, b)\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.wsConn.SetDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Implement a WebSocket server handler for a DERP (Distributed Encrypted Relay for Packets) server using the nhooyr.io/websocket library in Go. The handler should upgrade HTTP connections to WebSocket, enforce protocol requirements, and establish the connection for DERP communication.\n\nStruct Description: The DERPServer struct represents a DERP server instance that handles WebSocket connections for relaying encrypted packets between Tailscale nodes.\n\nFields:\nkey: [key.NodePrivate] - The private key used for node authentication\ntailscaleDERP: [*derp.Server] - The underlying DERP server instance that manages relay connections\n\nMethods:\nserveWebsocket: [Name](writer http.ResponseWriter, req *http.Request) -> [void] - Handles incoming HTTP requests by upgrading them to WebSocket connections. Validates the subprotocol, creates a network connection wrapper around the WebSocket, and passes it to the DERP server for handling.\n\nInput:\n- writer: [http.ResponseWriter] - The HTTP response writer\n- req: [*http.Request] - The incoming HTTP request\n\nOutput:\n- None (handles connection directly, may write error responses to writer)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/coder/websocket\"\n\t\"tailscale.com/derp\"\n\t\"tailscale.com/net/wsconn\"\n)\n\ntype DERPServer struct {\n\tkey           key.NodePrivate\n\ttailscaleDERP *derp.Server\n}\n\nfunc (d *DERPServer) serveWebsocket(writer http.ResponseWriter, req *http.Request) {\n\twebsocketConn, err := websocket.Accept(writer, req, &websocket.AcceptOptions{\n\t\tSubprotocols:   []string{\"derp\"},\n\t\tOriginPatterns: []string{\"*\"},\n\t\tCompressionMode: websocket.CompressionDisabled,\n\t})\n\tif err != nil {\n\t\twriter.Header().Set(\"Content-Type\", \"text/plain\")\n\t\twriter.WriteHeader(http.StatusInternalServerError)\n\t\t_, err = writer.Write([]byte(\"Failed to upgrade websocket request\"))\n\t\treturn\n\t}\n\tdefer websocketConn.Close(websocket.StatusInternalError, \"closing\")\n\tif websocketConn.Subprotocol() != \"derp\" {\n\t\twebsocketConn.Close(websocket.StatusPolicyViolation, \"client must speak the derp subprotocol\")\n\t\treturn\n\t}\n\n\twc := wsconn.NetConn(req.Context(), websocketConn, websocket.MessageBinary, req.RemoteAddr)\n\tbrw := bufio.NewReadWriter(bufio.NewReader(wc), bufio.NewWriter(wc))\n\td.tailscaleDERP.Accept(req.Context(), wc, brw, req.RemoteAddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"nhooyr.io/websocket\"\n\t\"github.com/tailscale/erect/derp\"\n\t\"github.com/tailscale/erect/key\"\n)\n\ntype DERPServer struct {\n\tkey             key.NodePrivate\n\ttailscaleDERP   *derp.Server\n}\n\nfunc (s *DERPServer) serveWebsocket(w http.ResponseWriter, r *http.Request) {\n\tif err := websocket.Accept(w, r); err != nil {\n\t\thttp.Error(w, \"WebSocket accept error\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tconn, err := s.tailscaleDERP.NewConnection(s.key)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to create DERP connection\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif err := websocket.WriteMessage(w, websocket.TextMessage, []byte(\" DERP Connection Established \")); err != nil {\n\t\thttp.Error(w, \"Failed to send WebSocket message\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, p, err := websocket.ReadMessage(w)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif _, err = conn.Write(p); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tp, err := conn.Read()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := websocket.WriteMessage(w, websocket.TextMessage, p); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Implement a WebSocket server in Go that handles WebSocket connections, messages, and events using the nhooyr.io/websocket package. The server should provide event-based handling for connection establishment, message reception, and connection closure.\n\nStruct Description: The `testServer` struct represents a WebSocket server with event handling capabilities. It manages HTTP routes, WebSocket connections, and provides methods to subscribe to WebSocket events.\n\nFields:\n\n- sync.Mutex: sync.Mutex - Provides thread-safe access to the server's resources\n- eventEmitter: playwright.EventEmitter - Handles event subscription and emission for WebSocket events\n- mux: *http.ServeMux - HTTP request multiplexer for routing\n- testServer: *httptest.Server - HTTP test server instance\n- routes: map[string]http.HandlerFunc - Map of URL paths to their handler functions\n- requestSubscriberes: map[string][]chan *http.Request - Channels for request subscribers\n- PREFIX: string - Server URL prefix\n- EMPTY_PAGE: string - Path to empty page\n- CROSS_PROCESS_PREFIX: string - Prefix for cross-process communication\n- WS_PREFIX: string - WebSocket endpoint prefix\n- PORT: string - Server port number\n\nMethods:\n\n- wsHandler: (w http.ResponseWriter, r *http.Request) -> void - Handles WebSocket connection upgrade and message processing\n- OnceWebSocketConnection: (handler func(c *websocket.Conn, r *http.Request)) -> void - Registers a one-time connection handler\n- OnWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a persistent close handler\n- OnceWebSocketClose: (handler func(err *websocket.CloseError)) -> void - Registers a one-time close handler\n- OnWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a persistent message handler\n- OnceWebSocketMessage: (handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) -> void - Registers a one-time message handler\n- SendOnWebSocketConnection: (msgType websocket.MessageType, data []byte) -> void - Sends a message when a connection is established\n- WaitForWebSocketConnection: () -> <-chan *wsConnection - Returns a channel that receives the first WebSocket connection\n\nAdditional Struct:\n\n- wsConnection: struct - Represents an active WebSocket connection\n  Fields:\n    - Conn: *websocket.Conn - The WebSocket connection\n    - Req: *http.Request - The associated HTTP request\n  Methods:\n    - SendMessage: (msgType websocket.MessageType, data []byte) -> void - Sends a message through the connection",
    "Canonical_solution": "import (\n\t\"github.com/coder/websocket\"\n\t\"github.com/playwright-community/playwright-go\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype testServer struct {\n\tsync.Mutex\n\teventEmitter         playwright.EventEmitter\n\tmux                  *http.ServeMux\n\ttestServer           *httptest.Server\n\troutes               map[string]http.HandlerFunc\n\trequestSubscriberes  map[string][]chan *http.Request\n\tPREFIX               string\n\tEMPTY_PAGE           string\n\tCROSS_PROCESS_PREFIX string\n\tWS_PREFIX            string\n\tPORT                 string\n}\n\nfunc (t *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tInsecureSkipVerify: true,\n\t})\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not upgrade ws connection:\", err)\n\t\treturn\n\t}\n\tdefer c.Close(websocket.StatusNormalClosure, \"\")\n\n\tt.eventEmitter.Emit(\"connection\", c, r)\n\n\tfor {\n\t\ttyp, message, err := c.Read(r.Context())\n\t\tif err != nil {\n\t\t\tcloseErr := new(websocket.CloseError)\n\t\t\tif errors.As(err, closeErr) {\n\t\t\t\tt.eventEmitter.Emit(\"close\", closeErr)\n\t\t\t}\n\t\t\tswitch websocket.CloseStatus(err) {\n\t\t\tcase websocket.StatusNormalClosure, websocket.StatusGoingAway, websocket.StatusNoStatusRcvd:\n\t\t\tdefault:\n\t\t\t\tlog.Println(\"testServer: could not read ws message:\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tt.eventEmitter.Emit(\"message\", c, r, typ, message)\n\t}\n}\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (c *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\terr := c.Conn.Write(c.Req.Context(), msgType, data)\n\tif err != nil {\n\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\treturn\n\t}\n}\n\nfunc (t *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\tt.eventEmitter.Once(\"connection\", handler)\n}\n\nfunc (t *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.On(\"close\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\tt.eventEmitter.Once(\"close\", handler)\n}\n\nfunc (t *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.On(\"message\", handler)\n}\n\nfunc (t *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\tt.eventEmitter.Once(\"message\", handler)\n}\n\nfunc (t *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\terr := c.Write(r.Context(), msgType, data)\n\t\tif err != nil {\n\t\t\tlog.Println(\"testServer: could not write ws message:\", err)\n\t\t\treturn\n\t\t}\n\t})\n}\n\nfunc (t *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\tchannel := make(chan *wsConnection)\n\tt.OnceWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tchannel <- &wsConnection{Conn: c, Req: r}\n\t\tclose(channel)\n\t})\n\treturn channel\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/nhooyr/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\ntype testServer struct {\n\tmu              sync.Mutex\n\teventEmitter    *playwright.EventEmitter\n\tmux             *http.ServeMux\n\ttestServer      *httptest.Server\n\troutes          map[string]http.HandlerFunc\n\trequestSubscribers map[string][]chan *http.Request\n\tPREFIX          string\n\tEMPTY_PAGE      string\n\tCROSS_PROCESS_PREFIX string\n\tWS_PREFIX       string\n\tPORT            string\n}\n\ntype wsConnection struct {\n\tConn *websocket.Conn\n\tReq  *http.Request\n}\n\nfunc (c *wsConnection) SendMessage(msgType websocket.MessageType, data []byte) {\n\terr := c.Conn.WriteMessage(msgType, data)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending message:\", err)\n\t}\n}\n\nfunc (s *testServer) wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n\tif err != nil {\n\t\thttp.Error(w, \"WebSocket upgrade failed\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tc := &wsConnection{\n\t\tConn: conn,\n\t\tReq:  r,\n\t}\n\ts.eventEmitter.Emit(\"connection\", c)\n\ts.OnWebSocketConnection(func(c *websocket.Conn, r *http.Request) {\n\t\tc.SendMessage(websocket.TextMessage, []byte(\"Connection established\"))\n\t})\n}\n\nfunc (s *testServer) OnceWebSocketConnection(handler func(c *websocket.Conn, r *http.Request)) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.OnceWebSocketConnection = handler\n}\n\nfunc (s *testServer) OnWebSocketClose(handler func(err *websocket.CloseError)) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.OnWebSocketClose = handler\n}\n\nfunc (s *testServer) OnceWebSocketClose(handler func(err *websocket.CloseError)) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.OnceWebSocketClose = handler\n}\n\nfunc (s *testServer) OnWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.OnWebSocketMessage = handler\n}\n\nfunc (s *testServer) OnceWebSocketMessage(handler func(c *websocket.Conn, r *http.Request, msgType websocket.MessageType, msg []byte)) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.OnceWebSocketMessage = handler\n}\n\nfunc (s *testServer) SendOnWebSocketConnection(msgType websocket.MessageType, data []byte) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.SendOnWebSocketConnection = func(c *websocket.Conn, r *http.Request) {\n\t\tc.SendMessage(msgType, data)\n\t}\n}\n\nfunc (s *testServer) WaitForWebSocketConnection() <-chan *wsConnection {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tch := make(chan *wsConnection)\n\ts.WaitForWebSocketConnection = func() <-chan *wsConnection {\n\t\treturn ch\n\t}\n\treturn ch\n}\n\nfunc TestWebSocketServer(t *testing.T) {\n\tsuite.Run(t, new(WebSocketServerTestSuite))\n}\n\ntype WebSocketServerTestSuite struct {\n\tsuite.Suite\n\tserver *testServer\n}\n\nfunc (s *WebSocketServerTestSuite) SetupTest() {\n\ts.server = &testServer{\n\t\teventEmitter:    &playwright.EventEmitter{},\n\t\tmux:             mux.NewRouter(),\n\t\troutes:          make(map[string]http.HandlerFunc),\n\t\trequestSubscribers: make(map[string][]chan *http.Request),\n\t\tPREFIX:          \"/test\",\n\t\tEMPTY_PAGE:      \"/empty\",\n\t\tCROSS_PROCESS_PREFIX: \"/cross-process\",\n\t\tWS_PREFIX:       \"/ws\",\n\t\tPORT:            \"8080\",\n\t}\n\ts.server.mux.HandleFunc(s.server.PREFIX+s.server.WS_PREFIX, s.server.wsHandler)\n\ts.server.testServer = httptest.NewServer(s.server.mux)\n}\n\nfunc (s *WebSocketServerTestSuite) TearDownTest() {\n\ts.server.testServer.Close()\n}\n\nfunc (s *WebSocketServerTestSuite) TestWebSocketServer() {\n\ts.Require().Equal(\"/\", s.server.mux.URLPrefix())\n\ts.Require().Equal(s.server.PREFIX+s.server.WS_PREFIX, s.server.mux.URLPrefix()+s.server.WS_PREFIX)\n\ts.Require().Equal(s.server.EMPTY_PAGE, s.server.mux.URLPrefix()+s.server.EMPTY_PAGE)\n\ts.Require().Equal(s.server.CROSS_PROCESS_PREFIX, s.server.mux.URLPrefix()+s.server.CROSS_PROCESS_PREFIX)\n\ts.Require().Equal(s.server.WS_PREFIX, s.server.mux.URLPrefix()+s.server.WS_PREFIX)\n\ts.Require().Equal(s.server.PORT, s.server.testServer.Listener.Addr().String())\n}\n\nfunc (s *WebSocketServerTestSuite) TestWebSocketConnection() {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: func(netw, addr string) (net.Conn, error) {\n\t\t\t\treturn net.Dial(netw, s.server.testServer.URL + s.server.PREFIX+s.server.WS_PREFIX)\n\t\t\t},\n\t\t},\n\t}\n\treq, _ := http.NewRequest(\"GET\", s.server.testServer.URL+s.server.PREFIX+s.server.WS_PREFIX, nil)\n\treq.Header.Set(\"Upgrade\", \"websocket\")\n\treq.Header.Set(\"Connection\", \"Upgrade\")\n\tresp, _ := client.Do(req)\n\tdefer resp.Body.Close()\n\t// Check if the connection is upgraded\n\tassert.Equal(s.T(), http.StatusSwitchingProtocols, resp.StatusCode)\n}\n\nfunc (s *WebSocketServerTestSuite) TestWebSocketMessage() {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: func(netw, addr string) (net.Conn, error) {\n\t\t\t\treturn net.Dial(netw, s.server.testServer.URL + s.server.PREFIX+s.server.WS_PREFIX)\n\t\t\t},\n\t\t},\n\t}\n\treq, _ := http.NewRequest(\"GET\", s.server.testServer.URL+s.server.PREFIX+s.server.WS_PREFIX, nil)\n\treq.Header.Set(\"Upgrade\", \"websocket\")\n\treq.Header.Set(\"Connection\", \"Upgrade\")\n\tresp, _ := client.Do(req)\n\tdefer resp.Body.Close()\n\t// Check if the connection is upgraded\n\tassert.Equal(s.T(), http.StatusSwitchingProtocols, resp.StatusCode)\n}"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: The task involves creating a WebSocket handler in Go that upgrades HTTP connections to WebSocket connections, manages the connection lifecycle, and handles message exchange between client and server.\n\nStruct Description: The WsHandler struct is responsible for managing WebSocket connections, including upgrading HTTP connections, handling incoming messages, and managing connection state.\n\nFields:\n- svcCtx: *svc.ServiceContext - A reference to the service context containing dependencies and configuration\n\nMethods:\n- Upgrade: (ginCtx *gin.Context) -> void - Upgrades an HTTP connection to a WebSocket connection and manages the connection lifecycle\n  Input: ginCtx *gin.Context - The Gin context containing HTTP request and response objects\n  Output: None (handles connection directly)\n\n- onReceive: (ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) -> (pb.ResponseCode, error) - Handles incoming WebSocket messages\n  Input: \n    - ctx context.Context - Context for the operation\n    - connection *gatewayservicelogic.Connection - The WebSocket connection object\n    - typ websocket.MessageType - Type of the WebSocket message\n    - msg []byte - The message content\n  Output:\n    - pb.ResponseCode - Response code indicating processing result\n    - error - Any error that occurred during processing",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tgatewayservicelogic \"github.com/cherish-chat/xxim-server/app/gateway/internal/logic/gatewayservice\"\n\t\"github.com/cherish-chat/xxim-server/common/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/zeromicro/go-zero/core/logx\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"io\"\n\t\"math\"\n\t\"nhooyr.io/websocket\"\n\t\"strings\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tr := ginCtx.Request\n\tw := ginCtx.Writer\n\tlogger := logx.WithContext(r.Context())\n\theaders := make(map[string]string)\n\tfor k, v := range r.Header {\n\t\tif len(v) > 0 {\n\t\t\theaders[k] = v[0]\n\t\t}\n\t}\n\theader := &pb.RequestHeader{\n\t\tClientIp: utils.Http.GetClientIP(r),\n\t}\n\tcompressionMode := websocket.CompressionNoContextTakeover\n\tif strings.Contains(r.UserAgent(), \"Safari\") {\n\t\tcompressionMode = websocket.CompressionDisabled\n\t}\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tSubprotocols:         nil,\n\t\tInsecureSkipVerify:   true,\n\t\tOriginPatterns:       nil,\n\t\tCompressionMode:      compressionMode,\n\t\tCompressionThreshold: 0,\n\t})\n\tif err != nil {\n\t\tif r.URL.Path == \"/\" {\n\t\t\treturn\n\t\t}\n\t\tlogger.Errorf(\"failed to accept websocket connection: %v\", err)\n\t\treturn\n\t}\n\tc.SetReadLimit(math.MaxInt32)\n\tbeforeConnectResp, err := h.svcCtx.CallbackService.UserBeforeConnect(r.Context(), &pb.UserBeforeConnectReq{Header: header})\n\tif err != nil {\n\t\tlogger.Errorf(\"beforeConnect error: %v\", err)\n\t\tc.Close(websocket.StatusCode(pb.WebsocketCustomCloseCode_CloseCodeServerInternalError), err.Error())\n\t\treturn\n\t}\n\tif !beforeConnectResp.Success {\n\t\tc.Close(websocket.StatusCode(beforeConnectResp.CloseCode), beforeConnectResp.CloseReason)\n\t\treturn\n\t}\n\n\theader.UserId = beforeConnectResp.UserId\n\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\tctx, cancelFunc := context.WithCancel(r.Context())\n\tconnection := gatewayservicelogic.NewWebsocketConnect(ctx, header, c)\n\tdefer func() {\n\t\tgatewayservicelogic.ConnectionLogic.OnDisconnect(connection)\n\t}()\n\tgo func() {\n\t\tdefer cancelFunc()\n\t\tfor {\n\t\t\tlogger.Debugf(\"start read\")\n\t\t\ttyp, msg, err := c.Read(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t} else if websocket.CloseStatus(err) == websocket.StatusNormalClosure ||\n\t\t\t\t\twebsocket.CloseStatus(err) == websocket.StatusGoingAway {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"connection reset by peer\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"corrupt input\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlogx.Errorf(\"failed to read message: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\t_, _ = h.onReceive(ctx, connection, typ, msg)\n\t\t\t}()\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\tvar aesKey []byte\n\tvar aesIv []byte\n\tvar isEncrypt bool\n\n\tconnection.PublicKeyLock.RLock()\n\t{\n\t\tif len(connection.SharedSecret) == 0 {\n\t\t\tisEncrypt = false\n\t\t} else {\n\t\t\tisEncrypt = true\n\t\t\taesKey = connection.SharedSecret[:]\n\t\t\taesIv = connection.SharedSecret[8:24]\n\t\t}\n\t}\n\tconnection.PublicKeyLock.RUnlock()\n\n\tif isEncrypt {\n\t\tvar err error\n\t\tmsg, err = utils.Aes.Decrypt(aesKey, aesIv, msg)\n\t\tif err != nil {\n\t\t\tlogx.Errorf(\"decrypt message error: %v\", err)\n\t\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t\t}\n\t}\n\n\tapiRequest := &pb.GatewayApiRequest{}\n\terr := proto.Unmarshal(msg, apiRequest)\n\tif err != nil {\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t}\n\tapiRequest.Header = connection.GetHeader()\n\troute, ok := universalRouteMap[apiRequest.Path]\n\ttracer := otel.Tracer(common.TraceName)\n\tpropagator := otel.GetTextMapPropagator()\n\tspanName := apiRequest.Path\n\tcarrier := propagation.MapCarrier{\n\t\t\"appId\":       apiRequest.Header.AppId,\n\t\t\"userId\":      apiRequest.Header.UserId,\n\t\t\"clientIp\":    apiRequest.Header.ClientIp,\n\t\t\"installId\":   apiRequest.Header.InstallId,\n\t\t\"platform\":    apiRequest.Header.Platform.String(),\n\t\t\"deviceModel\": apiRequest.Header.DeviceModel,\n\t\t\"osVersion\":   apiRequest.Header.OsVersion,\n\t\t\"appVersion\":  apiRequest.Header.AppVersion,\n\t\t\"connectTime\": connection.ConnectedTime.Format(\"2006-01-02 15:04:05\"),\n\t\t\"extra\":       apiRequest.Header.Extra,\n\t}\n\tspanCtx := propagator.Extract(ctx, carrier)\n\tspanCtx, span := tracer.Start(spanCtx, spanName,\n\t\toteltrace.WithSpanKind(oteltrace.SpanKindServer),\n\t)\n\tdefer span.End()\n\tpropagator.Inject(spanCtx, carrier)\n\tif !ok {\n\t\tlogx.Errorf(\"path 404 not found: %s\", apiRequest.Path)\n\t\tspan.SetStatus(codes.Error, \"path\"+apiRequest.Path+\"404 not found\")\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", \"path 404 not found\")\n\t}\n\tcode, responseBody, err := route(spanCtx, connection, apiRequest)\n\tif len(responseBody) > 0 {\n\t\terr := connection.SendMessage(ctx, responseBody)\n\t\tif err != nil {\n\t\t\tlogx.Infof(\"failed to write message: %v\", err)\n\t\t}\n\t}\n\tspan.SetAttributes(attribute.Int(\"responseBody.length\", len(responseBody)))\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, err.Error())\n\t} else {\n\t\tspan.SetStatus(codes.Ok, \"\")\n\t}\n\treturn code, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gin-gonic/gin\"\n\t\"your_project/svc\"\n\t\"your_project/gatewayservicelogic\"\n\t\"your_project/pb\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(c *gin.Context) {\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tc.AbortWithStatus(500)\n\t\treturn\n\t}\n\n\t// Create a new connection object\n\tconnection := &gatewayservicelogic.Connection{\n\t\t// Initialize connection fields as needed\n\t}\n\n\t// Start a goroutine to handle incoming messages\n\tgo h.onReceive(context.Background(), connection, websocket.TextMessage, nil)\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\t// Process the incoming message\n\t// Example: parse message, handle business logic, etc.\n\n\t// Return response code and error\n\treturn pb.ResponseCode_SUCCESS, nil\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawnUserNamespaceCat creates a child process in a new user namespace to read a specified file. It establishes two pipes (one for standard output and one for standard error) to communicate between the parent and child processes. The function handles process creation, data transfer through pipes, process waiting, and error handling.\n\nInput:\n- nsPath (string): Path to the user namespace to spawn the process in\n- path (string): Path to the file that should be read by the child process\n\nOutput:\n- ([]byte, error): Returns the file contents as a byte slice if successful, or an error if any step fails. The error contains detailed information about the failure.\n\nNote: The function relies on an external C function spawn_userns_cat which handles the actual process creation in the new namespace. The function manages proper resource cleanup through defer statements and handles both successful and error cases with appropriate return values.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/sirupsen/logrus\"\n)\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n// spawnUserNamespaceCat spawns a process in a new user namespace to read a file.\n// It uses pipes for inter-process communication to capture both standard output and error streams.\n// Returns the file contents as a byte slice if successful, or an error if any step fails.\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\t// Create pipes for stdout and stderr\n\trwStdout, wstdout, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trwStderr, wstderr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set up the child process in the new user namespace\n\t// This requires a C function spawn_userns_cat which is not provided here\n\t// For the purpose of this example, we assume it is available and returns the child PID\n\tpid, err := spawn_userns_cat(nsPath, path, wstdout, wstderr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Close the write ends of the pipes to signal the child to exit\n\twstdout.Close()\n\twstderr.Close()\n\n\t// Wait for the child process to finish\n\tstatus := make([]byte, 4)\n\t_, _, err = syscall.Syscall(syscall.SYS_WAITPID, uintptr(pid), unsafe.Pointer(&status[0]), 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the output and error from the pipes\n\tvar stdout []byte\n\tif rwStdout != nil {\n\t\tstdout, err = os.ReadAll(rwStdout)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar stderr []byte\n\tif rwStderr != nil {\n\t\tstderr, err = os.ReadAll(rwStderr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return the combined output and error\n\tif len(stderr) > 0 {\n\t\treturn append(stdout, stderr...), nil\n\t}\n\treturn stdout, nil\n}"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a child process using Go's pipe mechanism. The handler should start the child process, monitor its initialization status through the pipe, and handle potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct encapsulates a child process command and provides methods to manage its execution and IPC communication.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as a child process.\n\nMethods:\nStart: Start() -> error - Initializes the child process, establishes a pipe for communication, monitors the child's initialization status, and returns any errors encountered during startup or a timeout if the child process fails to initialize within the specified duration.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\t// Create a pipe for communication\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.cmd = exec.Command(\"sh\", \"-c\", \"sleep 2 && echo 'Child process initialized'\")\n\tp.cmd.Stdout = w\n\tp.cmd.Stderr = w\n\tp.cmd.Stdin = r\n\terr = p.cmd.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Wait for the child process to initialize or timeout\n\ttimer := time.NewTimer(5 * time.Second)\n\tselect {\n\tcase <-timer.C:\n\t\treturn errors.New(\"child process initialization timeout\")\n\tcase <-p.cmd.Wait():\n\t\tfmt.Println(\"Child process initialized successfully\")\n\t\treturn nil\n\t}\n}"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Go struct that manages a proxy command process with inter-process communication capabilities using pipes for error handling and status reporting.\n\nStruct Description: The proxyCommand struct represents a proxy process manager that uses os.Pipe for IPC to monitor the startup status of a userland proxy. It handles process execution, pipe communication, and timeout management.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as the proxy process\n\nMethods:\nStart: () -> error - Starts the proxy command and monitors its initialization status through a pipe. Returns nil if successful or an error if the proxy fails to start or times out. Uses a pipe to communicate startup status from the child process and implements a 16-second timeout.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n\treader *os.File\n\twriter *os.File\n}\n\nfunc (p *proxyCommand) Start() error {\n\t// Create a pipe for communication with the child process\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set up the command to be executed\n\tp.cmd = exec.Command(\"your_proxy_command\", \"arguments...\")\n\tp.cmd.Stdout = os.Stderr\n\tp.cmd.Stderr = os.Stderr\n\tp.cmd.ExtraFiles = []*os.File{reader}\n\tp.reader = reader\n\tp.writer = writer\n\n\t// Start the command\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the command to finish or timeout\n\tselect {\n\tcase <-time.After(16 * time.Second):\n\t\t// Timeout occurred, kill the process\n\t\tp.cmd.Process.Kill()\n\t\treturn os.ErrDeadlineExceeded\n\tdefault:\n\t\t// Command completed, check its exit status\n\t\tif p.cmd.Wait() == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn os.ErrFailed\n\t}\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Go struct that represents a basic HTTP server capable of serving static files from a specified directory, with fallback to a default page when files are not found.\n\nStruct Description: The Site struct represents a simple HTTP server that serves static files from a \"./site\" directory. It handles file requests and falls back to serving \"index.html\" when the requested file is not found.\n\nFields: (This struct has no explicit fields as it's used purely for organizing HTTP server functionality)\n\nMethods:\n\nMethod1: New() -> *Site - A constructor function that creates and returns a new instance of the Site struct.\n\nMethod2: Run() - Starts the HTTP server on the port specified in the configuration. It sets up a file server handler with custom 404 behavior and begins listening for requests.\n\nMethod3: notFound(http.ResponseWriter, *http.Request) - A helper function that serves the \"./site/index.html\" file when a requested resource is not found. Takes standard HTTP handler parameters and returns nothing.\n\nMethod4: server(http.FileSystem) -> http.Handler - A helper function that creates a custom file server handler with fallback behavior. Takes a filesystem interface and returns an HTTP handler.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\ntype Site struct {\n}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\tdata, _ := ioutil.ReadFile(\"./site/index.html\")\n\t_, _ = fmt.Fprintf(w, string(data))\n\treturn\n}\n\nfunc server(fs http.FileSystem) http.Handler {\n\tfileServer := http.FileServer(fs)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfilePath := path.Clean(\"./site\" + r.URL.Path)\n\t\t_, err := os.Stat(filePath)\n\t\tif err != nil {\n\t\t\tnotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfileServer.ServeHTTP(w, r)\n\t})\n}\n\nfunc (s *Site) Run() {\n\tport := config.Conf.Site.SiteBase.ListenPort\n\taddr := fmt.Sprintf(\":%d\", port)\n\thttp.ListenAndServe(addr, server(http.Dir(\"./site\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\ntype Site struct{}\n\nfunc (s *Site) New() *Site {\n\treturn &Site{}\n}\n\nfunc (s *Site) Run() {\n\tfs := http.FileServer(http.Dir(\"./site\"))\n\thandler := s.server(fs)\n\thttp.ListenAndServe(\":8080\", handler)\n}\n\nfunc (s *Site) notFound(w http.ResponseWriter, r *http.Request) {\n\tindexPath := filepath.Join(\"./site\", \"index.html\")\n\thttp.ServeFile(w, r, indexPath)\n}\n\nfunc (s *Site) server(fs http.FileSystem) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := r.URL.Path\n\t\tif _, err := fs.Open(path); err != nil {\n\t\t\ts.notFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfs.ServeHTTP(w, r)\n\t})\n}"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a userland proxy using Go's pipe mechanism. The handler starts the proxy process, monitors its initialization status, and handles potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct manages the lifecycle of a userland proxy process, including process execution, IPC communication via pipes, and status monitoring.\n\nFields:\n- cmd: *exec.Cmd - The command object representing the proxy process to be executed.\n- ExtraFiles: []*os.File - Additional file descriptors to be passed to the child process (contains the pipe writer).\n\nMethods:\n- Start() -> error - Initializes the proxy process, establishes IPC via pipe, monitors startup status, and returns any errors encountered during execution or timeout. The method creates a pipe, passes the writer to the child process, reads the initialization status from the pipe reader, and handles errors or timeouts.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd       *exec.Cmd\n\tExtraFiles []*os.File\n}\n\nfunc (p *proxyCommand) Start() error {\n\t// Create a pipe for IPC\n\tr, w := os.Pipe()\n\n\t// Set up the child process with the pipe writer\n\tp.ExtraFiles = append(p.ExtraFiles, w)\n\tp.cmd = exec.Command(\"your_proxy_executable\", \"--pipe\", \"writer\")\n\tp.cmd.Stdin = os.DevNull\n\tp.cmd.Stdout = os.DevNull\n\tp.cmd.Stderr = os.DevNull\n\tp.cmd.Env = os.Environ()\n\tp.cmd.ExtraFiles = append(p.ExtraFiles, r)\n\n\t// Start the command\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the proxy to initialize (simulate a timeout)\n\ttimeout := time.NewTimer(5 * time.Second)\n\tinitialized := false\n\treader := bufio.NewReader(r)\n\n\tselect {\n\tcase <-timeout.C:\n\t\t// Timeout occurred, kill the process\n\t\tp.cmd.Process.Kill()\n\t\treturn fmt.Errorf(\"proxy initialization timeout\")\n\tcase <-p.cmd.Wait():\n\t\t// Process exited, check if it was successful\n\t\tif p.cmd.ProcessState.ExitCode() != 0 {\n\t\t\treturn fmt.Errorf(\"proxy process exited with error: %d\", p.cmd.ProcessState.ExitCode())\n\t\t}\n\t\tinitialized = true\n\t}\n\n\tif !initialized {\n\t\treturn fmt.Errorf(\"proxy process did not initialize properly\")\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It maintains client state, base URLs, user agent, rate limits, and provides access to various API services. The struct includes methods for creating new requests and executing them.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe access to rate limits\nrateLimits: [categories]Rate - Rate limit tracking for different API categories\ncommon: service - Shared service instance used by all API services\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support, rate limiting, and response handling",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype Rate struct {\n\tLimit     int\n\tRemaining int\n\tReset     time.Time\n}\n\ntype Client struct {\n\tclientMu  sync.Mutex\n\tclient    *http.Client\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\trateMu    sync.Mutex\n\trateLimits [3]Rate\n\tcommon    *Service\n}\n\ntype Service struct {\n\tbaseURL *url.URL\n\tclient  *Client\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\treturn &Client{\n\t\tclient:    httpClient,\n\t\tBaseURL:   &url.URL{},\n\t\tUploadURL: &url.URL{},\n\t\tUserAgent: \"my-app/1.0\",\n\t}\n}\n\nfunc (c *Client) NewRequest(method string, urlStr string, body interface{}) (*http.Request, error) {\n\turl, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(method, url.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\tif body != nil {\n\t\treq.Body = http.NewBody(body)\n\t}\n\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tc.rateMu.Lock()\n\tdefer c.rateMu.Unlock()\n\n\t// Check rate limits\n\tfor i := range c.rateLimits {\n\t\tif c.rateLimits[i].Remaining > 0 {\n\t\t\tc.rateLimits[i].Remaining--\n\t\t} else {\n\t\t\t// Reset rate limit if it's time to reset\n\t\t\tif c.rateLimits[i].Reset.Before(time.Now()) {\n\t\t\t\tc.rateLimits[i].Remaining = c.rateLimits[i].Limit\n\t\t\t\tc.rateLimits[i].Reset = time.Now().Add(60 * time.Second)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"rate limit exceeded for category %d\", i)\n\t\t\t}\n\t\t}\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Response\n\tif v != nil {\n\t\terr = json.NewDecoder(resp.Body).Decode(&res)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &res, nil\n}\n\ntype Response struct {\n\tStatus int\n\tBody   string\n}\n\nfunc main() {\n\thttpClient := &http.Client{}\n\tclient := NewClient(httpClient)\n\n\tservice := &Service{\n\t\tbaseURL: &url.URL{},\n\t\tclient:  client,\n\t}\n\n\trouter := chi.NewRouter()\n\trouter.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, world!\"))\n\t})\n\n\thttp.ListenAndServe(\":8080\", router)\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a simple HTTP server in Go that responds to requests with a greeting message containing the value of the \"AUTHOR\" environment variable.\n\nFunction Description: The main function sets up a basic HTTP server with a single route (\"/\") that responds to all HTTP requests. The response is a plain text message combining \"hello \" with the value of the \"AUTHOR\" environment variable. The server listens on a specified port.\n\nInput: \n- *addr (string pointer): A command-line flag specifying the server address and port to listen on (e.g., \":8080\")\n\nOutput: \n- None (The function runs indefinitely, serving HTTP requests until interrupted)\n- For each HTTP request to \"/\", outputs \"hello [AUTHOR]\" as the response body\n\nNote: The function does not explicitly return any values but writes to the http.ResponseWriter for each incoming request. The server continues running until terminated.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\nfunc main() {\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello \"+os.Getenv(\"AUTHOR\"))\n\t})\n\thttp.ListenAndServe(*addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\taddr := os.Getenv(\"ADDR\")\n\tif addr == \"\" {\n\t\taddr = \":8080\"\n\t}\n\n\tauthor := os.Getenv(\"AUTHOR\")\n\tif author == \"\" {\n\t\tfmt.Fprintf(os.Stderr, \"AUTHOR environment variable not set\\n\")\n\t\tos.Exit(1)\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello %s\", author)\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tfmt.Fprintf(w, \"hello %s\", author)\n\t\t\t})(w, r)\n\t\t}),\n\t}\n\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\t<-quit\n\t\tserver.Shutdown(nil)\n\t}()\n\n\tfmt.Printf(\"Server listening on %s\\n\", addr)\n\terr := server.ListenAndServe(addr, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a Go struct that represents a metric sink for sending metrics to a Cortex metrics server using HTTP with advanced configuration options.\n\nStruct Description: The CortexMetricSink struct is responsible for batching and sending metrics to a Cortex server via HTTP with support for custom headers, basic authentication, proxy configuration, and connection pooling.\n\nFields:\n\nURL: string - The endpoint URL of the Cortex server to send metrics to\nRemoteTimeout: time.Duration - Timeout for HTTP requests to Cortex\nProxyURL: string - URL of the proxy server to use (optional)\nClient: *http.Client - Custom HTTP client for making requests\nlogger: *logrus.Entry - Logger for the sink\nname: string - Name identifier for the sink\ntraceClient: *trace.Client - Tracing client for distributed tracing\naddHeaders: map[string]string - Additional headers to include in requests\nbasicAuth: *BasicAuthType - Basic authentication credentials (optional)\nbatchWriteSize: int - Maximum number of metrics to batch before sending\ncounters: map[counterMapKey]float64 - Internal counter storage\nconvertCountersToMonotonic: bool - Flag to convert counters to monotonic values\nexcludedTags: map[string]struct{} - Tags to exclude from metrics\nhost: string - Host identifier for metrics\n\nMethods:\n\nStart: (tc *trace.Client) -> error - Initializes the sink with tracing and HTTP client configuration\nwriteMetrics: (ctx context.Context, metrics []samplers.InterMetric) -> error - Processes and sends a batch of metrics to Cortex\n\nBasicAuthType Struct Description: Nested struct for storing basic authentication credentials\n\nFields:\n\nUsername: util.StringSecret - Basic auth username (secret type)\nPassword: util.StringSecret - Basic auth password (secret type)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/golang/snappy\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/prometheus/prometheus/prompb\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/veneur/v14/samplers\"\n\t\"github.com/stripe/veneur/v14/sinks\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype CortexMetricSink struct {\n\tURL                        string\n\tRemoteTimeout              time.Duration\n\tProxyURL                   string\n\tClient                     *http.Client\n\tlogger                     *logrus.Entry\n\tname                       string\n\ttraceClient                *trace.Client\n\taddHeaders                 map[string]string\n\tbasicAuth                  *BasicAuthType\n\tbatchWriteSize             int\n\tcounters                   map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags               map[string]struct{}\n\thost                       string\n}\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret `yaml:\"username\"`\n\tPassword util.StringSecret `yaml:\"password\"`\n}\n\nfunc (s *CortexMetricSink) Start(tc *trace.Client) error {\n\ts.logger.Infof(\"Starting sink for %s\", s.URL)\n\tt := http.DefaultTransport.(*http.Transport).Clone()\n\tt.MaxIdleConns = MaxConns\n\tt.MaxConnsPerHost = MaxConns\n\tt.MaxIdleConnsPerHost = MaxConns\n\n\tif len(s.ProxyURL) > 0 {\n\t\tp, err := url.Parse(s.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"malformed cortex_proxy_url\")\n\t\t}\n\t\tt.Proxy = http.ProxyURL(p)\n\t}\n\n\ts.Client = &http.Client{\n\t\tTimeout:   s.RemoteTimeout,\n\t\tTransport: t,\n\t}\n\n\ts.traceClient = tc\n\treturn nil\n}\n\nfunc (s *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\tspan, _ := trace.StartSpanFromContext(ctx, \"\")\n\tdefer span.ClientFinish(s.traceClient)\n\n\twr := s.makeWriteRequest(metrics)\n\n\tdata, err := wr.Marshal()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to marshal proto\\\"\")\n\t}\n\n\tvar buf bytes.Buffer\n\tencoded := snappy.Encode(nil, data)\n\tbuf.Write(encoded)\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", s.URL, &buf)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to create http request\\\"\")\n\t}\n\n\treq.Header.Set(\"Content-Encoding\", \"snappy\")\n\treq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\treq.Header.Set(\"User-Agent\", \"veneur/cortex\")\n\treq.Header.Set(\"X-Prometheus-Remote-Write-Version\", \"0.1.0\")\n\tfor key, value := range s.addHeaders {\n\t\treq.Header.Set(key, value)\n\t}\n\tif s.basicAuth != nil {\n\t\treq.SetBasicAuth(s.basicAuth.Username.Value, s.basicAuth.Password.Value)\n\t}\n\n\tts := time.Now()\n\tr, err := s.Client.Do(req)\n\tif err != nil {\n\t\tspan.Error(err)\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: misc http client error\\\" duration_secs=%.2f\", time.Since(ts).Seconds())\n\t}\n\tdefer r.Body.Close()\n\n\tif r.StatusCode >= 300 {\n\t\tb, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: downstream returned error response with unreadable body\\\" response_code=%d\", r.StatusCode)\n\t\t}\n\t\treturn fmt.Errorf(\"cortex_err=\\\"failed to write batch: error response\\\", response_code=%d response_body=\\\"%s\\\"\", r.StatusCode, b)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package metrics\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/client_golang/api\"\n\t\"github.com/prometheus/client_golang/api/metrics\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/prometheus/common/model\"\n\t\"github.com/prometheus/prometheus/tsdb\"\n\t\"github.com/prometheus/prometheus/pkg/labels\"\n\t\"github.com/prometheus/prometheus/prompb\"\n\t\"github.com/prometheus/prometheus/storage\"\n\t\"github.com/prometheus/prometheus/storage/file\"\n\t\"github.com/prometheus/prometheus/storage/local\"\n\t\"github.com/prometheus/prometheus/storage/memory\"\n\t\"github.com/prometheus/prometheus/storage/remote\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_write\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_read\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_query\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_series\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_index\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_compactor\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_config\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_executor\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_scheduler\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_server\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_client\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_writer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_reader\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_manager\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_loader\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_store\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_index\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_series\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_indexer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_compressor\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_decompressor\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_serializer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_deserializer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_encoder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_decoder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_coder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_decoder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_serializer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_deserializer\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_encoder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_decoder\"\n\t\"github.com/prometheus/prometheus/storage/remote/remote_block_coder\"\n)\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret\n\tPassword util.StringSecret\n}\n\ntype CortexMetricSink struct {\n\tURL             string\n\tRemoteTimeout   time.Duration\n\tProxyURL        string\n\tClient          *http.Client\n\tLogger          *logrus.Entry\n\tName            string\n\tTraceClient     *trace.Client\n\tAddHeaders      map[string]string\n\tBasicAuth       *BasicAuthType\n\tBatchWriteSize  int\n\tCounters        map[counterMapKey]float64\n\tConvertCountersToMonotonic bool\n\tExcludedTags    map[string]struct{}\n\tHost            string\n}\n\nfunc (s *CortexMetricSink) Start(tc *trace.Client) error {\n\ts.TraceClient = tc\n\tif s.Client == nil {\n\t\ts.Client = &http.Client{\n\t\t\tTimeout: s.RemoteTimeout,\n\t\t}\n\t\tif s.ProxyURL != \"\" {\n\t\t\tproxy, err := url.Parse(s.ProxyURL)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Client.Transport = &http.Transport{\n\t\t\t\tProxy: http.ProxyURL(proxy),\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\t// Process and send metrics to Cortex\n\t// This is a placeholder for the actual implementation\n\treturn nil\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server with health check and metrics endpoints using Go's net/http package.\n\nFunction Description: The function `serveMetrics` initializes an HTTP server with two endpoints: `/healthz` for health checks (returns \"OK\" with 200 status) and `/metrics` for Prometheus metrics (handled by promhttp). The server listens on the specified address and runs until terminated.\n\nInput: \n- `address` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput: \n- None (function runs indefinitely until server termination)\n- Logs fatal errors if server fails to start",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc serveMetrics(address string) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\n\tlog.Fatal(http.ListenAndServe(address, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/prometheus/client_golang/prometheus/handle\"\n)\n\nfunc serveMetrics(address string) {\n\tmux := http.NewServeMux()\n\n\tmux.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\tmux.Handle(\"/metrics\", handle.DefaultServerHandler())\n\n\tserver := &http.Server{\n\t\tAddr:    address,\n\t\tHandler: mux,\n\t}\n\n\tfmt.Printf(\"Starting server on %s\\n\", address)\n\tif err := server.ListenAndServe(address, nil); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Implement a function to start an HTTP server with configurable parameters including authentication, TLS, and database integration. The function should handle routing, authentication wrapping, and server startup with both HTTP and HTTPS support.\n\nFunction Description: The `Start` function initializes and starts an HTTP server with various endpoints for database operations. It supports optional authentication via a pre-shared token and can be configured to use TLS for secure connections. The server connects to a tiedot database and provides RESTful endpoints for database operations.\n\nInput:\n- `dir` (string): Directory path for the tiedot database\n- `port` (int): Port number to listen on\n- `tlsCrt` (string): Path to TLS certificate file (empty for HTTP)\n- `tlsKey` (string): Path to TLS private key file (empty for HTTP)\n- `jwtPubKey` (string): JWT public key (unused in reference code)\n- `jwtPrivateKey` (string): JWT private key (unused in reference code)\n- `bind` (string): Network interface to bind to (empty for all interfaces)\n- `authToken` (string): Pre-shared token for authentication (empty to disable)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics on error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/HouzuoGuo/tiedot/db\"\n\t\"github.com/HouzuoGuo/tiedot/tdlog\"\n)\n\nvar (\n\tHttpDB *db.DB\n)\n\nfunc Start(dir string, port int, tlsCrt, tlsKey, jwtPubKey, jwtPrivateKey, bind, authToken string) {\n\tvar err error\n\tHttpDB, err = db.OpenDB(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thttp.HandleFunc(\"/\", Welcome)\n\thttp.HandleFunc(\"/version\", Version)\n\thttp.HandleFunc(\"/memstats\", MemStats)\n\n\tvar authWrap func(http.HandlerFunc) http.HandlerFunc\n\tif authToken != \"\" {\n\t\ttdlog.Noticef(\"API endpoints now require the pre-shared token in Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tif \"token \"+authToken != r.Header.Get(\"Authorization\") {\n\t\t\t\t\thttp.Error(w, \"\", http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\toriginalHandler(w, r)\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"API endpoints do not require Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn originalHandler\n\t\t}\n\t}\n\n\thttp.HandleFunc(\"/create\", authWrap(Create))\n\thttp.HandleFunc(\"/rename\", authWrap(Rename))\n\thttp.HandleFunc(\"/drop\", authWrap(Drop))\n\thttp.HandleFunc(\"/all\", authWrap(All))\n\thttp.HandleFunc(\"/scrub\", authWrap(Scrub))\n\thttp.HandleFunc(\"/sync\", authWrap(Sync))\n\thttp.HandleFunc(\"/query\", authWrap(Query))\n\thttp.HandleFunc(\"/count\", authWrap(Count))\n\thttp.HandleFunc(\"/insert\", authWrap(Insert))\n\thttp.HandleFunc(\"/get\", authWrap(Get))\n\thttp.HandleFunc(\"/getpage\", authWrap(GetPage))\n\thttp.HandleFunc(\"/update\", authWrap(Update))\n\thttp.HandleFunc(\"/delete\", authWrap(Delete))\n\thttp.HandleFunc(\"/approxdoccount\", authWrap(ApproxDocCount))\n\thttp.HandleFunc(\"/index\", authWrap(Index))\n\thttp.HandleFunc(\"/indexes\", authWrap(Indexes))\n\thttp.HandleFunc(\"/unindex\", authWrap(Unindex))\n\thttp.HandleFunc(\"/shutdown\", authWrap(Shutdown))\n\thttp.HandleFunc(\"/dump\", authWrap(Dump))\n\n\tiface := \"all interfaces\"\n\tif bind != \"\" {\n\t\tiface = bind\n\t}\n\n\tif tlsCrt != \"\" {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTPS), port %d.\", iface, port)\n\t\tif err := http.ListenAndServeTLS(fmt.Sprintf(\"%s:%d\", bind, port), tlsCrt, tlsKey, nil); err != nil {\n\t\t\ttdlog.Panicf(\"Failed to start HTTPS service - %s\", err)\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTP), port %d.\", iface, port)\n\t\thttp.ListenAndServe(fmt.Sprintf(\"%s:%d\", bind, port), nil)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype Server struct {\n\tdb *sql.DB\n\tr  *mux.Router\n}\n\nfunc NewServer(dir string, port int, tlsCrt, tlsKey, bind string, authToken string) (*Server, error) {\n\tdb, err := sql.Open(\"postgres\", fmt.Sprintf(\"host=%s user=postgres password=postgres dbname=tiedot sslmode=disable\", dir))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = db.Ping()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, world!\"))\n\t})\n\n\tsrv := &Server{\n\t\tdb: db,\n\t\tr:  r,\n\t}\n\n\tif authToken != \"\" {\n\t\tsrv.setupAuthMiddleware(authToken)\n\t}\n\n\tif tlsCrt != \"\" && tlsKey != \"\" {\n\t\tsrv.setupTLS(tlsCrt, tlsKey, port, bind)\n\t} else {\n\t\tsrv.setupHTTP(port, bind)\n\t}\n\n\treturn srv, nil\n}\n\nfunc (s *Server) setupAuthMiddleware(token string) {\n\ts.r.Use(func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// Simple token validation (in a real scenario, this would be more robust)\n\t\t\tif r.Header.Get(\"Authorization\") != \"Bearer \"+token {\n\t\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t\th.ServeHTTP(w, r)\n\t\t})\n\t})\n}\n\nfunc (s *Server) setupTLS(crt, key string, port int, bind string) {\n\tserver := &http.Server{\n\t\tAddr:      fmt.Sprintf(\"%s:%d\", bind, port),\n\t\tTLSConfig: &tls.Config{Certificates: []tls.Certificate{{Certificate: []byte(crt), PrivateKey: []byte(key)}}},\n\t\tHandler:   s.r,\n\t}\n\n\tfmt.Printf(\"Starting HTTPS server on %s:%d\\n\", bind, port)\n\terr := server.ListenAndServeTLS(\"\", \"\", crt, key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (s *Server) setupHTTP(port int, bind string) {\n\tserver := &http.Server{\n\t\tAddr:      fmt.Sprintf(\"%s:%d\", bind, port),\n\t\tHandler:   s.r,\n\t}\n\n\tfmt.Printf(\"Starting HTTP server on %s:%d\\n\", bind, port)\n\terr := server.ListenAndServe(\"\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc main() {\n\tdir := os.Getenv(\"TIEDOT_DIR\")\n\tport := 8080\n\ttlsCrt := \"\"\n\ttlsKey := \"\"\n\tbind := \"\"\n\tauthToken := \"\"\n\n\tif dir == \"\" {\n\t\tdir = \"./tiedot\"\n\t}\n\n\tif strings.HasPrefix(os.Getenv(\"TIEDOT_PORT\"), \":\") {\n\t\tport = 0\n\t}\n\n\tif os.Getenv(\"TIEDOT_TLS_CRT\") != \"\" {\n\t\ttlsCrt = os.Getenv(\"TIEDOT_TLS_CRT\")\n\t}\n\tif os.Getenv(\"TIEDOT_TLS_KEY\") != \"\" {\n\t\ttlsKey = os.Getenv(\"TIEDOT_TLS_KEY\")\n\t}\n\tif os.Getenv(\"TIEDOT_BIND\") != \"\" {\n\t\tbind = os.Getenv(\"TIEDOT_BIND\")\n\t}\n\tif os.Getenv(\"TIEDOT_AUTH_TOKEN\") != \"\" {\n\t\tauthToken = os.Getenv(\"TIEDOT_AUTH_TOKEN\")\n\t}\n\n\tserver, err := NewServer(dir, port, tlsCrt, tlsKey, bind, authToken)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a function that checks the health status of a Kubernetes cluster by making an HTTP GET request to the cluster's livez endpoint using a custom HTTP client with TLS configuration.\n\nFunction Description: The function `GetClusterStatusByAPI` verifies the health of a Kubernetes cluster by sending an HTTPS request to the cluster's `/livez` endpoint. It uses a custom `http.Client` with TLS configuration loaded from the cluster's connection settings. The function returns a boolean indicating the cluster's health status and a string containing any error messages or the response body if the check fails.\n\nInput: \n- `addr` [string]: The address of the Kubernetes cluster API server.\n- `cluster` [*model.Cluster]: A pointer to a cluster object containing connection configuration details.\n\nOutput: \n- [bool]: `true` if the cluster is healthy (HTTP status code 200), `false` otherwise.\n- [string]: An empty string if the cluster is healthy, otherwise an error message or the response body.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/client-go/rest\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\treqURL := fmt.Sprintf(\"https://%s/livez\", addr)\n\tconf, err := clusterUtil.LoadConnConf(cluster, addr)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"load cluster config error %s\", err.Error())\n\t}\n\ttls2, err := rest.TransportFor(conf)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"config transport error %s\", err.Error())\n\t}\n\tclient := &http.Client{Timeout: 1 * time.Second, Transport: tls2}\n\trequest, _ := http.NewRequest(\"GET\", reqURL, nil)\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Https get error %s\", err.Error())\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode == 200 {\n\t\treturn true, \"\"\n\t}\n\ts, _ := ioutil.ReadAll(response.Body)\n\treturn false, fmt.Sprintf(\"Api check error %s\", string(s))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\t// Create TLS config\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t}\n\n\t// Create HTTP client with TLS config\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t},\n\t}\n\n\t// Construct URL\n\turl := fmt.Sprintf(\"https://%s/livez\", addr)\n\n\t// Send HTTP GET request\n\tresp, err := client.Get(url)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check response status\n\tif resp.StatusCode != 200 {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn false, string(body)\n\t}\n\n\t// Read response body\n\tbody, _ := io.ReadAll(resp.Body)\n\treturn true, \"\"\n}"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Go HTTP server that implements WebDAV functionality with custom logging and special handling for specific HTTP headers.\n\nStruct Description: The webdav.Handler struct provides WebDAV server functionality with in-memory storage for files and locks. We'll wrap this with custom request handling.\n\nFields:\n- FileSystem: webdav.FileSystem - In-memory filesystem implementation\n- LockSystem: webdav.LockSystem - In-memory lock system implementation\n- Logger: func(*http.Request, error) - Custom logging function for request tracking\n\nMethods:\n- ServeHTTP: (http.ResponseWriter, *http.Request) -> () - Main handler method that processes HTTP requests\n- NewMemFS: () -> webdav.FileSystem - Creates new in-memory filesystem\n- NewMemLS: () -> webdav.LockSystem - Creates new in-memory lock system\n\nAdditional Functions:\n- main: () -> () - Entry point that sets up the server and routes\n- requestHandler: (http.ResponseWriter, *http.Request) -> () - Custom middleware for special header handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype webdavHandler struct {\n\tFileSystem webdav.FileSystem\n\tLockSystem webdav.LockSystem\n\tLogger    func(*http.Request, error)\n}\n\nfunc (h *webdavHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.requestHandler(w, r)\n}\n\nfunc (h *webdavHandler) requestHandler(w http.ResponseWriter, r *http.Request) {\n\t// Custom header handling\n\tif strings.HasPrefix(r.Header.Get(\"X-Special-Header\"), \"Special\") {\n\t\tfmt.Fprintf(w, \"Special header detected!\\n\")\n\t\treturn\n\t}\n\n\t// Default WebDAV handling\n\twebdav.DefaultHandler(h.FileSystem, h.LockSystem).ServeHTTP(w, r)\n}\n\nfunc NewMemFS() webdav.FileSystem {\n\treturn webdav.NewMemFS()\n}\n\nfunc NewMemLS() webdav.LockSystem {\n\treturn webdav.NewMemLS()\n}\n\nfunc main() {\n\tfs := NewMemFS()\n\tlockSystem := NewMemLS()\n\tlogger := func(r *http.Request, err error) {\n\t\tfmt.Printf(\"Request: %s %s %s\\n\", r.Method, r.URL, r.RemoteAddr)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t}\n\t}\n\n\thandler := &webdavHandler{\n\t\tFileSystem: fs,\n\t\tLockSystem: lockSystem,\n\t\tLogger:     logger,\n\t}\n\n\thttp.ListenAndServe(\":8080\", handler)\n}"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a function that sets up a basic HTTP server to receive SDP (Session Description Protocol) data through HTTP POST requests and forward it through a channel.\n\nFunction Description: The function `httpSDPServer` creates an HTTP server that listens on a specified port. When a POST request is received at the root path (\"/\"), it reads the request body, sends the body content through a channel, and responds with \"done\". The server runs in a separate goroutine to avoid blocking.\n\nInput: \n- port [int] - The port number on which the HTTP server should listen\n\nOutput:\n- [chan string] - A channel that will receive the SDP data from incoming HTTP requests",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tfmt.Fprintf(w, \"done\")\n\t\tsdpChan <- string(body)\n\t})\n\n\tgo func() {\n\t\tpanic(http.ListenAndServe(\":\"+strconv.Itoa(port), nil))\n\t}()\n\n\treturn sdpChan\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "func httpSDPServer(port int) chan string {\n\tch := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tch <- string(body)\n\t\tw.Write([]byte(\"done\"))\n\t})\n\tgo func() {\n\t\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\treturn ch\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a function that performs an HTTP request with custom headers and handles the response, including error handling and logging for debugging purposes.\n\nFunction Description: The function `realRequest` performs an HTTP request with custom headers, handles authentication, and processes the response. It includes validation of required headers, adds security tokens and user agents, computes signatures for authentication, and handles response errors. Debug logging is available for both requests and responses.\n\nInput:\n- `ctx` (context.Context): Context for the request, allowing cancellation and timeouts.\n- `project` (*LogProject): A struct containing project-specific details like base URL, access keys, and user agent.\n- `method` (string): HTTP method (e.g., \"GET\", \"POST\").\n- `uri` (string): The URI path for the request.\n- `headers` (map[string]string): A map of HTTP headers to include in the request.\n- `body` ([]byte): The request body as a byte slice.\n\nOutput:\n- (*http.Response, error): Returns the HTTP response and an error if any occurred during the request or response handling. The error is wrapped in custom error types for better context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"time\"\n\n\t\"github.com/go-kit/kit/log/level\"\n)\n\nvar (\n\tdefaultRequestTimeout = 60 * time.Second\n\tdefaultRetryTimeout   = 90 * time.Second\n\tdefaultHttpClient     = &http.Client{\n\t\tTimeout: defaultRequestTimeout,\n\t}\n)\n\nfunc realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif _, ok := headers[\"x-log-bodyrawsize\"]; !ok {\n\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'x-log-bodyrawsize' header\"))\n\t}\n\n\tbaseURL := project.getBaseURL()\n\theaders[\"Host\"] = baseURL\n\theaders[\"Date\"] = nowRFC1123()\n\theaders[\"x-log-apiversion\"] = version\n\theaders[\"x-log-signaturemethod\"] = signatureMethod\n\tif len(project.UserAgent) > 0 {\n\t\theaders[\"User-Agent\"] = project.UserAgent\n\t} else {\n\t\theaders[\"User-Agent\"] = DefaultLogUserAgent\n\t}\n\n\tif project.SecurityToken != \"\" {\n\t\theaders[\"x-acs-security-token\"] = project.SecurityToken\n\t}\n\n\tif body != nil {\n\t\tbodyMD5 := fmt.Sprintf(\"%X\", md5.Sum(body))\n\t\theaders[\"Content-MD5\"] = bodyMD5\n\t\tif _, ok := headers[\"Content-Type\"]; !ok {\n\t\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'Content-Type' header\"))\n\t\t}\n\t}\n\n\tdigest, err := signature(project.AccessKeySecret, method, uri, headers)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tauth := fmt.Sprintf(\"SLS %v:%v\", project.AccessKeyID, digest)\n\theaders[\"Authorization\"] = auth\n\n\treader := bytes.NewReader(body)\n\turlStr := fmt.Sprintf(\"%s%s\", baseURL, uri)\n\treq, err := http.NewRequest(method, urlStr, reader)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Add(k, v)\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpRequest(req, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Request:\\n%v\", string(dump))\n\t}\n\n\tresp, err := project.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\terr := &Error{}\n\t\terr.HTTPCode = (int32)(resp.StatusCode)\n\t\tdefer resp.Body.Close()\n\t\tbuf, ioErr := ioutil.ReadAll(resp.Body)\n\t\tif ioErr != nil {\n\t\t\treturn nil, NewBadResponseError(ioErr.Error(), resp.Header, resp.StatusCode)\n\t\t}\n\t\tif jErr := json.Unmarshal(buf, err); jErr != nil {\n\t\t\treturn nil, NewBadResponseError(string(buf), resp.Header, resp.StatusCode)\n\t\t}\n\t\terr.RequestID = resp.Header.Get(RequestIDHeader)\n\t\treturn nil, err\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpResponse(resp, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Response:\\n%v\", string(dump))\n\t}\n\treturn resp, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype LogProject struct {\n\tBaseURL string\n\tAccessKey string\n\tSecretKey string\n\tUserAgent string\n}\n\nfunc realRequest(ctx context.Context, project *LogProject, method string, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif project == nil {\n\t\treturn nil, fmt.Errorf(\"project is nil\")\n\t}\n\n\tif project.BaseURL == \"\" {\n\t\treturn nil, fmt.Errorf(\"base URL is empty\")\n\t}\n\n\tif method == \"\" {\n\t\treturn nil, fmt.Errorf(\"method is empty\")\n\t}\n\n\tif uri == \"\" {\n\t\treturn nil, fmt.Errorf(\"URI is empty\")\n\t}\n\n\t// Validate required headers\n\trequiredHeaders := map[string]bool{\"Authorization\": true, \"User-Agent\": true}\n\tfor header, required := range requiredHeaders {\n\t\tif required && headers[header] == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"required header %s is missing\", header)\n\t\t}\n\t}\n\n\t// Add security tokens and user agent\n\theaders[\"User-Agent\"] = project.UserAgent\n\tauthToken := generateAuthToken(project.AccessKey, project.SecretKey, method, uri, headers)\n\theaders[\"Authorization\"] = authToken\n\n\t// Create the request\n\turl := project.BaseURL + uri\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(body))\n\tif err != nil {\n\t\tlog.Printf(\"Error creating request: %v\", err)\n\t\treturn nil, err\n\t}\n\n\t// Set headers\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\tlog.Printf(\"Error sending request: %v\", err)\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Log response\n\tlog.Printf(\"Response status: %s\", resp.Status)\n\tbodyBytes, _ := io.ReadAll(resp.Body)\n\tlog.Printf(\"Response body: %s\", string(bodyBytes))\n\n\t// Check for errors in response\n\tif resp.StatusCode >= 400 {\n\t\treturn nil, fmt.Errorf(\"HTTP error: %s\", resp.Status)\n\t}\n\n\treturn resp, nil\n}\n\nfunc generateAuthToken(accessKey, secretKey, method, uri string, headers map[string]string) string {\n\t// Placeholder for actual token generation logic\n\t// This should compute a signature based on the request parameters\n\tsignature := fmt.Sprintf(\"%s-%s-%s-%s\", method, uri, accessKey, secretKey)\n\tfor k, v := range headers {\n\t\tsignature += \"-\" + k + \"-\" + v\n\t}\n\treturn \"Bearer \" + signature\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests on specified routes, supports HTTPS with TLS certificates, and redirects HTTP traffic to HTTPS.\n\nFunction Description: The code demonstrates setting up a basic HTTP server with HTTPS support. It includes a handler function to process requests, sets up an HTTP-to-HTTPS redirect, and starts both HTTP and HTTPS servers concurrently.\n\nInput:\n- Port numbers for HTTP (9999) and HTTPS (10443) servers\n- TLS certificate files (\"cert.pem\" and \"key.pem\")\n- HTTP request objects (*http.Request) for the handler function\n\nOutput:\n- HTTP responses (through http.ResponseWriter)\n- Server logs indicating server status and errors\n- Automatic HTTP-to-HTTPS redirection (301 Moved Permanently)\n\nMethods:\n1. handler(w http.ResponseWriter, req *http.Request) - Processes incoming requests and writes a plain text response\n2. main() - Configures and starts the HTTP and HTTPS servers, including the redirect handler",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"This is an example server.\\n\"))\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tlog.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\")\n\tgo http.ListenAndServe(\":9999\", http.RedirectHandler(\"https://127.0.0.1:10443/\", 301))\n\terr := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Hello, world!\\n\")\n}\n\nfunc redirectHandler(w http.ResponseWriter, req *http.Request) {\n\thttp.Redirect(w, req, \"https://\"+req.Host+req.URL.Path, 301)\n}\n\nfunc main() {\n\thttpPort := 9999\n\thttpsPort := 10443\n\tcertFile := \"cert.pem\"\n\tkeyFile := \"key.pem\"\n\n\t// Check if certificate files exist\n\tif _, err := os.Stat(certFile); os.IsNotExist(err) {\n\t\tfmt.Printf(\"Error: Certificate file %s not found\\n\", certFile)\n\t\tos.Exit(1)\n\t}\n\tif _, err := os.Stat(keyFile); os.IsNotExist(err) {\n\t\tfmt.Printf(\"Error: Key file %s not found\\n\", keyFile)\n\t\tos.Exit(1)\n\t}\n\n\t// Create HTTP server with redirect handler\n\thttpServer := &http.Server{\n\t\tAddr:       fmt.Sprintf(\":%d\", httpPort),\n\t\tHandler:    http.HandlerFunc(redirectHandler),\n\t\tErrorLog:   nil,\n\t\tIdleTimeout: 30 * time.Second,\n\t}\n\n\t// Create HTTPS server with handler\n\thttpsServer := &http.Server{\n\t\tAddr:       fmt.Sprintf(\":%d\", httpsPort),\n\t\tHandler:    http.HandlerFunc(handler),\n\t\tErrorLog:   nil,\n\t\tIdleTimeout: 30 * time.Second,\n\t}\n\n\t// Set up TLS configuration\n\ttlsConfig := &tls.Config{\n\t\tMinVersion: tls.VersionTLS12,\n\t\tCipherSuites: []uint16{\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\t},\n\t}\n\n\t// Load TLS certificate\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\tfmt.Println(\"Error loading TLS certificate:\", err)\n\t\tos.Exit(1)\n\t}\n\ttlsConfig.Certificates = []tls.Certificate{cert}\n\n\t// Start HTTP and HTTPS servers\n\tgo func() {\n\t\tif err := httpServer.ListenAndServeTLS(\"\", \"\", tlsConfig); err != nil {\n\t\t\tfmt.Printf(\"HTTP server error: %v\\n\", err)\n\t\t}\n\t}()\n\n\tif err := httpsServer.ListenAndServeTLS(certFile, keyFile, tlsConfig); err != nil {\n\t\tfmt.Printf(\"HTTPS server error: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server with instrumented handlers for metrics collection using Prometheus. The function should register routes for metrics and a custom endpoint, apply middleware for context handling, and instrument handlers with counters and histograms.\n\nFunction Description: The function ExampleInstrumentHandlerWithLabelResolver demonstrates how to create an HTTP server with Prometheus instrumentation. It sets up counter and histogram metrics, creates handlers for specific routes, applies middleware to extract headers into context, and starts the server on port 3000. The function doesn't take any explicit parameters but relies on package-level configurations.\n\nInput: None (uses package-level constants and variables)\n\nOutput: None (starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\nfunc ExampleInstrumentHandlerWithLabelResolver() {\n\tcounter := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"api_requests_total\",\n\t\t\tHelp: \"A counter for requests to the wrapped handler.\",\n\t\t},\n\t\t[]string{\"code\", \"method\", \"myheader\"},\n\t)\n\n\tduration := prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"request_duration_seconds\",\n\t\t\tHelp:    \"A histogram of latencies for requests.\",\n\t\t\tBuckets: []float64{.25, .5, 1, 2.5, 5, 10},\n\t\t},\n\t\t[]string{\"handler\", \"method\", \"myheader\"},\n\t)\n\n\tpullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Pull\"))\n\t})\n\n\topts := WithLabelFromCtx(\"myheader\",\n\t\tfunc(ctx context.Context) string {\n\t\t\treturn ctx.Value(CtxResolverKey).(string)\n\t\t},\n\t)\n\n\tpullChain := InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{\"handler\": \"pull\"}),\n\t\tInstrumentHandlerCounter(counter, pullHandler, opts),\n\t\topts,\n\t)\n\n\tmiddleware := func(next http.HandlerFunc) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), CtxResolverKey, r.Header.Get(\"x-my-header\"))\n\n\t\t\tnext(w, r.WithContext(ctx))\n\t\t}\n\t}\n\n\thttp.Handle(\"/metrics\", Handler())\n\thttp.Handle(\"/pull\", middleware(pullChain))\n\n\tif err := http.ListenAndServe(\":3000\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors/histogram\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"go.uber.org/zap\"\n)\n\nvar (\n\tmux        = http.NewServeMux()\n\tlistenAddr = \":3000\"\n\tlogger     = zap.New(zap.Sugar())\n)\n\nvar (\n\trequestCounter = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"http_request_count\",\n\t\t\tHelp: \"Total number of HTTP requests.\",\n\t\t},\n\t\t[]string{\"method\", \"endpoint\"},\n\t)\n\trequestDuration = prometheus.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_duration_seconds\",\n\t\t\tHelp:    \"HTTP request duration in seconds.\",\n\t\t\tBuckets: []float64{0.001, 0.01, 0.1, 0.5, 1, 2, 5, 10},\n\t\t},\n\t\t[]string{\"method\", \"endpoint\"},\n\t)\n)\n\nfunc init() {\n\tprometheus.Register(requestCounter)\n\tprometheus.Register(requestDuration)\n}\n\nfunc main() {\n\t// Register metrics endpoint\n\tmux.Handle(\"/metrics\", promhttp.HandlerFor(prometheus.Gatherer{prometheus.NewPedagogicalGatherer()}, promhttp.HandlerOpts{}))\n\n\t// Register custom endpoint\n\tmux.HandleFunc(\"/custom\", func(w http.ResponseWriter, r *http.Request) {\n\t\tlogger.Info(\"Custom endpoint called\")\n\t\tw.Write([]byte(\"Hello from custom endpoint!\"))\n\t})\n\n\t// Start server\n\tserver := &http.Server{\n\t\tAddr:           listenAddr,\n\t\tHandler:        mux,\n\t\tMaxIdleConns:   1000,\n\t\tIdleConnTimeout: 90 * time.Second,\n\t}\n\n\t// Handle shutdown signal\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Start server in a separate goroutine\n\tgo func() {\n\t\tif err := server.ListenAndServe(listenAddr, nil); err != nil {\n\t\t\tlogger.Error(\"Server failed to start\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Wait for shutdown signal\n\t<-sigChan\n\tlogger.Info(\"Shutting down server...\")\n\n\t// Gracefully shutdown the server\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tif err := server.Shutdown(ctx); err != nil {\n\t\tlogger.Error(\"Server shutdown failed\", zap.Error(err))\n\t}\n}"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a function that sets up a basic HTTP server to receive SDP (Session Description Protocol) data through HTTP POST requests and forward it through a channel.\n\nFunction Description: The function `httpSDPServer` creates an HTTP server that listens on a specified port. When a POST request is received at the root path (\"/\"), it reads the request body, sends the body content through a channel, and responds with \"done\". The server runs in a separate goroutine to avoid blocking.\n\nInput: \n- `port` [int] - The port number on which the HTTP server should listen.\n\nOutput:\n- `chan string` - A channel that will receive the SDP data from incoming HTTP requests.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc httpSDPServer(port int) chan string {\n\tsdpChan := make(chan string)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tfmt.Fprintf(w, \"done\")\n\t\tsdpChan <- string(body)\n\t})\n\n\tgo func() {\n\t\tpanic(http.ListenAndServe(\":\"+strconv.Itoa(port), nil))\n\t}()\n\n\treturn sdpChan\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "func httpSDPServer(port int) chan string {\n\tch := make(chan string)\n\tgo func() {\n\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.Method != \"POST\" {\n\t\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tch <- string(body)\n\t\t\tw.Write([]byte(\"done\"))\n\t\t})\n\t\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\treturn ch\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement an HTTP worker struct that can process jobs by making HTTP requests with custom headers and handling the responses appropriately.\n\nStruct Description: HTTPWorker is a struct that handles HTTP job processing with configurable user agent and logging capabilities. It implements job execution by making POST requests to specified URLs with JSON payloads and processing the responses.\n\nFields:\nUserAgent: string - The User-Agent header value to be used in HTTP requests\nLogger: *zerolog.Logger - Logger instance for debug and error logging\n\nMethods:\nWork: (job jobqueue.Job) -> *jobqueue.Result - Processes a job by making an HTTP POST request to the job's URL with the job's payload as JSON. Handles request creation, execution, response reading, and result parsing. Returns a jobqueue.Result indicating the outcome of the job processing.\n\nInput Parameters:\n- job: jobqueue.Job - Contains the job details including URL, payload, and timeout\n\nOutput:\n- *jobqueue.Result - The result of the job processing, including status, code, and message",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fireworq/fireworq/jobqueue\"\n\t\"github.com/rs/zerolog\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\nfunc (worker *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\tclient := &http.Client{\n\t\tTimeout: time.Duration(job.Timeout()) * time.Second,\n\t}\n\treq, err := http.NewRequest(\n\t\t\"POST\",\n\t\tjob.URL(),\n\t\tstrings.NewReader(job.Payload()),\n\t)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Cannot create http request: %v\", err),\n\t\t}\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tuserAgent := worker.UserAgent\n\tif userAgent == \"\" {\n\t\tuserAgent = defaultUserAgent\n\t}\n\treq.Header.Add(\"User-Agent\", userAgent)\n\n\tresp, err := client.Do(req)\n\n\tworker.Logger.Debug().\n\t\tStr(\"action\", \"dispatch\").\n\t\tStr(\"worker\", \"HTTPWorker\").\n\t\tStr(\"url\", job.URL()).\n\t\tStr(\"payload\", job.Payload()).\n\t\tMsg(\"Dispatched via HTTP\")\n\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Request failed: %v\", err),\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Cannot read body: %v\", err),\n\t\t}\n\t}\n\n\tvar rslt jobqueue.Result\n\terr = json.Unmarshal(body, &rslt)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus: jobqueue.ResultStatusFailure,\n\t\t\tCode:   resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Cannot parse body as JSON: %v\\nOriginal response body:\\n%s\",\n\t\t\t\terr,\n\t\t\t\tstring(body),\n\t\t\t),\n\t\t}\n\t}\n\n\tif !rslt.IsValid() {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Invalid result status: %s\\nOriginal response body:\\n%s\", rslt.Status, string(body)),\n\t\t}\n\t}\n\n\trslt.Code = resp.StatusCode\n\treturn &rslt\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype Job struct {\n\tURL      string        `json:\"url\"`\n\tPayload  map[string]interface{} `json:\"payload\"`\n\tTimeout  time.Duration\n}\n\ntype Result struct {\n\tStatus  string `json:\"status\"`\n\tCode    int    `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *log.Logger\n}\n\nfunc (w *HTTPWorker) Work(job Job) *Result {\n\tctx, cancel := context.WithTimeout(context.Background(), job.Timeout)\n\tdefer cancel()\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", job.URL, json.NewEncoder(bytes.Buffer{}))\n\tif err != nil {\n\t\tw.Logger.Err(err).Msg(\"Failed to create request\")\n\t\treturn &Result{Status: \"error\", Code: 500, Message: \"Failed to create request\"}\n\t}\n\n\treq.Header.Set(\"User-Agent\", w.UserAgent)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tw.Logger.Err(err).Msg(\"Failed to execute request\")\n\t\treturn &Result{Status: \"error\", Code: 500, Message: \"Failed to execute request\"}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tw.Logger.Err(err).Msg(\"Failed to read response body\")\n\t\treturn &Result{Status: \"error\", Code: 500, Message: \"Failed to read response body\"}\n\t}\n\n\tvar result Result\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\tw.Logger.Err(err).Msg(\"Failed to parse response\")\n\t\treturn &Result{Status: \"error\", Code: 500, Message: \"Failed to parse response\"}\n\t}\n\n\tw.Logger.Info().Msgf(\"Job processed successfully: %s\", job.URL)\n\treturn &result\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Go struct that represents local network services capable of running both a DNS server and an HTTP server concurrently. The DNS server should resolve a specific domain to a local IP address, while the HTTP server should serve predefined webpages.\n\nStruct Description: The `localNetworkServices` struct encapsulates functionality for running concurrent DNS and HTTP servers. The DNS server resolves a configured domain to a local IP address, and the HTTP server serves static web content mapped to specific paths.\n\nFields:\n- domain: string - The domain name that will be resolved by the DNS server\n- webpages: map[string]string - A map of URL paths to their corresponding webpage content\n- ipAddr: string - The local IP address that both servers will bind to\n\nMethods:\n- DNSServerIP() -> string - Returns the IP address of the DNS server\n- URL(subpath string) -> string - Constructs a full URL for a given subpath using the configured domain\n- Serve(ctx context.Context) -> error - Starts both DNS and HTTP servers concurrently using an errgroup, returns any error that occurs during execution\n\nAdditional Helper Struct:\n- dnsHandler: Implements the dns.Handler interface to handle DNS queries\n\nFields:\n- records: map[string]string - A map of domain names to their corresponding IP addresses\n\nMethods:\n- ServeDNS(w dns.ResponseWriter, r *dns.Msg) - Handles incoming DNS queries, responding with A records for configured domains",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"github.com/miekg/dns\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (l localNetworkServices) DNSServerIP() string {\n\treturn l.ipAddr\n}\n\nfunc (l localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s/%s\", l.domain, subpath)\n}\n\nfunc (l localNetworkServices) Serve(ctx context.Context) error {\n\terrGroup, _ := errgroup.WithContext(ctx)\n\n\terrGroup.Go(func() error {\n\t\tdnsSrv := &dns.Server{\n\t\t\tAddr: l.ipAddr + \":53\",\n\t\t\tNet:  \"udp\",\n\t\t\tHandler: &dnsHandler{\n\t\t\t\trecords: map[string]string{\n\t\t\t\t\tl.domain + \".\": l.ipAddr,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treturn dnsSrv.ListenAndServe()\n\t})\n\n\terrGroup.Go(func() error {\n\t\tfor path, contents := range l.webpages {\n\t\t\twebpage := contents\n\t\t\thttp.HandleFunc(\"/\"+path, func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tio.WriteString(w, webpage)\n\t\t\t})\n\t\t}\n\n\t\treturn http.ListenAndServe(l.ipAddr+\":80\", nil)\n\t})\n\n\treturn errGroup.Wait()\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tmsg := dns.Msg{}\n\tmsg.SetReply(r)\n\tif r.Question[0].Qtype == dns.TypeA {\n\t\tmsg.Authoritative = true\n\t\tdomain := msg.Question[0].Name\n\t\taddress, ok := h.records[domain]\n\t\tif ok {\n\t\t\tmsg.Answer = append(msg.Answer, &dns.A{\n\t\t\t\tHdr: dns.RR_Header{Name: domain, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 3600},\n\t\t\t\tA:   net.ParseIP(address),\n\t\t\t})\n\t\t} else {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t}\n\n\tw.WriteMsg(&msg)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/miekg/dns\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n\tdnsHandler\n\tmu       sync.RWMutex\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (d *dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tif r.Hdr.Op == dns.OP_QUERY && r.Hdr.RRCount == 0 {\n\t\tm := new(dns.Msg)\n\t\tm.SetReply(r)\n\t\tm.Hdr.Op = dns.OP_REPLY\n\t\tfor _, q := range r.Answer {\n\t\t\tif q.Type == dns.A {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NS {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.CNAME {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.MX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SOA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.TXT {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.PTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AAAA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SRV {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NAPTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.KX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SIG {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.DNSKEY {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.PX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ECDSA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.TLSA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.OPT {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AUX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.A6 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.APL {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ANY {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.UA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.URI {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.CDNAME {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AFSDB {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.X25 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ISCN {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SSHFP {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SSHFP {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.OPT {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AUX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.A6 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.APL {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ANY {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.UA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.URI {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.CDNAME {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AFSDB {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.X25 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ISCN {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SSHFP {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SSHFP {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NSEC3PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.OPT {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AUX {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.A6 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.APL {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ANY {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.UA {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.URI {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.CDNAME {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.AFSDB {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.X25 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.ISCN {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.SSHFP {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif q.Type == dns.NID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif len(m.Answer) == 0 {\n\t\t\tm.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t\tw.WriteMsg(m)\n\t}\n}\n\nfunc NewLocalNetworkServices(domain, ipAddr string, webpages map[string]string) *localNetworkServices {\n\treturn &localNetworkServices{\n\t\tdomain:     domain,\n\t\tipAddr:     ipAddr,\n\t\twebpages:   webpages,\n\t\trecords:    make(map[string]string),\n\t\tdnsHandler: dnsHandler{records: make(map[string]string)},\n\t}\n}\n\nfunc (s *localNetworkServices) DNSServerIP() string {\n\treturn s.ipAddr\n}\n\nfunc (s *localNetworkServices) URL(subpath string) string {\n\tu, _ := url.Parse(s.domain)\n\tu.Path = subpath\n\treturn u.String()\n}\n\nfunc (s *localNetworkServices) Serve(ctx context.Context) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\ts.records[s.domain] = s.ipAddr\n\n\tdnsServer := &dns.Server{\n\t\tAddr:        fmt.Sprintf(\"%s:53\", s.ipAddr),\n\t\tHandFunc:    s.dnsHandler.ServeDNS,\n\t\tTimeout:     10 * time.Second,\n\t\tUDPSize:     65507,\n\t\tMaxMsgSize:  1024,\n\t}\n\n\thttpServer := &http.Server{\n\t\tAddr:         fmt.Sprintf(\"%s:80\", s.ipAddr),\n\t\tHandler:      http.HandlerFunc(s.handleHTTP),\n\t\tMaxHeaderSize: 1 << 20,\n\t\tIdleConnTimeout: 90 * time.Second,\n\t}\n\n\tif err := dnsServer.ListenAndServe(\"udp\", nil); err != nil {\n\t\treturn err\n\t}\n\n\tif err := httpServer.ListenAndServe(\":80\", nil); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *localNetworkServices) handleHTTP(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Path\n\tcontent, ok := s.webpages[path]\n\tif ok {\n\t\tw.Write([]byte(content))\n\t} else {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tw.Write([]byte(\"Page not found\"))\n\t}\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a basic HTTP server in Go that serves a template-based web page and handles requests on a configurable port.\n\nFunction Description: The main function sets up an HTTP server with a root route handler that renders a template. It configures the server port from environment variables with a default fallback, then starts the server.\n\nInput: \n- Environment variable \"PORT\" (optional): Specifies the port number to listen on\n- Template file \"todos/index.jet\": The template to be rendered and served\n\nOutput:\n- HTTP server running on the specified port, serving the rendered template at the root path (\"/\")\n- Log output indicating the server's running status and any template errors\n\nNote: The reference code shows the implementation but doesn't explicitly define separate functions for each operation. The main function combines:\n1. Route handling (with template rendering)\n2. Port configuration\n3. Server startup",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tview, err := views.GetTemplate(\"todos/index.jet\")\n\t\tif err != nil {\n\t\t\tlog.Println(\"Unexpected template err:\", err.Error())\n\t\t}\n\t\tview.Execute(w, nil, todos)\n\t})\n\n\tport := os.Getenv(\"PORT\")\n\tif len(port) == 0 {\n\t\tport = \":8080\"\n\t} else if !strings.HasPrefix(\":\", port) {\n\t\tport = \":\" + port\n\t}\n\n\tlog.Println(\"Serving on \" + port)\n\thttp.ListenAndServe(port, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "package main\n\nimport (\n\t\"embed\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/go-templates/go-templates\"\n\t\"github.com/gorilla/mux\"\n\t\"net/http\"\n)\n\n//go:embed todos/index.jet\nvar templateFS embed.FS\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttmpl, err := templates.New(\"index.jet\").ParseFS(templateFS, \"todos/index.jet\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdata := map[string]string{\n\t\t\t\"message\": \"Hello from the template!\",\n\t\t}\n\n\t\terr = tmpl.Execute(w, data)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t})\n\n\tfmt.Printf(\"Server running on port %s\\n\", port)\n\terr := http.ListenAndServe(\":\"+port, router)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t}\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that performs HTTP requests with customizable options including TLS configuration, request method, headers, and payload.\n\nFunction Description: The function DoRequest executes HTTP requests with various configurable options. It handles TLS configuration (including insecure mode), sets request headers, processes different HTTP methods, and manages response reading. The function is designed to be flexible for different API interaction scenarios while maintaining security and error handling.\n\nInput:\n- opt (EtcdRequestOption struct) - Configuration options for the HTTP request containing:\n  - Endpoint (string): Base URL for the request\n  - Api (string): API endpoint path\n  - PostData (string): Request payload data\n  - TlsConfig (*tls.Config): TLS configuration (nil for insecure)\n  - Method (string): HTTP method (GET, POST, etc.)\n  - Silent (bool): Unused in current implementation\n\nOutput:\n- (string) - Response body content as string\n- (error) - Error object if request fails, nil on success",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/cdk-team/CDK/pkg/errors\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\tif opt.TlsConfig == nil || len(opt.TlsConfig.Certificates) == 0 || opt.TlsConfig.RootCAs == nil {\n\t\topt.TlsConfig = &tls.Config{InsecureSkipVerify: true}\n\t}\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t},\n\t\tTimeout: time.Duration(5) * time.Second,\n\t}\n\n\trequest, err := http.NewRequest(opt.Method, opt.Endpoint+opt.Api, bytes.NewBuffer([]byte(opt.PostData)))\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found while generate post request in net.http .\"}\n\t}\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(request)\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t} else if err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\treturn string(content), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint string\n\tApi      string\n\tPostData string\n\tTlsConfig *tls.Config\n\tMethod   string\n\tSilent   bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\turl := opt.Endpoint + opt.Api\n\treq, err := http.NewRequest(opt.Method, url, strings.NewReader(opt.PostData))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif opt.TlsConfig != nil {\n\t\tclient := &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t\t},\n\t\t}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif resp.StatusCode >= 400 {\n\t\t\treturn \"\", fmt.Errorf(\"request failed with status code %d: %s\", resp.StatusCode, string(body))\n\t\t}\n\t\treturn string(body), nil\n\t} else {\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif resp.StatusCode >= 400 {\n\t\t\treturn \"\", fmt.Errorf(\"request failed with status code %d: %s\", resp.StatusCode, string(body))\n\t\t}\n\t\treturn string(body), nil\n\t}\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves static files from an embedded filesystem using the go.rice package.\n\nFunction Description: The main function initializes an Echo web server, sets up route handlers for serving static files from an embedded directory (\"app\"), and starts the server on port 1323. The static files are served under the root path (\"/\") and a static prefix path (\"/static/*\").\n\nInput: None (The function takes no explicit parameters)\n\nOutput: None (The function doesn't return anything explicitly but starts an HTTP server that runs indefinitely until interrupted)\n\nNote: The reference code shows the complete implementation at the package level (main function) rather than as an isolated function or struct. The instruction follows the function-level format as the code primarily demonstrates functional behavior rather than object-oriented structure.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\tassetHandler := http.FileServer(rice.MustFindBox(\"app\").HTTPBox())\n\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", assetHandler)))\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/vgarvardt/gorice\"\n)\n\nfunc main() {\n\trice, _ := gorice.NewFromBox(\"app\")\n\te := echo.New()\n\n\te.StaticFS(\"/\", rice.Boxes[\"app\"])\n\te.StaticFS(\"/static/\", rice.Boxes[\"static\"])\n\n\te.Logger.Info(\"Server started on port 1323\")\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a Go struct that implements an HTTP server using the Echo framework, supporting both HTTP/2 and HTTPS configurations, with customizable timeouts and root path handling.\n\nStruct Description: The Api struct represents an HTTP server configuration with support for TLS, HTTP/2, and customizable timeouts. It provides methods to start and stop the server gracefully.\n\nFields:\nport: int - The port number on which the server will listen\nbindIp: string - The IP address to bind the server to\ntlsCertFile: string - Path to TLS certificate file (empty for non-HTTPS)\ntlsKeyFile: string - Path to TLS private key file (empty for non-HTTPS)\ntimeout: time.Duration - Server timeout duration for read/write operations\nrootPath: string - The root path for the server's default route\nsrv: *echo.Echo - The Echo server instance\n\nMethods:\nStart: () -> error - Initializes and starts the HTTP server in a goroutine, supporting both TLS and HTTP/2 configurations. Returns nil on successful startup.\nStop: (ctx context.Context) -> error - Gracefully shuts down the server using the provided context. Returns any error that occurs during shutdown.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype Api struct {\n\tport        int\n\tbindIp      string\n\ttlsCertFile string\n\ttlsKeyFile  string\n\ttimeout     time.Duration\n\trootPath    string\n\tsrv         *echo.Echo\n}\n\nfunc (a *Api) Start() error {\n\ta.srv = echo.New()\n\ta.srv.HideBanner = true\n\ta.srv.HidePort = true\n\ta.srv.Server.ReadTimeout = a.timeout\n\ta.srv.Server.IdleTimeout = a.timeout\n\ta.srv.Server.WriteTimeout = a.timeout + a.timeout\n\n\ta.srv.GET(\n\t\ta.rootPath,\n\t\tfunc(c echo.Context) error {\n\t\t\treturn c.HTML(http.StatusOK, `Hey, Gotenberg has no UI, it's an API. Head to the <a href=\"https://gotenberg.dev\">documentation</a> to learn how to interact with it \ud83d\ude80`)\n\t\t},\n\t)\n\n\tgo func() {\n\t\tvar err error\n\t\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\t\terr = a.srv.StartTLS(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), a.tlsCertFile, a.tlsKeyFile)\n\t\t} else {\n\t\t\tserver := &http2.Server{}\n\t\t\terr = a.srv.StartH2CServer(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), server)\n\t\t}\n\t\tif !errors.Is(err, http.ErrServerClosed) {\n\t\t\ta.logger.Fatal(err.Error())\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\treturn a.srv.Shutdown(ctx)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "wrong_result": "package main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype Api struct {\n\tport          int\n\tbindIp        string\n\ttlsCertFile   string\n\ttlsKeyFile    string\n\ttimeout       time.Duration\n\trootPath      string\n\tsrv           *echo.Echo\n}\n\nfunc (a *Api) Start() error {\n\te := echo.New()\n\te.Logger.SetLevel(\"info\")\n\te.Timeout = a.timeout\n\te.Path = a.rootPath\n\n\tif a.port <= 0 {\n\t\ta.port = 8080\n\t}\n\n\tif a.bindIp == \"\" {\n\t\ta.bindIp = \"0.0.0.0\"\n\t}\n\n\tvar err error\n\tvar srv *echo.Echo\n\n\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\tsrv, err = echo.NewHTTP2Server(e, echo.WithTLSConfig(\n\t\t\t&echo.TLSConfig{\n\t\t\t\tCertFile:   a.tlsCertFile,\n\t\t\t\tKeyFile:    a.tlsKeyFile,\n\t\t\t\tMinVersion: 123,\n\t\t\t\tMaxVersion: 123,\n\t\t\t},\n\t\t))\n\t} else {\n\t\tsrv = e\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.srv = srv\n\tgo func() {\n\t\tif err := srv.ListenAndServe(a.bindIp+\":\"+strconv.Itoa(a.port), nil); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\tif a.srv == nil {\n\t\treturn nil\n\t}\n\n\ta.srv.Stop()\n\treturn nil\n}"
  }
]