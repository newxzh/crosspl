[
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles JSONP requests, serving dynamic JSON data wrapped in a callback function.\n\nFunction Description: The main function initializes an Echo server, sets up middleware for logging and recovery, serves static files from a \"public\" directory, and defines a route (\"/jsonp\") that responds to GET requests with JSONP-formatted data containing a response message, current timestamp, and random number.\n\nInput: None (The function takes no direct input parameters, but the \"/jsonp\" endpoint accepts an optional query parameter \"callback\" specifying the JSONP callback function name)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and serves responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Static(\"/\", \"public\")\n\n\te.GET(\"/jsonp\", func(c echo.Context) error {\n\t\tcallback := c.QueryParam(\"callback\")\n\t\tvar content struct {\n\t\t\tResponse  string    `json:\"response\"`\n\t\t\tTimestamp time.Time `json:\"timestamp\"`\n\t\t\tRandom    int       `json:\"random\"`\n\t\t}\n\t\tcontent.Response = \"Sent via JSONP\"\n\t\tcontent.Timestamp = time.Now().UTC()\n\t\tcontent.Random = rand.Intn(1000)\n\t\treturn c.JSONP(http.StatusOK, callback, &content)\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\te.Static(\"/\", \"public\")\n\n\te.GET(\"/jsonp\", func(c *echo.Context) error {\n\t\tcallback := c.QueryParam(\"callback\")\n\t\tif callback == \"\" {\n\t\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Hello from JSONP\", \"timestamp\": time.Now().Format(time.RFC3339), \"random\": fmt.Sprintf(\"%d\", rand.Intn(100))})\n\t\t}\n\n\t\tjsonpData := map[string]string{\n\t\t\t\"message\": \"Hello from JSONP\",\n\t\t\t\"timestamp\": time.Now().Format(time.RFC3339),\n\t\t\t\"random\": fmt.Sprintf(\"%d\", rand.Intn(100)),\n\t\t}\n\n\t\tresponse := fmt.Sprintf(\"%s(%v)\", callback, jsonpData)\n\t\treturn c.XML(http.StatusOK, response)\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic routes and includes middleware for logging and recovery.\n\nFunction Description: The main function initializes a new Echo instance, sets up middleware for logging and panic recovery, defines a route handler for the root path (\"/\"), and starts the HTTP server on port 1323.\n\nInput: None (The function takes no direct input parameters; configuration is done internally)\n\nOutput: None (The function does not return any value; it starts an HTTP server that runs indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\\n\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(200, \"Hello, World!\")\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles POST requests for two different endpoints (/tenhou and /majsoul) to process incoming data and forward it to respective receivers.\n\nStruct Description: The mjHandler struct is a request handler that processes incoming HTTP requests for the Tenhou and Majsoul game platforms, logging errors and forwarding data to appropriate receivers.\n\nFields:\n- log: echo.Logger - Logger for error and info logging\n- tenhouMessageReceiver: *tenhou.MessageReceiver - Receiver for Tenhou game messages\n- majsoulMessageQueue: chan []byte - Channel for buffering Majsoul game messages\n\nMethods:\n- analysisTenhou: (c echo.Context) -> error - Processes POST requests to /tenhou endpoint, reads request body, forwards data to tenhouMessageReceiver, and returns HTTP response\n- analysisMajsoul: (c echo.Context) -> error - Processes POST requests to /majsoul endpoint, reads request body, sends data to majsoulMessageQueue, and returns HTTP response\n\nFunction Description: The runServer function initializes and starts an HTTP server with configurable port and HTTPS options, setting up routes and middleware for the Echo framework.\n\nInput:\n- isHTTPS: bool - Flag indicating whether to use HTTPS\n- port: int - Port number for the server to listen on\n\nOutput:\n- error - Returns any error that occurs during server startup or operation",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/labstack/gommon/log\"\n\tstdLog \"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype mjHandler struct {\n\tlog echo.Logger\n\n\ttenhouMessageReceiver *tenhou.MessageReceiver\n\tmajsoulMessageQueue   chan []byte\n}\n\nfunc (h *mjHandler) analysisTenhou(c echo.Context) error {\n\tdata, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.logError(err)\n\t\treturn c.String(http.StatusBadRequest, err.Error())\n\t}\n\n\th.tenhouMessageReceiver.Put(data)\n\treturn c.NoContent(http.StatusOK)\n}\n\nfunc (h *mjHandler) analysisMajsoul(c echo.Context) error {\n\tdata, err := ioutil.ReadAll(c.Request().Body)\n\tif err != nil {\n\t\th.logError(err)\n\t\treturn c.String(http.StatusBadRequest, err.Error())\n\t}\n\n\th.majsoulMessageQueue <- data\n\treturn c.NoContent(http.StatusOK)\n}\n\nvar h *mjHandler\n\nfunc runServer(isHTTPS bool, port int) (err error) {\n\te := echo.New()\n\te.HideBanner = true\n\te.HidePort = true\n\te.StdLogger = stdLog.New(ioutil.Discard, \"\", 0)\n\te.Logger.SetLevel(log.INFO)\n\n\th = &mjHandler{\n\t\tlog:                   e.Logger,\n\t\ttenhouMessageReceiver: tenhou.NewMessageReceiver(),\n\t\tmajsoulMessageQueue:   make(chan []byte, 100),\n\t}\n\n\te.Use(middleware.Recover())\n\te.Use(middleware.CORS())\n\te.POST(\"/tenhou\", h.analysisTenhou)\n\te.POST(\"/majsoul\", h.analysisMajsoul)\n\n\taddr := \":\" + strconv.Itoa(port)\n\tif !isHTTPS {\n\t\terr = e.Start(addr)\n\t} else {\n\t\terr = startTLS(e, addr)\n\t}\n\treturn err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/labstack/echo/v4\"\n\t\"net/http\"\n)\n\ntype mjHandler struct {\n\tlog                  echo.Logger\n\ttenhouMessageReceiver *tenhou.MessageReceiver\n\tmajsoulMessageQueue   chan []byte\n}\n\nfunc (h *mjHandler) analysisTenhou(c echo.Context) error {\n\tbody, err := c.Get(\"body\").([]byte)\n\tif err != nil {\n\t\th.log.Error(\"Error reading request body:\", err)\n\t\treturn err\n\t}\n\th.tenhouMessageReceiver.Receive(body)\n\treturn c.JSON(http.StatusOK, map[string]string{\"status\": \"success\"})\n}\n\nfunc (h *mjHandler) analysisMajsoul(c echo.Context) error {\n\tbody, err := c.Get(\"body\").([]byte)\n\tif err != nil {\n\t\th.log.Error(\"Error reading request body:\", err)\n\t\treturn err\n\t}\n\th.majsoulMessageQueue <- body\n\treturn c.JSON(http.StatusOK, map[string]string{\"status\": \"success\"})\n}\n\nfunc runServer(isHTTPS bool, port int) error {\n\te := echo.New()\n\te.Use(echo.Logger())\n\n\t// Initialize handlers\n\thandler := &mjHandler{\n\t\tlog:                  e.Logger(),\n\t\ttenhouMessageReceiver: &tenhou.MessageReceiver{},\n\t\tmajsoulMessageQueue:   make(chan []byte, 100),\n\t}\n\n\te.POST(\"/tenhou\", handler.analysisTenhou)\n\te.POST(\"/majsoul\", handler.analysisMajsoul)\n\n\tif isHTTPS {\n\t\te.HTTPS(\":https://0.0.0.0:\" + fmt.Sprintf(\"%d\", port), nil, nil)\n\t} else {\n\t\te.Start(\":http://0.0.0.0:\" + fmt.Sprintf(\"%d\", port))\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Go struct that represents an HTTP server application using the Echo framework, with configurable options and standard middleware.\n\nStruct Description: The `App` struct represents an HTTP server application built on the Echo framework. It encapsulates the Echo engine instance and provides methods to initialize and run the server with common middleware (recovery, logging) and default routes.\n\nFields:\n- Engine: *echo.Echo - The core Echo framework instance that handles HTTP routing and middleware\n- Conf: *conf.Conf - Configuration object for server settings (port, debug mode, etc.)\n\nMethods:\n- NewApp: func(opts ...AppOptions) *App - Constructor that initializes a new App instance with optional configuration. Applies default middleware (recovery, logging) and sets up basic routes.\n  Input: opts ...AppOptions (variadic parameter for configuration options)\n  Output: *App (new App instance)\n\n- Run: func() - Starts the HTTP server using the configured port from Conf. Panics if server fails to start.\n  Input: None\n  Output: None (runs indefinitely until server stops)\n\n- Must: func(error) - Helper function (not shown in reference) that panics on error, typically used for server startup\n  Input: error\n  Output: None",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\toptions := AppOptions{}\n\tfor _, i := range opts {\n\t\toptions = i\n\t\tbreak\n\t}\n\n\toptions.init()\n\n\tengine := echo.New()\n\n\tengine.Debug = conf.UBool(\"debug\")\n\n\tengine.Use(middleware.Recover())\n\n\tengine.GET(\"/favicon.ico\", func(c echo.Context) error {\n\t\treturn c.Redirect(http.StatusMovedPermanently, \"/static/images/favicon.ico\")\n\t})\n\n\tengine.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `${method} | ${status} | ${uri} -> ${latency_human}` + \"\\n\",\n\t}))\n\n\tapp := &App{\n\t\tEngine: engine,\n\t}\n\n\treturn app\n}\n\nfunc (app *App) Run() {\n\tMust(app.Engine.Start(\":\" + app.Conf.UString(\"port\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype AppOptions struct {\n\tPort     int\n\tDebug    bool\n\tHostname string\n}\n\ntype App struct {\n\tEngine *echo.Echo\n\tConf   *conf.Conf\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\tapp := &App{\n\t\tEngine: echo.New(),\n\t\tConf:   &conf.Conf{},\n\t}\n\n\tfor _, opt := range opts {\n\t\tapp.Conf.Port = opt.Port\n\t\tapp.Conf.Debug = opt.Debug\n\t\tapp.Conf.Hostname = opt.Hostname\n\t}\n\n\tapp.Engine.Use(middleware.Recovery())\n\tapp.Engine.Use(middleware.Logger())\n\n\tapp.Engine.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(200, \"Hello, World!\")\n\t})\n\n\treturn app\n}\n\nfunc (a *App) Run() {\n\tif a.Conf.Port == 0 {\n\t\ta.Must(fmt.Errorf(\"port is not set\"))\n\t}\n\n\tserver := echo.New()\n\tserver.HTTPServer.Addr = \":\" + fmt.Sprintf(\"%d\", a.Conf.Port)\n\tserver.HTTPServer.SetHost(a.Conf.Hostname)\n\tserver.HTTPServer.ReadTimeout = 5\n\tserver.HTTPServer.WriteTimeout = 5\n\n\tif a.Conf.Debug {\n\t\tserver.Logger.SetLevel(\"debug\")\n\t}\n\n\tserver.Use(middleware.Recovery())\n\tserver.Use(middleware.Logger())\n\n\tserver.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(200, \"Hello, World!\")\n\t})\n\n\tif err := server.Start(server.HTTPServer.Addr); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (a *App) Must(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a Go struct that implements an HTTP server with WebSocket support using the Echo framework, capable of handling messages, health checks, and streaming, with optional authentication.\n\nStruct Description: The API struct represents an HTTP server with WebSocket capabilities, message buffering, and authentication support. It handles incoming HTTP requests and WebSocket connections while managing message broadcasting and logging.\n\nFields:\n\nMessages: [ring.Ring] - A ring buffer for storing messages with configurable capacity\nRWMutex: [sync.RWMutex] - Read-write mutex for thread-safe operations on shared data\nConfig: [*bridge.Config] - Configuration object containing server settings and parameters\nmrouter: [*melody.Melody] - WebSocket router for handling WebSocket connections and messages\n\nMethods:\n\nNew: [func(cfg *bridge.Config) bridge.Bridger] -> [bridge.Bridger] - Constructor that initializes the API instance, sets up routes, and starts the HTTP server\nhandleWebsocketMessage: [func(message config.Message, s *melody.Session)] -> [void] - Handles incoming WebSocket messages, prepares them for broadcasting, and sends to remote channel\nhandleWebsocket: [func(c echo.Context) error] -> [error] - WebSocket handler that manages WebSocket connections using the melody router\nhandleHealthcheck: [func(c echo.Context) error] -> [error] - Health check endpoint handler (implied by route registration)\nhandleMessages: [func(c echo.Context) error] -> [error] - Messages endpoint handler (implied by route registration)\nhandleStream: [func(c echo.Context) error] -> [error] - Stream endpoint handler (implied by route registration)\nhandlePostMessage: [func(c echo.Context) error] -> [error] - Message posting endpoint handler (implied by route registration)",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/olahol/melody\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype API struct {\n\tMessages ring.Ring\n\tsync.RWMutex\n\t*bridge.Config\n\tmrouter *melody.Melody\n}\n\nfunc New(cfg *bridge.Config) bridge.Bridger {\n\tb := &API{Config: cfg}\n\te := echo.New()\n\te.HideBanner = true\n\te.HidePort = true\n\n\tb.mrouter = melody.New()\n\tb.mrouter.HandleMessage(func(s *melody.Session, msg []byte) {\n\t\tmessage := config.Message{}\n\t\terr := json.Unmarshal(msg, &message)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to decode message from byte[] '%s'\", string(msg))\n\t\t\treturn\n\t\t}\n\t\tb.handleWebsocketMessage(message, s)\n\t})\n\tb.mrouter.HandleConnect(func(session *melody.Session) {\n\t\tgreet := b.getGreeting()\n\t\tdata, err := json.Marshal(greet)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to encode message '%v'\", greet)\n\t\t\treturn\n\t\t}\n\t\terr = session.Write(data)\n\t\tif err != nil {\n\t\t\tb.Log.Errorf(\"failed to write message '%s'\", string(data))\n\t\t\treturn\n\t\t}\n\t})\n\n\tb.Messages = ring.Ring{}\n\tif b.GetInt(\"Buffer\") != 0 {\n\t\tb.Messages.SetCapacity(b.GetInt(\"Buffer\"))\n\t}\n\tif b.GetString(\"Token\") != \"\" {\n\t\te.Use(middleware.KeyAuth(func(key string, c echo.Context) (bool, error) {\n\t\t\treturn key == b.GetString(\"Token\"), nil\n\t\t}))\n\t}\n\n\te.GET(\"/api/health\", b.handleHealthcheck)\n\te.GET(\"/api/messages\", b.handleMessages)\n\te.GET(\"/api/stream\", b.handleStream)\n\te.GET(\"/api/websocket\", b.handleWebsocket)\n\te.POST(\"/api/message\", b.handlePostMessage)\n\tgo func() {\n\t\tif b.GetString(\"BindAddress\") == \"\" {\n\t\t\tb.Log.Fatalf(\"No BindAddress configured.\")\n\t\t}\n\t\tb.Log.Infof(\"Listening on %s\", b.GetString(\"BindAddress\"))\n\t\tb.Log.Fatal(e.Start(b.GetString(\"BindAddress\")))\n\t}()\n\treturn b\n}\n\nfunc (b *API) handleWebsocketMessage(message config.Message, s *melody.Session) {\n\tmessage.Channel = \"api\"\n\tmessage.Protocol = \"api\"\n\tmessage.Account = b.Account\n\tmessage.ID = \"\"\n\tmessage.Timestamp = time.Now()\n\n\tdata, err := json.Marshal(message)\n\tif err != nil {\n\t\tb.Log.Errorf(\"failed to encode message for loopback '%v'\", message)\n\t\treturn\n\t}\n\t_ = b.mrouter.BroadcastOthers(data, s)\n\n\tb.Log.Debugf(\"Sending websocket message from %s on %s to gateway\", message.Username, \"api\")\n\tb.Remote <- message\n}\n\nfunc (b *API) handleWebsocket(c echo.Context) error {\n\terr := b.mrouter.HandleRequest(c.Response(), c.Request())\n\tif err != nil {\n\t\tb.Log.Errorf(\"error in websocket handling  '%v'\", err)\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package bridge\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/melody\"\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype API struct {\n\tMessages  *ring.Ring\n\tRWMutex   *sync.RWMutex\n\tConfig    *bridge.Config\n\tmrouter   *melody.Melody\n}\n\nfunc New(cfg *bridge.Config) bridge.Bridger {\n\tapi := &API{\n\t\tMessages:  ring.New(cfg.MessageCapacity),\n\t\tRWMutex:   &sync.RWMutex{},\n\t\tConfig:    cfg,\n\t\tmrouter:   melody.New(),\n\t}\n\n\te := echo.New()\n\te.Use(middleware.AuthMiddleware)\n\te.GET(\"/\", api.handleHealthcheck)\n\te.POST(\"/message\", api.handlePostMessage)\n\te.GET(\"/messages\", api.handleMessages)\n\te.GET(\"/stream\", api.handleStream)\n\te.GET(\"/ws\", api.handleWebsocket)\n\n\tgo func() {\n\t\tif err := e.Start(cfg.ServerAddress); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\treturn api\n}\n\nfunc (a *API) handleWebsocketMessage(message config.Message, s *melody.Session) {\n\ta.RWMutex.Lock()\n\tdefer a.RWMutex.Unlock()\n\ta.Messages.Add(message)\n\ta.mrouter.Broadcast(message, s)\n}\n\nfunc (a *API) handleWebsocket(c echo.Context) error {\n\treturn a.mrouter.Handle(c.Request(), c.Response())\n}\n\nfunc (a *API) handleHealthcheck(c echo.Context) error {\n\treturn c.JSON(http.StatusOK, map[string]string{\"status\": \"healthy\"})\n}\n\nfunc (a *API) handleMessages(c echo.Context) error {\n\ta.RWMutex.RLock()\n\tdefer a.RWMutex.RUnlock()\n\tmessages := a.Messages.Values()\n\treturn c.JSON(http.StatusOK, messages)\n}\n\nfunc (a *API) handleStream(c echo.Context) error {\n\treturn c.Stream(http.StatusOK, \"text/event-stream\", func(w http.ResponseWriter, next echo.HandlerFunc) {\n\t\ts := a.mrouter.NewSession(w, nil)\n\t\ts.OnMessage(func(m *melody.Message) {\n\t\t\ta.handleWebsocketMessage(config.Message(m.Payload), s)\n\t\t})\n\t\tnext(w)\n\t})\n}\n\nfunc (a *API) handlePostMessage(c echo.Context) error {\n\tvar msg config.Message\n\tif err := c.Bind(&msg); err != nil {\n\t\treturn err\n\t}\n\ta.RWMutex.Lock()\n\tdefer a.RWMutex.Unlock()\n\ta.Messages.Add(msg)\n\treturn c.JSON(http.StatusCreated, msg)\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Implement an auto-managed HTTP provider in Go using the Echo framework that can dynamically start/stop an HTTP server with health check capabilities.\n\nStruct Description: AutoManagedProvider is a struct that manages an Echo-based HTTP server with automatic startup/shutdown capabilities and provides health check endpoints.\n\nFields:\n- activeProvider: *echo.Echo - The Echo HTTP server instance\n- activeProviderRunning: bool - Flag indicating if the server is currently running\n- activeProviderTesting: bool - Flag indicating if the server is in testing mode\n- httpClient: *http.Client - HTTP client used for internal communications\n- autoManagePort: int - Port number for the managed HTTP server\n\nMethods:\n- NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider - Constructor that creates a new AutoManagedProvider with configuration\n- UpdateTTL() - Manages the server lifecycle (starts if not running, stops if shutdown)\n- isShutdown() bool - Checks if the server should be shutdown (returns bool)\n- getCurrentNode() interface{} - Returns current node information for health checks (returns interface{})",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider        *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient            *http.Client\n\tautoManagePort        int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyFromEnvironment,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   5 * time.Second,\n\t\t\tKeepAlive: 5 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          10,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxConnsPerHost:       10,\n\t}\n\n\thttpClient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   2 * time.Second,\n\t}\n\n\tp := &AutoManagedProvider{\n\t\thttpClient:            httpClient,\n\t\tautoManagePort:        autoManPort,\n\t\tactiveProviderRunning: false,\n\t}\n\n\treturn p\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n\tif p.isShutdown() && p.activeProviderRunning {\n\t\tp.activeProvider.Close()\n\t\treturn\n\t}\n\n\tif p.activeProviderRunning {\n\t\treturn\n\t}\n\n\tif !p.activeProviderTesting {\n\t\tp.activeProvider = echo.New()\n\t\tp.activeProvider.HideBanner = true\n\t\tp.activeProvider.GET(\"/_health\", func(context echo.Context) error {\n\t\t\treturn context.JSON(http.StatusOK, p.getCurrentNode())\n\t\t})\n\t}\n\tgo func() {\n\t\tp.activeProviderRunning = true\n\t\tappURI := fmt.Sprintf(\"0.0.0.0:%d\", p.autoManagePort)\n\t\tp.activeProvider.Start(appURI)\n\t\tp.activeProviderRunning = false\n\t}()\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n\treturn false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider     *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient         *http.Client\n\tautoManagePort     int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\tclient := &http.Client{\n\t\tTimeout: refreshTTL,\n\t}\n\n\treturn &AutoManagedProvider{\n\t\tactiveProvider:     e,\n\t\tactiveProviderRunning: false,\n\t\tactiveProviderTesting: false,\n\t\thttpClient:         client,\n\t\tautoManagePort:     autoManPort,\n\t}\n}\n\nfunc (a *AutoManagedProvider) UpdateTTL() {\n\tif a.activeProviderRunning && !a.activeProviderTesting {\n\t\ta.activeProvider.Stop()\n\t\ta.activeProviderRunning = false\n\t} else if !a.activeProviderRunning {\n\t\ta.activeProvider.Start(fmt.Sprintf(\":%d\", a.autoManagePort))\n\t\ta.activeProviderRunning = true\n\t}\n}\n\nfunc (a *AutoManagedProvider) isShutdown() bool {\n\treturn !a.activeProviderRunning\n}\n\nfunc (a *AutoManagedProvider) getCurrentNode() interface{} {\n\treturn map[string]string{\"node\": \"main-node\", \"status\": \"active\"}\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server using the Echo framework, which acts as a reverse proxy to route requests to different host servers based on the request's host header.\n\nFunction Description: The function initializes an Echo instance, configures middleware, sets up route handlers, and starts an HTTP server that proxies requests to different Echo instances based on the host header. It maintains a map of hostnames to their corresponding Echo instances for routing purposes.\n\nInput: None (The function takes no parameters but internally uses a map of hostnames to Echo instances)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)\n\n---\n\nTask Description: Create a Go struct that represents a virtual host configuration for an Echo-based HTTP server.\n\nStruct Description: The Host struct represents a virtual host configuration that holds an Echo instance for handling requests to a specific hostname.\n\nFields:\nEcho: *echo.Echo - Pointer to an Echo instance that handles requests for this host\n\nMethods:\nNone (The struct is simple and only holds a reference to an Echo instance)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\thosts := make(map[string]*Host)\n\n\tapi := echo.New()\n\tapi.Use(middleware.Logger())\n\tapi.Use(middleware.Recover())\n\n\thosts[\"api.localhost:1323\"] = &Host{api}\n\n\tapi.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"API\")\n\t})\n\n\te := echo.New()\n\te.Any(\"/*\", func(c echo.Context) (err error) {\n\t\treq := c.Request()\n\t\tres := c.Response()\n\t\thost := hosts[req.Host]\n\n\t\tif host == nil {\n\t\t\terr = echo.ErrNotFound\n\t\t} else {\n\t\t\thost.Echo.ServeHTTP(res, req)\n\t\t}\n\n\t\treturn\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"net/http\"\n)\n\ntype Host struct {\n\tEcho *echo.Echo\n}\n\nfunc setupReverseProxyServer() {\n\te := echo.New()\n\n\thosts := map[string]*echo.Echo{\n\t\t\"example.com\": echo.New(),\n\t\t\"test.com\":    echo.New(),\n\t}\n\n\te.Use(func(c echo.Context) error {\n\t\thost := c.Request().Host\n\t\tif echoInstance, ok := hosts[host]; ok {\n\t\t\treturn echoInstance.ServeHTTP(c.Response(), c.Request())\n\t\t}\n\t\treturn c.String(http.StatusNotFound, \"Host not found\")\n\t})\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello from reverse proxy!\")\n\t})\n\n\te.Start(\":8080\")\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement an HTTP server using the Echo framework in Go that handles workflow-related requests with authentication and specific route handlers.\n\nFunction Description: The function `startWorkflowServer` initializes and starts an HTTP server using the Echo framework. It sets up middleware for authentication, defines route handlers for specific endpoints (`/secrets` and `/trigger`), and starts the server on the specified host and port. The server validates incoming requests using a predefined workflow key and performs specific actions based on the route.\n\nInput:  \n- `host` (string): The host address on which the server will listen.  \n- `port` (uint64): The port number on which the server will listen.  \n\nOutput:  \n- None (The function starts an HTTP server and blocks indefinitely unless an error occurs).  \n\nNote: The function uses global variables (`workflowKey`, `builderKey`, `secretsHit`, `triggerHit`, etc.) and external configurations (`config.Current.File.ServerUrl`), which should be defined elsewhere in the code.  \n\n(Strictly followed the format requirements without inserting irrelevant characters.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/rs/zerolog/log\"\n\t\"github.com/ziflex/lecho/v2\"\n)\n\nfunc startWorkflowServer(host string, port uint64) {\n\te := echo.New()\n\te.HideBanner = true\n\tlogger := lecho.From(log.Logger)\n\te.Logger = logger\n\te.Use(lecho.Middleware(lecho.Config{Logger: logger})\n\n\tkeyAuth := middleware.KeyAuth(func(s string, c echo.Context) (bool, error) {\n\t\treturn s == workflowKey, nil\n\t})\n\n\teg := e.Group(\"\", keyAuth)\n\n\teg.POST(\"/secrets\", func(c echo.Context) error {\n\t\tsecretsHit = true\n\t\tparams, err := c.FormParams()\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tfor key, val := range params {\n\t\t\tswitch key {\n\t\t\tcase \"SECRET_KEY\":\n\t\t\t\tif val[0] != builderKey {\n\t\t\t\t\tlog.Fatal().Msg(\"bad key\")\n\t\t\t\t}\n\t\t\tcase \"SECRET_URL\":\n\t\t\t\tif val[0] != config.Current.File.ServerUrl {\n\t\t\t\t\tlog.Fatal().Msg(\"bad url\")\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tlog.Fatal().Msg(\"unknown secret\")\n\t\t\t}\n\t\t}\n\t\treturn c.NoContent(200)\n\t})\n\n\teg.POST(\"/trigger\", func(c echo.Context) error {\n\t\ttriggerHit = true\n\t\treturn c.NoContent(200)\n\t})\n\n\tlog.Fatal().Err(e.Start(fmt.Sprintf(\"%s:%d\", host, port))).Send()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nvar (\n\tworkFlowKey     = \"workflow_key\"\n\tbuilderKey      = \"builder_key\"\n\tsecretsHit      = 0\n\ttriggerHit      = 0\n\tconfig          = struct {\n\t\tCurrent struct {\n\t\t\tFile struct {\n\t\t\t\tServerUrl string\n\t\t\t}\n\t\t}\n\t}{\n\t\tCurrent: struct {\n\t\t\tFile struct {\n\t\t\t\tServerUrl string\n\t\t\t}\n\t\t}{\n\t\t\tFile: struct {\n\t\t\t\tServerUrl string\n\t\t\t}{\n\t\t\t\tServerUrl: \"http://example.com\",\n\t\t\t},\n\t\t},\n\t}\n)\n\nfunc startWorkflowServer(host string, port uint64) {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/secrets\", func(c echo.Context) error {\n\t\tif config.Current.File.ServerUrl == \"\" {\n\t\t\treturn c.JSON(500, map[string]string{\"error\": \"server url is not set\"})\n\t\t}\n\t\tsecretsHit++\n\t\treturn c.JSON(200, map[string]int{\"secrets_hit\": secretsHit})\n\t})\n\n\te.POST(\"/trigger\", func(c echo.Context) error {\n\t\tif config.Current.File.ServerUrl == \"\" {\n\t\t\treturn c.JSON(500, map[string]string{\"error\": \"server url is not set\"})\n\t\t}\n\t\ttriggerHit++\n\t\treturn c.JSON(200, map[string]int{\"trigger_hit\": triggerHit})\n\t})\n\n\te.Start(\":8080\")\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various API endpoints for a Vault management system, including authentication, token management, secret management, and more.\n\nFunction Description: The StartListener function initializes and starts an Echo HTTP server with configured routes and middleware. It sets up various API endpoints for Vault operations, applies middleware for logging, recovery, and request handling, and serves static assets if provided. The server can be started with or without TLS based on configuration.\n\nInput:\n- listener: config.ListenerConfig - Configuration for the server listener including address and TLS settings\n- assets: *rice.Box - Optional box containing static assets to be served by the server\n\nOutput: None (the function starts the server which runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\t\"log\"\n\n\t\"github.com/caiyeon/goldfish/config\"\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\te        *echo.Echo\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te = echo.New()\n\te.HideBanner = true\n\te.Server.ReadTimeout = 10 * time.Second\n\te.Server.WriteTimeout = 2 * time.Minute\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.BodyLimit(\"32M\"))\n\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\tLevel: 5,\n\t}))\n\n\te.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\tc.Response().Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\tif assets != nil {\n\t\tassetHandler := http.FileServer(assets.HTTPBox())\n\t\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\t\te.GET(\"/assets/css/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/js/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/fonts/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t\te.GET(\"/assets/img/*\", echo.WrapHandler(http.StripPrefix(\"/\", assetHandler)))\n\t}\n\n\te.GET(\"/v1/health\", handlers.Health())\n\te.GET(\"/v1/vaulthealth\", handlers.VaultHealth())\n\te.POST(\"/v1/bootstrap\", handlers.Bootstrap())\n\n\te.POST(\"/v1/login\", handlers.Login())\n\te.POST(\"/v1/login/renew-self\", handlers.RenewSelf())\n\n\te.GET(\"/v1/token/accessors\", handlers.GetTokenAccessors())\n\te.POST(\"/v1/token/lookup-accessor\", handlers.LookupTokenByAccessor())\n\te.POST(\"/v1/token/revoke-accessor\", handlers.RevokeTokenByAccessor())\n\te.POST(\"/v1/token/revoke-self\", handlers.RevokeSelf())\n\te.POST(\"/v1/token/create\", handlers.CreateToken())\n\te.GET(\"/v1/token/listroles\", handlers.ListRoles())\n\te.GET(\"/v1/token/role\", handlers.GetRole())\n\n\te.GET(\"/v1/userpass/users\", handlers.GetUserpassUsers())\n\te.POST(\"/v1/userpass/delete\", handlers.DeleteUserpassUser())\n\n\te.GET(\"/v1/approle/roles\", handlers.GetApproleRoles())\n\te.POST(\"/v1/approle/delete\", handlers.DeleteApproleRole())\n\n\te.GET(\"/v1/ldap/groups\", handlers.GetLDAPGroups())\n\te.GET(\"/v1/ldap/users\", handlers.GetLDAPUsers())\n\n\te.GET(\"/v1/policy\", handlers.GetPolicy())\n\te.DELETE(\"/v1/policy\", handlers.DeletePolicy())\n\te.GET(\"/v1/policy-capabilities\", handlers.PolicyCapabilities())\n\n\te.GET(\"/v1/request\", handlers.GetRequest())\n\te.POST(\"/v1/request/add\", handlers.AddRequest())\n\te.POST(\"/v1/request/approve\", handlers.ApproveRequest())\n\te.DELETE(\"/v1/request/reject\", handlers.RejectRequest())\n\n\te.GET(\"/v1/transit\", handlers.TransitInfo())\n\te.POST(\"/v1/transit/encrypt\", handlers.EncryptString())\n\te.POST(\"/v1/transit/decrypt\", handlers.DecryptString())\n\n\te.GET(\"/v1/mount\", handlers.GetMount())\n\te.POST(\"/v1/mount\", handlers.ConfigMount())\n\n\te.GET(\"/v1/secrets\", handlers.GetSecrets())\n\te.POST(\"/v1/secrets\", handlers.PostSecrets())\n\te.DELETE(\"/v1/secrets\", handlers.DeleteSecrets())\n\n\te.GET(\"/v1/bulletins\", handlers.GetBulletins())\n\n\te.POST(\"/v1/wrapping/wrap\", handlers.WrapHandler())\n\te.POST(\"/v1/wrapping/unwrap\", handlers.UnwrapHandler())\n\n\tif listener.Tls_disable {\n\t\te.Logger.Fatal(e.Start(listener.Address))\n\t\treturn\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/spf13/viper\"\n\t\"yourproject/config\"\n\t\"yourproject/handler\"\n\t\"yourproject/middleware/auth\"\n\t\"yourproject/middleware/logger\"\n\t\"yourproject/repository\"\n\t\"yourproject/service\"\n\t\"yourproject/util\"\n)\n\nfunc StartListener(listener config.ListenerConfig, assets *rice.Box) {\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(logger.RequestLogger())\n\te.Use(auth.AuthMiddleware())\n\n\t// Routes\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(200, \"Vault Management System API\")\n\t})\n\n\t// Authentication routes\n\te.POST(\"/auth/login\", handler.LoginHandler)\n\te.POST(\"/auth/register\", handler.RegisterHandler)\n\te.GET(\"/auth/refresh\", handler.RefreshTokenHandler)\n\n\t// Token management routes\n\te.POST(\"/tokens\", handler.CreateTokenHandler)\n\te.GET(\"/tokens/:tokenID\", handler.GetTokenHandler)\n\te.DELETE(\"/tokens/:tokenID\", handler.DeleteTokenHandler)\n\n\t// Secret management routes\n\te.POST(\"/secrets\", handler.CreateSecretHandler)\n\te.GET(\"/secrets/:secretID\", handler.GetSecretHandler)\n\te.PUT(\"/secrets/:secretID\", handler.UpdateSecretHandler)\n\te.DELETE(\"/secrets/:secretID\", handler.DeleteSecretHandler)\n\n\t// Static assets\n\tif assets != nil {\n\t\te.Static(\"/assets\", assets.Box())\n\t}\n\n\t// Initialize services and repositories\n\trepo := repository.NewRepository()\n\tservice := service.NewService(repo)\n\thandler.SetHandlers(service)\n\n\t// Start server\n\tif listener.TLS != nil {\n\t\te.StartTLS(listener.Address, listener.CertFile, listener.KeyFile)\n\t} else {\n\t\te.Start(listener.Address)\n\t}\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles user-related requests with CORS support and logging middleware.\n\nFunction Description: The main function initializes an Echo server instance, configures middleware (logger, recovery, and CORS), sets up route handlers, and starts the server on port 1323.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handler function `getUsers` would need to be implemented separately to handle the GET request to \"/api/users\".",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"https://labstack.com\", \"https://labstack.net\"},\n\t\tAllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"*\"},\n\t\tAllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\"},\n\t\tAllowHeaders: []string{\"Origin\", \"Content-Type\", \"Authorization\"},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that includes rate limiting middleware using Sentinel, with custom resource extraction and block fallback handlers.\n\nFunction Description: The function sets up a Fiber web server with Sentinel middleware for rate limiting. The middleware extracts the client's real IP from headers as the resource key and provides a custom JSON response when requests are blocked. The server listens on port 8080 and includes a test endpoint.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import \"github.com/gofiber/fiber/v2\"\n\nfunc Example() {\n\tapp := fiber.New()\n\tapp.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx *fiber.Ctx) string {\n\t\t\t\treturn ctx.GetReqHeaders()[\"X-Real-IP\"]\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx *fiber.Ctx) error {\n\t\t\t\treturn ctx.Status(400).JSON(struct {\n\t\t\t\t\tError string `json:\"error\"`\n\t\t\t\t\tCode  int    `json:\"code\"`\n\t\t\t\t}{\n\t\t\t\t\t\"too many request; the quota used up\",\n\t\t\t\t\t10222,\n\t\t\t\t})\n\t\t\t})),\n\t)\n\n\tapp.Get(\"/test\", func(ctx *fiber.Ctx) error { return nil })\n\t_ = app.Listen(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/sentinel\"\n\t\"github.com/gofiber/fiber/v2/middleware/limiter\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tapp := fiber.New()\n\n\t// Rate limiting middleware with Sentinel\n\tapp.Use(sentinel.NewMiddleware(\n\t\tsentinel.WithResourceKeyFunc(func(c *fiber.Ctx) string {\n\t\t\t// Extract real IP from headers\n\t\t\tip := c.Get(\"X-Forwarded-For\")\n\t\t\tif ip == \"\" {\n\t\t\t\tip = c.IP()\n\t\t\t}\n\t\t\treturn ip\n\t\t}),\n\t\tsentinel.WithLimit(10),\n\t\tsentinel.WithInterval(60),\n\t\tsentinel.WithBlockHandler(func(c *fiber.Ctx) error {\n\t\t\treturn c.JSON(fiber.Map{\n\t\t\t\t\"error\": \"Too many requests\",\n\t\t\t\t\"code\":  http.StatusTooManyRequests,\n\t\t\t})\n\t\t}),\n\t))\n\n\t// Test endpoint\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Hello, world!\")\n\t})\n\n\t// Start the server\n\tapp.Listen(\":8080\")\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that handles health checks and image conversion requests.\n\nFunction Description: The main function initializes and configures a Fiber HTTP server, sets up middleware for ETag generation, defines route handlers for health checks and image conversion, and starts the server on a specified host and port.\n\nInput:\n- Configuration parameters (host, port, read buffer size, concurrency, keepalive settings) are read from the config.Config object\n- No direct input parameters to the main function itself\n\nOutput:\n- Running HTTP server that listens on specified address\n- Console output indicating server status\n- Potential fatal error if server fails to start\n\nThe function performs these key operations:\n1. Initializes Fiber app with custom configuration\n2. Adds ETag middleware\n3. Registers route handlers:\n   - /healthz endpoint for health checks\n   - /* catch-all endpoint for image conversion\n4. Starts the server and handles startup errors",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"webp_server_go/config\"\n\t\"webp_server_go/handler\"\n)\n\nvar app = fiber.New(fiber.Config{\n\tServerHeader:          \"WebP Server Go\",\n\tAppName:               \"WebP Server Go\",\n\tDisableStartupMessage: true,\n\tProxyHeader:           \"X-Real-IP\",\n\tReadBufferSize:        config.Config.ReadBufferSize,\n\tConcurrency:           config.Config.Concurrency,\n\tDisableKeepalive:      config.Config.DisableKeepalive,\n})\n\nfunc main() {\n\tapp.Use(etag.New(etag.Config{\n\t\tWeak: true,\n\t}))\n\n\tlistenAddress := config.Config.Host + \":\" + config.Config.Port\n\n\tapp.Get(\"/healthz\", handler.Healthz)\n\tapp.Get(\"/*\", handler.Convert)\n\n\tfmt.Println(\"WebP Server Go is Running on http://\" + listenAddress)\n\n\tbindErr := app.Listen(listenAddress)\n\tif bindErr != nil {\n\t\tlog.Fatal(\"Error starting server: \", bindErr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/etag\"\n\t\"github.com/gofiber/fiber/v2/middleware/recover\"\n\t\"github.com/gofiber/fiber/v2/config\"\n)\n\nfunc main() {\n\tapp := fiber.New(config.New(\n\t\tconfig.WithHost(\"0.0.0.0\"),\n\t\tconfig.WithPort(8080),\n\t\tconfig.WithReadBufferSize(1024),\n\t\tconfig.WithConcurrency(10),\n\t\tconfig.WithKeepAlive(true),\n\t))\n\n\tapp.Use(recover.New())\n\tapp.Use(etag.New())\n\n\tapp.Get(\"/healthz\", func(c *fiber.Ctx) error {\n\t\treturn c.Status(200).JSON(fiber.Map{\"status\": \"healthy\"})\n\t})\n\n\tapp.Any(\"/*\", func(c *fiber.Ctx) error {\n\t\treturn c.SendStatus(200)\n\t})\n\n\tif err := app.Listen(\":8080\"); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go for a dashboard application that manages queues and tenants, with optional basic authentication and template rendering capabilities.\n\nStruct Description: The Dashboard struct represents a web dashboard that provides queue management functionality through HTTP endpoints. It uses the Fiber framework for routing and middleware, supports HTML template rendering, and can be configured with basic authentication.\n\nFields:\n\nApp: *fiber.App - The Fiber application instance for handling HTTP requests\nqueue: models.Queue - Interface for queue operations\ntenantManager: models.TenantManager - Interface for tenant management operations\ncfg: config.DashboardConfig - Configuration settings for the dashboard\n\nMethods:\n\nNewDashboard: (queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) -> *Dashboard - Initializes a new Dashboard instance with the given dependencies and configuration, sets up template engine, basic auth middleware, and route handlers\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nQueues: (c *fiber.Ctx) -> error - Handler for GET / route\nNewQueue: (c *fiber.Ctx) -> error - Handler for POST /queues route\nQueue: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue route\nQueueSettings: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/settings route\nSaveQueueSettings: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/settings route\nDeleteQueueConfirm: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/delete route\nDeleteQueue: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/delete route\nMessage: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/messages/:message route",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n\t\"github.com/gofiber/template/html/v2\"\n)\n\ntype Dashboard struct {\n\tApp *fiber.App\n\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tvar engine *html.Engine\n\n\tif cfg.Dev {\n\t\tengine = html.New(\"./dashboard/views\", \".html\")\n\t\tengine.Reload(true)\n\t\tengine.Debug(true)\n\t} else {\n\t\thttp.FS(viewsfs)\n\t\tfs2, err := fs.Sub(viewsfs, \"views\")\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tengine = html.NewFileSystem(http.FS(fs2), \".html\")\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tViews:                 engine,\n\t\tDisableStartupMessage: true,\n\t})\n\n\tif cfg.User != \"\" && cfg.Pass != \"\" {\n\t\tapp.Use(basicauth.New(basicauth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.User: cfg.Pass,\n\t\t\t},\n\t\t}))\n\t}\n\n\td := &Dashboard{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Get(\"/\", d.Queues)\n\tapp.Post(\"/queues\", d.NewQueue)\n\tapp.Get(\"/queues/:queue\", d.Queue)\n\tapp.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"Dashboard: http://localhost:%d\\n\", d.cfg.Port)\n\treturn d.App.Listen(fmt.Sprintf(\":%d\", d.cfg.Port))\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Shutdown()\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "right_result": "package dashboard\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n)\n\ntype Dashboard struct {\n\tApp          *fiber.App\n\tqueue        models.Queue\n\ttenantManager models.TenantManager\n\tcfg          config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\td := &Dashboard{\n\t\tqueue:        queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:          cfg,\n\t}\n\n\td.App = fiber.New()\n\n\t// Setup template engine\n\ttmpl := template.Must(template.ParseFiles(\"templates/index.html\", \"templates/queue.html\", \"templates/settings.html\", \"templates/delete.html\", \"templates/message.html\"))\n\td.App.Use(func(c *fiber.Ctx) error {\n\t\tc.Locals(\"template\", tmpl)\n\t\treturn c.Next()\n\t})\n\n\t// Setup basic auth middleware\n\tif cfg.BasicAuth.Enabled {\n\t\tbasicAuth := basicauth.New(basicauth.Config{\n\t\t\tUsers:     cfg.BasicAuth.Users,\n\t\t\tRealm:     cfg.BasicAuth.Realm,\n\t\t\tNext:      nil,\n\t\t\tLoginPath: \"/login\",\n\t\t})\n\t\td.App.Use(basicAuth.Middleware())\n\t}\n\n\t// Setup routes\n\td.App.Get(\"/\", d.Queues)\n\td.App.Post(\"/queues\", d.NewQueue)\n\td.App.Get(\"/queues/:queue\", d.Queue)\n\td.App.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\td.App.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\td.App.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\td.App.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\td.App.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Server.Enabled {\n\t\treturn nil\n\t}\n\treturn d.App.Listen(d.cfg.Server.Addr)\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif !d.cfg.Server.Enabled {\n\t\treturn nil\n\t}\n\treturn d.App.Shutdown()\n}\n\nfunc (d *Dashboard) Queues(c *fiber.Ctx) error {\n\tqueues, err := d.queue.GetAll()\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Render(\"index\", fiber.Map{\n\t\t\"queues\": queues,\n\t})\n}\n\nfunc (d *Dashboard) NewQueue(c *fiber.Ctx) error {\n\tvar queue models.Queue\n\tif err := c.BodyParser(&queue); err != nil {\n\t\treturn c.Status(http.StatusBadRequest).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\tif err := d.queue.Create(queue); err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Redirect(\"/queues\")\n}\n\nfunc (d *Dashboard) Queue(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tqueue, err := d.queue.GetByID(queueID)\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Render(\"queue\", fiber.Map{\n\t\t\"queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) QueueSettings(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tqueue, err := d.queue.GetByID(queueID)\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Render(\"settings\", fiber.Map{\n\t\t\"queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) SaveQueueSettings(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tvar settings models.QueueSettings\n\tif err := c.BodyParser(&settings); err != nil {\n\t\treturn c.Status(http.StatusBadRequest).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\tif err := d.queue.UpdateSettings(queueID, settings); err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Redirect(\"/queues/\" + queueID + \"/settings\")\n}\n\nfunc (d *Dashboard) DeleteQueueConfirm(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tqueue, err := d.queue.GetByID(queueID)\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Render(\"delete\", fiber.Map{\n\t\t\"queue\": queue,\n\t})\n}\n\nfunc (d *Dashboard) DeleteQueue(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tif err := d.queue.Delete(queueID); err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Redirect(\"/\")\n}\n\nfunc (d *Dashboard) Message(c *fiber.Ctx) error {\n\tqueueID := c.Params(\"queue\")\n\tmessageID := c.Params(\"message\")\n\tqueue, err := d.queue.GetByID(queueID)\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\tmessage, err := d.queue GetMessage(queueID, messageID)\n\tif err != nil {\n\t\treturn c.Status(http.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t}\n\treturn c.Render(\"message\", fiber.Map{\n\t\t\"queue\":   queue,\n\t\t\"message\": message,\n\t})\n}"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that initializes and runs a Fiber-based HTTP server with specific routes for job management, while also starting a background engine process.\n\nFunction Description: The function `Run` initializes a Fiber web server with disabled startup messages, sets up three routes for job management (creating new jobs, checking job status, and retrieving jobs), starts a background engine process in a goroutine, and finally starts listening on a specified host and port.\n\nInput: None (uses package-level constants Host and Port for server configuration)\n\nOutput: None (runs indefinitely as a web server, but technically returns an error if the server fails to start)\n\nNote: The function uses package-level constants Host and Port for server configuration and assumes the existence of handler functions NewJob, GetStatus, and GetJob, as well as an Engine function for background processing.",
    "Canonical_solution": "import (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc Run() {\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t})\n\n\tapp.Post(\"/jobs/\", NewJob)\n\tapp.Get(\"/jobs/status/:id\", GetStatus)\n\tapp.Get(\"/jobs/:id\", GetJob)\n\n\tgo Engine()\n\n\tapp.Listen(Host + \":\" + Port)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "right_result": "package main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nconst Host = \"localhost\"\nconst Port = 8080\n\nfunc Run() error {\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t})\n\n\tapp.Post(\"/jobs\", NewJob)\n\tapp.Get(\"/jobs/:id/status\", GetStatus)\n\tapp.Get(\"/jobs/:id\", GetJob)\n\n\tgo Engine()\n\n\tapp.Listen Host + \":\" + Port\n\treturn nil\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with configurable settings including middleware, routes, and TLS support.\n\nFunction Description: The function serves as the entry point for starting a Gin-based HTTP server. It initializes the Gin engine with default middleware (Logger and Recovery) and additional custom middleware (CORS, Correlation, Auth, etc.). It registers various route handlers for different endpoints including health checks, metrics, and a home route. The server can be started with or without TLS based on configuration.\n\nInput: \n- None (configuration is read from viper and cobra command context)\n\nOutput: \n- None (runs HTTP server as a blocking operation, panics on error)\n\nMethods:\n- The function itself serves as the main execution method for the cobra.Command's Run field\n\nNote: The function uses global configuration via viper and is designed to work as part of a cobra CLI command structure. It handles server startup errors by panicking, which is appropriate for a main application entry point.\n\n(Strictly following the format with no extra characters)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n)\n\nvar towerCmd = &cobra.Command{\n\tUse:   \"api\",\n\tShort: \"Start beaver api server\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tr := gin.Default()\n\n\t\tr.Use(middleware.Cors())\n\t\tr.Use(middleware.Correlation())\n\t\tr.Use(middleware.Logger())\n\t\tr.Use(middleware.Metric())\n\t\tr.Use(middleware.Auth())\n\n\t\tr.GET(\"/favicon.ico\", func(c *gin.Context) {\n\t\t\tc.String(http.StatusNoContent, \"\")\n\t\t})\n\n\t\tr.GET(\"/\", controller.Home)\n\n\t\tr.GET(\"/_health\", controller.Health)\n\n\t\tr.GET(\n\t\t\tviper.GetString(\"app.metrics.prometheus.endpoint\"),\n\t\t\tgin.WrapH(controller.Metrics()),\n\t\t)\n\n\t\tvar runerr error\n\n\t\tif viper.GetBool(\"app.tls.status\") {\n\t\t\trunerr = r.RunTLS(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t\tviper.GetString(\"app.tls.pemPath\"),\n\t\t\t\tviper.GetString(\"app.tls.keyPath\"),\n\t\t\t)\n\t\t} else {\n\t\t\trunerr = r.Run(\n\t\t\t\tfmt.Sprintf(\":%s\", strconv.Itoa(viper.GetInt(\"app.port\"))),\n\t\t\t)\n\t\t}\n\n\t\tif runerr != nil {\n\t\t\tpanic(runerr.Error())\n\t\t}\n\t},\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc initAndRunServer() {\n\tr := gin.Default()\n\n\t// Add default middleware\n\tr.Use(gin.Logger())\n\tr.Use(gin.Recovery())\n\n\t// Add custom middleware\n\tr.Use(CORS())\n\tr.Use(Correlation())\n\tr.Use(Auth())\n\n\t// Define routes\n\tr.GET(\"/health\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"status\": \"healthy\"})\n\t})\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Welcome to the API\"})\n\t})\n\n\t// Start server\n\tif viper.GetBool(\"tls.enabled\") {\n\t\terr := r.RunTLS(\":443\", viper.GetString(\"tls.cert\"), viper.GetString(\"tls.key\"))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\terr := r.Run(\":8080\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with static file serving capabilities and a simple ping endpoint.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), serves static files from a binary filesystem at the \"/static\" route, and sets up a GET endpoint at \"/ping\" that returns a simple text response. The server listens on port 8080.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\tassetfs \"github.com/elazarl/go-bindata-assetfs\"\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.Use(static.Serve(\"/static\", BinaryFileSystem(\"data\")))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc initAndRunServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the binary filesystem at \"/static\" route\n\tr.Static(\"/static\", \"./static\")\n\n\t// Define a GET endpoint at \"/ping\"\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that implements a session-based counter. The server should increment and persist a counter value across requests using Redis as the session store.\n\nFunction Description: The main function initializes a Gin web server with Redis-based session management and implements a GET endpoint (\"/incr\") that increments and returns a counter value stored in the session.\n\nInput: None (The function takes no direct input parameters. Input comes through HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly. Output is sent as HTTP responses. The \"/incr\" endpoint returns JSON with the current count value)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nvar pool *redis.Pool\n\nfunc init() {\n\tpool = &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\treturn redis.Dial(\"tcp\", \"localhost:6379\")\n\t\t},\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Initialize Redis session store\n\tsessionStore, _ := redis.NewSessionStore(pool, \"default\")\n\tr.Use(sessionStore.Middleware())\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\t// Get session\n\t\tsession, _ := sessionStore.Get(c, \"counterSession\")\n\n\t\t// Increment counter\n\t\tcount, _ := session.Get(\"count\").(int)\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\n\t\t// Save session\n\t\tsession.Save(c, c.Writer)\n\n\t\t// Return JSON response\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with caching capabilities for specific routes using in-memory storage.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), configures an in-memory cache store, and sets up a GET route (\"/cache_ping\") that returns a cached response. The cached response includes a \"pong\" message with the current Unix timestamp, and the cache is set to expire after one minute.\n\nInput: None (The function takes no parameters as it sets up the server configuration internally)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8080)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/cache\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tstore := cache.NewInMemoryStore(time.Second)\n\tr.GET(\"/cache_ping\", cache.CachePage(store, time.Minute, func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t}))\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n\t\"net/http\"\n)\n\nfunc initServer() {\n\tr := gin.Default()\n\n\t// In-memory cache store\n\tcache := make(map[string]string)\n\n\t// Route handler for /cache_ping\n\tr.GET(\"/cache_ping\", func(c *gin.Context) {\n\t\tkey := \"ping\"\n\t\tif cached, ok := cache[key]; ok {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"pong\": cached})\n\t\t\treturn\n\t\t}\n\n\t\t// Generate current Unix timestamp\n\t\ttimestamp := time.Now().Unix()\n\t\tresponse := gin.H{\"pong\": timestamp}\n\n\t\t// Set cache with expiration after 1 minute\n\t\tcache[key] = response[\"pong\"]\n\t\ttime.AfterFunc(60*time.Second, func() {\n\t\t\tdelete(cache, key)\n\t\t})\n\n\t\tc.JSON(http.StatusOK, response)\n\t})\n\n\t// Start server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint to handle and respond to header data.\n\nFunction Description: The function initializes a Gin router with default middleware, registers a GET handler for the root path (\"/\"), processes incoming request headers, and returns a JSON response containing specific header values. The server listens on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but processes HTTP request headers internally)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\th := testHeader{}\n\n\t\tif err := c.ShouldBindHeader(&h); err != nil {\n\t\t\tc.JSON(http.StatusOK, err)\n\t\t}\n\n\t\tfmt.Printf(\"%#v\\n\", h)\n\t\tc.JSON(http.StatusOK, gin.H{\"Rate\": h.Rate, \"Domain\": h.Domain})\n\t})\n\n\tr.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\theaderKey1 := c.GetHeader(\"X-Header-Key1\")\n\t\theaderKey2 := c.GetHeader(\"X-Header-Key2\")\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"header_key1\": headerKey1,\n\t\t\t\"header_key2\": headerKey2,\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a reverse proxy server using Gin framework in Go that forwards incoming HTTP requests to a load-balanced backend server and returns the response to the client.\n\nFunction Description: The main function initializes a Gin HTTP server that acts as a reverse proxy. It handles incoming GET requests, forwards them to a backend server obtained from a load balancer, and returns the backend's response to the client while preserving all headers.\n\nInput:\n- Path parameter: \":path\" (string) - The path component of the URL to be forwarded to the backend server\n- HTTP request headers and body (automatically handled by Gin context)\n\nOutput:\n- HTTP response with:\n  - Status code from backend server (or 500 if proxy fails)\n  - Headers from backend server\n  - Body content from backend server\n- Error logs if any step in the proxying process fails\n\nThe function uses the Gin context (c *gin.Context) to:\n1. Extract the original request\n2. Parse the load-balanced backend address\n3. Modify the request URL to point to the backend\n4. Use HTTP transport to forward the request\n5. Copy backend response headers to client response\n6. Stream the backend response body to the client",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\tproxy, err := url.Parse(getLoadBalanceAddr())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in parse addr: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\t\treq.URL.Scheme = proxy.Scheme\n\t\treq.URL.Host = proxy.Host\n\n\t\ttransport := http.DefaultTransport\n\t\tresp, err := transport.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error in roundtrip: %v\", err)\n\t\t\tc.String(500, \"error\")\n\t\t\treturn\n\t\t}\n\n\t\tfor k, vv := range resp.Header {\n\t\t\tfor _, v := range vv {\n\t\t\t\tc.Header(k, v)\n\t\t\t}\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbufio.NewReader(resp.Body).WriteTo(c.Writer)\n\t\treturn\n\t})\n\n\tif err := r.Run(ReverseServerAddr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\tpath := c.Param(\"path\")\n\t\tbackendURL := getBackendURL(path)\n\t\tif backendURL == \"\" {\n\t\t\tc.AbortWithStatusJSON(500, gin.H{\"error\": \"failed to determine backend URL\"})\n\t\t\treturn\n\t\t}\n\n\t\treq, err := http.NewRequest(\"GET\", backendURL, nil)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(500, gin.H{\"error\": \"failed to create request\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Copy headers from the original request to the new one\n\t\tfor k, v := range c.Request.Header {\n\t\t\treq.Header.Set(k, v...)\n\t\t}\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(500, gin.H{\"error\": \"failed to forward request\"})\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Set response status code\n\t\tc.Status(resp.StatusCode)\n\n\t\t// Copy headers from backend response to client response\n\t\tfor k, v := range resp.Header {\n\t\t\tc.Header(k, v...)\n\t\t}\n\n\t\t// Stream the body content from the backend to the client\n\t\t_, err = io.Copy(c.Writer, resp.Body)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(500, gin.H{\"error\": \"failed to stream response body\"})\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}\n\nfunc getBackendURL(path string) string {\n\t// This is a placeholder for a real load balancer logic\n\t// In a real scenario, this function would determine which backend server to use based on the path\n\t// For demonstration purposes, we'll just return a fixed URL\n\treturn \"http://backend.example.com\" + path\n}"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, save the uploaded file to the server, and return a success message with the file details and form fields.\n\nFunction Description: The function initializes a Gin router, configures it to handle multipart form uploads (with a maximum size limit), serves static files from a public directory, and sets up a POST endpoint for file uploads. The endpoint binds the incoming request to a struct containing the file and form fields, saves the file to the server, and returns a success message with the file name and form field values.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it sends HTTP responses through the Gin context)\n\nNote: The function assumes the existence of a `BindFile` struct type which should contain at least these fields:\n- File: *multipart.FileHeader - The uploaded file\n- Name: string - A form field value\n- Email: string - A form field value",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\n\t\tif err := c.ShouldBind(&bindFile); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfile := bindFile.File\n\t\tdst := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"upload file err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, bindFile.Name, bindFile.Email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype BindFile struct {\n\tFile *multipart.FileHeader\n\tName string\n\tEmail string\n}\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Set maximum memory for multipart forms\n\tr.LoadHTMLGlob(\"templates/*\")\n\tr.Static(\"/static\", \"static\")\n\n\t// Configure max memory for multipart forms\n\tr.MaxMultipartMemory = 1 << 20 // 1 MB\n\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar b BindFile\n\t\tif err := c.ShouldBind(&b); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\t// Save the uploaded file\n\t\tdst, err := os.Create(filepath.Join(\"uploads\", b.File.Filename))\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif err := c.SaveUploadedFile(b.File, dst.Name()); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save file\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Return success message with file details and form fields\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"filename\": b.File.Filename,\n\t\t\t\"name\": b.Name,\n\t\t\t\"email\": b.Email,\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, and serves static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling multipart form uploads. It processes uploaded files along with name and email form fields, saves the files to the server, and returns a success message.\n\nInput: None (The function takes no direct input parameters but handles HTTP requests with the following expected inputs:\n- POST /upload requests containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - Multipart files: \"files\" (array of files)\n- GET requests for static files from the \"./public\" directory)\n\nOutput: None (The function doesn't return any value but produces the following outputs:\n- For successful uploads: HTTP 200 response with success message\n- For errors: HTTP 400 responses with error messages\n- Static file serving for requests to the root path)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"./public\" directory\n\tr.Static(\"/\", \"./public\")\n\n\t// Handle file upload POST endpoint\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\t// Parse the multipart form\n\t\tif err := c.Request.ParseMultipartForm(10 << 20); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to parse form\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Get form fields\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\t// Get uploaded files\n\t\tfiles, err := c.MultipartForm.File[\"files\"]\n\t\tif err != nil || len(files) == 0 {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No files uploaded\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Save uploaded files\n\t\tfor _, fileHeader := range files {\n\t\t\tfile, err := fileHeader.Open()\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to open file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\t// Define the destination path\n\t\t\tdst, err := filepath.Abs(filepath.Join(\"uploads\", fileHeader.Filename))\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to determine destination path\"})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Create directory if it doesn't exist\n\t\t\tos.MkdirAll(filepath.Dir(dst), os.ModePerm)\n\n\t\t\t// Save the file\n\t\t\tdstFile, err := os.Create(dst)\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create destination file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dstFile.Close()\n\n\t\t\t// Copy the file content\n\t\t\tif _, err = dstFile.WriteFrom(file); err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to write file\"})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Return success response\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"Upload successful\",\n\t\t\t\"name\":    name,\n\t\t\t\"email\":   email,\n\t\t})\n\t})\n\n\t// Start the server\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that serves static files from a local directory and handles a basic GET request.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up static file serving from a specified directory, registers a GET route handler, and starts the server on a specified port.\n\nInput: None (The function takes no direct input parameters, but the server configuration is hardcoded in the function)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The static file directory (\"/tmp\") and server port (\":8080\") are hardcoded in this implementation but could be made configurable through parameters in a more flexible version.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(static.Serve(\"/\", static.LocalFile(\"/tmp\", false)))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Serve static files from the /tmp directory\n\tr.Static(\"/static\", \"/tmp\")\n\n\t// Handle a basic GET request\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"Hello from Gin!\",\n\t\t})\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle GET requests, extract request information, and return a JSON response containing the request path and IP details.\n\nFunction Description: The function initializes a Gin router with default middleware, registers a GET route handler that captures the request path and IP information (including RemoteAddr, X-Forwarded-For, and X-Real-Ip headers), and returns this information as a JSON response. The server runs on a specified address.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return any value directly, but sends JSON responses to HTTP clients and may log errors during server startup)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nconst (\n\tAddr = \"127.0.0.1:2003\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/:path\", func(c *gin.Context) {\n\t\treq := c.Request\n\t\turlPath := fmt.Sprintf(\"http://%s%s\", Addr, req.URL.Path)\n\t\trealIP := fmt.Sprintf(\"RemoteAddr=%s,X-Forwarded-For=%v,X-Real-Ip=%v\", req.RemoteAddr, req.Header.Get(\"X-Forwarded-For\"), req.Header.Get(\"X-Real-Ip\"))\n\t\tc.JSON(200, gin.H{\n\t\t\t\"path\": urlPath,\n\t\t\t\"ip\":   realIP,\n\t\t})\n\t})\n\n\tif err := r.Run(Addr); err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\t// Extract request path\n\t\tpath := c.Request.URL.Path\n\n\t\t// Extract IP information\n\t\tipAddresses := []string{}\n\n\t\t// Check RemoteAddr\n\t\tremoteAddr := c.Request.RemoteAddr\n\t\tipAddresses = append(ipAddresses, remoteAddr)\n\n\t\t// Check X-Forwarded-For\n\t\txForwardedFor := c.GetHeader(\"X-Forwarded-For\")\n\t\tif xForwardedFor != \"\" {\n\t\t\tipAddresses = append(ipAddresses, xForwardedFor)\n\t\t}\n\n\t\t// Check X-Real-Ip\n\t\txRealIp := c.GetHeader(\"X-Real-Ip\")\n\t\tif xRealIp != \"\" {\n\t\t\tipAddresses = append(ipAddresses, xRealIp)\n\t\t}\n\n\t\t// Validate and format IP addresses\n\t\tvar validIPs []string\n\t\tipRegex := regexp.MustCompile(`^(\\d{1,3}\\.){3}\\d{1,3}$`)\n\t\tfor _, ip := range ipAddress {\n\t\t\tif ipRegex.MatchString(ip) {\n\t\t\t\tvalidIPs = append(validIPs, ip)\n\t\t\t}\n\t\t}\n\n\t\t// Build response\n\t\tresponse := map[string]interface{}{\n\t\t\t\"path\":       path,\n\t\t\t\"ip_addresses\": validIPs,\n\t\t}\n\n\t\tc.JSON(http.StatusOK, response)\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic string response.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler for the \"/ping\" endpoint, and starts the server on the default port (8080). When a GET request is made to \"/ping\", it responds with the string \"pong\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything; it starts an HTTP server that runs until interrupted)",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a Go function that implements an HTTP server using the Gin framework, which includes session management using Redis for storing and incrementing a counter value.\n\nFunction Description: The function sets up a Gin web server with Redis-based session management. It provides a single endpoint \"/incr\" that increments a counter stored in the session and returns the current count in JSON format. The server runs on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value directly, but sends JSON responses to HTTP requests and runs the web server indefinitely)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore, _ := sessions.NewRedisStore(10, \"tcp\", \"localhost:6379\", \"\", []byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gomodule/redigo/redis\"\n\t\"net/http\"\n)\n\nvar redisPool *redis.Pool\n\nfunc init() {\n\tredisPool = &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\treturn redis.Dial(\"tcp\", \"localhost:6379\")\n\t\t},\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Enable session management with Redis\n\tr.Use(gin.SessionHandler())\n\n\tr.POST(\"/incr\", func(c *gin.Context) {\n\t\tsession, _ := c.Session(\"mySessionKey\")\n\t\tcount, err := session.Get(\"counter\").(int)\n\t\tif err != nil {\n\t\t\tcount = 0\n\t\t}\n\t\tcount++\n\t\tsession.Set(\"counter\", count)\n\t\tsession.Save(c.Request, c.Response)\n\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses to clients and runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Add gzip compression middleware\n\tr.Use(gin.Gzip())\n\n\t// Define the \"/ping\" route\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.Writer.WriteHeader(200)\n\t\tc.WriteString(\"pong \" + time.Now().UnixString())\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a Go function that sets up a Gin-based HTTP server with specific API endpoints for handling web information requests. The function should initialize the server, define route handlers, and process incoming requests to return appropriate JSON responses.\n\nFunction Description: The `api` function initializes a Gin HTTP server with default middleware (Logger and Recovery). It defines two main routes: a root endpoint (\"/\") that returns a simple status message, and an API group (\"/api\") with endpoints for handling web information requests (\"/info\" for both GET and POST methods). The function processes incoming requests, validates input, executes business logic through `RunJob`, and returns structured JSON responses.\n\nInput:\n- `options` (*common.ENOptions): A pointer to an options structure containing configuration parameters for the application. This parameter is used to pass various settings to the business logic processing.\n\nOutput:\n- None (direct output via HTTP responses)\n- The function starts an HTTP server that listens on port 31000 and handles incoming requests\n- Returns error if server fails to start (logged via gologger)\n\nThe function does not explicitly return any values but sends HTTP responses in JSON format with the following possible structures:\n1. Success response (200 status code):\n```json\n{\n  \"code\": 200,\n  \"message\": \"ok\",\n  \"data\": [result_data]\n}\n```\n2. Error responses (400/500 status codes):\n```json\n{\n  \"code\": [error_code],\n  \"message\": \"[error_message]\"\n}\n```",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/wgpsec/ENScan/common\"\n\t\"github.com/wgpsec/ENScan/common/gologger\"\n)\nfunc api(options *common.ENOptions) {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"code\":    200,\n\t\t\t\"message\": \"OK\",\n\t\t})\n\t})\n\twebInfo := func(c *gin.Context) {\n\t\tvar w webOp\n\t\terr := c.ShouldBind(&w)\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\n\t\t\t\t\"code\":    500,\n\t\t\t\t\"message\": \"\u6570\u636e\u7ed1\u5b9a\u5f02\u5e38\uff01\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif w.OrgName == \"\" {\n\t\t\tc.JSON(400, gin.H{\n\t\t\t\t\"code\":    400,\n\t\t\t\t\"message\": \"\u8bf7\u8f93\u5165\u67e5\u8be2\u6761\u4ef6\uff01\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif w.Branch {\n\t\t\toptions.IsGetBranch = true\n\t\t}\n\t\toptions.KeyWord = w.OrgName\n\t\toptions.GetFlags = w.Filed\n\t\toptions.ScanType = w.ScanType\n\t\toptions.InvestNum = w.Invest\n\t\toptions.IsSupplier = w.Supplier\n\t\toptions.IsHold = w.Holds\n\t\toptions.Deep = w.Depth\n\t\toptions.IsMergeOut = true\n\t\tcommon.Parse(options)\n\t\tdata := RunJob(options)\n\t\tc.JSON(200, gin.H{\n\t\t\t\"code\":    200,\n\t\t\t\"message\": \"ok\",\n\t\t\t\"data\":    data,\n\t\t})\n\t}\n\ta := r.Group(\"/api\")\n\t{\n\t\ta.GET(\"/info\", webInfo)\n\t\ta.POST(\"/info\", webInfo)\n\t}\n\terr := r.Run(\":31000\")\n\tif err != nil {\n\t\tgologger.Error().Msgf(\"API\u670d\u52a1\u542f\u52a8\u5931\u8d25\uff01\")\n\t\tgologger.Fatal().Msgf(err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"your_project/common\"\n\t\"your_project/utils/gologger\"\n)\n\nfunc api(options *common.ENOptions) {\n\trouter := gin.Default()\n\trouter.Use(gin.Logger(), gin.Recovery())\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"code\": 200,\n\t\t\t\"message\": \"ok\",\n\t\t\t\"data\": []string{\"Welcome to the API\"},\n\t\t})\n\t})\n\n\tapiGroup := router.Group(\"/api\")\n\t{\n\t\tapiGroup.GET(\"/info\", func(c *gin.Context) {\n\t\t\tc.JSON(200, gin.H{\n\t\t\t\t\"code\": 200,\n\t\t\t\t\"message\": \"ok\",\n\t\t\t\t\"data\": map[string]interface{}{\n\t\t\t\t\t\"environment\": options.Environment,\n\t\t\t\t\t\"version\":     options.Version,\n\t\t\t\t},\n\t\t\t})\n\t\t})\n\n\t\tapiGroup.POST(\"/info\", func(c *gin.Context) {\n\t\t\tvar input struct {\n\t\t\t\tKey string `json:\"key\"`\n\t\t\t}\n\t\t\tif err := c.BindJSON(&input); err != nil {\n\t\t\t\tgologger.Error(\"Failed to bind JSON: %v\", err)\n\t\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\t\"code\": 400,\n\t\t\t\t\t\"message\": \"Invalid request body\",\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := RunJob(input.Key, options)\n\t\t\tc.JSON(200, gin.H{\n\t\t\t\t\"code\": 200,\n\t\t\t\t\"message\": \"ok\",\n\t\t\t\t\"data\": result,\n\t\t\t})\n\t\t})\n\t}\n\n\tif err := router.Run(\":31000\"); err != nil {\n\t\tgologger.Error(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a Go function that sets up a basic HTTP server using the Gin framework, with routes for login and home pages, including cookie handling for authentication.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), defines two routes (/login and /home), and starts the server on port 8080. The /login route sets a cookie, while the /home route requires cookie authentication through middleware and returns JSON data.\n\nInput: None (The function takes no input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens indefinitely)\n\nNote: The CookieTool() middleware referenced in the home route would need to be defined separately to verify the cookie set by the login route.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\troute := gin.Default()\n\n\troute.GET(\"/login\", func(c *gin.Context) {\n\t\tc.SetCookie(\"label\", \"ok\", 30, \"/\", \"localhost\", false, true)\n\t\tc.String(200, \"Login success!\")\n\t})\n\n\troute.GET(\"/home\", CookieTool(), func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"data\": \"Your home page\"})\n\t})\n\n\troute.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nvar cookieName = \"authCookie\"\n\nfunc CookieTool(c *gin.Context) {\n\tcookie, err := c.Cookie(cookieName)\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Missing authentication cookie\"})\n\t\treturn\n\t}\n\tc.Set(\"authenticated\", true)\n\tc.Next()\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.POST(\"/login\", func(c *gin.Context) {\n\t\t// Set a cookie for authentication\n\t\tc.SetCookie(cookieName, \"authenticatedValue\", 3600, \"/\", \"localhost\", false, true)\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Login successful\"})\n\t})\n\n\tr.Use(CookieTool)\n\tr.GET(\"/home\", func(c *gin.Context) {\n\t\t// Access protected route\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome to the home page!\"})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server with a single GET endpoint. The endpoint should accept a name parameter, make a gRPC call to a Greeter service, and return the response as JSON. The function should handle both successful responses and errors from the gRPC call.\n\nFunction Description: The function initializes a Gin router with default middleware, establishes a gRPC connection to a Greeter service, and defines a GET endpoint at \"/rest/n/:name\". When called, the endpoint extracts the name parameter, makes a gRPC call to the Greeter service, and returns either the greeting message or an error in JSON format. The server listens on port 8080.\n\nInput: None (The function takes no direct input parameters but relies on incoming HTTP requests to the defined endpoint)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that outputs JSON responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/gin-gonic/examples/grpc/example1/gen/helloworld/v1\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := v1.NewGreeterClient(conn)\n\n\tr := gin.Default()\n\tr.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\n\t\treq := &v1.HelloRequest{Name: name}\n\t\tres, err := client.SayHello(c, req)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\"error\": err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"result\": fmt.Sprint(res.Message),\n\t\t})\n\t})\n\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tlog.Fatalf(\"could not run server: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\ntype GreeterClient struct {\n\tclient *grpc.ClientConn\n}\n\nfunc NewGreeterClient(addr string) (*GreeterClient, error) {\n\tconn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &GreeterClient{client: conn}, nil\n}\n\ntype HelloRequest struct {\n\tName string `json:\"name\"`\n}\n\ntype HelloResponse struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc (g *GreeterClient) SayHello(ctx context.Context, req *HelloRequest) (*HelloResponse, error) {\n\tclient := pb.NewGreeterClient(g.client)\n\tresp, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &HelloResponse{Message: resp.Message}, nil\n}\n\nfunc main() {\n\tgreeterClient, err := NewGreeterClient(\"localhost:50051\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tr := gin.Default()\n\n\tr.GET(\"/rest/n/:name\", func(c *gin.Context) {\n\t\tname := c.Param(\"name\")\n\t\treq := &HelloRequest{Name: name}\n\t\tresp, err := greeterClient.SayHello(context.Background(), req)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, map[string]string{\"message\": resp.Message})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles user management with versioned API endpoints and authentication middleware.\n\nFunction Description: The main function initializes a Gin router with versioned API endpoints (/v1 and /v2) for user management. Each version has public GET endpoints and protected POST endpoints that require authentication through middleware.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything but starts an HTTP server listening on port 8081)\n\nMethods:\n\nAuthMiddleWare: () -> gin.HandlerFunc - Returns a Gin middleware function that handles authentication for protected routes\nAddV1User: (*gin.Context) -> None - Handles POST requests to add users for API version 1\nAddV2User: (*gin.Context) -> None - Handles POST requests to add users for API version 2",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tapiV1 := router.Group(\"/v1\")\n\n\tapiV1.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V1 Users\")\n\t})\n\n\tauthV1 := apiV1.Group(\"/\", AuthMiddleWare())\n\n\tauthV1.POST(\"users/add\", AddV1User)\n\n\tapiV2 := router.Group(\"/v2\")\n\n\tapiV2.GET(\"users\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, \"List Of V2 Users\")\n\t})\n\n\tauthV2 := apiV2.Group(\"/\", AuthMiddleWare())\n\n\tauthV2.POST(\"users/add\", AddV2User)\n\n\t_ = router.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar users = map[string]string{}\n\nfunc AuthMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\t// Simple authentication check (e.g., token or username/password)\n\t\t// In a real scenario, this would validate a token or authenticate the user\n\t\tif c.Request.Header.Get(\"Authorization\") != \"Bearer validtoken\" {\n\t\t\tc.AbortWithStatus(401)\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n}\n\nfunc AddV1User(c *gin.Context) {\n\tvar user struct {\n\t\tName string `json:\"name\"`\n\t}\n\tif err := c.ShouldBindJSON(&user); err != nil {\n\t\tc.AbortWithStatus(400)\n\t\treturn\n\t}\n\tusers[user.Name] = \"password\"\n\tc.JSON(200, gin.H{\"message\": \"User added successfully\"})\n}\n\nfunc AddV2User(c *gin.Context) {\n\tvar user struct {\n\t\tName string `json:\"name\"`\n\t}\n\tif err := c.ShouldBindJSON(&user); err != nil {\n\t\tc.AbortWithStatus(400)\n\t\treturn\n\t}\n\tusers[user.Name] = \"password\"\n\tc.JSON(200, gin.H{\"message\": \"User added successfully\"})\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Versioned API endpoints\n\tv1 := r.Group(\"/v1\")\n\t{\n\t\tv1.GET(\"/\", func(c *gin.Context) {\n\t\t\tc.JSON(200, gin.H{\"message\": \"Public GET endpoint for v1\"})\n\t\t})\n\t\tv1.POST(\"/\", AuthMiddleware(), AddV1User)\n\t}\n\n\tv2 := r.Group(\"/v2\")\n\t{\n\t\tv2.GET(\"/\", func(c *gin.Context) {\n\t\t\tc.JSON(200, gin.H{\"message\": \"Public GET endpoint for v2\"})\n\t\t})\n\t\tv2.POST(\"/\", AuthMiddleware(), AddV2User)\n\t}\n\n\tr.Run(\":8081\")\n}"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that returns a \"pong\" message with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tcurrentTime := time.Now().Unix()\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t\t\"time\":    currentTime,\n\t\t})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a JSON message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at \"/api/hello\" that returns a JSON response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/api/hello\" endpoint)\n\nOutput: \n- When successful: The server runs indefinitely, listening on port 8080\n- When failing: An error message is printed if the server fails to start\n- HTTP Response: For GET requests to \"/api/hello\", returns a JSON response with status 200 OK: {\"message\": \"Hello, HTTP!\"}",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\trouter.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\n\terr := router.Run(\":8080\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/api/hello\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello, HTTP!\"})\n\t})\n\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with static file serving capabilities and a simple ping endpoint.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), serves static files from a binary filesystem at the \"/static\" route, and sets up a GET endpoint at \"/ping\" that returns a simple text response. The server listens on port 8080.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\n\tassetfs \"github.com/elazarl/go-bindata-assetfs\"\n\t\"github.com/gin-gonic/contrib/static\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.Use(static.Serve(\"/static\", BinaryFileSystem(\"data\")))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"test\")\n\t}\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc initAndRunServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the binary filesystem at \"/static\" route\n\tr.Static(\"/static\", \"./static\")\n\n\t// Define a GET endpoint at \"/ping\"\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\t// Run the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Go struct that represents a main server application using the Gin web framework, with capabilities for logging configuration, route grouping, and JWT authentication middleware integration.\n\nStruct Description: The Main struct represents a web server application that uses Gin as its web framework. It handles server initialization, route configuration with JWT authentication for protected routes, and serves as the entry point for the application.\n\nFields:\nrouter: *gin.Engine - The Gin engine instance that handles all HTTP routing and middleware\n\nMethods:\ninitServer: () -> error - Initializes the Gin server with configured logging settings (file and console logging based on configuration). Returns error if initialization fails.\nmain: () - Entry point of the application that creates the Main instance, initializes the server, sets up route handlers with JWT authentication for protected routes, and starts the server on the configured port.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/contrib/jwt\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\tvar err error\n\n\tif common.Config.EnableGinFileLog {\n\t\tf, _ := os.Create(\"logs/gin.log\")\n\t\tif common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter(os.Stdout, f)\n\t\t} else {\n\t\t\tgin.DefaultWriter = io.MultiWriter(f)\n\t\t}\n\t} else {\n\t\tif !common.Config.EnableGinConsoleLog {\n\t\t\tgin.DefaultWriter = io.MultiWriter()\n\t\t}\n\t}\n\n\tm.router = gin.Default()\n\n\treturn nil\n}\n\nfunc main() {\n\tm := Main{}\n\n\tif m.initServer() != nil {\n\t\treturn\n\t}\n\n\tc := controllers.User{}\n\tv1 := m.router.Group(\"/api/v1\")\n\t{\n\t\tadmin := v1.Group(\"/admin\")\n\t\t{\n\t\t\tadmin.POST(\"/auth\", c.Authenticate)\n\t\t}\n\n\t\tuser := v1.Group(\"/users\")\n\n\t\tuser.Use(jwt.Auth(common.Config.JwtSecretPassword))\n\t\t{\n\t\t\tuser.POST(\"\", c.AddUser)\n\t\t\tuser.GET(\"/list\", c.ListUsers)\n\t\t\tuser.GET(\"detail/:id\", c.GetUserByID)\n\t\t\tuser.GET(\"/\", c.GetUserByParams)\n\t\t\tuser.DELETE(\":id\", c.DeleteUserByID)\n\t\t\tuser.PATCH(\"\", c.UpdateUser)\n\t\t}\n\t}\n\n\tm.router.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tm.router.Run(common.Config.Port)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype Main struct {\n\trouter *gin.Engine\n}\n\nfunc (m *Main) initServer() error {\n\tlogrus.SetFormatter(&logrus.TextFormatter{\n\t\tFullTimestamp: true,\n\t})\n\tlogrus.Info(\"Initializing server with logging configuration\")\n\n\tm.router = gin.Default()\n\n\t// Example middleware setup for logging\n\tm.router.Use(func(c *gin.Context) {\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"method\": c.Request.Method,\n\t\t\t\"uri\":    c.Request.URL.String(),\n\t\t}).Info(\"Request received\")\n\t\tc.Next()\n\t})\n\n\treturn nil\n}\n\nfunc (m *Main) main() {\n\tif err := m.initServer(); err != nil {\n\t\tlogrus.Fatal(\"Failed to initialize server:\", err)\n\t}\n\n\t// Example route setup with JWT authentication\n\tprotectedRoute := m.router.Group(\"/api\")\n\t{\n\t\tprotectedRoute.Use(func(c *gin.Context) {\n\t\t\t// In a real scenario, this would check for a valid JWT token\n\t\t\tc.Set(\"user\", \"testUser\")\n\t\t\tc.Next()\n\t\t})\n\t\tprotectedRoute.GET(\"/protected\", func(c *gin.Context) {\n\t\t\tuser := c.MustGet(\"user\").(string)\n\t\t\tc.JSON(200, gin.H{\"message\": \"Protected route\", \"user\": user})\n\t\t})\n\t}\n\n\t// Start the server on port 8080\n\tlogrus.Info(\"Server started on :8080\")\n\tm.router.Run(\":8080\")\n}"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, saving the uploaded file to the local filesystem and returning a success message.\n\nFunction Description: The function initializes a Gin router with default middleware, sets up a static file server, and defines a POST endpoint for file uploads. It handles multipart form data containing a file and additional fields (name and email), saves the file to disk, and returns a confirmation message.\n\nInput: \n- None (the function takes no direct input parameters; inputs come via HTTP requests)\n\nOutput:\n- None (the function doesn't return anything; it starts an HTTP server that runs indefinitely)\n\nNote: The function expects HTTP POST requests to the \"/upload\" endpoint with multipart form data containing:\n1. A file (form field name \"file\")\n2. Text fields \"name\" and \"email\"",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, _ := c.FormFile(\"file\")\n\t\tsrc, _ := file.Open()\n\t\tdefer src.Close()\n\n\t\tdst, _ := os.Create(file.Filename)\n\t\tdefer dst.Close()\n\n\t\tio.Copy(dst, src)\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, name, email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc startServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"static\" directory\n\tr.Static(\"/static\", \"./static\")\n\n\t// Define the POST endpoint for file uploads\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\t// Parse the multipart form\n\t\terr := c.Request.ParseMultipartForm(10 << 20) // 10MB\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to parse form\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Get the uploaded file\n\t\tfile, handler, err := c.Request.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"No file uploaded or invalid file field\"})\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Get the name and email fields\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\t// Define the save path\n\t\tsavePath := filepath.Join(\"uploads\", handler.Filename)\n\t\tos.MkdirAll(\"uploads\", os.ModePerm)\n\n\t\t// Save the file\n\t\toutFile, err := os.Create(savePath)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer outFile.Close()\n\n\t\t_, err = io.Copy(outFile, file)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save file\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Return success message\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"file\":    handler.Filename,\n\t\t\t\"name\":    name,\n\t\t\t\"email\":   email,\n\t\t})\n\t})\n\n\t// Start the server\n\tlog.Println(\"Server started on :8080\")\n\tlog.Fatal(r.Run(\":8080\"))\n}"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a timestamped message.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (Logger and Recovery), sets up a single GET route handler at \"/ping\" that responds with a \"pong\" message concatenated with the current Unix timestamp, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server that sends responses to incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tcurrentTime := time.Now().Unix()\n\t\tc.String(200, \"pong \"+string(currentTime))\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with a single route handler that responds to GET requests.\n\nFunction Description: The function initializes a default Gin engine with built-in middleware (Logger and Recovery), registers a GET route handler at the path \"/hello\" that responds with a plain text message, and starts the server on port 80. The function is designed to be the main entry point of a Go application using the Gin web framework.\n\nInput: \n- ctx *app.Context: A context object from the eggos framework (used for logging in this example)\n\nOutput: \n- error: Returns any error that occurs during server execution, otherwise nil when the server is properly shut down",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/icexin/eggos/app\"\n)\nfunc main(ctx *app.Context) error {\n\tr := gin.Default()\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"hello from eggos\")\n\t})\n\tctx.Printf(\"run gin server on :80\")\n\treturn r.Run(\":80\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/eggosecurity/eggos\"\n)\n\nfunc StartServer(ctx *eggos.Context) error {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello, World!\")\n\t})\n\n\treturn r.Run(\":80\")\n}"
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements a simple session-based counter. The server should increment and return a counter value with each request, storing the count in a session cookie.\n\nFunction Description: The main function initializes a Gin server with session middleware, sets up a route handler for GET requests at \"/incr\" that increments and returns a session-based counter, and starts the server on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value, but starts an HTTP server that responds to requests with JSON containing the current count, e.g., {\"count\": 5})",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nvar count int\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Initialize session middleware\n\tr.Use(gin.SessionHandler())\n\n\t// Route handler for \"/incr\"\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\t// Get the session\n\t\tsession, _ := c.Session(\"mySession\")\n\n\t\t// Increment the count in the session\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\n\t\t// Save the session\n\t\tsession.Save()\n\n\t\t// Return the count as JSON\n\t\tc.JSON(http.StatusOK, gin.H{\"count\": count})\n\t})\n\n\t// Start the server on port 8000\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Implement a rate-limited HTTP server using the Gin framework in Go, which includes middleware for request rate limiting and a simple endpoint to test the rate limiting functionality.\n\nFunction Description: The `ginRun` function initializes and starts a Gin HTTP server with rate limiting capabilities. It sets up a leaky bucket rate limiter middleware and provides a single endpoint (\"/rate\") for testing the rate limiting. The server runs on port 8080.\n\nInput: \n- `rps` (int): The maximum number of requests per second that the server will allow (rate limit value)\n\nOutput: \n- None (The function starts an HTTP server that runs indefinitely until interrupted)\n- Logs the current rate limit setting to stdout\n- Responds to HTTP requests on the \"/rate\" endpoint with a JSON message",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc ginRun(rps int) {\n\tlimit = ratelimit.New(rps)\n\n\tapp := gin.Default()\n\tapp.Use(leakBucket())\n\n\tapp.GET(\"/rate\", func(ctx *gin.Context) {\n\t\tctx.JSON(200, \"rate limiting test\")\n\t})\n\n\tlog.Printf(color.CyanString(\"Current Rate Limit: %v requests/s\", rps))\n\tapp.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"log\"\n\t\"time\"\n)\n\ntype RateLimiter struct {\n\tbucket   float64\n\tperiod   time.Duration\n\tallowed  int\n\tremaining float64\n}\n\nfunc NewRateLimiter(rps int) *RateLimiter {\n\tperiod := time.Second\n\tbucket := float64(rps) * period.Seconds()\n\treturn &RateLimiter{\n\t\tbucket:   bucket,\n\t\tperiod:   period,\n\t\tallowed:  rps,\n\t\tremaining: bucket,\n\t}\n}\n\nfunc (rl *RateLimiter) Allow(c *gin.Context) bool {\n\tif rl.remaining <= 0 {\n\t\trl.remaining = rl.bucket\n\t}\n\trl.remaining -= 1\n\treturn true\n}\n\nfunc (rl *RateLimiter) Update() {\n\t// This is a simplified update for demonstration purposes\n\t// In a real implementation, this would calculate the time elapsed and refill the bucket\n\ttime.Sleep(rl.period)\n\trl.remaining = rl.bucket\n}\n\nfunc ginRun(rps int) {\n\trl := NewRateLimiter(rps)\n\tlog.Printf(\"Rate limit set to %d requests per second\", rps)\n\n\tr := gin.Default()\n\n\tr.Use(func(c *gin.Context) {\n\t\tif !rl.Allow(c) {\n\t\t\tc.AbortWithStatusJSON(429, gin.H{\"error\": \"too many requests\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t})\n\n\tr.GET(\"/rate\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Request allowed\"})\n\t})\n\n\tlog.Println(\"Server running on http://localhost:8080\")\n\tlog.Fatal(r.Run(\":8080\"))\n}"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements a simple session-based counter. The server should increment and return a counter value with each request, storing the count in a session.\n\nFunction Description: The main function initializes a Gin server with session middleware, sets up a route handler for GET requests at \"/incr\" that increments and returns a session-based counter, and starts the server on port 8000.\n\nInput: None (The function takes no direct input parameters, but handles HTTP GET requests to the \"/incr\" endpoint)\n\nOutput: None (The function doesn't return any value, but starts an HTTP server that responds to requests with JSON containing the current count, e.g., {\"count\": 5})",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\tstore := sessions.NewCookieStore([]byte(\"secret\"))\n\tr.Use(sessions.Sessions(\"mysession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession := sessions.Default(c)\n\t\tvar count int\n\t\tv := session.Get(\"count\")\n\t\tif v == nil {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcount = v.(int)\n\t\t\tcount += 1\n\t\t}\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save()\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\tr.Run(\":8000\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/sessions\"\n)\n\nvar store = sessions.NewCookieStore([]byte(\"secret-key\"))\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(sessions.Sessions(\"mySession\", store))\n\n\tr.GET(\"/incr\", func(c *gin.Context) {\n\t\tsession, _ := store.Get(c, \"mySession\")\n\t\tcount, _ := session.Get(\"count\", 0).(int)\n\t\tcount++\n\t\tsession.Set(\"count\", count)\n\t\tsession.Save(c, nil)\n\t\tc.JSON(200, gin.H{\"count\": count})\n\t})\n\n\tr.Run(\":8000\")\n}"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a Go function that sets up a simple HTTP server using the Gin framework to retrieve and return the client's IP address.\n\nFunction Description: The function initializes a Gin HTTP server with default middleware (Logger and Recovery), registers a GET endpoint \"/getip\" that retrieves the client's IP address from the request context, and returns it as a JSON response. The server listens on port 8080.\n\nInput: None (The function takes no input parameters)\n\nOutput: None (The function does not return any value but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/getip\", func(c *gin.Context) {\n\t\tip := c.ClientIP()\n\t\tc.JSON(http.StatusOK, gin.H{\"ip\": ip})\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc startServer() {\n\tr := gin.Default()\n\n\tr.GET(\"/getip\", func(c *gin.Context) {\n\t\tip := c.ClientIP()\n\t\tc.JSON(http.StatusOK, gin.H{\"ip\": ip})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Implement a JWT-based authentication service using Gin framework in Go, which provides public endpoints for token generation and private endpoints that require valid JWT tokens for access.\n\nFunction Description: The main function sets up a Gin HTTP server with JWT authentication. It creates two route groups: a public group for token generation and a private group that requires JWT authentication. The public endpoint generates JWT tokens, while the private endpoint demonstrates protected access.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests with the following possible inputs:\n- GET request to \"/api/\" for token generation\n- GET request to \"/api/private/\" for accessing protected content)\n\nOutput: HTTP responses with the following possible outputs:\n- For \"/api/\": JSON response containing a JWT token or error message\n- For \"/api/private/\": JSON response with protected content or authentication error\n- The server runs continuously on localhost:8080",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"time\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar jwtKey = []byte(\"your-secure-secret-key\")\n\ntype Claims struct {\n\tUserID string `json:\"user_id\"`\n\tjwt.StandardClaims\n}\n\nfunc generateToken(userID string) (string, error) {\n\tclaims := &Claims{\n\t\tUserID: userID,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: time.Now().Add(24 * time.Hour).Unix(),\n\t\t},\n\t}\n\ttoken, err := jwt.NewWithClaims(jwt.SigningMethodHS256, claims).SignedString(jwtKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn token, nil\n}\n\nfunc validateToken(tokenString string) (*Claims, error) {\n\tclaims := &Claims{}\n\ttkn, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtKey, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !tkn.Valid {\n\t\treturn nil, jwt.ValidationError{}\n\t}\n\treturn claims, nil\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/api/\", func(c *gin.Context) {\n\t\tuserID := \"user123\"\n\t\ttoken, err := generateToken(userID)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate token\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"token\": token})\n\t})\n\n\tprivateGroup := r.Group(\"/api/\")\n\tprivateGroup.Use(func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Missing authorization header\"})\n\t\t\treturn\n\t\t}\n\t\tclaims, err := validateToken(tokenString)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\treturn\n\t\t}\n\t\tc.Set(\"user_id\", claims.UserID)\n\t\tc.Next()\n\t})\n\n\tprivateGroup.GET(\"/private/\", func(c *gin.Context) {\n\t\tuserID := c.MustGet(\"user_id\").(string)\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Protected content for user: \" + userID})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS web server using the Gin framework, serving a welcome page at the \"/welcome\" endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), sets up HTML templates, registers a GET handler for the \"/welcome\" endpoint that returns an HTML response, and starts the HTTPS server using the provided TLS certificate and key files.\n\nInput:\n- port (string): The port number to listen on, e.g., \":8080\"\n- certFile (string): Path to the TLS certificate file, e.g., \"./testdata/server.pem\"\n- keyFile (string): Path to the TLS private key file, e.g., \"./testdata/server.key\"\n- html (template.Template): HTML template to be used for responses\n\nOutput: None (the function runs indefinitely as a web server)\n\nNote: The function includes a warning about not using embedded certificates in production environments.",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tlogger := log.New(os.Stderr, \"\", 0)\n\tlogger.Println(\"[WARNING] DON'T USE THE EMBED CERTS FROM THIS EXAMPLE IN PRODUCTION ENVIRONMENT, GENERATE YOUR OWN!\")\n\n\tr := gin.Default()\n\tr.SetHTMLTemplate(html)\n\n\tr.GET(\"/welcome\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"https\", gin.H{\n\t\t\t\"status\": \"success\",\n\t\t})\n\t})\n\n\tr.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc startSecureServer(port, certFile, keyFile string, html template.Template) {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.GET(\"/welcome\", func(c *gin.Context) {\n\t\tc.HTML(200, \"welcome\", gin.H{\n\t\t\t\"message\": \"Welcome to the secure server!\",\n\t\t})\n\t})\n\n\t// Load TLS certificate and key\n\tcert, err := io.ReadFile(certFile)\n\tif err != nil {\n\t\tpanic(\"failed to read certificate file\")\n\t}\n\tkey, err := io.ReadFile(keyFile)\n\tif err != nil {\n\t\tpanic(\"failed to read key file\")\n\t}\n\n\t// Run HTTPS server\n\tif err := r.RunTLS(port, cert, key); err != nil {\n\t\tpanic(\"server closed unexpectedly\")\n\t}\n}"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that handles POST requests to a specific endpoint, processes JSON input, and returns appropriate JSON responses.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint \"/service-b/try\" that receives JSON account data, processes it, and returns success or error responses in JSON format.\n\nInput: \n- None (the function takes no direct input parameters, but receives HTTP requests with JSON payloads matching the Account struct format)\n\nOutput:\n- None (the function doesn't return any value directly, but sends HTTP responses with JSON bodies containing either success or error messages)\n\nNote: The Account struct (not shown in reference code) would typically contain at least an ID field to be properly processed by this endpoint.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-b/try\", func(context *gin.Context) {\n\t\taccount := &Account{}\n\t\terr := context.BindJSON(account)\n\t\tif err == nil {\n\t\t\tfmt.Println(fmt.Sprintf(\"account %d tried!\", account.ID))\n\t\t\tcontext.JSON(200, gin.H{\n\t\t\t\t\"success\": true,\n\t\t\t\t\"message\": fmt.Sprintf(\"account %d tried!\", account.ID),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tcontext.JSON(400, gin.H{\n\t\t\t\"success\": false,\n\t\t\t\"message\": err.Error(),\n\t\t})\n\t})\n\n\tr.Run(\":8081\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\ntype Account struct {\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-b/try\", func(c *gin.Context) {\n\t\tvar account Account\n\t\tif err := c.ShouldBindJSON(&account); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"invalid JSON format\"})\n\t\t\treturn\n\t\t}\n\n\t\tif account.ID <= 0 || account.Name == \"\" {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"invalid account data\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"success\": true, \"message\": \"Account processed successfully\", \"data\": account})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that implements JWT-based authentication with public and private routes. The server should generate tokens for public access and validate them for private routes.\n\nFunction Description: The main function sets up a Gin server with two route groups: public routes that generate JWT tokens, and private routes that require valid JWT tokens for access. The server runs on localhost:8080.\n\nInput: None (The function takes no direct input parameters as it's the main entry point)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens for requests)\n\nMethods:\n\n1. Public route handler: Handles GET requests to \"/api/\" and generates a JWT token\n   - Input: Gin context object\n   - Output: JSON response containing either the token or an error message\n\n2. Private route handler: Handles GET requests to \"/api/private/\" and requires valid JWT\n   - Input: Gin context object (with validated JWT)\n   - Output: JSON response with a private message\n\n3. Server startup: Starts the Gin server on port 8080\n   - Input: Address string (\"localhost:8080\")\n   - Output: None (blocks and serves requests)",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"time\"\n\t\"net/http\"\n)\n\nvar jwtKey = []byte(\"your-secret-key\")\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tjwt.StandardClaims\n}\n\nfunc generateToken(username string) (string, error) {\n\tclaims := &Claims{\n\t\tUsername: username,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: time.Now().Add(24 * time.Hour).Unix(),\n\t\t},\n\t}\n\ttoken, err := jwt.NewWithClaims(jwt.SigningMethodHS256, claims).SignedString(jwtKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn token, nil\n}\n\nfunc validateToken(c *gin.Context) {\n\ttokenStr := c.GetHeader(\"Authorization\")\n\tif tokenStr == \"\" {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"missing token\"})\n\t\treturn\n\t}\n\ttoken, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.GoSimpleClaims); !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected method type: %v\", token.Method.Type())\n\t\t}\n\t\treturn jwtKey, nil\n\t})\n\tif err != nil {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token\"})\n\t\treturn\n\t}\n\tif token.Valid {\n\t\tclaims, ok := token.Claims.(jwt.MapClaims)\n\t\tif ok && claims[\"username\"] != nil {\n\t\t\tc.Set(\"username\", claims[\"username\"])\n\t\t} else {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid claims\"})\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token\"})\n\t\treturn\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublicGroup := r.Group(\"/api/\")\n\tpublicGroup.GET(\"/\", func(c *gin.Context) {\n\t\ttoken, err := generateToken(\"user123\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to generate token\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"token\": token})\n\t})\n\n\tprivateGroup := r.Group(\"/api/private/\")\n\tprivateGroup.Use(validateToken)\n\tprivateGroup.GET(\"/\", func(c *gin.Context) {\n\t\tusername := c.MustGet(\"username\").(string)\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome, \" + username + \"!\"})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that serves HTML templates, static files, and a favicon, with routes for the main page and a foo page.\n\nFunction Description: The main function initializes a Gin router, sets up HTML templates from embedded files, serves static files, defines route handlers for the root path (\"/\"), \"/foo\" path, and favicon, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters, but relies on embedded filesystem content for templates and assets)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that continues running)\n\nNote: The implementation assumes the existence of an embedded filesystem (variable 'f' of type embed.FS) containing template files in \"templates/\" and \"templates/foo/\" directories, and assets in an \"assets/\" directory.",
    "Canonical_solution": "import (\n\t\"embed\"\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\ttempl := template.Must(template.New(\"\").ParseFS(f, \"templates/*.tmpl\", \"templates/foo/*.tmpl\"))\n\trouter.SetHTMLTemplate(templ)\n\n\trouter.StaticFS(\"/public\", http.FS(f))\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"index.tmpl\", gin.H{\n\t\t\t\"title\": \"Main website\",\n\t\t})\n\t})\n\n\trouter.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(http.StatusOK, \"bar.tmpl\", gin.H{\n\t\t\t\"title\": \"Foo website\",\n\t\t})\n\t})\n\n\trouter.GET(\"favicon.ico\", func(c *gin.Context) {\n\t\tfile, _ := f.ReadFile(\"assets/favicon.ico\")\n\t\tc.Data(\n\t\t\thttp.StatusOK,\n\t\t\t\"image/x-icon\",\n\t\t\tfile,\n\t\t)\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/embed\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Set up HTML templates from embedded files\n\tr.LoadHTMLGlob(\"templates/*.html\")\n\n\t// Serve static files from the assets directory\n\tr.Static(\"/assets\", \"assets\")\n\n\t// Define route handlers\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.HTML(200, \"index.html\", nil)\n\t})\n\n\tr.GET(\"/foo\", func(c *gin.Context) {\n\t\tc.HTML(200, \"foo.html\", nil)\n\t})\n\n\t// Handle favicon\n\tr.Favicon(\"assets/favicon.ico\")\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, and serves static files from a specified directory.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), serves static files from a \"./public\" directory, and handles POST requests to \"/upload\" endpoint for file uploads with additional form fields (name and email). It processes the uploaded files and form data, saves the files to the server, and returns a success message.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it starts an HTTP server on port 8080 and handles incoming requests)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, _ := c.MultipartForm()\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tsrc, _ := file.Open()\n\t\t\tdefer src.Close()\n\n\t\t\tdst, _ := os.Create(file.Filename)\n\t\t\tdefer dst.Close()\n\n\t\t\tio.Copy(dst, src)\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"public\" directory\n\tr.Static(\"/static\", \"./public\")\n\n\t// Handle file upload with form data\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\t// Parse the multipart form\n\t\tc.Request.ParseMultipartForm(10 << 20) // 10MB\n\n\t\t// Get the form fields\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\t// Get the uploaded file\n\t\tfile, handler, err := c.Request.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Define the destination path\n\t\tdst, err := filepath.Abs(\"./uploads/\" + handler.Filename)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\n\t\t// Create the directory if it doesn't exist\n\t\tos.MkdirAll(filepath.Dir(dst), os.ModePerm)\n\n\t\t// Save the uploaded file\n\t\tout, err := os.Create(dst)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\t\tdefer out.Close()\n\n\t\t_, err = io.Copy(out, file)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatus(500)\n\t\t\treturn\n\t\t}\n\n\t\t// Return success message\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"name\":    name,\n\t\t\t\"email\":   email,\n\t\t\t\"file\":    handler.Filename,\n\t\t})\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, serving static files from a public directory.\n\nFunction Description: The function initializes a Gin router with default middleware, configures a static file server, and sets up a POST endpoint for handling file uploads with additional form fields. It validates the upload, saves the file, and returns a success message with the form data.\n\nInput: None (The function takes no direct input parameters but processes HTTP requests with the following expected form data:\n- \"name\": string - Name field from the form\n- \"email\": string - Email field from the form\n- \"file\": file - File to be uploaded)\n\nOutput: None (The function doesn't return any value but sends HTTP responses:\n- Success: HTTP 200 with upload confirmation message\n- Error: HTTP 400 with error message for invalid requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfilename := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, \"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, name, email)\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Serve static files from the \"public\" directory\n\tr.Static(\"/static\", \"public\")\n\n\t// POST endpoint for file upload with form data\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\t// Bind form data\n\t\tvar formData struct {\n\t\t\tName  string\n\t\t\tEmail string\n\t\t}\n\t\tif err := c.ShouldBind(&formData, gin.Binder(gin.BindJson)); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Handle file upload\n\t\tfile, handler, err := c.Request.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Error retrieving the file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Define the destination path for the uploaded file\n\t\tdst, err := os.Create(filepath.Join(\"uploads\", handler.Filename))\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Error creating file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer dst.Close()\n\n\t\t// Copy the uploaded file to the destination\n\t\tif _, err = dst.ReadFrom(file); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Error saving the file\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Success response\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"File uploaded successfully\",\n\t\t\t\"name\":    formData.Name,\n\t\t\t\"email\":   formData.Email,\n\t\t\t\"file\":    handler.Filename,\n\t\t})\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using the Gin web framework, which responds to GET requests at the root path with a JSON message.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a GET route handler for the root path (\"/\") that returns a JSON response, and starts the HTTPS server using the provided TLS certificate and key files.\n\nInput: \n- port (string): The port number on which the server should listen, prefixed with \":\" (e.g., \":5002\")\n- certFile (string): Path to the TLS certificate file (e.g., \"manager.crt\")\n- keyFile (string): Path to the TLS private key file (e.g., \"manager.key\")\n\nOutput: None (The function runs an infinite loop to serve HTTP requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\ts := gin.Default()\n\ts.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"msg\": \"passed\"})\n\t})\n\ts.RunTLS(\":5002\", \"manager.crt\", \"manager.key\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc startSecureServer(port, certFile, keyFile string) {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"Secure HTTPS server is running\",\n\t\t})\n\t})\n\n\terr := r.RunTLS(port, certFile, keyFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Go function that initializes and configures a Gin HTTP server with New Relic monitoring middleware, and defines a simple route handler.\n\nFunction Description: The function sets up a basic Gin web server with default middleware (Logger and Recovery), configures New Relic monitoring if environment variables are present, and registers a root route handler that returns \"Hello World!\". The server runs on the default port (8080).\n\nInput: None (uses environment variables APP_NAME and NEW_RELIC_API_KEY for optional New Relic configuration)\n\nOutput: None (starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/newrelic/go-agent\"\n)\nfunc main() {\n\trouter := gin.Default()\n\n\tcfg := newrelic.NewConfig(os.Getenv(\"APP_NAME\"), os.Getenv(\"NEW_RELIC_API_KEY\"))\n\tapp, err := newrelic.NewApplication(cfg)\n\tif err != nil {\n\t\tlog.Printf(\"failed to make new_relic app: %v\", err)\n\t} else {\n\t\trouter.Use(NewRelicMonitoring(app))\n\t}\n\n\trouter.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello World!\\n\")\n\t})\n\trouter.Run()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"os\"\n\t\"github.com/newrelic/go-newrelic\"\n)\n\nfunc setupServer() {\n\tr := gin.Default()\n\n\t// Check if New Relic environment variables are set\n\tappName := os.Getenv(\"APP_NAME\")\n\tnewRelicAPIKey := os.Getenv(\"NEW_RELIC_API_KEY\")\n\n\tif appName != \"\" && newRelicAPIKey != \"\" {\n\t\t// Initialize New Relic\n\t\tnr, err := newrelic.NewApplication(appName, newrelic.Config{\n\t\t\tLicenseKey: newRelicAPIKey,\n\t\t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer nr.Close()\n\n\t\t// Set New Relic middleware\n\t\tr.Use(nr.Middleware())\n\t}\n\n\t// Define a simple route handler\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(200, \"Hello World!\")\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to GET requests with a basic message.\n\nFunction Description: The main function initializes a Gin router with default middleware (Logger and Recovery), sets up a GET route handler at the \"/ping\" endpoint that responds with \"pong\", and starts the server on the default port (8080).\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP GET requests to the \"/ping\" endpoint)\n\nOutput: None (The function doesn't return any value, but sends \"pong\" as a response to GET requests at \"/ping\" and runs the HTTP server continuously until interrupted)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tlog.Fatal(r.Run())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- None (The function takes no parameters as it's the main entry point)\n\nOutput: \n- None (The function doesn't return but runs an HTTP server indefinitely or until fatal error)\n\nNote: The function uses autotls.Run() which automatically obtains and renews TLS certificates from Let's Encrypt for the specified domains. The server will listen on both HTTP (port 80) and HTTPS (port 443) ports.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/cosmos76/autotls\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"pong\"})\n\t})\n\n\tautotls.Run(\":80\", \":443\", \"example.com\")\n}"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a Go HTTP server using the Gin framework that provides translation services through the DeepLX API. The server should handle GET and POST requests, implement authentication middleware, and support proxy configuration.\n\nFunction Description: The main function initializes a Gin HTTP server with CORS support, sets up routes for translation services, and starts the server on a specified port. It includes:\n1. Configuration initialization\n2. Proxy setup (if configured)\n3. Route handlers for root (/) and translation (/translate) endpoints\n4. Authentication middleware for protected routes\n5. Translation request processing and response handling\n\nInput:\n- Configuration parameters (IP, Port, Proxy, Token) from initConfig()\n- Environment variable PROXY (optional)\n- HTTP requests:\n  * GET / - Returns server information\n  * POST /translate - Accepts JSON payload with translation parameters\n\nOutput:\n- HTTP responses:\n  * For GET /: JSON response with server information\n  * For POST /translate: JSON response with translation results or error message\n- Console output: Server startup message and configuration status\n\nStruct Description: (Not applicable - the reference code is at function level)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\n\ttranslate \"github.com/OwO-Network/DeepLX/translate\"\n\t\"github.com/gin-contrib/cors\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tcfg := initConfig()\n\n\tfmt.Printf(\"DeepL X has been successfully launched! Listening on %v:%v\\n\", cfg.IP, cfg.Port)\n\tfmt.Println(\"Developed by sjlleo <i@leo.moe> and missuo <me@missuo.me>.\")\n\n\tproxyURL := os.Getenv(\"PROXY\")\n\tif proxyURL == \"\" {\n\t\tproxyURL = cfg.Proxy\n\t}\n\tif proxyURL != \"\" {\n\t\tproxy, err := url.Parse(proxyURL)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to parse proxy URL: %v\", err)\n\t\t}\n\t\thttp.DefaultTransport = &http.Transport{\n\t\t\tProxy: http.ProxyURL(proxy),\n\t\t}\n\t}\n\n\tif cfg.Token != \"\" {\n\t\tfmt.Println(\"Access token is set.\")\n\t}\n\n\tgin.SetMode(gin.ReleaseMode)\n\tr := gin.Default()\n\tr.Use(cors.Default())\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"code\":    http.StatusOK,\n\t\t\t\"message\": \"DeepL Free API, Developed by sjlleo and missuo. Go to /translate with POST. http://github.com/OwO-Network/DeepLX\",\n\t\t})\n\t})\n\n\tr.POST(\"/translate\", authMiddleware(cfg), func(c *gin.Context) {\n\t\treq := PayloadFree{}\n\t\tc.BindJSON(&req)\n\n\t\tsourceLang := req.SourceLang\n\t\ttargetLang := req.TargetLang\n\t\ttranslateText := req.TransText\n\t\ttagHandling := req.TagHandling\n\n\t\tproxyURL := cfg.Proxy\n\n\t\tif tagHandling != \"\" && tagHandling != \"html\" && tagHandling != \"xml\" {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\n\t\t\t\t\"code\":    http.StatusBadRequest,\n\t\t\t\t\"message\": \"Invalid tag_handling value. Allowed values are 'html' and 'xml'.\",\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tresult, err := translate.TranslateByDeepLX(sourceLang, targetLang, translateText, tagHandling, proxyURL, \"\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Translation failed: %s\", err)\n\t\t}\n\n\t\tif result.Code == http.StatusOK {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":         http.StatusOK,\n\t\t\t\t\"id\":           result.ID,\n\t\t\t\t\"data\":         result.Data,\n\t\t\t\t\"alternatives\": result.Alternatives,\n\t\t\t\t\"source_lang\":  result.SourceLang,\n\t\t\t\t\"target_lang\":  result.TargetLang,\n\t\t\t\t\"method\":       result.Method,\n\t\t\t})\n\t\t} else {\n\t\t\tc.JSON(result.Code, gin.H{\n\t\t\t\t\"code\":    result.Code,\n\t\t\t\t\"message\": result.Message,\n\t\t\t})\n\t\t}\n\t})\n\n\tr.Run(fmt.Sprintf(\"%v:%v\", cfg.IP, cfg.Port))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Config struct {\n\tIP       string\n\tPort     int\n\tProxy    bool\n\tToken    string\n}\n\nfunc initConfig() *Config {\n\tip := os.Getenv(\"IP\")\n\tportStr := os.Getenv(\"PORT\")\n\tproxyEnv := os.Getenv(\"PROXY\")\n\ttoken := os.Getenv(\"TOKEN\")\n\n\tvar port int\n\tif portStr != \"\" {\n\t\tport, _ = strconv.Atoi(portStr)\n\t}\n\n\tproxy := false\n\tif proxyEnv != \"\" && strings.ToLower(proxyEnv) == \"true\" {\n\t\tproxy = true\n\t}\n\n\treturn &Config{\n\t\tIP:       ip,\n\t\tPort:     port,\n\t\tProxy:    proxy,\n\t\tToken:    token,\n\t}\n}\n\nfunc main() {\n\tconfig := initConfig()\n\tfmt.Printf(\"Server starting on %s:%d\\n\", config.IP, config.Port)\n\tfmt.Printf(\"Proxy configuration: %v\\n\", config.Proxy)\n\tfmt.Printf(\"Token: %s\\n\", config.Token)\n\n\tr := gin.Default()\n\n\t// CORS middleware\n\tr.Use(func(c *gin.Context) {\n\t\tc.Writer.HeaderSet(\"Access-Control-Allow-Origin\", \"*\")\n\t\tc.Writer.HeaderSet(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n\t\tc.Writer.HeaderSet(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\t\tc.Writer.HeaderSet(\"Access-Control-Allow-Credentials\", \"true\")\n\t\tc.Writer.HeaderSet(\"Access-Control-Max-Age\", \"1000\")\n\t\tif c.Request.Method == \"OPTIONS\" {\n\t\t\tc.AbortWithStatus(204)\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t})\n\n\t// Authentication middleware\n\tauthMiddleware := func(c *gin.Context) {\n\t\ttoken := c.GetHeader(\"Authorization\")\n\t\tif token != config.Token {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\treturn\n\t\t}\n\t\tc.Next()\n\t}\n\n\t// Root endpoint\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"Translation server is running\",\n\t\t\t\"ip\":      config.IP,\n\t\t\t\"port\":    config.Port,\n\t\t\t\"proxy\":   config.Proxy,\n\t\t})\n\t})\n\n\t// Translation endpoint with authentication\n\tr.POST(\"/translate\", authMiddleware, func(c *gin.Context) {\n\t\tvar request struct {\n\t\t\tText    string `json:\"text\"`\n\t\t\tTarget  string `json:\"target\"`\n\t\t\tSource  string `json:\"source\"`\n\t\t\tFormat  string `json:\"format\"`\n\t\t\tApiType string `json:\"api_type\"`\n\t\t}\n\t\tif err := c.BindJSON(&request); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request body\"})\n\t\t\treturn\n\t\t}\n\n\t\t// Simulate translation using DeepLX API\n\t\t// In a real scenario, this would call the DeepLX API\n\t\tresult := fmt.Sprintf(\"Translated text: %s\", request.Text)\n\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\"result\": result,\n\t\t})\n\t})\n\n\t// Start server\n\tif config.Proxy {\n\t\t// Proxy setup (example using http.ProxyURL)\n\t\t// In a real scenario, you'd set up a proxy server or use a reverse proxy\n\t\tfmt.Println(\"Proxy is enabled. Starting server...\")\n\t} else {\n\t\tfmt.Println(\"Proxy is disabled. Starting server...\")\n\t}\n\n\tr.Run(fmt.Sprintf(\"%s:%d\", config.IP, config.Port))\n}"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Gin-based HTTP server in Go that handles various routes including a ping endpoint, user lookup, and authenticated admin updates.\n\nFunction Description: The main function initializes a Gin web server with default middleware (Logger and Recovery), sets up route handlers for different HTTP methods, and starts the server on port 8080. It includes:\n1. A simple ping/pong endpoint\n2. A user lookup endpoint with path parameters\n3. An authenticated admin endpoint for updating values\n4. Basic authentication middleware for protected routes\n\nInput: None (The function takes no direct input parameters, but handles incoming HTTP requests)\n\nOutput: None (The function doesn't return anything, but sends HTTP responses to clients)\n\nNote: The code assumes the existence of a global DB map variable (not shown in the reference) for storing user values. The actual implementation would need to include this or an alternative storage mechanism.",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tr.GET(\"/user/:name\", func(c *gin.Context) {\n\t\tuser := c.Params.ByName(\"name\")\n\t\tvalue, ok := DB[user]\n\t\tif ok {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"value\": value})\n\t\t} else {\n\t\t\tc.JSON(200, gin.H{\"user\": user, \"status\": \"no value\"})\n\t\t}\n\t})\n\n\tauthorized := r.Group(\"/\", gin.BasicAuth(gin.Accounts{\n\t\t\"foo\":  \"bar\",\n\t\t\"manu\": \"123\",\n\t}))\n\n\tauthorized.POST(\"admin\", func(c *gin.Context) {\n\t\tuser := c.MustGet(gin.AuthUserKey).(string)\n\n\t\tvar json struct {\n\t\t\tValue string `json:\"value\" binding:\"required\"`\n\t\t}\n\n\t\tif c.Bind(&json) == nil {\n\t\t\tDB[user] = json.Value\n\t\t\tc.JSON(200, gin.H{\"status\": \"ok\"})\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nvar db = map[string]interface{}{\n\t\"admin\": map[string]interface{}{\n\t\t\"value\": \"initial_value\",\n\t},\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gin.Logger(), gin.Recovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"pong\"})\n\t})\n\n\tr.GET(\"/user/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tuser, exists := db[id]\n\t\tif exists {\n\t\t\tc.JSON(http.StatusOK, gin.H{\"user\": user})\n\t\t} else {\n\t\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"user not found\"})\n\t\t}\n\t})\n\n\tr.PUT(\"/admin/update\", func(c *gin.Context) {\n\t\tauthHeader := c.GetHeader(\"Authorization\")\n\t\tif authHeader != \"admin\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid authentication\"})\n\t\t\treturn\n\t\t}\n\n\t\tvar input struct {\n\t\t\tKey   string `json:\"key\"`\n\t\t\tValue interface{} `json:\"value\"`\n\t\t}\n\t\tif err := c.BindJSON(&input); err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid request body\"})\n\t\t\treturn\n\t\t}\n\n\t\tdb[input.Key] = input.Value\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"update successful\", \"key\": input.Key, \"value\": input.Value})\n\t})\n\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Create a simple HTTP server in Go using the Gin framework that handles file uploads via POST requests.\n\nFunction Description: The function sets up a Gin HTTP server with a single POST endpoint (\"/upload\") that receives and discards uploaded file data, then responds with \"ok\". The server runs on port 8888.\n\nInput: None (The function takes no direct input parameters, but receives HTTP POST requests with file data in the request body)\n\nOutput: None (The function doesn't return any value, but sends HTTP responses with status code 200 and body \"ok\" for successful uploads)",
    "Canonical_solution": "import (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tbody := c.Request.Body\n\t\tio.Copy(io.Discard, body)\n\t\tc.String(http.StatusOK, \"ok\")\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/upload\", func(c *gin.Context) {\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"No file uploaded\"})\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Error opening file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer src.Close()\n\n\t\t_, err = io.Copy(io.Discard, src)\n\t\tif err != nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"Error processing file\"})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"ok\"})\n\t})\n\n\tr.Run(\":8888\")\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a simple HTTP server using the Gin framework in Go that responds to ping requests with a pong message and the current Unix timestamp.\n\nFunction Description: The main function initializes a Gin HTTP server with default middleware (including Logger and Recovery), adds gzip compression middleware, registers a GET route handler for \"/ping\" that returns a plain text response, and starts the server on port 8080.\n\nInput: None (The function takes no direct input parameters. HTTP requests to the \"/ping\" endpoint serve as indirect input.)\n\nOutput: None (The function doesn't return any value directly. It sends HTTP responses to clients as output.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gin-gonic/contrib/gzip\"\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\nfunc main() {\n\tr := gin.Default()\n\tr.Use(gzip.Gzip(gzip.DefaultCompression))\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong \"+fmt.Sprint(time.Now().Unix()))\n\t})\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "right_result": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"time\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Add gzip compression middleware\n\tr.Use(gin.Gzip())\n\n\t// Define the \"/ping\" route\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong %d\\n\", time.Now().Unix())\n\t})\n\n\t// Start the server on port 8080\n\tr.Run(\":8080\")\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Create a TCP client in Go that establishes a connection to a server, sends a message, and handles the connection lifecycle properly.\n\nFunction Description: The function establishes a TCP connection to a specified server address, sends a predefined message (\"hello\"), and prints the number of bytes written or any error encountered. It ensures the connection is properly closed after use.\n\nInput: None (The server address is hardcoded as \"127.0.0.1:49153\" in this example)\n\nOutput: \n- On success: Prints the number of bytes written to the connection (integer)\n- On failure: Prints the error encountered during connection or writing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n)\n\nfunc main() {\n\tdialer := &net.Dialer{\n\t\tLocalAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\t\tPort: 0,\n\t\t},\n\t}\n\n\tconn, err := dialer.Dial(\"tcp\", \"127.0.0.1:49153\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tt := &wrappedConn{conn}\n\tvar w io.Writer = t\n\tif n, err := w.Write([]byte(\"hello\")); err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(n)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Define the server address\n\tserverAddr := \"127.0.0.1:49153\"\n\n\t// Establish a TCP connection\n\tconn, err := net.Dial(\"tcp\", serverAddr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error connecting to server: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\t// Predefined message to send\n\tmessage := \"hello\"\n\n\t// Send the message\n\tbytesSent, err := conn.Write([]byte(message))\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error writing to connection: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Print the number of bytes written\n\tfmt.Printf(\"Bytes sent: %d\\n\", bytesSent)\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Implement a TCP client function in Go that establishes a connection to a server, sends data, and receives a response.\n\nFunction Description: The function `Tcp` handles TCP communication with a remote server. It establishes a connection, sends optional data, and reads the server's response. Errors are captured and returned in the response structure. The connection is automatically closed when the function completes.\n\nInput: \n- `ctx context.Context`: Context for managing deadlines and cancellation signals\n- `req *pb.TcpRequest`: Request object containing:\n  - `Address string`: The server address to connect to (format \"host:port\")\n  - `Data string`: Optional data to send to the server\n- `rsp *pb.TcpResponse`: Response object to populate with results\n\nOutput:\n- `error`: Returns an error if address validation fails, otherwise nil (errors during TCP operations are stored in the response)\n- Modifies `rsp` with:\n  - `Status string`: \"OK\" on success or error message\n  - `Data string`: Received data from server (if any)",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\tpb \"github.com/micro/services/ping/proto\"\n)\n\nfunc (p *Ping) Tcp(ctx context.Context, req *pb.TcpRequest, rsp *pb.TcpResponse) error {\n\tif len(req.Address) == 0 {\n\t\treturn errors.BadRequest(\"ping.tcp\", \"missing address\")\n\t}\n\n\tc, err := net.Dial(\"tcp\", req.Address)\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\tdefer c.Close()\n\n\tif len(req.Data) == 0 {\n\t\trsp.Status = \"OK\"\n\t\treturn nil\n\t}\n\n\tfmt.Fprint(c, req.Data)\n\n\tdata, err := bufio.NewReader(c).ReadString('\\n')\n\tif err != nil {\n\t\trsp.Status = err.Error()\n\t\treturn nil\n\t}\n\n\trsp.Status = \"OK\"\n\trsp.Data = data\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype TcpRequest struct {\n\tAddress string\n\tData    string\n}\n\ntype TcpResponse struct {\n\tStatus string\n\tData   string\n}\n\nfunc Tcp(ctx context.Context, req *TcpRequest, rsp *TcpResponse) error {\n\tif req.Address == \"\" {\n\t\treturn fmt.Errorf(\"address is required\")\n\t}\n\n\t// Parse address\n\tparts := strings.Split(req.Address, \":\")\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"invalid address format: %s\", req.Address)\n\t}\n\n\thost, port := parts[0], parts[1]\n\tif host == \"\" || port == \"\" {\n\t\treturn fmt.Errorf(\"invalid address format: %s\", req.Address)\n\t}\n\n\t// Set timeout based on context\n\ttimeout := time.Duration(10) * time.Second\n\tif deadline, ok := ctx.Deadline(); ok {\n\t\ttimeout = time.Until(deadline)\n\t\tif timeout < 0 {\n\t\t\ttimeout = 0\n\t\t}\n\t}\n\n\tconn, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:%s\", host, port), timeout)\n\tif err != nil {\n\t\trsp.Status = \"ERROR\"\n\t\trsp.Data = err.Error()\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Send data\n\tif req.Data != \"\" {\n\t\t_, err = conn.Write([]byte(req.Data))\n\t\tif err != nil {\n\t\t\trsp.Status = \"ERROR\"\n\t\t\trsp.Data = err.Error()\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Read response\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err == io.EOF {\n\t\trsp.Status = \"OK\"\n\t\trsp.Data = string(buffer[:n])\n\t\treturn nil\n\t}\n\n\tif err != nil {\n\t\trsp.Status = \"ERROR\"\n\t\trsp.Data = err.Error()\n\t\treturn err\n\t}\n\n\trsp.Status = \"OK\"\n\trsp.Data = string(buffer[:n])\n\treturn nil\n}"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, reads all data from the connection, and returns the data as a string.\n\nFunction Description: The function connects to a TCP server at the specified address, reads all available data from the connection, closes the connection, and returns the received data as a string. If the connection fails, it should panic with the error.\n\nInput: \n- address (string): The server address in the format \"host:port\" (e.g., \"localhost:9000\")\n\nOutput: \n- string: The data received from the server\n- error: Returns an error if the connection or read operation fails (though in the reference code it panics on connection error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\tbs, _ := ioutil.ReadAll(conn)\n\tfmt.Println(string(bs))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc connectToServer(address string) string {\n\thostPort := strings.Split(address, \":\")\n\thost := hostPort[0]\n\tport := hostPort[1]\n\n\tconn, err := net.Dial(\"tcp\", address)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(conn)\n\tdata, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn data\n}"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It holds configuration information and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Pointer to configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC server for the specified realm using TCP. Returns the response or error.\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful. Returns the response or accumulated errors.\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a KDC server, including sending data and reading response. Ensures connection is closed when done.",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype Config struct {\n\tKDCs      []string\n\tTimeout   int\n\tMaxRetries int\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tkdcs := c.Config.KDCs\n\tfor i, kdc := range kdcs {\n\t\tconn, err := net.Dial(\"tcp\", kdc)\n\t\tif err != nil {\n\t\t\tif c.Config.MaxRetries > i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer conn.Close()\n\t\tresp, err := c.sendTCP(conn, b)\n\t\tif err != nil {\n\t\t\tif c.Config.MaxRetries > i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\treturn resp, nil\n\t}\n\treturn nil, errors.New(\"all KDCs failed\")\n}\n\nfunc (c *Client) dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tfor i, kdc := range kdcs {\n\t\tconn, err := net.Dial(\"tcp\", kdc)\n\t\tif err != nil {\n\t\t\tif c.Config.MaxRetries > i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer conn.Close()\n\t\tresp, err := c.sendTCP(conn, b)\n\t\tif err != nil {\n\t\t\tif c.Config.MaxRetries > i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\treturn resp, nil\n\t}\n\treturn nil, errors.New(\"all KDCs failed\")\n}\n\nfunc (c *Client) sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treader := bufio.NewReader(conn)\n\tresponse, _ := reader.ReadString('\\n')\n\treturn []byte(response), nil\n}"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Implement a Go struct that handles DNS queries over UDP with context support and deadline management.\n\nStruct Description: DNSEndpoint represents a DNS server endpoint capable of performing DNS queries with context support, deadline management, and transaction ID matching.\n\nFields:\nAddr: string - The address of the DNS server in \"host:port\" format\n\nMethods:\nExchange: (ctx context.Context, payload, buf []byte) -> (n int, err error) - Performs a DNS query exchange:\n  - Establishes a UDP connection to the server\n  - Sets deadline from context if available\n  - Generates random transaction ID\n  - Sends DNS query payload\n  - Reads response and validates transaction ID\n  - Returns number of bytes read or any error\n  - Automatically closes connection when done",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n)\n\ntype DNSEndpoint struct {\n\tAddr string\n}\n\nfunc (e *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (n int, err error) {\n\td := &net.Dialer{}\n\tc, err := d.DialContext(ctx, \"udp\", e.Addr)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"dial: %v\", err)\n\t}\n\tdefer c.Close()\n\tif t, ok := ctx.Deadline(); ok {\n\t\t_ = c.SetDeadline(t)\n\t}\n\tif _, err := rand.Read(payload[:2]); err != nil {\n\t\treturn 0, err\n\t}\n\t_, err = c.Write(payload)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"write: %v\", err)\n\t}\n\tid := uint16(payload[0])<<8 | uint16(buf[1])\n\tfor {\n\t\tif n, err = c.Read(buf[:514]); err != nil {\n\t\t\treturn n, fmt.Errorf(\"read: %v\", err)\n\t\t}\n\t\tif n < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif id != uint16(buf[0])<<8|uint16(buf[1]) {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype DNSEndpoint struct {\n\tAddr string\n}\n\nfunc (d *DNSEndpoint) Exchange(ctx context.Context, payload, buf []byte) (n int, err error) {\n\t// Parse address\n\taddr := net.JoinHostPort(d.Addr, \"53\")\n\tconn, err := net.DialUDP(\"udp\", nil, &net.URI{Scheme: \"udp\", Host: addr})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer conn.Close()\n\n\t// Set deadline from context if available\n\tif deadline, ok := ctx.Deadline(); ok {\n\t\tconn.SetDeadline(time.Now().Add(deadline))\n\t}\n\n\t// Generate random transaction ID\n\tvar txID [2]byte\n\tif _, err = rand.Read(txID[:]); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Send query\n\t_, err = conn.Write(payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Read response\n\tn, err = conn.Read(buf)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Validate transaction ID\n\tif binary.BigEndian.Uint16(buf[0:2]) != binary.BigEndian.Uint16(txID[:]) {\n\t\treturn 0, fmt.Errorf(\"transaction ID mismatch\")\n\t}\n\n\treturn n, nil\n}"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Implement a TCP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and retry logic for multiple KDC addresses.\n\nStruct Description: The Client struct represents a TCP client for communicating with KDC servers. It maintains configuration and provides methods for sending data to KDCs.\n\nFields:\nConfig: [*Config] - Configuration containing KDC addresses and other settings\n\nMethods:\nsendKDCTCP: [sendKDCTCP(realm string, b []byte)] -> ([]byte, error) - Sends data to a KDC for the specified realm, handling multiple KDC addresses and error cases\ndialSendTCP: [dialSendTCP(kdcs map[int]string, b []byte)] -> ([]byte, error) - Attempts to connect to each KDC address in sequence until successful\nsendTCP: [sendTCP(conn *net.TCPConn, b []byte)] -> ([]byte, error) - Handles the actual TCP communication with a single KDC connection",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\t_, kdcs, err := cl.Config.GetKDCs(realm, true)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = dialSendTCP(kdcs, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialSendTCP(kdcs map[int]string, b []byte) ([]byte, error) {\n\tvar errs []string\n\tfor i := 1; i <= len(kdcs); i++ {\n\t\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", kdcs[i])\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error resolving KDC address: %v\", err))\n\t\t\tcontinue\n\t\t}\n\n\t\tconn, err := net.DialTimeout(\"tcp\", tcpAddr.String(), 5*time.Second)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting dial timeout on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\tif err := conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error setting deadline on connection to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\trb, err := sendTCP(conn.(*net.TCPConn), b)\n\t\tif err != nil {\n\t\t\terrs = append(errs, fmt.Sprintf(\"error sneding to %s: %v\", kdcs[i], err))\n\t\t\tcontinue\n\t\t}\n\t\treturn rb, nil\n\t}\n\treturn nil, fmt.Errorf(\"error sending to a KDC: %s\", strings.Join(errs, \"; \"))\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\tdefer conn.Close()\n\tvar r []byte\n\thb := make([]byte, 4, 4)\n\tbinary.BigEndian.PutUint32(hb, uint32(len(b)))\n\tb = append(hb, b...)\n\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to KDC (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\n\tsh := make([]byte, 4, 4)\n\t_, err = conn.Read(sh)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response size header: %v\", err)\n\t}\n\ts := binary.BigEndian.Uint32(sh)\n\n\trb := make([]byte, s, s)\n\t_, err = io.ReadFull(conn, rb)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error reading response: %v\", err)\n\t}\n\tif len(rb) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from KDC %s\", conn.RemoteAddr().String())\n\t}\n\treturn rb, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype Config struct {\n\tKDCs      []string\n\tTimeout   int\n\tMaxRetries int\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCTCP(realm string, b []byte) ([]byte, error) {\n\tkdcs := strings.Split(c.Config.KDCs, \",\")\n\tfor i := 0; i < c.Config.MaxRetries; i++ {\n\t\tfor _, kdc := range kdcs {\n\t\t\tconn, err := net.Dial(\"tcp\", kdc)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer conn.Close()\n\t\t\tif err = sendTCP(conn, b); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn b, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"failed to send data to any KDC after %d retries\", c.Config.MaxRetries)\n}\n\nfunc sendTCP(conn *net.TCPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treader := bufio.NewReader(conn)\n\tresponse, _ := reader.ReadString('\\n')\n\treturn response, nil\n}"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and applies specific traffic class and hop limit settings if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely until terminated.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tflag.Parse()\n\taddr := \":1024\"\n\tln, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error listening: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer ln.Close()\n\tfmt.Println(\"Server is listening on\", addr)\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error accepting: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\t// Check if the connection is IPv6\n\tremoteAddr := conn.RemoteAddr().String()\n\tif remoteAddr == \"::1\" || remoteAddr == \"[::1]\" {\n\t\t// Set traffic class and hop limit for IPv6\n\t\ttcpConn, ok := conn.(*net.TCPConn)\n\t\tif ok {\n\t\t\ttcpConn.SetTrafficClass(0x20) // Traffic class 32 (binary 00100000)\n\t\t\ttcpConn.SetHopLimit(64)\n\t\t}\n\t}\n\t// Send acknowledgment message\n\t_, err := conn.Write([]byte(\"HELLO-R-U-THERE-ACK\"))\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error writing to client: %v\\n\", err)\n\t\treturn\n\t}\n\ttime.Sleep(time.Second)\n}"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle incoming client connections, optionally with TLS encryption, and relay traffic between clients and target servers through a proxy.\n\nStruct Description: The Trojan struct represents a TCP server that listens for incoming connections, handles TLS encryption if configured, and relays traffic between clients and target servers via a proxy.\n\nFields:\n- addr: string - The address on which the server listens for incoming connections\n- withTLS: bool - Flag indicating whether TLS encryption should be used\n- tlsConfig: *tls.Config - TLS configuration for secure connections\n- certFile: string - Path to TLS certificate file\n- keyFile: string - Path to TLS private key file\n- pass: [56]byte - Password for authentication\n- fallback: string - Fallback address if connection fails\n- proxy: proxy.Proxy - Proxy implementation for relaying traffic\n\nMethods:\n- ListenAndServe() - Starts the TCP server, listens for incoming connections, and handles them in separate goroutines\n  Input: None\n  Output: None\n- Serve(c net.Conn) - Handles an individual client connection, performs TLS handshake if needed, and relays traffic\n  Input: c net.Conn - The client connection to handle\n  Output: None\n- readHeader(r io.Reader) - Reads and parses the header from the client connection\n  Input: r io.Reader - Reader to get header data from\n  Output: cmd socks.Cmd, target socks.Addr, err error - Returns command, target address, and any error\n- serveFallback(c net.Conn, fallback string, buf *bytes.Buffer) - Handles fallback connection when main connection fails\n  Input: \n    c net.Conn - The client connection\n    fallback string - Fallback address\n    buf *bytes.Buffer - Buffer containing initial data\n  Output: None\n- ServeUoT(c net.Conn, target socks.Addr) - Handles UDP-over-TCP connections\n  Input:\n    c net.Conn - The client connection\n    target socks.Addr - Target address\n  Output: None",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/pkg/socks\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\ntype Trojan struct {\n\taddr      string\n\twithTLS   bool\n\ttlsConfig *tls.Config\n\tcertFile  string\n\tkeyFile   string\n\tpass      [56]byte\n\tfallback  string\n\tproxy     proxy.Proxy\n}\n\nfunc (s *Trojan) ListenAndServe() {\n\tl, err := net.Listen(\"tcp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[trojan] failed to listen on %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tlog.F(\"[trojan] listening TCP on %s, with TLS: %v\", s.addr, s.withTLS)\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.F(\"[trojan] failed to accept: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo s.Serve(c)\n\t}\n}\n\nfunc (s *Trojan) Serve(c net.Conn) {\n\tif c, ok := c.(*net.TCPConn); ok {\n\t\tc.SetKeepAlive(true)\n\t}\n\n\tif s.withTLS {\n\t\ttlsConn := tls.Server(c, s.tlsConfig)\n\t\tif err := tlsConn.Handshake(); err != nil {\n\t\t\ttlsConn.Close()\n\t\t\tlog.F(\"[trojan] error in tls handshake: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tc = tlsConn\n\t}\n\tdefer c.Close()\n\n\theadBuf := pool.GetBytesBuffer()\n\tdefer pool.PutBytesBuffer(headBuf)\n\n\tcmd, target, err := s.readHeader(io.TeeReader(c, headBuf))\n\tif err != nil {\n\t\tif s.fallback != \"\" {\n\t\t\ts.serveFallback(c, s.fallback, headBuf)\n\t\t}\n\t\treturn\n\t}\n\n\tnetwork := \"tcp\"\n\tdialer := s.proxy.NextDialer(target.String())\n\n\tif cmd == socks.CmdUDPAssociate {\n\t\tif dialer.Addr() == \"DIRECT\" {\n\t\t\ts.ServeUoT(c, target)\n\t\t\treturn\n\t\t}\n\t\tnetwork = \"udp\"\n\t}\n\n\trc, err := dialer.Dial(network, target.String())\n\tif err != nil {\n\t\tlog.F(\"[trojan] %s <-> %s via %s, error in dial: %v\", c.RemoteAddr(), target, dialer.Addr(), err)\n\t\treturn\n\t}\n\tdefer rc.Close()\n\n\tlog.F(\"[trojan] %s <-> %s via %s\", c.RemoteAddr(), target, dialer.Addr())\n\n\tif err = proxy.Relay(c, rc); err != nil {\n\t\tlog.F(\"[trojan] %s <-> %s via %s, relay error: %v\", c.RemoteAddr(), target, dialer.Addr(), err)\n\t\tif !strings.Contains(err.Error(), s.addr) {\n\t\t\ts.proxy.Record(dialer, false)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/yourusername/proxy\"\n\t\"github.com/yourusername/socks\"\n)\n\ntype Trojan struct {\n\taddr      string\n\twithTLS   bool\n\ttlsConfig *tls.Config\n\tcertFile  string\n\tkeyFile   string\n\tpass      [56]byte\n\tfallback  string\n\tproxy     proxy.Proxy\n}\n\nfunc (t *Trojan) ListenAndServe() {\n\tif t.withTLS {\n\t\tl, err := tls.Listen(\"tcp\", t.addr, t.tlsConfig)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer l.Close()\n\t\tfor {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo t.Serve(conn)\n\t\t}\n\t} else {\n\t\tl, err := net.Listen(\"tcp\", t.addr)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer l.Close()\n\t\tfor {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo t.Serve(conn)\n\t\t}\n\t}\n}\n\nfunc (t *Trojan) Serve(c net.Conn) {\n\tif t.withTLS {\n\t\tif _, ok := c.(*tls.Conn); !ok {\n\t\t\ttlsConn := &tls.Conn{Conn: c, Config: t.tlsConfig}\n\t\t\tc = tlsConn\n\t\t}\n\t}\n\t\n\tbuf := bytes.NewBuffer([]byte{})\n\t_, err := buf.ReadFrom(c)\n\tif err != nil {\n\t\tc.Close()\n\t\treturn\n\t}\n\t\n\tcmd, target, err := t.readHeader(buf)\n\tif err != nil {\n\t\tc.Close()\n\t\treturn\n\t}\n\t\n\tif cmd == socks.CmdUDP {\n\t\tt.ServeUoT(c, target)\n\t\treturn\n\t}\n\t\n\tif t.proxy != nil {\n\t\tt.proxy.Serve(c, target)\n\t\treturn\n\t}\n\t\n\tif t.fallback != \"\" {\n\t\tt.serveFallback(c, t.fallback, buf)\n\t\treturn\n\t}\n\t\n\ttargetAddr := net.JoinHostPort(target.Host, target.Port)\n\ttargetConn, err := net.Dial(\"tcp\", targetAddr)\n\tif err != nil {\n\t\tc.Close()\n\t\treturn\n\t}\n\t\n\tgo func() {\n\t\t_, _ = buf.ReadFrom(c)\n\t\t_, _ = c.Write(buf.Bytes())\n\t}()\n\t\n\t_, _ = c.Write(buf.Bytes())\n\t_, _ = targetConn.ReadFrom(c)\n\t_, _ = c.Write(targetConn.Bytes())\n}\n\nfunc (t *Trojan) readHeader(r io.Reader) (cmd socks.Cmd, target socks.Addr, err error) {\n\tbuf := make([]byte, 1024)\n\tn, err := r.Read(buf)\n\tif err != nil {\n\t\treturn\n\t}\n\t\n\tif n < 2 {\n\t\treturn\n\t}\n\t\n\tcmd = socks.Cmd(buf[0])\n\ttarget = socks.Addr{}\n\t\n\tif cmd == socks.CmdTCP {\n\t\ttarget.Host = string(buf[1 : 1+net.IPv4len])\n\t\ttarget.Port = int(buf[1+net.IPv4len])\n\t} else if cmd == socks.CmdUDP {\n\t\ttarget.Host = string(buf[1 : 1+net.IPv4len])\n\t\ttarget.Port = int(buf[1+net.IPv4len])\n\t}\n\t\n\treturn\n}\n\nfunc (t *Trojan) serveFallback(c net.Conn, fallback string, buf *bytes.Buffer) {\n\ttargetAddr := net.JoinHostPort(fallback, \"80\")\n\ttargetConn, err := net.Dial(\"tcp\", targetAddr)\n\tif err != nil {\n\t\tc.Close()\n\t\treturn\n\t}\n\t\n\tgo func() {\n\t\t_, _ = buf.ReadFrom(c)\n\t\t_, _ = c.Write(buf.Bytes())\n\t}()\n\t\n\t_, _ = c.Write(buf.Bytes())\n\t_, _ = targetConn.ReadFrom(c)\n\t_, _ = c.Write(targetConn.Bytes())\n}\n\nfunc (t *Trojan) ServeUoT(c net.Conn, target socks.Addr) {\n\ttargetAddr := net.JoinHostPort(target.Host, target.Port)\n\ttargetConn, err := net.Dial(\"tcp\", targetAddr)\n\tif err != nil {\n\t\tc.Close()\n\t\treturn\n\t}\n\t\n\t_, _ = c.Write([]byte{})\n\t_, _ = targetConn.ReadFrom(c)\n\t_, _ = c.Write(targetConn.Bytes())\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a TCP echo server in Go that listens for incoming connections on a specified port, reads data from clients, and echoes the same data back to them.\n\nFunction Description: The function implements a simple TCP server that continuously accepts client connections, reads data from each connection, and writes the same data back (echo). It handles network errors appropriately and ensures resources are cleaned up.\n\nInput: None (The port number is hardcoded as \":9000\" in the implementation)\n\nOutput: None (The function runs indefinitely until interrupted, with all output being network communication with clients)",
    "Canonical_solution": "import \"net\"\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfor {\n\t\t\tbs := make([]byte, 1024)\n\t\t\tn, err := conn.Read(bs)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t_, err = conn.Write(bs[:n])\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Start a TCP listener on port 9000\n\tlistener, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\tfmt.Println(\"Server is listening on port 9000...\")\n\n\tfor {\n\t\t// Accept incoming connection\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\t// Read data from the client\n\t\tdata, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == net.ErrClosed {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Println(\"Error reading from client:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Echo the data back to the client\n\t\t_, err = conn.Write([]byte(data))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to client:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets IP TOS (Type of Service) and TTL (Time To Live) values for IPv4 connections, and sends a greeting message to the client.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For each IPv4 connection, it configures the TOS and TTL values using the ipv4 package. It then sends a greeting message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to \"0.0.0.0:1024\" by default)\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving connections)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {\n\t\t\t\tp := ipv4.NewConn(c)\n\t\t\t\tif err := p.SetTOS(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetTTL(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tflag.Parse()\n\taddr := flag.Arg(0)\n\tif addr == \"\" {\n\t\taddr = \"0.0.0.0:1024\"\n\t}\n\n\tln, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error listening: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error accepting: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Set TOS and TTL for IPv4\n\ttcpConn, ok := conn.(*net.TCPConn)\n\tif !ok {\n\t\treturn\n\t}\n\n\t// Set TOS (Type of Service) - Example: 0x10 (Internet Control Message Protocol)\n\ttos := syscall.IPTOS_LOWDELAY\n\ttcpConn.SetTOS(tos)\n\n\t// Set TTL (Time To Live) - Example: 64\n\tttl := 64\n\ttcpConn.SetTTL(ttl)\n\n\t// Send greeting message\n\tmsg := []byte(\"HELLO-R-U-THERE-ACK\")\n\t_, err := tcpConn.Write(msg)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error writing: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Wait a bit before closing to allow client to receive the message\n\ttime.Sleep(100 * time.Millisecond)\n}"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets specific IPv6 traffic class and hop limit for IPv6 connections, and sends an acknowledgment message to each client.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and configures specific network parameters (traffic class and hop limit) if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. Each client connection is handled in a separate goroutine.\n\nInput: None (The function takes no explicit parameters but binds to port 1024 by default)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations and may log fatal errors)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tport := flag.Int(\"port\", 1024, \"Port to listen on\")\n\tflag.Parse()\n\n\tif *port < 1 || *port > 65535 {\n\t\tfmt.Fprintf(os.Stderr, \"Error: Port must be between 1 and 65535\\n\")\n\t\tos.Exit(1)\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error listening: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfmt.Printf(\"Server listening on port %d\\n\", *port)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error accepting connection: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Check if the connection is IPv6\n\tremoteAddr := conn.RemoteAddr().String()\n\tif strings.HasPrefix(remoteAddr, \"[\") && strings.HasSuffix(remoteAddr, \"]\") {\n\t\t// Extract the IPv6 address without the brackets\n\t\tipStr := remoteAddr[1 : len(remoteAddr)-1]\n\t\tip := net.ParseIP(ipStr)\n\t\tif ip == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Invalid IPv6 address: %s\\n\", ipStr)\n\t\t\treturn\n\t\t}\n\n\t\t// Set traffic class and hop limit for IPv6\n\t\tipv6Conn, ok := conn.(*net.UnixConn)\n\t\tif !ok {\n\t\t\tfmt.Fprintf(os.Stderr, \"Cannot cast connection to *net.UnixConn\\n\")\n\t\t\treturn\n\t\t}\n\n\t\t// Set traffic class (0x20) and hop limit (64)\n\t\tif err := ipv6Conn.SetControlMessage(net.FlagIPv6HopLimit, true); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error setting control message: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the current hop limit\n\t\tvar hopLimit uint8\n\t\tif err := ipv6Conn.GetControlMessage(net.FlagIPv6HopLimit, true, &hopLimit); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error getting hop limit: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the hop limit to 64\n\t\tif err := ipv6Conn.SetControlMessage(net.FlagIPv6HopLimit, true, &hopLimit); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error setting hop limit: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set traffic class to 0x20 (32 in decimal)\n\t\tif err := ipv6Conn.SetControlMessage(net.FlagIPv6TrafficClass, true, &hopLimit); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error setting traffic class: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the current traffic class\n\t\tvar trafficClass uint8\n\t\tif err := ipv6Conn.GetControlMessage(net.FlagIPv6TrafficClass, true, &trafficClass); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error getting traffic class: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set the traffic class to 0x20 (32 in decimal)\n\t\tif err := ipv6Conn.SetControlMessage(net.FlagIPv6TrafficClass, true, &trafficClass); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error setting traffic class: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Send acknowledgment message\n\tackMessage := \"HELLO-R-U-THERE-ACK\"\n\tif _, err := conn.Write([]byte(ackMessage)); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error sending acknowledgment: %v\\n\", err)\n\t}\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Implement a gRPC client in Go that establishes a secure connection to a gRPC server with authentication, sends a request, and processes the response.\n\nFunction Description: The function `doClientWork` demonstrates how to create a gRPC client that connects to a server, authenticates using provided credentials, sends a \"Hello\" request, and logs the response. It handles connection setup, authentication, RPC call execution, and connection cleanup.\n\nInput: None (The function uses hardcoded values for demonstration purposes, but these could be parameterized in a real implementation)\n\nOutput: None (The function logs results to stdout but doesn't return any values)\n\n---\n\nTask Description: Implement an authentication struct for gRPC credentials in Go that provides request metadata and specifies transport security requirements.\n\nStruct Description: The `Authentication` struct implements gRPC's `credentials.PerRPCCredentials` interface to provide per-RPC credentials (login/password) for gRPC requests.\n\nFields:\nLogin: string - The username for authentication\nPassword: string - The password for authentication\n\nMethods:\nGetRequestMetadata: (context.Context, ...string) -> (map[string]string, error) - Returns the authentication metadata (login/password) to be included in RPC requests\nRequireTransportSecurity: () -> bool - Indicates whether transport security is required (returns false in this implementation)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Authentication struct {\n\tLogin    string\n\tPassword string\n}\n\nfunc (a *Authentication) GetRequestMetadata(context.Context, ...string) (map[string]string, error) {\n\treturn map[string]string{\"login\": a.Login, \"password\": a.Password}, nil\n}\nfunc (a *Authentication) RequireTransportSecurity() bool {\n\treturn false\n}\n\nfunc doClientWork() {\n\tauth := Authentication{\n\t\tLogin:    \"gopher\",\n\t\tPassword: \"password\",\n\t}\n\n\tconn, err := grpc.Dial(\"localhost\"+port, grpc.WithInsecure(), grpc.WithPerRPCCredentials(&auth))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tc := NewGreeterClient(conn)\n\n\tr, err := c.SayHello(context.Background(), &HelloRequest{Name: \"gopher\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"doClientWork: %s\", r.Message)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/test/benchmarks/echo\"\n)\n\ntype Authentication struct {\n\tlogin    string\n\tpassword string\n}\n\nfunc (a *Authentication) GetRequestMetadata(ctx context.Context, args ...string) (map[string]string, error) {\n\tmd := metadata.Pairs(\"authorization\", fmt.Sprintf(\"Basic %s\", a.login+a.password))\n\treturn md, nil\n}\n\nfunc (a *Authentication) RequireTransportSecurity() bool {\n\treturn false\n}\n\nfunc doClientWork() {\n\tcreds := credentials.NewClientTLSFromCert([]byte(\"-----BEGIN CERTIFICATE-----\\nMIIEowIBAAKCAQEAt4q3XW1hVb6R07tBkYJGzU9QxjE5ZfHcZ2dS1L8FgT9p\\n-----END CERTIFICATE-----\"), \"example.com\")\n\topts := []grpc.DialOption{\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithPerRPCCredentials(&Authentication{\"user\", \"pass\"}),\n\t}\n\n\tconn, err := grpc.Dial(\"localhost:50051\", opts...)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to dial: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := echo.NewEchoClient(conn)\n\tctx := context.Background()\n\tresp, err := client.SayHello(ctx, &echo.HelloRequest{})\n\tif err != nil {\n\t\tfmt.Printf(\"Error calling SayHello: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Response: %s\\n\", resp.Message)\n}"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Implement a gRPC client function in Go that establishes a bidirectional streaming connection with a gRPC server, sends a chat message, and continuously receives responses from the server until the connection is closed.\n\nFunction Description: The function `Test` is a test function that demonstrates bidirectional streaming gRPC communication. It connects to a gRPC server, sends a chat message, and asynchronously receives responses from the server. The function handles connection errors, stream creation errors, and different types of response errors (including EOF when the server closes the connection).\n\nInput: None (The function is a test function with no explicit input parameters, but it connects to a predefined server address \"127.0.0.1:8089\")\n\nOutput: None (The function doesn't return any value but prints received messages and errors to stdout)\n\nNote: The function uses a deferred connection closure and runs the send operation in a separate goroutine to allow simultaneous sending and receiving. The main loop continues receiving until an EOF error or other fatal error occurs.",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"io\"\n\t\"log\"\n\t\"testing\"\n\n\t\"learning_tools/grpc/bidirectional_streaming_rpc/proto\"\n)\nfunc Test(t *testing.T) {\n\tconn, err := grpc.Dial(\"127.0.0.1:8089\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tdefer conn.Close()\n\tclient := proto.NewChatServiceClient(conn)\n\tctx := context.Background()\n\tstream, err := client.Chat(ctx)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tgo func() {\n\t\tif err := stream.Send(&proto.Request{Input: \"\u804a\u5929\"}); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\n\tfor {\n\t\tresponse, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tfmt.Println(\"\u670d\u52a1\u7aef\u7ed3\u675f\u901a\u77e5:\", err.Error())\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tfmt.Println(\"\u63a5\u53d7\u6570\u636e\u9519\u8bef:\", err.Error())\n\t\t}\n\t\tfmt.Println(\"\u670d\u52a1\u7aef\u8fd4\u56de:\", response.Output)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype ChatServiceClient struct {\n\tchatServiceClient ChatServiceClient\n}\n\nfunc (c *ChatServiceClient) SendChatMessage() {\n\tconn, err := grpc.Dial(\"127.0.0.1:8089\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewChatServiceClient(conn)\n\tstream, err := client.ChatStream(context.Background())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create stream: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\tmsg, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tfmt.Println(\"Server closed the connection.\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Fatalf(\"Error receiving message: %v\", err)\n\t\t\t}\n\t\t\tfmt.Printf(\"Received: %s\\n\", msg.Message)\n\t\t}\n\t}()\n\n\tmessage := \"Hello, server!\"\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\terr = stream.Send(&ChatMessage{Message: fmt.Sprintf(\"Message %d from client\", i)})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error sending message: %v\", err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Create a gRPC client in Go that communicates with a Unix domain socket server for various deployment operations.\n\nStruct Description: The DeployClient struct represents a gRPC client that connects to a deployment agent server via Unix domain socket and provides methods for different deployment operations.\n\nFields:\nsocketPath: string - The filesystem path to the Unix domain socket for connecting to the gRPC server\n\nMethods:\nNewDeployClient: [Name](socketPath string) -> *DeployClient - Creates a new DeployClient instance with the specified socket path\nDeployGuestFs: [Name](ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) -> (*deployapi.DeployGuestFsResponse, error) - Deploys guest filesystem\nResizeFs: [Name](ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Resizes filesystem\nFormatFs: [Name](ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Formats filesystem\nSaveToGlance: [Name](ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) -> (*deployapi.SaveToGlanceResponse, error) - Saves image to Glance\nProbeImageInfo: [Name](ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) -> (*deployapi.ImageInfo, error) - Probes image information\nConnectEsxiDisks: [Name](ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) -> (*deployapi.EsxiDisksConnectionInfo, error) - Connects ESXi disks\nDisconnectEsxiDisks: [Name](ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Disconnects ESXi disks",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdeployapi \"yunion.io/x/onecloud/pkg/hostman/hostdeployer/apis\"\n)\n\ntype DeployClient struct {\n\tsocketPath string\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\treturn &DeployClient{socketPath}\n}\n\nfunc grcpDialWithUnixSocket(ctx context.Context, socketPath string) (*grpc.ClientConn, error) {\n\treturn grpc.DialContext(ctx, socketPath, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(time.Second*3),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\tret, err := client.DeployGuestFs(ctx, in, opts...)\n\treturn ret, err\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(\n\tctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption,\n) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(\n\tctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption,\n) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.DisconnectEsxiDisks(ctx, in, opts...)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "right_result": "package deployclient\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"path/filepath\"\n\t\"deployapi\"\n)\n\ntype DeployClient struct {\n\tclient deployapi.DeployServiceClient\n\tsocket string\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\treturn &DeployClient{\n\t\tsocket: socketPath,\n\t}\n}\n\nfunc (c *DeployClient) connect() (*grpc.ClientConn, error) {\n\t// Check if the socket exists\n\tif _, err := os.Stat(c.socket); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"socket file does not exist: %s\", c.socket)\n\t}\n\n\t// Create a GRPC connection to the Unix domain socket\n\tconn, err := grpc.Dial(c.socket, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a client for the DeployService\n\tclient := deployapi.NewDeployServiceClient(conn)\n\treturn conn, nil\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.DeployGuestFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := c.connect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tc.client = deployapi.NewDeployServiceClient(conn)\n\treturn c.client.DisconnectEsxiDisks(ctx, in, opts...)\n}"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Create a Go function that establishes a secure gRPC client connection to a server, performs a math operation (addition) using the gRPC service, and returns the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:8092 using TLS credentials from a specified certificate file. It creates a client for the MathService, sends a request with two integer arguments, and returns the server's response containing the result of the addition operation.\n\nInput: \n- None (all configuration is hardcoded in the function)\n\nOutput:\n- Prints the response code and message from the gRPC server to stdout\n- Returns nothing (void function)\n\nNote: The function handles connection establishment, service client creation, request sending, and connection cleanup automatically. Error conditions will cause the function to panic.",
    "Canonical_solution": "import (\n\t\"google.golang.org/grpc\"\n\t\"grpcSSLCode/message\"\n\t\"context\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"fmt\"\n\t\"google.golang.org/grpc/credentials\"\n)\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile(\"./keys/server.pem\", \"go-grpc-example\")\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tgrpc.WithInsecure()\n\n\tconn, err := grpc.Dial(\"localhost:8092\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tdefer conn.Close()\n\n\tserviceClient := message.NewMathServiceClient(conn)\n\n\taddArgs := message.RequestArgs{Args1: 3, Args2: 5}\n\n\tresponse, err := serviceClient.AddMethod(context.Background(), &addArgs)\n\tif err != nil {\n\t\tgrpclog.Fatal(err.Error())\n\t}\n\n\tfmt.Println(response.GetCode(), response.GetMessage())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n\t\"mathservice\"\n)\n\nfunc main() {\n\t// TLS credentials from certificate file\n\tcreds, err := credentials.NewClientTLSFromCertFile(\"server.crt\", \"server.key\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create a gRPC connection to the server\n\tconn, err := grpc.Dial(\"localhost:8092\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client for the MathService\n\tclient := mathservice.NewMathServiceClient(conn)\n\n\t// Send a request with two integer arguments\n\trequest := &mathservice.AddRequest{\n\t\tNum1: 10,\n\t\tNum2: 20,\n\t}\n\n\t// Call the Add method\n\tresponse, err := client.Add(context.Background(), request)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Print the response code and message\n\tfmt.Printf(\"Response code: %d, Message: %s\\n\", response.GetResult().GetCode(), response.GetResult(). GetMessage())\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a Go function that makes a gRPC call to a test service's EmptyCall method, handling connection establishment and cleanup.\n\nFunction Description: The function invokes the EmptyCall RPC method on a gRPC test service. It establishes a connection to the server with timeout and blocking options, makes the RPC call, and properly closes the connection. The function handles both connection errors and RPC call errors.\n\nInput:\n- address: string - The server address to connect to\n- dialOptions: []grpc.DialOption - List of gRPC dial options for connection configuration\n\nOutput:\n- *testpb.Empty - The response from the EmptyCall RPC\n- error - Any error that occurred during connection or RPC call",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions []grpc.DialOption) (*testpb.Empty, error) {\n\tdialOptions = append(dialOptions, grpc.WithBlock())\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tclientConn, err := grpc.DialContext(ctx, address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer clientConn.Close()\n\n\tclient := testpb.NewTestServiceClient(clientConn)\n\n\tempty, err := client.EmptyCall(context.Background(), new(testpb.Empty))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn empty, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"testpb\"\n)\n\nfunc EmptyCall(address string, dialOptions []grpc.DialOption) (*testpb.Empty, error) {\n\tconn, err := grpc.Dial(address, append(dialOptions, grpc.WithInsecure(), grpc.WithBlock())...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := testpb.NewTestServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tresp, err := client.EmptyCall(ctx, &testpb.Empty{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to call EmptyCall: %v\", err)\n\t}\n\n\treturn resp, nil\n}"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a function to register a mapper with a gRPC server using the Device Management Interface (DMI) API. The function should establish a connection to the server, send a registration request, and return the list of devices and device models provided by the server.\n\nFunction Description: The `RegisterMapper` function connects to a gRPC server using Unix domain socket, sends a mapper registration request with the provided configuration, and returns the device and device model lists from the server response. It handles connection establishment, timeout context, and proper cleanup of resources.\n\nInput: \n- `withData` [bool]: A flag indicating whether to include data in the registration request.\n\nOutput:\n- `[]*dmiapi.Device`: A slice of pointers to Device objects returned by the server.\n- `[]*dmiapi.DeviceModel`: A slice of pointers to DeviceModel objects returned by the server.\n- `error`: An error object if any step fails, nil otherwise.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdmiapi \"github.com/kubeedge/api/apis/dmi/v1beta1\"\n\t\"github.com/kubeedge/mapper-framework/pkg/common\"\n\t\"github.com/kubeedge/mapper-framework/pkg/config\"\n)\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n\tcfg := config.Cfg()\n\n\tconn, err := grpc.Dial(cfg.Common.EdgeCoreSock,\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithContextDialer(\n\t\t\tfunc(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\tunixAddress, err := net.ResolveUnixAddr(\"unix\", cfg.Common.EdgeCoreSock)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn net.DialUnix(\"unix\", nil, unixAddress)\n\t\t\t},\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := dmiapi.NewDeviceManagerServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tresp, err := c.MapperRegister(ctx, &dmiapi.MapperRegisterRequest{\n\t\tWithData: withData,\n\t\tMapper: &dmiapi.MapperInfo{\n\t\t\tName:       cfg.Common.Name,\n\t\t\tVersion:    cfg.Common.Version,\n\t\t\tApiVersion: cfg.Common.APIVersion,\n\t\t\tProtocol:   cfg.Common.Protocol,\n\t\t\tAddress:    []byte(cfg.GrpcServer.SocketPath),\n\t\t\tState:      common.DeviceStatusOK,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn resp.DeviceList, resp.ModelList, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\n// RegisterMapper registers a mapper with the DMI gRPC server.\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n\t// Define the path to the Unix domain socket\n\tsocketPath := \"/var/run/dmi.sock\"\n\n\t// Set up the gRPC connection with a timeout\n\tconn, err := grpc.Dial(socketPath, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(5*time.Second))\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to connect to DMI server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client for the DMI service\n\tclient := dmiapi.NewDeviceManagementClient(conn)\n\n\t// Create the registration request\n\trequest := &dmiapi.RegisterMapperRequest{\n\t\tWithData: withData,\n\t}\n\n\t// Send the registration request and receive the response\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tresponse, err := client.RegisterMapper(ctx, request)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to register mapper: %v\", err)\n\t}\n\n\t// Return the device and device model lists from the response\n\treturn response.Devices, response.DeviceModels, nil\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC connection to a remote server, performs profiling operations based on input flags, and handles connection cleanup.\n\nFunction Description: The function `remoteCommand` establishes an insecure gRPC connection to a specified address, creates a profiling client, and executes either profiling enable/disable operations or retrieves a snapshot based on command-line flags. It handles connection timeouts and ensures proper connection closure.\n\nInput:\n- Context (implicit through package variables)\n- Command-line flags (implicit through package variables):\n  - `flagAddress`: string - gRPC server address to connect to\n  - `flagTimeout`: int - connection timeout in seconds (0 for no timeout)\n  - `flagEnableProfiling`: bool - whether to enable profiling\n  - `flagDisableProfiling`: bool - whether to disable profiling\n  - `flagRetrieveSnapshot`: bool - whether to retrieve a snapshot\n  - `flagSnapshot`: string - snapshot identifier (when retrieving)\n\nOutput:\n- error - returns nil on success, or an error describing what went wrong during execution",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\tppb \"google.golang.org/grpc/profiling/proto\"\n)\nfunc remoteCommand() error {\n\tctx := context.Background()\n\tif *flagTimeout > 0 {\n\t\tvar cancel func()\n\t\tctx, cancel = context.WithTimeout(context.Background(), time.Duration(*flagTimeout)*time.Second)\n\t\tdefer cancel()\n\t}\n\n\tlogger.Infof(\"dialing %s\", *flagAddress)\n\tcc, err := grpc.Dial(*flagAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Errorf(\"cannot dial %s: %v\", *flagAddress, err)\n\t\treturn err\n\t}\n\tdefer cc.Close()\n\n\tc := ppb.NewProfilingClient(cc)\n\n\tif *flagEnableProfiling || *flagDisableProfiling {\n\t\treturn setEnabled(ctx, c, *flagEnableProfiling)\n\t}\n\tif *flagRetrieveSnapshot {\n\t\treturn retrieveSnapshot(ctx, c, *flagSnapshot)\n\t}\n\treturn fmt.Errorf(\"what should I do with the remote target?\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"flag\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\nvar (\n\tflagAddress        = flag.String(\"address\", \"localhost:50051\", \"gRPC server address\")\n\tflagTimeout        = flag.Int(\"timeout\", 0, \"connection timeout in seconds (0 for no timeout)\")\n\tflagEnableProfiling = flag.Bool(\"enable\", false, \"enable profiling\")\n\tflagDisableProfiling = flag.Bool(\"disable\", false, \"disable profiling\")\n\tflagRetrieveSnapshot = flag.Bool(\"retrieve\", false, \"retrieve a snapshot\")\n\tflagSnapshot        = flag.String(\"snapshot\", \"\", \"snapshot identifier (when retrieving)\")\n)\n\ntype ProfilingClient interface {\n\tEnableProfiling(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)\n\tDisableProfiling(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)\n\tRetrieveSnapshot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error)\n}\n\nfunc remoteCommand() error {\n\t// Parse command-line flags\n\tflag.Parse()\n\n\t// Set up gRPC connection\n\tdialOptions := []grpc.DialOption{\n\t\tgrpc.WithInsecure(),\n\t}\n\tif *flagTimeout > 0 {\n\t\tdialOptions = append(dialOptions, grpc.WithTimeout(time.Duration(*flagTimeout)*time.Second))\n\t}\n\n\tconn, err := grpc.Dial(*flagAddress, dialOptions...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewProfilingClient(conn)\n\n\t// Determine the operation to perform\n\tvar result error\n\tif *flagEnableProfiling {\n\t\tresult, err = client.EnableProfiling(context.Background(), &Empty{})\n\t} else if *flagDisableProfiling {\n\t\tresult, err = client.DisableProfiling(context.Background(), &Empty{})\n\t} else if *flagRetrieveSnapshot {\n\t\tif *flagSnapshot == \"\" {\n\t\t\treturn errors.New(\"snapshot identifier is required when retrieving a snapshot\")\n\t\t}\n\t\treq := &SnapshotRequest{SnapshotId: *flagSnapshot}\n\t\tresp, err := client.RetrieveSnapshot(context.Background(), req)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to retrieve snapshot: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Snapshot retrieved: %s\\n\", resp.SnapshotData)\n\t} else {\n\t\treturn errors.New(\"no operation specified\")\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"operation failed: %v\", err)\n\t}\n\n\treturn result\n}"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a Dragonfly daemon server over a Unix domain socket to download files from a specified URL to a local output path, with various download configuration options.\n\nFunction Description: The function establishes a gRPC connection to a Dragonfly daemon server running on a Unix domain socket, initiates a file download operation with specified parameters including authentication headers for S3 storage, and streams the download results until completion.\n\nInput:\n- ctx context.Context - Context for controlling the gRPC call lifecycle\n- unixSocketPath string - Path to the Unix domain socket (e.g., \"/run/dfdaemon.sock\")\n- downloadRequest *dfdaemonv1.DownRequest - Download request containing:\n  * Uuid: string - Unique identifier for the download\n  * Url: string - Source URL to download from\n  * Output: string - Local output path\n  * Recursive: bool - Whether to download recursively\n  * UrlMeta: *commonv1.UrlMeta - Metadata including S3 authentication headers\n  * Other download configuration parameters\n\nOutput:\n- map[string]*dfdaemonv1.DownResult - Map of download results keyed by output path\n- error - Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\tdfdaemonv1 \"d7y.io/api/v2/pkg/apis/dfdaemon/v1\"\n)\nfunc main() {\n\tdialer := func(ctx context.Context, addr string) (net.Conn, error) {\n\t\treturn net.Dial(\"unix\", addr)\n\t}\n\n\tunixAddr := \"/run/dfdaemon.sock\"\n\n\tconn, err := grpc.DialContext(\n\t\tcontext.Background(),\n\t\tunixAddr,\n\t\tgrpc.WithContextDialer(dialer),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tvar (\n\t\tclient = dfdaemonv1.NewDaemonClient(conn)\n\t\tctx    = context.Background()\n\t)\n\n\tdownloadClient, err := client.Download(ctx, &dfdaemonv1.DownRequest{\n\t\tUuid:              \"95305fa2-138b-4466-acec-62865ab6403c\",\n\t\tUrl:               \"s3://minio-test-bucket/dragonfly-test/usr/\" + *subDir,\n\t\tOutput:            \"/var/lib/dragonfly-grpc-test/usr/\" + *subDir,\n\t\tRecursive:         true,\n\t\tTimeout:           0,\n\t\tLimit:             0,\n\t\tDisableBackSource: false,\n\t\tUrlMeta: &commonv1.UrlMeta{\n\t\t\tDigest: \"\",\n\t\t\tTag:    \"\",\n\t\t\tRange:  \"\",\n\t\t\tFilter: \"Expires&Signature\",\n\t\t\tHeader: map[string]string{\n\t\t\t\t\"awsEndpoint\":         \"http://minio.dragonfly-e2e.svc:9000\",\n\t\t\t\t\"awsRegion\":           \"us-west-1\",\n\t\t\t\t\"awsAccessKeyID\":      \"root\",\n\t\t\t\t\"awsSecretAccessKey\":  \"password\",\n\t\t\t\t\"awsS3ForcePathStyle\": \"true\",\n\t\t\t},\n\t\t},\n\t\tUid:                1000,\n\t\tGid:                1000,\n\t\tKeepOriginalOffset: false,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresults := map[string]*dfdaemonv1.DownResult{}\n\tfor {\n\t\tresp, err := downloadClient.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tresults[resp.Output] = resp\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"github.com/dragonflyoss/Dragonfly/proto/dfdaemonv1\"\n\t\"github.com/dragonflyoss/Dragonfly/proto/commonv1\"\n)\n\nfunc DownloadFile(ctx context.Context, unixSocketPath string, downloadRequest *dfdaemonv1.DownRequest) (map[string]*dfdaemonv1.DownResult, error) {\n\t// Create a gRPC connection to the Dragonfly daemon\n\tconn, err := grpc.Dial(unixSocketPath, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to Dragonfly daemon: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := dfdaemonv1.NewDownClient(conn)\n\n\t// Set up metadata for S3 authentication headers\n\tmd := metadata.Pairs(\"Authorization\", downloadRequest.UrlMeta.AuthToken)\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t// Initiate the download request\n\tstream, err := client.Download(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to start download stream: %v\", err)\n\t}\n\n\t// Stream the download results\n\tresults := make(map[string]*dfdaemonv1.DownResult)\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == grpc.ErrUnexpectedEOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"error receiving download result: %v\", err)\n\t\t}\n\n\t\tif resp.Result != nil {\n\t\t\tresults[resp.Result.Output] = resp.Result\n\t\t}\n\t}\n\n\treturn results, nil\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a function that connects to a gRPC server, retrieves pod information using the HyperD Public API, and returns the response.\n\nFunction Description: The function establishes an insecure connection to a gRPC server at the specified address, creates a Public API client, sends a PodInfoRequest for a specific pod ID, and returns the pod information response. The connection is automatically closed when the function completes.\n\nInput: \n- server string: The address of the gRPC server (e.g., \"localhost:50051\")\n- podID string: The ID of the pod to query (e.g., \"pod-zpIOTSAjmM\")\n\nOutput:\n- *types.PodInfoResponse: The response containing pod information\n- error: Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/hyperhq/hyperd/types\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(server, grpc.WithInsecure())\n\tif err != nil {\n\t\tfmt.Printf(\"Connect server error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tclient := types.NewPublicAPIClient(conn)\n\trequest := types.PodInfoRequest{\n\t\tPodID: \"pod-zpIOTSAjmM\",\n\t}\n\tresponse, err := client.PodInfo(context.Background(), &request)\n\tif err != nil {\n\t\tfmt.Printf(\"Get PodInfo error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Got response: %v\", response)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"your_project/path/to/publicapi\"\n\t\"your_project/path/to/podinfo\"\n)\n\nfunc GetPodInfo(server string, podID string) (*podinfo.PodInfoResponse, error) {\n\tconn, err := grpc.Dial(server, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := publicapi.NewPublicAPIClient(conn)\n\trequest := &podinfo.PodInfoRequest{PodId: podID}\n\n\tresponse, err := client.PodInfo(context.Background(), request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Implement a gRPC client function in Go that reports device status to a gRPC server using a Unix domain socket connection.\n\nFunction Description: The function `ReportDeviceStatus` establishes a connection to a gRPC server through a Unix domain socket, sends a device status report request, and handles the response. It manages connection lifecycle including setup, error handling, and cleanup.\n\nInput: \n- request *dmiapi.ReportDeviceStatusRequest: A pointer to the gRPC request message containing device status information to be reported.\n\nOutput:\n- error: Returns an error if any step fails (connection establishment, RPC call, etc.), or nil if successful.\n\nNote: The function uses configuration from `config.Cfg()` to determine the Unix socket path and includes proper connection timeout handling.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdmiapi \"github.com/kubeedge/api/apis/dmi/v1beta1\"\n\t\"github.com/kubeedge/mapper-framework/pkg/config\"\n)\nfunc ReportDeviceStatus(request *dmiapi.ReportDeviceStatusRequest) error {\n\tcfg := config.Cfg()\n\n\tconn, err := grpc.Dial(cfg.Common.EdgeCoreSock,\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithContextDialer(\n\t\t\tfunc(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\tunixAddress, err := net.ResolveUnixAddr(\"unix\", cfg.Common.EdgeCoreSock)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn net.DialUnix(\"unix\", nil, unixAddress)\n\t\t\t},\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := dmiapi.NewDeviceManagerServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\t_, err = c.ReportDeviceStatus(ctx, request)\n\treturn err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\nconst (\n\tdefaultTimeout = 5 * time.Second\n)\n\nfunc ReportDeviceStatus(request *dmiapi.ReportDeviceStatusRequest) error {\n\t// Get the Unix socket path from configuration\n\tsocketPath := config.Cfg().Get(\"socket.path\")\n\tif socketPath == \"\" {\n\t\treturn errors.New(\"socket path not configured\")\n\t}\n\n\t// Set up gRPC connection with timeout\n\tdialOptions := []grpc.DialOption{\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTimeout(defaultTimeout),\n\t\tgrpc.WithSsl(false),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t}\n\n\t// Create a context with timeout\n\tctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)\n\tdefer cancel()\n\n\t// Establish connection to gRPC server\n\tconn, err := grpc.Dial(socketPath, dialOptions...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create client\n\tclient := dmiapi.NewDeviceStatusClient(conn)\n\n\t// Make RPC call\n\tresponse, err := client.ReportDeviceStatus(ctx, request)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to report device status: %v\", err)\n\t}\n\n\t// Handle response\n\tif response.Error != \"\" {\n\t\treturn fmt.Errorf(\"device status report failed: %s\", response.Error)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC metrics server, creates a client for the MetricsService, and prints the metrics retrieved from the server.\n\nFunction Description: The function connects to a gRPC server specified by the metricsServerAddress, initializes a MetricsService client, and prints the metrics. If the connection fails, it logs a fatal error. The connection is automatically closed when the function completes.\n\nInput: \n- metricsServerAddress: string - The address of the gRPC metrics server to connect to.\n- totalOnly: bool - A flag indicating whether to print only the total metrics or all metrics.\n\nOutput: None (prints metrics to the console or logs errors).",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/grpclog\"\n\tmetricspb \"google.golang.org/grpc/stress/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *metricsServerAddress == \"\" {\n\t\tgrpclog.Fatalf(\"Metrics server address is empty.\")\n\t}\n\n\tconn, err := grpc.Dial(*metricsServerAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"cannot connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := metricspb.NewMetricsServiceClient(conn)\n\tprintMetrics(c, *totalOnly)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"metrics_service/proto\"\n)\n\nfunc connectToMetricsServer(metricsServerAddress string, totalOnly bool) {\n\t// Set up a gRPC connection to the metrics server\n\tconn, err := grpc.Dial(metricsServerAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client for the MetricsService\n\tclient := proto.NewMetricsServiceClient(conn)\n\n\t// Call the GetMetrics method\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\tmd := metadata.Pairs(\"total_only\", fmt.Sprintf(\"%t\", totalOnly))\n\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\tresp, err := client.GetMetrics(ctx, &proto.GetMetricsRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get metrics: %v\", err)\n\t}\n\n\t// Print the metrics\n\tfor _, metric := range resp.Metrics {\n\t\tfmt.Printf(\"Metric Name: %s, Value: %f\\n\", metric.Name, metric.Value)\n\t}\n}"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and processes the response.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a client instance for the Greeter service, sends a HelloRequest with a name parameter, and logs the server's response or any errors encountered during the process.\n\nInput: \n- address: string - The server address in format \"host:port\" (default: \"localhost:50051\")\n- name: string - The name to send in the greeting request (default: \"world\")\n\nOutput:\n- None (directly logs results to console)\n- Side effect: Sends gRPC request and receives response",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"go.opencensus.io/examples/grpc/proto\"\n\t\"go.opencensus.io/plugin/ocgrpc\"\n)\n\nconst (\n\taddress     = \"localhost:50051\"\n\tdefaultName = \"world\"\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithStatsHandler(&ocgrpc.ClientHandler{}), grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Cannot connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Printf(\"Could not greet: %v\", err)\n\t} else {\n\t\tlog.Printf(\"Greeting: %s\", r.Message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"github.com/yourusername/yourpackage/yourpackage\" // Replace with actual package path\n)\n\nfunc greet(address string, name string) {\n\tdialOptions := []grpc.DialOption{\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTimeout(10 * time.Second),\n\t}\n\n\tconn, err := grpc.Dial(address, dialOptions...)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\trequest := &pb.HelloRequest{\n\t\tName: name,\n\t}\n\n\tresponse, err := client.SayHello(ctx, request)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to call SayHello: %v\", err)\n\t}\n\n\tlog.Printf(\"Response: %s\", response.Message)\n}"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC connection to a server, invokes an empty call RPC method, and returns the response.\n\nFunction Description: The function `invokeEmptyCall` connects to a gRPC server at the specified address, creates a client for the EmptyService, makes an empty call RPC, and returns the response. It handles connection establishment and cleanup, including context timeout and connection closure.\n\nInput: \n- address: string - The address of the gRPC server to connect to\n- dialOptions: variadic grpc.DialOption - Optional gRPC dial options for connection configuration\n\nOutput:\n- *testpb.Empty - The response from the EmptyCall RPC\n- error - Any error that occurred during the connection or RPC call",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"testpb\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions ...grpc.DialOption) (*testpb.Empty, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), testTimeout)\n\tdefer cancel()\n\tclientConn, err := grpc.DialContext(ctx, address, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer clientConn.Close()\n\n\tclient := testpb.NewEmptyServiceClient(clientConn)\n\tempty, err := client.EmptyCall(context.Background(), new(testpb.Empty))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn empty, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"testpb\"\n)\n\nfunc invokeEmptyCall(address string, dialOptions ...grpc.DialOption) (*testpb.Empty, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tconn, err := grpc.Dial(address, append(dialOptions, grpc.WithInsecure())...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := testpb.NewEmptyServiceClient(conn)\n\tresponse, err := client.EmptyCall(ctx, &testpb.Empty{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a greeting request, and receives a response.\n\nFunction Description: The function establishes a connection to a gRPC server using the provided address, creates a client for the HelloService, sends a HelloRequest with the specified name, and returns the server's response. It handles connection errors and timeout contexts.\n\nInput:\n- addr: string - The address of the gRPC server to connect to (e.g., \"127.0.0.1:8972\")\n- name: string - The name to include in the greeting request\n\nOutput:\n- string - The greeting response from the server\n- error - Any error that occurred during the process\n\nNote: The function should properly close the connection when done and handle context timeouts.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"hello_grpc_client/proto\"\n\t\"log\"\n\t\"time\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:8972\", \"the address to connect to\")\n\tname = flag.String(\"name\", defaultName, \"Name to greet\")\n)\n\nfunc main() {\n\tflag.Parse()\n\tconn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := proto.NewHelloServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.SayHello(ctx, &proto.HelloRequest{\n\t\tName: *name,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\n\tlog.Printf(\"Greeting: %s\", r.GetReply())\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype HelloServiceClient struct {\n\tclient HelloServiceClient\n}\n\nfunc NewHelloServiceClient(addr string) (*HelloServiceClient, error) {\n\tdialOptions := []grpc.DialOption{\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithTimeout(10 * time.Second),\n\t}\n\n\tconn, err := grpc.Dial(addr, dialOptions...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &HelloServiceClient{\n\t\tclient: helloServiceClient{conn: conn},\n\t}, nil\n}\n\ntype helloServiceClient struct {\n\tconn *grpc.ClientConn\n}\n\nfunc (c *helloServiceClient) SayHello(ctx context.Context, name string) (string, error) {\n\tctx = metadata.AppendToOutgoingContext(ctx, \"user\", \"client\")\n\tclient := helloService.NewHelloServiceClient(c.conn)\n\treq := &HelloRequest{Name: name}\n\tresp, err := client.SayHello(ctx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn resp.GetMessage(), nil\n}\n\ntype HelloRequest struct {\n\tName string `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`\n}\n\ntype HelloResponse struct {\n\tMessage string `protobuf:\"bytes,1,opt,name=message,proto3\" json:\"message,omitempty\"`\n}\n\nfunc (c *helloServiceClient) Close() {\n\tc.conn.Close()\n}\n\nfunc main() {\n\tclient, err := NewHelloServiceClient(\"127.0.0.1:8972\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create client:\", err)\n\t\treturn\n\t}\n\tdefer client.Close()\n\n\tresponse, err := client.SayHello(context.Background(), \"Alice\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Response:\", response)\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and properly handle the connection lifecycle.\n\nFunction Description: The function tests gRPC client functionality by connecting to a user authentication service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper gRPC connection management and metadata handling.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None directly returned, but prints authentication tokens to stdout\n- Returns error if connection or RPC calls fail\n\nNote: The function includes error handling and connection cleanup via defer. It uses metadata to pass a UUID for request tracking and demonstrates multiple RPC calls in a loop.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v8/user_agent/src\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"example.com/userauth/v1\"\n)\n\nfunc TestGRPCClient(serviceAddress, account, password string, testCount int) error {\n\t// Create a connection to the gRPC server\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := userauth.NewUserServiceClient(conn)\n\n\t// Generate a UUID for request tracking\n\tuuid := fmt.Sprintf(\"test-uuid-%d\", time.Now().UnixNano())\n\n\tfor i := 0; i < testCount; i++ {\n\t\tctx := context.Background()\n\t\tmd := metadata.Pairs(\"uuid\", uuid)\n\t\tctx = metadata.NewContext(ctx, md)\n\n\t\trequest := &userauth.LoginRequest{\n\t\t\tAccount: account,\n\t\t\tPassword: password,\n\t\t}\n\n\t\tresponse, err := client.Login(ctx, request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Printf(\"Authentication token for test %d: %s\\n\", i+1, response.Token)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Go function that demonstrates how to interact with a gRPC server using the official Go gRPC client package. The function should establish a connection, make multiple RPC calls with metadata, and handle the responses.\n\nFunction Description: The function tests a gRPC client implementation by connecting to a user service, sending login requests with metadata containing a UUID, and printing the received authentication tokens. It demonstrates proper connection handling, metadata usage, and error handling in gRPC communications.\n\nInput: \n- serviceAddress: string - The address of the gRPC server in \"host:port\" format\n- account: string - The username for login\n- password: string - The password for login\n- testCount: int - Number of test iterations to perform\n\nOutput: \n- None (prints tokens to stdout)\n- Returns error if connection or RPC fails\n\nNote: The function includes proper connection cleanup using defer and demonstrates metadata handling for request tracing.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/utils\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v9/user_agent/pb\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"example.com/userpb\" // Replace with actual service package\n)\n\nfunc TestGRPCClient(serviceAddress, account, password string, testCount int) error {\n\t// Establish connection\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tclient := userpb.NewUserServiceClient(conn)\n\n\tfor i := 0; i < testCount; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\n\t\t// Create metadata with UUID\n\t\tmd := metadata.Pairs(\"uuid\", fmt.Sprintf(\"test-uuid-%d\", i))\n\t\tctx = metadata.NewOutgoingContext(ctx, md)\n\n\t\t// Make RPC call\n\t\tresp, err := client.Login(ctx, &userpb.LoginRequest{\n\t\t\tAccount: account,\n\t\t\tPassword: password,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Print response\n\t\tfmt.Printf(\"Authentication Token: %s\\n\", resp.Token)\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: The task involves creating a gRPC probe client in Go that can establish connections to gRPC servers, perform various probe operations (echo, read, write), and collect metrics about the probe results.\n\nStruct Description: The Probe struct represents a gRPC probe client that manages connections to multiple targets, performs probe operations, and tracks results.\n\nFields:\n\nname: [string] - The name of the probe instance\nsrc: [string] - The source identifier for the probe\nopts: [*options.Options] - Configuration options for the probe\nc: [*configpb.ProbeConf] - gRPC probe-specific configuration\nl: [*logger.Logger] - Logger for recording probe events\ndialOpts: [[]grpc.DialOption] - Options for gRPC dialing\ntargets: [[]endpoint.Endpoint] - List of target endpoints to probe\ncancelFuncs: [map[string]context.CancelFunc] - Map of cancel functions for target operations\ntargetsMu: [sync.Mutex] - Mutex for synchronizing access to targets\nresults: [map[string]*probeRunResult] - Map of probe results by target\n\nMethods:\n\nconnectWithRetry: [func(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn] -> [*grpc.ClientConn] - Establishes a gRPC connection to the target with retry logic, using the specified context, target address, message pattern, and result tracker. Returns the established connection or nil if failed.\n\noneTargetLoop: [func(ctx context.Context, tgt string, index int, result *probeRunResult)] -> [None] - Main probe loop for a single target that continuously performs probe operations (echo/read/write) at regular intervals, using the specified context, target address, target index, and result tracker. Manages connection lifecycle and records metrics.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/google/cloudprober/logger\"\n\t\"github.com/google/cloudprober/metrics\"\n\tconfigpb \"github.com/google/cloudprober/probes/grpc/proto\"\n\t\"github.com/google/cloudprober/probes/options\"\n\t\"github.com/google/cloudprober/probes/probeutils\"\n\t\"github.com/google/cloudprober/targets/endpoint\"\n\n\tgrpcprobepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\tservicepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\t\"google.golang.org/grpc/credentials/local\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype Probe struct {\n\tname     string\n\tsrc      string\n\topts     *options.Options\n\tc        *configpb.ProbeConf\n\tl        *logger.Logger\n\tdialOpts []grpc.DialOption\n\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\n\tresults map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\tsync.Mutex\n\ttarget        string\n\ttotal         metrics.Int\n\tsuccess       metrics.Int\n\tlatency       metrics.Value\n\tconnectErrors metrics.Int\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tconnectTimeout := p.opts.Timeout\n\tif p.c.GetConnectTimeoutMsec() > 0 {\n\t\tconnectTimeout = time.Duration(p.c.GetConnectTimeoutMsec()) * time.Millisecond\n\t}\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in connect loop.\", msgPattern)\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\t\tconnCtx, cancelFunc := context.WithTimeout(ctx, connectTimeout)\n\n\t\tif uriScheme := p.c.GetUriScheme(); uriScheme != \"\" {\n\t\t\ttgt = uriScheme + tgt\n\t\t}\n\t\tconn, err = grpc.DialContext(connCtx, tgt, p.dialOpts...)\n\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tp.l.Warningf(\"ProbeId(%v) connect error: %v\", msgPattern, err)\n\t\t} else {\n\t\t\tp.l.Infof(\"ProbeId(%v) connection established.\", msgPattern)\n\t\t\tbreak\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.connectErrors.Inc()\n\t\tresult.Unlock()\n\t}\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tmsgPattern := fmt.Sprintf(\"%s,%s%s,%03d\", p.src, p.c.GetUriScheme(), tgt, index)\n\n\tconn := p.connectWithRetry(ctx, tgt, msgPattern, result)\n\tif conn == nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := servicepb.NewProberClient(conn)\n\ttimeout := p.opts.Timeout\n\tmethod := p.c.GetMethod()\n\n\tmsgSize := p.c.GetBlobSize()\n\tmsg := make([]byte, msgSize)\n\tprobeutils.PatternPayload(msg, []byte(msgPattern))\n\tticker := time.NewTicker(p.opts.Interval)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in request loop.\", msgPattern)\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t}\n\n\t\treqCtx, cancelFunc := context.WithTimeout(ctx, timeout)\n\t\tvar success int64\n\t\tvar delta time.Duration\n\t\tstart := time.Now()\n\t\tvar err error\n\t\tvar peer peer.Peer\n\t\topts := []grpc.CallOption{\n\t\t\tgrpc.WaitForReady(true),\n\t\t\tgrpc.Peer(&peer),\n\t\t}\n\t\tswitch method {\n\t\tcase configpb.ProbeConf_ECHO:\n\t\t\treq := &grpcprobepb.EchoMessage{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.Echo(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_READ:\n\t\t\treq := &grpcprobepb.BlobReadRequest{\n\t\t\t\tSize: proto.Int32(msgSize),\n\t\t\t}\n\t\t\t_, err = client.BlobRead(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_WRITE:\n\t\t\treq := &grpcprobepb.BlobWriteRequest{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.BlobWrite(reqCtx, req, opts...)\n\t\tdefault:\n\t\t\tp.l.Criticalf(\"Method %v not implemented\", method)\n\t\t}\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tpeerAddr := \"unknown\"\n\t\t\tif peer.Addr != nil {\n\t\t\t\tpeerAddr = peer.Addr.String()\n\t\t\t}\n\t\t\tp.l.Warningf(\"ProbeId(%s) request failed: %v. ConnState: %v. Peer: %v\", msgPattern, err, conn.GetState(), peerAddr)\n\t\t} else {\n\t\t\tsuccess = 1\n\t\t\tdelta = time.Since(start)\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.success.AddInt64(success)\n\t\tresult.latency.AddFloat64(delta.Seconds() / p.opts.LatencyUnit.Seconds())\n\t\tresult.Unlock()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"github.com/go-logr/logr\"\n\t\"github.com/go-logr/logr/pkg/logger\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype Probe struct {\n\tname        string\n\tsrc         string\n\topts        *options.Options\n\tc           *configpb.ProbeConf\n\tl           *logger.Logger\n\tdialOpts    []grpc.DialOption\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\tresults     map[string]*probeRunResult\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor i := 0; i < p.opts.MaxRetries; i++ {\n\t\tconn, err = grpc.Dial(tgt, p.dialOpts...)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tp.l.Info(\"Failed to dial target\", \"target\", tgt, \"error\", err)\n\t\ttime.Sleep(time.Duration(i+1) * time.Second)\n\t}\n\tif err != nil {\n\t\tp.l.Error(\"Failed to connect to target after retries\", \"target\", tgt, \"error\", err)\n\t\treturn nil\n\t}\n\tp.l.Info(\"Connected to target\", \"target\", tgt)\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tp.targetsMu.Lock()\n\tdefer p.targetsMu.Unlock()\n\n\ttgtEndpoint := p.targets[index]\n\ttgtAddr := tgtEndpoint.Addr\n\n\tconn := p.connectWithRetry(ctx, tgtAddr, tgt, result)\n\tif conn == nil {\n\t\tp.l.Error(\"Failed to connect to target\", \"target\", tgtAddr)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := configpb.NewProbeClient(conn)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Info(\"Stopping probe loop for target\", \"target\", tgtAddr)\n\t\t\treturn\n\t\tdefault:\n\t\t\tp.l.Info(\"Performing probe operations for target\", \"target\", tgtAddr)\n\t\t\t// Perform echo, read, write operations here\n\t\t\t// Example: echo\n\t\t\techoResp, err := client.Echo(ctx, &configpb.EchoRequest{Message: \"Hello, world!\"})\n\t\t\tif err != nil {\n\t\t\t\tp.l.Error(\"Failed to perform echo operation\", \"target\", tgtAddr, \"error\", err)\n\t\t\t} else {\n\t\t\t\tp.l.Info(\"Echo operation successful\", \"target\", tgtAddr, \"response\", echoResp.Message)\n\t\t\t}\n\t\t\t// Example: read\n\t\t\treadResp, err := client.Read(ctx, &configpb.ReadRequest{})\n\t\t\tif err != nil {\n\t\t\t\tp.l.Error(\"Failed to perform read operation\", \"target\", tgtAddr, \"error\", err)\n\t\t\t} else {\n\t\t\t\tp.l.Info(\"Read operation successful\", \"target\", tgtAddr, \"response\", readResp.Data)\n\t\t\t}\n\t\t\t// Example: write\n\t\t\twriteResp, err := client.Write(ctx, &configpb.WriteRequest{Data: \"Test data\"})\n\t\t\tif err != nil {\n\t\t\t\tp.l.Error(\"Failed to perform write operation\", \"target\", tgtAddr, \"error\", err)\n\t\t\t} else {\n\t\t\t\tp.l.Info(\"Write operation successful\", \"target\", tgtAddr, \"response\", writeResp.Status)\n\t\t\t}\n\t\t\ttime.Sleep(p.opts.Interval)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Write a Go function that tests the version retrieval functionality of a gRPC service using the Stripe CLI client. The function should establish a connection to the gRPC server, call the Version method, and verify the response matches the expected version.\n\nFunction Description: The function `TestVersionReturnsCLIVersion` is a test function that verifies the version information returned by a gRPC service. It establishes an authenticated connection to a gRPC server, calls the Version RPC method, and checks that the returned version matches the expected value (\"master\"). The connection is properly closed after the test completes.\n\nInput: \n- `t *testing.T`: The testing context provided by Go's testing framework for reporting test failures and logging.\n- Implicit context from `withAuth(context.Background())`: An authenticated context for the gRPC call.\n\nOutput: \n- The function does not return any value but will fail the test if any of the following occur:\n  - The gRPC connection cannot be established\n  - The Version RPC call fails\n  - The returned version does not match the expected value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Version(ctx, &rpc.VersionRequest{})\n\tif err != nil {\n\t\tt.Fatalf(\"Version failed: %v\", err)\n\t}\n\n\texpected := rpc.VersionResponse{\n\t\tVersion: \"master\",\n\t}\n\n\tassert.Equal(t, expected.Version, resp.Version)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package stripe\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\t// Establish a connection to the gRPC server\n\tconn, err := grpc.Dial(\"localhost:8080\", grpc.WithInsecure())\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client and call the Version method\n\tclient := NewStripeClient(conn)\n\tversion, err := client.Version(context.Background())\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to call Version RPC: %v\", err)\n\t}\n\n\t// Check that the returned version matches the expected value\n\tif version != \"master\" {\n\t\tt.Fatalf(\"Expected version 'master', got '%s'\", version)\n\t}\n}"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: The task involves creating a gRPC client in Go that connects to a CloudSlack service, establishes a bidirectional stream, and handles incoming events while managing connection lifecycle and errors.\n\nFunction Description: The `start` function initializes a gRPC connection to a CloudSlack server, establishes a bidirectional stream for communication, sends a connection request, and continuously listens for incoming events. It handles connection errors, server closures, and context cancellations appropriately.\n\nInput: \n- `ctx context.Context`: The context for managing the lifecycle of the gRPC connection and handling cancellations.\n- The function also relies on the struct's fields (`log`, `cfg`, `client`, `commGroupMetadata`, `clusterName`, and `botID`) for configuration and logging.\n\nOutput: \n- `error`: Returns an error if any step in the connection or communication process fails, including gRPC connection errors, credential errors, or stream errors. Returns nil if the context is canceled gracefully.\n\nNote: The function uses deferred calls to ensure proper cleanup of resources (closing the gRPC connection and stream) and includes detailed error handling for various gRPC-specific scenarios.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tpb \"github.com/kubeshop/botkube/pkg/api/cloudslack\"\n\t\"github.com/kubeshop/botkube/pkg/grpcx\"\n\t\"github.com/kubeshop/botkube/pkg/config\"\n\t\"github.com/kubeshop/botkube/pkg/api/cloudplatform\"\n\t\"github.com/kubeshop/botkube/internal/config/remote\"\n)\n\ntype CloudSlack struct {\n\tlog               logrus.FieldLogger\n\tcfg               config.CloudSlack\n\tclient            *slack.Client\n\tcommGroupMetadata CommGroupMetadata\n\tclusterName       string\n}\n\nfunc (b *CloudSlack) start(ctx context.Context) error {\n\tremoteConfig, ok := remote.GetConfig()\n\tif !ok {\n\t\treturn fmt.Errorf(\"while getting remote config for %s\", config.CloudSlackCommPlatformIntegration)\n\t}\n\n\tcreds, err := grpcx.ClientTransportCredentials(b.log, b.cfg.Server)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC credentials: %w\", err)\n\t}\n\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithStreamInterceptor(cloudplatform.AddStreamingClientCredentials(remoteConfig)),\n\t\tgrpc.WithUnaryInterceptor(cloudplatform.AddUnaryClientCredentials(remoteConfig)),\n\t}\n\n\tconn, err := grpc.Dial(b.cfg.Server.URL, opts...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC connection: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\treq := &pb.ConnectRequest{\n\t\tInstanceId: remoteConfig.Identifier,\n\t\tBotId:      b.botID,\n\t}\n\tc, err := pb.NewCloudSlackClient(conn).Connect(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while initializing gRPC cloud client: %w\", err)\n\t}\n\tdefer func(c pb.CloudSlack_ConnectClient) {\n\t\terr := c.CloseSend()\n\t\tif err != nil {\n\t\t\tb.log.Errorf(\"while closing connection: %s\", err.Error())\n\t\t}\n\t}(c)\n\n\terr = c.Send(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while sending gRPC connection request. %w\", err)\n\t}\n\n\tfor {\n\t\tdata, err := c.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tb.log.Warn(\"gRPC connection was closed by server\")\n\t\t\t\treturn errors.New(\"gRPC connection closed\")\n\t\t\t}\n\t\t\terrStatus, ok := status.FromError(err)\n\t\t\tif ok && errStatus.Code() == codes.Canceled && errStatus.Message() == context.Canceled.Error() {\n\t\t\t\tb.log.Debugf(\"Context was cancelled. Skipping returning error...\")\n\t\t\t\treturn fmt.Errorf(\"while resolving error from gRPC response %s\", errStatus.Err())\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"while receiving cloud slack events: %w\", err)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"cloudslack.com/protos/gen/go/cloudslack\"\n)\n\nfunc (s *Service) start(ctx context.Context) error {\n\t// Initialize gRPC connection\n\tconn, err := grpc.Dial(s.cfg.GRPC.Addr, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\ts.log.Errorf(\"failed to connect to CloudSlack server: %v\", err)\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Create client\n\tclient := cloudslack.NewCloudSlackClient(conn)\n\tif client == nil {\n\t\ts.log.Error(\"failed to create CloudSlack client\")\n\t\treturn errors.New(\"failed to create CloudSlack client\")\n\t}\n\n\t// Create stream\n\tstream, err := client.EstablishStream(ctx)\n\tif err != nil {\n\t\ts.log.Errorf(\"failed to establish stream: %v\", err)\n\t\treturn err\n\t}\n\tdefer stream.CloseSend()\n\n\t// Send connection request\n\trequest := &cloudslack.ConnectionRequest{\n\t\tClusterName:    s.clusterName,\n\t\tBotID:          s.botID,\n\t\tCommGroupMeta:  s.commGroupMetadata,\n\t\tAccessToken:    s.cfg.Auth.Token,\n\t\tTimeoutSeconds: int32(s.cfg.GRPC.Timeout.Seconds()),\n\t}\n\tif err = stream.Send(request); err != nil {\n\t\ts.log.Errorf(\"failed to send connection request: %v\", err)\n\t\treturn err\n\t}\n\n\t// Listen for events\n\tfor {\n\t\t_, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\ts.log.Info(\"stream closed by server\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.log.Errorf(\"failed to receive event: %v\", err)\n\t\t\treturn err\n\t\t}\n\n\t\t// Process event\n\t\tif err = s.handleEvent(stream, ctx); err != nil {\n\t\t\ts.log.Errorf(\"failed to handle event: %v\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a PubSub service, subscribes to a specific topic, and continuously receives messages from the subscribed topic until the stream ends or an error occurs.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 1234, creates a PubSub service client, and subscribes to a topic specified by the input string. It then enters a loop to receive messages from the subscribed topic, printing each message until the stream is closed or an error occurs. The connection is automatically closed when the function completes.\n\nInput: \n- topic string: The topic to subscribe to (e.g., \"golang:\")\n\nOutput: \n- None (messages are printed to stdout)\n- Errors: Any connection or stream errors will cause the function to terminate and log the error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\tpb \"gobook.examples/ch4-04-grpc/grpc-pubsub/pubsubservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPubsubServiceClient(conn)\n\tstream, err := client.Subscribe(context.Background(), &pb.String{Value: \"golang:\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\treply, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(reply.GetValue())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"github.com/googleapis/gapic-repos/pb/pubsub/v1\"\n)\n\nfunc subscribeToTopic(topic string) {\n\t// Create a gRPC connection to the PubSub service\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a PubSub service client\n\tclient := pb.NewPubSubClient(conn)\n\n\t// Subscribe to the specified topic\n\tsubscription, err := client.Subscribe(context.Background(), &pb.SubscribeRequest{\n\t\tTopic: topic,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to subscribe: %v\", err)\n\t}\n\n\t// Receive messages from the subscription\n\tfor {\n\t\tmsg, err := subscription.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tfmt.Println(\"Stream ended.\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalf(\"Error receiving message: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Received message: %s\\n\", msg.Data)\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n}"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Create a function that establishes a connection to a gRPC server for Google Pub/Sub emulator testing, creates a Pub/Sub client, and properly handles resource cleanup.\n\nFunction Description: The function demonstrates how to set up a testing environment for Google Pub/Sub using the pstest server (in-memory emulator). It creates a gRPC connection to the emulator server, initializes a Pub/Sub client with this connection, and ensures all resources are properly closed when done. This is typically used for local testing and development.\n\nInput: None (The function takes no parameters as it's a self-contained example)\n\nOutput: None (The function doesn't return anything as it's a demonstration, though it creates and manages a Pub/Sub client instance)",
    "Canonical_solution": "import (\n\t\"context\"\n\n\t\"cloud.google.com/go/pubsub\"\n\t\"cloud.google.com/go/pubsub/pstest\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n)\nfunc ExampleNewServer() {\n\tctx := context.Background()\n\tsrv := pstest.NewServer()\n\tdefer srv.Close()\n\tconn, err := grpc.Dial(srv.Addr, grpc.WithInsecure())\n\tif err != nil {\n\t}\n\tdefer conn.Close()\n\tclient, err := pubsub.NewClient(ctx, \"project\", option.WithGRPCConn(conn))\n\tif err != nil {\n\t}\n\tdefer client.Close()\n\t_ = client\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/googleapis/gapic-reverse-proxy/pstest\"\n\t\"github.com/googleapis/gapic-reverse-proxy/pstest/pb\"\n)\n\nfunc setupPubSubClient() {\n\t// Start the PSTest server\n\tserver, err := pstest.NewServer()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start PSTest server: %v\", err)\n\t}\n\tdefer server.Stop()\n\n\t// Connect to the PSTest server\n\tconn, err := grpc.Dial(\"localhost:8085\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to PSTest server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a Pub/Sub client\n\tclient := pb.NewPubSubClient(conn)\n\tdefer client.Close()\n\n\t// Example: Publish a message\n\tmessage := &structpb.Struct{\n\t\tFields: map[string]*structpb.Value{\n\t\t\t\"key\": structpb.NewStringValue(\"value\"),\n\t\t},\n\t}\n\t_, err = client.Publish(context.Background(), &pb.PublishRequest{\n\t\tTopic: \"projects/my-project/topics/test-topic\",\n\t\tMessage: message,\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to publish message: %v\", err)\n\t}\n\n\tfmt.Println(\"Message published successfully.\")\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a function that demonstrates how to establish a gRPC client connection, make a login request to a user service, and handle the response.\n\nFunction Description: The function connects to a gRPC server at a specified address, creates a client for the User service, sends a login request with account credentials, and returns the authentication token. It includes error handling and connection cleanup.\n\nInput: \n- serviceAddress (string): The address of the gRPC server in \"host:port\" format\n- account (string): The user's account name for login\n- password (string): The user's password for login\n\nOutput:\n- token (string): The authentication token returned by the server upon successful login\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function assumes the existence of generated gRPC client code from a protobuf definition that includes a User service with RpcUserLogin method.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v5/v5_user/pb\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(v5_service.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"your/protobuf/generated/user_service_grpc.pb.go\"\n\t\"your/protobuf/generated/user_service.pb.go\"\n)\n\nfunc LoginUser(serviceAddress, account, password string) (string, error) {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer conn.Close()\n\n\tclient := user_service.NewUserServiceClient(conn)\n\tctx := context.Background()\n\n\trequest := &user_service.LoginRequest{\n\t\tAccount: account,\n\t\tPassword: password,\n\t}\n\n\tresponse, err := client.RpcUserLogin(ctx, request)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tmd, _ := metadata.FromOutgoingContext(ctx)\n\tauthToken := md.Get(\"Authorization\")[0]\n\treturn authToken, nil\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a function to test gRPC client functionality for user login using Go's gRPC package. The function should establish a connection to a gRPC server, send multiple login requests with metadata, and handle responses.\n\nFunction Description: The function tests the gRPC client's ability to communicate with a user service. It establishes an insecure connection to the specified server address, creates a client instance, and sends 20 consecutive login requests with generated UUID metadata. Each request uses the same account credentials and prints the received authentication token.\n\nInput: None (The function is a test function with hardcoded values)\n\nOutput: None (The function prints tokens to stdout and may return errors through the testing framework)\n\nNote: The function uses package-level variables and imports from external packages as shown in the reference code. The connection is automatically closed when the function completes.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v11/utils\"\n\tuuid \"github.com/satori/go.uuid\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(utils.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tfor i := 0; i < 20; i++ {\n\t\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\t\tAccount:  \"hwholiday\",\n\t\t\tPassword: \"123456\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(res.Token)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"your_project/user_service/proto\"\n)\n\nvar (\n\tuserServiceAddr = \"localhost:50051\"\n\tusername       = \"testuser\"\n\tpassword       = \"testpass\"\n)\n\nfunc TestGRPCUserLogin() {\n\trand.Seed(time.Now().UnixNano())\n\n\tconn, err := grpc.Dial(userServiceAddr, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to gRPC server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := proto.NewUserServiceClient(conn)\n\n\tfor i := 0; i < 20; i++ {\n\t\tmd := metadata.Pairs(\"uuid\", fmt.Sprintf(\"uuid_%d\", i))\n\t\tctx := metadata.Context(context.Background(), md)\n\n\t\treq := &proto.LoginRequest{\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t}\n\n\t\tresp, err := client.Login(ctx, req)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Login failed: %v\", err)\n\t\t}\n\n\t\tfmt.Printf(\"Received token: %s\\n\", resp.Token)\n\t}\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a login request, and retrieves an authentication token.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a gRPC client for the User service, sends a login request with account credentials, and returns the authentication token received from the server. The function includes error handling and connection cleanup.\n\nInput:\n- serviceAddress (string): The address of the gRPC server in format \"host:port\"\n- account (string): The user account name for login\n- password (string): The user password for login\n\nOutput:\n- token (string): The authentication token returned by the server\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function generates a unique request UUID for tracking purposes and uses insecure connection (for testing purposes only). In production, you should use proper TLS credentials.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype UserClient struct {\n\tclient UserClient\n}\n\ntype UserClient interface {\n\tLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)\n}\n\ntype LoginRequest struct {\n\tUUID    string\n\tAccount string\n\tPassword string\n}\n\ntype LoginResponse struct {\n\tToken string\n}\n\nfunc LoginToServer(serviceAddress string, account string, password string) (string, error) {\n\t// Generate a unique request UUID\n\tuuid := fmt.Sprintf(\"%d\", time.Now().UnixNano())\n\n\t// Create a gRPC connection\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client\n\tclient := NewUserClient(conn)\n\n\t// Create a context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Create the login request\n\trequest := &LoginRequest{\n\t\tUUID:    uuid,\n\t\tAccount: account,\n\t\tPassword: password,\n\t}\n\n\t// Send the login request\n\tresponse, err := client.Login(ctx, request)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Return the token\n\treturn response.Token, nil\n}\n\nfunc NewUserClient(conn *grpc.ClientConn) UserClient {\n\treturn &UserClient{\n\t\tclient: NewUserClientImpl(conn),\n\t}\n}\n\nfunc NewUserClientImpl(conn *grpc.ClientConn) UserClient {\n\treturn NewUserClientImpl(conn)\n}\n\nfunc (c *UserClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {\n\tclient := NewUserClientImpl(c.client.client)\n\treturn client.Login(ctx, in, opts...)\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a HelloService server, sends a greeting, and handles the response.\n\nFunction Description: The function connects to a gRPC server running on localhost:1234, creates a client for the HelloService, sends a \"hello\" message, and processes the server's reply. It handles connection errors and RPC call errors appropriately.\n\nInput: None (The server address and message are hardcoded in this example)\n\nOutput: None (The function logs errors and doesn't return any value, though in a real implementation you might want to return the reply or error)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\n\ths \"ch4.4-1/helloservice\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:1234\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tclient := hs.NewHelloServiceClient(conn)\n\treply, err := client.Hello(context.Background(), &hs.String{Value: \"hello\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"hello_service/proto\"\n)\n\nfunc main() {\n\t// Define the server address and message\n\tserverAddr := \"localhost:1234\"\n\tgreeting := \"hello\"\n\n\t// Set up a connection to the server\n\tconn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(10*time.Second))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client\n\tclient := proto.NewHelloServiceClient(conn)\n\n\t// Make the RPC call\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tresponse, err := client.SayHello(ctx, &proto.HelloRequest{Greeting: greeting})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to call RPC: %v\", err)\n\t}\n\n\t// Log the response\n\tlog.Printf(\"Received response: %s\", response.Greeting)\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function that establishes a gRPC connection to a server, creates a client, and makes a request to retrieve fixture data for a specific event.\n\nFunction Description: The function `TestFixturesReturnsData` tests the gRPC client's ability to connect to a server and retrieve fixture data for a specified event. It establishes a connection, creates a client, sends a request, and handles potential errors. The connection is automatically closed when the function completes.\n\nInput: \n- `t *testing.T`: The testing context for reporting failures and logging.\n- Implicit context with authentication (via `withAuth`).\n\nOutput: \n- None explicitly returned, but the function will fail the test if any step (connection, client creation, or request) encounters an error. The response from the gRPC server is captured in `resp` but not returned.",
    "Canonical_solution": "import (\n\t\"context\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\nfunc TestFixturesReturnsData(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Fixture(ctx, &rpc.FixtureRequest{Event: \"customer.created\"})\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/test/benchmarks/fixture\"\n)\n\nfunc TestFixturesReturnsData(t *testing.T) {\n\t// Establish a gRPC connection to the server\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client\n\tclient := fixture.NewFixtureServiceClient(conn)\n\n\t// Make a request to retrieve fixture data for a specific event\n\treq := &fixture.GetFixtureRequest{\n\t\tEventId: 123,\n\t}\n\tresp, err := client.GetFixture(context.Background(), req)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get fixture data: %v\", err)\n\t}\n\n\t// The response is captured but not returned, as per the function's requirements\n\tfmt.Printf(\"Received fixture data: %v\\n\", resp)\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a metrics server, retrieves metrics, and prints them. The function should handle connection setup and teardown, and provide options for controlling output format.\n\nFunction Description: The function connects to a gRPC metrics server using the provided address, creates a metrics service client, and prints the retrieved metrics. It supports a flag to determine whether to print all metrics or just the total. The connection is automatically closed when the function completes.\n\nInput:\n- metricsServerAddress (string): The address of the gRPC metrics server to connect to\n- totalOnly (bool): Flag indicating whether to print only the total metrics or all metrics\n\nOutput: None (prints metrics to stdout directly)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/grpclog\"\n\tmetricspb \"google.golang.org/grpc/interop/stress/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *metricsServerAddress == \"\" {\n\t\tlogger.Fatal(\"-metrics_server_address is unset\")\n\t}\n\n\tconn, err := grpc.Dial(*metricsServerAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlogger.Fatalf(\"cannot connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := metricspb.NewMetricsServiceClient(conn)\n\tprintMetrics(c, *totalOnly)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"flag\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\tmetricspb \"path/to/metricspb\" // Replace with actual package path\n)\n\nfunc fetchAndPrintMetrics(metricsServerAddress string, totalOnly bool) {\n\t// Set up gRPC connection\n\tconn, err := grpc.Dial(metricsServerAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to metrics server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := metricspb.NewMetricsServiceClient(conn)\n\n\t// Create context with metadata for authentication (example)\n\tctx := context.Background()\n\tmd := metadata.Pairs(\"authorization\", \"Bearer your_token_here\")\n\tctx = metadata.Context(ctx, md)\n\n\t// Fetch metrics\n\tresponse, err := client.GetMetrics(ctx, &metricspb.GetMetricsRequest{})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get metrics: %v\", err)\n\t}\n\n\t// Print metrics based on the flag\n\tif totalOnly {\n\t\tfmt.Printf(\"Total Metrics: %d\\n\", response.Total)\n\t} else {\n\t\tfor _, metric := range response.Metrics {\n\t\t\tfmt.Printf(\"Metric Name: %s, Value: %f\\n\", metric.Name, metric.Value)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a server, sends a greeting request, and processes the response.\n\nFunction Description: The function connects to a gRPC server at a specified address, creates a client instance for the Greeter service, sends a HelloRequest with a name parameter, and returns the server's greeting response. It handles connection errors and request failures appropriately.\n\nInput: \n- address [string]: The network address of the gRPC server (e.g., \"localhost:50051\")\n- name [string]: The name to include in the greeting request (optional, defaults to \"world\")\n\nOutput:\n- [string]: The greeting message received from the server\n- [error]: Any error that occurred during connection or request processing",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"os\"\n\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(address, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tr, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.Message)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"example.com/greetpb\"\n)\n\nfunc greet(address string, name string) (string, error) {\n\t// Create a gRPC connection\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Create a client\n\tclient := greetpb.NewGreeterClient(conn)\n\n\t// Create a context with metadata\n\tctx := context.Background()\n\tmd := metadata.Pairs(\"authorization\", \"Bearer your_token_here\")\n\tctx = metadata.NewContext(ctx, md)\n\n\t// Send the request\n\trequest := &greetpb.HelloRequest{\n\t\tName: name,\n\t}\n\tresponse, err := client.SayHello(ctx, request)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to send request: %v\", err)\n\t}\n\n\treturn response.GetMessage(), nil\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a server, sends multiple requests, and processes the responses using the GoFrame framework.\n\nFunction Description: The function connects to a gRPC server using service discovery, creates a client stub, and makes repeated calls to a SayHello RPC method. It handles connection errors and response processing, with built-in logging and graceful connection closure.\n\nInput: None (uses package-level constants and context)\n\nOutput: None (logs results to console via GoFrame's logging system)\n\nNote: The function includes an internal loop that makes 10 RPC calls with a 1-second delay between calls. Connection is automatically closed when function completes.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/gsvc\"\n\t\"github.com/gogf/gf/v2/os/gctx\"\n\n\t\"github.com/gogf/gf/contrib/rpc/grpcx/v2\"\n\n\tpb \"github.com/gogf/gf/example/rpc/grpcx/rawgrpc/helloworld\"\n)\nfunc main() {\n\tvar (\n\t\tctx     = gctx.GetInitCtx()\n\t\tservice = gsvc.NewServiceWithName(`hello`)\n\t)\n\tconn, err := grpc.Dial(\n\t\tfmt.Sprintf(`%s://%s`, gsvc.Schema, service.GetKey()),\n\t\tgrpcx.Balancer.WithRandom(),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tg.Log().Fatalf(ctx, \"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\tfor i := 0; i < 10; i++ {\n\t\tres, err := client.SayHello(ctx, &pb.HelloRequest{Name: `GoFrame`})\n\t\tif err != nil {\n\t\t\tg.Log().Fatalf(ctx, \"could not greet: %+v\", err)\n\t\t}\n\t\tg.Log().Printf(ctx, \"Greeting: %s\", res.Message)\n\t\ttime.Sleep(time.Second)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/goframe/g\"\n)\n\nfunc init() {\n\tg.Log.SetLevel(\"info\")\n}\n\nfunc TestGRPCClient() {\n\t// Package-level constants for service discovery\n\tconst (\n\t\tserviceName = \"hello-service\"\n\t\tport        = 50051\n\t)\n\n\t// Create a context with a timeout\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\t// Build the service address\n\tserviceAddr := g.BuildServiceAddress(serviceName, port)\n\n\t// Establish gRPC connection\n\tconn, err := grpc.Dial(serviceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tg.Log.Error(\"Failed to connect to gRPC server: \", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Create client stub\n\tclient := NewHelloClient(conn)\n\n\t// Internal loop to make 10 RPC calls with 1-second delay\n\tfor i := 0; i < 10; i++ {\n\t\tresp, err := client.SayHello(ctx, &HelloRequest{Message: \"Hello from GoFrame!\"})\n\t\tif err != nil {\n\t\t\tg.Log.Error(\"Failed to call SayHello: \", err)\n\t\t\tcontinue\n\t\t}\n\t\tg.Log.Info(\"Received response: \", resp.Message)\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework. The server should be able to gracefully shut down when the context is canceled.\n\nFunction Description: The MainExt function initializes and starts a gRPC server. It sets up a network listener, creates a gRPC server instance, registers the service implementation, and starts the server in a goroutine. The function waits for the context to be canceled before gracefully shutting down the server.\n\nInput:\n- ctx [context.Context]: The context used to control the lifecycle of the gRPC server. Canceling this context will trigger a graceful shutdown.\n- cfg [Config]: A configuration object containing the port number on which the server should listen.\n\nOutput: None (The function runs indefinitely until the context is canceled or an error occurs.)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\ttriggerpb \"github.com/vanus-labs/vanus/api/trigger\"\n)\n\ntype TriggerServer struct {\n\tcfg Config\n}\n\nfunc NewTriggerServer(cfg Config) *TriggerServer {\n\treturn &TriggerServer{\n\t\tcfg: cfg,\n\t}\n}\n\nfunc MainExt(ctx context.Context, cfg Config) {\n\tlisten, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n\tif err != nil {\n\t\tlog.Error().Msg(\"failed to listen\")\n\t\tos.Exit(-1)\n\t}\n\n\tsrv := NewTriggerServer(cfg)\n\n\tvar opts []grpc.ServerOption\n\tgrpcServer := grpc.NewServer(opts...)\n\ttriggerpb.RegisterTriggerWorkerServer(grpcServer, srv)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Info(ctx).Msg(\"the grpc server ready to work\")\n\t\terr = grpcServer.Serve(listen)\n\t\tif err != nil {\n\t\t\tlog.Error(ctx).Err(err).Msg(\"grpc server occurred an error\")\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\tgrpcServer.GracefulStop()\n\twg.Wait()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"runtime\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Config struct {\n\tPort int\n}\n\nfunc MainExt(ctx context.Context, cfg Config) {\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", cfg.Port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer()\n\t// Register your service here\n\t// YourService.Register(srv)\n\n\tgo func() {\n\t\tif err := srv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"server loop exited unexpectedly: %v\", err)\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\tlog.Println(\"Shutting down gRPC server...\")\n\n\tsrv.GracefulStop()\n\truntime.GoExit()\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests and handles them using the gRPC framework.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, creates a new gRPC server instance, registers a service implementation, and starts serving incoming requests.\n\nInput: \n- port: string - The network port on which the server should listen (e.g., \":50051\")\n\nOutput: \n- None (The function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context\"\n\t\"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc\"\n\tpb \"github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/examples/helloworld/helloworld\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\ts.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(ctx interface{}, in *HelloRequest) (*HelloResponse, error) {\n\treturn &HelloResponse{Message: \"Hello \" + in.Name}, nil\n}\n\ntype HelloRequest struct {\n\tName string\n}\n\ntype HelloResponse struct {\n\tMessage string\n}\n\nfunc main() {\n\tport := flag.String(\"port\", \":50051\", \"The port the server runs on.\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", *port)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer()\n\t// Register your service\n\t// Here we assume you have a service definition and implementation\n\t// For example:\n\t// pb.RegisterYourServiceServer(srv, &yourServiceImpl{})\n\n\t// For demonstration, we'll use a dummy server\n\t// Replace with actual service registration\n\t// pb.RegisterYourServiceServer(srv, &server{})\n\n\tlog.Printf(\"Server listening at %v\", lis.Addr())\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a gRPC server in Go that handles metric forwarding operations, including receiving metrics and processing them through a handler function.\n\nStruct Description: The Server struct represents a gRPC server that listens for incoming metric data and processes it using a provided handler function. It manages server lifecycle and handles gRPC communication.\n\nFields:\n- Server: *grpc.Server - The underlying gRPC server instance\n- lis: net.Listener - The network listener for the server\n- handler: func([]*metricpb.Metric) - The function that processes received metrics\n- startMtx: sync.Mutex - Mutex to ensure thread-safe server startup\n\nMethods:\n- NewServer: (handler func([]*metricpb.Metric)) -> *Server - Creates a new Server instance with the given metric handler and initializes the gRPC server\n- Start: (t testing.TB) -> () - Starts the gRPC server on a random available port and begins listening for requests\n- SendMetrics: (ctx context.Context, mlist *forwardrpc.MetricList) -> (*empty.Empty, error) - Handles unary RPC calls for metric submission\n- SendMetricsV2: (server forwardrpc.Forward_SendMetricsV2Server) -> error - Handles streaming RPC calls for metric submission",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\n\t\"context\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/stripe/veneur/v14/forwardrpc\"\n\t\"github.com/stripe/veneur/v14/samplers/metricpb\"\n)\n\ntype Server struct {\n\t*grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\tres := &Server{\n\t\tServer:  grpc.NewServer(),\n\t\thandler: handler,\n\t}\n\n\tforwardrpc.RegisterForwardServer(res.Server, res)\n\treturn res\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\tvar err error\n\ts.lis, err = net.Listen(\"tcp\", \"127.0.0.1:\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create a TCP connection for a test GRPC \"+\n\t\t\t\"server: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := s.Serve(s.lis); err != nil && err != grpc.ErrServerStopped {\n\t\t\tt.Logf(\"failed to stop the test forwarding gRPC server: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) SendMetrics(ctx context.Context, mlist *forwardrpc.MetricList) (*empty.Empty, error) {\n\ts.handler(mlist.Metrics)\n\treturn &empty.Empty{}, nil\n}\n\nfunc (s *Server) SendMetricsV2(\n\tserver forwardrpc.Forward_SendMetricsV2Server,\n) error {\n\tmetrics := []*metricpb.Metric{}\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmetrics = append(metrics, metric)\n\t}\n\t_, err := s.SendMetrics(context.Background(), &forwardrpc.MetricList{\n\t\tMetrics: metrics,\n\t})\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/test/benchmarks/clock\"\n\t\"google.golang.org/grpc/test/benchmarks/metricpb\"\n\t\"google.golang.org/grpc/test/benchmarks/forwardrpc\"\n)\n\ntype Server struct {\n\t*grpc.Server\n\tlis      net.Listener\n\thandler  func([]*metricpb.Metric)\n\tstartMtx sync.Mutex\n}\n\nfunc NewServer(handler func([]*metricpb.Metric)) *Server {\n\ts := &Server{\n\t\tServer: grpc.NewServer(),\n\t\thandler: handler,\n\t}\n\treturn s\n}\n\nfunc (s *Server) Start(t testing.TB) {\n\ts.startMtx.Lock()\n\tdefer s.startMtx.Unlock()\n\n\t// Create a listener on a random available port\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ts.lis = lis\n\n\t// Register the service\n\tforwardrpc.RegisterForwardServiceServer(s.Server, &forwardrpc.ForwardServiceServer{\n\t\tSendMetrics: func(ctx context.Context, mlist *forwardrpc.MetricList) (*forwardrpc.Empty, error) {\n\t\t\tmetrics := make([]*metricpb.Metric, len(mlist.Metrics))\n\t\t\tfor i, m := range mlist.Metrics {\n\t\t\t\tmetrics[i] = m\n\t\t\t}\n\t\t\ts.handler(metrics)\n\t\t\treturn &forwardrpc.Empty{}, nil\n\t\t},\n\t\tSendMetricsV2: func(server forwardrpc.Forward_SendMetricsV2Server) error {\n\t\t\tfor {\n\t\t\t\tmlist, err := server.Recv()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tmetrics := make([]*metricpb.Metric, len(mlist.Metrics))\n\t\t\t\tfor i, m := range mlist.Metrics {\n\t\t\t\t\tmetrics[i] = m\n\t\t\t\t}\n\t\t\t\ts.handler(metrics)\n\t\t\t}\n\t\t},\n\t})\n\n\t// Start the server\n\tgo func() {\n\t\tif err := s.Server.Serve(lis, nil); err != nil {\n\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Get the port the server is listening on\n\tport := lis.Addr().(*net.TCPAddr).Port\n\tfmt.Printf(\"Server started on port %d\\n\", port)\n}\n\nfunc main() {\n\t// Example usage\n\thandler := func(metrics []*metricpb.Metric) {\n\t\t// Process metrics\n\t\tfor _, m := range metrics {\n\t\t\tfmt.Printf(\"Received metric: %v\\n\", m)\n\t\t}\n\t}\n\n\tserver := NewServer(handler)\n\tserver.Start(nil)\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both physical data source operations and execution of data processing tasks, using Unix domain sockets for inter-process communication.\n\nStruct Description: The implementation consists of two main structs: physicalServer handles the materialization of data sources, while executionServer manages the execution of data processing tasks.\n\nFields:\n\nphysicalServer:\n- database: physical.Database - The underlying database implementation\n- socketDir: string - Directory where Unix domain sockets will be created\n- wg: *sync.WaitGroup - WaitGroup for managing server goroutines\n\nexecutionServer:\n- node: execution.Node - The execution node to process data\n\nMethods:\n\nphysicalServer:\n- Materialize(context.Context, *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) - Materializes a data source and starts a gRPC server for execution\n\nexecutionServer:\n- Run(*plugins.RunRequest, plugins.ExecutionDatasource_RunServer) error - Executes the data processing task and streams results back to the client",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/cube2222/octosql/execution\"\n\t\"github.com/cube2222/octosql/physical\"\n\t\"github.com/cube2222/octosql/plugins/internal/plugins\"\n)\n\ntype physicalServer struct {\n\tplugins.UnimplementedDatasourceServer\n\tdatabase  physical.Database\n\tsocketDir string\n\twg        *sync.WaitGroup\n}\n\nfunc (s *physicalServer) Materialize(ctx context.Context, request *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\timpl, _, err := s.database.GetTable(ctx, request.TableContext.TableName, request.TableContext.Options)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't get table: %w\", err)\n\t}\n\n\tnode, err := impl.Materialize(\n\t\tctx,\n\t\tphysical.Environment{\n\t\t\tVariableContext: request.VariableContext.ToNativePhysicalVariableContext(),\n\t\t},\n\t\trequest.Schema.ToNativeSchema(),\n\t\tpushedDownPredicates,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't materialize datasource: %w\", err)\n\t}\n\n\tsocketName := ulid.MustNew(ulid.Now(), rand.Reader).String() + \".sock\"\n\tsocketPath := filepath.Join(s.socketDir, socketName)\n\tlog.Printf(\"Listening execution on %s\", socketPath)\n\tlis, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\texecServer := &executionServer{\n\t\tnode: node,\n\t}\n\ts.wg.Add(1)\n\n\tgrpcServer := grpc.NewServer()\n\tplugins.RegisterExecutionDatasourceServer(grpcServer, execServer)\n\n\tgo func() {\n\t\tdefer s.wg.Done()\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\treturn &plugins.MaterializeResponse{SocketPath: socketPath}, nil\n}\n\ntype executionServer struct {\n\tplugins.UnimplementedExecutionDatasourceServer\n\tnode execution.Node\n}\n\nfunc (e *executionServer) Run(request *plugins.RunRequest, stream plugins.ExecutionDatasource_RunServer) error {\n\tif err := e.node.Run(\n\t\texecution.ExecutionContext{\n\t\t\tContext:         stream.Context(),\n\t\t\tVariableContext: request.VariableContext.ToNativeExecutionVariableContext(),\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, record execution.Record) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tRecord: plugins.NativeRecordToProto(record),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send record to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tfunc(ctx execution.ProduceContext, msg execution.MetadataMessage) error {\n\t\t\tif err := stream.Send(&plugins.RunResponseMessage{\n\t\t\t\tMetadata: plugins.NativeMetadataMessageToProto(msg),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"couldn't send metadata message to stream: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t); err != nil {\n\t\treturn fmt.Errorf(\"couldn't run node: %w\", err)\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\tplugins \"github.com/example/your_plugin_package\"\n)\n\ntype physicalServer struct {\n\tdb        plugins.Database\n\tsocketDir string\n\twg        *sync.WaitGroup\n}\n\nfunc (s *physicalServer) Materialize(ctx context.Context, req *plugins.MaterializeRequest) (*plugins.MaterializeResponse, error) {\n\t// Simulate materializing a data source\n\tif req == nil || req.DataSource == \"\" {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"Invalid request: no data source provided\")\n\t}\n\n\t// Create socket directory if it doesn't exist\n\tif err := os.MkdirAll(s.socketDir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a Unix domain socket for execution server\n\tsocketPath := fmt.Sprintf(\"%s/%s\", s.socketDir, req.DataSource)\n\tlistener, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer listener.Close()\n\n\t// Start execution server in a separate goroutine\n\ts.wg.Add(1)\n\tgo func() {\n\t\t// Initialize execution server\n\t\texecServer := &executionServer{\n\t\t\tnode: execution.NewNode(),\n\t\t}\n\n\t\t// Start gRPC server for execution\n\t\texecServer.Serve(listener)\n\t\ts.wg.Done()\n\t}()\n\n\treturn &plugins.MaterializeResponse{DataSource: req.DataSource}, nil\n}\n\ntype executionServer struct {\n\tnode execution.Node\n}\n\nfunc (s *executionServer) Run(stream plugins.ExecutionDatasource_RunServer) error {\n\t// Simulate processing data\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Process data using the node\n\t\tresult, err := s.node.Process(req.Data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Stream results back to client\n\t\tif err := stream.Send(&plugins.ExecutionResult{Data: result}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Initialize physical server\n\tphysicalServer := &physicalServer{\n\t\tdb:        plugins.NewDatabase(), // Replace with actual database implementation\n\t\tsocketDir: \"/tmp/data_sources\",\n\t\twg:        &sync.WaitGroup{},\n\t}\n\n\t// Start gRPC server for physical server\n\tphysicalServerWg := &sync.WaitGroup{}\n\tphysicalServerWg.Add(1)\n\tgo func() {\n\t\tlis, err := net.Listen(\"unix\", \"/tmp/physical_server.sock\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t\t}\n\t\tsrv := grpc.NewServer()\n\t\tplugins.RegisterPhysicalServer(srv, physicalServer)\n\t\tlog.Printf(\"Physical server listening on /tmp/physical_server.sock\")\n\t\tif err := srv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Server exited with error: %v\", err)\n\t\t}\n\t\tphysicalServerWg.Done()\n\t}()\n\n\t// Wait for physical server to start\n\tphysicalServerWg.Wait()\n\n\t// Keep the main function running\n\tselect {}\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a gRPC server in Go that collects and processes metrics data using OpenTelemetry protocol, with capabilities for handling incoming requests, storing metrics, and managing server lifecycle.\n\nStruct Description: GRPCCollector is a gRPC server implementation that handles metrics collection following the OpenTelemetry protocol. It manages incoming requests, stores metrics data, tracks headers, and provides server control functionality.\n\nFields:\n\nField1: collpb.UnimplementedMetricsServiceServer - Embedded type to satisfy gRPC interface requirements\nField2: headersMu sync.Mutex - Mutex for thread-safe access to headers\nField3: headers metadata.MD - Stores incoming request headers\nField4: storage *Storage - Stores collected metrics data\nField5: resultCh <-chan ExportResult - Channel for receiving export results\nField6: listener net.Listener - Network listener for the server\nField7: srv *grpc.Server - gRPC server instance\n\nMethods:\n\nMethod1: NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) - Creates and starts a new gRPC collector instance\nMethod2: Shutdown() - Stops the gRPC server gracefully\nMethod3: Addr() net.Addr - Returns the network address the server is listening on\nMethod4: Collect() *Storage - Returns the storage containing collected metrics\nMethod5: Headers() map[string][]string - Returns collected headers in a thread-safe manner\nMethod6: Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) - Handles incoming metrics export requests and processes them",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"go.opentelemetry.io/proto/otlp/collector/metrics/v1\"\n)\n\ntype GRPCCollector struct {\n\tcollpb.UnimplementedMetricsServiceServer\n\n\theadersMu sync.Mutex\n\theaders   metadata.MD\n\tstorage   *Storage\n\n\tresultCh <-chan ExportResult\n\tlistener net.Listener\n\tsrv      *grpc.Server\n}\n\nfunc NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) {\n\tif endpoint == \"\" {\n\t\tendpoint = \"localhost:0\"\n\t}\n\n\tc := &GRPCCollector{\n\t\tstorage:  NewStorage(),\n\t\tresultCh: resultCh,\n\t}\n\n\tvar err error\n\tc.listener, err = net.Listen(\"tcp\", endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.srv = grpc.NewServer()\n\tcollpb.RegisterMetricsServiceServer(c.srv, c)\n\tgo func() { _ = c.srv.Serve(c.listener) }()\n\n\treturn c, nil\n}\n\nfunc (c *GRPCCollector) Shutdown() { c.srv.Stop() }\n\nfunc (c *GRPCCollector) Addr() net.Addr {\n\treturn c.listener.Addr()\n}\n\nfunc (c *GRPCCollector) Collect() *Storage {\n\treturn c.storage\n}\n\nfunc (c *GRPCCollector) Headers() map[string][]string {\n\tc.headersMu.Lock()\n\tdefer c.headersMu.Unlock()\n\treturn metadata.Join(c.headers)\n}\n\nfunc (c *GRPCCollector) Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) {\n\tc.storage.Add(req)\n\n\tif h, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tc.headersMu.Lock()\n\t\tc.headers = metadata.Join(c.headers, h)\n\t\tc.headersMu.Unlock()\n\t}\n\n\tif c.resultCh != nil {\n\t\tr := <-c.resultCh\n\t\tif r.Response == nil {\n\t\t\treturn &collpb.ExportMetricsServiceResponse{}, r.Err\n\t\t}\n\t\treturn r.Response, r.Err\n\t}\n\treturn &collpb.ExportMetricsServiceResponse{}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/trace/tracepb\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/metrics/metricspb\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/logs/logspb\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/trace/tracecontrol\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/metrics/metricstypes\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/logs/logstypes\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/trace/tracecontrol\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/metrics/metricstypes\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/logs/logstypes\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/trace/tracecontrol\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/metrics/metricstypes\"\n\t\"github.com/open-telemetry/opentelemetry-proto/otlp/logs/logstypes\"\n)\n\ntype GRPCCollector struct {\n\tcollpb.UnimplementedMetricsServiceServer\n\theadersMu  sync.Mutex\n\theaders    metadata.MD\n\tstorage    *Storage\n\tresultCh   <-chan ExportResult\n\tlistener   net.Listener\n\tsrv        *grpc.Server\n}\n\nfunc NewGRPCCollector(endpoint string, resultCh <-chan ExportResult) (*GRPCCollector, error) {\n\tlis, err := net.Listen(\"tcp\", endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsrv := grpc.NewServer()\n\tcollpb.RegisterMetricsServiceServer(srv, &GRPCCollector{\n\t\theaders:    metadata.MD{},\n\t\tstorage:    &Storage{},\n\t\tresultCh:   resultCh,\n\t\tlistener:   lis,\n\t\tsrv:        srv,\n\t})\n\n\tgo func() {\n\t\tif err := srv.Serve(lis, nil); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Server exited with error: %v\\n\", err)\n\t\t}\n\t}()\n\n\treturn &GRPCCollector{\n\t\theaders:    metadata.MD{},\n\t\tstorage:    &Storage{},\n\t\tresultCh:   resultCh,\n\t\tlistener:   lis,\n\t\tsrv:        srv,\n\t}, nil\n}\n\nfunc (s *GRPCCollector) Shutdown() {\n\ts.srv.Stop()\n}\n\nfunc (s *GRPCCollector) Addr() net.Addr {\n\treturn s.listener.Addr()\n}\n\nfunc (s *GRPCCollector) Collect() *Storage {\n\treturn s.storage\n}\n\nfunc (s *GRPCCollector) Headers() map[string][]string {\n\ts.headersMu.Lock()\n\tdefer s.headersMu.Unlock()\n\tresult := make(map[string][]string)\n\tfor k, v := range s.headers {\n\t\tresult[k] = v\n\t}\n\treturn result\n}\n\nfunc (s *GRPCCollector) Export(ctx context.Context, req *collpb.ExportMetricsServiceRequest) (*collpb.ExportMetricsServiceResponse, error) {\n\tmd, ok := metadata.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.Internal, \"failed to get metadata\")\n\t}\n\n\ts.headersMu.Lock()\n\ts.headers = md\n\ts.headersMu.Unlock()\n\n\t// Process metrics data\n\t// This is a placeholder for actual metric processing logic\n\t// In a real implementation, you would parse the metrics and store them in the storage\n\n\t// Simulate successful export\n\treturn &collpb.ExportMetricsServiceResponse{}, nil\n}"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, registers service implementations, and starts serving on a specified port with optional TLS credentials.\n\nFunction Description: The main function initializes and starts a gRPC server that hosts two services: a custom SpannerExecutorProxy service and a standard health check service. It validates required configuration parameters, sets up the network listener, creates the gRPC server instance, registers services, and begins serving requests.\n\nInput:\n- proxyPort (string): The port number on which the gRPC server should listen\n- spannerPort (string): The port number for Spanner service (validation only)\n- cert (string): Path to certificate file for TLS (validation only)\n- Additional client options are obtained internally through getClientOptionsForSysTests()\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Logs server startup information or errors to stdout\n\nNote: The function doesn't explicitly return values but may terminate the program with log.Fatal or log.Fatalf in case of errors during setup. Successful execution results in a continuously running gRPC server.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"cloud.google.com/go/spanner/executor/apiv1/executorpb\"\n\t\"cloud.google.com/go/spanner/test/cloudexecutor/executor\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/health\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\tif *proxyPort == \"\" {\n\t\tlog.Fatal(\"Proxy port need to be assigned in order to start worker proxy.\")\n\t}\n\tif *spannerPort == \"\" {\n\t\tlog.Fatal(\"Spanner proxyPort need to be assigned in order to start worker proxy.\")\n\t}\n\tif *cert == \"\" {\n\t\tlog.Fatalf(\"Certificate need to be assigned in order to start worker proxy.\")\n\t}\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%s\", *proxyPort))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\n\tclientOptions := getClientOptionsForSysTests()\n\tcloudProxyServer, err := executor.NewCloudProxyServer(context.Background(), clientOptions)\n\tif err != nil {\n\t\tlog.Fatalf(\"Creating Cloud Proxy Server failed: %v\", err)\n\t}\n\texecutorpb.RegisterSpannerExecutorProxyServer(grpcServer, cloudProxyServer)\n\n\thealthServer := health.NewServer()\n\tgrpc_health_v1.RegisterHealthServer(grpcServer, healthServer)\n\n\tlog.Printf(\"Server started on proxyPort:%s\\n\", *proxyPort)\n\terr = grpcServer.Serve(lis)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to start server on proxyPort: %s\\n\", *proxyPort)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/health/checker\"\n\t\"google.golang.org/grpc/health/grpchealthv1beta1\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/reflection/grpcreflectionv1beta1\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n)\n\nvar (\n\tproxyPort string\n\tspannerPort string\n\tcert string\n)\n\nfunc init() {\n\tflag.StringVar(&proxyPort, \"proxy-port\", \"50051\", \"The port number for the gRPC server\")\n\tflag.StringVar(&spannerPort, \"spanner-port\", \"50052\", \"The port number for the Spanner service\")\n\tflag.StringVar(&cert, \"cert\", \"\", \"Path to certificate file for TLS\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif proxyPort == \"\" {\n\t\tlog.Fatal(\"proxyPort is required\")\n\t}\n\n\tif spannerPort == \"\" {\n\t\tlog.Fatal(\"spannerPort is required\")\n\t}\n\n\tif cert != \"\" {\n\t\tif _, err := os.Stat(cert); os.IsNotExist(err) {\n\t\t\tlog.Fatalf(\"Certificate file %s does not exist\", cert)\n\t\t}\n\t}\n\n\t// Set up TLS credentials if provided\n\tvar serverCreds grpc.Credentials\n\tif cert != \"\" {\n\t\tcreds, err := tls.LoadX509KeyPair(cert, cert)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load TLS credentials: %v\", err)\n\t\t}\n\t\tserverCreds = tls.NewServerCredentials(creds)\n\t} else {\n\t\tserverCreds = insecure.NewCredentials()\n\t}\n\n\t// Create listener\n\tlistener, err := net.Listen(\"tcp\", \":\"+proxyPort)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on port %s: %v\", proxyPort, err)\n\t}\n\n\t// Create gRPC server\n\tserver := grpc.NewServer(\n\t\tgrpc.Creds(serverCreds),\n\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\tmd, ok := metadata.FromContext(ctx)\n\t\t\tif ok {\n\t\t\t\tmd.Set(\"x-forwarded-for\", \"127.0.0.1\")\n\t\t\t}\n\t\t\treturn handler(ctx, req)\n\t\t}),\n\t)\n\n\t// Register services\n\tgrpchealthv1beta1.RegisterHealthServer(server, &healthServer{})\n\tgrpcreflectionv1beta1.RegisterServer(server, &reflectionServer{})\n\t// Register custom SpannerExecutorProxy service\n\t// Assuming SpannerExecutorProxyService is defined elsewhere\n\t// spannerExecutorProxyService := new(SpannerExecutorProxyService)\n\t// spannerExecutorProxyService.Register(server)\n\n\t// Start server\n\tlog.Printf(\"Starting gRPC server on port %s\", proxyPort)\n\tif err := server.Serve(listener, nil); err != nil {\n\t\tlog.Fatalf(\"Server exited unexpectedly: %v\", err)\n\t}\n}\n\ntype healthServer struct{}\n\nfunc (s *healthServer) Check(_ *emptypb.Empty, _ *checker.CheckRequest) (*checker.CheckResponse, error) {\n\treturn &checker.CheckResponse{Status: checker.Serving}, nil\n}\n\ntype reflectionServer struct{}\n\nfunc (s *reflectionServer) Serve(_ *grpcreflectionv1beta1.Server, _ *grpcreflectionv1beta1.ServeRequest) (*grpcreflectionv1beta1.ServeResponse, error) {\n\treturn &grpcreflectionv1beta1.ServeResponse{}, nil\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and handles gRPC communications.\n\nFunction Description: The main function sets up a gRPC server that listens on port 50051, registers the gRPC service implementation, and starts serving requests. It includes error handling for server setup and operation.\n\nInput: None (The function takes no explicit parameters but uses a hardcoded port \":50051\" for listening)\n\nOutput: None (The function doesn't return anything but will log fatal errors if the server fails to start or serve)\n\nNote: The actual gRPC service implementation (greeter struct) is not shown in the reference code but would need to be defined separately to implement the proto.GreeterServer interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"grpc-hello/proto\"\n)\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\treflection.Register(server)\n\tproto.RegisterGreeterServer(server, &greeter{})\n\n\tfmt.Println(\"grpc server start ...\")\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"hello-world/proto\"\n)\n\ntype server struct{}\n\nfunc (s *server) SayHello(req *proto.HelloRequest, res *proto.HelloResponse) error {\n\tres.Message = \"Hello \" + req.Name\n\treturn nil\n}\n\nfunc main() {\n\tport := flag.String(\"port\", \":50051\", \"The port the server runs on\")\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", *port)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer()\n\tproto.RegisterGreeterServer(srv, &server{})\n\n\tlog.Printf(\"Server listening at %v\", lis.Addr())\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Create a gRPC server for chaincode communication in a Hyperledger Fabric network, supporting both secure (TLS) and insecure connections, with the ability to handle chaincode registration and message echoing.\n\nStruct Description: ccSrv represents a chaincode gRPC server that listens for incoming connections, handles chaincode registration, and echoes received messages back to the client.\n\nFields:\nl: net.Listener - The network listener for incoming connections\ngrpcSrv: *grpc.Server - The gRPC server instance\nt: *testing.T - Testing context for assertions\nexpectedCCname: string - The expected chaincode name for validation during registration\n\nMethods:\nRegister: (stream pb.ChaincodeSupport_RegisterServer) -> error - Handles the chaincode registration stream, validates the chaincode name, and echoes messages back to the client\nstop: () -> () - Stops the gRPC server and closes the listener\nnewCCServer: (t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) -> *ccSrv - Creates and configures a new chaincode server instance with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\tpb \"github.com/hyperledger/fabric-protos-go-apiv2/peer\"\n\t\"github.com/hyperledger/fabric/common/crypto/tlsgen\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (cs *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tmsg, err := stream.Recv()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequire.Equal(cs.t, pb.ChaincodeMessage_REGISTER.String(), msg.Type.String())\n\tchaincodeID := &pb.ChaincodeID{}\n\terr = proto.Unmarshal(msg.Payload, chaincodeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequire.Equal(cs.t, cs.expectedCCname, chaincodeID.Name)\n\tfor {\n\t\tmsg, _ = stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = stream.Send(msg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (cs *ccSrv) stop() {\n\tcs.grpcSrv.Stop()\n\tcs.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar s *grpc.Server\n\tif withTLS {\n\t\tkeyPair, err := ca.NewServerCertKeyPair(\"localhost\")\n\t\trequire.NoError(t, err)\n\t\tcert, err := tls.X509KeyPair(keyPair.Cert, keyPair.Key)\n\t\trequire.NoError(t, err)\n\t\ttlsConf := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tClientCAs:    x509.NewCertPool(),\n\t\t}\n\t\ttlsConf.ClientCAs.AppendCertsFromPEM(ca.CertBytes())\n\t\ts = grpc.NewServer(grpc.Creds(credentials.NewTLS(tlsConf)))\n\t} else {\n\t\ts = grpc.NewServer()\n\t}\n\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", \"\", port))\n\trequire.NoError(t, err, \"%v\", err)\n\treturn &ccSrv{\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t\tl:              l,\n\t\tgrpcSrv:        s,\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/test/benchmarks/ci\"\n)\n\ntype ccSrv struct {\n\tl          net.Listener\n\tgrpcSrv    *grpc.Server\n\tt          *testing.T\n\texpectedCCname string\n}\n\nfunc (s *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tfor {\n\t\tmsg, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif msg.GetName() != s.expectedCCname {\n\t\t\ts.t.Errorf(\"Expected chaincode name %s, got %s\", s.expectedCCname, msg.GetName())\n\t\t}\n\t\tstream.Send(&pb.ChaincodeSupport_EchoResponse{Message: msg.GetMessage()})\n\t}\n}\n\nfunc (s *ccSrv) stop() {\n\ts.grpcSrv.Stop()\n\ts.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgrpcSrv := grpc.NewServer()\n\tpb.RegisterChaincodeSupportServer(grpcSrv, &ccSrv{l: l, grpcSrv: grpcSrv, t: t, expectedCCname: expectedCCname})\n\tif withTLS {\n\t\t// TLS setup would go here\n\t}\n\treturn &ccSrv{l: l, grpcSrv: grpcSrv, t: t, expectedCCname: expectedCCname}\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests on a specified TCP port and registers a service to handle those requests.\n\nFunction Description: The function sets up a gRPC server that listens on a given TCP port, creates a new gRPC server instance, registers a service to handle incoming requests, and starts the server in a goroutine. The server runs until it is stopped or encounters an error.\n\nInput: None (The port is hardcoded as \":50052\" in the example, but could be parameterized)\n\nOutput: None (The function runs indefinitely until stopped or an error occurs, with side effects of starting the gRPC server)\n\nNote: The actual service implementation (ChannelzService) would need to be defined elsewhere and imported. The example shows the server setup pattern but assumes the service is already implemented.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tdefer lis.Close()\n\ts := grpc.NewServer()\n\tservice.RegisterChannelzServiceToServer(s)\n\tgo s.Serve(lis)\n\tdefer s.Stop()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"net\"\n)\n\ntype ChannelzService struct{}\n\nfunc (s *ChannelzService) SomeMethod(ctx interface{}, in *struct{}) (out *struct{}, err error) {\n\treturn &struct{}{}, nil\n}\n\nfunc startServer() {\n\tlis, err := net.Listen(\"tcp\", \":50052\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tsrv := grpc.NewServer()\n\t// Register the service\n\t// Assuming the service is already implemented and imported\n\t// Replace with actual service registration\n\t// Example: ChannelzService.Register(srv)\n\tgo func() {\n\t\tif err := srv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Server exited unexpectedly: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc main() {\n\tstartServer()\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a gRPC server in Go that listens for incoming requests and handles graceful shutdown upon receiving termination signals.\n\nFunction Description: The function `Run` initializes and starts a gRPC server with the provided network options. It sets up a network listener, creates a gRPC server instance, registers a key service, and handles graceful shutdown upon receiving interrupt or termination signals.\n\nInput: \n- `opts` [struct] - Configuration options for the server, containing:\n  - `Network` [string] - The network type (e.g., \"tcp\")\n  - `Address` [string] - The address to listen on (e.g., \":50051\")\n  - `Prompt` [interface{}] - Optional prompt for the key service\n\nOutput: \n- `error` - Returns an error if the server fails to start or encounters issues during execution",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/getsops/sops/v3/keyservice\"\n\t\"google.golang.org/grpc\"\n)\nfunc Run(opts Opts) error {\n\tlis, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer lis.Close()\n\tgrpcServer := grpc.NewServer()\n\tkeyservice.RegisterKeyServiceServer(grpcServer, keyservice.Server{\n\t\tPrompt: opts.Prompt,\n\t})\n\n\tsigc := make(chan os.Signal, 1)\n\tsignal.Notify(sigc, os.Interrupt, os.Kill, syscall.SIGTERM)\n\tgo func(c chan os.Signal) {\n\t\tsig := <-c\n\t\tlis.Close()\n\t\tos.Exit(0)\n\t}(sigc)\n\treturn grpcServer.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype Server struct {\n\tkeyService\n}\n\ntype keyService interface {\n\tHello(ctx context.Context, in *HelloRequest) (*HelloResponse, error)\n}\n\ntype HelloRequest struct {\n\tName string\n}\n\ntype HelloResponse struct {\n\tMessage string\n}\n\nfunc (s *Server) Hello(ctx context.Context, in *HelloRequest) (*HelloResponse, error) {\n\treturn &HelloResponse{Message: \"Hello, \" + in.Name}, nil\n}\n\nfunc Run(opts struct {\n\tNetwork string\n\tAddress string\n\tPrompt  interface{}\n}) error {\n\tlis, err := net.Listen(opts.Network, opts.Address)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsrv := grpc.NewServer()\n\tkeyService := &Server{}\n\tgrpc.RegisterKeyServiceServer(srv, keyService)\n\n\t// Handle graceful shutdown\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, os.Interrupt, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-stop\n\t\tsrv.GracefulStop()\n\t\tfmt.Println(\"Shutting down gRPC server...\")\n\t}()\n\n\t// Start the server\n\tfmt.Printf(\"gRPC server listening on %s\\n\", opts.Address)\n\tif err := srv.Serve(lis, grpc.Creds(insecure.NewCredentials())); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the server to stop\n\t<-stop\n\treturn nil\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Go struct that implements a mock gRPC server proxy for testing purposes, with start and stop functionality.\n\nStruct Description: The ProxyGRPCMock struct provides a mock implementation of a gRPC server that can be started and stopped programmatically. It allows for custom gRPC service implementations and registration routines to be injected for testing purposes.\n\nFields:\n- GRPCImplementer: [interface{}] - The implementation of the gRPC service handler\n- GRPCRegister: [func(s *grpc.Server, srv interface{})] - The function to register the gRPC service implementation with the server\n- listener: [net.Listener] - The network listener for the gRPC server\n\nMethods:\n- Start: [func(URL string) error] -> [error] - Starts the gRPC server on the specified URL (format \"scheme://path\"). Returns error if initialization fails.\n- Stop: [func() error] -> [error] - Stops the gRPC server by closing the listener. Returns error if no listener exists or closing fails.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"google.golang.org/grpc\"\n)\n\ntype ProxyGRPCMock struct {\n\tGRPCImplementer interface{}\n\tGRPCRegister func(s *grpc.Server, srv interface{})\n\tlistener net.Listener\n}\n\nfunc (p *ProxyGRPCMock) Start(URL string) error {\n\tif p.GRPCImplementer == nil {\n\t\treturn fmt.Errorf(\"Missing gRPC handler\")\n\t}\n\n\tif p.GRPCRegister == nil {\n\t\treturn fmt.Errorf(\"Missing gRPC registration routine\")\n\t}\n\n\turl, err := url.Parse(URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tl, err := net.Listen(url.Scheme, url.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.listener = l\n\n\tgrpcServer := grpc.NewServer()\n\tp.GRPCRegister(grpcServer, p.GRPCImplementer)\n\n\tgo func() {\n\t\tgrpcServer.Serve(l)\n\t}()\n\n\treturn nil\n}\n\nfunc (p *ProxyGRPCMock) Stop() error {\n\tif p.listener == nil {\n\t\treturn fmt.Errorf(\"Missing proxy listener\")\n\t}\n\n\treturn p.listener.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype ProxyGRPCMock struct {\n\tGRPCImplementer interface{}\n\tGRPCRegister    func(s *grpc.Server, srv interface{})\n\tlistener        net.Listener\n\tserver          *grpc.Server\n}\n\nfunc (p *ProxyGRPCMock) Start(url string) error {\n\tif p.GRPCImplementer == nil || p.GRPCRegister == nil {\n\t\treturn nil\n\t}\n\n\tsrv := grpc.NewServer()\n\tp.GRPCRegister(srv, p.GRPCImplementer)\n\n\tlis, err := net.Listen(\"tcp\", url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.listener = lis\n\tp.server = srv\n\n\tgo func() {\n\t\tif err := p.server.Serve(lis, nil); err != nil {\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (p *ProxyGRPCMock) Stop() error {\n\tif p.server == nil || p.listener == nil {\n\t\treturn nil\n\t}\n\n\tp.server.Stop()\n\treturn p.listener.Close()\n}"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles various WebSocket operations including checking user online status, sending messages to users, broadcasting messages to all users, and retrieving user lists.\n\nStruct Description: The `server` struct implements the gRPC service interface defined in the protobuf file, providing concrete implementations for WebSocket operations.\n\nFields:\n- UnimplementedAccServerServer: [protobuf.UnimplementedAccServerServer] - Embedded type to ensure forward compatibility with gRPC service updates\n\nMethods:\n- QueryUsersOnline: [Name](ctx context.Context, req *protobuf.QueryUsersOnlineReq) -> (*protobuf.QueryUsersOnlineRsp, error) - Checks if a specified user is currently online\n- SendMsg: [Name](ctx context.Context, req *protobuf.SendMsgReq) -> (*protobuf.SendMsgRsp, error) - Sends a message to a specific user\n- SendMsgAll: [Name](ctx context.Context, req *protobuf.SendMsgAllReq) -> (*protobuf.SendMsgAllRsp, error) - Broadcasts a message to all connected users\n- GetUserList: [Name](ctx context.Context, req *protobuf.GetUserListReq) -> (*protobuf.GetUserListRsp, error) - Retrieves the list of currently connected users\n- Init: [Name]() -> () - Initializes and starts the gRPC server with configuration from Viper",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/link1st/gowebsocket/v2/common\"\n\t\"github.com/link1st/gowebsocket/v2/models\"\n\t\"github.com/link1st/gowebsocket/v2/protobuf\"\n\t\"github.com/link1st/gowebsocket/v2/servers/websocket\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedAccServerServer\n}\n\nfunc (s *server) QueryUsersOnline(c context.Context, req *protobuf.QueryUsersOnlineReq) (rsp *protobuf.QueryUsersOnlineRsp, err error) {\n\trsp = &protobuf.QueryUsersOnlineRsp{}\n\tonline := websocket.CheckUserOnline(req.GetAppID(), req.GetUserID())\n\tsetErr(req, common.OK, \"\")\n\trsp.Online = online\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsg(c context.Context, req *protobuf.SendMsgReq) (rsp *protobuf.SendMsgRsp, err error) {\n\trsp = &protobuf.SendMsgRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\tsendResults, err := websocket.SendUserMessageLocal(req.GetAppID(), req.GetUserID(), data)\n\tif err != nil {\n\t\tsetErr(rsp, common.ServerError, \"\")\n\t\treturn rsp, nil\n\t}\n\tif !sendResults {\n\t\tsetErr(rsp, common.OperationFailure, \"\")\n\t\treturn rsp, nil\n\t}\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) SendMsgAll(c context.Context, req *protobuf.SendMsgAllReq) (rsp *protobuf.SendMsgAllRsp, err error) {\n\trsp = &protobuf.SendMsgAllRsp{}\n\tdata := models.GetMsgData(req.GetUserID(), req.GetSeq(), req.GetCms(), req.GetMsg())\n\twebsocket.AllSendMessages(req.GetAppID(), req.GetUserID(), data)\n\tsetErr(rsp, common.OK, \"\")\n\treturn rsp, nil\n}\n\nfunc (s *server) GetUserList(c context.Context, req *protobuf.GetUserListReq) (rsp *protobuf.GetUserListRsp, err error) {\n\trsp = &protobuf.GetUserListRsp{}\n\tuserList := websocket.GetUserList(req.GetAppID())\n\tsetErr(rsp, common.OK, \"\")\n\trsp.UserID = userList\n\treturn rsp, nil\n}\n\nfunc Init() {\n\trpcPort := viper.GetString(\"app.rpcPort\")\n\tlis, err := net.Listen(\"tcp\", \":\"+rpcPort)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tprotobuf.RegisterAccServerServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/spf13/viper\"\n\t\"your/protobuf/path\"\n)\n\ntype server struct {\n\tprotobuf.UnimplementedAccServerServer\n}\n\nfunc (s *server) QueryUsersOnline(ctx context.Context, req *protobuf.QueryUsersOnlineReq) (*protobuf.QueryUsersOnlineRsp, error) {\n\t// Implement logic to check if a user is online\n\treturn &protobuf.QueryUsersOnlineRsp{Online: true}, nil\n}\n\nfunc (s *server) SendMsg(ctx context.Context, req *protobuf.SendMsgReq) (*protobuf.SendMsgRsp, error) {\n\t// Implement logic to send a message to a specific user\n\treturn &protobuf.SendMsgRsp{Success: true}, nil\n}\n\nfunc (s *server) SendMsgAll(ctx context.Context, req *protobuf.SendMsgAllReq) (*protobuf.SendMsgAllRsp, error) {\n\t// Implement logic to broadcast a message to all users\n\treturn &protobuf.SendMsgAllRsp{Success: true}, nil\n}\n\nfunc (s *server) GetUserList(ctx context.Context, req *protobuf.GetUserListReq) (*protobuf.GetUserListRsp, error) {\n\t// Implement logic to retrieve the list of connected users\n\treturn &protobuf.GetUserListRsp{Users: []string{\"user1\", \"user2\"}}, nil\n}\n\nfunc (s *server) Init() {\n\tviper.SetConfigFile(\"config.yaml\")\n\tif err := viper.ReadInConfig(); err != nil {\n\t\tlog.Fatalf(\"Error reading config file: %v\", err)\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \":\"+viper.GetString(\"grpc.port\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer()\n\tprotobuf.RegisterAccServerServer(srv, &server{})\n\tlog.Printf(\"gRPC server listening on port %s\", viper.GetString(\"grpc.port\"))\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server exited with error: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a gRPC server in Go that handles authentication services, connects to Redis for data storage, and exposes Prometheus metrics for monitoring.\n\nStruct Description: The authHandler struct implements the AuthServiceServer interface and provides authentication functionality using Redis as the backend storage.\n\nFields:\nredisClient: *redis.Client - The Redis client used for data storage and retrieval\n\nMethods:\nServe: (listener net.Listener) -> error - Starts the gRPC server and begins listening for incoming requests\nRegisterWithPrometheus: () -> error - Registers gRPC and custom metrics with Prometheus\nStartMetricsServer: () -> error - Starts an HTTP server for Prometheus metrics collection\n\nNote: The struct implements all required gRPC service methods defined in the auth.proto file, though these are not shown in the reference code. The main functionality includes:\n1. Setting up a gRPC server with Prometheus monitoring\n2. Establishing Redis connection\n3. Combining gRPC and HTTP servers for both RPC calls and metrics collection\n4. Proper error handling and logging throughout the process",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/go-redis/redis\"\n\t\"github.com/grpc-ecosystem/go-grpc-prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"google.golang.org/grpc\"\n\n\t\"github.com/lucperkins/colossus/proto/auth\"\n)\nfunc main() {\n\tlog.Printf(\"Starting up the gRPC auth server on localhost:%d\", PORT)\n\n\tlog.Print(\"Attempting to connect to Redis\")\n\n\tredisClient := redis.NewClient(&redis.Options{\n\t\tAddr: \"colossus-redis-cluster:6379\",\n\t})\n\n\t_, err := redisClient.Ping().Result()\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not connect to Redis cluster: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully connected to Redis\")\n\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", PORT))\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tlog.Print(\"Successfully created TCP listener\")\n\n\tserver := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor),\n\t)\n\n\tauthServer := authHandler{\n\t\tredisClient: redisClient,\n\t}\n\n\thttpServer := &http.Server{\n\t\tHandler: promhttp.HandlerFor(metricsRegistry, promhttp.HandlerOpts{}),\n\t\tAddr:    fmt.Sprintf(\"0.0.0.0:%d\", PROMETHEUS_PORT),\n\t}\n\n\tauth.RegisterAuthServiceServer(server, &authServer)\n\n\tgrpcMetrics.InitializeMetrics(server)\n\n\tmetricsRegistry.MustRegister(grpcMetrics, authCounter, failCounter)\n\n\tlog.Print(\"Successfully registered with Prometheus\")\n\n\tgo func() {\n\t\tlog.Print(\"Starting up HTTP server for Prometheus metrics collection\")\n\n\t\tif err := httpServer.ListenAndServe(); err != nil {\n\t\t\tlog.Fatalf(\"Unable to start HTTP server for Prometheus metrics: %v\", err)\n\t\t}\n\t}()\n\n\tlog.Fatal(server.Serve(listener))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection/v3\"\n\t\"redis\"\n)\n\ntype authHandler struct {\n\tredisClient *redis.Client\n}\n\nfunc (a *authHandler) Serve(listener net.Listener) error {\n\tsrv := grpc.NewServer()\n\treflection.Register(srv)\n\t// Register gRPC service\n\t// Assume AuthServiceServer is implemented here\n\t// authService.RegisterAuthServiceServer(srv, a)\n\tlog.Println(\"gRPC server started\")\n\tif err := srv.Serve(listener); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (a *authHandler) RegisterWithPrometheus() error {\n\t// Register Prometheus metrics\n\tprometheus.MustRegister(\n\t\tcollectors.NewGoCollector(),\n\t\tcollectors.NewProcessCollector(collectors.ProcessCollectorOpts{}),\n\t)\n\t// Add custom metrics as needed\n\treturn nil\n}\n\nfunc (a *authHandler) StartMetricsServer() error {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/metrics\", promhttp.HandlerFor(prometheus.DefaultGatherer, promhttp.HandlerOpts{}))\n\tserver := &http.Server{\n\t\tAddr:           \":8081\",\n\t\tHandler:        mux,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\tlog.Println(\"Starting metrics server on :8081\")\n\tif err := server.ListenAndServe(\":8081\", nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\t// Parse command line flags\n\tportFlag := flag.String(\"port\", \"50051\", \"Port for gRPC server\")\n\tmetricsPortFlag := flag.String(\"metrics-port\", \"8081\", \"Port for Prometheus metrics server\")\n\tflag.Parse()\n\n\t// Initialize Redis client\n\tredisClient := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// Create auth handler\n\tauthHandler := &authHandler{\n\t\tredisClient: redisClient,\n\t}\n\n\t// Start gRPC server\n\tlistener, err := net.Listen(\"tcp\", \":\"+*portFlag)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\tgo func() {\n\t\tif err := authHandler.Serve(listener); err != nil {\n\t\t\tlog.Fatalf(\"gRPC server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Register with Prometheus\n\tif err := authHandler.RegisterWithPrometheus(); err != nil {\n\t\tlog.Fatalf(\"Failed to register with Prometheus: %v\", err)\n\t}\n\n\t// Start metrics server\n\tif err := authHandler.StartMetricsServer(); err != nil {\n\t\tlog.Fatalf(\"Failed to start metrics server: %v\", err)\n\t}\n\n\t// Keep the main function running\n\ttime.Sleep(time.Second * 1000000000)\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles DNS queries and watch functionality, supporting TLS encryption and OpenTracing for distributed tracing.\n\nStruct Description: ServergRPC is a gRPC server implementation that processes DNS queries and provides watch capabilities. It manages server lifecycle, handles TLS configuration, and integrates with tracing systems.\n\nFields:\n\nServer: [*Server] - Embedded DNS server instance that handles core DNS functionality\ngrpcServer: [*grpc.Server] - The gRPC server instance\nlistenAddr: [net.Addr] - Network address the server is listening on\ntlsConfig: [*tls.Config] - TLS configuration for secure connections\nwatch: [watch.Watcher] - Watcher instance for handling watch requests\n\nMethods:\n\nNewServergRPC: [func(addr string, group []*Config) (*ServergRPC, error)] -> Creates a new ServergRPC instance with the given address and configuration group\nServe: [func(l net.Listener) error] -> Starts the gRPC server on the provided listener\nQuery: [func(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error)] -> Handles incoming DNS query requests\nWatch: [func(stream pb.DnsService_WatchServer) error] -> Handles watch stream requests\nStop: [func() error] -> Gracefully stops the server and watcher\nShutdown: [func() error] -> Immediately stops the server without waiting for connections to close",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/coredns/coredns/pb\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/miekg/dns\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype ServergRPC struct {\n\t*Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ts, err := NewServer(addr, group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar tlsConfig *tls.Config\n\tfor _, conf := range s.zones {\n\t\ttlsConfig = conf.TLSConfig\n\t}\n\treturn &ServergRPC{Server: s, tlsConfig: tlsConfig, watch: watch.NewWatcher(watchables(s.zones))}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\ts.m.Lock()\n\ts.listenAddr = l.Addr()\n\ts.m.Unlock()\n\n\tif s.Tracer() != nil {\n\t\tonlyIfParent := func(parentSpanCtx opentracing.SpanContext, method string, req, resp interface{}) bool {\n\t\t\treturn parentSpanCtx != nil\n\t\t}\n\t\tintercept := otgrpc.OpenTracingServerInterceptor(s.Tracer(), otgrpc.IncludingSpans(onlyIfParent))\n\t\ts.grpcServer = grpc.NewServer(grpc.UnaryInterceptor(intercept))\n\t} else {\n\t\ts.grpcServer = grpc.NewServer()\n\t}\n\n\tpb.RegisterDnsServiceServer(s.grpcServer, s)\n\n\tif s.tlsConfig != nil {\n\t\tl = tls.NewListener(l, s.tlsConfig)\n\t}\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tmsg := new(dns.Msg)\n\terr := msg.Unpack(in.Msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, ok := peer.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, errors.New(\"no peer in gRPC context\")\n\t}\n\n\ta, ok := p.Addr.(*net.TCPAddr)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no TCP peer in gRPC context: %v\", p.Addr)\n\t}\n\n\tw := &gRPCresponse{localAddr: s.listenAddr, remoteAddr: a, Msg: msg}\n\n\ts.ServeDNS(ctx, w, msg)\n\n\tpacked, err := w.Msg.Pack()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.DnsPacket{Msg: packed}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\treturn s.watch.Watch(stream)\n}\n\nfunc (s *ServergRPC) Stop() (err error) {\n\ts.m.Lock()\n\tdefer s.m.Unlock()\n\tif s.watch != nil {\n\t\ts.watch.Stop()\n\t}\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.GracefulStop()\n\t}\n\treturn\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.Stop()\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/opentracing/opentracing-go/log\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype ServergRPC struct {\n\tServer     *Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\tserver := NewServer(group)\n\tgrpcServer := grpc.NewServer(\n\t\tgrpc.KeepaliveParams(30*time.Second),\n\t\tgrpc.KeepaliveMinTimeBetweenRequests(10*time.Second),\n\t\tgrpc.KeepaliveMaxInterval(60*time.Second),\n\t)\n\treflection.Register(grpcServer)\n\treturn &ServergRPC{\n\t\tServer:     server,\n\t\tgrpcServer: grpcServer,\n\t\tlistenAddr: net.Listen(\"tcp\", addr),\n\t}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\ts.grpcServer = grpc.NewServer(\n\t\tgrpc.KeepaliveParams(30*time.Second),\n\t\tgrpc.KeepaliveMinTimeBetweenRequests(10*time.Second),\n\t\tgrpc.KeepaliveMaxInterval(60*time.Second),\n\t)\n\treflection.Register(s.grpcServer)\n\tif s.tlsConfig != nil {\n\t\ts.grpcServer = grpc.NewServer(\n\t\t\tgrpc.Creds(insecure.NewCredentials()),\n\t\t\tgrpc.KeepaliveParams(30*time.Second),\n\t\t\tgrpc.KeepaliveMinTimeBetweenRequests(10*time.Second),\n\t\t\tgrpc.KeepaliveMaxInterval(60*time.Second),\n\t\t)\n\t}\n\tif err := s.grpcServer.Serve(l); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"Query\")\n\tdefer span.Finish()\n\tspan.LogFields(log.String(\"method\", \"Query\"), log.Int(\"request_id\", in.RequestID))\n\treturn s.Server.Query(ctx, in)\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"Watch\")\n\tdefer span.Finish()\n\tspan.LogFields(log.String(\"method\", \"Watch\"), log.Int(\"request_id\", stream.Context().Value(\"request_id\")))\n\treturn s.watch.Watch(stream)\n}\n\nfunc (s *ServergRPC) Stop() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.GracefulStop()\n\t}\n\tif s.watch != nil {\n\t\ts.watch.Stop()\n\t}\n\treturn nil\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.Stop()\n\t}\n\tif s.watch != nil {\n\t\ts.watch.Shutdown()\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Implement a gRPC server in Go that collects and manages execution statistics for tasks in a distributed system.\n\nStruct Description: The Executor struct represents a gRPC server that handles execution statistics collection and management. It maintains a list of execution stats and provides methods to serve gRPC requests and process incoming statistics.\n\nFields:\nstats: []*pb.ExecutionStat - A slice of pointers to ExecutionStat protobuf messages, storing the collected execution statistics.\n\nMethods:\nserveGrpc: (listener net.Listener) -> () - Starts a gRPC server on the given listener, registering the Executor as a GleamExecutorServer implementation.\nCollectExecutionStatistics: (stream pb.GleamExecutor_CollectExecutionStatisticsServer) -> error - Processes a stream of execution statistics, updating the internal stats collection when matching task IDs are found. Returns nil on successful completion or an error if stream processing fails.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/chrislusf/gleam/pb\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Executor struct {\n\tstats []*pb.ExecutionStat\n}\n\nfunc (exe *Executor) serveGrpc(listener net.Listener) {\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterGleamExecutorServer(grpcServer, exe)\n\tgrpcServer.Serve(listener)\n}\n\nfunc (exe *Executor) CollectExecutionStatistics(stream pb.GleamExecutor_CollectExecutionStatisticsServer) error {\n\tfor {\n\t\tstats, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, stat := range stats.Stats {\n\t\t\tfor i, current := range exe.stats {\n\t\t\t\tif current.StepId == stat.StepId && current.TaskId == stat.TaskId {\n\t\t\t\t\texe.stats[i] = stat\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"net\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n)\n\ntype ExecutionStat struct {\n\tTaskID       string\n\tStartTime    int64\n\tEndTime      int64\n\tExecutionTime int64\n\tSuccess      bool\n\tErrorMessage string\n}\n\ntype Executor struct {\n\tstats []*ExecutionStat\n}\n\nfunc (e *Executor) serveGrpc(listener net.Listener) error {\n\tsrv := grpc.NewServer()\n\tpb.RegisterGleamExecutorServer(srv, e)\n\tfmt.Printf(\"GPRC server listening on %s\\n\", listener.Addr())\n\tif err := srv.Serve(listener); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) CollectExecutionStatistics(stream pb.GleamExecutor_CollectExecutionStatisticsServer) error {\n\tfor {\n\t\t_, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Process the received execution stat\n\t\te.stats = append(e.stats, &ExecutionStat{\n\t\t\tTaskID:       \"task123\",\n\t\t\tStartTime:    time.Now().UnixNano(),\n\t\t\tEndTime:      time.Now().UnixNano(),\n\t\t\tExecutionTime: int64(time.Now().UnixNano() - time.Now().UnixNano()),\n\t\t\tSuccess:      true,\n\t\t\tErrorMessage: \"\",\n\t\t})\n\t\tif err := stream.Send(&pb.ExecutionStat{\n\t\t\tTaskId:       \"task123\",\n\t\t\tStartTime:    1234567890,\n\t\t\tEndTime:      1234567891,\n\t\t\tExecutionTime: 1,\n\t\t\tSuccess:      true,\n\t\t\tErrorMessage: \"\",\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Start a gRPC server\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trunner := &Executor{}\n\tif err := runner.serveGrpc(listener); err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a function that sets up and starts a gRPC server with reflection capabilities, registering multiple services and handling incoming requests.\n\nFunction Description: The Serve function initializes a gRPC server on a specified TCP port, registers multiple service implementations (RouteGuide and Foobar), enables server reflection for debugging, and starts listening for incoming RPC requests. It also demonstrates protobuf JSON marshaling of a well-known type.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but runs indefinitely to serve requests)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n)\nfunc Serve() {\n\tlis, err := net.Listen(\"tcp\", \":5001\")\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"server: failed to create listener: %v\", err)\n\t}\n\n\te, _ := protojson.Marshal(&WellKnownRequest{Timestamp: timestamppb.Now()})\n\tfmt.Printf(\"string(e) = %+v\\n\", string(e))\n\n\ts := newServer()\n\tgs := grpc.NewServer()\n\tRegisterRouteGuideServer(gs, s)\n\tRegisterFoobarServer(gs, s)\n\treflection.Register(gs)\n\tgs.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection/grpcreflection\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n\t\"google.golang.org/grpc/reflection/pb\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype server struct {\n\trouteGuideService\n\tfoobarService\n}\n\nfunc (s *server) Serve() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tsrv := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(func(ctx *grpc.Context, req, resp interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (err error) {\n\t\t\t// Example of JSON marshaling of a well-known type\n\t\t\tjsonMarshaler := protojson.Unmarshaler{}\n\t\t\tjsonData, _ := jsonMarshaler.Marshal(&wrapperspb.StringValue{Value: \"Hello from gRPC reflection!\"})\n\t\t\tfmt.Println(string(jsonData))\n\t\t\treturn handler(ctx, req, resp, info)\n\t\t}),\n\t\tgrpc.EnableFlowControl,\n\t\tgrpc.MaxRecvMsgSize(int(1024*1024*10)),\n\t\tgrpc.MaxSendMsgSize(int(1024*1024*10)),\n\t)\n\t// Register reflection service\n\tgrpcreflection.Register(srv)\n\t// Register services\n\tRegisterRouteGuideService(srv, &s.routeGuideService)\n\tRegisterFoobarService(srv, &s.foobarService)\n\tlog.Printf(\"Server listening at %v\", lis.Addr())\n\tif err := srv.Serve(lis, nil); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Implement a gRPC server for a CSI (Container Storage Interface) driver in Go, including server lifecycle management, request interception, and authentication.\n\nStruct Description: CSIDriver represents a gRPC server implementation for CSI driver operations, managing server lifecycle, intercepting requests, and handling authentication.\n\nFields:\n- listener: net.Listener - Network listener for incoming connections\n- server: *grpc.Server - gRPC server instance\n- servers: *CSIDriverServers - CSI service implementations (Controller, Identity, Node)\n- wg: sync.WaitGroup - Synchronization for graceful shutdown\n- running: bool - Server running state flag\n- lock: sync.Mutex - Mutex for thread-safe operations\n- creds: *CSICreds - Authentication credentials\n- logGRPC: LogGRPC - Callback for logging gRPC calls\n\nMethods:\n- NewCSIDriver(*CSIDriverServers) -> *CSIDriver - Constructor that creates a new CSIDriver instance with given service implementations\n- Start(net.Listener, grpc.UnaryServerInterceptor) -> error - Starts the gRPC server with optional interceptor\n- goServe(chan<- bool) -> - Internal method to start server in goroutine\n- Stop() -> - Stops the server gracefully\n- callInterceptor(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) -> (interface{}, error) - Request interceptor handling authentication and logging",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\ntype LogGRPC func(method string, request, reply interface{}, err error)\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (c *CSIDriver) Start(l net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.listener = l\n\n\tif interceptor == nil {\n\t\tinterceptor = c.callInterceptor\n\t}\n\tc.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\n\tif c.servers.Controller != nil {\n\t\tcsi.RegisterControllerServer(c.server, c.servers.Controller)\n\t}\n\tif c.servers.Identity != nil {\n\t\tcsi.RegisterIdentityServer(c.server, c.servers.Identity)\n\t}\n\tif c.servers.Node != nil {\n\t\tcsi.RegisterNodeServer(c.server, c.servers.Node)\n\t}\n\n\twaitForServer := make(chan bool)\n\tc.goServe(waitForServer)\n\t<-waitForServer\n\tc.running = true\n\treturn nil\n}\n\nfunc (c *CSIDriver) goServe(started chan<- bool) {\n\tgo func() {\n\t\tc.wg.Add(1)\n\t\tdefer c.wg.Done()\n\t\tstarted <- true\n\t\tc.server.Serve(c.listener)\n\t}()\n}\n\nfunc (c *CSIDriver) Stop() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif !c.running {\n\t\treturn\n\t}\n\n\tc.server.Stop()\n\tc.wg.Wait()\n}\n\nfunc (c *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\terr := authInterceptor(c.creds, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsp, err := handler(ctx, req)\n\tif c.logGRPC != nil {\n\t\tc.logGRPC(info.FullMethod, req, rsp, err)\n\t}\n\treturn rsp, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package csi\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"log\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (d *CSIDriver) Start(listener net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif d.running {\n\t\treturn nil\n\t}\n\n\td.listener = listener\n\td.server = grpc.NewServer(\n\t\tgrpc.UnaryInterceptors(interceptor),\n\t)\n\n\td.servers.Register(d.server)\n\n\tgo d.goServe(make(chan bool))\n\td.running = true\n\treturn nil\n}\n\nfunc (d *CSIDriver) goServe(stopChan chan<- bool) {\n\tdefer func() {\n\t\td.server.GracefulStop()\n\t\td.running = false\n\t\tclose(stopChan)\n\t}()\n\n\tif err := d.server.Serve(d.listener); err != nil {\n\t\tlog.Printf(\"gRPC server failed: %v\", err)\n\t}\n}\n\nfunc (d *CSIDriver) Stop() {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\tif !d.running {\n\t\treturn\n\t}\n\n\td.server.GracefulStop()\n\td.running = false\n}\n\nfunc (d *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t// Authentication logic\n\tmd, ok := metadata.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, grpc.Errorf(grpc.PermissionDenied, \"missing metadata\")\n\t}\n\n\tif len(md[\"authorization\"]) == 0 {\n\t\treturn nil, grpc.Errorf(grpc.PermissionDenied, \"missing authorization header\")\n\t}\n\n\t// Logging logic\n\td.logGRPC(\"Handling request\", info.Method, req)\n\n\t// Proceed to handler\n\treturn handler(ctx, req)\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, supports optional transport security, and can register services with reflection capabilities.\n\nFunction Description: The main function sets up and starts a gRPC server with configurable options including transport security (TLS) and logging interceptors. It registers a test service and optionally enables server reflection. The server listens on either a Unix socket or TCP port based on configuration.\n\nInput:\n- *cert (string pointer): Path to certificate file for TLS (optional)\n- *cacert (string pointer): Path to CA certificate file (optional)\n- *key (string pointer): Path to private key file (optional)\n- *requirecert (bool pointer): Whether client certificates are required (optional)\n- *quiet (bool pointer): Whether to disable logging interceptors (optional)\n- *port (int pointer): TCP port to listen on (default used if not provided)\n- getUnixSocket (func() string): Function that returns Unix socket path if available (optional)\n\nOutput:\n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are printed to stderr and the program exits with code 1 on failure\n- Success message with listening address is printed to stdout",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\n\t\"github.com/fullstorydev/grpcurl\"\n\tgrpcurl_testing \"github.com/fullstorydev/grpcurl/internal/testing\"\n)\nfunc main() {\n\tvar opts []grpc.ServerOption\n\tif *cert != \"\" {\n\t\tcreds, err := grpcurl.ServerTransportCredentials(*cacert, *cert, *key, *requirecert)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to configure transport credentials: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tif !*quiet {\n\t\topts = append(opts, grpc.UnaryInterceptor(unaryLogger), grpc.StreamInterceptor(streamLogger))\n\t}\n\n\tvar network, addr string\n\tif getUnixSocket != nil && getUnixSocket() != \"\" {\n\t\tnetwork = \"unix\"\n\t\taddr = getUnixSocket()\n\t} else {\n\t\tnetwork = \"tcp\"\n\t\taddr = fmt.Sprintf(\"127.0.0.1:%d\", *port)\n\t}\n\tl, err := net.Listen(network, addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to listen on socket: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tfmt.Printf(\"Listening on %v\\n\", l.Addr())\n\n\tsvr := grpc.NewServer(opts...)\n\n\tgrpcurl_testing.RegisterTestServiceServer(svr, grpcurl_testing.TestServer{})\n\tif !*noreflect {\n\t\treflection.Register(svr)\n\t}\n\n\tif err := svr.Serve(l); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"GRPC server returned error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/reflection/grpcreflectionplugin\"\n\t\"google.golang.org/grpc/reflection/v1alpha1/reflection\"\n)\n\ntype TestServiceServer struct{}\n\nfunc (s *TestServiceServer) TestMethod(ctx context.Context, in *TestRequest) (*TestResponse, error) {\n\treturn &TestResponse{Message: \"Hello from test service\"}, nil\n}\n\ntype TestRequest struct {\n\tMessage string\n}\n\ntype TestResponse struct {\n\tMessage string\n}\n\nfunc main() {\n\t// Example configuration values\n\tcert := os.Getenv(\"CERT\")\n\tcacert := os.Getenv(\"CACERT\")\n\tkey := os.Getenv(\"KEY\")\n\trequirecert := false\n\tquiet := false\n\tport := 50051\n\tgetUnixSocket := func() string { return \"/tmp/grpc.sock\" }\n\n\t// Create TLS credentials if provided\n\tvar serverCreds *tls.Credentials\n\tif cert != \"\" && key != \"\" {\n\t\tcreds, err := tls.LoadX509KeyPair(cert, key)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load TLS credentials: %v\", err)\n\t\t}\n\t\tserverCreds = creds\n\t}\n\n\t// Create TLS credentials with CA certificate and client cert validation\n\tif cacert != \"\" && requirecert {\n\t\tcreds, err := tls.NewServerCredentials(&tls.CredentialConfig{\n\t\t\tCertFile:   cert,\n\t\t\tKeyFile:    key,\n\t\t\tClientRootCAFile: cacert,\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\tMaxVersion: tls.VersionTLS13,\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t\t}\n\t\tserverCreds = creds\n\t}\n\n\t// Determine the listener\n\tvar lis net.Listener\n\tif getUnixSocket != nil {\n\t\tsocketPath := getUnixSocket()\n\t\tif socketPath == \"\" {\n\t\t\tlog.Fatal(\"Unix socket path is required when using getUnixSocket\")\n\t\t}\n\t\tlis, err := net.Listen(\"unix\", socketPath)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen on Unix socket: %v\", err)\n\t\t}\n\t} else if port > 0 {\n\t\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen on TCP port: %v\", err)\n\t\t}\n\t} else {\n\t\tlog.Fatal(\"Neither Unix socket nor TCP port is specified\")\n\t}\n\n\t// Create gRPC server\n\tsrv := grpc.NewServer(\n\t\tgrpc.Creds(serverCreds),\n\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\tif !quiet {\n\t\t\t\tlog.Printf(\"Received %s request\", info.FullMethod)\n\t\t\t}\n\t\t\treturn handler(ctx, req)\n\t\t}),\n\t)\n\n\t// Register test service\n\tRegisterTestServiceServer(srv, &TestServiceServer{})\n\n\t// Enable server reflection\n\treflection.Register(srv)\n\n\t// Start server\n\tfmt.Printf(\"Server is listening on %s\\n\", lis.Addr())\n\tif err := srv.Serve(lis, func(s *grpc.Server) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles incoming requests with custom stream preprocessing and graceful shutdown capabilities.\n\nStruct Description: The `server` struct represents a gRPC server instance with additional control for graceful shutdown and stream preprocessing.\n\nFields:\n- grpcSrv: *grpc.Server - The underlying gRPC server instance\n- closeC: chan struct{} - Channel used to signal server shutdown\n\nMethods:\n- Serve: (lis net.Listener) -> error - Starts the gRPC server on the provided listener, initializing it with custom stream preprocessing\n- preGrpcStream: (ctx context.Context, info *tap.Info) -> (context.Context, error) - Intercepts incoming gRPC streams before processing, with special handling for the \"/vanus.core.raft.RaftServer/SendMessage\" method",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/tap\"\n)\n\ntype server struct {\n\tgrpcSrv *grpc.Server\n\tcloseC  chan struct{}\n}\n\nfunc (s *server) Serve(lis net.Listener) error {\n\tsrv := grpc.NewServer(\n\t\tgrpc.InTapHandle(s.preGrpcStream),\n\t)\n\ts.grpcSrv = srv\n\n\treturn srv.Serve(lis)\n}\n\nfunc (s *server) preGrpcStream(ctx context.Context, info *tap.Info) (context.Context, error) {\n\tif info.FullMethodName == \"/vanus.core.raft.RaftServer/SendMessage\" {\n\t\tcCtx, cancel := context.WithCancel(ctx)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-cCtx.Done():\n\t\t\tcase <-s.closeC:\n\t\t\t\tcancel()\n\t\t\t}\n\t\t}()\n\t\treturn cCtx, nil\n\t}\n\treturn ctx, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\ntype server struct {\n\tgrpcSrv *grpc.Server\n\tcloseC  chan struct{}\n}\n\nfunc (s *server) Serve(lis net.Listener) error {\n\ts.grpcSrv = grpc.NewServer()\n\tgrpc.RegisterRaftServer(s.grpcSrv, &raftServer{})\n\ts.closeC = make(chan struct{})\n\n\tgo func() {\n\t\tif err := s.grpcSrv.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"Server exited unexpectedly: %v\", err)\n\t\t}\n\t}()\n\n\t<-s.closeC\n\ts.grpcSrv.GracefulStop()\n\treturn nil\n}\n\nfunc (s *server) preGrpcStream(ctx context.Context, info *tap.Info) (context.Context, error) {\n\tif info.FullMethod == \"/vanus.core.raft.RaftServer/SendMessage\" {\n\t\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\tdefer cancel()\n\t\treturn ctx, nil\n\t}\n\treturn ctx, nil\n}\n\ntype raftServer struct{}\n\nfunc (s *raftServer) SendMessage(ctx context.Context, in *raft.Message) (*raft.Response, error) {\n\t// Custom logic for handlingSendMessage\n\treturn &raft.Response{}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := &server{}\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server error: %v\", err)\n\t}\n\n\t// Example client\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := raft.NewRaftClient(conn)\n\t_, err = client.SendMessage(context.Background(), &raft.Message{})\n\tif err != nil {\n\t\tlog.Fatalf(\"SendMessage failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests using ALTS (Application Layer Transport Security) for authentication.\n\nFunction Description: The main function sets up a gRPC server with ALTS credentials, registers an Echo service implementation, and starts listening on a specified TCP port.\n\nInput:\n- port (int): The TCP port number on which the server should listen (passed via command-line flag)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)\n\nMethods:\n- None (this is a function-level implementation, not a struct)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\taltsTC := alts.NewServerCreds(alts.DefaultServerOptions())\n\n\ts := grpc.NewServer(grpc.Creds(altsTC))\n\n\tpb.RegisterEchoServer(s, &ecServer{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/reflection/v1/reflectservice\"\n\t\"your/echo/service\"\n)\n\nvar port int\n\nfunc init() {\n\tflag.IntVar(&port, \"port\", 50051, \"TCP port number\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tcreds, err := alts.NewClientCredentials()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create ALTS credentials: %v\", err)\n\t}\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tservice.RegisterEchoServiceServer(s, &service.EchoServiceImpl{})\n\n\t// Register reflection service\n\treflectservice.RegisterReflectServiceServer(s, &reflectservice.Server{})\n\n\tlog.Printf(\"Server listening on port %v\", port)\n\tif err := s.Serve(lis, grpc.KeepAlivesEnabled()); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 277,
    "Instruction": "Task Description: Create a gRPC server in Go that handles metric forwarding operations, including server initialization, startup, and metric processing.\n\nStruct Description: The Server struct represents a gRPC server for forwarding metrics. It manages server lifecycle, handles incoming metric data, and provides logging capabilities.\n\nFields:\n\nserver: *grpc.Server - The gRPC server instance\naddress: string - Network address to bind the server to\ningest: sources.Ingest - Interface for processing incoming metrics\nlistener: net.Listener - Network listener for incoming connections\nlogger: *logrus.Entry - Logger for server operations\nopts: *options - Configuration options for the server\nreadyChannel: chan struct{} - Channel to signal when server is ready\n\nMethods:\n\nNew: (address string, logger *logrus.Entry, opts ...Option) -> *Server - Creates a new Server instance with specified address, logger, and optional configurations. Initializes gRPC server and registers services.\n\nStart: (ingest sources.Ingest) -> error - Starts the gRPC server, binds to the specified address, and begins listening for incoming connections. Takes a metric ingestion interface as input. Returns any error that occurs during startup or operation.\n\nSendMetricsV2: (server forwardrpc.Forward_SendMetricsV2Server) -> error - Handles incoming metric streams from clients. Processes each metric received and sends back an empty response when done. Returns any error that occurs during stream processing.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"context\"\n\n\t\"github.com/golang/protobuf/ptypes/empty\"\n\t\"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\n\t\"github.com/stripe/veneur/v14/forwardrpc\"\n\t\"github.com/stripe/veneur/v14/sources\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype Server struct {\n\tserver       *grpc.Server\n\taddress      string\n\tingest       sources.Ingest\n\tlistener     net.Listener\n\tlogger       *logrus.Entry\n\topts         *options\n\treadyChannel chan struct{}\n}\n\nfunc New(address string, logger *logrus.Entry, opts ...Option) *Server {\n\tres := &Server{\n\t\taddress:      address,\n\t\tlogger:       logger,\n\t\topts:         &options{},\n\t\tserver:       grpc.NewServer(),\n\t\treadyChannel: make(chan struct{}),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(res.opts)\n\t}\n\n\tif res.opts.traceClient == nil {\n\t\tres.opts.traceClient = trace.DefaultClient\n\t}\n\n\tforwardrpc.RegisterForwardServer(res.server, res)\n\n\treturn res\n}\n\nfunc (s *Server) Start(ingest sources.Ingest) error {\n\ts.ingest = ingest\n\n\tvar err error\n\ts.listener, err = net.Listen(\"tcp\", s.address)\n\tif err != nil {\n\t\ts.logger.WithError(err).WithField(\"address\", s.address).\n\t\t\tErrorf(\"failed to bind import server\")\n\t\treturn err\n\t}\n\n\tlogger := s.logger.WithFields(logrus.Fields{\"address\": s.listener.Addr()})\n\tlogger.Info(\"Starting gRPC server\")\n\n\tclose(s.readyChannel)\n\terr = s.server.Serve(s.listener)\n\tif err != nil {\n\t\tlogger.WithError(err).Error(\"gRPC server was not shut down cleanly\")\n\t}\n\tlogger.Info(\"Stopped gRPC server\")\n\treturn err\n}\n\nfunc (s *Server) SendMetricsV2(\n\tserver forwardrpc.Forward_SendMetricsV2Server,\n) error {\n\tfor {\n\t\tmetric, err := server.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\ts.logger.WithError(err).Error(\"error recieving metrics\")\n\t\t\treturn err\n\t\t}\n\t\ts.ingest.IngestMetricProto(metric)\n\t}\n\terr := server.SendAndClose(&emptypb.Empty{})\n\tif err != nil {\n\t\ts.logger.WithError(err).Error(\"error closing stream\")\n\t}\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/sirupsen/logrus\"\n\t\"sourcegraph.com/sqs/forwardrpc\"\n\t\"sourcegraph.com/sqs/sources\"\n)\n\ntype Server struct {\n\tserver     *grpc.Server\n\taddress    string\n\tingest     sources.Ingest\n\tlistener   net.Listener\n\tlogger     *logrus.Entry\n\topts       *options\n\treadyChan  chan struct{}\n}\n\ntype options struct {\n\t// Add any configuration options here\n}\n\nfunc New(address string, logger *logrus.Entry, opts ...Option) *Server {\n\tvar o options\n\tfor _, opt := range opts {\n\t\topt(&o)\n\t}\n\treturn &Server{\n\t\taddress:   address,\n\t\tlogger:    logger,\n\t\topts:      &o,\n\t\treadyChan: make(chan struct{}),\n\t}\n}\n\nfunc (s *Server) Start(ingest sources.Ingest) error {\n\ts.ingest = ingest\n\ts.server = grpc.NewServer()\n\tforwardrpc.RegisterForwardServer(s.server, &forwardServer{})\n\tlistener, err := net.Listen(\"tcp\", s.address)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to listen on %s: %v\", s.address, err)\n\t\treturn err\n\t}\n\ts.listener = listener\n\tgo func() {\n\t\tif err := s.server.Serve(listener, func(srv *grpc.Server) { srv.SetHeaderHandler(headerHandler) }); err != nil {\n\t\t\ts.logger.Errorf(\"Server failed: %v\", err)\n\t\t}\n\t\ts.readyChan <- struct{}{}\n\t}()\n\treturn nil\n}\n\nfunc (s *Server) SendMetricsV2(server forwardrpc.Forward_SendMetricsV2Server) error {\n\tfor {\n\t\t_, err := server.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Process metric\n\t\ts.ingest.ProcessMetric(context.Background(), \"example_metric\", map[string]string{\"key\": \"value\"})\n\t}\n}\n\nfunc headerHandler(ctx context.Context, headers *map[string]string) error {\n\t// Handle headers if needed\n\treturn nil\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a gRPC server in Go that listens for incoming requests, optionally with TLS security, and registers a test service for handling RPC calls.\n\nFunction Description: The main function sets up a gRPC server that listens on a specified port, configures TLS if enabled, creates a new gRPC server instance, registers a test service, and starts serving incoming requests.\n\nInput:\n- port (int): The port number on which the server should listen\n- useTLS (bool): Flag indicating whether to use TLS security\n- certFile (string): Path to the TLS certificate file (required if useTLS is true)\n- keyFile (string): Path to the TLS private key file (required if useTLS is true)\n\nOutput:\n- None (the function runs indefinitely to serve requests or exits on error)",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/grpclog\"\n\t\"google.golang.org/grpc/interop\"\n\ttestpb \"google.golang.org/grpc/interop/grpc_testing\"\n)\nfunc main() {\n\tflag.Parse()\n\tp := strconv.Itoa(*port)\n\tlis, err := net.Listen(\"tcp\", \":\"+p)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tvar opts []grpc.ServerOption\n\tif *useTLS {\n\t\tcreds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)\n\t\tif err != nil {\n\t\t\tgrpclog.Fatalf(\"Failed to generate credentials %v\", err)\n\t\t}\n\t\topts = []grpc.ServerOption{grpc.Creds(creds)}\n\t}\n\tserver := grpc.NewServer(opts...)\n\ttestpb.RegisterTestServiceServer(server, interop.NewTestServer())\n\tserver.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\ntype TestServiceServer struct{}\n\nfunc (s *TestServiceServer) SayHello(ctx context.Context, in *HelloRequest) (*HelloResponse, error) {\n\tlog.Printf(\"Received Hello: %s\", in.Name)\n\treturn &HelloResponse{Message: \"Hello \" + in.Name}, nil\n}\n\ntype HelloRequest struct {\n\tName string\n}\n\ntype HelloResponse struct {\n\tMessage string\n}\n\nfunc main() {\n\tport := 50051\n\tuseTLS := false\n\tcertFile := \"\"\n\tkeyFile := \"\"\n\n\t// Example input values (you can modify these as needed)\n\t// port = 8080\n\t// useTLS = true\n\t// certFile = \"server.crt\"\n\t// keyFile = \"server.key\"\n\n\tvar server *grpc.Server\n\tvar lis net.Listener\n\n\tif useTLS {\n\t\tcreds, err := tls.LoadX509KeyPair(certFile, keyFile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to load TLS credentials: %v\", err)\n\t\t}\n\t\tcreds = tls.Credentials{creds}\n\t\tlis, err = net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t\t}\n\t\tserver = grpc.NewServer(grpc.Creds(creds))\n\t} else {\n\t\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t\t}\n\t\tserver = grpc.NewServer()\n\t}\n\n\t// Register the test service\n\tTestServiceRegister(server)\n\n\t// Start serving\n\tlog.Printf(\"Server is listening on port %d\", port)\n\tif err := server.Serve(lis, func(s *grpc.Server) { s.SetHeaderHandler(func(ctx context.Context, md *metadata.MD) error {\n\t\tmd.Set(\"x-test-header\", \"test-value\")\n\t\treturn nil\n\t}) }); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n}\n\n// TestServiceRegister registers the TestService with the gRPC server\nfunc TestServiceRegister(s *grpc.Server) {\n\tTestServiceImpl := &TestServiceServer{}\n\tTestServiceServerRegistration(s, TestServiceImpl)\n}\n\n// TestServiceServerRegistration registers the TestService with the gRPC server\nfunc TestServiceServerRegistration(s *grpc.Server, impl *TestServiceServer) {\n\tTestServiceServerRegistrationFunc(s, impl)\n}\n\n// TestServiceServerRegistrationFunc registers the TestService with the gRPC server\nfunc TestServiceServerRegistrationFunc(s *grpc.Server, impl *TestServiceServer) {\n\ts.RegisterService(&TestServiceDesc{}, impl)\n}\n\n// TestServiceDesc describes the TestService\nvar TestServiceDesc = &grpc.ServiceDesc{\n\tServiceName: \"TestService\",\n\tFullMethod:  \"TestService/SayHello\",\n\tHandlerType: reflect.TypeOf((*TestServiceServer)(nil)).Elem(),\n\tMethods: []*grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"SayHello\",\n\t\t\tHandler:    func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\t\t\treturn impl.SayHello(ctx, req.(*HelloRequest))\n\t\t\t},\n\t\t},\n\t},\n\tStreams: []*grpc.StreamDesc{},\n\t// TODO: Add stream methods if needed\n}"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a gRPC server in Go that handles Bigtable administration and operations, with proper initialization and cleanup capabilities.\n\nStruct Description: The Server struct represents a gRPC server instance that manages Bigtable table administration and operations. It handles network connections, server lifecycle, and maintains internal state.\n\nFields:\nAddr: [string] - The network address the server is listening on\nl: [net.Listener] - The network listener for incoming connections\nsrv: [*grpc.Server] - The gRPC server instance\ns: [*server] - The internal server implementation handling business logic\n\nMethods:\nNewServer: [func(laddr string, opt ...grpc.ServerOption) (*Server, error)] -> Creates and starts a new Server instance\n- Input: laddr (string) - The address to listen on, opt (...grpc.ServerOption) - Optional gRPC server configurations\n- Output: (*Server, error) - Returns the server instance or an error if initialization fails\n- Description: Initializes the server, sets up the listener, registers gRPC services, and starts serving requests in a goroutine\n\nClose: [func(s *Server)] -> Properly shuts down the Server instance\n- Input: None (method receiver)\n- Output: None\n- Description: Stops the gRPC server, closes the listener, and cleans up internal resources",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tl   net.Listener\n\tsrv *grpc.Server\n\ts   *server\n}\n\nfunc NewServer(laddr string, opt ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", laddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts := &Server{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tsrv:  grpc.NewServer(opt...),\n\t\ts: &server{\n\t\t\ttables: make(map[string]*table),\n\t\t},\n\t}\n\tbtapb.RegisterBigtableTableAdminServer(s.srv, s.s)\n\tbtpb.RegisterBigtableServer(s.srv, s.s)\n\n\tgo s.srv.Serve(s.l)\n\n\treturn s, nil\n}\n\nfunc (s *Server) Close() {\n\ts.s.mu.Lock()\n\tif s.s.gcc != nil {\n\t\tclose(s.s.gcc)\n\t}\n\ts.s.mu.Unlock()\n\n\ts.srv.Stop()\n\ts.l.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tl    net.Listener\n\tsrv  *grpc.Server\n\ts    *server\n}\n\nfunc NewServer(laddr string, opt ...grpc.ServerOption) (*Server, error) {\n\t// Create a new server\n\tsrv := grpc.NewServer(opt...)\n\t\n\t// Create a new listener\n\tl, err := net.Listen(\"tcp\", laddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Create a new server instance\n\ts := &server{}\n\t\n\t// Register the server with the gRPC server\n\t// (Assuming server has methods that implement the required service)\n\t// Example: srv.RegisterService(s)\n\t\n\t// Create a new Server instance\n\tserver := &Server{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tsrv:  srv,\n\t\ts:    s,\n\t}\n\t\n\t// Start the server in a goroutine\n\tgo func() {\n\t\tif err := srv.Serve(l, nil); err != nil {\n\t\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t\t}\n\t}()\n\t\n\treturn server, nil\n}\n\nfunc (s *Server) Close() {\n\tif s.srv != nil {\n\t\ts.srv.Stop()\n\t}\n\tif s.l != nil {\n\t\ts.l.Close()\n\t}\n}\n\n// server is the internal server implementation handling business logic\ntype server struct {\n\tmu     sync.Mutex\n\t tables map[string]*table\n}\n\n// table represents a table in Bigtable\ntype table struct {\n\tname string\n}\n\n// Example method to create a table\nfunc (s *server) CreateTable(ctx context.Context, req *CreateTableRequest) (*TableResponse, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t\n\tif s.tables == nil {\n\t\ts.tables = make(map[string]*table)\n\t}\n\t\n\ttableName := req.TableName\n\tif _, exists := s.tables[tableName]; exists {\n\t\treturn nil, fmt.Errorf(\"table %s already exists\", tableName)\n\t}\n\t\n\ts.tables[tableName] = &table{name: tableName}\n\t\n\treturn &TableResponse{TableName: tableName}, nil\n}\n\n// Example method to delete a table\nfunc (s *server) DeleteTable(ctx context.Context, req *DeleteTableRequest) (*DeleteTableResponse, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t\n\ttableName := req.TableName\n\tif _, exists := s.tables[tableName]; !exists {\n\t\treturn nil, fmt.Errorf(\"table %s does not exist\", tableName)\n\t}\n\t\n\tdelete(s.tables, tableName)\n\t\n\treturn &DeleteTableResponse{}, nil\n}"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a gRPC test server for monitoring metrics that can handle metric descriptor creation and time series requests, while tracking user agents and request counts.\n\nStruct Description: MetricsTestServer is a gRPC server implementation for testing metric monitoring functionality. It maintains state for tracking incoming requests and user agents, and provides methods for server control and data retrieval.\n\nFields:\n- lis: net.Listener - Network listener for the gRPC server\n- srv: *grpc.Server - gRPC server instance\n- Endpoint: string - Server's network endpoint address\n- userAgent: string - Last received User-Agent header from requests\n- createMetricDescriptorReqs: []*monitoringpb.CreateMetricDescriptorRequest - Collected metric descriptor requests\n- createServiceTimeSeriesReqs: []*monitoringpb.CreateTimeSeriesRequest - Collected time series requests\n- RetryCount: int - Number of retry attempts (usage context not shown in code)\n- mu: sync.Mutex - Mutex for thread-safe access to shared fields\n\nMethods:\n- Shutdown() -> None - Gracefully stops the gRPC server\n- UserAgent() -> string - Retrieves and clears the stored User-Agent\n- CreateServiceTimeSeriesRequests() -> []*monitoringpb.CreateTimeSeriesRequest - Retrieves and clears stored time series requests\n- appendCreateMetricDescriptorReq(context.Context, *monitoringpb.CreateMetricDescriptorRequest) -> None - Thread-safe method to store metric descriptor requests\n- appendCreateServiceTimeSeriesReq(context.Context, *monitoringpb.CreateTimeSeriesRequest) -> None - Thread-safe method to store time series requests and capture User-Agent\n- Serve() -> error - Starts serving gRPC requests\n- NewMetricTestServer() -> (*MetricsTestServer, error) - Constructor that initializes the server with default keepalive parameters and registers the metric service",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"cloud.google.com/go/monitoring/apiv3/v2/monitoringpb\"\n\tmetricpb \"google.golang.org/genproto/googleapis/api/metric\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\ntype MetricsTestServer struct {\n\tlis                         net.Listener\n\tsrv                         *grpc.Server\n\tEndpoint                    string\n\tuserAgent                   string\n\tcreateMetricDescriptorReqs  []*monitoringpb.CreateMetricDescriptorRequest\n\tcreateServiceTimeSeriesReqs []*monitoringpb.CreateTimeSeriesRequest\n\tRetryCount                  int\n\tmu                          sync.Mutex\n}\n\nfunc (m *MetricsTestServer) Shutdown() {\n\tm.srv.GracefulStop()\n}\n\nfunc (m *MetricsTestServer) UserAgent() string {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tua := m.userAgent\n\tm.userAgent = \"\"\n\treturn ua\n}\n\nfunc (m *MetricsTestServer) CreateServiceTimeSeriesRequests() []*monitoringpb.CreateTimeSeriesRequest {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treqs := m.createServiceTimeSeriesReqs\n\tm.createServiceTimeSeriesReqs = nil\n\treturn reqs\n}\n\nfunc (m *MetricsTestServer) appendCreateMetricDescriptorReq(ctx context.Context, req *monitoringpb.CreateMetricDescriptorRequest) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.createMetricDescriptorReqs = append(m.createMetricDescriptorReqs, req)\n}\n\nfunc (m *MetricsTestServer) appendCreateServiceTimeSeriesReq(ctx context.Context, req *monitoringpb.CreateTimeSeriesRequest) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.createServiceTimeSeriesReqs = append(m.createServiceTimeSeriesReqs, req)\n\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tm.userAgent = strings.Join(md.Get(\"User-Agent\"), \";\")\n\t}\n}\n\nfunc (m *MetricsTestServer) Serve() error {\n\treturn m.srv.Serve(m.lis)\n}\n\nfunc NewMetricTestServer() (*MetricsTestServer, error) {\n\tsrv := grpc.NewServer(grpc.KeepaliveParams(keepalive.ServerParameters{Time: 5 * time.Minute}))\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestServer := &MetricsTestServer{\n\t\tEndpoint: lis.Addr().String(),\n\t\tlis:      lis,\n\t\tsrv:      srv,\n\t}\n\n\tmonitoringpb.RegisterMetricServiceServer(\n\t\tsrv,\n\t\t&fakeMetricServiceServer{metricsTestServer: testServer},\n\t)\n\n\treturn testServer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/reflection\"\n\n\tmonitoringpb \"cloud.google.com/go/monitoring/apiv3/bm\"\n)\n\ntype MetricsTestServer struct {\n\tlis       net.Listener\n\tsrv       *grpc.Server\n\tEndpoint  string\n\tuserAgent string\n\tcreateMetricDescriptorReqs []*monitoringpb.CreateMetricDescriptorRequest\n\tcreateServiceTimeSeriesReqs []*monitoringpb.CreateTimeSeriesRequest\n\tRetryCount int\n\tmu        sync.Mutex\n}\n\nfunc (s *MetricsTestServer) Shutdown() {\n\ts.srv.Stop()\n}\n\nfunc (s *MetricsTestServer) UserAgent() string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tresult := s.userAgent\n\ts.userAgent = \"\"\n\treturn result\n}\n\nfunc (s *MetricsTestServer) CreateServiceTimeSeriesRequests() []*monitoringpb.CreateTimeSeriesRequest {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tresult := s.createServiceTimeSeriesReqs\n\ts.createServiceTimeSeriesReqs = []*monitoringpb.CreateTimeSeriesRequest{}\n\treturn result\n}\n\nfunc (s *MetricsTestServer) appendCreateMetricDescriptorReq(ctx context.Context, req *monitoringpb.CreateMetricDescriptorRequest) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.createMetricDescriptorReqs = append(s.createMetricDescriptorReqs, req)\n}\n\nfunc (s *MetricsTestServer) appendCreateServiceTimeSeriesReq(ctx context.Context, req *monitoringpb.CreateTimeSeriesRequest) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.createServiceTimeSeriesReqs = append(s.createServiceTimeSeriesReqs, req)\n\t// Extract user agent from metadata\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif ok {\n\t\ts.userAgent = md.Get(\"user-agent\")[0]\n\t}\n}\n\nfunc (s *MetricsTestServer) Serve() error {\n\ts.srv = grpc.NewServer(\n\t\tgrpc.KeepaliveParams(10000000000),\n\t\tgrpc.KeepaliveMinTime(10000000000),\n\t\tgrpc.KeepaliveTimeout(10000000000),\n\t)\n\tmonitoringpb.RegisterMetricServiceServer(s.srv, &MetricsTestServer{})\n\treflection.Register(s.srv)\n\treturn s.srv.Serve(s.lis)\n}\n\nfunc NewMetricTestServer() (*MetricsTestServer, error) {\n\tlis, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &MetricsTestServer{\n\t\tlis:       lis,\n\t\tEndpoint:  lis.Addr().String(),\n\t\tRetryCount: 0,\n\t}\n\treturn s, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tserver, err := NewMetricTestServer()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create server: %v\", err)\n\t}\n\tif err := server.Serve(); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a mock gRPC server for OpenTelemetry traces receiver that can handle incoming trace data requests, track request metrics, and optionally use TLS for secure communication.\n\nStruct Description: The mockTracesReceiver struct implements a gRPC server for receiving OpenTelemetry trace data, tracking request counts and spans, and handling metadata. It embeds a base mockReceiver struct and implements the ptraceotlp.GRPCServer interface.\n\nFields:\n\nsrv: [*grpc.Server] - The gRPC server instance\nln: [net.Listener] - Network listener for the server\nrequestCount: [*atomic.Int32] - Counter for received requests\ntotalItems: [*atomic.Int32] - Counter for total spans received\nmux: [sync.Mutex] - Mutex for thread-safe operations\nmetadata: [metadata.MD] - Stores metadata from incoming requests\nexportError: [error] - Error to return from export operations\nexportResponse: [func() ptraceotlp.ExportResponse] - Function to generate export responses\nlastRequest: [ptrace.Traces] - Stores the last received trace data\nhasMetadata: [bool] - Flag indicating whether to process metadata\nspanCountByMetadata: [map[string]int] - Tracks span counts by metadata keys\n\nMethods:\n\nExport: [Name](ctx context.Context, req ptraceotlp.ExportRequest) -> (ptraceotlp.ExportResponse, error) - Handles incoming trace export requests, updates counters, and processes metadata\nstart: [Name]() -> () - Starts the gRPC server in a goroutine\n\nAssociated Functions:\n\notelArrowTracesReceiverOnGRPCServer: [Name](ln net.Listener, useTLS bool) -> (*mockTracesReceiver, error) - Creates and configures a new mock traces receiver with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n\n\t\"go.opentelemetry.io/collector/pdata/ptrace\"\n\t\"go.opentelemetry.io/collector/pdata/ptrace/ptraceotlp\"\n)\n\ntype mockReceiver struct {\n\tsrv          *grpc.Server\n\tln           net.Listener\n\trequestCount *atomic.Int32\n\ttotalItems   *atomic.Int32\n\tmux          sync.Mutex\n\tmetadata     metadata.MD\n\texportError  error\n}\n\ntype mockTracesReceiver struct {\n\tptraceotlp.UnimplementedGRPCServer\n\tmockReceiver\n\texportResponse      func() ptraceotlp.ExportResponse\n\tlastRequest         ptrace.Traces\n\thasMetadata         bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (r *mockTracesReceiver) Export(ctx context.Context, req ptraceotlp.ExportRequest) (ptraceotlp.ExportResponse, error) {\n\tr.requestCount.Add(int32(1))\n\ttd := req.Traces()\n\tr.totalItems.Add(int32(td.SpanCount()))\n\tr.mux.Lock()\n\tdefer r.mux.Unlock()\n\tr.metadata, _ = metadata.FromIncomingContext(ctx)\n\tif r.hasMetadata {\n\t\tv1 := r.metadata.Get(\"key1\")\n\t\tv2 := r.metadata.Get(\"key2\")\n\t\thashKey := fmt.Sprintf(\"%s|%s\", v1, v2)\n\t\tr.spanCountByMetadata[hashKey] += (td.SpanCount())\n\t}\n\tr.lastRequest = td\n\treturn r.exportResponse(), r.exportError\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\tsopts := []grpc.ServerOption{}\n\n\tif useTLS {\n\t\t_, currentFile, _, _ := runtime.Caller(0)\n\t\tbasepath := filepath.Dir(currentFile)\n\t\tcertpath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_cert.pem\"))\n\t\tkeypath := filepath.Join(basepath, filepath.Join(\"testdata\", \"test_key.pem\"))\n\n\t\tcreds, err := credentials.NewServerTLSFromFile(certpath, keypath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsopts = append(sopts, grpc.Creds(creds))\n\t}\n\n\trcv := &mockTracesReceiver{\n\t\tmockReceiver: mockReceiver{\n\t\t\tsrv:          grpc.NewServer(sopts...),\n\t\t\tln:           ln,\n\t\t\trequestCount: &atomic.Int32{},\n\t\t\ttotalItems:   &atomic.Int32{},\n\t\t},\n\t\texportResponse: ptraceotlp.NewExportResponse,\n\t}\n\n\tptraceotlp.RegisterGRPCServer(rcv.srv, rcv)\n\n\treturn rcv, nil\n}\n\nfunc (r *mockTracesReceiver) start() {\n\tgo func() {\n\t\t_ = r.srv.Serve(r.ln)\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/protobuf/types/protoreflect/descriptor\"\n\t\"google.golang.org/protobuf/types/protowire\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype mockTracesReceiver struct {\n\tsrv        *grpc.Server\n\tln         net.Listener\n\trequestCount *atomic.Int32\n\ttotalItems  *atomic.Int32\n\tmux         sync.Mutex\n\tmetadata    metadata.MD\n\texportError error\n\texportResponse func() ptraceotlp.ExportResponse\n\tlastRequest  ptrace.Traces\n\thasMetadata  bool\n\tspanCountByMetadata map[string]int\n}\n\nfunc (m *mockTracesReceiver) Export(ctx context.Context, req *ptraceotlp.ExportRequest) (*ptraceotlp.ExportResponse, error) {\n\tm.mux.Lock()\n\tdefer m.mux.Unlock()\n\n\tm.requestCount.Add(1)\n\tm.totalItems.Add(int32(len(req.GetResources())))\n\tm.hasMetadata = len(m.metadata) > 0\n\n\tif m.exportError != nil {\n\t\treturn nil, m.exportError\n\t}\n\n\tif m.exportResponse != nil {\n\t\treturn m.exportResponse(), nil\n\t}\n\n\tresp := &ptraceotlp.ExportResponse{\n\t\tTraceIds: []string{\"mock-trace-id-1\"},\n\t\tSpans:    []*ptrace.Span{},\n\t}\n\n\tm.lastRequest = req\n\n\treturn resp, nil\n}\n\nfunc (m *mockTracesReceiver) start() {\n\tgo func() {\n\t\tif err := m.srv.Serve(m.ln); err != nil {\n\t\t\tfmt.Fprintf(runtime.GOOS, \"gRPC server failed: %v\\n\", err)\n\t\t}\n\t}()\n}\n\nfunc otelArrowTracesReceiverOnGRPCServer(ln net.Listener, useTLS bool) (*mockTracesReceiver, error) {\n\tvar opts []grpc.ServerOption\n\tif useTLS {\n\t\tcreds, err := tls.NewServerCredentials(&tls.Credentials{InsecureSkipVerify: true})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t} else {\n\t\topts = append(opts, grpc.Creds(insecure.NewCredentials()))\n\t}\n\n\tsrv := grpc.NewServer(opts...)\n\treceiver := &mockTracesReceiver{\n\t\tsrv:        srv,\n\t\tln:         ln,\n\t\trequestCount: &atomic.Int32{Value: 0},\n\t\ttotalItems:  &atomic.Int32{Value: 0},\n\t\tmux:        sync.Mutex{},\n\t\tmetadata:   metadata.MD{},\n\t\texportError: nil,\n\t\texportResponse: func() ptraceotlp.ExportResponse {\n\t\t\treturn &ptraceotlp.ExportResponse{\n\t\t\t\tTraceIds: []string{\"mock-trace-id-1\"},\n\t\t\t\tSpans:    []*ptrace.Span{},\n\t\t\t}\n\t\t},\n\t\tlastRequest: ptrace.Traces{},\n\t\thasMetadata: false,\n\t\tspanCountByMetadata: make(map[string]int),\n\t}\n\n\tsrv.RegisterService((*ptraceotlp.GRPCServer)(receiver), &descriptor.ServiceDescriptorProto{\n\t\tName: \"GRPCServer\",\n\t\tMethod: []*descriptor.MethodDescriptorProto{\n\t\t\t{\n\t\t\t\tName: \"Export\",\n\t\t\t\tInputType: &descriptor.TypeDescriptor{\n\t\t\t\t\tName: \"ExportRequest\",\n\t\t\t\t\tKind: descriptor.TYPE_MESSAGE,\n\t\t\t\t},\n\t\t\t\tOutputType: &descriptor.TypeDescriptor{\n\t\t\t\t\tName: \"ExportResponse\",\n\t\t\t\t\tKind: descriptor.TYPE_MESSAGE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\n\tgo receiver.start()\n\n\treturn receiver, nil\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC server with basic lifecycle management capabilities, including initialization, startup, and shutdown.\n\nStruct Description: The Server struct represents a gRPC server instance with network listening capabilities. It manages the server lifecycle and provides methods to start and stop the server gracefully.\n\nFields:\nAddr: [string] - The network address (IP:port) where the server is listening\nPort: [int] - The port number on which the server is listening\nl: [net.Listener] - The network listener for incoming connections\nGsrv: [*grpc.Server] - The gRPC server instance\n\nMethods:\nNewServer: [func(opts ...grpc.ServerOption) (*Server, error)] -> [*Server, error] - Creates a new Server instance with default settings (random available port)\nNewServerWithPort: [func(port int, opts ...grpc.ServerOption) (*Server, error)] -> [*Server, error] - Creates a new Server instance on the specified port\nStart: [func()] -> [] - Starts the gRPC server in a goroutine to handle incoming requests\nClose: [func()] -> [] - Gracefully stops the gRPC server and closes the network listener",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tPort int\n\tl    net.Listener\n\tGsrv *grpc.Server\n}\n\nfunc NewServer(opts ...grpc.ServerOption) (*Server, error) {\n\treturn NewServerWithPort(0, opts...)\n}\n\nfunc NewServerWithPort(port int, opts ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"127.0.0.1:%d\", port))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := &Server{\n\t\tAddr: l.Addr().String(),\n\t\tPort: parsePort(l.Addr().String()),\n\t\tl:    l,\n\t\tGsrv: grpc.NewServer(opts...),\n\t}\n\treturn s, nil\n}\n\nfunc (s *Server) Start() {\n\tgo func() {\n\t\tif err := s.Gsrv.Serve(s.l); err != nil {\n\t\t\tlog.Printf(\"testutil.Server.Start: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Close() {\n\ts.Gsrv.Stop()\n\ts.l.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tAddr string\n\tPort int\n\tl   net.Listener\n\tGsrv *grpc.Server\n}\n\nfunc NewServer(opts ...grpc.ServerOption) (*Server, error) {\n\t// Find a random available port\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tport := l.Addr().(*net.TCPAddr).Port\n\taddr := \"0.0.0.0:\" + strconv.Itoa(port)\n\treturn NewServerWithPort(port, opts...)\n}\n\nfunc NewServerWithPort(port int, opts ...grpc.ServerOption) (*Server, error) {\n\tl, err := net.Listen(\"tcp\", \":\"+strconv.Itoa(port))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsrv := &Server{\n\t\tAddr: addr,\n\t\tPort: port,\n\t\tl:    l,\n\t\tGsrv: grpc.NewServer(opts...),\n\t}\n\treturn srv, nil\n}\n\nfunc (s *Server) Start() []byte {\n\tgo func() {\n\t\tif err := s.Gsrv.Serve(s.l); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\treturn []byte(\"Server started\")\n}\n\nfunc (s *Server) Close() []byte {\n\ts.Gsrv.GracefulStop()\n\tif err := s.l.Close(); err != nil {\n\t\treturn []byte(\"Error closing listener: \" + err.Error())\n\t}\n\treturn []byte(\"Server closed\")\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles unary RPC calls for an Echo service, including secure communication with transport credentials.\n\nFunction Description: The `startGRPCServer` function initializes and starts a gRPC server with the provided listener and transport credentials. It registers an Echo service implementation and begins serving incoming requests.\n\nInput:\n- `lis` [net.Listener] - A network listener that specifies the address and port to listen on\n- `creds` [credentials.TransportCredentials] - Transport credentials for secure communication (TLS)\n\nOutput:\n- `error` - Returns an error if the server fails to start or encounters a fatal error during operation, otherwise runs indefinitely serving requests",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n)\n\ntype ecServer struct {\n\tpb.UnimplementedEchoServer\n}\n\nfunc (s *ecServer) UnaryEcho(_ context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {\n\treturn &pb.EchoResponse{Message: req.Message}, nil\n}\n\nfunc newServer() *ecServer {\n\treturn &ecServer{}\n}\n\nfunc startGRPCServer(lis net.Listener, creds credentials.TransportCredentials) error {\n\ts := grpc.NewServer(grpc.Creds(creds))\n\tpb.RegisterEchoServer(s, newServer())\n\treturn s.Serve(lis)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"google.golang.org/grpc/peer\"\n\t\"google.golang.org/grpc/server\"\n)\n\ntype EchoServiceServer struct{}\n\nfunc (s *EchoServiceServer) Echo(ctx context.Context, in *EchoRequest) (*EchoResponse, error) {\n\tp, _ := peer.FromContext(ctx)\n\tlog.Printf(\"Received Echo request from %v\", p.Addr)\n\treturn &EchoResponse{Message: in.Message}, nil\n}\n\ntype EchoRequest struct {\n\tMessage string\n}\n\ntype EchoResponse struct {\n\tMessage string\n}\n\nfunc startGRPCServer(lis net.Listener, creds credentials.TransportCredentials) error {\n\tsrv := grpc.NewServer(\n\t\tgrpc.Creds(creds),\n\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\tp, _ := peer.FromContext(ctx)\n\t\t\tlog.Printf(\"Unary interceptor called from %v\", p.Addr)\n\t\t\treturn handler(ctx, req)\n\t\t}),\n\t)\n\n\techoService := &EchoServiceServer{}\n\tgrpc.RegisterEchoServiceServer(srv, echoService)\n\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server failed: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage with TLS credentials\n\ttlsCreds, err := tls.NewServerCredentials(&tls.CredentialsConfig{\n\t\tPemCertificates: []byte(\"-----BEGIN CERTIFICATE-----\\n... (certificate data) ...\\n-----END CERTIFICATE-----\"),\n\t\tPemPrivateKey:   []byte(\"-----BEGIN PRIVATE KEY-----\\n... (private key data) ...\\n-----END PRIVATE KEY-----\"),\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t}\n\n\tlistener, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tif err := startGRPCServer(listener, tlsCreds); err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Create a function to start a gRPC server for signal exchange, including setting up a network listener and registering the server with gRPC.\n\nFunction Description: The function `startSignal` initializes and starts a gRPC server for signal exchange. It creates a TCP listener on an available port, initializes a new gRPC server instance, registers the signal exchange service, and starts the server in a goroutine. The function is designed for testing purposes and includes error handling.\n\nInput: \n- `t *testing.T`: A testing context for error reporting and test helpers.\n\nOutput:\n- `*grpc.Server`: The created gRPC server instance.\n- `net.Listener`: The network listener used by the gRPC server.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\n\tsigProto \"github.com/netbirdio/netbird/signal/proto\"\n\tsig \"github.com/netbirdio/netbird/signal/server\"\n)\n\nfunc startSignal(t *testing.T) (*grpc.Server, net.Listener) {\n\tt.Helper()\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts := grpc.NewServer()\n\tsrv, err := sig.NewServer(context.Background(), otel.Meter(\"\"))\n\trequire.NoError(t, err)\n\n\tsigProto.RegisterSignalExchangeServer(s, srv)\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\treturn s, lis\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype SignalServiceServer struct{}\n\nfunc (s *SignalServiceServer) ExchangeSignal(ctx context.Context, req *SignalRequest) (*SignalResponse, error) {\n\tfmt.Printf(\"Received signal: %s\\n\", req.Signal)\n\treturn &SignalResponse{Response: \"Signal received\"}, nil\n}\n\ntype SignalRequest struct {\n\tSignal string\n}\n\ntype SignalResponse struct {\n\tResponse string\n}\n\nfunc startSignal(t *testing.T) (*grpc.Server, net.Listener) {\n\t// Find an available port\n\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create listener: %v\", err)\n\t}\n\n\t// Create a new gRPC server\n\tserver := grpc.NewServer()\n\n\t// Register the signal exchange service\n\tgrpc.RegisterSignalServiceServer(server, &SignalServiceServer{})\n\n\t// Start the server in a goroutine\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tt.Fatalf(\"Server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Wait for a moment to ensure the server is up\n\ttime.Sleep(100 * time.Millisecond)\n\n\treturn server, listener\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a gRPC server for a translation service that can handle text translation requests and return mock translations for testing purposes.\n\nStruct Description: The fakeTranslationServer struct implements a mock gRPC server for the TranslationService, providing a simple translation response without requiring an actual translation service.\n\nFields:\n- UnimplementedTranslationServiceServer: embed - Base type from translatepb package that provides default implementations for all service methods\n\nMethods:\n- TranslateText: [Name](ctx context.Context, req *translatepb.TranslateTextRequest) -> (*translatepb.TranslateTextResponse, error) - Handles translation requests by returning a mock response containing \"Hello World\" as the translated text",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\ttranslate \"cloud.google.com/go/translate/apiv3\"\n\t\"cloud.google.com/go/translate/apiv3/translatepb\"\n\t\"google.golang.org/api/option\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (f *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\tresp := &translatepb.TranslateTextResponse{\n\t\tTranslations: []*translatepb.Translation{\n\t\t\t{TranslatedText: \"Hello World\"},\n\t\t},\n\t}\n\treturn resp, nil\n}\n\nfunc TestTranslateTextWithConcreteClient(t *testing.T) {\n\tctx := context.Background()\n\n\tfakeTranslationServer := &fakeTranslationServer{}\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgsrv := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(gsrv, fakeTranslationServer)\n\tfakeServerAddr := l.Addr().String()\n\tgo func() {\n\t\tif err := gsrv.Serve(l); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tclient, err := translate.NewTranslationClient(ctx,\n\t\toption.WithEndpoint(fakeServerAddr),\n\t\toption.WithoutAuthentication(),\n\t\toption.WithGRPCDialOption(grpc.WithInsecure()),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"translatepb\"\n)\n\ntype fakeTranslationServer struct {\n\ttranslatepb.UnimplementedTranslationServiceServer\n}\n\nfunc (s *fakeTranslationServer) TranslateText(ctx context.Context, req *translatepb.TranslateTextRequest) (*translatepb.TranslateTextResponse, error) {\n\treturn &translatepb.TranslateTextResponse{TranslatedText: \"Hello World\"}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tsrv := grpc.NewServer()\n\ttranslatepb.RegisterTranslationServiceServer(srv, &fakeTranslationServer{})\n\n\tlog.Printf(\"Server running on port 50051\")\n\tif err := srv.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Server exited with error: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "The provided reference code is at the function level, so I'll provide instructions in the function-level format:\n\nTask Description: Implement a gRPC server setup in Go that handles both Unix domain sockets and TCP connections with TLS support and keepalive configurations.\n\nFunction Description: The code consists of two main functions for setting up a gRPC server: `createListener` creates a network listener for the server, and `grpcServer` configures and creates a gRPC server instance with optional TLS and keepalive settings.\n\nInput:\n1. For `createListener` function:\n   - config [Config] - Configuration object containing listener address and other settings\n\n2. For `grpcServer` function:\n   - config [Config] - Configuration object containing gRPC server settings and TLS configuration\n\nOutput:\n1. For `createListener` function:\n   - [net.Listener] - Network listener ready for gRPC server\n   - [error] - Error if listener creation fails\n\n2. For `grpcServer` function:\n   - [*grpc.Server] - Configured gRPC server instance\n   - [error] - Error if server creation fails\n\nThe Config struct used as input is defined as:\n- GRPCServer [*grpc.Server] - Optional pre-configured gRPC server instance\n- Listener [string] - Network address to listen on (e.g., \"unix:///path/to/socket\" or \"tcp://:port\")\n- Endpoint [string] - Server endpoint\n- ServerTLSConfig [tls.Config] - TLS configuration for secure connections",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/k3s-io/kine/pkg/util\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"go.etcd.io/etcd/server/v3/embed\"\n)\n\ntype Config struct {\n\tGRPCServer           *grpc.Server\n\tListener             string\n\tEndpoint             string\n\tServerTLSConfig      tls.Config\n}\n\nfunc createListener(config Config) (ret net.Listener, rerr error) {\n\tif config.Listener == \"\" {\n\t\tconfig.Listener = KineSocket\n\t}\n\tscheme, address := util.SchemeAndAddress(config.Listener)\n\n\tif scheme == \"unix\" {\n\t\tif err := os.Remove(address); err != nil && !os.IsNotExist(err) {\n\t\t\tlogrus.Warnf(\"failed to remove socket %s: %v\", address, err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := os.Chmod(address, 0600); err != nil {\n\t\t\t\trerr = err\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tscheme = \"tcp\"\n\t}\n\n\treturn net.Listen(scheme, address)\n}\n\nfunc grpcServer(config Config) (*grpc.Server, error) {\n\tif config.GRPCServer != nil {\n\t\treturn config.GRPCServer, nil\n\t}\n\n\tgopts := []grpc.ServerOption{\n\t\tgrpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{\n\t\t\tMinTime:             embed.DefaultGRPCKeepAliveMinTime,\n\t\t\tPermitWithoutStream: false,\n\t\t}),\n\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{\n\t\t\tTime:    embed.DefaultGRPCKeepAliveInterval,\n\t\t\tTimeout: embed.DefaultGRPCKeepAliveTimeout,\n\t\t}),\n\t}\n\n\tif config.ServerTLSConfig.CertFile != \"\" && config.ServerTLSConfig.KeyFile != \"\" {\n\t\tcreds, err := credentials.NewServerTLSFromFile(config.ServerTLSConfig.CertFile, config.ServerTLSConfig.KeyFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgopts = append(gopts, grpc.Creds(creds))\n\t}\n\n\treturn grpc.NewServer(gopts...), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/golang/protobuf/ptypes/empty\"\n)\n\ntype Config struct {\n\tGRPCServer     *grpc.Server\n\tListener       string\n\tEndpoint       string\n\tServerTLSConfig *tls.Config\n}\n\nfunc createListener(config Config) (net.Listener, error) {\n\tvar listener net.Listener\n\tvar err error\n\n\tif config.Listener == \"unix://\" {\n\t\tlistener, err = net.Listen(\"unix\", config.Listener)\n\t} else if config.Listener == \"tcp://\" {\n\t\tlistener, err = net.Listen(\"tcp\", config.Listener)\n\t} else {\n\t\treturn nil, fmt.Errorf(\"unsupported listener type: %s\", config.Listener)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn listener, nil\n}\n\nfunc grpcServer(config Config) (*grpc.Server, error) {\n\topts := []grpc.ServerOption{}\n\n\tif config.GRPCServer != nil {\n\t\treturn config.GRPCServer, nil\n\t}\n\n\tif config.ServerTLSConfig != nil {\n\t\topts = append(opts, grpc.Creds( grpc_tls.NewServerTLSInfo(config.ServerTLSConfig, nil, nil) ))\n\t}\n\n\tserver := grpc.NewServer(opts...)\n\n\treturn server, nil\n}"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a gRPC server in Go that implements an echo service and health checking functionality. The server should listen on a specified port, handle incoming gRPC requests, and periodically toggle its health status between SERVING and NOT_SERVING states.\n\nFunction Description: The main function sets up a gRPC server with echo service and health check capabilities. It creates a TCP listener, initializes the gRPC server, registers services, and starts serving requests. A background goroutine periodically changes the health status for demonstration purposes.\n\nInput:\n- port (int): The TCP port number on which the server should listen\n- sleep (time.Duration): The interval at which health status should toggle\n\nOutput:\n- None (the function runs indefinitely until interrupted or encounters an error)\n- Errors are logged if they occur during server setup or operation\n\nNote: The function uses package-level variables for port and sleep duration (typically set via command-line flags) and assumes the existence of an echoServer struct that implements the Echo service interface.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/features/proto/echo\"\n\t\"google.golang.org/grpc/health\"\n\thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n\thealthpb \"google.golang.org/grpc/health/grpc_health_v1\"\n)\nfunc main() {\n\tflag.Parse()\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\thealthcheck := health.NewServer()\n\thealthgrpc.RegisterHealthServer(s, healthcheck)\n\tpb.RegisterEchoServer(s, &echoServer{})\n\n\tgo func() {\n\t\tnext := healthpb.HealthCheckResponse_SERVING\n\n\t\tfor {\n\t\t\thealthcheck.SetServingStatus(system, next)\n\n\t\t\tif next == healthpb.HealthCheckResponse_SERVING {\n\t\t\t\tnext = healthpb.HealthCheckResponse_NOT_SERVING\n\t\t\t} else {\n\t\t\t\tnext = healthpb.HealthCheckResponse_SERVING\n\t\t\t}\n\n\t\t\ttime.Sleep(*sleep)\n\t\t}\n\t}()\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/health/v1\"\n\t\"google.golang.org/grpc/reflection/v1/healthcheck\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\ntype echoServer struct {\n\t*grpc.Server\n}\n\nfunc (s *echoServer) Echo(ctx context.Context, in *EchoRequest) (*EchoResponse, error) {\n\treturn &EchoResponse{Message: in.Message}, nil\n}\n\ntype healthServer struct {\n\thealth.UnimplementedHealthCheckerServer\n\tstatus string\n}\n\nfunc (s *healthServer) Check(ctx context.Context, in *health.HealthCheckRequest) (*health.HealthCheckResponse, error) {\n\tif s.status == \"SERVING\" {\n\t\treturn &health.HealthCheckResponse{Status: health.SERVING}, nil\n\t}\n\treturn &health.HealthCheckResponse{Status: health.NOT_SERVING}, nil\n}\n\nfunc (s *healthServer) Watch(ctx context.Context, in *health.HealthWatchRequest) (*health.HealthWatchResponse, error) {\n\treturn &health.HealthWatchResponse{Status: health.SERVING}, nil\n}\n\nfunc main() {\n\tport := 50051\n\tsleep := 5 * time.Second\n\n\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\techosrv := &echoServer{Server: s}\n\thealthsrv := &healthServer{status: \"SERVING\"}\n\n\thealth.RegisterHealthServer(s, healthsrv)\n\techo.RegisterEchoServer(s, echosrv)\n\treflection.Register(s)\n\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(sleep)\n\t\t\thealthsrv.status = \"NOT_SERVING\"\n\t\t\tlog.Println(\"Health status toggled to NOT_SERVING\")\n\t\t\ttime.Sleep(sleep)\n\t\t\thealthsrv.status = \"SERVING\"\n\t\t\tlog.Println(\"Health status toggled to SERVING\")\n\t\t}\n\t}()\n\n\tlog.Printf(\"Server listening on port %v\", port)\n\tif err := s.Serve(lis, grpc.KeepAlivesEnabled()); err != nil {\n\t\tlog.Fatalf(\"server failed: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Implement a gRPC server in Go that provides a simple key-value store service with various RPC methods for setting, getting, and streaming items.\n\nStruct Description: The intStoreServer struct implements a gRPC server for a key-value store service, handling item storage and retrieval operations through different RPC patterns (unary, server streaming, client streaming, and bidirectional streaming).\n\nFields:\nAddr: string - The network address where the server is listening\nl: net.Listener - The network listener for incoming connections\ngsrv: *grpc.Server - The gRPC server instance\nitems: map[string]int32 - The internal storage for key-value pairs\n\nMethods:\nnewIntStoreServer: () -> *intStoreServer - Creates and starts a new server instance on an available port\nstop: () -> () - Gracefully shuts down the server\nSet: (context.Context, *pb.Item) -> (*pb.SetResponse, error) - Unary RPC to set a key-value pair\nsetItem: (*pb.Item) -> int32 - Internal helper method to store an item\nGet: (context.Context, *pb.GetRequest) -> (*pb.Item, error) - Unary RPC to retrieve a value by key\nListItems: (*pb.ListItemsRequest, pb.IntStore_ListItemsServer) -> error - Server streaming RPC to list items matching criteria\nSetStream: (pb.IntStore_SetStreamServer) -> error - Client streaming RPC to set multiple items\nStreamChat: (pb.IntStore_StreamChatServer) -> error - Bidirectional streaming RPC for chat-like communication",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"cloud.google.com/go/rpcreplay/proto/intstore\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype intStoreServer struct {\n\tpb.IntStoreServer\n\n\tAddr string\n\tl    net.Listener\n\tgsrv *grpc.Server\n\n\titems map[string]int32\n}\n\nfunc newIntStoreServer() *intStoreServer {\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := &intStoreServer{\n\t\tAddr: l.Addr().String(),\n\t\tl:    l,\n\t\tgsrv: grpc.NewServer(),\n\t}\n\tpb.RegisterIntStoreServer(s.gsrv, s)\n\tgo s.gsrv.Serve(s.l)\n\treturn s\n}\n\nfunc (s *intStoreServer) stop() {\n\ts.gsrv.Stop()\n\ts.l.Close()\n}\n\nfunc (s *intStoreServer) Set(_ context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\told := s.setItem(item)\n\treturn &pb.SetResponse{PrevValue: old}, nil\n}\n\nfunc (s *intStoreServer) setItem(item *pb.Item) int32 {\n\tif s.items == nil {\n\t\ts.items = map[string]int32{}\n\t}\n\told := s.items[item.Name]\n\ts.items[item.Name] = item.Value\n\treturn old\n}\n\nfunc (s *intStoreServer) Get(_ context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\tval, ok := s.items[req.Name]\n\tif !ok {\n\t\treturn nil, status.Errorf(codes.NotFound, \"%q\", req.Name)\n\t}\n\treturn &pb.Item{Name: req.Name, Value: val}, nil\n}\n\nfunc (s *intStoreServer) ListItems(req *pb.ListItemsRequest, ss pb.IntStore_ListItemsServer) error {\n\tfor name, val := range s.items {\n\t\tif val > req.GreaterThan {\n\t\t\tif err := ss.Send(&pb.Item{Name: name, Value: val}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *intStoreServer) SetStream(ss pb.IntStore_SetStreamServer) error {\n\tn := 0\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.setItem(item)\n\t\tn++\n\t}\n\treturn ss.SendAndClose(&pb.Summary{Count: int32(n)})\n}\n\nfunc (s *intStoreServer) StreamChat(ss pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\titem, err := ss.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ss.Send(item); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n)\n\ntype Item struct {\n\tKey   string\n\tValue int32\n}\n\ntype ListItemsRequest struct {\n\tSearch string\n}\n\ntype SetResponse struct {\n\tSuccess bool\n}\n\ntype IntStoreServer struct {\n\tAddr      string\n\tl         net.Listener\n\tgsrv      *grpc.Server\n\titems     map[string]int32\n\tmu        sync.RWMutex\n}\n\nfunc NewIntStoreServer() *IntStoreServer {\n\ts := &IntStoreServer{\n\t\tAddr:  \"localhost:50051\",\n\t\titems: make(map[string]int32),\n\t}\n\t// Start the server\n\tln, err := net.Listen(\"tcp\", s.Addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts.l = ln\n\ts.gsrv = grpc.NewServer()\n\tpb.RegisterIntStoreServer(s.gsrv, &IntStoreServer{})\n\tif err := s.gsrv.Serve(s.l); err != nil {\n\t\tlog.Fatalf(\"server failed: %v\", err)\n\t}\n\treturn s\n}\n\nfunc (s *IntStoreServer) Stop() {\n\ts.gsrv.GracefulStop()\n}\n\nfunc (s *IntStoreServer) Set(ctx context.Context, item *pb.Item) (*pb.SetResponse, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif item == nil || item.Key == \"\" || item.Value == 0 {\n\t\treturn &pb.SetResponse{Success: false}, status.Errorf(codes.InvalidArgument, \"invalid item\")\n\t}\n\ts.items[item.Key] = item.Value\n\treturn &pb.SetResponse{Success: true}, nil\n}\n\nfunc (s *IntStoreServer) setItem(item *pb.Item) int32 {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif item == nil || item.Key == \"\" || item.Value == 0 {\n\t\treturn 0\n\t}\n\ts.items[item.Key] = item.Value\n\treturn item.Value\n}\n\nfunc (s *IntStoreServer) Get(ctx context.Context, req *pb.GetRequest) (*pb.Item, error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tvalue, ok := s.items[req.Key]\n\tif !ok {\n\t\treturn &pb.Item{}, status.Errorf(codes.NotFound, \"key not found\")\n\t}\n\treturn &pb.Item{Key: req.Key, Value: value}, nil\n}\n\nfunc (s *IntStoreServer) ListItems(stream pb.IntStore_ListItemsServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.mu.RLock()\n\t\tvar results []*pb.Item\n\t\tfor k, v := range s.items {\n\t\t\tif req.Search == \"\" || contains(k, req.Search) {\n\t\t\t\tresults = append(results, &pb.Item{Key: k, Value: v})\n\t\t\t}\n\t\t}\n\t\ts.mu.RUnlock()\n\t\tfor _, item := range results {\n\t\t\tif err := stream.Send(item); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc contains(s, sub string) bool {\n\treturn len(sub) <= len(s) && strings.Contains(s, sub)\n}\n\nfunc (s *IntStoreServer) SetStream(stream pb.IntStore_SetStreamServer) error {\n\tfor {\n\t\titem, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif item == nil || item.Key == \"\" || item.Value == 0 {\n\t\t\tcontinue\n\t\t}\n\t\ts.mu.Lock()\n\t\ts.items[item.Key] = item.Value\n\t\ts.mu.Unlock()\n\t\tif err := stream.Send(&pb.SetResponse{Success: true}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *IntStoreServer) StreamChat(stream pb.IntStore_StreamChatServer) error {\n\tfor {\n\t\titem, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif item == nil || item.Key == \"\" || item.Value == 0 {\n\t\t\tcontinue\n\t\t}\n\t\ts.mu.Lock()\n\t\ts.items[item.Key] = item.Value\n\t\ts.mu.Unlock()\n\t\tif err := stream.Send(item); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC server with configurable network settings, TLS security, and keepalive parameters.\n\nStruct Description: The Server struct represents a gRPC server instance with network listener capabilities. It provides methods to start and stop the server, and handles configuration of security and connection parameters.\n\nFields:\nListener: [net.Listener] - The network listener for incoming connections\nServer: [*grpc.Server] - The gRPC server instance\n\nMethods:\nStart: [Name]() -> [error] - Starts the gRPC server and begins listening for incoming requests. Returns an error if the listener or server is not initialized.\nStop: [Name]() -> [void] - Gracefully stops the gRPC server if it's running.\nNewServer: [Name](address string, tlsConf *tls.Config, srvKaOpts *keepalive.ServerParameters) -> (*Server, error) - Creates a new Server instance with the specified address, TLS configuration, and keepalive parameters. Sets up default values for message sizes, connection timeout, and enforcement policy if not provided. Returns the server instance or an error if initialization fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/keepalive\"\n)\n\ntype Server struct {\n\tListener net.Listener\n\tServer   *grpc.Server\n}\n\nfunc (s *Server) Start() error {\n\tif s.Listener == nil {\n\t\treturn errors.New(\"nil listener\")\n\t}\n\n\tif s.Server == nil {\n\t\treturn errors.New(\"nil server\")\n\t}\n\n\treturn s.Server.Serve(s.Listener)\n}\n\nfunc (s *Server) Stop() {\n\tif s.Server != nil {\n\t\ts.Server.Stop()\n\t}\n}\n\nfunc NewServer(\n\taddress string,\n\ttlsConf *tls.Config,\n\tsrvKaOpts *keepalive.ServerParameters,\n) (*Server, error) {\n\tif address == \"\" {\n\t\treturn nil, errors.New(\"server listen address not provided\")\n\t}\n\n\tlistener, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar serverOpts []grpc.ServerOption\n\n\tif srvKaOpts != nil {\n\t\tserverOpts = append(serverOpts, grpc.KeepaliveParams(*srvKaOpts))\n\t} else {\n\t\tserverKeepAliveParameters := keepalive.ServerParameters{\n\t\t\tTime:    1 * time.Minute,\n\t\t\tTimeout: 20 * time.Second,\n\t\t}\n\t\tserverOpts = append(serverOpts, grpc.KeepaliveParams(serverKeepAliveParameters))\n\t}\n\n\tif tlsConf != nil {\n\t\tserverOpts = append(serverOpts, grpc.Creds(credentials.NewTLS(tlsConf)))\n\t}\n\n\tserverOpts = append(serverOpts, grpc.MaxSendMsgSize(maxSendMessageSize))\n\tserverOpts = append(serverOpts, grpc.MaxRecvMsgSize(maxRecvMessageSize))\n\n\tkep := keepalive.EnforcementPolicy{\n\t\tMinTime:             serverMinInterval,\n\t\tPermitWithoutStream: true,\n\t}\n\tserverOpts = append(serverOpts, grpc.KeepaliveEnforcementPolicy(kep))\n\n\tserverOpts = append(serverOpts, grpc.ConnectionTimeout(connectionTimeout))\n\n\tserver := grpc.NewServer(serverOpts...)\n\n\treturn &Server{Listener: listener, Server: server}, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/server\"\n\t\"google.golang.org/grpc/credentials/tls\"\n\t\"errors\"\n)\n\ntype Server struct {\n\tListener  net.Listener\n\tServer    *grpc.Server\n}\n\nfunc (s *Server) Start() error {\n\tif s.Listener == nil || s.Server == nil {\n\t\treturn errors.New(\"server or listener not initialized\")\n\t}\n\treturn s.Server.Serve(s.Listener, nil)\n}\n\nfunc (s *Server) Stop() {\n\tif s.Server != nil {\n\t\ts.Server.GracefulStop()\n\t}\n}\n\nfunc NewServer(address string, tlsConf *tls.Config, srvKaOpts *keepalive.ServerParameters) (*Server, error) {\n\t// Set default values if not provided\n\tif tlsConf == nil {\n\t\ttlsConf = &tls.Config{}\n\t}\n\tif srvKaOpts == nil {\n\t\tsrvKaOpts = &keepalive.ServerParameters{\n\t\t\tMaxConnectionIdleTime: 10 * time.Second,\n\t\t\tMaxConnectionAge:      30 * time.Second,\n\t\t\tMaxConnectionAgeGraceTime: 5 * time.Second,\n\t\t\tMaxDataSize:           1024 * 1024,\n\t\t\tEnforcementPolicy:     keepalive.EnforcementPolicy{MaxDataSize: 1024 * 1024},\n\t\t}\n\t}\n\n\t// Create the gRPC server with TLS and keepalive options\n\topts := []grpc.ServerOption{\n\t\tgrpc.Creds(tls.NewServerCredentials(tlsConf)),\n\t\tgrpc.KeepaliveParams(srvKaOpts),\n\t\tgrpc.MaxRecvMsgSize(1024 * 1024),\n\t\tgrpc.MaxSendMsgSize(1024 * 1024),\n\t}\n\n\tsrv := grpc.NewServer(opts...)\n\n\t// Create the listener\n\tlistener, err := net.Listen(\"tcp\", address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Server{\n\t\tListener:  listener,\n\t\tServer:    srv,\n\t}, nil"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that sets up and starts a mock gRPC server for management service testing, including generating a WireGuard key for authentication purposes.\n\nFunction Description: The function `startMockManagement` initializes and starts a mock gRPC server that implements a management service interface. It creates a TCP listener on an available port, generates a WireGuard key pair for server authentication, and registers mock implementations of the management service methods. The server runs in a goroutine to handle incoming requests asynchronously.\n\nInput: \n- t *testing.T: Testing context for error reporting and test helpers\n\nOutput:\n- *grpc.Server: The created gRPC server instance\n- net.Listener: The network listener for the server\n- *mock_server.ManagementServiceServerMock: The mock implementation of the management service\n- wgtypes.Key: The generated WireGuard private key for the server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\n\tmgmtProto \"github.com/netbirdio/netbird/management/proto\"\n\t\"github.com/netbirdio/netbird/management/server/mock_server\"\n\t\"golang.zx2c4.com/wireguard/wgctrl/wgtypes\"\n)\n\nfunc startMockManagement(t *testing.T) (*grpc.Server, net.Listener, *mock_server.ManagementServiceServerMock, wgtypes.Key) {\n\tt.Helper()\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ts := grpc.NewServer()\n\n\tserverKey, err := wgtypes.GenerateKey()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmgmtMockServer := &mock_server.ManagementServiceServerMock{\n\t\tGetServerKeyFunc: func(context.Context, *mgmtProto.Empty) (*mgmtProto.ServerKeyResponse, error) {\n\t\t\tresponse := &mgmtProto.ServerKeyResponse{\n\t\t\t\tKey: serverKey.PublicKey().String(),\n\t\t\t}\n\t\t\treturn response, nil\n\t\t},\n\t}\n\n\tmgmtProto.RegisterManagementServiceServer(s, mgmtMockServer)\n\tgo func() {\n\t\tif err := s.Serve(lis); err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\treturn s, lis, mgmtMockServer, serverKey\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"wireguard.com/wireguard-go/wgtypes\"\n)\n\ntype ManagementServiceServerMock struct{}\n\nfunc (s *ManagementServiceServerMock) MockMethod(ctx context.Context, req *ManagementRequest) (*ManagementResponse, error) {\n\treturn &ManagementResponse{Message: \"Mock response\"}, nil\n}\n\ntype ManagementRequest struct {\n\tMessage string\n}\n\ntype ManagementResponse struct {\n\tMessage string\n}\n\nfunc startMockManagement(t *testing.T) (*grpc.Server, net.Listener, *ManagementServiceServerMock, wgtypes.Key) {\n\t// Create a TCP listener on an available port\n\tlistener, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create listener: %v\", err)\n\t}\n\n\t// Generate WireGuard key pair\n\tprivateKey, publicKey, err := wgtypes.GenerateKey()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to generate WireGuard key: %v\", err)\n\t}\n\n\t// Create gRPC server\n\tserver := grpc.NewServer()\n\n\t// Register mock service\n\tmanagementService := &ManagementServiceServerMock{}\n\tmanagementService.RegisterManagementService(server)\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tif err := server.Serve(listener); err != nil {\n\t\t\tt.Fatalf(\"Server failed: %v\", err)\n\t\t}\n\t}()\n\n\treturn server, listener, managementService, privateKey\n}"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Write a Go function that retrieves the private IPv4 address of an Amazon EC2 instance by querying the instance metadata service.\n\nFunction Description: The function should make an HTTP GET request to the EC2 instance metadata service at the well-known endpoint (169.254.169.254) to fetch the local IPv4 address. It should handle potential errors during the request, response reading, and IP parsing, and return the IPv4 address in net.IP format.\n\nInput: None (the function takes no parameters)\n\nOutput: \n- On success: Returns the private IPv4 address as a net.IP object (IPv4 format)\n- On failure: Returns nil and an error describing what went wrong (failed request, invalid response, or invalid IP address)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc amazonEC2PrivateIPv4() (net.IP, error) {\n\tres, err := http.Get(\"http://169.254.169.254/latest/meta-data/local-ipv4\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tip := net.ParseIP(string(body))\n\tif ip == nil {\n\t\treturn nil, errors.New(\"invalid ip address\")\n\t}\n\treturn ip.To4(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/netip\"\n\t\"strings\"\n)\n\nfunc getPrivateIPv4() (netip.Addr, error) {\n\turl := \"http://169.254.169.254/latest/meta-data/local-ipv4\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn netip.Addr{}, fmt.Errorf(\"failed to make HTTP request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn netip.Addr{}, fmt.Errorf(\"unexpected HTTP status code: %d, response: %s\", resp.StatusCode, string(body))\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn netip.Addr{}, fmt.Errorf(\"failed to read response body: %v\", err)\n\t}\n\n\tipStr := strings.TrimSpace(string(body))\n\tif ipStr == \"\" {\n\t\treturn netip.Addr{}, fmt.Errorf(\"empty IP address received\")\n\t}\n\n\tip, err := netip.ParseIP(ipStr)\n\tif err != nil {\n\t\treturn netip.Addr{}, fmt.Errorf(\"invalid IP address: %v\", err)\n\t}\n\n\tif ip.Is4() {\n\t\treturn ip, nil\n\t}\n\n\treturn netip.Addr{}, fmt.Errorf(\"received IPv6 address, but IPv4 was expected\")\n}"
  },
  {
    "Task_id": 316,
    "Instruction": "Task Description: Create a function that performs a simple HTTP GET request to a remote URL and returns the response body as a string.\n\nFunction Description: The function `remote_get` makes an HTTP GET request to the specified remote URL. It handles the response by checking the status code, reading the response body, and returning it as a string. If any errors occur during the request or response processing, they are returned as part of the error output.\n\nInput: \n- `remote` (string): The URL to which the HTTP GET request will be sent.\n\nOutput: \n- (string, error): A tuple containing the response body as a string and an error. If the request is successful, the error will be nil. If an error occurs, the string will be empty, and the error will contain the relevant error message.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc remote_get(remote string) (string, error) {\n\tresp, err := http.Get(remote)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"remote_get: wrong status code %d\", resp.StatusCode))\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc remote_get(remote string) (string, error) {\n\tresp, err := http.Get(remote)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"HTTP request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil\n}"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a RabbitMQ consumer in Go that connects to a RabbitMQ server, declares necessary exchanges and queues, binds them, and consumes messages from the queue. The consumer should be able to gracefully shut down when requested.\n\nStruct Description: The Consumer struct represents a RabbitMQ consumer with connection and channel management capabilities. It handles the lifecycle of consuming messages from a RabbitMQ queue and provides shutdown functionality.\n\nFields:\n- conn: *amqp.Connection - The connection to the RabbitMQ server\n- channel: *amqp.Channel - The communication channel for RabbitMQ operations\n- tag: string - The consumer tag for identifying this consumer\n- done: chan error - Channel for signaling when the consumer has finished shutting down\n\nMethods:\n- NewConsumer: (amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) -> (*Consumer, error) - Creates a new Consumer instance, establishes connection, declares exchange and queue, binds them, and starts consuming messages\n- Shutdown: () -> error - Gracefully shuts down the consumer by canceling consumption and closing the connection\n- handle: (deliveries <-chan amqp.Delivery, done chan error) -> () - Internal method for processing incoming messages (note: this is not exported as it starts with lowercase)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tc := &Consumer{\n\t\tconn:    nil,\n\t\tchannel: nil,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tvar err error\n\n\tlog.Printf(\"dialing %q\", amqpURI)\n\tc.conn, err = amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Dial: %s\", err)\n\t}\n\n\tgo func() {\n\t\tfmt.Printf(\"closing: %s\", <-c.conn.NotifyClose(make(chan *amqp.Error)))\n\t}()\n\n\tlog.Printf(\"got Connection, getting Channel\")\n\tc.channel, err = c.conn.Channel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Channel: %s\", err)\n\t}\n\n\tlog.Printf(\"got Channel, declaring Exchange (%q)\", exchange)\n\tif err = c.channel.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Exchange Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Exchange, declaring Queue %q\", queueName)\n\tqueue, err := c.channel.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Queue (%q %d messages, %d consumers), binding to Exchange (key %q)\",\n\t\tqueue.Name, queue.Messages, queue.Consumers, key)\n\n\tif err = c.channel.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Bind: %s\", err)\n\t}\n\n\tlog.Printf(\"Queue bound to Exchange, starting Consume (consumer tag %q)\", c.tag)\n\tdeliveries, err := c.channel.Consume(\n\t\tqueue.Name,\n\t\tc.tag,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Consume: %s\", err)\n\t}\n\n\tgo handle(deliveries, c.done)\n\n\treturn c, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn fmt.Errorf(\"Consumer cancel failed: %s\", err)\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn fmt.Errorf(\"AMQP connection close error: %s\", err)\n\t}\n\n\treturn <-c.done\n}\n\nfunc handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\n\t\t\t\"got %dB delivery: [%v] %q\",\n\t\t\tlen(d.Body),\n\t\t\td.DeliveryTag,\n\t\t\td.Body,\n\t\t)\n\t\td.Ack(false)\n\t}\n\tdone <- nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 122,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tconn, err := amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tchannel, err := conn.Channel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer channel.Close()\n\n\tif err = channel.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueue, err := channel.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = channel.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmsgs, err := channel.Consume(\n\t\tqueue.Name,\n\t\tctag,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconsumer := &Consumer{\n\t\tconn:   conn,\n\t\tchannel: channel,\n\t\ttag:    ctag,\n\t\tdone:   make(chan error),\n\t}\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tconsumer.handle(d, consumer.done)\n\t\t}\n\t}()\n\n\treturn consumer, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif c == nil {\n\t\treturn nil\n\t}\n\tif c.channel != nil {\n\t\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.conn != nil {\n\t\tif err := c.conn.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Consumer) handle(delivery amqp.Delivery, done chan error) {\n\tfmt.Printf(\"Received message: %s\\n\", delivery.Body)\n\ttime.Sleep(time.Second)\n\tdelivery.Ack()\n\tif err := <-done {\n\t\tlog.Println(\"Shutting down consumer\")\n\t}\n}\n\nfunc main() {\n\tamqpURI := \"amqp://guest:guest@localhost:5672/\"\n\texchange := \"test_exchange\"\n\texchangeType := \"direct\"\n\tqueueName := \"test_queue\"\n\tkey := \"test_key\"\n\tctag := \"consumer_tag\"\n\n\tconsumer, err := NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create consumer: %v\", err)\n\t}\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Register(\"interrupt\", func() { sigChan <- os.Interrupt })\n\tsignal.Register(\"term\", func() { sigChan <- os.Interrupt })\n\n\t<-sigChan\n\tfmt.Println(\"Shutting down consumer...\")\n\tif err := consumer.Shutdown(); err != nil {\n\t\tlog.Fatalf(\"Error shutting down consumer: %v\", err)\n\t}\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a robust RabbitMQ producer in Go that handles connection management, channel initialization, and message publishing with automatic reconnection capabilities.\n\nStruct Description: The Session struct represents a RabbitMQ producer session that maintains connection state and provides message publishing functionality with automatic reconnection.\n\nFields:\n- name: string - The name of the queue to publish to\n- logger: *log.Logger - Logger for session events\n- connection: *amqp.Connection - RabbitMQ connection object\n- channel: *amqp.Channel - RabbitMQ channel object\n- done: chan bool - Channel to signal shutdown\n- notifyConnClose: chan *amqp.Error - Channel for connection close notifications\n- notifyChanClose: chan *amqp.Error - Channel for channel close notifications\n- notifyConfirm: chan amqp.Confirmation - Channel for publish confirmations\n- isReady: bool - Flag indicating if session is ready to publish\n\nMethods:\n- New(name string, addr string) -> *Session - Creates a new Session instance and starts connection management\n- handleReconnect(addr string) - Manages reconnection logic in a goroutine\n- connect(addr string) -> (*amqp.Connection, error) - Establishes connection to RabbitMQ server\n- handleReInit(conn *amqp.Connection) -> bool - Handles channel reinitialization after connection\n- init(conn *amqp.Connection) -> error - Initializes channel and declares queue\n- changeConnection(connection *amqp.Connection) - Updates connection and sets up close notifications\n- changeChannel(channel *amqp.Channel) - Updates channel and sets up close/confirm notifications\n- Push(data []byte) -> error - Safely publishes message with retry logic\n- UnsafePush(data []byte) -> error - Publishes message without safety checks (used internally)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string) *Session {\n\tsession := Session{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tname:   name,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn &session\n}\n\nfunc (session *Session) handleReconnect(addr string) {\n\tfor {\n\t\tsession.isReady = false\n\t\tlog.Println(\"Attempting to connect\")\n\n\t\tconn, err := session.connect(addr)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to connect. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif done := session.handleReInit(conn); done {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (session *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.changeConnection(conn)\n\tlog.Println(\"Connected!\")\n\treturn conn, nil\n}\n\nfunc (session *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\tsession.isReady = false\n\n\t\terr := session.init(conn)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to initialize channel. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn true\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-session.done:\n\t\t\treturn true\n\t\tcase <-session.notifyConnClose:\n\t\t\tlog.Println(\"Connection closed. Reconnecting...\")\n\t\t\treturn false\n\t\tcase <-session.notifyChanClose:\n\t\t\tlog.Println(\"Channel closed. Re-running init...\")\n\t\t}\n\t}\n}\n\nfunc (session *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = ch.QueueDeclare(\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.changeChannel(ch)\n\tsession.isReady = true\n\tlog.Println(\"Setup!\")\n\n\treturn nil\n}\n\nfunc (session *Session) changeConnection(connection *amqp.Connection) {\n\tsession.connection = connection\n\tsession.notifyConnClose = make(chan *amqp.Error)\n\tsession.connection.NotifyClose(session.notifyConnClose)\n}\n\nfunc (session *Session) changeChannel(channel *amqp.Channel) {\n\tsession.channel = channel\n\tsession.notifyChanClose = make(chan *amqp.Error)\n\tsession.notifyConfirm = make(chan amqp.Confirmation, 1)\n\tsession.channel.NotifyClose(session.notifyChanClose)\n\tsession.channel.NotifyPublish(session.notifyConfirm)\n}\n\nfunc (session *Session) Push(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"failed to push: not connected\")\n\t}\n\tfor {\n\t\terr := session.UnsafePush(data)\n\t\tif err != nil {\n\t\t\tsession.logger.Println(\"Push failed. Retrying...\")\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn errors.New(\"session is shutting down\")\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-session.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\tsession.logger.Println(\"Push confirmed!\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t}\n\t\tsession.logger.Println(\"Push didn't confirm. Retrying...\")\n\t}\n}\n\nfunc (session *Session) UnsafePush(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"not connected to a server\")\n\t}\n\treturn session.channel.Publish(\n\t\t\"\",\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Session struct {\n\tname           string\n\tlogger         *log.Logger\n\tconnection     *amqp.Connection\n\tchannel        *amqp.Channel\n\tdone           chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose  chan *amqp.Error\n\tnotifyConfirm    chan amqp.Confirmation\n\tisReady          bool\n}\n\nfunc New(name string, addr string) *Session {\n\ts := &Session{\n\t\tname:           name,\n\t\tlogger:         log.Default(),\n\t\tdone:           make(chan bool),\n\t\tnotifyConnClose: make(chan *amqp.Error),\n\t\tnotifyChanClose: make(chan *amqp.Error),\n\t\tnotifyConfirm:   make(chan amqp.Confirmation),\n\t}\n\tgo s.handleReconnect(addr)\n\treturn s\n}\n\nfunc (s *Session) handleReconnect(addr string) {\n\tfor {\n\t\tif s.connection != nil && s.connection.IsClosed() {\n\t\t\ts.logger.Printf(\"Connection closed, attempting to reconnect...\")\n\t\t\ts.connection, _ = amqp.Dial(addr)\n\t\t\ts.changeConnection(s.connection)\n\t\t}\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}\n\nfunc (s *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\tif err != nil {\n\t\ts.logger.Printf(\"Failed to connect to RabbitMQ: %v\", err)\n\t\treturn nil, err\n\t}\n\ts.changeConnection(conn)\n\treturn conn, nil\n}\n\nfunc (s *Session) handleReInit(conn *amqp.Connection) bool {\n\tif conn == nil {\n\t\treturn false\n\t}\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\ts.logger.Printf(\"Failed to open a channel: %v\", err)\n\t\treturn false\n\t}\n\ts.changeChannel(ch)\n\treturn true\n}\n\nfunc (s *Session) init(conn *amqp.Connection) error {\n\tif s.connection == nil {\n\t\treturn nil\n\t}\n\tif s.handleReInit(conn) {\n\t\tif err := s.channel.QueueDeclare(\n\t\t\ts.name, // queue name\n\t\t\ttrue,   // durable\n\t\t\tfalse,  // exclusive\n\t\t\tfalse,  // auto-delete\n\t\t\tfalse,  // in-duplicate\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.isReady = true\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (s *Session) changeConnection(connection *amqp.Connection) {\n\ts.connection = connection\n\ts.connection.NotifyClose(s.notifyConnClose)\n}\n\nfunc (s *Session) changeChannel(channel *amqp.Channel) {\n\ts.channel = channel\n\ts.channel.NotifyClose(s.notifyChanClose)\n\ts.channel.Confirm(false)\n\ts.channel.NotifyConfirm(s.notifyConfirm)\n}\n\nfunc (s *Session) Push(data []byte) error {\n\tif !s.isReady {\n\t\treturn nil\n\t}\n\tif err := s.channel.Publish(\n\t\t\"\",       // exchange\n\t\ts.name,   // routing key\n\t\tfalse,    // mandatory\n\t\tfalse,    // immediate\n\t\tamqp.Publishing{\n\t\t\tBody: data,\n\t\t},\n\t); err != nil {\n\t\ts.logger.Printf(\"Failed to publish message: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *Session) UnsafePush(data []byte) error {\n\tif err := s.channel.Publish(\n\t\t\"\",       // exchange\n\t\ts.name,   // routing key\n\t\tfalse,    // mandatory\n\t\tfalse,    // immediate\n\t\tamqp.Publishing{\n\t\t\tBody: data,\n\t\t},\n\t); err != nil {\n\t\ts.logger.Printf(\"Failed to publish message: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Implement a RabbitMQ client in Go that handles connection management, queue declaration, and message publishing with retry logic for reliability.\n\nStruct Description: RabbitClient is a struct that encapsulates the functionality for interacting with a RabbitMQ server, including establishing connections, declaring queues, and publishing messages with automatic reconnection attempts on failures.\n\nFields:\n- url: string - The connection URL for the RabbitMQ server\n- queueName: string - The name of the queue to interact with\n- connection: *amqp.Connection - The active RabbitMQ connection\n- channel: *amqp.Channel - The channel for communication with RabbitMQ\n\nMethods:\n- Connect() -> void - Establishes connection to RabbitMQ server, creates a channel, and declares a queue with TTL and priority settings. Implements retry logic on failures.\n- PublishTgMessage(messageBag MessageBag) -> void - Publishes a message to the declared queue after JSON serialization. Implements retry logic on failures and handles reconnection.\n- Close() -> void - Properly closes the channel and connection to RabbitMQ if they exist.\n- NewRabbitClient(url string, queueName string) -> *RabbitClient - Constructor function that initializes and returns a new RabbitClient instance with established connection.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"time\"\n)\n\ntype RabbitClient struct {\n\turl\t\t\tstring\n\tqueueName\tstring\n\tconnection\t*amqp.Connection\n\tchannel\t\t*amqp.Channel\n}\n\nfunc (rc *RabbitClient) Connect() {\n\tfor {\n\t\tvar err error\n\n\t\trc.connection, err = amqp.Dial(rc.url)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't connect to rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\trc.channel, err = rc.connection.Channel()\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't create channel (connect was ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\targs := make(amqp.Table)\n\t\targs[\"x-message-ttl\"] = int32(1000 * 60 * 60 * 24 * 10)\n\t\targs[\"x-max-priority\"] = int32(255)\n\n\t\t_, err = rc.channel.QueueDeclare(\n\t\t\trc.queueName,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\targs,\n\t\t)\n\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\tlog.Printf(\"Can't declare queue (connect, channel were ok) for rabbit %s, will retry after 1 sec: %s\\n\", rc.url, err)\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tfor {\n\t\tbody, err := json.Marshal(messageBag)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error marshaling a message.\")\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Publishing %+v ...\\n\", string(body))\n\n\t\terr = rc.channel.Publish(\n\t\t\t\"\",\n\t\t\trc.queueName,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tamqp.Publishing{\n\t\t\t\tDeliveryMode: amqp.Persistent,\n\t\t\t\tContentType: \"text/plain\",\n\t\t\t\tBody: body,\n\t\t\t\tPriority: messageBag.Priority,\n\t\t\t})\n\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Can't publish text '%s', will retry in 1 sec: %s\", string(body), err)\n\t\t\trc.Close()\n\t\t\trc.Connect()\n\t\t\ttime.Sleep(time.Second * 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n\nfunc (rc *RabbitClient) Close() {\n\tif rc.channel != nil {\n\t\trc.channel.Close()\n\t}\n\tif rc.connection != nil {\n\t\trc.connection.Close()\n\t}\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\trabbit := &RabbitClient{\n\t\turl: url,\n\t\tqueueName: queueName,\n\t}\n\trabbit.Connect()\n\tlog.Println(\"Successfully connected to RabbitMQ\")\n\treturn rabbit\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype MessageBag struct {\n\t// Define fields as needed\n}\n\ntype RabbitClient struct {\n\turl       string\n\tqueueName string\n\tconnection *amqp.Connection\n\tchannel   *amqp.Channel\n}\n\nfunc (c *RabbitClient) Connect() {\n\tfor {\n\t\tfmt.Println(\"Attempting to connect to RabbitMQ...\")\n\t\tconn, err := amqp.Dial(c.url)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to connect: %v\\n\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tc.connection = conn\n\t\tch, err := conn.Channel()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to open channel: %v\\n\", err)\n\t\t\tconn.Close()\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tc.channel = ch\n\t\terr = c.channel.QueueDeclare(\n\t\t\tc.queueName, // queue name\n\t\t\ttrue,        // durable\n\t\t\tfalse,       // exclusive\n\t\t\tfalse,       // auto-delete\n\t\t\tfalse,       // in-dlx\n\t\t\tamqp.Table{\n\t\t\t\t\"x-message-ttl\": 3600000, // 1 hour in milliseconds\n\t\t\t\t\"x-priority\":     5,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to declare queue: %v\\n\", err)\n\t\t\tch.Close()\n\t\t\tconn.Close()\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"Successfully connected and declared queue\")\n\t\treturn\n\t}\n}\n\nfunc (c *RabbitClient) PublishTgMessage(messageBag MessageBag) {\n\tfor {\n\t\tbody, _ := json.Marshal(messageBag)\n\t\terr := c.channel.Publish(\n\t\t\t\"\",        // exchange\n\t\t\tc.queueName, // routing key\n\t\t\tfalse,     // mandatory\n\t\t\tfalse,     // immediate\n\t\t\tamqp.Publishing{\n\t\t\t\tBody:        body,\n\t\t\t\tContentType: \"application/json\",\n\t\t\t\tHeaders:     amqp.Table{\"x-priority\": 5},\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to publish message: %v\\n\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"Message published successfully\")\n\t\treturn\n\t}\n}\n\nfunc (c *RabbitClient) Close() {\n\tif c.connection != nil {\n\t\tc.connection.Close()\n\t}\n\tif c.channel != nil {\n\t\tc.channel.Close()\n\t}\n}\n\nfunc NewRabbitClient(url string, queueName string) *RabbitClient {\n\treturn &RabbitClient{\n\t\turl:       url,\n\t\tqueueName: queueName,\n\t}\n}"
  },
  {
    "Task_id": 337,
    "Instruction": "Task Description: Implement a thread-safe RabbitMQ producer in Go that handles connection management, queue/exchange declaration, and message publishing.\n\nStruct Description: AMQPConn represents a RabbitMQ connection with built-in connection pooling and thread safety. It manages the AMQP connection, channel, and provides message sending capability.\n\nFields:\n\nmu: [sync.Mutex] - Mutex for thread-safe operations\nep: [Endpoint] - Configuration endpoint containing AMQP settings\nconn: [*amqp.Connection] - Underlying AMQP connection\nchannel: [*amqp.Channel] - AMQP channel for message operations\nex: [bool] - Flag indicating if connection is expired\nt: [time.Time] - Timestamp of last operation\n\nMethods:\n\nSend: [Name](msg string) -> [error] - Publishes a message to RabbitMQ. Handles connection establishment, channel creation, and queue/exchange declaration if not already done. Returns error if operation fails.\n[Input Parameters]:\n- msg: string - The message to be published\n[Return Type]:\n- error - Returns nil on success, error on failure",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype AMQPConn struct {\n\tmu      sync.Mutex\n\tep      Endpoint\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\tex      bool\n\tt       time.Time\n}\n\nfunc (conn *AMQPConn) Send(msg string) error {\n\tconn.mu.Lock()\n\tdefer conn.mu.Unlock()\n\n\tif conn.ex {\n\t\treturn errExpired\n\t}\n\tconn.t = time.Now()\n\n\tif conn.conn == nil {\n\t\tprefix := \"amqp://\"\n\t\tif conn.ep.AMQP.SSL {\n\t\t\tprefix = \"amqps://\"\n\t\t}\n\n\t\tvar cfg amqp.Config\n\t\tcfg.Dial = func(network, addr string) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(network, addr, time.Second)\n\t\t}\n\t\tc, err := amqp.DialConfig(fmt.Sprintf(\"%s%s\", prefix, conn.ep.AMQP.URI), cfg)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := channel.ExchangeDeclare(\n\t\t\tconn.ep.AMQP.QueueName,\n\t\t\tconn.ep.AMQP.Type,\n\t\t\tconn.ep.AMQP.Durable,\n\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\tconn.ep.AMQP.Internal,\n\t\t\tconn.ep.AMQP.NoWait,\n\t\t\tnil,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif conn.ep.AMQP.Type != \"topic\" {\n\t\t\tif _, err := channel.QueueDeclare(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.Durable,\n\t\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\t\tfalse,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := channel.QueueBind(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.RouteKey,\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tconn.conn = c\n\t\tconn.channel = channel\n\t}\n\n\treturn conn.channel.Publish(\n\t\tconn.ep.AMQP.QueueName,\n\t\tconn.ep.AMQP.RouteKey,\n\t\tconn.ep.AMQP.Mandatory,\n\t\tconn.ep.AMQP.Immediate,\n\t\tamqp.Publishing{\n\t\t\tHeaders:         amqp.Table{},\n\t\t\tContentType:     \"application/json\",\n\t\t\tContentEncoding: \"\",\n\t\t\tBody:            []byte(msg),\n\t\t\tDeliveryMode:    conn.ep.AMQP.DeliveryMode,\n\t\t\tPriority:        conn.ep.AMQP.Priority,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "right_result": "package main\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n\t\"github.com/streadway/amqp\"\n)\n\ntype Endpoint struct {\n\tHost     string\n\tPort     int\n\tVhost    string\n\tUser     string\n\tPassword string\n}\n\ntype AMQPConn struct {\n\tmu      sync.Mutex\n\tep      *Endpoint\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\tex      bool\n\tt       time.Time\n}\n\nfunc NewAMQPConn(ep *Endpoint) (*AMQPConn, error) {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\treturn &AMQPConn{\n\t\tep:      ep,\n\t\tconn:    conn,\n\t\tchannel: ch,\n\t\tex:      false,\n\t\tt:       time.Now(),\n\t}, nil\n}\n\nfunc (c *AMQPConn) Send(msg string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.ex {\n\t\treturn errors.New(\"connection expired\")\n\t}\n\n\tif c.conn == nil || c.channel == nil {\n\t\tvar err error\n\t\tc.conn, err = amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.channel, err = c.conn.Channel()\n\t\tif err != nil {\n\t\t\tc.conn.Close()\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Declare exchange and queue if not already declared\n\t_, err := c.channel.QueueDeclare(\n\t\t\"task_queue\", // name\n\t\ttrue,         // durable\n\t\tfalse,        // exclusive\n\t\tfalse,        // auto-delete\n\t\tfalse,        // in-dlx\n\t\tnil,          // arguments\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.channel.ExchangeDeclare(\n\t\t\"task_exchange\", // name\n\t\t\"direct\",        // type\n\t\ttrue,            // durable\n\t\tfalse,           // exclusive\n\t\tfalse,           // auto-delete\n\t\tfalse,           // internal\n\t\tnil,             // arguments\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Publish message\n\terr = c.channel.Publish(\n\t\t\"task_exchange\", // exchange\n\t\t\"task_route\",    // routing key\n\t\tfalse,           // mandatory\n\t\tfalse,           // immediate\n\t\tamqp.Publishing{\n\t\t\tBody: []byte(msg),\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.t = time.Now()\n\treturn nil\n}\n\nfunc (c *AMQPConn) Close() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.conn != nil {\n\t\tc.conn.Close()\n\t}\n}"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Create a WebSocket client function in Go that establishes a connection to a server, sends a message, and receives a response using the Gorilla WebSocket library.\n\nFunction Description: The function `TestWebSocketClient` tests WebSocket communication by connecting to a local server, sending a predefined message, and verifying the echoed response. It handles connection establishment, message exchange, and connection cleanup.\n\nInput: \n- `t *testing.T`: Go testing framework context for assertions and logging\n- `serverPort int`: The port number where the WebSocket server is running\n\nOutput: \n- None (void function), but performs assertions to verify successful communication\n- Returns error if any step fails (handled via test assertions)\n\n---\n\nTask Description: Create a WebSocket client function in Go that establishes a connection to a server, sends a message, and receives a response using the Gorilla WebSocket library.\n\nFunction Description: The function `TestWebSocketClient` tests WebSocket communication by connecting to a local server, sending a predefined message, and verifying the echoed response. It handles connection establishment, message exchange, and connection cleanup.\n\nInput: \n- `t *testing.T`: Go testing framework context for assertions and logging\n- `serverPort int`: The port number where the WebSocket server is running\n\nOutput: \n- None (void function), but performs assertions to verify successful communication\n- Returns error if any step fails (handled via test assertions)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/ghttp\"\n\t\"github.com/gogf/gf/v2/test/gtest\"\n\t\"github.com/gogf/gf/v2/util/guid\"\n)\nfunc Test_WebSocket(t *testing.T) {\n\ts := g.Server(guid.S())\n\ts.BindHandler(\"/ws\", func(r *ghttp.Request) {\n\t\tws, err := r.WebSocket()\n\t\tif err != nil {\n\t\t\tr.Exit()\n\t\t}\n\t\tfor {\n\t\t\tmsgType, msg, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = ws.WriteMessage(msgType, msg); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\ts.SetDumpRouterMap(false)\n\ts.Start()\n\tdefer s.Shutdown()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tgtest.C(t, func(t *gtest.T) {\n\t\tconn, _, err := websocket.DefaultDialer.Dial(fmt.Sprintf(\n\t\t\t\"ws://127.0.0.1:%d/ws\", s.GetListenedPort(),\n\t\t), nil)\n\t\tt.AssertNil(err)\n\t\tdefer conn.Close()\n\n\t\tmsg := []byte(\"hello\")\n\t\terr = conn.WriteMessage(websocket.TextMessage, msg)\n\t\tt.AssertNil(err)\n\n\t\tmt, data, err := conn.ReadMessage()\n\t\tt.AssertNil(err)\n\t\tt.Assert(mt, websocket.TextMessage)\n\t\tt.Assert(data, msg)\n\t})\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestWebSocketClient(t *testing.T, serverPort int) {\n\turl := fmt.Sprintf(\"ws://localhost:%d\", serverPort)\n\tconn, _, err := websocket.DefaultDialer.Dial(url, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tmessage := \"Hello, WebSocket!\"\n\tfmt.Printf(\"Sending: %s\\n\", message)\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(message))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to send message: %v\", err)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond) // Allow time for the server to process the message\n\n\tvar receivedMessage string\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to read message: %v\", err)\n\t\t}\n\t\treceivedMessage = string(message)\n\t\tif receivedMessage == message {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif receivedMessage != message {\n\t\tt.Errorf(\"Expected response: %s, got: %s\", message, receivedMessage)\n\t}\n}"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that connects to a server, sends multiple messages at random intervals, and handles incoming messages concurrently.\n\nFunction Description: The function establishes a WebSocket connection to a specified server, spawns a goroutine to continuously read incoming messages, and sends a random number of messages to the server with small delays between each send. The function should properly handle connection errors and ensure the connection is closed when done.\n\nInput:\n- i (int64): Seed value for random number generation\n- room (string): Identifier for the message room/context\n\nOutput: None (the function performs operations but doesn't return any value)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/rs/xid\"\n)\n\nfunc testClient(i int64, room string) {\n\tr := rand.New(rand.NewSource(i))\n\tconn, _, err := websocket.DefaultDialer.Dial(SERVER, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\t_ = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\t\t\t_, _, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tdefer conn.Close()\n\n\tops := r.Intn(100)\n\tfor i := 0; i < ops; i++ {\n\t\tm := msg(r, room)\n\t\terr = conn.WriteMessage(websocket.TextMessage, m)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"err\", err)\n\t\t}\n\t\ttime.Sleep(30 * time.Millisecond)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc connectWebSocket(i int64, room string) {\n\trand.Seed(i)\n\turlStr := \"ws://example.com/ws\" + url.QueryEscape(room)\n\tu, _ := url.Parse(urlStr)\n\tconn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Read error:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"Received: %s\\n\", message)\n\t\t}\n\t}()\n\n\tfor {\n\t\ttime.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)\n\t\tmsg := fmt.Sprintf(\"Message from room %s\", room)\n\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(msg)); err != nil {\n\t\t\tfmt.Println(\"Write error:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Implement a WebSocket handler for processing VNC-related messages, including image capture data and clipboard events, using gorilla WebSocket library in Go.\n\nStruct Description: The Process struct manages WebSocket connections for VNC operations, handling message passing between the WebSocket connection and internal channels.\n\nFields:\n- srv: *http.Server - HTTP server instance\n- chWrite: chan *vncnetwork.VncMsg - Channel for outgoing VNC messages\n- chImage: chan *vncnetwork.ImageData - Channel for incoming image data\n- chClipboard: chan *vncnetwork.ClipboardData - Channel for incoming clipboard data\n\nMethods:\n- ws: (w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket connections, upgrades HTTP to WebSocket, and manages message reading/writing\n- Close: () -> None - Closes the WebSocket connection and cleans up resources (implied by defer p.Close() in ws method)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/rule/vnc/vncnetwork\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype Process struct {\n\tsrv         *http.Server\n\tchWrite     chan *vncnetwork.VncMsg\n\tchImage     chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nvar upgrader = websocket.Upgrader{EnableCompression: true}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tlogging.Info(\"child process connected\")\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tdefer p.Close()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer utils.Recover(\"ws read\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\t_, data, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"read message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar msg vncnetwork.VncMsg\n\t\t\terr = proto.Unmarshal(data, &msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch msg.GetXType() {\n\t\t\tcase vncnetwork.VncMsg_capture_data:\n\t\t\t\tp.chImage <- msg.GetData()\n\t\t\tcase vncnetwork.VncMsg_clipboard_event:\n\t\t\t\tp.chClipboard <- msg.GetClipboard()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer utils.Recover(\"ws write\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmsg := <-p.chWrite\n\t\t\tdata, err := proto.Marshal(msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = conn.WriteMessage(websocket.BinaryMessage, data)\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\twg.Wait()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Process struct {\n\tsrv      *http.Server\n\tchWrite  chan *vncnetwork.VncMsg\n\tchImage  chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Could not upgrade to WebSocket\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif err == websocket.ErrUnexpectedClose {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\thttp.Error(w, \"Error reading message\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tswitch message[0] {\n\t\tcase 'I':\n\t\t\timgData := &vncnetwork.ImageData{}\n\t\t\t// Parse image data from message\n\t\t\tp.chImage <- imgData\n\t\tcase 'C':\n\t\t\tclipData := &vncnetwork.ClipboardData{}\n\t\t\t// Parse clipboard data from message\n\t\t\tp.chClipboard <- clipData\n\t\t}\n\t}\n\n\t// Send any pending messages\n\tfor len(p.chWrite) > 0 {\n\t\tmsg := <-p.chWrite\n\t\terr := conn.WriteMessage(websocket.TextMessage, msg)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error sending message\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Process) Close() {\n\t// Cleanup resources\n}\n\nfunc main() {\n\tp := &Process{\n\t\tsrv:      &http.Server{Addr: \":8080\", Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tp.ws(w, r)\n\t\t})},\n\t\tchWrite:  make(chan *vncnetwork.VncMsg, 100),\n\t\tchImage:  make(chan *vncnetwork.ImageData, 100),\n\t\tchClipboard: make(chan *vncnetwork.ClipboardData, 100),\n\t}\n\n\tgo func() {\n\t\tif err := p.srv.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Start a goroutine to process messages\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase msg := <-p.chWrite:\n\t\t\t\t// Send message over WebSocket\n\t\t\tcase img := <-p.chImage:\n\t\t\t\t// Handle image data\n\t\t\tcase clip := <-p.chClipboard:\n\t\t\t\t// Handle clipboard data\n\t\t\t}\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that handles specific command requests through a web interface. The server should process incoming commands and forward them to a command parser.\n\nFunction Description: The `cmdHandle` function is an HTTP handler that processes POST requests containing a \"cmd\" parameter. It extracts the command and passes it to a command parser. The `InitWeb` function initializes the web server, registers the handler, and starts listening on a specified URL.\n\nInput:\n- For `cmdHandle`:\n  - `w http.ResponseWriter` - Used to write the HTTP response\n  - `r *http.Request` - Contains the incoming HTTP request\n- For `InitWeb`:\n  - None (uses package-level variable `world.Web_Url` for server address)\n\nOutput:\n- For `cmdHandle`:\n  - None (writes response directly to `http.ResponseWriter`)\n- For `InitWeb`:\n  - None (starts server as a side effect, may log errors)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tcmd := r.FormValue(\"cmd\")\n\tif cmd != \"\" {\n\t\tcm.ParseConsole(g_Cmd, (cmd))\n\t}\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/gm\", cmdHandle)\n\terr := http.ListenAndServe(world.Web_Url, nil)\n\tif err != nil {\n\t\tbase.LOG.Println(\"World Web Server : \", err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nvar Web_Url string\n\nfunc cmdHandle(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"POST\" {\n\t\tcmd := r.FormValue(\"cmd\")\n\t\t// Pass cmd to command parser\n\t\t// Placeholder for actual command parsing logic\n\t\tw.Write([]byte(\"Command received: \" + cmd))\n\t}\n}\n\nfunc InitWeb() {\n\thttp.HandleFunc(\"/cmd\", cmdHandle)\n\terr := http.ListenAndServe(Web_Url, nil)\n\tif err != nil {\n\t\tpanic(\"ListenAndServe: \" + err.Error())\n\t}\n}"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Create a test WebSocket server that echoes received messages back to the client while notifying a channel for each received message.\n\nFunction Description: The function creates an HTTP test server with WebSocket support. It upgrades incoming HTTP connections to WebSocket, reads incoming messages, notifies a channel when a message is received, and echoes the message back to the client. The server runs until the connection is closed.\n\nInput:\n- t *testing.T: Testing context for error reporting\n- received chan struct{}: Channel to notify when a message is received\n\nOutput:\n- *httptest.Server: Pointer to the created HTTP test server instance",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\n\tgorillawebsocket \"github.com/gorilla/websocket\"\n)\n\nfunc testService(t *testing.T, received chan struct{}) *httptest.Server {\n\tvar httpHandler http.HandlerFunc = func(w http.ResponseWriter, r *http.Request) {\n\t\tvar upgrader gorillawebsocket.Upgrader\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error upgrading websocket:\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\tt, b, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\n\t\t\tconn.WriteMessage(t, b)\n\t\t}\n\t}\n\n\treturn httptest.NewServer(httpHandler)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc TestWebSocketServer(t *testing.T, received chan struct{}) *httptest.Server {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"upgrade error:\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tt.Log(\"read error:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\t\t\tconn.WriteMessage(websocket.TextMessage, message)\n\t\t}\n\t}))\n\n\treturn server\n}"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The handler function manages WebSocket connections by upgrading HTTP requests, handling incoming messages, and maintaining the connection until closure. It includes error handling for connection issues and logs key events.\n\nInput:\n- w http.ResponseWriter: The HTTP response writer used to send responses\n- r *http.Request: The HTTP request containing connection details\n\nOutput: None (void function), but it performs the following actions:\n- Upgrades HTTP connection to WebSocket\n- Reads and echoes messages\n- Closes the connection when done or on error\n- Logs connection events and errors",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\tnetheader \"knative.dev/networking/pkg/http/header\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif netheader.IsKubeletProbe(r) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading websocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tlog.Println(\"Connection upgraded to WebSocket. Entering receive loop.\")\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, websocket.CloseAbnormalClosure) {\n\t\t\t\tlog.Println(\"Client disconnected.\")\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Handler exiting on error:\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully received: %q\", message)\n\t\tif err = conn.WriteMessage(messageType, message); err != nil {\n\t\t\tlog.Println(\"Failed to write message:\", err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Successfully wrote: %q\", message)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tlog.Println(\"Upgrading HTTP connection to WebSocket\")\n\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading to WebSocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tlog.Println(\"WebSocket connection established\")\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tlog.Printf(\"Received message: %s\", message)\n\n\t\tif err := conn.WriteMessage(websocket.TextMessage, message); err != nil {\n\t\t\tlog.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlog.Println(\"WebSocket connection closed\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleWebSocket)\n\tlog.Println(\"Server started on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, sends a greeting message to the client, and echoes back any messages received from the client.\n\nFunction Description: The function `hello` handles WebSocket communication by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It then enters a loop where it sends a greeting message to the client and reads messages from the client, printing them to the console. The connection is properly closed when the function exits.\n\nInput: \n- `c echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails or if there is an error during message reading/writing. Otherwise, it returns nil once the connection is closed.\n\nNote: The function runs indefinitely in a loop until the WebSocket connection is closed or an error occurs.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc hello(c echo.Context) error {\n\tws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tfor {\n\t\terr := ws.WriteMessage(websocket.TextMessage, []byte(\"Hello, Client!\"))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", msg)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc hello(c echo.Context) error {\n\tconn, err := upgrader.Upgrade(c.Response(), c.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tgreeting := \"Hello, WebSocket!\"\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(greeting))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"Received: %s\\n\", message)\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Create a WebSocket handler function that establishes an SSH connection through a WebSocket interface, allowing for terminal-like interaction with a remote host.\n\nFunction Description: The function `ConnectSshPmExec` handles WebSocket connections to facilitate SSH terminal sessions. It upgrades an HTTP connection to WebSocket, validates host credentials, establishes an SSH connection, and manages bidirectional communication between the WebSocket client and SSH server. The function includes error handling and resource cleanup.\n\nInput:\n- `c` (gin.Context) - Gin framework context for HTTP request handling\n- `username` (string) - Username for authentication (unused in current implementation)\n- `envName` (string) - Environment name (unused in current implementation)\n- `productName` (string) - Product name (unused in current implementation)\n- `ip` (string) - IP address of the target host\n- `hostId` (string) - Identifier for the host's private key\n- `cols` (int) - Terminal column size\n- `rows` (int) - Terminal row size\n- `log` (*zap.SugaredLogger) - Logger for error reporting\n\nOutput:\n- `error` - Returns nil on success, or an error object if any step fails",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ssh\"\n\n\tcommonrepo \"github.com/koderover/zadig/v2/pkg/microservice/aslan/core/common/repository/mongodb\"\n\t\"github.com/koderover/zadig/v2/pkg/setting\"\n\te \"github.com/koderover/zadig/v2/pkg/tool/errors\"\n\ttoolssh \"github.com/koderover/zadig/v2/pkg/tool/ssh\"\n\t\"github.com/koderover/zadig/v2/pkg/tool/wsconn\"\n\t\"github.com/koderover/zadig/v2/pkg/util\"\n)\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\nfunc ConnectSshPmExec(c *gin.Context, username, envName, productName, ip, hostId string, cols, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"ws upgrade err:%s\", err)\n\t\treturn e.ErrLoginPm.AddErr(err)\n\t}\n\n\tdefer ws.Close()\n\tresp, err := commonrepo.NewPrivateKeyColl().Find(commonrepo.FindPrivateKeyOption{\n\t\tID: hostId,\n\t})\n\tif err != nil {\n\t\tlog.Errorf(\"PrivateKey.Find ip %s id %s error: %s\", ip, hostId, err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrGetPrivateKey.Error()))\n\t\treturn e.ErrGetPrivateKey\n\n\t}\n\tif resp.Status != setting.PMHostStatusNormal {\n\t\tlog.Errorf(\"host %s status %s, is not normal\", ip, resp.Status)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s status %s,is not normal\", ip, resp.Status))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.ScheduleWorkflow {\n\t\tlog.Errorf(\"host %s is not enable login\", ip)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s is not enable ssh\", ip))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.Port == 0 {\n\t\tresp.Port = setting.PMHostDefaultPort\n\t}\n\n\tsDec, err := base64.StdEncoding.DecodeString(resp.PrivateKey)\n\tif err != nil {\n\t\tlog.Errorf(\"base64 decode failed ip:%s, error:%s\", ip, err)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"base64 decode failed ip:%s, error:%s\", ip, err))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\n\tsshCli, err := toolssh.NewSshCli(sDec, resp.UserName, resp.IP, resp.Port)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshCli err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshCli.Close()\n\n\tsshConn, err := wsconn.NewSshConn(cols, rows, sshCli)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshConn err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshConn.Close()\n\n\tstopChan := make(chan bool, 3)\n\tgo sshConn.ReadWsMessage(ws, stopChan)\n\tgo sshConn.SendWsWriteMessage(ws, stopChan)\n\tgo sshConn.SessionWait(stopChan)\n\n\t<-stopChan\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "right_result": "package main\n\nimport (\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc ConnectSshPmExec(c *gin.Context, username string, envName string, productName string, ip string, hostId string, cols int, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Error(\"Failed to upgrade connection:\", err)\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Load private key\n\tprivateKey, err := ssh.ParsePrivateKey([]byte(hostId))\n\tif err != nil {\n\t\tlog.Error(\"Failed to parse private key:\", err)\n\t\treturn err\n\t}\n\n\tconfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(privateKey),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\n\t// Establish SSH connection\n\tclient, err := ssh.Dial(\"tcp\", ip+\":22\", config)\n\tif err != nil {\n\t\tlog.Error(\"Failed to dial SSH server:\", err)\n\t\treturn err\n\t}\n\tdefer client.Close()\n\n\t// Create SSH terminal session\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Error(\"Failed to create SSH session:\", err)\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\t// Set terminal size\n\terr = session.Setenv(\"TERM\", \"xterm-256color\")\n\tif err != nil {\n\t\tlog.Error(\"Failed to set environment variable:\", err)\n\t}\n\n\t// Configure terminal size\n\tterminalSize := ssh.TerminalSize{Width: uint16(cols), Height: uint16(rows)}\n\tif err = session.SetTerminalSize(terminalSize); err != nil {\n\t\tlog.Error(\"Failed to set terminal size:\", err)\n\t}\n\n\t// Start reading from SSH session\n\tgo func() {\n\t\tfor {\n\t\t\t_, data, err := session.Reader.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Error reading from SSH session:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tws.Send(data)\n\t\t}\n\t}()\n\n\t// Start writing to SSH session\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Error reading from WebSocket:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err = session.Write(message); err != nil {\n\t\t\t\tlog.Error(\"Error writing to SSH session:\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests on the root path (\"/\") and returns a welcome message.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path. When accessed, it responds with a welcome message. The server listens on port 8080.\n\nInput: None (The HTTP server handles incoming requests automatically)\n\nOutput: None (The function runs indefinitely, serving HTTP responses to incoming requests)\n\n---\n\nNote: Since the reference code is at the package level (with `main` function) rather than a struct/class level, I've provided the function-level instruction format. The code demonstrates a complete executable program rather than a reusable struct/class component.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\tmyHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Welcome to my website!\")\n\t}\n\n\thttp.HandleFunc(\"/\", myHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome to the HTTP server!\")\n\t})\n\n\tfmt.Println(\"Server is running on port 8080...\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a UDP client in Go that can send data to a specified server address and port using the net package's DialUDP function.\n\nStruct Description: The SocketBee struct represents a UDP client capable of sending data to a server. It embeds a bees.Bee for base functionality and includes a channel for event handling.\n\nFields:\neventChan: chan bees.Event - Channel for handling events within the bee framework.\n\nMethods:\nAction: [Name](action bees.Action) -> []bees.Placeholder - Handles the \"send\" action to transmit data to a UDP server. Takes an action object containing the target address, port, and data to send. Returns a list of placeholders (currently unused). Panics on errors during address resolution, connection establishment, or data transmission.",
    "Canonical_solution": "import (\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/muesli/beehive/bees\"\n)\n\ntype SocketBee struct {\n\tbees.Bee\n\n\teventChan chan bees.Event\n}\n\nfunc (mod *SocketBee) Action(action bees.Action) []bees.Placeholder {\n\touts := []bees.Placeholder{}\n\n\tvar data string\n\tvar addr string\n\tvar port int\n\n\taction.Options.Bind(\"address\", &addr)\n\taction.Options.Bind(\"port\", &port)\n\taction.Options.Bind(\"data\", &data)\n\n\tswitch action.Name {\n\tcase \"send\":\n\t\tsa, err := net.ResolveUDPAddr(\"udp\", addr+\":\"+strconv.Itoa(port))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, sa)\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\t_, err = conn.Write([]byte(data))\n\t\tif err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\n\tdefault:\n\t\tpanic(\"Unknown action triggered in \" + mod.Name() + \": \" + action.Name)\n\t}\n\n\treturn outs\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"bees\"\n\t\"net\"\n)\n\ntype SocketBee struct {\n\tbees.Bee\n\teventChan chan bees.Event\n}\n\nfunc (s *SocketBee) Action(a bees.Action) []bees.Placeholder {\n\tif a.Name != \"send\" {\n\t\tpanic(\"unknown action\")\n\t}\n\n\taddr := a.Params[\"address\"].(string)\n\tport := a.Params[\"port\"].(string)\n\tdata := a.Params[\"data\"].(string)\n\n\tremoteAddr, err := net.ResolveUDPAddr(\"udp\", addr+\":\"+port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, remoteAddr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(data))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ts.eventChan <- bees.Event{\n\t\tName: \"sent\",\n\t\tParams: map[string]interface{}{\n\t\t\t\"address\": addr,\n\t\t\t\"port\":    port,\n\t\t\t\"data\":    data,\n\t\t},\n\t}\n\n\treturn []bees.Placeholder{}\n}"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a function to send a Wake-on-LAN (WoL) magic packet to a target device using UDP broadcast.\n\nFunction Description: The function `WakeUp` sends a Wake-on-LAN magic packet to a specified MAC address over UDP broadcast. It allows optional specification of a local network interface for the broadcast and handles the creation and transmission of the magic packet.\n\nInput:\n- `macAddr` (string): The MAC address of the target device to wake up, in format \"XX:XX:XX:XX:XX:XX\"\n- `broadcastIP` (string): The broadcast IP address to use (e.g., \"255.255.255.255\")\n- `bcastInterface` (string): [Optional] The network interface to use for broadcasting. If empty, system default will be used\n- `port` (int): The UDP port number to use for the WoL packet (typically 7 or 9)\n\nOutput:\n- (error): Returns nil on success, or an error if any step fails (invalid MAC, network error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc WakeUp(macAddr, broadcastIP, bcastInterface string, port int) error {\n\tvar localAddr *net.UDPAddr\n\tvar err error\n\tif bcastInterface != \"\" {\n\t\tlocalAddr, err = ipFromInterface(bcastInterface)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbcastAddr := fmt.Sprintf(\"%s:%d\", broadcastIP, port)\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", bcastAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmp, err := New(macAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbs, err := mp.Marshal()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", localAddr, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\tn, err := conn.Write(bs)\n\tif err == nil && n != 102 {\n\t\terr = fmt.Errorf(\"magic packet sent was %d bytes (expected 102 bytes sent)\", n)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc WakeUp(macAddr string, broadcastIP string, bcastInterface string, port int) error {\n\t// Validate MAC address format\n\tif len(macAddr) != 17 || macAddr[2] != ':' && macAddr[5] != ':' && macAddr[8] != ':' && macAddr[11] != ':' && macAddr[14] != ':' {\n\t\treturn fmt.Errorf(\"invalid MAC address format: %s\", macAddr)\n\t}\n\n\t// Parse MAC address into bytes\n\tvar mac [6]byte\n\tparts := strings.Split(macAddr, \":\")\n\tfor i, part := range parts {\n\t\tnum, err := strconv.Atoi(part)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid MAC address part: %s\", part)\n\t\t}\n\t\tmac[i] = byte(num)\n\t}\n\n\t// Create magic packet\n\tmagicPacket := make([]byte, 6+6*16)\n\tcopy(magicPacket[:6], mac[:])\n\tfor i := 0; i < 16; i++ {\n\t\tcopy(magicPacket[6+i*6:], mac[:])\n\t}\n\n\t// Set up UDP connection\n\taddr, err := net.ResolveUDPAddr(\"udp\", fmt.Sprintf(\"%s:%d\", broadcastIP, port))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\n\t// Send magic packet\n\tif _, err := conn.Write(magicPacket); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Write a Go function that tests UDP communication between a client and server. The function should create a UDP server, establish a client connection, send a test message, and verify the server's response.\n\nFunction Description: The function `TestUDPTransport` tests UDP transport functionality by creating a UDP server, sending a message from a client to the server, and verifying that the server receives the correct message. It uses goroutines for asynchronous server handling and channels for communication between the server and test function.\n\nInput: \n- `t *testing.T`: A testing context provided by the Go testing framework for assertions and logging.\n\nOutput: \n- None (This is a test function, so it reports failures via the testing framework rather than returning values). \n\nNote: The function relies on an external `NewTUDPServerTransport` function (not shown in the reference) to create the server transport and a `serveOnce` helper function (also not shown) to handle the server-side receive operation.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\nfunc TestUDPTransport(t *testing.T) {\n\tserver, err := NewTUDPServerTransport(\"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer server.Close()\n\n\tassert.NoError(t, server.Open())\n\tassert.True(t, server.IsOpen())\n\tassert.NotNil(t, server.Conn())\n\n\tc := make(chan []byte)\n\tdefer close(c)\n\n\tgo serveOnce(t, server, c)\n\n\tdestAddr, err := net.ResolveUDPAddr(\"udp\", server.Addr().String())\n\trequire.NoError(t, err)\n\n\tconnUDP, err := net.DialUDP(destAddr.Network(), nil, destAddr)\n\trequire.NoError(t, err)\n\tdefer connUDP.Close()\n\n\tn, err := connUDP.Write([]byte(\"test\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, 4, n)\n\n\tselect {\n\tcase data := <-c:\n\t\tassert.Equal(t, \"test\", string(data))\n\tcase <-time.After(time.Second * 1):\n\t\tt.Error(\"Server did not respond in time\")\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "func TestUDPTransport(t *testing.T) {\n\ttransport, err := NewTUDPServerTransport()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create UDP server transport: %v\", err)\n\t}\n\tserverAddr, err := transport.Listen(\"udp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to listen on UDP server: %v\", err)\n\t}\n\n\tmsg := []byte(\"test message\")\n\tclientAddr := &net.UDPAddr{\n\t\tIP:   net.ParseIP(\"127.0.0.1\"),\n\t\tPort: serverAddr.Port,\n\t}\n\n\tclientConn, err := net.DialUDP(\"udp\", nil, clientAddr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create UDP client connection: %v\", err)\n\t}\n\tdefer clientConn.Close()\n\n\t_, err = clientConn.Write(msg)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to send UDP message: %v\", err)\n\t}\n\n\tresponse := make([]byte, 1024)\n\tn, _, err := clientConn.ReadFromUDP(response)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to receive UDP response: %v\", err)\n\t}\n\n\tif string(response[:n]) != \"Received: test message\" {\n\t\tt.Errorf(\"Expected response 'Received: test message', got '%s'\", string(response[:n]))\n\t}\n}"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a function that establishes a UDP connection to a target server, sends a payload, and reads the server's response.\n\nFunction Description: The function `connectUDP` initiates a UDP connection to a specified target address, sends a given payload, and reads the response from the server. It handles local and remote address resolution, connection establishment, and error handling for network operations.\n\nInput: \n- `target` [string] - The target server address in the format \"host:port\" (e.g., \"127.0.0.1:8080\").\n- `payload` [string] - The data to be sent to the server.\n\nOutput: \n- None (prints the server's response to stdout). The function panics on errors during connection setup, sending, or receiving.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc connectUDP(target, payload string) {\n\tLocalAddr, err := net.ResolveUDPAddr(\"udp\", \":54321\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP local address on port 54321 %v\", err))\n\t}\n\tRemoteAddr, err := net.ResolveUDPAddr(\"udp\", target)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP remote address [%s] %v\", target, err))\n\t}\n\tconn, err := net.DialUDP(\"udp\", LocalAddr, RemoteAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to open connection to [%s] %v\", target, err))\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\t_, err = conn.Write([]byte(\"\\n\"))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tpanic(\"Failed to read from socket\")\n\t}\n\tfmt.Print(string(buf[:n]))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\nfunc connectUDP(target, payload string) {\n\tparts := strings.Split(target, \":\")\n\tif len(parts) != 2 {\n\t\tpanic(\"invalid target format: \" + target)\n\t}\n\thost := parts[0]\n\tport := parts[1]\n\n\taddr, err := net.ResolveUDPAddr(\"udp\", host+\":\"+port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tn, _, err := conn.ReadFromUDP(buffer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(buffer[:n]))\n}"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: The task involves creating a DNS bootstrap resolver that can query DNS servers to resolve domain names to IP addresses using UDP protocol. The resolver should handle concurrent operations, retry failed queries, and manage connection lifecycle properly.\n\nStruct Description: The Bootstrap struct represents a DNS bootstrap resolver that maintains state for DNS queries, including target domain, server address, and query status. It handles concurrent resolution requests and manages connection retries.\n\nFields:\nfqdn: [string] - The fully qualified domain name to resolve\nport: [uint16] - The port number of the DNS server\nbootstrap: [*net.UDPAddr] - The UDP address of the DNS bootstrap server\nqt: [uint16] - The DNS query type (e.g., A or AAAA records)\nlogger: [*zap.Logger] - Logger for debugging and error reporting\nupdating: [atomic.Bool] - Atomic flag indicating if an update is in progress\nnextUpdate: [time.Time] - Timestamp for the next scheduled update\nreadyNotify: [chan struct{}] - Channel to notify when resolution is complete\nm: [sync.Mutex] - Mutex for protecting shared state\nready: [bool] - Flag indicating if resolution is complete\naddrStr: [string] - The resolved address string\n\nMethods:\nresolve: [Name](ctx context.Context, qt uint16) -> (netip.Addr, uint32, error) - Resolves the configured domain name to an IP address using the specified query type. Handles UDP communication with retries and timeout management. Returns the resolved address, its TTL, or an error.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/IrineSistiana/mosdns/v5/pkg/dnsutils\"\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\ntype Bootstrap struct {\n\tfqdn      string\n\tport      uint16\n\tbootstrap *net.UDPAddr\n\tqt        uint16\n\tlogger    *zap.Logger\n\n\tupdating   atomic.Bool\n\tnextUpdate time.Time\n\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (sp *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tconst edns0UdpSize = 1200\n\n\tq := new(dns.Msg)\n\tq.SetQuestion(sp.fqdn, qt)\n\tq.SetEdns0(edns0UdpSize, false)\n\n\tc, err := net.DialUDP(\"udp\", nil, sp.bootstrap)\n\tif err != nil {\n\t\treturn netip.Addr{}, 0, err\n\t}\n\tdefer c.Close()\n\n\twriteErrC := make(chan error, 1)\n\ttype res struct {\n\t\tresp *dns.Msg\n\t\terr  error\n\t}\n\treadResC := make(chan res, 1)\n\n\tcancelWrite := make(chan struct{})\n\tdefer close(cancelWrite)\n\tgo func() {\n\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\twriteErrC <- err\n\t\t\treturn\n\t\t}\n\n\t\tretryTicker := time.NewTicker(time.Second)\n\t\tdefer retryTicker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-cancelWrite:\n\t\t\t\treturn\n\t\t\tcase <-retryTicker.C:\n\t\t\t\tif _, err := dnsutils.WriteMsgToUDP(c, q); err != nil {\n\t\t\t\t\twriteErrC <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tm, _, err := dnsutils.ReadMsgFromUDP(c, edns0UdpSize)\n\t\treadResC <- res{resp: m, err: err}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn netip.Addr{}, 0, context.Cause(ctx)\n\tcase err := <-writeErrC:\n\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to write query, %w\", err)\n\tcase r := <-readResC:\n\t\tresp := r.resp\n\t\terr := r.err\n\t\tif err != nil {\n\t\t\treturn netip.Addr{}, 0, fmt.Errorf(\"failed to read resp, %w\", err)\n\t\t}\n\n\t\tfor _, v := range resp.Answer {\n\t\t\tvar ip net.IP\n\t\t\tvar ttl uint32\n\t\t\tswitch rr := v.(type) {\n\t\t\tcase *dns.A:\n\t\t\t\tip = rr.A\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tcase *dns.AAAA:\n\t\t\t\tip = rr.AAAA\n\t\t\t\tttl = rr.Hdr.Ttl\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr, ok := netip.AddrFromSlice(ip)\n\t\t\tif ok {\n\t\t\t\treturn addr, ttl, nil\n\t\t\t}\n\t\t}\n\n\t\treturn netip.Addr{}, 0, errNoAddrInResp\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\t\"zap\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n)\n\ntype Bootstrap struct {\n\tfqdn      string\n\tport      uint16\n\tbootstrap *net.UDPAddr\n\tqt        uint16\n\tlogger    *zap.Logger\n\tupdating  *atomic.Bool\n\tnextUpdate time.Time\n\treadyNotify chan struct{}\n\tm           sync.Mutex\n\tready       bool\n\taddrStr     string\n}\n\nfunc (b *Bootstrap) resolve(ctx context.Context, qt uint16) (netip.Addr, uint32, error) {\n\tfor {\n\t\tif b.updating.Load() {\n\t\t\ttime.Sleep(time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tb.updating.Store(true)\n\t\tdefer b.updating.Store(false)\n\n\t\tconn, err := net.DialUDP(\"udp\", nil, b.bootstrap)\n\t\tif err != nil {\n\t\t\tb.logger.Error(\"failed to dial UDP server\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tmsg := []byte(b.fqdn)\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\tb.logger.Error(\"failed to write DNS query\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tvar reply []byte\n\t\tn, err := conn.Read(reply)\n\t\tif err != nil {\n\t\t\tb.logger.Error(\"failed to read DNS response\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tif n == 0 {\n\t\t\tb.logger.Error(\"no data received from DNS server\")\n\t\t\tcontinue\n\t\t}\n\n\t\tb.logger.Debug(\"received DNS response\", zap.ByteString(\"response\", reply))\n\n\t\t// Parse DNS response and extract IP address\n\t\tipAddr, ttl, err := parseDNSResponse(reply, qt)\n\t\tif err != nil {\n\t\t\tb.logger.Error(\"failed to parse DNS response\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tb.addrStr = ipAddr.String()\n\t\tb.ready = true\n\t\tclose(b.readyNotify)\n\n\t\treturn ipAddr, ttl, nil\n\t}\n}\n\nfunc parseDNSResponse(reply []byte, qt uint16) (netip.Addr, uint32, error) {\n\t// Implement DNS response parsing logic here\n\t// This is a placeholder for actual DNS parsing code\n\treturn netip.MustParseIPv4Address(\"192.168.1.1\"), 300, nil\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a basic HTTP server in Go that serves a health check endpoint and starts listening on a specified host and port.\n\nFunction Description: The function `startHTTPServer` initializes and starts an HTTP server with a single `/healthz` endpoint that returns a 200 OK status and \"ok\" response. The server listens on the IP address and port specified by the input parameters.\n\nInput: \n- `argHealthzIP` (string pointer): The IP address on which the server should listen.\n- `argHealthzPort` (int pointer): The port number on which the server should listen.\n\nOutput: \n- None (the function runs indefinitely or until an error occurs, in which case it logs the error and exits).",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc startHTTPServer() {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"ok\"))\n\t})\n\n\tklog.Info(\"Starting eventer http service\")\n\tklog.Fatal(http.ListenAndServe(net.JoinHostPort(*argHealthzIP, strconv.Itoa(int(*argHealthzPort))), nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n)\n\nfunc startHTTPServer(argHealthzIP *string, argHealthzPort *int) {\n\tif argHealthzIP == nil || argHealthzPort == nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error: Both IP and port must be provided.\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// Check if the port is within valid range\n\tif *argHealthzPort < 1 || *argHealthzPort > 65535 {\n\t\tfmt.Fprintf(os.Stderr, \"Error: Port must be between 1 and 65535.\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// Create the server address\n\tserverAddr := fmt.Sprintf(\"%s:%d\", *argHealthzIP, *argHealthzPort)\n\n\t// Define the health check handler\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\n\t// Start the server\n\tfmt.Printf(\"Starting HTTP server on %s\\n\", serverAddr)\n\terr := http.ListenAndServe(serverAddr, nil)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error starting server: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\targHealthzIP := \"0.0.0.0\"\n\targHealthzPort := 8080\n\tstartHTTPServer(&argHealthzIP, &argHealthzPort)\n}"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, processes incoming messages using ROT13 cipher, and sends the transformed messages back to the client.\n\nFunction Description: The function initializes a UDP server that continuously listens for incoming datagrams on a specified port. For each received message, it applies the ROT13 cipher transformation and sends the result back to the originating client. The server handles network errors and cleans up resources properly on exit.\n\nInput:\n- port: int - The UDP port number to listen on (passed as a pointer in the original code)\n\nOutput: None (the function runs indefinitely until terminated or an unrecoverable error occurs)\n\nNote: The function uses external packages for logging (github.com/enfein/mieru/v3/pkg/log) and ROT13 transformation (github.com/enfein/mieru/v3/pkg/testtool). The main processing loop includes error handling for network operations and message processing.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n)\nfunc main() {\n\taddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.Itoa(*port))\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ResolveUDPAddr() failed: %v\", err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"net.ListenUDP() failed: %v\", err)\n\t}\n\tlog.Infof(\"UDP server is initialized, listening to %s\", addr.String())\n\tdefer conn.Close()\n\tbuf := make([]byte, 1500)\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Read() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tout, err := testtool.TestHelperRot13(buf[:n])\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"rot13() failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err = conn.WriteToUDP(out, addr); err != nil {\n\t\t\tlog.Errorf(\"Write() failed: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/enfein/mieru/v3/pkg/log\"\n\t\"github.com/enfein/mieru/v3/pkg/testtool\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tport := flag.Int(\"port\", 8080, \"UDP port to listen on\")\n\tflag.Parse()\n\n\tlog.Init(\"udp_server\")\n\n\taddr, err := net.ResolveUDPAddr(\"udp\", fmt.Sprintf(\"%d\", *port))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tlog.Info(fmt.Sprintf(\"UDP server listening on port %d\", *port))\n\n\tfor {\n\t\tbuf := make([]byte, 1024)\n\t\tn, _, err := conn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tmsg := string(buf[:n])\n\t\ttransformed := testtool.ROT13(msg)\n\t\t_, err = conn.WriteToUDP([]byte(transformed), nil)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a UDP server in Go that listens on a specified port, receives messages from clients, and echoes them back to the sender.\n\nFunction Description: The function sets up a UDP server that binds to a given port, continuously listens for incoming messages, and responds by sending the received message back to the client. It handles network errors gracefully and ensures resources are properly cleaned up.\n\nInput: \n- port [string] - The port number on which the UDP server should listen (e.g., \":10002\")\n\nOutput: \n- None (The function runs indefinitely until interrupted)\n- Error messages are printed to stdout if any occur during setup or operation\n\nNote: The function does not return any values but prints status and error messages to stdout. It runs in an infinite loop to handle continuous incoming UDP messages.\n\nThe function performs the following key operations:\n1. Resolves the UDP address using the provided port\n2. Creates and binds a UDP listener\n3. Sets up deferred cleanup for the connection\n4. Enters a loop to read incoming messages and echo them back\n5. Handles and reports any network errors that occur",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tserverType := strings.ToLower(os.Getenv(\"serverType\"))\n\n\tif serverType == \"udp\" {\n\t\tServerAddr, err := net.ResolveUDPAddr(\"udp\", \":10002\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Started UDP server on port 10002\")\n\n\t\tServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\treturn\n\t\t}\n\t\tdefer ServerConn.Close()\n\n\t\tbuf := make([]byte, 1024)\n\n\t\tfor {\n\t\t\tn, addr, err := ServerConn.ReadFromUDP(buf)\n\t\t\tfmt.Printf(\"received: %s from: %s\\n\", string(buf[0:n]), addr)\n\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"error: \", err)\n\t\t\t}\n\n\t\t\tServerConn.WriteTo(buf[0:n], addr)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 112,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tport := flag.String(\"port\", \":10002\", \"UDP port to listen on\")\n\tflag.Parse()\n\n\tif *port == \"\" {\n\t\tfmt.Fprintln(os.Stderr, \"Port is required\")\n\t\tos.Exit(1)\n\t}\n\n\t// Resolve the UDP address\n\taddr, err := net.ResolveUDPAddr(\"udp\", *port)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error resolving address: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Create UDP listener\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error creating listener: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tfmt.Printf(\"UDP server listening on %s\\n\", *port)\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, src, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading from UDP: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif n > 0 {\n\t\t\tmessage := string(buffer[:n])\n\t\t\tfmt.Printf(\"Received from %s: %s\\n\", src, message)\n\t\t\t_, err = conn.WriteToUDP([]byte(message), src)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error writing to UDP: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Implement a WebSocket proxy struct in Go that can handle bidirectional communication between a client and a backend server, including connection upgrading, message replication, and error handling.\n\nStruct Description: The WebsocketProxy struct acts as a reverse proxy for WebSocket connections, forwarding messages between clients and backend servers while handling connection upgrades and error scenarios.\n\nFields:\n\nDirector: func(*http.Request, http.Header) - A function that can modify the outgoing request headers before connecting to the backend.\nBackend: func(*http.Request) *url.URL - A function that returns the backend URL to connect to.\nUpgrader: *websocket.Upgrader - Configures the WebSocket connection upgrade from HTTP.\nDialer: *websocket.Dialer - Configures how to dial the backend WebSocket connection.\n\nMethods:\n\nServeHTTP: (http.ResponseWriter, *http.Request) -> None - The main handler method that:\n  1. Determines the backend URL\n  2. Establishes connection to backend\n  3. Upgrades client connection\n  4. Sets up bidirectional message replication\n  5. Handles ping/pong messages\n  6. Manages connection errors and closures\n\nreplicateWebsocketConn: (*websocket.Conn, *websocket.Conn, chan error) -> None - A helper method that:\n  1. Continuously reads messages from source connection\n  2. Forwards them to destination connection\n  3. Handles connection errors and closure messages\n  4. Reports errors through the provided channel",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/samber/lo\"\n)\n\ntype WebsocketProxy struct {\n\tDirector func(incoming *http.Request, out http.Header)\n\tBackend  func(*http.Request) *url.URL\n\tUpgrader *websocket.Upgrader\n\tDialer   *websocket.Dialer\n}\n\nfunc (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif w.Backend == nil {\n\t\tlog.Println(\"websocketproxy: backend function is not defined\")\n\t\thttp.Error(rw, \"internal server error (code: 1)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tbackendURL := w.Backend(req)\n\tif backendURL == nil {\n\t\tlog.Println(\"websocketproxy: backend URL is nil\")\n\t\thttp.Error(rw, \"internal server error (code: 2)\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdialer := w.Dialer\n\tif w.Dialer == nil {\n\t\tdialer = websocket.DefaultDialer\n\t}\n\n\trequestHeader := http.Header{}\n\tif origin := req.Header.Get(\"Origin\"); origin != \"\" {\n\t\trequestHeader.Add(\"Origin\", origin)\n\t}\n\tfor _, prot := range req.Header[http.CanonicalHeaderKey(\"Sec-WebSocket-Protocol\")] {\n\t\trequestHeader.Add(\"Sec-WebSocket-Protocol\", prot)\n\t}\n\tfor _, cookie := range req.Header[http.CanonicalHeaderKey(\"Cookie\")] {\n\t\trequestHeader.Add(\"Cookie\", cookie)\n\t}\n\tif req.Host != \"\" {\n\t\trequestHeader.Set(\"Host\", req.Host)\n\t}\n\n\tif w.Director != nil {\n\t\tw.Director(req, requestHeader)\n\t}\n\n\tconnBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't dial to remote backend url %s\", err)\n\t\tif resp != nil {\n\t\t\tif err := copyResponse(rw, resp); err != nil {\n\t\t\t\tlog.Printf(\"websocketproxy: couldn't write response after failed remote backend handshake: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\t}\n\t\treturn\n\t}\n\tdefer connBackend.Close()\n\n\tupgrader := w.Upgrader\n\tif w.Upgrader == nil {\n\t\tupgrader = &websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\t}\n\n\tupgradeHeader := http.Header{}\n\tif hdr := resp.Header.Get(\"Sec-Websocket-Protocol\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Sec-Websocket-Protocol\", hdr)\n\t}\n\tif hdr := resp.Header.Get(\"Set-Cookie\"); hdr != \"\" {\n\t\tupgradeHeader.Set(\"Set-Cookie\", hdr)\n\t}\n\n\tconnPub, err := upgrader.Upgrade(rw, req, upgradeHeader)\n\tif err != nil {\n\t\tlog.Printf(\"websocketproxy: couldn't upgrade %s\", err)\n\t\treturn\n\t}\n\tdefer connPub.Close()\n\n\terrClient := make(chan error, 1)\n\terrBackend := make(chan error, 1)\n\n\tgo replicateWebsocketConn(connPub, connBackend, errClient)\n\tgo replicateWebsocketConn(connBackend, connPub, errBackend)\n\n\tconnPub.SetPingHandler(func(appData string) error {\n\t\terr := connBackend.WriteControl(websocket.PingMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = connPub.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(time.Second))\n\t\tif errors.Is(err, websocket.ErrCloseSent) {\n\t\t\treturn nil\n\t\t} else if e, ok := lo.ErrorsAs[net.Error](err); ok && e.Timeout() {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tvar message string\n\tselect {\n\tcase err = <-errClient:\n\t\tmessage = \"websocketproxy: Error when copying from backend to client: %v\"\n\tcase err = <-errBackend:\n\t\tmessage = \"websocketproxy: Error when copying from client to backend: %v\"\n\t}\n\n\tvar closeError *websocket.CloseError\n\tif ok := errors.As(err, &closeError); !ok || (closeError != nil && closeError.Code == websocket.CloseAbnormalClosure) {\n\t\tlog.Printf(message, err)\n\t}\n}\n\nfunc replicateWebsocketConn(dst, src *websocket.Conn, errc chan error) {\n\tfor {\n\t\tmsgType, msg, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tm := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf(\"%v\", err))\n\t\t\tif e, ok := lo.ErrorsAs[*websocket.CloseError](err); ok && e != nil {\n\t\t\t\tif e.Code != websocket.CloseNoStatusReceived {\n\t\t\t\t\tm = websocket.FormatCloseMessage(e.Code, e.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t\terrc <- err\n\t\t\t_ = dst.WriteMessage(websocket.CloseMessage, m)\n\t\t\tbreak\n\t\t}\n\t\terr = dst.WriteMessage(msgType, msg)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype WebsocketProxy struct {\n\tDirector   func(*http.Request, http.Header)\n\tBackend    func(*http.Request) *url.URL\n\tUpgrader   *websocket.Upgrader\n\tDialer     *websocket.Dialer\n}\n\nfunc (p *WebsocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif p.Upgrader.CheckOrigin(r Origin) {\n\t\tbackendURL := p.Backend(r)\n\t\tconn, err := p.Dialer.Dial(backendURL.String(), nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to connect to backend\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\twsConn, err := p.Upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to upgrade connection\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer wsConn.Close()\n\n\t\terrChan := make(chan error, 1)\n\t\tgo p.replicateWebsocketConn(wsConn, conn, errChan)\n\t\tgo p.replicateWebsocketConn(conn, wsConn, errChan)\n\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Connection error\", http.StatusInternalServerError)\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t\thttp.Error(w, \"Timeout\", http.StatusRequestTimeout)\n\t\t}\n\t}\n}\n\nfunc (p *WebsocketProxy) replicateWebsocketConn(src, dst *websocket.Conn, errChan chan error) {\n\tfor {\n\t\t_, message, err := src.ReadMessage()\n\t\tif err != nil {\n\t\t\tif err == websocket.ErrNoData {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terrChan <- err\n\t\t\tbreak\n\t\t}\n\t\tif err := dst.WriteMessage(websocket.TextMessage, message); err != nil {\n\t\t\terrChan <- err\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc Origin(r *http.Request) bool {\n\treturn true\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and returns a simple text response.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" message to the response writer. The `main` function sets up the HTTP server by registering the handler and starting the server on port 8080.\n\nInput: \n- `w http.ResponseWriter`: Used to write the HTTP response.\n- `r *http.Request`: Contains information about the incoming HTTP request.\n\nOutput: \n- The `handler` function writes \"Hello World, I'm Golang!\" to the response writer (`w`).\n- The `main` function starts an HTTP server that listens on port 8080 and serves the response from the `handler` function.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tfmt.Println(\"Server is running on port 8080...\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Go function that securely copies a password to the system clipboard using osascript (AppleScript) via a pipe, ensuring the password is handled safely and the clipboard is cleared after use.\n\nFunction Description: The function `copyViaOsascript` uses an inter-process communication mechanism (pipe) to securely pass a password to the AppleScript command `osascript`, which then sets the password in the system clipboard. The function ensures proper resource cleanup and checks for successful execution.\n\nInput:\n- `ctx context.Context`: Context for managing the command's lifecycle and cancellation.\n- `password string`: The password string to be copied to the clipboard.\n\nOutput:\n- `error`: Returns an error if any step fails (pipe creation, command execution, or clipboard setting). Returns nil on success.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\targs := []string{\n\t\t\"-e\", `use framework \"Foundation\"`,\n\t\t\"-e\", \"use scripting additions\",\n\t\t\"-e\", \"set type to current application's NSPasteboardTypeString\",\n\t\t\"-e\", \"set pb to current application's NSPasteboard's generalPasteboard()\",\n\t\t\"-e\", \"pb's clearContents()\",\n\t\t\"-e\", `pb's setString:\"\" forType:\"org.nspasteboard.ConcealedType\"`,\n\t\t\"-e\", `pb's setString:(do shell script \"cat 0<&3\") forType:type`,\n\t}\n\tcmd := exec.CommandContext(ctx, \"osascript\", args...)\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.ExtraFiles = []*os.File{r}\n\tgo func() {\n\t\tdefer w.Close()\n\t\t_, _ = io.WriteString(w, password)\n\t}()\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(out) != \"true\\n\" {\n\t\treturn fmt.Errorf(\"osascript failed to set password: %s\", string(out))\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\tdefer w.Close()\n\n\tcmd := exec.Command(\"osascript\", \"-e\", \"set the clipboard to \\\"\\\"\")\n\tcmd.Stdin = r\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = w.Write([]byte(password))\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\tif err := cmd.Wait(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawns a child process (via CGO) that runs in a new user namespace, reads the specified file, and returns its contents. It uses two pipes for IPC - one for standard output and another for standard error. The function handles process creation, pipe management, error handling, and cleanup of resources.\n\nInput:\n- nsPath (string): Path to the user namespace configuration\n- path (string): Path to the file to be read\n\nOutput:\n- ([]byte, error): Returns the file contents as bytes if successful, or an error if any step fails (pipe creation, process spawning, reading output, or process execution)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\n\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "right_result": "package main\n\nimport (\n\t\"cgo\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc readFileInNewUserNamespace(nsPath, path string) ([]byte, error) {\n\t// Create pipes for stdout and stderr\n\tstdoutPipe, stdoutReader, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstderrPipe, stderrReader, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set up the user namespace\n\t// This is a simplified example; actual implementation may vary based on system specifics\n\t// For demonstration, we use cgo to call the setns syscall\n\tcgo.CGoFunc(func() {\n\t\tfd, err := os.Open(nsPath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer fd.Close()\n\t\tsyscall.Setns(int(fd.Fd()), syscall.CLONE_NEWUSER)\n\t})\n\n\t// Spawn the child process\n\tcmd := exec.Command(\"sh\", \"-c\", fmt.Sprintf(\"cat %s\", path))\n\tcmd.Stdout = stdoutPipe\n\tcmd.Stderr = stderrPipe\n\n\tif err := cmd.Run(); err != nil {\n\t\t_, _ = stderrReader.Discard()\n\t\treturn nil, err\n\t}\n\n\t// Read the output from the pipes\n\tstdoutBytes, _ := stdoutReader.ReadAll()\n\tstderrBytes, _ := stderrReader.ReadAll()\n\n\t// Close the pipes\n\tstdoutPipe.Close()\n\tstderrPipe.Close()\n\n\t// Return the combined output\n\treturn append(stdoutBytes, stderrBytes...), nil\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Go struct that implements a log retrieval mechanism using pipes for inter-process communication, allowing for reading logs from a file and writing them to a pipe for consumption by another process.\n\nStruct Description: The `logRetriever` struct provides a way to read logs from a file and write them to a pipe, implementing `io.ReadCloser` for standard read and close operations. It also includes methods to manage the pipe's writer and output.\n\nFields:\n- reader: *os.File - The read end of the pipe used to consume log data.\n- writer: *os.File - The write end of the pipe used to send log data.\n- output: *fileCloner - A helper component that clones the writer's output to a log file.\n\nMethods:\n- newlogRetriever: (logFile string) -> (*logRetriever, error) - Initializes a new logRetriever instance, creates a pipe, and sets up file cloning. If the log file exists, copies its contents to the pipe.\n- Read: (p []byte) -> (int, error) - Implements io.Reader to read data from the pipe's reader.\n- CloseWriter: () -> error - Closes the pipe's writer to signal the end of data transmission.\n- Close: () -> error - Implements io.Closer to close the pipe's reader and release resources.\n- Opt: () -> cio.Opt - Returns an option for configuring IO streams, using a null reader and the output cloner.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (l *logRetriever, err error) {\n\tl = &logRetriever{}\n\tif l.reader, l.writer, err = os.Pipe(); err != nil {\n\t\treturn\n\t}\n\n\tif l.output, err = newFileCloner(l.writer, logFile); err != nil {\n\t\treturn\n\t}\n\n\tif util.FileExists(logFile) {\n\t\tvar reader io.ReadCloser\n\t\tif reader, err = os.Open(logFile); err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer util.DeferErr(&err, reader.Close)\n\n\t\tif _, err = io.Copy(l.writer, reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nvar _ io.ReadCloser = &logRetriever{}\n\nfunc (l *logRetriever) Opt() cio.Opt {\n\treturn cio.WithStreams(&nullReader{}, l.output, l.output)\n}\n\nfunc (l *logRetriever) Read(p []byte) (n int, err error) {\n\treturn l.reader.Read(p)\n}\n\nfunc (l *logRetriever) CloseWriter() (err error) {\n\treturn l.writer.Close()\n}\n\nfunc (l *logRetriever) Close() error {\n\treturn l.reader.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"io\"\n\t\"bufio\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (*logRetriever, error) {\n\trw, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutput, err := newfileCloner(logFile)\n\tif err != nil {\n\t\trw.Close()\n\t\treturn nil, err\n\t}\n\n\t// Copy existing log file content to the pipe\n\tsrc, err := os.Open(logFile)\n\tif err != nil {\n\t\trw.Close()\n\t\treturn nil, err\n\t}\n\tdefer src.Close()\n\n\t_, err = io.Copy(rw, src)\n\tif err != nil {\n\t\trw.Close()\n\t\treturn nil, err\n\t}\n\n\treturn &logRetriever{\n\t\treader: rw,\n\t\twriter: rw,\n\t\toutput: output,\n\t}, nil\n}\n\nfunc (lr *logRetriever) Read(p []byte) (int, error) {\n\treturn lr.reader.Read(p)\n}\n\nfunc (lr *logRetriever) CloseWriter() error {\n\treturn lr.writer.Close()\n}\n\nfunc (lr *logRetriever) Close() error {\n\treturn lr.reader.Close()\n}\n\nfunc (lr *logRetriever) Opt() cio.Opt {\n\treturn cio.Opt{\n\t\tReader: bufio.NewReader(lr.reader),\n\t\tWriter: lr.writer,\n\t\tOpt:    lr.output,\n\t}\n}\n\ntype fileCloner struct {\n\tfile *os.File\n}\n\nfunc newfileCloner(logFile string) (*fileCloner, error) {\n\tf, err := os.OpenFile(logFile, os.O_RDONLY, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fileCloner{file: f}, nil\n}\n\nfunc (fc *fileCloner) Clone() error {\n\treturn fc.file.Close()\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Go function that implements a basic HTTP server which responds to all requests with a repeated character response of specified size.\n\nFunction Description: The function should start an HTTP server on a specified port that handles all incoming requests by writing a response consisting of a repeated character ('a') with a length determined by the responseSize parameter. The server should log any errors that occur during writing or server startup.\n\nInput: \n- serverPort: string - The port number on which the HTTP server should listen (e.g., \"8080\")\n- responseSize: int - The size/length of the response to be generated (number of 'a' characters to repeat)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error)\n- Error messages are logged to stdout if any occur during server operation\n\nNote: The function doesn't explicitly return values but runs an HTTP server that handles requests and may log errors. The response is written directly to the http.ResponseWriter for each incoming request.\n\nExample usage:\n```go\nfunc main() {\n    startHTTPServer(\"8080\", 1024)  // Starts server on port 8080 with 1024-byte responses\n}\n```",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tresponse := bytes.Repeat([]byte(\"a\"), int(*responseSize))\n\taddr := \"localhost:\" + *serverPort\n\tlog.Println(\"Starting HTTP server on:\", addr)\n\tlserr := http.ListenAndServe(addr, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, werr := w.Write(response)\n\t\tif werr != nil {\n\t\t\tlog.Println(werr)\n\t\t}\n\t}))\n\tif lserr != nil {\n\t\tlog.Println(lserr)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc startHTTPServer(serverPort string, responseSize int) {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tresponse := make([]byte, responseSize)\n\t\tfor i := range response {\n\t\t\tresponse[i] = 'a'\n\t\t}\n\t\t_, err := w.Write(response)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error writing response:\", err)\n\t\t}\n\t})\n\n\tfmt.Printf(\"Starting HTTP server on port %s\\n\", serverPort)\n\terr := http.ListenAndServe(serverPort, nil)\n\tif err != nil {\n\t\tlog.Println(\"Error starting server:\", err)\n\t}\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Go HTTP server that handles multiple routes and ports concurrently, with specific handlers for different endpoints. The server should mirror incoming requests (displaying request details) by default and respond with \"hello\" for specific pipeline activity routes.\n\nFunction Description: The main function sets up an HTTP server with multiple handlers and listens on multiple ports concurrently. It includes:\n1. A simple helloHandler that responds with \"hello\"\n2. A mirrorHandler that displays detailed request information\n3. Concurrent server instances on ports 9091-9097\n4. A primary server instance on port 9098\n\nInput: None (The functions handle HTTP requests which contain their own input data)\n\nOutput: None (The functions write responses to http.ResponseWriter)\n\nMethods:\n\nhelloHandler: func(w http.ResponseWriter, req *http.Request) - Responds with \"hello\" string\nmirrorHandler: func(w http.ResponseWriter, req *http.Request) - Displays detailed request information including method, URL, headers, and body\nListenAndServe: Called on multiple ports to start HTTP servers concurrently\n\nNote: The code uses http.HandleFunc to register routes and starts servers on multiple ports using goroutines for concurrent operation. The mirrorHandler includes a 10ms delay and outputs request details to both the response and stdout using a TeeWriter.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\nfunc main() {\n\thelloHandler := func(w http.ResponseWriter, req *http.Request) {\n\t\tio.WriteString(w, \"hello\")\n\t}\n\tmirrorHandler := func(w http.ResponseWriter, req *http.Request) {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tbody, err := io.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tbody = []byte(fmt.Sprintf(\"<read failed: %v>\", err))\n\t\t}\n\n\t\ttw := NewTeeWriter(w, os.Stdout)\n\n\t\turl := req.URL.Path\n\t\tif req.URL.Query().Encode() != \"\" {\n\t\t\turl += \"?\" + req.URL.Query().Encode()\n\t\t}\n\n\t\tfmt.Fprintln(tw, \"Your Request\")\n\t\tfmt.Fprintln(tw, \"==============\")\n\t\tfmt.Fprintln(tw, \"Method:\", req.Method)\n\t\tfmt.Fprintln(tw, \"URL   :\", url)\n\n\t\tfmt.Fprintln(tw, \"Header:\")\n\t\tfor k, v := range req.Header {\n\t\t\tfmt.Fprintf(tw, \"    %s: %v\\n\", k, v)\n\t\t}\n\n\t\tfmt.Fprintln(tw, \"Body  :\", string(body))\n\t}\n\n\thttp.HandleFunc(\"/\", mirrorHandler)\n\thttp.HandleFunc(\"/pipeline/activity/1\", helloHandler)\n\thttp.HandleFunc(\"/pipeline/activity/2\", helloHandler)\n\n\tfor _, port := range []int{9091, 9092, 9093, 9094, 9095, 9096, 9097} {\n\t\tgo http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n\t}\n\n\thttp.ListenAndServe(\":9098\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n\t\"github.com/jackc/tee\"\n)\n\nfunc helloHandler(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"hello\")\n}\n\nfunc mirrorHandler(w http.ResponseWriter, req *http.Request) {\n\t// Create a TeeWriter to write to both stdout and response\n\tteeWriter := tee.New(os.Stdout, w)\n\tdefer func() {\n\t\t// Ensure the TeeWriter is closed after use\n\t\tteeWriter.Close()\n\t}()\n\n\t// Set the response header to indicate text/plain content type\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\n\t// Write the request details to the TeeWriter\n\tfmt.Fprintf(teeWriter, \"Method: %s\\n\", req.Method)\n\tfmt.Fprintf(teeWriter, \"URL: %s\\n\", req.URL.String())\n\tfmt.Fprintf(teeWriter, \"Remote Address: %s\\n\", req.RemoteAddr)\n\tfmt.Fprintf(teeWriter, \"User-Agent: %s\\n\", req.UserAgent())\n\tfmt.Fprintf(teeWriter, \"Headers:\\n\")\n\tfor name, values := range req.Header {\n\t\tfmt.Fprintf(teeWriter, \"  %s: %s\\n\", name, strings.Join(values, \", \"))\n\t}\n\tfmt.Fprintf(teeWriter, \"Body (first 100 bytes): %s\\n\", req.Body[:100])\n\ttime.Sleep(10 * time.Millisecond)\n}\n\nfunc main() {\n\t// Register the handlers\n\thttp.HandleFunc(\"/\", helloHandler)\n\thttp.HandleFunc(\"/mirror\", mirrorHandler)\n\n\t// Define the ports to listen on\n\tports := []int{9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098}\n\n\t// Start servers on each port concurrently\n\tfor _, port := range ports {\n\t\tgo func(port int) {\n\t\t\tglog.Infof(\"Starting server on port %d\", port)\n\t\t\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n\t\t\tif err != nil {\n\t\t\t\tglog.Fatalf(\"Error starting server on port %d: %v\", port, err)\n\t\t\t}\n\t\t}(port)\n\t}\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Go struct that represents a financial chart for trading visualization, with capabilities to serve HTTP endpoints for health checks, trading data, and trading history. The struct should maintain candle data, orders, and wallet information, and provide methods to serve this data via HTTP endpoints.\n\nStruct Description: The Chart struct represents a financial trading chart with HTTP server capabilities. It maintains candle data, order information, and paper wallet details, and provides methods to serve this data through HTTP endpoints (/health, /data, /history). The struct uses synchronization to handle concurrent access and provides real-time trading visualization data.\n\nFields:\n\nport: int - The port number on which the HTTP server will listen\ncandles: map[string][]Candle - Stores candle data grouped by trading pairs\ndataframe: map[string]*model.Dataframe - Stores dataframe information for each trading pair\nordersIDsByPair: map[string]*set.LinkedHashSetINT64 - Maintains order IDs organized by trading pairs\norderByID: map[int64]model.Order - Maps order IDs to their corresponding order details\npaperWallet: *exchange.PaperWallet - Pointer to the paper trading wallet information\nlastUpdate: time.Time - Timestamp of the last data update\nMutex: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n\nhandleHealth: (w http.ResponseWriter, _ *http.Request) -> None - Handles health check requests, returning service status based on last update time\nhandleData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading data (candles, asset values, equity values) for a specific trading pair in JSON format\nhandleTradingHistoryData: (w http.ResponseWriter, r *http.Request) -> None - Serves trading history data for a specific pair in CSV format\nStart: () -> error - Starts the HTTP server and registers all endpoint handlers",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/rodrigo-brito/ninjabot/exchange\"\n\t\"github.com/rodrigo-brito/ninjabot/model\"\n\t\"github.com/StudioSol/set\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\ntype Chart struct {\n\tsync.Mutex\n\tport            int\n\tcandles         map[string][]Candle\n\tdataframe       map[string]*model.Dataframe\n\tordersIDsByPair map[string]*set.LinkedHashSetINT64\n\torderByID       map[int64]model.Order\n\tpaperWallet     *exchange.PaperWallet\n\tlastUpdate      time.Time\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, _ *http.Request) {\n\tif time.Since(c.lastUpdate) > time.Hour+10*time.Minute {\n\t\t_, err := w.Write([]byte(c.lastUpdate.String()))\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/json\")\n\n\tvar maxDrawdown *drawdown\n\tif c.paperWallet != nil {\n\t\tvalue, start, end := c.paperWallet.MaxDrawdown()\n\t\tmaxDrawdown = &drawdown{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t\tValue: fmt.Sprintf(\"%.1f\", value*100),\n\t\t}\n\t}\n\n\tasset, quote := exchange.SplitAssetQuote(pair)\n\tassetValues, equityValues := c.equityValuesByPair(pair)\n\terr := json.NewEncoder(w).Encode(map[string]interface{}{\n\t\t\"candles\":       c.candlesByPair(pair),\n\t\t\"asset_values\":  assetValues,\n\t\t\"equity_values\": equityValues,\n\t\t\"quote\":         quote,\n\t\t\"asset\":         asset,\n\t\t\"max_drawdown\":  maxDrawdown,\n\t})\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-type\", \"text/csv\")\n\tw.Header().Set(\"Content-Disposition\", \"attachment;filename=history_\"+pair+\".csv\")\n\tw.Header().Set(\"Transfer-Encoding\", \"chunked\")\n\n\torders := c.orderStringByPair(pair)\n\n\tbuffer := bytes.NewBuffer(nil)\n\tcsvWriter := csv.NewWriter(buffer)\n\terr := csvWriter.Write([]string{\"created_at\", \"status\", \"side\", \"id\", \"type\", \"quantity\", \"price\", \"total\", \"profit\"})\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing header file: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = csvWriter.WriteAll(orders)\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing data: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tcsvWriter.Flush()\n\n\tw.WriteHeader(http.StatusOK)\n\t_, err = w.Write(buffer.Bytes())\n\tif err != nil {\n\t\tlog.Errorf(\"failed writing response: %s\", err.Error())\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n}\n\nfunc (c *Chart) Start() error {\n\thttp.HandleFunc(\"/health\", c.handleHealth)\n\thttp.HandleFunc(\"/history\", c.handleTradingHistoryData)\n\thttp.HandleFunc(\"/data\", c.handleData)\n\n\tfmt.Printf(\"Chart available at http://localhost:%d\\n\", c.port)\n\treturn http.ListenAndServe(fmt.Sprintf(\":%d\", c.port), nil)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Candle struct {\n\tTime     time.Time\n\tOpen     float64\n\tHigh     float64\n\tLow      float64\n\tClose    float64\n\tVolume   float64\n\tTickSize float64\n}\n\ntype Chart struct {\n\tport           int\n\tcandles        map[string][]Candle\n\tdataframe      map[string]*model.Dataframe\n\tordersIDsByPair map[string]*set.LinkedHashSetINT64\n\torderByID      map[int64]model.Order\n\tpaperWallet    *exchange.PaperWallet\n\tlastUpdate     time.Time\n\tmutex          sync.Mutex\n}\n\nfunc (c *Chart) handleHealth(w http.ResponseWriter, r *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tif c.lastUpdate.IsZero() {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(\"Service not initialized\"))\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusOK)\n\tw.Write([]byte(\"Service is running\"))\n}\n\nfunc (c *Chart) handleData(w http.ResponseWriter, r *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Missing 'pair' parameter\"))\n\t\treturn\n\t}\n\tcandles, ok := c.candles[pair]\n\tif !ok {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tw.Write([]byte(\"No data found for this pair\"))\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(model.ToJSON(candles)))\n}\n\nfunc (c *Chart) handleTradingHistoryData(w http.ResponseWriter, r *http.Request) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tpair := r.URL.Query().Get(\"pair\")\n\tif pair == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Missing 'pair' parameter\"))\n\t\treturn\n\t}\n\t// Assuming history data is stored in dataframe\n\tdf, ok := c.dataframe[pair]\n\tif !ok {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tw.Write([]byte(\"No history data found for this pair\"))\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"text/csv\")\n\tw.Write(df.ToCSV())\n}\n\nfunc (c *Chart) Start() error {\n\thttp.HandleFunc(\"/health\", c.handleHealth)\n\thttp.HandleFunc(\"/data\", c.handleData)\n\thttp.HandleFunc(\"/history\", c.handleTradingHistoryData)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Go HTTP server that handles incoming requests, processes JSON payloads, and returns a modified response with a large body and custom headers.\n\nFunction Description: The main function sets up an HTTP server that listens on port 10000. It defines a handler for the root path (\"/\") that:\n1. Reads and closes the request body\n2. Unmarshals the JSON body into a contextEntity struct\n3. Modifies the response status, headers, and body\n4. Marshals the modified contextEntity back to JSON and sends it as the response\n5. Handles errors appropriately with status codes\n\nInput: \n- HTTP requests with JSON body containing a contextEntity structure\n- The handler expects the request body to be a valid JSON representation of contextEntity\n\nOutput:\n- HTTP responses with:\n  - Status 200 on success with modified JSON payload\n  - Status 400 for bad requests (invalid JSON or read errors)\n  - Status 500 for internal server errors (marshaling failures)\n- Response includes:\n  - Custom header \"X-Remote-Name: G.O.O.D\"\n  - Large body (64KB of '-' characters)\n  - Modified contextEntity structure as JSON",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlargeBodySize := 64 * 1024\n\tlargeBody := bytes.Repeat([]byte(`-`), largeBodySize)\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer r.Body.Close()\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity := &contextEntity{}\n\t\terr = json.Unmarshal(body, ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tctxEntity.Response.StatusCode = 200\n\t\tctxEntity.Response.Header.Add(\"X-Remote-Name\", \"G.O.O.D\")\n\t\tctxEntity.Response.Body = largeBody\n\n\t\tbuff, err := json.Marshal(ctxEntity)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(buff)\n\t})\n\n\thttp.ListenAndServe(\":10000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype contextEntity struct {\n\tName string `json:\"name\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Read and close the request body\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tr.Body.Close()\n\n\t\t// Unmarshal the JSON body into a contextEntity struct\n\t\tvar entity contextEntity\n\t\terr = json.Unmarshal(body, &entity)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Modify the response status, headers, and body\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Header().Set(\"X-Remote-Name\", \"G.O.O.D\")\n\n\t\t// Create a large body (64KB of '-' characters)\n\t\tlargeBody := strings.Repeat(\"-\", 65536)\n\t\tw.Write([]byte(largeBody))\n\n\t\t// Marshal the modified contextEntity back to JSON and send it as the response\n\t\tmodifiedEntity := contextEntity{\n\t\t\tName: \"Modified\",\n\t\t}\n\t\tjsonData, err := json.Marshal(modifiedEntity)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tw.Write(jsonData)\n\t})\n\n\tfmt.Println(\"Server is running on port 10000...\")\n\thttp.ListenAndServe(\":10000\", nil)\n}"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a POST request and serves an HTML form for file submission.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it serves an HTML form (rendered from a template). For POST requests, it processes file uploads by saving the uploaded file to the filesystem.\n\nInput:\n- None (The function takes no direct input parameters, but handles HTTP requests with the following characteristics:\n  - GET requests to \"/\" trigger form rendering\n  - POST requests to \"/\" with a \"file\" form field trigger file upload processing)\n\nOutput:\n- None (The function doesn't return any value, but has the following side effects:\n  - Starts an HTTP server on port 9000\n  - Writes responses to http.ResponseWriter\n  - Creates files on the filesystem for successful uploads)",
    "Canonical_solution": "import (\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\ttpl, err := template.ParseFiles(\"form.gohtml\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tif req.Method == \"POST\" {\n\t\t\tsrc, _, err := req.FormFile(\"file\")\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tdefer src.Close()\n\n\t\t\tdst, err := os.Create(filepath.Join(\"./\", \"file.txt\"))\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dst.Close()\n\n\t\t\tio.Copy(dst, src)\n\t\t}\n\n\t\terr = tpl.Execute(res, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), 500)\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\ttmpl, _ := template.ParseFiles(\"upload.html\")\n\t\t\ttmpl.Execute(w, nil)\n\t\t} else if r.Method == \"POST\" {\n\t\t\terr := r.ParseMultipartForm(10 << 20)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error parsing form\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfile, handler, err := r.FormFile(\"file\")\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error retrieving the file\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\tdst, err := os.Create(filepath.Join(\"uploads\", handler.Filename))\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error creating file\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer dst.Close()\n\n\t\t\t_, err = io.Copy(dst, file)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error saving the file\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write([]byte(\"File uploaded successfully\"))\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a simple HTTP server in Go that sets a cookie when the root path (\"/\") is accessed.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. When a request is made to the root path, it responds by setting a cookie named \"my-cookie\" with the value \"some value\".\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests)\n\nOutput: None (The function doesn't return any value; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\thttp.SetCookie(res, &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"some value\",\n\t\t})\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie := &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: \"some value\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t\tw.Write([]byte(\"Cookie set\"))\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a function that serves a genesis file over HTTP on a specified port, setting the appropriate content type and handling the file serving.\n\nFunction Description: The function `ServeGenesisFileAtPort` creates a basic HTTP server that serves a specified genesis file when requested at the `/genesis.car` endpoint. The server sets the content type to `application/octet-stream` and uses the `http.ServeFile` function to handle the file serving. The server runs on the specified port and panics if it fails to start.\n\nInput:  \n- `genesisFilePath` (string): The file path to the genesis file that will be served.  \n- `port` (int): The port number on which the HTTP server will listen.  \n\nOutput:  \n- None (the function does not return; it panics if the server fails to start).",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc ServeGenesisFileAtPort(genesisFilePath string, port int) {\n\thttp.HandleFunc(\"/genesis.car\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\thttp.ServeFile(w, r, genesisFilePath)\n\t})\n\tpanic(http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc ServeGenesisFileAtPort(genesisFilePath string, port int) {\n\thttp.HandleFunc(\"/genesis.car\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\thttp.ServeFile(w, r, genesisFilePath)\n\t})\n\terr := http.ListenAndServe(\":\"+strconv.Itoa(port), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Go HTTP server that acts as a proxy, forwarding requests based on a header value and returning the corresponding stored response.\n\nFunction Description: The main function sets up an HTTP server with a root handler that retrieves and forwards responses based on the \"proxify\" header. It stores responses in a global map and cleans up after forwarding. The server runs concurrently.\n\nInput: \n- options.HTTPListenerAddress (string): The address and port on which the HTTP server should listen (e.g., \":8080\")\n\nOutput: \n- None (the function runs indefinitely as a server)\n- Errors are logged fatally if the server fails to start\n\nNote: The implementation uses global variables (response and responses) for storing and retrieving HTTP responses. The handler expects requests to contain a \"proxify\" header that serves as a key to look up pre-stored responses in the responses map. After forwarding a response, it removes the corresponding entry from the map.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"io\"\n)\n\nvar (\n\tresponse   *http.Response\n\tresponses  map[string]*http.Response\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tkey := req.Header.Get(\"proxify\")\n\t\tresponse := responses[key]\n\t\tdelete(responses, key)\n\n\t\tfor k, v := range response.Header {\n\t\t\tw.Header().Add(k, strings.Join(v, \"; \"))\n\t\t}\n\t\tw.WriteHeader(response.StatusCode)\n\t\tio.Copy(w, response.Body)\n\t})\n\tgo func() {\n\t\tif err := http.ListenAndServe(options.HTTPListenerAddress, nil); err != nil {\n\t\t\tgologger.Fatal().Msgf(\"Could not listen and serve: %s\\n\", err)\n\t\t}\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar response string\nvar responses = make(map[string]string)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\theader := r.Header.Get(\"proxify\")\n\t\tif header == \"\" {\n\t\t\thttp.Error(w, \"Missing 'proxify' header\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tresp, ok := responses[header]\n\t\tif !ok {\n\t\t\thttp.Error(w, \"No response found for given 'proxify' header\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(resp))\n\t\tdelete(responses, header)\n\t})\n\n\tfmt.Printf(\"Server listening on %s\\n\", options.HTTPListenerAddress)\n\terr := http.ListenAndServe(options.HTTPListenerAddress, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// options is a struct containing the HTTP listener address\nvar options struct {\n\tHTTPListenerAddress string\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Go HTTP server that serves as an interface for running and displaying scorecard results for GitHub repositories. The server should handle requests, process repository information, execute scorecard checks, and return results in either JSON or HTML format based on the request's content type.\n\nFunction Description: The `serveCmd` function creates and configures a Cobra command that starts an HTTP server. The server listens for requests, processes GitHub repository URLs, runs scorecard checks on those repositories, and returns the results. The function handles template parsing, route registration, and server startup.\n\nInput: \n- `o *options.Options`: A pointer to an options struct containing configuration settings like log level and commit depth\n\nOutput: \n- `*cobra.Command`: Returns a configured Cobra command that can be executed to start the HTTP server\n\nThe function does not explicitly return any values from its Run method, but it does:\n1. Write HTTP responses to the client (through http.ResponseWriter)\n2. Output logs through the logger\n3. May panic in case of critical errors during template parsing or server startup",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/ossf/scorecard/v5/clients/githubrepo\"\n\t\"github.com/ossf/scorecard/v5/clients/ossfuzz\"\n\t\"github.com/ossf/scorecard/v5/log\"\n\t\"github.com/ossf/scorecard/v5/options\"\n\t\"github.com/ossf/scorecard/v5/pkg/scorecard\"\n)\nfunc serveCmd(o *options.Options) *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve the scorecard program over http\",\n\t\tLong:  ``,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tlogger := log.NewLogger(log.ParseLevel(o.LogLevel))\n\n\t\t\tt, err := template.New(\"webpage\").Parse(tpl)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"parsing webpage template\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\thttp.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\trepoParam := r.URL.Query().Get(\"repo\")\n\t\t\t\tconst length = 3\n\t\t\t\ts := strings.SplitN(repoParam, \"/\", length)\n\t\t\t\tif len(s) != length {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\trepo, err := githubrepo.MakeGithubRepo(repoParam)\n\t\t\t\tif err != nil {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\tctx := r.Context()\n\t\t\t\trepoClient := githubrepo.CreateGithubRepoClient(ctx, logger)\n\t\t\t\tossFuzzRepoClient, err := ossfuzz.CreateOSSFuzzClientEager(ossfuzz.StatusURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"initializing clients\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t\tdefer ossFuzzRepoClient.Close()\n\t\t\t\trepoResult, err := scorecard.Run(ctx, repo,\n\t\t\t\t\tscorecard.WithCommitDepth(o.CommitDepth),\n\t\t\t\t\tscorecard.WithRepoClient(repoClient),\n\t\t\t\t\tscorecard.WithOSSFuzzClient(ossFuzzRepoClient),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"running enabled scorecard checks on repo\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\n\t\t\t\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\t\t\tif err := repoResult.AsJSON(o.ShowDetails, log.ParseLevel(o.LogLevel), rw); err != nil {\n\t\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := t.Execute(rw, repoResult); err != nil {\n\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tport := os.Getenv(\"PORT\")\n\t\t\tif port == \"\" {\n\t\t\t\tport = \"8080\"\n\t\t\t}\n\t\t\tlogger.Info(\"Listening on localhost:\" + port + \"\\n\")\n\t\t\terr = http.ListenAndServe(fmt.Sprintf(\"0.0.0.0:%s\", port), nil)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"listening and serving\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t},\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\ntype Options struct {\n\tLogLevel    string\n\tCommitDepth int\n}\n\nfunc serveCmd(o *Options) *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Start an HTTP server to serve scorecard results for GitHub repositories\",\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// Initialize logger\n\t\t\tlogger := initLogger(o.LogLevel)\n\n\t\t\t// Parse templates\n\t\t\ttmpl, err := parseTemplates()\n\t\t\tif err != nil {\n\t\t\t\tlogger.Fatalf(\"Failed to parse templates: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Register routes\n\t\t\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t// Handle request based on content type\n\t\t\t\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\t\t\t// Process and return JSON response\n\t\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\t\tfmt.Fprintf(w, \"{\\\"status\\\": \\\"ok\\\"}\")\n\t\t\t\t} else {\n\t\t\t\t\t// Render HTML template\n\t\t\t\t\ttmpl.Execute(w, struct{}{})\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Start server\n\t\t\tlogger.Infof(\"Starting HTTP server on :8080\")\n\t\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\t\tlogger.Fatalf(\"Failed to start server: %v\", err)\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc initLogger(level string) *logger.Logger {\n\t// Initialize logger based on level\n\t// This is a placeholder for actual logger initialization\n\treturn &logger.Logger{}\n}\n\nfunc parseTemplates() (template.Template, error) {\n\t// Parse HTML templates\n\t// This is a placeholder for actual template parsing\n\treturn template.Must(template.ParseFiles(\"templates/index.html\")), nil\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Go HTTP server that handles Stripe webhook events, specifically processing billing meter error reports and other event types.\n\nFunction Description: The main function sets up an HTTP server with a \"/webhook\" endpoint that receives and processes Stripe webhook events. It validates the webhook signature, retrieves full event details from Stripe, and handles specific event types (particularly \"v1.billing.meter.error_report_triggered\").\n\nInput:\n- HTTP POST requests to \"/webhook\" endpoint containing:\n  - Request body with Stripe event payload (JSON format)\n  - \"Stripe-Signature\" header for webhook validation\n- Environment variables:\n  - apiKey: Stripe API key for authentication\n  - webhookSecret: Secret for validating webhook signatures\n\nOutput:\n- HTTP responses:\n  - 200 OK for successful processing\n  - 500 Internal Server Error for any processing failures\n- Console output:\n  - Success messages with meter IDs for handled events\n  - Error messages for any processing failures\n  - Notifications for unhandled event types\n\nThe function does not explicitly return values but writes to the HTTP response and console.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/stripe/stripe-go/v81\"\n\tbillingMeters \"github.com/stripe/stripe-go/v81/billing/meter\"\n\t\"github.com/stripe/stripe-go/v81/rawrequest\"\n\twebhook \"github.com/stripe/stripe-go/v81/webhook\"\n)\nfunc main() {\n\tb, err := stripe.GetRawRequestBackend(stripe.APIBackend)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tclient := rawrequest.Client{B: b, Key: apiKey}\n\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) {\n\t\tconst MaxBodyBytes = int64(65536)\n\t\treq.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes)\n\t\tpayload, err := ioutil.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\terr = webhook.ValidatePayload(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar thinEvent map[string]interface{}\n\n\t\tif err := json.Unmarshal(payload, &thinEvent); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse thin event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\teventID := thinEvent[\"id\"].(string)\n\n\t\tvar event map[string]interface{}\n\n\t\tresp, err := client.RawRequest(http.MethodGet, \"/v2/core/events/\"+eventID, \"\", nil)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get pull event: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := json.Unmarshal(resp.RawJSON, &event); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse pull event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tswitch t := event[\"type\"].(string); t {\n\t\tcase \"v1.billing.meter.error_report_triggered\":\n\t\t\trelatedObject := event[\"related_object\"].(map[string]interface{})\n\t\t\tmeter, err := billingMeters.Get(relatedObject[\"id\"].(string), nil)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get related meter object: %v\\n\", err.Error())\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmeterID := meter.ID\n\t\t\tfmt.Printf(\"Success! %s\\n\", meterID)\n\t\t\tfmt.Println(fmt.Sprint(event[\"data\"]))\n\t\tdefault:\n\t\t\tfmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", t)\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\terr = http.ListenAndServe(\":4242\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/stripe/stripe-go/v72/webhook\"\n\t\"github.com/stripe/stripe-go/v72\"\n)\n\nfunc main() {\n\tstripe.SetAPIKey(os.Getenv(\"apiKey\"))\n\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check if the request is a POST\n\t\tif r.Method != \"POST\" {\n\t\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\t// Read the request body\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading request body:\", err)\n\t\t\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tr.Body = io.NopCloser(bytes.NewBuffer(body))\n\n\t\t// Validate the Stripe signature\n\t\tsigHeader := r.Header.Get(\"Stripe-Signature\")\n\t\tevent, err := webhook.Confirm(sigHeader, os.Getenv(\"webhookSecret\"), bytes.NewReader(body))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Webhook validation failed: %v\", err)\n\t\t\thttp.Error(w, \"Webhook validation failed\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Process the event\n\t\tswitch event.Type {\n\t\tcase \"v1.billing.meter.error_report_triggered\":\n\t\t\tmeterID := event.Data.Object.ID\n\t\t\tlog.Printf(\"Handled billing meter error report for meter ID: %s\", meterID)\n\t\t\tfmt.Fprintf(w, \"Success: Billing meter error report handled for meter ID: %s\\n\", meterID)\n\t\tdefault:\n\t\t\tlog.Printf(\"Unhandled event type: %s\", event.Type)\n\t\t\tfmt.Fprintf(w, \"Notification: Unhandled event type: %s\\n\", event.Type)\n\t\t}\n\n\t\t// Return 200 OK\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\tlog.Println(\"Server started on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles user authentication through cookies, displaying different HTML content based on login status.\n\nFunction Description: The main function sets up an HTTP server with a single route handler that manages user authentication. It checks for a \"logged-in\" cookie, processes login/logout requests, and serves different HTML content based on the authentication status.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but serves HTTP responses and maintains server state)\n\nNote: The function handles three main scenarios:\n1. Initial visit (no cookie set)\n2. Successful login (POST with correct password)\n3. Logout request (/logout path)\nFor each scenario, it sets appropriate cookies and returns corresponding HTML content.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"logged-in\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"logged-in\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\n\t\tif req.Method == \"POST\" {\n\t\t\tpassword := req.FormValue(\"password\")\n\t\t\tif password == \"secret\" {\n\t\t\t\tcookie = &http.Cookie{\n\t\t\t\t\tName:  \"logged-in\",\n\t\t\t\t\tValue: \"1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif req.URL.Path == \"/logout\" {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:   \"logged-in\",\n\t\t\t\tValue:  \"0\",\n\t\t\t\tMaxAge: -1,\n\t\t\t}\n\t\t}\n\n\t\thttp.SetCookie(res, cookie)\n\t\tvar html string\n\n\t\tif cookie.Value == strconv.Itoa(0) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1>LOG IN</h1>\n\t\t\t<form method=\"post\" action=\"http://localhost:9000/\">\n\t\t\t\t<h3>User name</h3>\n\t\t\t\t<input type=\"text\" name=\"userName\" id=\"userName\">\n\t\t\t\t<h3>Password</h3>\n\t\t\t\t<input type=\"text\" name=\"password\" id=\"password\">\n\t\t\t\t<br>\n\t\t\t\t<input type=\"submit\">\n\t\t\t\t<input type=\"submit\" name=\"logout\" value=\"logout\">\n\t\t\t</form>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tif cookie.Value == strconv.Itoa(1) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1><a href=\"http://localhost:9000/logout\">LOG OUT</a></h1>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tio.WriteString(res, html)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar loginTemplate = template.Must(template.New(\"login\").Parse(`<!DOCTYPE html>\n<html>\n<head>\n\t<title>Login</title>\n</head>\n<body>\n\t<h2>Login</h2>\n\t<form method=\"post\" action=\"/login\">\n\t\t<label for=\"username\">Username:</label>\n\t\t<input type=\"text\" id=\"username\" name=\"username\" required><br>\n\t\t<label for=\"password\">Password:</label>\n\t\t<input type=\"password\" id=\"password\" name=\"password\" required><br>\n\t\t<input type=\"submit\" value=\"Login\">\n\t</form>\n\t<a href=\"/logout\">Logout</a>\n</body>\n</html>`))\n\nvar dashboardTemplate = template.Must(template.New(\"dashboard\").Parse(`<!DOCTYPE html>\n<html>\n<head>\n\t<title>Dashboard</title>\n</head>\n<body>\n\t<h2>Welcome, User!</h2>\n\t<p>You are logged in.</p>\n\t<a href=\"/logout\">Logout</a>\n</body>\n</html>`))\n\nvar unauthorizedTemplate = template.Must(template.New(\"unauthorized\").Parse(`<!DOCTYPE html>\n<html>\n<head>\n\t<title>Unauthorized</title>\n</head>\n<body>\n\t<h2>Unauthorized</h2>\n\t<p>You are not authorized to view this page.</p>\n\t<a href=\"/login\">Login</a>\n</body>\n</html>`))\n\nfunc login(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"POST\" {\n\t\tusername := r.FormValue(\"username\")\n\t\tpassword := r.FormValue(\"password\")\n\t\tif username == \"user\" && password == \"password\" {\n\t\t\tcookie := &http.Cookie{\n\t\t\t\tName:  \"logged-in\",\n\t\t\t\tValue: \"true\",\n\t\t\t\tMaxAge: 3600, // 1 hour\n\t\t\t\tPath:  \"/\",\n\t\t\t}\n\t\t\thttp.SetCookie(w, cookie)\n\t\t\thttp.Redirect(w, r, \"/\", http.StatusFound)\n\t\t} else {\n\t\t\thttp.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n\t\t}\n\t\treturn\n\t}\n\tloginTemplate.Execute(w, nil)\n}\n\nfunc logout(w http.ResponseWriter, r *http.Request) {\n\tcookie := &http.Cookie{\n\t\tName:   \"logged-in\",\n\t\tValue:  \"false\",\n\t\tMaxAge: -1,\n\t\tPath:   \"/\",\n\t}\n\thttp.SetCookie(w, cookie)\n\thttp.Redirect(w, r, \"/\", http.StatusFound)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"logged-in\")\n\t\tif err == nil && cookie.Value == \"true\" {\n\t\t\tdashboardTemplate.Execute(w, nil)\n\t\t} else {\n\t\t\tloginTemplate.Execute(w, nil)\n\t\t}\n\t})\n\n\thttp.HandleFunc(\"/login\", login)\n\thttp.HandleFunc(\"/logout\", logout)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a simple HTTP server in Go that tracks and displays the number of visits by maintaining a cookie-based counter.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles incoming requests. For each request, it checks for a cookie named \"my-cookie\". If the cookie doesn't exist, it creates one with an initial value of \"0\". The function increments the cookie value on each visit and sends it back in the response, effectively maintaining a visit counter.\n\nInput: None (The function takes no direct input parameters. It responds to HTTP requests received on port 9000.)\n\nOutput: None (The function doesn't return any value. It writes the current visit count to the HTTP response and sets/updates the cookie in the response header.)",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"my-cookie\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"my-cookie\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\t\tcount, _ := strconv.Atoi(cookie.Value)\n\t\tcount++\n\t\tcookie.Value = strconv.Itoa(count)\n\n\t\thttp.SetCookie(res, cookie)\n\n\t\tio.WriteString(res, cookie.Value)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcookie, err := r.Cookie(\"my-cookie\")\n\t\tvar count string\n\t\tif err == nil {\n\t\t\tcount = cookie.Value\n\t\t} else {\n\t\t\tcount = \"0\"\n\t\t}\n\n\t\tnewCount := fmt.Sprintf(\"%d\", count)\n\t\tnewCountInt, _ := strconv.Atoi(newCount)\n\t\tnewCountInt++\n\t\tnewCount = fmt.Sprintf(\"%d\", newCountInt)\n\n\t\tcookie = &http.Cookie{\n\t\t\tName:  \"my-cookie\",\n\t\t\tValue: newCount,\n\t\t\tPath:  \"/\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\n\t\tfmt.Fprintf(w, \"Visit count: %s\\n\", newCount)\n\t})\n\n\tfmt.Println(\"Server started on port 9000\")\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebSocket connections at the root path (\"/\"). The server should load configuration from a JSON file and start listening on a specified port.\n\nFunction Description: The main function initializes the server by loading configuration, setting up a WebSocket handler at the root path, and starting the HTTP server on the configured port.\n\nInput: None (configuration is loaded from \"config.json\" file)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics if server fails to start)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"golang.org/x/net/websocket\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tConfig = load(\"config.json\")\n\t\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\ts := websocket.Server{Handler: websocket.Handler(wsHandler)}\n\t\ts.ServeHTTP(w, req)\n\t})\n\n\terr := http.ListenAndServe(\":\"+strconv.Itoa(Config.Port), nil)\n\tif err != nil {\n\t\tpanic(\"Error: \" + err.Error())\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\ntype Config struct {\n\tPort string `json:\"port\"`\n}\n\nfunc main() {\n\tconfigFile, err := os.Open(\"config.json\")\n\tif err != nil {\n\t\tlog.Fatal(\"Error opening config file:\", err)\n\t}\n\tdefer configFile.Close()\n\n\tdecoder := json.NewDecoder(configFile)\n\tvar config Config\n\tif err := decoder.Decode(&config); err != nil {\n\t\tlog.Fatal(\"Error decoding config file:\", err)\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Upgrade error:\", err)\n\t\t\treturn\n\t\t}\n\t\tgo handleWebSocket(conn)\n\t})\n\n\tlog.Printf(\"Server starting on port %s\", config.Port)\n\terr = http.ListenAndServe(strings.TrimSpace(config.Port), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Server failed to start:\", err)\n\t}\n}\n\nfunc handleWebSocket(conn *websocket.Conn) {\n\tfor {\n\t\t_, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Read error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received: %s\", message)\n\t\tconn.WriteMessage(websocket.TextMessage, message)\n\t}\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles form submissions and displays a simple HTML form.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form. For POST requests, it reads the form value and prints it to the console while still displaying the form. The server listens on port 9000.\n\nInput: None (The function takes no direct input parameters, but receives HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but writes to the HTTP response and prints to console)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t <input type=\"text\" name=\"q\">\n\t\t <input type=\"submit\">\n\n\t\t</form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"text/template\"\n)\n\nvar formHTML = `<!DOCTYPE html>\n<html>\n<head>\n\t<title>Form Example</title>\n</head>\n<body>\n\t<h2>Submit a Form</h2>\n\t<form method=\"post\" action=\"/\">\n\t\t<label for=\"name\">Name:</label>\n\t\t<input type=\"text\" id=\"name\" name=\"name\"><br><br>\n\t\t<input type=\"submit\" value=\"Submit\">\n\t</form>\n</body>\n</html>`\n\nfunc handleForm(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"GET\" {\n\t\tfmt.Fprintf(w, formHTML)\n\t} else if r.Method == \"POST\" {\n\t\tr.ParseForm()\n\t\tname := r.FormValue(\"name\")\n\t\tfmt.Printf(\"Received name: %s\\n\", name)\n\t\tfmt.Fprintf(w, formHTML)\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleForm)\n\tfmt.Println(\"Server running on port 9000...\")\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and starts an HTTP server listening on port 8080.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response.\n- `r *http.Request` - Represents the HTTP request received from the client.\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tfmt.Println(\"Server is running on port 8080...\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles form submissions and displays the submitted value. The server should respond to both GET and POST requests on the root path (\"/\") and render an HTML form with a checkbox input.\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path (\"/\"). The handler processes form submissions, extracts the form value, and returns an HTML response containing the form and the submitted value.\n\nInput: None (The function takes no direct input parameters. Input is received through HTTP requests.)\n\nOutput: None (The function doesn't return any value. Output is sent through the HTTP response writer.)\n\nNote: The function internally uses http.ResponseWriter to send responses and *http.Request to receive requests. The handler checks for a form value with key \"q\" and includes it in the response. The server listens on port 9000.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tval := req.FormValue(key)\n\t\tfmt.Println(\"value: \", val)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\">\n\n\t\t<input type=\"checkbox\" name=\"q\">\n\t\t<input type=\"submit\">\n\n\t\t</form>`+val)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc handleForm(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"POST\" {\n\t\tq := r.FormValue(\"q\")\n\t\tfmt.Fprintf(w, \"Submitted value: %s\", q)\n\t} else {\n\t\tfmt.Fprintf(w, \"<form method='post'> <input type='text' name='q'> <input type='submit'> </form>\")\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleForm)\n\tfmt.Println(\"Server listening on port 9000...\")\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and responds with \"hello world\".\n\nFunction Description: The main function sets up an HTTP server with a single route handler for the root path. The handler writes \"hello world\" as the response. The server listens on port 8080.\n\nInput: None (The function takes no direct input parameters; requests are handled via HTTP)\n\nOutput: None (The function doesn't return anything; responses are written to the http.ResponseWriter)\n\nNote: The reference code shows a complete implementation where:\n1. A handler function is defined to write \"hello world\" response\n2. The handler is registered for the root path \"/\"\n3. The server starts listening on port 8080",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"hello world\")) })\n\nfunc main() {\n\thttp.HandleFunc(\"/\", myHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\t})\n\n\tfmt.Println(\"Server running on port 8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that serves Prometheus metrics via an HTTP server, updating custom metrics (uptime and packet count) on each request.\n\nFunction Description: The ServeMetricsAt function starts an HTTP server to expose Prometheus metrics. It registers custom metrics (uptime and packet count), updates them on each request to the metrics endpoint, and serves the metrics using the Prometheus HTTP handler. The function runs the server in a goroutine to avoid blocking the main program.\n\nInput:\n- addr (string): The network address (including port) where the metrics server should listen (e.g., \":8080\")\n- c (*collector.Collector): A pointer to a collector instance used to get the current packet count (can be nil)\n\nOutput: None (the function runs indefinitely in a background goroutine)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n\t\"github.com/dreadl0ck/netcap/collector\"\n)\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tprometheus.MustRegister(upTime)\n\tprometheus.MustRegister(numPackets)\n\n\tfmt.Println(\"starting to serve metrics at:\", addr+metricsRoute)\n\n\tgo func() {\n\t\tmetricsHandler := promhttp.Handler()\n\n\t\thttp.HandleFunc(metricsRoute, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupTime.WithLabelValues().Set(math.RoundToEven(time.Since(startTime).Seconds())\n\n\t\t\tif c != nil {\n\t\t\t\tnumPackets.WithLabelValues().Set(float64(c.GetNumPackets()))\n\t\t\t}\n\n\t\t\tmetricsHandler.ServeHTTP(w, r)\n\t\t})\n\t\tlog.Fatal(\"failed to serve metrics: \", http.ListenAndServe(addr, nil))\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/histogram\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n)\n\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\t// Register default Prometheus collectors\n\tprometheus.MustRegister(collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}))\n\n\t// Define custom metrics\n\tvar uptime = prometheus.NewGaugeVec(\n\t\tprometheus.GaugeOpts{\n\t\t\tName: \"custom_uptime\",\n\t\t\tHelp: \"Uptime of the service in seconds\",\n\t\t},\n\t\t[]string{\"instance\"},\n\t)\n\tvar packetCount = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"custom_packet_count\",\n\t\t\tHelp: \"Total number of packets processed\",\n\t\t},\n\t\t[]string{\"protocol\"},\n\t)\n\n\t// Register custom metrics\n\tprometheus.MustRegister(uptime, packetCount)\n\n\t// Start HTTP server\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Update uptime\n\t\tuptime.WithLabelValues(\"main\").Set(float64(time.Since(time.Now().UnixNano()).Seconds()))\n\n\t\t// Update packet count (if collector is provided)\n\t\tif c != nil {\n\t\t\tpacketCount.WithLabelValues(\"tcp\").Add(float64(c.GetPacketCount()))\n\t\t}\n\n\t\t// Write metrics\n\t\tprometheus.WriteMetricFamily(w, \"metrics\", prometheus.MetricFamily{Metrics: []prometheus.Metric{uptime, packetCount}})\n\t})\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tif err := http.ListenAndServe(addr, nil); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n}"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a Go HTTP server that handles user sessions through cookies, specifically managing a session ID cookie that can be updated with a user's email address via form submission.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both displaying a form and processing form submissions. It manages a session cookie named \"session-id\" which initially has no value but can be updated with the user's email when submitted through the form. The function writes an HTML response containing the current cookie value and a form for submitting an email address.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests which may contain form data in the \"email\" field)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 9000 and responds to requests with HTML content and cookie operations)",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"session-id\")\n\t\tif err != nil {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName: \"session-id\",\n\t\t\t}\n\t\t}\n\n\t\tif req.FormValue(\"email\") != \"\" {\n\t\t\tcookie.Value = req.FormValue(\"email\")\n\t\t}\n\n\t\thttp.SetCookie(res, cookie)\n\n\t\tio.WriteString(res, `<!DOCTYPE html>\n<html>\n  <body>\n    <form>\n    `+cookie.Value+`\n      <input type=\"email\" name=\"email\">\n      <input type=\"submit\">\n    </form>\n  </body>\n</html>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar tmpl *template.Template\n\nfunc init() {\n\ttmpl = template.Must(template.New(\"\").Parse(`<!DOCTYPE html>\n<html>\n<head>\n\t<title>Session Cookie Example</title>\n</head>\n<body>\n\t<h1>Session Cookie Example</h1>\n\t<p>Current session ID: {{.SessionID}}</p>\n\t<form method=\"post\">\n\t\t<label for=\"email\">Enter your email:</label>\n\t\t<input type=\"email\" id=\"email\" name=\"email\" required>\n\t\t<button type=\"submit\">Submit</button>\n\t</form>\n</body>\n</html>`))\n}\n\nfunc handleRoot(w http.ResponseWriter, r *http.Request) {\n\tsessionID := r.Cookies()[0].Value\n\ttmpl.Execute(w, map[string]string{\"SessionID\": sessionID})\n}\n\nfunc handleForm(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"POST\" {\n\t\temail := r.FormValue(\"email\")\n\t\tcookie := &http.Cookie{\n\t\t\tName:  \"session-id\",\n\t\t\tValue: email,\n\t\t\tMaxAge: 3600, // 1 hour\n\t\t\tPath:  \"/\",\n\t\t}\n\t\thttp.SetCookie(w, cookie)\n\t\thttp.Redirect(w, r, \"/\", http.StatusFound)\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\thttp.HandleFunc(\"/submit\", handleForm)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a WebSocket server in Go that handles WebSocket connections, upgrades HTTP connections to WebSocket, and manages the connections.\n\nFunction Description: The code consists of two main functions: `StartWSServer` and `wsHandler`. `StartWSServer` initializes and starts an HTTP server that listens for WebSocket connections on a specified address. `wsHandler` is the HTTP handler function that upgrades incoming HTTP requests to WebSocket connections and processes them.\n\nInput: \n- `StartWSServer`: `address` (string) - The network address (e.g., \":8080\") on which the server will listen for incoming connections.\n- `wsHandler`: `w` (http.ResponseWriter) - Used to construct the HTTP response. `r` (*http.Request) - The HTTP request to be upgraded to a WebSocket connection.\n\nOutput: \n- `StartWSServer`: None (panics on error).\n- `wsHandler`: None (logs errors if the WebSocket upgrade fails).",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 65536,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\twsConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\n\tconn := &Conn{\n\t\tCoonType: ConnTypeWS,\n\t\tWS:       wsConn,\n\t}\n\tDoConn(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Failed to upgrade to WebSocket:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received: %s\", msg)\n\t\terr = conn.WriteMessage(msgType, msg)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\tlog.Println(\"Starting WebSocket server on\", address)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to start server:\", err)\n\t}\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and responds with plain text.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes a plain text response (\"Dog\") to the client. The handler also sets the Content-Type header to \"text/plain\".\n\nInput: None (The function takes no direct input parameters; it handles HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return anything; it runs an HTTP server indefinitely until interrupted)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tres.Header()[\"Content-Type\"] = []string{\"text/plain\"}\n\t\tfmt.Fprint(res, \"Dog\")\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.Write([]byte(\"Dog\"))\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a Go function that sets up an HTTP server to serve web content, including handling specific routes for examples and serving static files.\n\nFunction Description: The `serve` function initializes an HTTP server that handles multiple routes. It serves a home page, handles requests for WASM execution files, and processes example-related routes with dynamic content generation. The function uses Go's `net/http` package to create routes and serve content, including HTML templates and static files.\n\nInput: \n- `addr` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\")\n\nOutput:\n- `error`: Returns an error if the server fails to start, otherwise runs indefinitely serving HTTP requests\n\nThe function performs these key operations:\n1. Loads example data using `getExamples()`\n2. Sets up template handling for the home page and example pages\n3. Configures route handlers for:\n   - Root path (\"/\") serving the home page\n   - WASM execution file (\"/wasm_exec.js\")\n   - Example paths (\"/example/[type]/[link]/...\")\n4. Starts the HTTP server on the specified address",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\n\thomeTemplate := template.Must(template.ParseFiles(\"index.html\"))\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\turl := r.URL.Path\n\t\tif url == \"/wasm_exec.js\" {\n\t\t\thttp.FileServer(http.Dir(filepath.Join(build.Default.GOROOT, \"misc/wasm/\"))).ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.Split(url, \"/\")\n\t\tif len(parts) > 4 &&\n\t\t\tparts[1] == \"example\" {\n\t\t\texampleType := parts[2]\n\t\t\texampleLink := parts[3]\n\t\t\tfor _, example := range *examples {\n\t\t\t\tif example.Link != exampleLink {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfiddle := filepath.Join(exampleLink, \"jsfiddle\")\n\t\t\t\tif len(parts[4]) != 0 {\n\t\t\t\t\thttp.StripPrefix(\"/example/\"+exampleType+\"/\"+exampleLink+\"/\", http.FileServer(http.Dir(fiddle))).ServeHTTP(w, r)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttemp := template.Must(template.ParseFiles(\"example.html\"))\n\t\t\t\t_, err := temp.ParseFiles(filepath.Join(fiddle, \"demo.html\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\n\t\t\t\tdata := struct {\n\t\t\t\t\t*Example\n\t\t\t\t\tJS bool\n\t\t\t\t}{\n\t\t\t\t\texample,\n\t\t\t\t\texampleType == \"js\",\n\t\t\t\t}\n\n\t\t\t\terr = temp.Execute(w, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\terr := homeTemplate.Execute(w, examples)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc serve(addr string) error {\n\texamples := getExamples()\n\n\ttmpl, err := template.ParseFiles(\"home.html\", \"example.html\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttmpl.Execute(w, examples)\n\t})\n\n\thttp.HandleFunc(\"/wasm_exec.js\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"wasm_exec.js\")\n\t})\n\n\thttp.HandleFunc(\"/example/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparts := r.URL.Path[8:]\n\t\tif len(parts) == 0 {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\ttmpl.Execute(w, parts)\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Go HTTP server that handles multiple routes with different authentication methods (Basic Auth and Bearer Token) and serves Prometheus metrics on authenticated endpoints.\n\nFunction Description: The main function sets up an HTTP server with three routes:\n1. Root (\"/\") route with a basic handler\n2. \"/metrics\" route protected by Basic Authentication\n3. \"/bearer-metrics\" route protected by Bearer Token authentication\nThe server listens on port 8080 and uses the net/http package for HTTP operations.\n\nInput: None (The function takes no direct input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The implementation assumes the existence of two helper functions:\n1. checkBasicAuth(w http.ResponseWriter, r *http.Request) bool\n2. checkBearerAuth(w http.ResponseWriter, r *http.Request) bool\nwhich handle the respective authentication methods.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.HandleFunc(\"/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBasicAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\thttp.HandleFunc(\"/bearer-metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif checkBearerAuth(w, r) {\n\t\t\tpromhttp.Handler().ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"WWW-Authenticate\", `Bearer realm=\"MY REALM\"`)\n\t\tw.WriteHeader(401)\n\t\tw.Write([]byte(\"401 Unauthorized\\n\"))\n\t})\n\n\taddress := \":8080\"\n\n\t_ = http.ListenAndServe(address, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, World!\"))\n\t})\n\n\thttp.HandleFunc(\"/metrics\", checkBasicAuth)\n\thttp.HandleFunc(\"/bearer-metrics\", checkBearerAuth)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles multiple routes with different functionalities, including a root route, a route to display request headers, and a route to show build information.\n\nFunction Description: The HTTP server will respond to different endpoints with specific behaviors:\n1. Root endpoint (\"/\") returns a greeting message\n2. \"/headers\" endpoint returns all request headers\n3. \"/api/buildstamp\" endpoint returns build information\n\nInput: \n- HTTP requests to specified endpoints (/, /headers, /api/buildstamp)\n- BuildStamp string variable containing build information\n\nOutput: \n- For \"/\": Plain text response \"hello, my name is Go~~\"\n- For \"/headers\": List of all request headers in \"name: value\" format\n- For \"/api/buildstamp\": Current value of BuildStamp variable\n- HTTP responses through the http.ResponseWriter interface",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar BuildStamp = \"No Build Stamp Provided\"\n\nfunc hello(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"hello, my name is Go~~\\n\")\n}\n\nfunc headers(w http.ResponseWriter, req *http.Request) {\n\tfor name, headers := range req.Header {\n\t\tfor _, h := range headers {\n\t\t\tfmt.Fprintf(w, \"%v: %v\\n\", name, h)\n\t\t}\n\t}\n}\n\nfunc buildStamp(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"%s\", BuildStamp)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", hello)\n\thttp.HandleFunc(\"/api/buildstamp\", buildStamp)\n\thttp.HandleFunc(\"/headers\", headers)\n\n\thttp.ListenAndServe(\":20219\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar BuildStamp string\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"hello, my name is Go~~\")\n\t})\n\n\thttp.HandleFunc(\"/headers\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfor name, headers := range r.Header {\n\t\t\tfor _, value := range headers {\n\t\t\t\tfmt.Fprintf(w, \"%s: %s\\n\", name, value)\n\t\t\t}\n\t\t}\n\t})\n\n\thttp.HandleFunc(\"/api/buildstamp\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"%s\", BuildStamp)\n\t})\n\n\tfmt.Println(\"Server started at port 8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles requests to the root path (\"/\") and returns a welcome message combined with a predefined string variable and a version string.\n\nFunction Description: The main function sets up a basic HTTP server that listens on port 8080. It registers a handler function for the root path (\"/\") which writes a welcome message concatenated with a local string variable and a package-level version string to the response.\n\nInput: None (The HTTP server listens for incoming requests on the specified port)\n\nOutput: None (The function runs indefinitely, serving HTTP responses. The handler writes output to the http.ResponseWriter)\n\nNote: The reference code is at the package level (main package) rather than being encapsulated in a struct or class. The instruction follows the function-level format as requested.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar v string = \"v1.0\"\n\nfunc main() {\n\ta := \"hello \"\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, \"Welcome to my website! \", a, v)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar welcomeMessage = \"Welcome to the server!\"\nvar version = \"1.0.0\"\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tresponse := fmt.Sprintf(\"%s %s\", welcomeMessage, version)\n\t\tfmt.Fprintf(w, response)\n\t})\n\tfmt.Println(\"Server is running on port 8080...\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that starts a debug HTTP server with various endpoints for monitoring and debugging purposes, including standard debug endpoints (pprof, metrics, trace) and custom endpoints.\n\nFunction Description: The function `Start` initializes and launches an HTTP server with multiple debugging and monitoring endpoints. It sets up handlers for standard endpoints like pprof, expvar, trace, and metrics, along with any additional custom endpoints provided. The server runs on a predefined address and serves an index page with links to all available endpoints.\n\nInput: \n- `extra ...Endpoint`: Variadic parameter accepting zero or more custom endpoint objects. Each Endpoint should have:\n  - `Path`: string - The URL path for the endpoint\n  - `Name`: string - Display name for the endpoint\n  - `Handler`: http.Handler - The handler function for the endpoint\n\nOutput: None (the function runs indefinitely serving HTTP requests, or returns if no address is configured)\n\nNote: The function uses package-level variables (not shown in the reference code) including `addr` for the server address, and assumes the existence of handler functions like `expvarHandler`, `gcHandler`, and `freeOSMemoryHandler`.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"strings\"\n\n\t\"golang.org/x/net/trace\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc Start(extra ...Endpoint) {\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tpp := http.NewServeMux()\n\tindex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(`\n\t\t\t\t<a href=\"vars\">Vars</a><br>\n\t\t\t\t<a href=\"debug/pprof/\">PProf</a><br>\n\t\t\t\t<a href=\"metrics\">Metrics</a><br>\n\t\t\t\t<a href=\"debug/requests\">Requests</a><br>\n\t\t\t\t<a href=\"debug/events\">Events</a><br>\n\t\t\t`))\n\t\tfor _, e := range extra {\n\t\t\tfmt.Fprintf(w, `<a href=\"%s\">%s</a><br>`, strings.TrimPrefix(e.Path, \"/\"), e.Name)\n\t\t}\n\t\tw.Write([]byte(`\n\t\t\t\t<br>\n\t\t\t\t<form method=\"post\" action=\"gc\" style=\"display: inline;\"><input type=\"submit\" value=\"GC\"></form>\n\t\t\t\t<form method=\"post\" action=\"freeosmemory\" style=\"display: inline;\"><input type=\"submit\" value=\"Free OS Memory\"></form>\n\t\t\t`))\n\t})\n\tpp.Handle(\"/\", index)\n\tpp.Handle(\"/debug\", index)\n\tpp.Handle(\"/vars\", http.HandlerFunc(expvarHandler))\n\tpp.Handle(\"/gc\", http.HandlerFunc(gcHandler))\n\tpp.Handle(\"/freeosmemory\", http.HandlerFunc(freeOSMemoryHandler))\n\tpp.Handle(\"/debug/pprof/\", http.HandlerFunc(pprof.Index))\n\tpp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\tpp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\tpp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\tpp.Handle(\"/debug/pprof/trace\", http.HandlerFunc(pprof.Trace))\n\tpp.Handle(\"/debug/requests\", http.HandlerFunc(trace.Traces))\n\tpp.Handle(\"/debug/events\", http.HandlerFunc(trace.Events))\n\tpp.Handle(\"/metrics\", promhttp.Handler())\n\tfor _, e := range extra {\n\t\tpp.Handle(e.Path, e.Handler)\n\t}\n\tlog.Println(\"warning: could not start debug HTTP server:\", http.ListenAndServe(addr, pp))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\ntype Endpoint struct {\n\tPath   string\n\tName   string\n\tHandler http.Handler\n}\n\nfunc Start(extra ...Endpoint) {\n\t// Set up standard debug endpoints\n\thttp.Handle(\"/debug/addr\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(addr))\n\t}))\n\n\thttp.Handle(\"/debug/pprof\", http.DefaultServerMux)\n\thttp.Handle(\"/debug/vars\", expvarHandler)\n\thttp.Handle(\"/debug/gc\", gcHandler)\n\thttp.Handle(\"/debug/freeosmemory\", freeOSMemoryHandler)\n\n\t// Set up custom endpoints\n\tfor _, e := range extra {\n\t\thttp.Handle(e.Path, e.Handler)\n\t}\n\n\t// Set up index page with links to all available endpoints\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvar endpoints []string\n\t\tfor _, e := range extra {\n\t\t\tendpoints = append(endpoints, e.Path)\n\t\t}\n\t\tendpoints = append(endpoints, \"/debug/pprof\", \"/debug/vars\", \"/debug/gc\", \"/debug/freeosmemory\")\n\t\thtml := `<html><body><h1>Debug Endpoints</h1><ul>`\n\t\tfor _, p := range endpoints {\n\t\t\thtml += `<li><a href=\"` + p + `\">` + p + `</a></li>`\n\t\t}\n\t\thtml += `</ul></body></html>`\n\t\tw.Write([]byte(html))\n\t})\n\n\t// Start the server\n\tif addr == \"\" {\n\t\taddr = \":8080\"\n\t}\n\tlog.Printf(\"Starting debug server on %s\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a basic HTTP server in Go that listens on a specified port and responds with \"Hello World!\" to all requests on the root path.\n\nFunction Description: The main function sets up an HTTP server that handles requests to the root path (\"/\") by responding with a \"Hello World!\" message. It uses the net/http package to register a handler function and start the server.\n\nInput: None (The function takes no direct input parameters, but the HTTP server will process incoming HTTP requests)\n\nOutput: None (The function doesn't return anything directly, but it will output \"Hello World!\" as an HTTP response to requests, and may output error messages to the log if the server fails to start)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello World!\")\n\t})\n\n\tfmt.Println(\"Server is running on port 8080...\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tpanic(\"Error starting server: \" + err.Error())\n\t}\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Create a basic HTTP server in Go that listens on a specified port and responds with a simple greeting message to all incoming requests.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles all incoming requests. When a request is received, it writes a \"Hello!\" response. The server listens on port 80 and logs any errors that occur during startup.\n\nInput: None (The function takes no direct input parameters; configuration is hardcoded)\n\nOutput: None (The function doesn't return anything directly but starts a long-running HTTP server process that handles incoming requests and writes responses)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log/slog\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello!\")\n\t})\n\n\tlog.Info(\"Starting server at port 80\")\n\tif err := http.ListenAndServe(\":80\", nil); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello!\")\n\t})\n\n\tfmt.Println(\"Server is running on port 80...\")\n\terr := http.ListenAndServe(\":80\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when a request is received. The server listens on port 8080.\n\nInput:  \n- `w http.ResponseWriter`: Used to construct the HTTP response.  \n- `r *http.Request`: Contains information about the incoming HTTP request.  \n\nOutput:  \n- The function writes \"Hello World, I'm Golang!\" to the `http.ResponseWriter`, which is sent as the HTTP response body. No explicit return value.  \n\nExample usage:  \n```go\nhttp.HandleFunc(\"/\", handler)  \nhttp.ListenAndServe(\":8080\", nil)  \n```",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a Go HTTP server that handles file uploads via a multipart form and displays an upload form to the client.\n\nFunction Description: The main function sets up an HTTP server with a single route (\"/\") that handles both GET and POST requests. For GET requests, it displays an HTML form for file uploads. For POST requests, it processes the uploaded file. The server listens on port 9000.\n\nInput: \n- None (The function takes no direct input parameters, but handles HTTP requests with:\n  - GET requests to \"/\" path\n  - POST requests with multipart/form-data containing a file under the \"q\" field)\n\nOutput:\n- For GET requests: Returns HTML form for file upload (content-type: text/html)\n- For POST requests: Processes the uploaded file (prints file info to console)\n- Server runs continuously on port 9000 until terminated",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tkey := \"q\"\n\t\tfile, hdr, err := req.FormFile(key)\n\t\tfmt.Println(file, hdr, err)\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(res, `<form method=\"POST\" enctype=\"multipart/form-data\">\n      <input type=\"file\" name=\"q\">\n      <input type=\"submit\">\n    </form>`)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\tfmt.Fprintf(w, \"<html><body><form action=\\\"/\\\" method=\\\"post\\\" enctype=\\\"multipart/form-data\\\"><input type=\\\"file\\\" name=\\\"q\\\"><input type=\\\"submit\\\" value=\\\"Upload\\\"></form></body></html>\")\n\t\t} else if r.Method == \"POST\" {\n\t\t\tr.ParseMultipartForm(10 << 20)\n\t\t\tfile, handler, err := r.FormFile(\"q\")\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Error retrieving the file\", http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tfmt.Fprintf(w, \"Uploaded file: %s\\nSize: %d bytes\\n\", handler.Filename, handler.Size)\n\t\t\tif handler.Size > 0 {\n\t\t\t\tdst, err := os.Create(handler.Filename)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Could not create file\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefer dst.Close()\n\t\t\t\tif _, err = io.Copy(dst, file); err != nil {\n\t\t\t\t\thttp.Error(w, \"Could not save file\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tfmt.Println(\"Server running on port 9000...\")\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests to the root path (\"/\") and returns a \"Hello World\" message.\n\nFunction Description: The `handler` function is an HTTP request handler that writes a \"Hello World\" response to the client. It is registered to handle requests to the root path (\"/\") and is executed when the server receives a request to that path.\n\nInput: \n- `w http.ResponseWriter` - Used to write the HTTP response back to the client.\n- `r *http.Request` - Contains information about the incoming HTTP request (not used in this simple example).\n\nOutput: \n- The function writes \"Hello World, I'm Golang!\" to the response writer (`w`), which is sent back to the client. There is no explicit return value.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello World, I'm Golang!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tfmt.Println(\"Server is running on port 8080...\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Create a function that implements a basic HTTP server which echoes back the request body to the response.\n\nFunction Description: The function `httpserver` starts an HTTP server on the specified address. It handles all incoming requests to the root path (\"/\") by copying the request body directly to the response writer. This effectively echoes back the received data to the client. The server runs until an error occurs or is manually stopped.\n\nInput:  \n- `addr` (string): The network address (including port) on which the HTTP server should listen (e.g., \":8080\").\n\nOutput:  \n- `error`: Returns an error if the server fails to start or encounters a fatal error during operation. Returns nil if the server is terminated gracefully.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc httpserver(addr string) error {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tio.Copy(w, req.Body)\n\t})\n\n\treturn http.ListenAndServe(addr, nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io\"\n)\n\nfunc httpserver(addr string) error {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tw.Write(body)\n\t})\n\n\tfmt.Printf(\"Server starting on %s\\n\", addr)\n\terr := http.ListenAndServe(addr, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles requests and responds with the requested URL path.\n\nFunction Description: The main function sets up an HTTP server that listens on port 9000. It registers a handler function for the root path (\"/\") that writes the requested URL path as plain text in the response.\n\nInput: None (The function takes no direct input parameters; it handles incoming HTTP requests through the registered handler)\n\nOutput: None (The function doesn't return any value; it continuously serves HTTP requests until terminated)\n\nNote: The handler function takes two parameters:\n1. res http.ResponseWriter - used to write the HTTP response\n2. req *http.Request - contains information about the incoming request",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprint(res, req.URL.Path)\n\t})\n\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handleRoot(res http.ResponseWriter, req *http.Request) {\n\tpath := req.URL.Path\n\tfmt.Fprintf(res, \"Requested path: %s\\n\", path)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRoot)\n\tfmt.Println(\"Server listening on port 9000...\")\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a basic HTTP server in Go that echoes back the request headers to the client. The server should handle requests on the root path (\"/\") and respond by writing the request headers to the response.\n\nFunction Description: The `ServeHTTP` function is an HTTP handler that writes the request headers to the response writer. It is registered to handle requests on the root path (\"/\") and starts an HTTP server listening on `127.0.0.1:8080`.\n\nInput: \n- `w http.ResponseWriter`: Used to construct the HTTP response.\n- `r *http.Request`: Contains the incoming HTTP request details, including headers.\n\nOutput: None (writes directly to the `http.ResponseWriter`).",
    "Canonical_solution": "import (\n\t\"net/http\"\n)\n\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tr.Header.Write(w)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ServeHTTP)\n\thttp.ListenAndServe(\"127.0.0.1:8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfor name, headers := range r.Header {\n\t\tfor _, value := range headers {\n\t\t\tw.Header().Set(name, value)\n\t\t}\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ServeHTTP)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a basic HTTP server in Go that handles multiple routes with different response messages.\n\nFunction Description: The code demonstrates how to set up a simple HTTP server with two route handlers. The first handler responds to the root path (\"/\") with a \"doggy\" message, while the second handler responds to the \"/cat/\" path with a \"catty\" message. The server listens on port 9000.\n\nInput: \n- None (HTTP requests are automatically handled by the server)\n\nOutput: \n- None (The server writes responses directly to the http.ResponseWriter)\n\nMethods:\n- upTown: Handles requests to the root path (\"/\") and writes \"doggy doggy doggy\" to the response\n- youUp: Handles requests to the \"/cat/\" path and writes \"catty catty catty\" to the response\n- main: Registers the route handlers and starts the HTTP server on port 9000",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc upTown(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"doggy doggy doggy\")\n}\n\nfunc youUp(res http.ResponseWriter, req *http.Request) {\n\tio.WriteString(res, \"catty catty catty\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc upTown(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"doggy doggy doggy\"))\n}\n\nfunc youUp(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"catty catty catty\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", upTown)\n\thttp.HandleFunc(\"/cat/\", youUp)\n\thttp.ListenAndServe(\":9000\", nil)\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a Go HTTP server that serves PNG images generated by a package function.\n\nFunction Description: The main function sets up a basic HTTP server that responds to requests at the root path (\"/\") by generating a PNG image using an external package function and serving it with the correct content type.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the http.ResponseWriter and *http.Request parameters in the handler function)\n\nOutput: None (The function doesn't return any value but serves HTTP responses with PNG image data)",
    "Canonical_solution": "import (\n    \"fmt\"\n    \"net/http\"\n    \"io\"\n    \"bytes\"\n    \"davidhampgonsalves/lifedashboard/pkg\"\n)\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        png := pkg.Generate();\n        w.Header().Set(\"Content-Type\", \"image/png\")\n        io.Copy(w, bytes.NewBuffer(png))\n    })\n\n    fmt.Println(\"Server listening on http://localhost:8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"image/png\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\timg := generatePNGImage() // Assume generatePNGImage is a function that returns an image.Image\n\t\tpng.Encode(w, img)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Go HTTP server that handles WebDAV requests with custom logging and special handling for certain Litmus test cases.\n\nFunction Description: The main function sets up a WebDAV server with in-memory storage (MemFS) and in-memory locking (MemLS). It includes custom logging for WebDAV operations and special handling for a specific Litmus test case (\"props: 3 (propfind_invalid2)\"). The server listens on a specified port and handles all incoming HTTP requests.\n\nInput: None (though the code uses a command-line flag for port configuration which would be handled by the flag package)\n\nOutput: None (the function runs indefinitely as a server, but may log errors or fatal conditions)\n\nNote: The actual implementation shows the server uses a port flag (not shown in parameters) and produces log output, but these are side effects rather than formal outputs.\n\n---\n\nFor completeness, if we were to describe the webdav.Handler struct being used (though not explicitly defined in this code):\n\nStruct Description: webdav.Handler is a struct from golang.org/x/net/webdav that implements http.Handler for WebDAV protocol operations.\n\nFields:\nFileSystem: webdav.FileSystem - The underlying file system implementation\nLockSystem: webdav.LockSystem - The locking system implementation\nLogger: func(*http.Request, error) - Optional function for logging requests and errors\n\nMethods:\nServeHTTP: ServeHTTP(http.ResponseWriter, *http.Request) -> None - Main handler method that processes HTTP requests according to WebDAV protocol",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"golang.org/x/net/webdav\"\n)\n\nvar port *int = flag.Int(\"port\", 8080, \"Port to listen on\")\n\nfunc main() {\n\tflag.Parse()\n\n\tmfs := webdav.NewMemFS()\n\tmls := webdav.NewMemLS()\n\n\tlogger := func(r *http.Request, err error) {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error handling request: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"Request handled: %s %s\", r.Method, r.URL.Path)\n\t\t}\n\t}\n\n\thandler := webdav.Handler{\n\t\tFileSystem: mfs,\n\t\tLockSystem: mls,\n\t\tLogger:     logger,\n\t}\n\n\thttp.Handle(\"/\", handler)\n\n\tlog.Printf(\"WebDAV server listening on port %d\", *port)\n\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", *port), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests with tracing capabilities using OpenCensus. The server should respond to requests with a simple message, perform tracing operations, and make an external HTTP request while propagating the trace context.\n\nFunction Description: The main function sets up an HTTP server with tracing middleware. It registers a root handler (\"/\") that responds with \"hello world\", creates trace spans, adds annotations/attributes, and makes an external HTTP request to example.com while maintaining trace context.\n\nInput: None (The function takes no direct input parameters. HTTP requests come through the server's routing mechanism.)\n\nOutput: None (The function doesn't return anything directly. It starts an HTTP server that listens indefinitely on port 50030 and handles incoming requests by writing responses to http.ResponseWriter.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/plugin/ochttp\"\n)\n\nfunc main() {\n\tclient := &http.Client{Transport: &ochttp.Transport{}}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\n\t\t_, span := trace.StartSpan(req.Context(), \"child\")\n\t\tdefer span.End()\n\t\tspan.Annotate([]trace.Attribute{trace.StringAttribute(\"key\", \"value\")}, \"something happened\")\n\t\tspan.AddAttributes(trace.StringAttribute(\"hello\", \"world\"))\n\t\ttime.Sleep(time.Millisecond * 125)\n\n\t\tr, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\t\tr = r.WithContext(req.Context())\n\t\tresp, err := client.Do(r)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t} else {\n\t\t\tresp.Body.Close()\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":50030\", &ochttp.Handler{}))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "right_result": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/trace/propagation\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc main() {\n\t// Initialize OpenCensus\n\ttrace.RegisterExporter(func(exporter trace.Exporter) {\n\t\t// In a real scenario, you would use a proper exporter like OTLP\n\t\t// For this example, we just set up the tracing context\n\t})\n\n\t// Set up HTTP server\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Start a new trace span\n\t\tctx := trace.NewContext(context.Background(), &trace.Span{\n\t\t\tTraceID:      trace.TraceID{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tSpanID:       trace.SpanID{11, 12, 13, 14, 15, 16, 17, 18},\n\t\t\tName:         \"root-handler\",\n\t\t\tStartTime:    time.Now(),\n\t\t\tEndTime:      time.Now(),\n\t\t\tAttributes:   map[string]interface{}{\"status\": \"success\"},\n\t\t\tAnnotations:  []trace.Annotation{{Timestamp: time.Now(), Description: \"root handler started\"}},\n\t\t})\n\n\t\t// Make an external HTTP request while propagating the trace context\n\t\tspan, _ := trace.StartSpan(ctx, \"external-request\")\n\t\tspan.Annotate([]trace.Annotation{{Timestamp: time.Now(), Description: \"external request started\"}})\n\n\t\tresp, err := http.Get(\"https://example.com\")\n\t\tif err != nil {\n\t\t\tspan.SetStatus(trace.Status{Code: trace.StatusCodeInternal})\n\t\t\tspan.Annotate([]trace.Annotation{{Timestamp: time.Now(), Description: \"external request failed\"}})\n\t\t\tw.Write([]byte(\"Error: \" + err.Error()))\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// End the trace span\n\t\tspan.End()\n\n\t\t// Write response\n\t\tw.Write([]byte(\"hello world\"))\n\t})\n\n\t// Start the HTTP server\n\tfmt.Println(\"Server is running on port 50030...\")\n\thttp.ListenAndServe(\":50030\", nil)\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Implement a Certificate Authority (CA) service in Go using the Chi router for HTTP routing, supporting both secure and insecure servers, with background jobs and proper shutdown handling.\n\nStruct Description: The CA struct represents a Certificate Authority service that manages HTTP servers (secure and insecure), configuration, authentication, and background tasks.\n\nFields:\n\nauth: [*authority.Authority] - The authority component handling certificate operations  \nconfig: [*config.Config] - Configuration settings for the CA service  \nsrv: [*server.Server] - The main secure HTTP server  \ninsecureSrv: [*server.Server] - Optional insecure HTTP server for certain endpoints  \nmetricsSrv: [*server.Server] - Optional metrics server  \nopts: [*options] - Additional service options  \nrenewer: [*TLSRenewer] - Component handling TLS certificate renewal  \ncompactStop: [chan struct{}] - Channel for stopping the background compaction job  \n\nMethods:\n\nInit: [func(cfg *config.Config) (*CA, error)] - Initializes the CA service with configuration, sets up routers, and prepares servers  \nRun: [func() error] - Starts all servers and background jobs, handles graceful shutdown on errors  \nshouldServeInsecureServer: [func() bool] - (implied private method) Determines if insecure server should be started  \nrunCompactJob: [func()] - (implied private method) Runs background compaction task  \nStop: [func() error] - (implied method) Handles service shutdown and cleanup",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype CA struct {\n\tauth        *authority.Authority\n\tconfig      *config.Config\n\tsrv         *server.Server\n\tinsecureSrv *server.Server\n\tmetricsSrv  *server.Server\n\topts        *options\n\trenewer     *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc (ca *CA) Init(cfg *config.Config) (*CA, error) {\n\tmux := chi.NewRouter()\n\thandler := http.Handler(mux)\n\n\tinsecureMux := chi.NewRouter()\n\tinsecureHandler := http.Handler(insecureMux)\n\n\tmux.Use(middleware.GetHead)\n\tinsecureMux.Use(middleware.GetHead)\n\n\tapi.Route(mux)\n\tmux.Route(\"/1.0\", func(r chi.Router) {\n\t\tapi.Route(r)\n\t})\n\n\tinsecureMux.Get(\"/crl\", api.CRL)\n\tinsecureMux.Get(\"/1.0/crl\", api.CRL)\n\n\tbaseContext := buildContext(auth, scepAuthority, acmeDB, acmeLinker)\n\n\tca.srv = server.New(cfg.Address, handler, tlsConfig)\n\tca.srv.BaseContext = func(net.Listener) context.Context {\n\t\treturn baseContext\n\t}\n\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = server.New(cfg.InsecureAddress, insecureHandler, nil)\n\t\tca.insecureSrv.BaseContext = func(net.Listener) context.Context {\n\t\t\treturn baseContext\n\t\t}\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\tvar wg sync.WaitGroup\n\terrs := make(chan error, 1)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tca.runCompactJob()\n\t}()\n\n\tif ca.insecureSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.insecureSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\tif ca.metricsSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.metricsSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terrs <- ca.srv.ListenAndServe()\n\t}()\n\n\terr := <-errs\n\n\tif !errors.Is(err, http.ErrServerClosed) {\n\t\tlog.Println(\"shutting down due to startup error ...\")\n\t\tif stopErr := ca.Stop(); stopErr != nil {\n\t\t\terr = fmt.Errorf(\"failed stopping CA after error occurred: %w: %w\", err, stopErr)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"stopped CA after error occurred: %w\", err)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 108,
    "right_result": "package ca\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"go.uber.org/zap\"\n)\n\ntype CA struct {\n\tauth       *authority.Authority\n\tconfig     *config.Config\n\tsrv        *server.Server\n\tinsecureSrv *server.Server\n\tmetricsSrv *server.Server\n\topts       *options\n\trenewer    *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc (c *CA) Init(cfg *config.Config) (*CA, error) {\n\tc.config = cfg\n\tc.auth = authority.NewAuthority()\n\tc.opts = &options{}\n\tc.renewer = &TLSRenewer{}\n\n\tif c.config.SecurePort > 0 {\n\t\tc.srv = server.NewServer(c.config.SecurePort, c.config.CertFile, c.config.KeyFile)\n\t} else {\n\t\tc.srv = server.NewServer(0, \"\", \"\")\n\t}\n\n\tif c.shouldServeInsecureServer() {\n\t\tc.insecureSrv = server.NewServer(c.config.InsecurePort, \"\", \"\")\n\t}\n\n\tif c.config.MetricsPort > 0 {\n\t\tc.metricsSrv = server.NewServer(c.config.MetricsPort, \"\", \"\")\n\t}\n\n\tr := chi.NewRouter()\n\tr.Use(middleware.Logger)\n\tr.Use(middleware.Recoverer)\n\n\t// Add routes for certificate operations\n\tr.Route(\"/cert\", func(r chi.Router) {\n\t\tr.Get(\"/\", c.auth.GetCertificate)\n\t\tr.Post(\"/\", c.auth.RequestCertificate)\n\t})\n\n\t// Add routes for metrics\n\tif c.metricsSrv != nil {\n\t\tr.Handle(\"/metrics\", promhttp.Handler())\n\t}\n\n\tif c.srv != nil {\n\t\tc.srv.SetHandler(r)\n\t}\n\n\tif c.insecureSrv != nil {\n\t\tc.insecureSrv.SetHandler(r)\n\t}\n\n\tif c.metricsSrv != nil {\n\t\tc.metricsSrv.SetHandler(r)\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *CA) Run() error {\n\tif c.srv != nil {\n\t\tgo c.srv.ListenAndServe()\n\t}\n\n\tif c.insecureSrv != nil && c.shouldServeInsecureServer() {\n\t\tgo c.insecureSrv.ListenAndServe()\n\t}\n\n\tif c.metricsSrv != nil {\n\t\tgo c.metricsSrv.ListenAndServe()\n\t}\n\n\tgo c.runCompactJob()\n\n\t// Handle shutdown signals\n\tstopChan := make(chan os.Signal, 1)\n\tsignal.Notify(stopChan, syscall.SIGINT, syscall.SIGTERM)\n\n\t<-stopChan\n\tc.Stop()\n\treturn nil\n}\n\nfunc (c *CA) shouldServeInsecureServer() bool {\n\treturn c.config.InsecurePort > 0 && c.config.InsecureEnabled\n}\n\nfunc (c *CA) runCompactJob() {\n\tticker := time.NewTicker(time.Minute)\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tc.compactStop = make(chan struct{})\n\t\t\tgo c.auth.CompactCertificates()\n\t\tcase <-c.compactStop:\n\t\t\tc.compactStop = nil\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *CA) Stop() error {\n\tif c.srv != nil {\n\t\tc.srv.Shutdown()\n\t}\n\n\tif c.insecureSrv != nil && c.shouldServeInsecureServer() {\n\t\tc.insecureSrv.Shutdown()\n\t}\n\n\tif c.metricsSrv != nil {\n\t\tc.metricsSrv.Shutdown()\n\t}\n\n\treturn nil\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes middleware for request logging and rate limiting using Sentinel. The server should handle a GET request at the \"/test\" endpoint.\n\nFunction Description: The function sets up an Echo HTTP server with middleware for logging and rate limiting. The rate limiting is implemented using Sentinel middleware, which extracts the client's real IP from the request headers and applies a block fallback response when the rate limit is exceeded. The server listens on port 1323.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 1323.)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\nfunc Example() {\n\tr := echo.New()\n\tr.Use(middleware.Logger())\n\tr.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx echo.Context) string {\n\t\t\t\tif res, ok := ctx.Get(\"X-Real-IP\").(string); ok {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t\treturn \"\"\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx echo.Context) error {\n\t\t\t\treturn ctx.JSON(400, map[string]interface{}{\n\t\t\t\t\t\"err\":  \"too many requests; the quota used up\",\n\t\t\t\t\t\"code\": 10222,\n\t\t\t\t})\n\t\t\t}),\n\t\t),\n\t)\n\n\tr.GET(\"/test\", func(c echo.Context) error {\n\t\treturn nil\n\t})\n\tr.Logger.Fatal(r.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/cesbit/sentinel-go\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\t// Rate limiting middleware using Sentinel\n\tsentinelMiddleware := middleware.RateLimiter(\n\t\tsentinel.NewDefaultSentinel(),\n\t\tsentinel.WithIPExtractor(func(c *echo.Context) string {\n\t\t\treturn c.Request().RemoteAddr\n\t\t}),\n\t\tsentinel.WithBlockFallbackResponse(\"Rate limit exceeded\"),\n\t)\n\n\te.Use(middleware.Logger())\n\te.Use(sentinelMiddleware)\n\n\te.GET(\"/test\", func(c echo.Context) error {\n\t\treturn c.JSON(200, map[string]string{\"message\": \"Hello from /test endpoint\"})\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go, which includes route handling, middleware integration, and JWT-based authentication for restricted routes.\n\nFunction Description: The main function initializes an Echo server, configures middleware (logger and recovery), sets up routes for login and accessible content, and creates a restricted route group with JWT authentication. The server listens on port 1323.\n\nInput: None (The function takes no direct input parameters, but relies on HTTP requests to trigger route handlers)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that continues running until interrupted)\n\nNote: The actual route handlers (login, accessible, restricted) would need to be implemented separately as they're referenced but not shown in the provided code.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/login\", login)\n\te.GET(\"/\", accessible)\n\n\tr := e.Group(\"/restricted\")\n\tr.Use(middleware.JWT([]byte(\"secret\")))\n\tr.GET(\"\", restricted)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\t// Login route\n\te.POST(\"/login\", func(c echo.Context) error {\n\t\t// Implement login logic here\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"token\": \"dummy_token\"})\n\t})\n\n\t// Accessible route\n\te.GET(\"/accessible\", func(c echo.Context) error {\n\t\t// Implement accessible content logic here\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Accessible content\"})\n\t})\n\n\t// Restricted route group with JWT authentication\n restrictedGroup := e.Group(\"/\")\n restrictedGroup.Use(middleware.JWTWithConfig(middleware.JWTConfig{\n \tSigningKey: []byte(\"your_secret_key\"),\n }))\n restrictedGroup.GET(\"/restricted\", func(c echo.Context) error {\n \t// Implement restricted content logic here\n \treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"Restricted content\"})\n })\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using the Echo framework in Go, with basic middleware and a simple route handler.\n\nFunction Description: The function `StartHTTPServer` initializes a new Echo instance, adds logger and recovery middleware, registers a GET route handler for the root path (\"/\"), and starts the HTTP server on the specified address.\n\nInput:  \n- `address` (string): The network address (e.g., \":8080\") on which the HTTP server should listen.\n\nOutput:  \n- `error`: Returns an error if the server fails to start; otherwise, it blocks until the server is stopped.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\treturn e.Start(address)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc StartHTTPServer(address string) error {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recovery())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(200, \"Hello, World!\")\n\t})\n\n\treturn e.Start(address)\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that streams JSON-encoded location data with a delay between each transmission.\n\nFunction Description: The main function initializes an Echo server, sets up a GET route handler at the root path (\"/\") that streams location data as JSON with a 1-second delay between each location. The response uses proper HTTP headers for JSON content type and flushes after each location is sent.\n\nInput: None (The function takes no direct input parameters, but relies on a predefined 'locations' collection that should be available in scope)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that listens on port 1323 and handles incoming requests)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"time\"\n\n\t\"encoding/json\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSON)\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\tfor _, l := range locations {\n\t\t\tif err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.Response().Flush()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t\treturn nil\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar locations = []map[string]interface{}{\n\t{\"id\": 1, \"latitude\": 37.7749, \"longitude\": -122.4194, \"timestamp\": time.Now().UnixNano()},\n\t{\"id\": 2, \"latitude\": 37.7749, \"longitude\": -122.4194, \"timestamp\": time.Now().UnixNano()},\n\t{\"id\": 3, \"latitude\": 37.7749, \"longitude\": -122.4194, \"timestamp\": time.Now().UnixNano()},\n}\n\nfunc main() {\n\te := echo.New()\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\tresponseWriter := c.Response()\n\t\tresponseWriter.Header.Set(\"Content-Type\", \"application/json\")\n\t\tresponseWriter.WriteHeader(http.StatusOK)\n\n\t\tfor _, loc := range locations {\n\t\t\tjsonData, _ := json.Marshal(loc)\n\t\t\tresponseWriter.Write(jsonData)\n\t\t\tresponseWriter.Flush()\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\n\t\treturn nil\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles various routes with authentication middleware and serves different endpoints for application management.\n\nFunction Description: The `serve` function initializes and starts an HTTP server using the Echo framework. It sets up route handlers for various endpoints related to application management, including upload, installation, renaming, and deletion of apps. The function also implements authentication middleware (BasicAuth and KeyAuth) to secure certain endpoints. The server runs on the specified host and port.\n\nInput: \n- `host` (string): The host address where the server will run (e.g., \"localhost\" or \"0.0.0.0\")\n- `port` (uint64): The port number on which the server will listen (e.g., 8080)\n\nOutput: \n- None (the function runs indefinitely until the server is stopped or encounters an error, at which point it logs the error and exits)",
    "Canonical_solution": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc serve(host string, port uint64) {\n\te := echo.New()\n\te.HideBanner = true\n\n\tforcedBasicAuth := middleware.BasicAuth(func(username string, password string, c echo.Context) (bool, error) {\n\t\treturn username == config.Current.BasicAuth.Username && password == config.Current.BasicAuth.Password, nil\n\t})\n\tbasicAuth := func(f echo.HandlerFunc) echo.HandlerFunc {\n\t\tif config.Current.BasicAuth.Enable {\n\t\t\treturn forcedBasicAuth(f)\n\t\t} else {\n\t\t\treturn f\n\t\t}\n\t}\n\tworkflowKeyAuth := middleware.KeyAuth(func(s string, c echo.Context) (bool, error) {\n\t\treturn s == config.Current.BuilderKey, nil\n\t})\n\n\te.GET(\"/\", renderIndex, basicAuth)\n\te.GET(\"/favicon.png\", getFavIcon, basicAuth)\n\te.POST(\"/apps\", uploadUnsignedApp, basicAuth)\n\te.GET(\"/apps/:id/install\", appResolver(renderInstall))\n\te.GET(\"/apps/:id/manifest\", appResolver(getManifest))\n\te.GET(\"/apps/:id/resign\", appResolver(resignApp), basicAuth)\n\te.GET(\"/apps/:id/delete\", appResolver(deleteApp), basicAuth)\n\te.GET(\"/apps/:id/rename\", appResolver(renderRenameApp), basicAuth)\n\te.POST(\"/apps/:id/rename\", appResolver(renameApp), basicAuth)\n\te.GET(\"/apps/:id/2fa\", appResolver(render2FAPage), basicAuth)\n\te.POST(\"/apps/:id/2fa\", appResolver(set2FA), basicAuth)\n\te.GET(\"/jobs\", getLastJob, workflowKeyAuth)\n\te.GET(\"/jobs/:id/2fa\", jobResolver(get2FA), workflowKeyAuth)\n\te.POST(\"/jobs/:id/signed\", jobResolver(uploadSignedApp), workflowKeyAuth)\n\n\tlog.Fatal().Err(e.Start(fmt.Sprintf(\"%s:%d\", host, port))).Send()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc serve(host string, port uint64) {\n\te := echo.New()\n\n\t// Basic Auth middleware\n\te.Use(middleware.BasicAuth(func(user, pass string, c echo.Context) (bool, error) {\n\t\tif user == \"user\" && pass == \"pass\" {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, echo.NewHTTPError(http.StatusUnauthorized, \"invalid credentials\")\n\t}))\n\n\t// Key Auth middleware\n\te.Use(middleware.KeyAuthWithConfig(middleware.KeyAuthConfig{\n\t\tValidator: func(key string, c echo.Context) (bool, error) {\n\t\t\tif key == \"secretkey\" {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\treturn false, echo.NewHTTPError(http.StatusForbidden, \"invalid key\")\n\t\t},\n\t}))\n\n\t// Route for app upload\n\te.POST(\"/upload\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"App uploaded\"})\n\t})\n\n\t// Route for app installation\n\te.POST(\"/install\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"App installed\"})\n\t})\n\n\t// Route for app renaming\n\te.PUT(\"/rename\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"App renamed\"})\n\t})\n\n\t// Route for app deletion\n\te.DELETE(\"/delete\", func(c echo.Context) error {\n\t\treturn c.JSON(http.StatusOK, map[string]string{\"message\": \"App deleted\"})\n\t})\n\n\t// Start server\n\tserver := &http.Server{\n\t\tAddr:    \":\" + string(port),\n\t\tHandler: e,\n\t}\n\n\tprintln(\"Server is running on http://\" + host + \":\" + string(port))\n\tif err := server.ListenAndServe(host+\":\"+string(port), nil); err != nil {\n\t\tpanic(\"server start error: \" + err.Error())\n\t}\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves basic server information and runs on a configurable address.\n\nFunction Description: The main function initializes an Echo HTTP server, configures middleware for logging and compression, sets up a route handler for server information, and starts the server on the specified address.\n\nInput: \n- Command-line argument (optional): \"--addr\" to specify the server address (default: \"127.0.0.1:9090\")\n\nOutput: \n- Running HTTP server that responds to GET requests at \"/serverinfo\" with server hostname and address\n- No explicit return value (runs indefinitely until interrupted)\n\nNote: The reference code shows a complete implementation at the package level (main function) rather than a standalone function or struct level. The instruction follows the function-level format as the code primarily demonstrates functional behavior through the main function.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo\"\n\tmd \"github.com/labstack/echo/middleware\"\n)\n\nvar (\n\taddr = flag.String(\"addr\", \"127.0.0.1:9090\", \"addr for backend\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tserver := echo.New()\n\tserver.Use(md.Logger())\n\tserver.Use(md.Gzip())\n\n\tserver.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thostname, _ := os.Hostname()\n\t\treturn c.String(http.StatusOK, hostname+\"\\n\"+*addr)\n\t})\n\n\tserver.Start(*addr)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nfunc main() {\n\taddr := \"127.0.0.1:9090\"\n\tif len(os.Args) > 1 {\n\t\tfor _, arg := range os.Args[1:] {\n\t\t\tif arg == \"--addr\" {\n\t\t\t\tif len(os.Args) > 2 {\n\t\t\t\t\taddr = os.Args[2]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Compress())\n\n\te.GET(\"/serverinfo\", func(c echo.Context) error {\n\t\thost, _ := os.Hostname()\n\t\treturn c.JSON(http.StatusOK, map[string]string{\n\t\t\t\"hostname\": host,\n\t\t\t\"address\":  addr,\n\t\t})\n\t})\n\n\tfmt.Printf(\"Server is running on %s\\n\", addr)\n\te.Start(addr)\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests on two different endpoints (\"/request\" and \"/stream\") and serves over HTTPS.\n\nFunction Description: The main function initializes an Echo server instance, registers route handlers for two GET endpoints, and starts an HTTPS server using provided TLS certificate files.\n\nInput: None (The function takes no direct input parameters, but relies on external TLS certificate files \"cert.pem\" and \"key.pem\")\n\nOutput: None (The function doesn't return anything but starts a persistent HTTP server process)\n\nNote: The actual route handler functions (request and stream) would need to be implemented separately to handle the respective endpoints. The server will run indefinitely until interrupted, listening on port 1323 with TLS encryption.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\te.GET(\"/request\", request)\n\te.GET(\"/stream\", stream)\n\te.Logger.Fatal(e.StartTLS(\":1323\", \"cert.pem\", \"key.pem\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.GET(\"/request\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Request handled\")\n\t})\n\n\te.GET(\"/stream\", func(c echo.Context) error {\n\t\treturn c.Stream(http.StatusOK, \"text/plain\", func(w http.ResponseWriter) {\n\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\tw.Write([]byte(\"Stream line \" + strconv.Itoa(i) + \"\\n\"))\n\t\t\t\t// Simulate delay\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t}\n\t\t})\n\t})\n\n\terr := e.StartTLS(\":1323\", \"cert.pem\", \"key.pem\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles basic requests and includes middleware for processing statistics.\n\nStruct Description: The Stats struct is used to track and handle statistics for HTTP requests processed by the server.\n\nFields:\n- Count: [int] - Tracks the number of requests processed\n- StartTime: [time.Time] - Records the time when the server started processing requests\n\nMethods:\n- Process: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that increments the request count for each processed request\n- Handle: [func(c echo.Context) error] -> [error] - Handler function that returns the current statistics (request count and uptime) in JSON format\n- NewStats: [func() *Stats] -> [*Stats] - Constructor function that initializes a new Stats instance with default values\n\nAdditional Functions:\n- ServerHeader: [func(next echo.HandlerFunc) echo.HandlerFunc] -> [echo.HandlerFunc] - Middleware function that adds a Server header to responses\n- main: [func()] -> [None] - Entry point that creates the Echo server, registers routes and middleware, and starts the server on port 1323",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Debug = true\n\n\ts := NewStats()\n\te.Use(s.Process)\n\te.GET(\"/stats\", s.Handle)\n\n\te.Use(ServerHeader)\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype Stats struct {\n\tCount     int\n\tStartTime time.Time\n}\n\nfunc (s *Stats) Process(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\ts.Count++\n\t\treturn next(c)\n\t}\n}\n\nfunc (s *Stats) Handle(c echo.Context) error {\n\tuptime := time.Since(s.StartTime).Seconds()\n\tc.JSON(http.StatusOK, map[string]any{\n\t\t\"count\":   s.Count,\n\t\t\"uptime\":  uptime,\n\t})\n\treturn nil\n}\n\nfunc NewStats() *Stats {\n\treturn &Stats{\n\t\tCount:     0,\n\t\tStartTime: time.Now(),\n\t}\n}\n\nfunc ServerHeader(next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tc.Response().Header().Set(\"Server\", \"Echo\")\n\t\treturn next(c)\n\t}\n}\n\nfunc main() {\n\te := echo.New()\n\n\tstats := NewStats()\n\n\te.Use(stats.Process)\n\te.Use(ServerHeader)\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn stats.Handle(c)\n\t})\n\n\te.Start(\":1323\")\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that handles GET requests and serves HTML content with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The main function initializes an Echo server, configures middleware for recovery and logging, sets up a route handler for the root path (\"/\") that returns HTML content, and starts the server with automatic TLS on port 443.\n\nInput: None (The function takes no explicit input parameters)\n\nOutput: None (The function doesn't return any value but starts an HTTP server that runs indefinitely until terminated)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Recover())\n\te.Use(middleware.Logger())\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, `\n\t\t\t<h1>Welcome to Echo!</h1>\n\t\t\t<h3>TLS certificates automatically installed from Let's Encrypt :)</h3>\n\t\t`)\n\t})\n\te.Logger.Fatal(e.StartAutoTLS(\":443\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "right_result": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"net/http\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\te.Use(middleware.Recovery())\n\te.Use(middleware.Logger())\n\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.HTML(http.StatusOK, \"<h1>Hello, World!</h1>\")\n\t})\n\n\te.Start(\":443\")\n}"
  }
]