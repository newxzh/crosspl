[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Implement a Go struct that represents a Docker registry repository client, capable of interacting with Docker registry API v2 to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct serves as a client for interacting with a Docker registry's repository, providing methods to access blob storage, manifests, and tag services. It maintains HTTP client configuration and URL building capabilities.\n\nFields:\n- client: *http.Client - Custom HTTP client configured with transport and redirect handling\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nTask Description: Implement a Go struct that represents a tag service for a Docker registry repository, capable of retrieving tag information from a Docker registry API v2.\n\nStruct Description: The `tags` struct provides tag-related operations for a Docker repository, implementing the distribution.TagService interface. It uses HTTP requests to interact with the registry's tag API endpoints.\n\nFields:\n- client: *http.Client - HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing tag-related API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves the descriptor for a specific tag, making HEAD and GET requests as needed to the registry API",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/distribution/v2\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\t// Implementation for BlobStore\n\treturn nil\n}\n\nfunc (r *repository) Manifests(ctx context.Context, opts ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\t// Implementation for ManifestService\n\treturn nil, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.name,\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\t// Implementation for Get method\n\treturn distribution.Descriptor{}, nil\n}\n```"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Go HTTP client struct that can make authenticated API requests with custom headers and handle responses, including error status codes.\n\nStruct Description: The Client struct represents an HTTP client with authentication credentials and endpoint configuration, capable of making various HTTP requests and processing responses.\n\nFields:\nUser: string - The username for basic authentication\nApiKey: string - The API key or password for basic authentication\nEndpoint: string - The base URL for API endpoints\n\nMethods:\nisOkStatus: [Name](code int) -> bool - Checks if the HTTP status code indicates a successful response (200, 201, 204 return true; 400, 404, 500, 409, 406 return false)\nnewRequest: [Name](method string, uri string, body interface{}) -> ([]byte, error) - Creates and executes an HTTP request with the given method, URI, and optional body. Returns the response body or an error if the request fails or returns a non-success status code. Automatically adds basic authentication headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tcodes := map[int]bool{\n\t\t200: true,\n\t\t201: true,\n\t\t204: true,\n\t\t400: false,\n\t\t404: false,\n\t\t500: false,\n\t\t409: false,\n\t\t406: false,\n\t}\n\n\treturn codes[code]\n}\n\nfunc (c *Client) newRequest(method, uri string, body interface{}) ([]byte, error) {\n\tvar (\n\t\tclient = &http.Client{}\n\t\turl    = fmt.Sprintf(\"%s/%s\", c.Endpoint, uri)\n\t\terr    error\n\t\treq    *http.Request\n\t)\n\n\tif body != nil {\n\t\tbodyJSON, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treq, err = http.NewRequest(method, url, bytes.NewBuffer(bodyJSON))\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error with request: %v - %q\", url, err)\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\ttype apiErr struct {\n\t\t\tErr string `json:\"error\"`\n\t\t}\n\t\tvar outErr apiErr\n\t\tjson.Unmarshal(data, &outErr)\n\t\treturn nil, fmt.Errorf(\"Error in response: %s\", outErr.Err)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tUser     string\n\tApiKey   string\n\tEndpoint string\n}\n\nfunc (c *Client) isOkStatus(code int) bool {\n\tswitch code {\n\tcase 200, 201, 204:\n\t\treturn true\n\tcase 400, 404, 500, 409, 406:\n\t\treturn false\n\tdefault:\n\t\treturn code >= 200 && code < 300\n\t}\n}\n\nfunc (c *Client) newRequest(method string, uri string, body interface{}) ([]byte, error) {\n\turl := c.Endpoint + uri\n\tvar reqBody []byte\n\tif body != nil {\n\t\tvar err error\n\t\treqBody, err = json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal request body: %w\", err)\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\treq.SetBasicAuth(c.User, c.ApiKey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif !c.isOkStatus(resp.StatusCode) {\n\t\treturn nil, fmt.Errorf(\"non-success status code: %d\", resp.StatusCode)\n\t}\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\treturn respBody, nil\n}\n```"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Go struct that represents an HTTP server application using the Echo framework, with configurable options and standard middleware.\n\nStruct Description: The `App` struct represents an HTTP server application built on the Echo framework. It encapsulates the Echo engine instance and provides methods to initialize and run the server with common middleware (recovery, logging) and default routes.\n\nFields:\n- Engine: *echo.Echo - The core Echo framework instance that handles HTTP routing and middleware\n- Conf: *conf.Conf - Configuration object for server settings (port, debug mode, etc.)\n\nMethods:\n- NewApp: func(opts ...AppOptions) *App - Constructor that initializes a new App instance with optional configuration. Applies default middleware (recovery, logging) and sets up basic routes.\n  Input: opts ...AppOptions (variadic parameter for configuration options)\n  Output: *App (new App instance)\n\n- Run: func() - Starts the HTTP server using the configured port from Conf. Panics if server fails to start.\n  Input: None\n  Output: None (runs indefinitely until server stops)\n\n- Must: func(error) - Helper function (not shown in reference) that panics on error, typically used for server startup\n  Input: error\n  Output: None",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\t\"github.com/labstack/echo/middleware\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\toptions := AppOptions{}\n\tfor _, i := range opts {\n\t\toptions = i\n\t\tbreak\n\t}\n\n\toptions.init()\n\n\tengine := echo.New()\n\n\tengine.Debug = conf.UBool(\"debug\")\n\n\tengine.Use(middleware.Recover())\n\n\tengine.GET(\"/favicon.ico\", func(c echo.Context) error {\n\t\treturn c.Redirect(http.StatusMovedPermanently, \"/static/images/favicon.ico\")\n\t})\n\n\tengine.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `${method} | ${status} | ${uri} -> ${latency_human}` + \"\\n\",\n\t}))\n\n\tapp := &App{\n\t\tEngine: engine,\n\t}\n\n\treturn app\n}\n\nfunc (app *App) Run() {\n\tMust(app.Engine.Start(\":\" + app.Conf.UString(\"port\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"log\"\n)\n\ntype App struct {\n\tEngine *echo.Echo\n\tConf   *Conf\n}\n\ntype Conf struct {\n\tPort     int\n\tDebug    bool\n}\n\nfunc NewApp(opts ...AppOptions) *App {\n\tapp := &App{\n\t\tEngine: echo.New(),\n\t}\n\tfor _, opt := range opts {\n\t\topt(app)\n\t}\n\tapp.Engine.Use(middleware.Recover())\n\tapp.Engine.Use(middleware.Logger())\n\treturn app\n}\n\nfunc (a *App) Run() {\n\ta.Must(a.Engine.Start(a.Conf.Port))\n}\n\nfunc (a *App) Must(err error) {\n\tif err != nil {\n\t\tlog.Panicln(\"Server failed to start:\", err)\n\t}\n}\n\ntype AppOption func(*App)\n\nfunc WithPort(port int) AppOption {\n\treturn func(a *App) {\n\t\ta.Conf = &Conf{Port: port}\n\t}\n}\n\nfunc WithDebug(debug bool) AppOption {\n\treturn func(a *App) {\n\t\ta.Conf.Debug = debug\n\t\ta.Engine.SetDebug(debug)\n\t}\n}\n```"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Implement an auto-managed HTTP provider in Go using the Echo framework that can dynamically start/stop an HTTP server with health check capabilities.\n\nStruct Description: AutoManagedProvider is a struct that manages an Echo-based HTTP server with automatic startup/shutdown capabilities and provides health check endpoints.\n\nFields:\n- activeProvider: *echo.Echo - The Echo HTTP server instance\n- activeProviderRunning: bool - Flag indicating if the server is currently running\n- activeProviderTesting: bool - Flag indicating if the server is in testing mode\n- httpClient: *http.Client - HTTP client used for internal communications\n- autoManagePort: int - Port number for the managed HTTP server\n\nMethods:\n- NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider - Constructor that creates a new AutoManagedProvider with configuration\n- UpdateTTL() - Manages the server lifecycle (starts if not running, stops if shutdown)\n- isShutdown() bool - Checks if the server should be shutdown (returns bool)\n- getCurrentNode() interface{} - Returns current node information for health checks (returns interface{})",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/labstack/echo\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider        *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient            *http.Client\n\tautoManagePort        int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyFromEnvironment,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   5 * time.Second,\n\t\t\tKeepAlive: 5 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          10,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxConnsPerHost:       10,\n\t}\n\n\thttpClient := &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   2 * time.Second,\n\t}\n\n\tp := &AutoManagedProvider{\n\t\thttpClient:            httpClient,\n\t\tautoManagePort:        autoManPort,\n\t\tactiveProviderRunning: false,\n\t}\n\n\treturn p\n}\n\nfunc (p *AutoManagedProvider) UpdateTTL() {\n\tif p.isShutdown() && p.activeProviderRunning {\n\t\tp.activeProvider.Close()\n\t\treturn\n\t}\n\n\tif p.activeProviderRunning {\n\t\treturn\n\t}\n\n\tif !p.activeProviderTesting {\n\t\tp.activeProvider = echo.New()\n\t\tp.activeProvider.HideBanner = true\n\t\tp.activeProvider.GET(\"/_health\", func(context echo.Context) error {\n\t\t\treturn context.JSON(http.StatusOK, p.getCurrentNode())\n\t\t})\n\t}\n\tgo func() {\n\t\tp.activeProviderRunning = true\n\t\tappURI := fmt.Sprintf(\"0.0.0.0:%d\", p.autoManagePort)\n\t\tp.activeProvider.Start(appURI)\n\t\tp.activeProviderRunning = false\n\t}()\n}\n\nfunc (p *AutoManagedProvider) isShutdown() bool {\n\treturn false\n}\n\nfunc (p *AutoManagedProvider) getCurrentNode() interface{} {\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype AutoManagedProvider struct {\n\tactiveProvider     *echo.Echo\n\tactiveProviderRunning bool\n\tactiveProviderTesting bool\n\thttpClient         *http.Client\n\tautoManagePort       int\n}\n\nfunc NewWithConfig(refreshTTL time.Duration, autoManPort int, hosts ...string) *AutoManagedProvider {\n\treturn &AutoManagedProvider{\n\t\tactiveProvider:     echo.New(),\n\t\tactiveProviderRunning: false,\n\t\tactiveProviderTesting: false,\n\t\thttpClient:         &http.Client{},\n\t\tautoManagePort:       autoManPort,\n\t}\n}\n\nfunc (amp *AutoManagedProvider) UpdateTTL() {\n\tif !amp.activeProviderRunning && !amp.isShutdown() {\n\t\tgo func() {\n\t\t\tamp.activeProvider.Start(amp.autoManagePort)\n\t\t\tamp.activeProviderRunning = true\n\t\t}()\n\t} else if amp.activeProviderRunning && amp.isShutdown() {\n\t\tgo func() {\n\t\t\tamp.activeProvider.Stop()\n\t\t\tamp.activeProviderRunning = false\n\t\t}()\n\t}\n}\n\nfunc (amp *AutoManagedProvider) isShutdown() bool {\n\t// Logic to determine if the server should be shutdown\n\treturn false // Placeholder implementation\n}\n\nfunc (amp *AutoManagedProvider) getCurrentNode() interface{} {\n\t// Logic to return current node information for health checks\n\treturn nil // Placeholder implementation\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a function to retrieve metadata and ETag from Google Compute Engine (GCE) metadata server using a custom HTTP client with specific timeout configurations.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the GCE metadata server to fetch metadata value and its associated ETag. It uses a pre-configured HTTP client with custom timeout settings and adds required headers to the request. The function handles various response scenarios including not found errors and non-200 status codes.\n\nInput:\n- suffix [string]: The metadata path suffix to append to the base metadata URL\n\nOutput:\n- value [string]: The retrieved metadata value\n- etag [string]: The ETag header value from the response\n- err [error]: Error object if any error occurs during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"google.golang.org/cloud/internal\"\n)\n\nvar metaClient = &http.Client{\n\tTransport: &internal.Transport{\n\t\tBase: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   750 * time.Millisecond,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 750 * time.Millisecond,\n\t\t},\n\t},\n}\n\nfunc getETag(suffix string) (value, etag string, err error) {\n\thost := os.Getenv(\"GCE_METADATA_HOST\")\n\tif host == \"\" {\n\t\thost = \"169.254.169.254\"\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\tres, err := metaClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc getETag(suffix string) (value string, etag string, err error) {\n\tbaseURL := \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n\turl := baseURL + suffix\n\tclient := &http.Client{\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), \"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to make request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", fmt.Errorf(\"not found\")\n\t} else if resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvalue = resp.Header.Get(\"X-Google-Metadata-Value\")\n\tetag = resp.Header.Get(\"ETag\")\n\n\treturn value, etag, nil\n}\n```"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go that includes rate limiting middleware using Sentinel, with custom resource extraction and block fallback handlers.\n\nFunction Description: The function sets up a Fiber web server with Sentinel middleware for rate limiting. The middleware extracts the client's real IP from headers as the resource key and provides a custom JSON response when requests are blocked. The server listens on port 8080 and includes a test endpoint.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that runs indefinitely)",
    "Canonical_solution": "import \"github.com/gofiber/fiber/v2\"\n\nfunc Example() {\n\tapp := fiber.New()\n\tapp.Use(\n\t\tSentinelMiddleware(\n\t\t\tWithResourceExtractor(func(ctx *fiber.Ctx) string {\n\t\t\t\treturn ctx.GetReqHeaders()[\"X-Real-IP\"]\n\t\t\t}),\n\t\t\tWithBlockFallback(func(ctx *fiber.Ctx) error {\n\t\t\t\treturn ctx.Status(400).JSON(struct {\n\t\t\t\t\tError string `json:\"error\"`\n\t\t\t\t\tCode  int    `json:\"code\"`\n\t\t\t\t}{\n\t\t\t\t\t\"too many request; the quota used up\",\n\t\t\t\t\t10222,\n\t\t\t\t})\n\t\t\t})),\n\t)\n\n\tapp.Get(\"/test\", func(ctx *fiber.Ctx) error { return nil })\n\t_ = app.Listen(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/alibaba/Sentinel-Golang/core/flow\"\n\t\"github.com/alibaba/Sentinel-Golang/core/resource\"\n\t\"github.com/alibaba/Sentinel-Golang/core/system\"\n\t\"github.com/alibaba/Sentinel-Golang/logging\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Initialize Sentinel resources\n\tresource.RegisterResource(\"client_ip_resource\", &resource.Resource{\n\t\tName: \"client_ip_resource\",\n\t})\n\n\t// Define flow rules\n\tflowRule := &flow.FlowRule{\n\t\tResource:        \"client_ip_resource\",\n\t\tRuleType:        flow.FLOW_GRADE_QPS,\n\t\tThreshold:       10,\n\t\tTokenCalculateStrategy: flow.Direct,\n\t}\n\tflow.LoadRules([]*flow.FlowRule{flowRule})\n\n\t// Define system rules\n\tsystemRule := &system.SystemRule{\n\t\tResource: \"client_ip_resource\",\n\t\tKeyType:  system.QPS,\n\t\tValue:    20,\n\t}\n\tsystem.LoadRules([]*system.SystemRule{systemRule})\n\n\t// Middleware for extracting client IP\n\tr.Use(func(c *gin.Context) {\n\t\tclientIP := c.ClientIP()\n\t\tc.Set(\"X-Real-IP\", clientIP)\n\t\tc.Next()\n\t})\n\n\t// Rate limiting middleware with Sentinel\n\tr.Use(flow.FlowMiddleware(\"client_ip_resource\"))\n\n\t// Custom block handler\n\tr.Use(func(c *gin.Context) {\n\t\tblockHandle(c, \"Too many requests, please try again later.\")\n\t})\n\n\t// Test endpoint\n\tr.GET(\"/test\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Hello, world!\"})\n\t})\n\n\t// Start server\n\tif err := r.Run(\":8080\"); err != nil {\n\t\tfmt.Println(\"Failed to start server:\", err)\n\t}\n}\n\nfunc blockHandle(c *gin.Context, msg string) {\n\tc.JSON(http.StatusTooManyRequests, gin.H{\"error\": msg})\n}\n```"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Fiber-based HTTP server in Go for a dashboard application that manages queues and tenants, with optional basic authentication and template rendering capabilities.\n\nStruct Description: The Dashboard struct represents a web dashboard that provides queue management functionality through HTTP endpoints. It uses the Fiber framework for routing and middleware, supports HTML template rendering, and can be configured with basic authentication.\n\nFields:\n\nApp: *fiber.App - The Fiber application instance for handling HTTP requests\nqueue: models.Queue - Interface for queue operations\ntenantManager: models.TenantManager - Interface for tenant management operations\ncfg: config.DashboardConfig - Configuration settings for the dashboard\n\nMethods:\n\nNewDashboard: (queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) -> *Dashboard - Initializes a new Dashboard instance with the given dependencies and configuration, sets up template engine, basic auth middleware, and route handlers\nStart: () -> error - Starts the HTTP server if enabled in configuration\nStop: () -> error - Gracefully shuts down the HTTP server if enabled\nQueues: (c *fiber.Ctx) -> error - Handler for GET / route\nNewQueue: (c *fiber.Ctx) -> error - Handler for POST /queues route\nQueue: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue route\nQueueSettings: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/settings route\nSaveQueueSettings: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/settings route\nDeleteQueueConfirm: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/delete route\nDeleteQueue: (c *fiber.Ctx) -> error - Handler for POST /queues/:queue/delete route\nMessage: (c *fiber.Ctx) -> error - Handler for GET /queues/:queue/messages/:message route",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/fiber/v2/middleware/adaptor\"\n\t\"github.com/gofiber/fiber/v2/middleware/basicauth\"\n\t\"github.com/gofiber/template/html/v2\"\n)\n\ntype Dashboard struct {\n\tApp *fiber.App\n\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\n\tcfg config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\tvar engine *html.Engine\n\n\tif cfg.Dev {\n\t\tengine = html.New(\"./dashboard/views\", \".html\")\n\t\tengine.Reload(true)\n\t\tengine.Debug(true)\n\t} else {\n\t\thttp.FS(viewsfs)\n\t\tfs2, err := fs.Sub(viewsfs, \"views\")\n\t\tif err != nil {\n\t\t\tlog.Fatal().Err(err).Send()\n\t\t}\n\t\tengine = html.NewFileSystem(http.FS(fs2), \".html\")\n\t}\n\n\tapp := fiber.New(fiber.Config{\n\t\tViews:                 engine,\n\t\tDisableStartupMessage: true,\n\t})\n\n\tif cfg.User != \"\" && cfg.Pass != \"\" {\n\t\tapp.Use(basicauth.New(basicauth.Config{\n\t\t\tUsers: map[string]string{\n\t\t\t\tcfg.User: cfg.Pass,\n\t\t\t},\n\t\t}))\n\t}\n\n\td := &Dashboard{\n\t\tApp:           app,\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\n\tapp.Get(\"/\", d.Queues)\n\tapp.Post(\"/queues\", d.NewQueue)\n\tapp.Get(\"/queues/:queue\", d.Queue)\n\tapp.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\tapp.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\tapp.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\tapp.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\tapp.Get(\"/queues/:queue/messages/:message\", d.Message)\n\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"Dashboard: http://localhost:%d\\n\", d.cfg.Port)\n\treturn d.App.Listen(fmt.Sprintf(\":%d\", d.cfg.Port))\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif d.cfg.Enabled {\n\t\treturn d.App.Shutdown()\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 107,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/gofiber/template/html\"\n\t\"net/http\"\n)\n\ntype Dashboard struct {\n\tApp           *fiber.App\n\tqueue         models.Queue\n\ttenantManager models.TenantManager\n\tcfg           config.DashboardConfig\n}\n\nfunc NewDashboard(queue models.Queue, tenantManager models.TenantManager, cfg config.DashboardConfig) *Dashboard {\n\td := &Dashboard{\n\t\tApp:           fiber.New(),\n\t\tqueue:         queue,\n\t\ttenantManager: tenantManager,\n\t\tcfg:           cfg,\n\t}\n\td.setupTemplateEngine()\n\td.setupBasicAuthMiddleware()\n\td.setupRoutes()\n\treturn d\n}\n\nfunc (d *Dashboard) Start() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\treturn d.App.Listen(d.cfg.Address)\n}\n\nfunc (d *Dashboard) Stop() error {\n\tif !d.cfg.Enabled {\n\t\treturn nil\n\t}\n\treturn d.App.Shutdown()\n}\n\nfunc (d *Dashboard) Queues(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Queues page\")\n}\n\nfunc (d *Dashboard) NewQueue(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"New Queue page\")\n}\n\nfunc (d *Dashboard) Queue(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Queue page\")\n}\n\nfunc (d *Dashboard) QueueSettings(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Queue Settings page\")\n}\n\nfunc (d *Dashboard) SaveQueueSettings(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Save Queue Settings page\")\n}\n\nfunc (d *Dashboard) DeleteQueueConfirm(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Delete Queue Confirm page\")\n}\n\nfunc (d *Dashboard) DeleteQueue(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Delete Queue page\")\n}\n\nfunc (d *Dashboard) Message(c *fiber.Ctx) error {\n\t// Implement handler logic here\n\treturn c.SendString(\"Message page\")\n}\n\nfunc (d *Dashboard) setupTemplateEngine() {\n\tengine := html.New(\"./views\", \".html\")\n\td.App.SetViewEngine(engine)\n}\n\nfunc (d *Dashboard) setupBasicAuthMiddleware() {\n\td.App.Use(func(c *fiber.Ctx) error {\n\t\tusername := c.Get(\"X-Username\")\n\t\tpassword := c.Get(\"X-Password\")\n\t\tif username != d.cfg.BasicAuth.Username || password != d.cfg.BasicAuth.Password {\n\t\t\treturn c.Status(http.StatusUnauthorized).SendString(\"Unauthorized\")\n\t\t}\n\t\treturn c.Next()\n\t})\n}\n\nfunc (d *Dashboard) setupRoutes() {\n\td.App.Get(\"/\", d.Queues)\n\td.App.Post(\"/queues\", d.NewQueue)\n\td.App.Get(\"/queues/:queue\", d.Queue)\n\td.App.Get(\"/queues/:queue/settings\", d.QueueSettings)\n\td.App.Post(\"/queues/:queue/settings\", d.SaveQueueSettings)\n\td.App.Get(\"/queues/:queue/delete\", d.DeleteQueueConfirm)\n\td.App.Post(\"/queues/:queue/delete\", d.DeleteQueue)\n\td.App.Get(\"/queues/:queue/messages/:message\", d.Message)\n}\n```"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that initializes and runs a Fiber-based HTTP server with specific routes for job management, while also starting a background engine process.\n\nFunction Description: The function `Run` initializes a Fiber web server with disabled startup messages, sets up three routes for job management (creating new jobs, checking job status, and retrieving jobs), starts a background engine process in a goroutine, and finally starts listening on a specified host and port.\n\nInput: None (uses package-level constants Host and Port for server configuration)\n\nOutput: None (runs indefinitely as a web server, but technically returns an error if the server fails to start)\n\nNote: The function uses package-level constants Host and Port for server configuration and assumes the existence of handler functions NewJob, GetStatus, and GetJob, as well as an Engine function for background processing.",
    "Canonical_solution": "import (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc Run() {\n\tapp := fiber.New(fiber.Config{\n\t\tDisableStartupMessage: true,\n\t})\n\n\tapp.Post(\"/jobs/\", NewJob)\n\tapp.Get(\"/jobs/status/:id\", GetStatus)\n\tapp.Get(\"/jobs/:id\", GetJob)\n\n\tgo Engine()\n\n\tapp.Listen(Host + \":\" + Port)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 107,
    "wrong_result": "```go\nfunc Run() {\n    app := fiber.New(fiber.Config{\n        DisableStartupMessage: true,\n    })\n\n    app.Post(\"/job\", NewJob)\n    app.Get(\"/job/status/:id\", GetStatus)\n    app.Get(\"/jobs\", GetJob)\n\n    go Engine()\n\n    err := app.Listen(fmt.Sprintf(\"%s:%d\", Host, Port))\n    if err != nil {\n        log.Fatalf(\"Failed to start server: %v\", err)\n    }\n}\n```"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a Go function that initializes and runs a secure HTTPS server using Gin framework with automatic TLS certificate management from Let's Encrypt.\n\nFunction Description: The function initializes a Gin web server with default middleware (Logger and Recovery), sets up a simple GET route handler, configures automatic TLS certificate management using autocert, and starts the HTTPS server. The server will automatically obtain and renew TLS certificates from Let's Encrypt for specified domains.\n\nInput: None (The function takes no parameters as all configurations are internally defined)\n\nOutput: None (The function doesn't return anything as it runs the server indefinitely. It will log.Fatal if there's an error starting the server.)\n\nNote: The function demonstrates a complete setup for a production-ready HTTPS server with automatic certificate management. The domains and cache directory are hardcoded in this example but could be parameterized in a real implementation.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/.cache\"),\n\t}\n\n\tlog.Fatal(autotls.RunWithManager(r, m))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello, world!\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tCache:      autocert.DirCache(\"/var/www/.acme-cache\"),\n\t\tHostPolicy: autocert.HostWhitelist(\"example.com\", \"www.example.com\"),\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:      \":443\",\n\t\tTLSConfig: m.TLSConfig(),\n\t\tHandler:   r,\n\t}\n\n\tlog.Fatal(server.ListenAndServeTLS(\"\", \"\"))\n}\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a Go struct representing a Docker registry repository client that can interact with a Docker registry API to manage blobs, manifests, and tags.\n\nStruct Description: The `repository` struct represents a client for interacting with a Docker registry repository. It provides methods to access blob storage, manifests, and tags through the Docker Registry HTTP API V2.\n\nFields:\n- client: *http.Client - Custom HTTP client for making requests to the registry\n- ub: *v2.URLBuilder - URL builder for constructing registry API endpoints\n- name: reference.Named - Named reference to the Docker repository\n\nMethods:\n- Named() -> reference.Named - Returns the named reference of the repository\n- Blobs(context.Context) -> distribution.BlobStore - Returns a BlobStore for managing repository blobs\n- Manifests(context.Context, ...distribution.ManifestServiceOption) -> (distribution.ManifestService, error) - Returns a ManifestService for managing repository manifests\n- Tags(context.Context) -> distribution.TagService - Returns a TagService for managing repository tags\n\nAdditional Struct: `tags` - Handles tag operations for a Docker repository\n\nFields:\n- client: *http.Client - HTTP client for making requests\n- ub: *v2.URLBuilder - URL builder for API endpoints\n- name: reference.Named - Named reference to the repository\n\nMethods:\n- Get(context.Context, string) -> (distribution.Descriptor, error) - Retrieves descriptor information for a specific tag, first trying HEAD request and falling back to GET if needed",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/distribution\"\n\tv2 \"github.com/docker/distribution/registry/api/v2\"\n\t\"github.com/docker/distribution/registry/client/transport\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc NewRepository(name reference.Named, baseURL string, transport http.RoundTripper) (distribution.Repository, error) {\n\tub, err := v2.NewURLBuilderFromString(baseURL, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{\n\t\tTransport:     transport,\n\t\tCheckRedirect: checkHTTPRedirect,\n\t}\n\n\treturn &repository{\n\t\tclient: client,\n\t\tub:     ub,\n\t\tname:   name,\n\t}, nil\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\tstatter := &blobStatter{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t}\n\treturn &blobs{\n\t\tname:    r.name,\n\t\tub:      r.ub,\n\t\tclient:  r.client,\n\t\tstatter: statter,\n\t}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn &manifests{\n\t\tname:   r.name,\n\t\tub:     r.ub,\n\t\tclient: r.client,\n\t\tetags:  make(map[string]string),\n\t}, nil\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{\n\t\tclient: r.client,\n\t\tub:     r.ub,\n\t\tname:   r.Named(),\n\t}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\tref, err := reference.WithTag(t.name, tag)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tu, err := t.ub.BuildManifestURL(ref)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\n\tnewRequest := func(method string) (*http.Response, error) {\n\t\treq, err := http.NewRequest(method, u, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, t := range distribution.ManifestMediaTypes() {\n\t\t\treq.Header.Add(\"Accept\", t)\n\t\t}\n\t\tresp, err := t.client.Do(req)\n\t\treturn resp, err\n\t}\n\n\tresp, err := newRequest(\"HEAD\")\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch {\n\tcase resp.StatusCode >= 200 && resp.StatusCode < 400 && len(resp.Header.Get(\"Docker-Content-Digest\")) > 0:\n\t\treturn descriptorFromResponse(resp)\n\tdefault:\n\t\tresp, err = newRequest(\"GET\")\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode >= 200 && resp.StatusCode < 400 {\n\t\t\treturn descriptorFromResponse(resp)\n\t\t}\n\t\treturn distribution.Descriptor{}, HandleErrorResponse(resp)\n\t}\n}\n\nfunc descriptorFromResponse(response *http.Response) (distribution.Descriptor, error) {\n\tdesc := distribution.Descriptor{}\n\theaders := response.Header\n\n\tctHeader := headers.Get(\"Content-Type\")\n\tif ctHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Type header\")\n\t}\n\tdesc.MediaType = ctHeader\n\n\tdigestHeader := headers.Get(\"Docker-Content-Digest\")\n\tif digestHeader == \"\" {\n\t\tbytes, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\t_, desc, err := distribution.UnmarshalManifest(ctHeader, bytes)\n\t\tif err != nil {\n\t\t\treturn distribution.Descriptor{}, err\n\t\t}\n\t\treturn desc, nil\n\t}\n\n\tdgst, err := digest.Parse(digestHeader)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Digest = dgst\n\n\tlengthHeader := headers.Get(\"Content-Length\")\n\tif lengthHeader == \"\" {\n\t\treturn distribution.Descriptor{}, errors.New(\"missing or empty Content-Length header\")\n\t}\n\tlength, err := strconv.ParseInt(lengthHeader, 10, 64)\n\tif err != nil {\n\t\treturn distribution.Descriptor{}, err\n\t}\n\tdesc.Size = length\n\n\treturn desc, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage dockerregistry\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/docker/distribution\"\n\t\"github.com/docker/distribution/reference\"\n\t\"github.com/docker/distribution/v2\"\n)\n\ntype repository struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (r *repository) Named() reference.Named {\n\treturn r.name\n}\n\nfunc (r *repository) Blobs(ctx context.Context) distribution.BlobStore {\n\treturn &blobStore{client: r.client, ub: r.ub}\n}\n\nfunc (r *repository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {\n\treturn v2.NewManifestService(r.client, r.ub.String(), options...)\n}\n\nfunc (r *repository) Tags(ctx context.Context) distribution.TagService {\n\treturn &tags{client: r.client, ub: r.ub, name: r.name}\n}\n\ntype tags struct {\n\tclient *http.Client\n\tub     *v2.URLBuilder\n\tname   reference.Named\n}\n\nfunc (t *tags) Get(ctx context.Context, tag string) (distribution.Descriptor, error) {\n\turl := t.ub.Build(\"manifests\", tag)\n\tvar desc distribution.Descriptor\n\terr := t.client.Head(url).Do(ctx, nil)\n\tif err != nil {\n\t\tresp, err := t.client.Get(url).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn desc, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\treturn desc, nil\n\t\t}\n\t\treturn desc, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\treturn desc, nil\n}\n```"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Create a Go function that sets up a Gin HTTP server to handle file uploads along with form data, save the uploaded file to the server, and return a success message with the file details and form fields.\n\nFunction Description: The function initializes a Gin router, configures it to handle multipart form uploads (with a maximum size limit), serves static files from a public directory, and sets up a POST endpoint for file uploads. The endpoint binds the incoming request to a struct containing the file and form fields, saves the file to the server, and returns a success message with the file name and form field values.\n\nInput: None (The function takes no direct input parameters; it receives HTTP requests through the Gin router)\n\nOutput: None (The function does not return any value; it sends HTTP responses through the Gin context)\n\nNote: The function assumes the existence of a `BindFile` struct type which should contain at least these fields:\n- File: *multipart.FileHeader - The uploaded file\n- Name: string - A form field value\n- Email: string - A form field value",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.MaxMultipartMemory = 8 << 20\n\trouter.Static(\"/\", \"./public\")\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tvar bindFile BindFile\n\n\t\tif err := c.ShouldBind(&bindFile); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfile := bindFile.File\n\t\tdst := filepath.Base(file.Filename)\n\t\tif err := c.SaveUploadedFile(file, dst); err != nil {\n\t\t\tc.String(http.StatusBadRequest, fmt.Sprintf(\"upload file err: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, fmt.Sprintf(\"File %s uploaded successfully with fields name=%s and email=%s.\", file.Filename, bindFile.Name, bindFile.Email))\n\t})\n\trouter.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype BindFile struct {\n\tFile  *multipart.FileHeader `form:\"file\" binding:\"required\"`\n\tName  string               `form:\"name\" binding:\"required\"`\n\tEmail string               `form:\"email\" binding:\"required\"`\n}\n\nfunc uploadHandler(c *gin.Context) {\n\tvar form BindFile\n\tif err := c.ShouldBind(&form); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\n\tfile, err := form.File.Open()\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to open file\"})\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdst, err := os.Create(form.File.Filename)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create file\"})\n\t\treturn\n\t}\n\tdefer dst.Close()\n\n\tif _, err := io.Copy(dst, file); err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to write file\"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\": \"File uploaded successfully\",\n\t\t\"filename\": form.File.Filename,\n\t\t\"name\":     form.Name,\n\t\t\"email\":    form.Email,\n\t})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.Static(\"/public\", \"./public\")\n\tr.POST(\"/upload\", uploadHandler)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that retrieves metadata from a metadata server using a custom HTTP client, with support for ETag headers and error handling.\n\nFunction Description: The function `getETag` makes an HTTP GET request to a metadata server endpoint, using a custom HTTP client with specific timeout configurations. It handles the response by checking status codes, reading the response body, and extracting both the content and ETag header. The function includes error handling for various scenarios including connection errors, missing resources, and non-200 status codes.\n\nInput:\n- client *http.Client: A custom HTTP client with configured timeouts for the request\n- suffix string: The path suffix to append to the base metadata URL\n\nOutput:\n- value string: The content of the response body as a string\n- etag string: The ETag header value from the response\n- err error: An error object if any step fails, nil on success",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc getETag(client *http.Client, suffix string) (value string, etag string, err error) {\n\turl := \"https://metadata.example.com\" + suffix\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to send request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", fmt.Errorf(\"resource not found\")\n\t} else if resp.StatusCode != http.StatusOK {\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\tvalue = string(bodyBytes)\n\tetag = resp.Header.Get(\"ETag\")\n\n\treturn value, etag, nil\n}\n```"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Implement a JWT-based authentication service using Gin framework in Go, which provides public endpoints for token generation and private endpoints that require valid JWT tokens for access.\n\nFunction Description: The main function sets up a Gin HTTP server with JWT authentication. It creates two route groups: a public group for token generation and a private group that requires JWT authentication. The public endpoint generates JWT tokens, while the private endpoint demonstrates protected access.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests with the following possible inputs:\n- GET request to \"/api/\" for token generation\n- GET request to \"/api/private/\" for accessing protected content)\n\nOutput: HTTP responses with the following possible outputs:\n- For \"/api/\": JSON response containing a JWT token or error message\n- For \"/api/private/\": JSON response with protected content or authentication error\n- The server runs continuously on localhost:8080",
    "Canonical_solution": "import (\n\t\"time\"\n\n\tjwt_lib \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar (\n\tmysupersecretpassword = \"unicornsAreAwesome\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublic := r.Group(\"/api\")\n\n\tpublic.GET(\"/\", func(c *gin.Context) {\n\t\ttoken := jwt_lib.New(jwt_lib.GetSigningMethod(\"HS256\"))\n\t\ttoken.Claims = jwt_lib.MapClaims{\n\t\t\t\"Id\":  \"Christopher\",\n\t\t\t\"exp\": time.Now().Add(time.Hour * 1).Unix(),\n\t\t}\n\t\ttokenString, err := token.SignedString([]byte(mysupersecretpassword))\n\t\tif err != nil {\n\t\t\tc.JSON(500, gin.H{\"message\": \"Could not generate token\"})\n\t\t}\n\t\tc.JSON(200, gin.H{\"token\": tokenString})\n\t})\n\n\tprivate := r.Group(\"/api/private\")\n\tprivate.Use(jwt.Auth(mysupersecretpassword))\n\n\tprivate.GET(\"/\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\"message\": \"Hello from private\"})\n\t})\n\n\tr.Run(\"localhost:8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\nvar jwtKey = []byte(\"your_secret_key\")\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tjwt.StandardClaims\n}\n\nfunc generateToken(username string) (string, error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &Claims{\n\t\tUsername: username,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString(jwtKey)\n}\n\nfunc authMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\ttokenString := c.GetHeader(\"Authorization\")\n\t\tif tokenString == \"\" {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"No token provided\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t\t}\n\t\t\treturn jwtKey, nil\n\t\t})\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Failed to parse token\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\t\tif claims, ok := token.Claims.(*Claims); ok && token.Valid {\n\t\t\tc.Set(\"username\", claims.Username)\n\t\t\tc.Next()\n\t\t} else {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})\n\t\t\tc.Abort()\n\t\t}\n\t}\n}\n\nfunc publicHandler(c *gin.Context) {\n\tusername := c.Query(\"username\")\n\tif username == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Username is required\"})\n\t\treturn\n\t}\n\ttoken, err := generateToken(username)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate token\"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"token\": token})\n}\n\nfunc privateHandler(c *gin.Context) {\n\tusername := c.MustGet(\"username\").(string)\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Welcome, \" + username + \"! This is protected content.\"})\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tpublicGroup := r.Group(\"/api/\")\n\tpublicGroup.GET(\"/\", publicHandler)\n\n\tprivateGroup := r.Group(\"/api/private/\", authMiddleware())\n\tprivateGroup.GET(\"/\", privateHandler)\n\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Go struct that handles HTTP requests to a metadata service with configurable endpoints, versioning, and resource paths. The struct should support request building, execution, and response handling with retry logic and mock capabilities for testing.\n\nStruct Description: The MetaData struct provides a client for interacting with a metadata service API. It supports building requests with versioning, resource types, and sub-resources, executing requests with retry logic, and decoding responses. It includes mock functionality for testing.\n\nFields:\n- mock: requestMock - A function type for mocking requests during testing\n- client: *http.Client - The HTTP client used to execute requests\n\nMethods:\n- NewMetaData(*http.Client) *MetaData - Constructor that initializes a new MetaData instance with an optional custom HTTP client\n- New() *MetaDataRequest - Creates a new request builder instance\n\nThe MetaDataRequest nested struct handles individual request configuration and execution:\n\nFields:\n- version: string - API version to use (defaults to \"latest\")\n- resourceType: string - Type of resource being accessed (defaults to \"meta-data\")\n- resource: string - Main resource path (required)\n- subResource: string - Optional sub-resource path\n- client: *http.Client - HTTP client for request execution\n- sendRequest: requestMock - Optional mock function for testing\n\nMethods:\n- Version(string) IMetaDataRequest - Sets the API version for the request\n- ResourceType(string) IMetaDataRequest - Sets the resource type for the request\n- Resource(string) IMetaDataRequest - Sets the main resource path\n- SubResource(string) IMetaDataRequest - Sets an optional sub-resource path\n- Url() (string, error) - Constructs the full request URL from components\n- Do(interface{}) error - Executes the request and decodes the response into the provided interface\n- send() (string, error) - Internal method that performs the actual HTTP request\n- Decode(string, interface{}) error - Handles response decoding (implementation not shown in reference)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"os\"\n)\n\ntype MetaData struct {\n\tmock requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\treturn &MetaData{\n\t\tclient: client,\n\t}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tclient:      m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype requestMock func(resource string) (string, error)\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest requestMock\n}\n\nfunc (vpc *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tvpc.version = version\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) ResourceType(rtype string) IMetaDataRequest {\n\tvpc.resourceType = rtype\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tvpc.resource = resource\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) SubResource(sub string) IMetaDataRequest {\n\tvpc.subResource = sub\n\treturn vpc\n}\n\nfunc (vpc *MetaDataRequest) Url() (string, error) {\n\tif vpc.version == \"\" {\n\t\tvpc.version = \"latest\"\n\t}\n\tif vpc.resourceType == \"\" {\n\t\tvpc.resourceType = \"meta-data\"\n\t}\n\tif vpc.resource == \"\" {\n\t\treturn \"\", errors.New(\"the resource you want to visit must not be nil!\")\n\t}\n\tendpoint := os.Getenv(\"METADATA_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = \"http://100.100.100.200\"\n\t}\n\tr := fmt.Sprintf(\"%s/%s/%s/%s\", endpoint, vpc.version, vpc.resourceType, vpc.resource)\n\tif vpc.subResource == \"\" {\n\t\treturn r, nil\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", r, vpc.subResource), nil\n}\n\nfunc (vpc *MetaDataRequest) Do(api interface{}) (err error) {\n\tvar res = \"\"\n\tfor r := retry.Start(); r.Next(); {\n\t\tif vpc.sendRequest != nil {\n\t\t\tres, err = vpc.sendRequest(vpc.resource)\n\t\t} else {\n\t\t\tres, err = vpc.send()\n\t\t}\n\t\tif !shouldRetry(err) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn vpc.Decode(res, api)\n}\n\nfunc (vpc *MetaDataRequest) send() (string, error) {\n\turl, err := vpc.Url()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\trequ, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := vpc.client.Do(requ)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn \"\", fmt.Errorf(\"Aliyun Metadata API Error: Status Code: %d\", resp.StatusCode)\n\t}\n\tdefer resp.Body.Close()\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage metadata\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\ntype requestMock func(req *http.Request) (*http.Response, error)\n\ntype MetaData struct {\n\tmock   requestMock\n\tclient *http.Client\n}\n\nfunc NewMetaData(client *http.Client) *MetaData {\n\tif client == nil {\n\t\tclient = &http.Client{}\n\t}\n\treturn &MetaData{client: client}\n}\n\nfunc (m *MetaData) New() *MetaDataRequest {\n\treturn &MetaDataRequest{\n\t\tversion:    \"latest\",\n\t\tresourceType: \"meta-data\",\n\t\tclient:     m.client,\n\t\tsendRequest: m.mock,\n\t}\n}\n\ntype MetaDataRequest struct {\n\tversion      string\n\tresourceType string\n\tresource     string\n\tsubResource  string\n\tclient       *http.Client\n\tsendRequest  requestMock\n}\n\nfunc (r *MetaDataRequest) Version(version string) IMetaDataRequest {\n\tr.version = version\n\treturn r\n}\n\nfunc (r *MetaDataRequest) ResourceType(resourceType string) IMetaDataRequest {\n\tr.resourceType = resourceType\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Resource(resource string) IMetaDataRequest {\n\tr.resource = resource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) SubResource(subResource string) IMetaDataRequest {\n\tr.subResource = subResource\n\treturn r\n}\n\nfunc (r *MetaDataRequest) Url() (string, error) {\n\tbaseUrl := \"/api/v\" + r.version + \"/\" + r.resourceType + \"/\" + r.resource\n\tif r.subResource != \"\" {\n\t\tbaseUrl += \"/\" + r.subResource\n\t}\n\treturn baseUrl, nil\n}\n\nfunc (r *MetaDataRequest) Do(result interface{}) error {\n\turl, err := r.Url()\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp, err := r.send(&http.Request{\n\t\tMethod: http.MethodGet,\n\t\tURL:    url,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"HTTP \" + resp.Status)\n\t}\n\n\treturn json.NewDecoder(resp.Body).Decode(result)\n}\n\nfunc (r *MetaDataRequest) send(req *http.Request) (string, error) {\n\tif r.sendRequest != nil {\n\t\tresp, err := r.sendRequest(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn resp.Status, nil\n\t}\n\n\tresp, err := r.client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn resp.Status, nil\n}\n\ntype IMetaDataRequest interface {\n\tVersion(string) IMetaDataRequest\n\tResourceType(string) IMetaDataRequest\n\tResource(string) IMetaDataRequest\n\tSubResource(string) IMetaDataRequest\n\tUrl() (string, error)\n\tDo(interface{}) error\n}\n```"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Go function that handles file uploads along with form data using the Gin web framework. The function should process multipart form data, save uploaded files, and return a response indicating success or failure.\n\nFunction Description: The function is a Gin route handler that processes POST requests to the \"/upload\" endpoint. It handles multipart/form-data submissions containing both form fields (name and email) and file uploads. The function saves all uploaded files to the server and returns a success message with the count of uploaded files and the form field values, or an error message if the operation fails.\n\nInput: \n- Gin context object (c *gin.Context) containing:\n  - Form fields: \"name\" (string), \"email\" (string)\n  - File uploads: \"files\" (multipart.FileHeader array)\n\nOutput:\n- On success: HTTP 200 status with success message (string)\n- On failure: HTTP 400 status with error message (string)",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\trouter := gin.Default()\n\trouter.POST(\"/upload\", func(c *gin.Context) {\n\t\tname := c.PostForm(\"name\")\n\t\temail := c.PostForm(\"email\")\n\n\t\tform, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusBadRequest, \"get form err: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tfiles := form.File[\"files\"]\n\n\t\tfor _, file := range files {\n\t\t\tfilename := filepath.Base(file.Filename)\n\t\t\tif err := c.SaveUploadedFile(file, filename); err != nil {\n\t\t\t\tc.String(http.StatusBadRequest, \"upload file err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.String(http.StatusOK, \"Uploaded successfully %d files with fields name=%s and email=%s.\", len(files), name, email)\n\t})\n\trouter.Run(\":8888\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc uploadHandler(c *gin.Context) {\n\tname := c.PostForm(\"name\")\n\temail := c.PostForm(\"email\")\n\n\tform, err := c.MultipartForm()\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to parse form\"})\n\t\treturn\n\t}\n\n\tfiles := form.File[\"files\"]\n\tuploadedCount := 0\n\n\tfor _, file := range files {\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to open file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(file.Filename)\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to create file\"})\n\t\t\treturn\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to copy file\"})\n\t\t\treturn\n\t\t}\n\n\t\tuploadedCount++\n\t}\n\n\tresponse := fmt.Sprintf(\"Upload successful! %d files uploaded. Name: %s, Email: %s\", uploadedCount, name, email)\n\tc.JSON(http.StatusOK, gin.H{\"message\": response})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/upload\", uploadHandler)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Go function that initializes and runs a Gin HTTP server with automatic TLS support using Let's Encrypt, handling a simple ping-pong endpoint.\n\nFunction Description: The function initializes a Gin router with default middleware (Logger and Recovery), registers a GET endpoint \"/ping\" that responds with \"pong\", and starts the HTTPS server with automatic TLS certificate management for the specified domains.\n\nInput: \n- None (The function takes no parameters as it's the main entry point)\n\nOutput: \n- None (The function doesn't return but runs an HTTP server indefinitely or until fatal error)\n\nNote: The function uses autotls.Run() which automatically obtains and renews TLS certificates from Let's Encrypt for the specified domains. The server will listen on both HTTP (port 80) and HTTPS (port 443) ports.",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/autotls\"\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(200, \"pong\")\n\t})\n\n\tlog.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"pong\")\n\t})\n\n\tm := autocert.Manager{\n\t\tPrompt:     autocert.AcceptTOS,\n\t\tHostPolicy: autocert.HostWhitelist(\"example.com\", \"www.example.com\"),\n\t\tCache:      autocert.DirCache(\"/var/www/certs\"),\n\t}\n\n\tgo http.ListenAndServe(\":80\", m.HTTPHandler(nil))\n\n\tif err := http.ListenAndServeTLS(\":443\", \"\", \"\", r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a Go HTTP client struct that can handle both HTTP and HTTPS requests with custom configurations, including authentication and request headers.\n\nStruct Description: The Client struct represents an HTTP client with configurable protocol, address, authentication, and transport settings. It provides methods to execute HTTP requests and handle responses.\n\nFields:\nProtocol: string - The protocol to use (http or https)\nAddr: string - The server address to connect to\nUser: string - The username for basic authentication\nPassword: string - The password for basic authentication\nc: *http.Client - The underlying HTTP client instance\n\nMethods:\nNewClient: (conf *ClientConfig) -> *Client - Creates a new Client instance with the given configuration, setting up either HTTP or HTTPS transport\nDoRequest: (method string, url string, body *bytes.Buffer) -> (*http.Response, error) - Executes an HTTP request with the given method, URL and body, adding basic auth if configured\nDo: (method string, url string, body map[string]interface{}) -> (*Response, error) - Executes a request with JSON body, parses the response and returns a structured Response object",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/juju/errors\"\n)\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\n\tc *http.Client\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\tc := new(Client)\n\n\tc.Addr = conf.Addr\n\tc.User = conf.User\n\tc.Password = conf.Password\n\n\tif conf.HTTPS {\n\t\tc.Protocol = \"https\"\n\t\ttr := &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t\tc.c = &http.Client{Transport: tr}\n\t} else {\n\t\tc.Protocol = \"http\"\n\t\tc.c = &http.Client{}\n\t}\n\n\treturn c\n}\n\nfunc (c *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tif len(c.User) > 0 && len(c.Password) > 0 {\n\t\treq.SetBasicAuth(c.User, c.Password)\n\t}\n\tresp, err := c.c.Do(req)\n\n\treturn resp, err\n}\n\nfunc (c *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tbodyData, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tbuf := bytes.NewBuffer(bodyData)\n\tif body == nil {\n\t\tbuf = bytes.NewBuffer(nil)\n\t}\n\n\tresp, err := c.DoRequest(method, url, buf)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tret := new(Response)\n\tret.Code = resp.StatusCode\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tif len(data) > 0 {\n\t\terr = json.Unmarshal(data, &ret.ResponseItem)\n\t}\n\n\treturn ret, errors.Trace(err)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype ClientConfig struct {\n\tProtocol   string\n\tAddr       string\n\tUser       string\n\tPassword   string\n\tTimeout    int\n\tSkipVerify bool\n}\n\ntype Client struct {\n\tProtocol string\n\tAddr     string\n\tUser     string\n\tPassword string\n\tc        *http.Client\n}\n\nfunc NewClient(conf *ClientConfig) *Client {\n\tvar tr http.RoundTripper = &http.Transport{}\n\tif conf.SkipVerify {\n\t\ttr.(*http.Transport).TLSClientConfig.InsecureSkipVerify = true\n\t}\n\tclient := &http.Client{\n\t\tTransport: tr,\n\t\tTimeout:   time.Duration(conf.Timeout) * time.Second,\n\t}\n\treturn &Client{\n\t\tProtocol: conf.Protocol,\n\t\tAddr:     conf.Addr,\n\t\tUser:     conf.User,\n\t\tPassword: conf.Password,\n\t\tc:        client,\n\t}\n}\n\nfunc (c *Client) DoRequest(method string, url string, body *bytes.Buffer) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.User != \"\" && c.Password != \"\" {\n\t\treq.SetBasicAuth(c.User, c.Password)\n\t}\n\tresp, err := c.c.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}\n\nfunc (c *Client) Do(method string, url string, body map[string]interface{}) (*Response, error) {\n\tjsonBody, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := c.DoRequest(method, url, bytes.NewBuffer(jsonBody))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tresponseData := new(Response)\n\terr = json.NewDecoder(resp.Body).Decode(responseData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn responseData, nil\n}\n\ntype Response struct {\n\tData  interface{} `json:\"data\"`\n\tError string      `json:\"error\"`\n}\n```"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Go function that implements a distributed transaction coordinator using HTTP communication between microservices. The function should handle transaction initiation, propagate transaction context, and coordinate between multiple services.\n\nFunction Description: The function serves as an HTTP handler for initiating a distributed transaction. It receives a transaction ID in the header, prepares transaction data for two different services (Account and Inventory), makes HTTP calls to these services, and handles their responses. The function ensures transaction context (xid) is propagated to all participating services.\n\nInput: \n- Gin context object (gin.Context) containing:\n  - HTTP request headers (including \"x_seata_xid\" for transaction ID)\n  - Request body (not used in this example, but could contain transaction details)\n\nOutput:\n- HTTP responses:\n  - 400 Bad Request with error details if any step fails\n  - Original service response if any service fails (non-200 status)\n  - Success response from the last service if all succeed (200 status)\n- Side effects: Makes HTTP calls to two different services with transaction data",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/service-a/begin\", func(context *gin.Context) {\n\t\txid := context.Request.Header.Get(\"x_seata_xid\")\n\t\taccount := &Account{\n\t\t\tID:     1000024549,\n\t\t\tAmount: 200,\n\t\t}\n\t\tinv := &Inventory{\n\t\t\tID:  1000000005,\n\t\t\tQty: 2,\n\t\t}\n\n\t\taccountReq, err := json.Marshal(account)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tinvReq, err := json.Marshal(inv)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1, err := http.NewRequest(\"POST\", \"http://localhost:2047/service-b/try\", bytes.NewBuffer(accountReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq1.Header.Set(\"x_seata_xid\", xid)\n\n\t\treq2, err := http.NewRequest(\"POST\", \"http://localhost:2048/service-c/try\", bytes.NewBuffer(invReq))\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\treq2.Header.Set(\"x_seata_xid\", xid)\n\n\t\tclient := &http.Client{}\n\t\tresult1, err := client.Do(req1)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result1.StatusCode != http.StatusOK {\n\t\t\tresult1.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\n\t\tresult2, err := client.Do(req2)\n\t\tif err != nil {\n\t\t\tcontext.JSON(400, gin.H{\"success\": false, \"message\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tif result2.StatusCode == http.StatusOK {\n\t\t\tresult2.Write(context.Writer)\n\t\t\treturn\n\t\t}\n\t})\n\n\tr.Run(\":8080\")\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 105,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype TransactionRequest struct {\n\t// Define your transaction request fields here\n}\n\nfunc InitiateTransaction(c *gin.Context) {\n\txid := c.GetHeader(\"x_seata_xid\")\n\tif xid == \"\" {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Transaction ID missing\"})\n\t\treturn\n\t}\n\n\taccountData := TransactionRequest{ /* Populate with account data */ }\n\tinventoryData := TransactionRequest{ /* Populate with inventory data */ }\n\n\tvar accountResponse, inventoryResponse *http.Response\n\n\t// Call Account service\n\tvar buf bytes.Buffer\n\tjson.NewEncoder(&buf).Encode(accountData)\n\taccountReq, _ := http.NewRequest(\"POST\", \"http://account-service/transaction\", &buf)\n\taccountReq.Header.Set(\"Content-Type\", \"application/json\")\n\taccountReq.Header.Set(\"xid\", xid)\n\tclient := &http.Client{}\n\taccountResponse, err := client.Do(accountReq)\n\tif err != nil || accountResponse.StatusCode != http.StatusOK {\n\t\tc.Data(accountResponse.StatusCode, accountResponse.Header.Get(\"Content-Type\"), accountResponse.Body.Bytes())\n\t\treturn\n\t}\n\tdefer accountResponse.Body.Close()\n\n\t// Call Inventory service\n\tbuf.Reset()\n\tjson.NewEncoder(&buf).Encode(inventoryData)\n\tinventoryReq, _ := http.NewRequest(\"POST\", \"http://inventory-service/transaction\", &buf)\n\tinventoryReq.Header.Set(\"Content-Type\", \"application/json\")\n\tinventoryReq.Header.Set(\"xid\", xid)\n\tinventoryResponse, err = client.Do(inventoryReq)\n\tif err != nil || inventoryResponse.StatusCode != http.StatusOK {\n\t\tc.Data(inventoryResponse.StatusCode, inventoryResponse.Header.Get(\"Content-Type\"), inventoryResponse.Body.Bytes())\n\t\treturn\n\t}\n\tdefer inventoryResponse.Body.Close()\n\n\t// All services succeeded, return success response\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Transaction completed successfully\"})\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.POST(\"/initiate-transaction\", InitiateTransaction)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a function that demonstrates asynchronous message production to a Kafka topic using the Sarama library in Go. The function should continuously generate and send messages at regular intervals while handling both successful deliveries and errors.\n\nFunction Description: The SaramaProducer function initializes and manages an asynchronous Kafka producer. It configures the producer with specific settings, handles message delivery success/failure notifications in a separate goroutine, and continuously generates and sends messages to a specified Kafka topic. The function runs indefinitely until terminated.\n\nInput: None (The function takes no input parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function doesn't return any value but prints success/error messages to stdout)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc SaramaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tconfig.Producer.Retry.Max = 1000\n\tconfig.Version = sarama.V2_2_0_0\n\n\tproducer, e := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif e != nil {\n\t\tfmt.Println(e)\n\t\treturn\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func(p sarama.AsyncProducer) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase suc := <-p.Successes():\n\t\t\t\tfmt.Println(\"offset: \", suc.Offset, \"timestamp: \", suc.Timestamp.String(), \"partitions: \", suc.Partition)\n\t\t\tcase fail := <-p.Errors():\n\t\t\t\tfmt.Println(\"err: \", fail.Err)\n\t\t\t}\n\t\t}\n\t}(producer)\n\n\tvar value string\n\tfor i := 0; ; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\ttime11 := time.Now()\n\t\tvalue = \"this is a message 0606 \" + time11.Format(\"15:04:05\")\n\t\tmsg := &sarama.ProducerMessage{\n\t\t\tTopic: \"0606_test\",\n\t\t}\n\t\tmsg.Value = sarama.ByteEncoder(value)\n\t\tfmt.Println(value)\n\t\tproducer.Input() <- msg\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc SaramaProducer() {\n\tbrokers := []string{\"localhost:9092\"}\n\ttopic := \"test-topic\"\n\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\n\tproducer, err := sarama.NewSyncProducer(brokers, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start Sarama producer: %v\", err)\n\t}\n\tdefer producer.Close()\n\n\tgo func() {\n\t\tfor range producer.Successes() {\n\t\t\tlog.Println(\"Message delivered\")\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor range producer.Errors() {\n\t\t\tlog.Println(\"Error delivering message\")\n\t\t}\n\t}()\n\n\tfor {\n\t\tmessage := &sarama.ProducerMessage{\n\t\t\tTopic: topic,\n\t\t\tValue: sarama.StringEncoder(\"Hello, Kafka!\"),\n\t\t}\n\n\t\tpartition, offset, err := producer.SendMessage(message)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to produce message: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"Message is stored in partition %d at offset %d\\n\", partition, offset)\n\t\t}\n\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n```"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a function that implements an asynchronous Kafka producer in Go, which continuously sends messages to a specified Kafka topic at regular intervals. The function should handle both success and error cases from the producer and properly clean up resources when done.\n\nFunction Description: The function `runAsyncKafkaProducer` initializes and manages an asynchronous Kafka producer that sends alternating message types (\"login\" and \"msg\" events) to a Kafka topic every 10 seconds. It configures the producer with appropriate settings, handles success/error notifications in a separate goroutine, and ensures proper resource cleanup.\n\nInput: None (The function takes no parameters as broker addresses and topic are hardcoded)\n\nOutput: None (The function runs indefinitely until terminated, printing success/error messages to stdout)\n\nReference Code Structure:\n\n```go\nfunc runAsyncKafkaProducer() {\n    // 1. Configure Kafka producer\n    config := sarama.NewConfig()\n    config.Producer.RequiredAcks = sarama.WaitForAll\n    config.Producer.Partitioner = sarama.NewRandomPartitioner\n    config.Producer.Return.Successes = true\n    config.Producer.Return.Errors = true\n    \n    // 2. Initialize async producer\n    producer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n    if err != nil {\n        panic(err)\n    }\n    defer producer.AsyncClose()\n    \n    // 3. Start goroutine to handle producer events\n    go func() {\n        for {\n            select {\n            case success := <-producer.Successes():\n                fmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n                    success.Topic, success.Partition, success.Offset)\n            case err := <-producer.Errors():\n                fmt.Printf(\"Failed to send message: %v\\n\", err)\n            }\n        }\n    }()\n    \n    // 4. Main message sending loop\n    var messageType int = 1\n    for {\n        msg := createMessage(messageType)\n        producer.Input() <- msg\n        \n        messageType = toggleMessageType(messageType)\n        time.Sleep(10 * time.Second)\n    }\n}\n\n// Helper functions would be defined here...\n```",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"time\"\n)\n\nfunc main() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\tAsyncProducer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer AsyncProducer.AsyncClose()\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase succ := <-AsyncProducer.Successes():\n\t\t\t\tfmt.Println(\"AsyncProducer.Successes()\", succ.Topic, succ.Offset, succ.Timestamp, succ.Partition)\n\t\t\tcase err := <-AsyncProducer.Errors():\n\t\t\t\tfmt.Println(\"AsyncProducer.Errors()\", err.Error())\n\t\t\t}\n\t\t}\n\t}()\n\tvar i = 1\n\tfor {\n\t\tMessage := &sarama.ProducerMessage{\n\t\t\tTopic:     \"msg_event\",\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tvar data []byte\n\t\tdate := time.Now().UnixNano() / 1e6\n\t\tif i == 1 {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"11\",\n\t\t\t\t\"uid\":         1,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"login\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 2\n\t\t} else {\n\t\t\tdata, _ = json.Marshal(map[string]interface{}{\n\t\t\t\t\"biz_tag\":     \"22\",\n\t\t\t\t\"uid\":         222222,\n\t\t\t\t\"create_time\": date,\n\t\t\t\t\"event\":       \"msg\",\n\t\t\t\t\"tag\":         \"1\",\n\t\t\t})\n\t\t\ti = 1\n\t\t}\n\n\t\tMessage.Value = sarama.ByteEncoder(data)\n\t\tAsyncProducer.Input() <- Message\n\t\ttime.Sleep(time.Second * 10)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 125,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc runAsyncKafkaProducer() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconfig.Producer.Return.Successes = true\n\tconfig.Producer.Return.Errors = true\n\n\tproducer, err := sarama.NewAsyncProducer([]string{\"172.12.17.161:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer producer.AsyncClose()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase success := <-producer.Successes():\n\t\t\t\tfmt.Printf(\"Message sent: topic=%s partition=%d offset=%d\\n\",\n\t\t\t\t\tsuccess.Topic, success.Partition, success.Offset)\n\t\t\tcase err := <-producer.Errors():\n\t\t\t\tfmt.Printf(\"Failed to send message: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar messageType int = 1\n\tfor {\n\t\tmsg := createMessage(messageType)\n\t\tproducer.Input() <- msg\n\t\t\n\t\tmessageType = toggleMessageType(messageType)\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}\n\nfunc createMessage(messageType int) *sarama.ProducerMessage {\n\ttopic := \"test-topic\"\n\tkey := []byte(fmt.Sprintf(\"key-%d\", messageType))\n\tvalue := []byte(fmt.Sprintf(\"value-%d\", messageType))\n\n\treturn &sarama.ProducerMessage{\n\t\tTopic: topic,\n\t\tKey:   sarama.StringEncoder(key),\n\t\tValue: sarama.ByteEncoder(value),\n\t}\n}\n\nfunc toggleMessageType(messageType int) int {\n\tif messageType == 1 {\n\t\treturn 2\n\t}\n\treturn 1\n}\n\nfunc main() {\n\trunAsyncKafkaProducer()\n}\n```"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.\n\nTask Description: Create a function that demonstrates how to use the Kafka synchronous producer in Go to send a message to a Kafka topic.\n\nFunction Description: The function initializes and configures a synchronous Kafka producer, sends a single message to a specified Kafka topic, and handles any errors that may occur during the process. The producer is properly closed after use.\n\nInput: None (The function is self-contained with hardcoded values for demonstration purposes)\n\nOutput: The function returns the result of the message send operation (partition and offset if successful, or error if failed) and prints it to the console. The function itself doesn't return any value but may terminate early if producer initialization fails.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/Shopify/sarama\"\n\t\"testing\"\n)\n\nfunc TestKafkaSyncProducer(t *testing.T) {\n\tconf := sarama.NewConfig()\n\tconf.Producer.RequiredAcks = sarama.WaitForAll\n\tconf.Producer.Partitioner = sarama.NewRandomPartitioner\n\tconf.Producer.Return.Successes = true\n\tconf.Producer.Return.Errors = true\n\tconf.Producer.Retry.Max = 1000\n\tconf.Version = sarama.V2_8_0_0\n\tproducer, err := sarama.NewSyncProducer([]string{\"172.12.12.165:9092\"}, conf)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer producer.Close()\n\tfmt.Println(producer.SendMessage(&sarama.ProducerMessage{\n\t\tTopic: \"gs_pay_transaction_topic\",\n\t\tValue: sarama.ByteEncoder(\"123123\"),\n\t}))\n\tselect {}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 123,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/Shopify/sarama\"\n)\n\nfunc main() {\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.Return.Successes = true\n\n\tproducer, err := sarama.NewSyncProducer([]string{\"localhost:9092\"}, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start Sarama producer: %s\", err)\n\t}\n\tdefer func() {\n\t\tif err := producer.Close(); err != nil {\n\t\t\tlog.Printf(\"Error closing producer: %s\", err)\n\t\t}\n\t}()\n\n\tmsg := &sarama.ProducerMessage{\n\t\tTopic: \"test\",\n\t\tValue: sarama.StringEncoder(\"Hello Kafka!\"),\n\t}\n\n\tpartition, offset, err := producer.SendMessage(msg)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send message: %s\", err)\n\t}\n\n\tfmt.Printf(\"Message is stored in topic(%s)/partition(%d)/offset(%d)\\n\", msg.Topic, partition, offset)\n}\n```"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Implement a TCP/UDP port scanner with proxy support and configurable source IP addresses.\n\nStruct Description: The Scanner struct provides functionality to check if a specific port is open on a given host, supporting both TCP and UDP protocols. It includes timeout configuration, proxy support, and the ability to specify source IP addresses for the connection.\n\nFields:\n- timeout: time.Duration - Maximum duration to wait for a connection attempt\n- proxyDialer: proxy.Dialer - Optional proxy dialer for making connections through a proxy\n- ListenHandler: *ListenHandler - Configuration for source IP addresses (both IPv4 and IPv6)\n\nMethods:\n- ConnectPort: (host string, p *port.Port, timeout time.Duration) -> (bool, error) - Attempts to connect to the specified port on the given host. Returns true if the port is open/reachable, along with any error that occurred during the connection attempt. The port parameter includes the protocol (TCP/UDP) and port number. The timeout parameter specifies the maximum duration for the connection attempt.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\t\"golang.org/x/net/proxy\"\n)\n\ntype Scanner struct {\n\ttimeout     time.Duration\n\tproxyDialer proxy.Dialer\n\tListenHandler *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port.Port, timeout time.Duration) (bool, error) {\n\thostport := net.JoinHostPort(host, fmt.Sprint(p.Port))\n\tvar (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\tif s.proxyDialer != nil {\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t\tproxyDialer, ok := s.proxyDialer.(proxy.ContextDialer)\n\t\tif !ok {\n\t\t\treturn false, errors.New(\"invalid proxy dialer\")\n\t\t}\n\t\tconn, err = proxyDialer.DialContext(ctx, p.Protocol.String(), hostport)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tnetDialer := net.Dialer{\n\t\t\tTimeout: timeout,\n\t\t}\n\t\tif s.ListenHandler.SourceIp4 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIp4}\n\t\t} else if s.ListenHandler.SourceIP6 != nil {\n\t\t\tnetDialer.LocalAddr = &net.TCPAddr{IP: s.ListenHandler.SourceIP6}\n\t\t}\n\t\tconn, err = netDialer.Dial(p.Protocol.String(), hostport)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer conn.Close()\n\n\tswitch p.Protocol {\n\tcase protocol.UDP:\n\t\tif err := conn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif _, err := conn.Write(nil); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif err := conn.SetReadDeadline(time.Now().Add(timeout)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tn, err := io.Copy(io.Discard, conn)\n\t\tif err != nil && !os.IsTimeout(err) {\n\t\t\treturn false, err\n\t\t}\n\t\treturn n > 0, nil\n\t}\n\n\treturn true, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n)\n\ntype port struct {\n\tProtocol string\n\tPort     int\n}\n\ntype ListenHandler struct {\n\tIPv4 string\n\tIPv6 string\n}\n\ntype Scanner struct {\n\ttimeout        time.Duration\n\tproxyDialer    *proxy.Dialer\n\tListenHandler  *ListenHandler\n}\n\nfunc (s *Scanner) ConnectPort(host string, p *port, timeout time.Duration) (bool, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tvar conn net.Conn\n\tvar err error\n\tswitch p.Protocol {\n\tcase \"tcp\":\n\t\tconn, err = s.dialTCP(ctx, host, p.Port)\n\tcase \"udp\":\n\t\tconn, err = s.dialUDP(ctx, host, p.Port)\n\tdefault:\n\t\treturn false, fmt.Errorf(\"unsupported protocol: %s\", p.Protocol)\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tconn.Close()\n\treturn true, nil\n}\n\nfunc (s *Scanner) dialTCP(ctx context.Context, host string, port int) (net.Conn, error) {\n\tdialer := net.Dialer{\n\t\tTimeout:   s.timeout,\n\t\tLocalAddr: s.getLocalAddr(),\n\t}\n\treturn dialer.DialContext(ctx, \"tcp\", fmt.Sprintf(\"%s:%d\", host, port))\n}\n\nfunc (s *Scanner) dialUDP(ctx context.Context, host string, port int) (net.Conn, error) {\n\taddr := &net.UDPAddr{IP: net.ParseIP(host), Port: port}\n\tdialer := net.Dialer{\n\t\tTimeout:   s.timeout,\n\t\tLocalAddr: s.getLocalAddr(),\n\t}\n\treturn dialer.DialContext(ctx, \"udp\", addr.String())\n}\n\nfunc (s *Scanner) getLocalAddr() net.Addr {\n\tif s.ListenHandler.IPv4 != \"\" {\n\t\treturn &net.TCPAddr{IP: net.ParseIP(s.ListenHandler.IPv4)}\n\t} else if s.ListenHandler.IPv6 != \"\" {\n\t\treturn &net.TCPAddr{IP: net.ParseIP(s.ListenHandler.IPv6)}\n\t}\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Create a function that uploads a video file to a specified URL using a multipart/form-data POST request with custom headers.\n\nFunction Description: The function uploads a video file to a given URL with specified form fields and authentication headers. It handles file operations, creates a multipart form payload, sets appropriate headers (including content type and access token), executes the HTTP request, and returns the response body.\n\nInput:\n- url (string): The target URL for the video upload\n- method (string): HTTP method (typically \"POST\")\n- advertiserID (string): The advertiser ID for the form field\n- uploadType (string): The upload type for the form field\n- videoSignature (string): The video signature for the form field\n- filePath (string): Path to the video file to upload\n- accessToken (string): Access token for authentication header\n\nOutput:\n- ([]byte, error): Returns the response body as bytes and any error that occurred during execution\n\nNote: The function should follow the same steps as the reference code, including creating a custom http.Client, setting headers, handling multipart form data, and properly managing resources (file handles, response bodies).",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"video_signature\", \"6b12a8bbbe8e69a2ef5929028b0b50c3\")\n\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\")\n\tdefer file.Close()\n\n\tpart4, errFile4 := writer.CreateFormFile(\"video_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/6b12a8bbbe8e69a2ef5929028b0b50c3.mp4\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc UploadVideo(url, method, advertiserID, uploadType, videoSignature, filePath, accessToken string) ([]byte, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\n\t}\n\tdefer file.Close()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tpart, err := writer.CreateFormFile(\"video\", filepath.Base(filePath))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create form file: %w\", err)\n\t}\n\n\t_, err = io.Copy(part, file)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to copy file to part: %w\", err)\n\t}\n\n\terr = writer.WriteField(\"advertiser_id\", advertiserID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write advertiser_id field: %w\", err)\n\t}\n\n\terr = writer.WriteField(\"upload_type\", uploadType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write upload_type field: %w\", err)\n\t}\n\n\terr = writer.WriteField(\"video_signature\", videoSignature)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write video_signature field: %w\", err)\n\t}\n\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to close writer: %w\", err)\n\t}\n\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", accessToken))\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to execute request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tresponseBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response body: %w\", err)\n\t}\n\n\treturn responseBody, nil\n}\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP client in Go that establishes a connection to a server, handles data transmission, and manages connection lifecycle with proper error handling and resource cleanup.\n\nStruct Description: The `Client` struct represents a TCP client that connects to a server using a round-robin server selection strategy. It manages server connections, handles policy enforcement, and processes data transmission for both TCP and UDP protocols.\n\nFields:\n- serverPicker: [protocol.ServerPicker] - Selects servers in a round-robin fashion from available server list  \n- policyManager: [policy.Manager] - Manages connection policies including timeouts and user levels\n\nMethods:\n- NewClient: [func(ctx context.Context, config *ClientConfig) (*Client, error)] -> (*Client, error) - Creates a new Client instance with server configurations and policy manager\n- Process: [func(ctx context.Context, link *transport.Link, dialer internet.Dialer) error] -> error - Main processing method that establishes connection, handles handshake, and manages data transfer between client and server",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/xtls/xray-core/common\"\n\t\"github.com/xtls/xray-core/common/buf\"\n\t\"github.com/xtls/xray-core/common/errors\"\n\t\"github.com/xtls/xray-core/common/net\"\n\t\"github.com/xtls/xray-core/common/protocol\"\n\t\"github.com/xtls/xray-core/common/retry\"\n\t\"github.com/xtls/xray-core/common/session\"\n\t\"github.com/xtls/xray-core/common/signal\"\n\t\"github.com/xtls/xray-core/common/task\"\n\t\"github.com/xtls/xray-core/core\"\n\t\"github.com/xtls/xray-core/features/policy\"\n\t\"github.com/xtls/xray-core/transport\"\n\t\"github.com/xtls/xray-core/transport/internet\"\n\t\"github.com/xtls/xray-core/transport/internet/stat\"\n)\n\ntype Client struct {\n\tserverPicker  protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tserverList := protocol.NewServerList()\n\tfor _, rec := range config.Server {\n\t\ts, err := protocol.NewServerSpecFromPB(rec)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"failed to get server spec\").Base(err)\n\t\t}\n\t\tserverList.AddServer(s)\n\t}\n\tif serverList.Size() == 0 {\n\t\treturn nil, errors.New(\"0 target server\")\n\t}\n\n\tv := core.MustFromContext(ctx)\n\tc := &Client{\n\t\tserverPicker:  protocol.NewRoundRobinServerPicker(serverList),\n\t\tpolicyManager: v.GetFeature(policy.ManagerType()).(policy.Manager),\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\toutbounds := session.OutboundsFromContext(ctx)\n\tob := outbounds[len(outbounds)-1]\n\tif !ob.Target.IsValid() {\n\t\treturn errors.New(\"target not specified.\")\n\t}\n\tob.Name = \"socks\"\n\tob.CanSpliceCopy = 2\n\tdestination := ob.Target\n\n\tvar server *protocol.ServerSpec\n\tvar dest net.Destination\n\tvar conn stat.Connection\n\n\tif err := retry.ExponentialBackoff(5, 100).On(func() error {\n\t\tserver = c.serverPicker.PickServer()\n\t\tdest = server.Destination()\n\t\trawConn, err := dialer.Dial(ctx, dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconn = rawConn\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn errors.New(\"failed to find an available destination\").Base(err)\n\t}\n\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\terrors.LogInfoInner(ctx, err, \"failed to closed connection\")\n\t\t}\n\t}()\n\n\tp := c.policyManager.ForLevel(0)\n\n\trequest := &protocol.RequestHeader{\n\t\tVersion: socks5Version,\n\t\tCommand: protocol.RequestCommandTCP,\n\t\tAddress: destination.Address,\n\t\tPort:    destination.Port,\n\t}\n\n\tif destination.Network == net.Network_UDP {\n\t\trequest.Command = protocol.RequestCommandUDP\n\t}\n\n\tuser := server.PickUser()\n\tif user != nil {\n\t\trequest.User = user\n\t\tp = c.policyManager.ForLevel(user.Level)\n\t}\n\n\tif err := conn.SetDeadline(time.Now().Add(p.Timeouts.Handshake)); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to set deadline for handshake\")\n\t}\n\tudpRequest, err := ClientHandshake(request, conn, conn)\n\tif err != nil {\n\t\treturn errors.New(\"failed to establish connection to server\").AtWarning().Base(err)\n\t}\n\tif udpRequest != nil {\n\t\tif udpRequest.Address == net.AnyIP || udpRequest.Address == net.AnyIPv6 {\n\t\t\tudpRequest.Address = dest.Address\n\t\t}\n\t}\n\n\tif err := conn.SetDeadline(time.Time{}); err != nil {\n\t\terrors.LogInfoInner(ctx, err, \"failed to clear deadline after handshake\")\n\t}\n\n\tvar newCtx context.Context\n\tvar newCancel context.CancelFunc\n\tif session.TimeoutOnlyFromContext(ctx) {\n\t\tnewCtx, newCancel = context.WithCancel(context.Background())\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\ttimer := signal.CancelAfterInactivity(ctx, func() {\n\t\tcancel()\n\t\tif newCancel != nil {\n\t\t\tnewCancel()\n\t\t}\n\t}, p.Timeouts.ConnectionIdle)\n\n\tvar requestFunc func() error\n\tvar responseFunc func() error\n\tif request.Command == protocol.RequestCommandTCP {\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\treturn buf.Copy(link.Reader, buf.NewWriter(conn), buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treturn buf.Copy(buf.NewReader(conn), link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t} else if request.Command == protocol.RequestCommandUDP {\n\t\tudpConn, err := dialer.Dial(ctx, udpRequest.Destination())\n\t\tif err != nil {\n\t\t\treturn errors.New(\"failed to create UDP connection\").Base(err)\n\t\t}\n\t\tdefer udpConn.Close()\n\t\trequestFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.DownlinkOnly)\n\t\t\twriter := &UDPWriter{Writer: udpConn, Request: request}\n\t\t\treturn buf.Copy(link.Reader, writer, buf.UpdateActivity(timer))\n\t\t}\n\t\tresponseFunc = func() error {\n\t\t\tdefer timer.SetTimeout(p.Timeouts.UplinkOnly)\n\t\t\treader := &UDPReader{Reader: udpConn}\n\t\t\treturn buf.Copy(reader, link.Writer, buf.UpdateActivity(timer))\n\t\t}\n\t}\n\n\tif newCtx != nil {\n\t\tctx = newCtx\n\t}\n\n\tresponseDonePost := task.OnSuccess(responseFunc, task.Close(link.Writer))\n\tif err := task.Run(ctx, requestFunc, responseDonePost); err != nil {\n\t\treturn errors.New(\"connection ends\").Base(err)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 110,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/yourusername/protocol\"\n\t\"github.com/yourusername/policy\"\n\t\"github.com/yourusername/transport\"\n\t\"github.com/yourusername/internet\"\n)\n\ntype Client struct {\n\tserverPicker protocol.ServerPicker\n\tpolicyManager policy.Manager\n}\n\ntype ClientConfig struct {\n\tServers []string\n\tPolicy  policy.Policy\n}\n\nfunc NewClient(ctx context.Context, config *ClientConfig) (*Client, error) {\n\tclient := &Client{\n\t\tserverPicker: protocol.NewRoundRobinServerPicker(config.Servers),\n\t\tpolicyManager: policy.NewManager(config.Policy),\n\t}\n\treturn client, nil\n}\n\nfunc (c *Client) Process(ctx context.Context, link *transport.Link, dialer internet.Dialer) error {\n\tfor {\n\t\tserver := c.serverPicker.Next()\n\t\tconn, err := dialer.DialContext(ctx, \"tcp\", server)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to connect to server %s: %w\", server, err)\n\t\t}\n\t\tdefer conn.Close()\n\n\t\terr = c.handshake(ctx, conn)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"handshake failed: %w\", err)\n\t\t}\n\n\t\terr = c.transferData(ctx, link, conn)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"data transfer failed: %w\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-time.After(c.policyManager.GetTimeout()):\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (c *Client) handshake(ctx context.Context, conn net.Conn) error {\n\t// Implement handshake logic here\n\treturn nil\n}\n\nfunc (c *Client) transferData(ctx context.Context, link *transport.Link, conn net.Conn) error {\n\t// Implement data transfer logic here\n\treturn nil\n}\n\nfunc main() {\n\tctx := context.Background()\n\tconfig := &ClientConfig{\n\t\tServers: []string{\"server1:port\", \"server2:port\"},\n\t\tPolicy: policy.Policy{\n\t\t\tTimeout: time.Second * 5,\n\t\t\tUserLevel: \"high\",\n\t\t},\n\t}\n\n\tclient, err := NewClient(ctx, config)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create client:\", err)\n\t\treturn\n\t}\n\n\tlink := transport.NewLink()\n\tdialer := internet.NewDialer()\n\n\terr = client.Process(ctx, link, dialer)\n\tif err != nil {\n\t\tfmt.Println(\"Client process failed:\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and applies specific traffic class and hop limit settings if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely until terminated.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\ttcpConn.SetTrafficClass(0x8)\n\t\ttcpConn.SetWriteBuffer(256)\n\t}\n\tconn.Write([]byte(\"HELLO-R-U-THERE-ACK\"))\n}\n\nfunc startServer() {\n\tlistener, err := net.ListenTCP(\"tcp6\", &net.TCPAddr{Port: 1024})\n\tif err != nil {\n\t\tfmt.Println(\"Error listening:\", err.Error())\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc main() {\n\tstartServer()\n}\n```"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Go struct that manages multiple TCP and UDP listeners for a proxy server, with methods to register and handle incoming connections.\n\nStruct Description: The Proxy struct manages network listeners for UDP, TCP, and local DNS-over-HTTPS (DoH) connections. It provides methods to create listeners from addresses and handle incoming connections through separate goroutines.\n\nFields:\nudpListeners: []*net.UDPConn - Slice of active UDP listeners\ntcpListeners: []*net.TCPListener - Slice of active TCP listeners\nlocalDoHListeners: []*net.TCPListener - Slice of active local DoH TCP listeners\n\nMethods:\nregisterUDPListener(*net.UDPConn) -> void - Adds a UDP listener to the udpListeners slice\nregisterTCPListener(*net.TCPListener) -> void - Adds a TCP listener to the tcpListeners slice\nregisterLocalDoHListener(*net.TCPListener) -> void - Adds a local DoH listener to the localDoHListeners slice\nudpListenerFromAddr(*net.UDPAddr) -> error - Creates and registers a UDP listener from address\ntcpListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a TCP listener from address\nlocalDoHListenerFromAddr(*net.TCPAddr) -> error - Creates and registers a local DoH listener from address\nudpListener(*net.UDPConn) -> void - Handles incoming UDP connections (runs in goroutine)\ntcpListener(*net.TCPListener) -> void - Handles incoming TCP connections (runs in goroutine)\nstartAcceptingClients() -> void - Starts all registered listeners in separate goroutines",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners    []*net.UDPConn\n\ttcpListeners    []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (proxy *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tproxy.udpListeners = append(proxy.udpListeners, conn)\n}\n\nfunc (proxy *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tproxy.tcpListeners = append(proxy.tcpListeners, listener)\n}\n\nfunc (proxy *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tproxy.localDoHListeners = append(proxy.localDoHListeners, listener)\n}\n\nfunc (proxy *Proxy) udpListenerFromAddr(listenAddr *net.UDPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"udp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"udp4\"\n\t}\n\tclientPc, err := net.ListenUDP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerUDPListener(clientPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) tcpListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerTCPListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) localDoHListenerFromAddr(listenAddr *net.TCPAddr) error {\n\tlistenAddrStr := listenAddr.String()\n\tnetwork := \"tcp\"\n\tisIPv4 := isDigit(listenAddrStr[0])\n\tif isIPv4 {\n\t\tnetwork = \"tcp4\"\n\t}\n\tacceptPc, err := net.ListenTCP(network, listenAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.registerLocalDoHListener(acceptPc)\n\treturn nil\n}\n\nfunc (proxy *Proxy) udpListener(clientPc *net.UDPConn) {\n\tdefer clientPc.Close()\n\tfor {\n\t\tbuffer := make([]byte, MaxDNSPacketSize-1)\n\t\tlength, clientAddr, err := clientPc.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tpacket := buffer[:length]\n\t\tgo proxy.processIncomingQuery(\"udp\", \"udp\", packet, &clientAddr, clientPc, time.Now(), false)\n\t}\n}\n\nfunc (proxy *Proxy) tcpListener(acceptPc *net.TCPListener) {\n\tdefer acceptPc.Close()\n\tfor {\n\t\tclientPc, err := acceptPc.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgo func() {\n\t\t\tdefer clientPc.Close()\n\t\t\tif err := clientPc.SetDeadline(time.Now().Add(proxy.timeout)); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart := time.Now()\n\t\t\tpacket, err := ReadPrefixed(&clientPc)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclientAddr := clientPc.RemoteAddr()\n\t\t\tproxy.processIncomingQuery(\"tcp\", \"tcp\", packet, &clientAddr, clientPc, start, false)\n\t\t}()\n\t}\n}\n\nfunc (proxy *Proxy) startAcceptingClients() {\n\tfor _, clientPc := range proxy.udpListeners {\n\t\tgo proxy.udpListener(clientPc)\n\t}\n\tproxy.udpListeners = nil\n\tfor _, acceptPc := range proxy.tcpListeners {\n\t\tgo proxy.tcpListener(acceptPc)\n\t}\n\tproxy.tcpListeners = nil\n\tfor _, acceptPc := range proxy.localDoHListeners {\n\t\tgo proxy.localDoHListener(acceptPc)\n\t}\n\tproxy.localDoHListeners = nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n)\n\ntype Proxy struct {\n\tudpListeners      []*net.UDPConn\n\ttcpListeners      []*net.TCPListener\n\tlocalDoHListeners []*net.TCPListener\n}\n\nfunc (p *Proxy) registerUDPListener(conn *net.UDPConn) {\n\tp.udpListeners = append(p.udpListeners, conn)\n}\n\nfunc (p *Proxy) registerTCPListener(listener *net.TCPListener) {\n\tp.tcpListeners = append(p.tcpListeners, listener)\n}\n\nfunc (p *Proxy) registerLocalDoHListener(listener *net.TCPListener) {\n\tp.localDoHListeners = append(p.localDoHListeners, listener)\n}\n\nfunc (p *Proxy) udpListenerFromAddr(addr *net.UDPAddr) error {\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerUDPListener(conn)\n\tgo p.udpListener(conn)\n\treturn nil\n}\n\nfunc (p *Proxy) tcpListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerTCPListener(listener)\n\tgo p.tcpListener(listener)\n\treturn nil\n}\n\nfunc (p *Proxy) localDoHListenerFromAddr(addr *net.TCPAddr) error {\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.registerLocalDoHListener(listener)\n\tgo p.tcpListener(listener) // Assuming same handler for simplicity\n\treturn nil\n}\n\nfunc (p *Proxy) udpListener(conn *net.UDPConn) {\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, _, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Handle UDP packet\n\t}\n}\n\nfunc (p *Proxy) tcpListener(listener *net.TCPListener) {\n\tfor {\n\t\tconn, err := listener.AcceptTCP()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Handle TCP connection\n\t}\n}\n\nfunc (p *Proxy) startAcceptingClients() {\n\tfor _, udpListener := range p.udpListeners {\n\t\tgo p.udpListener(udpListener)\n\t}\n\tfor _, tcpListener := range p.tcpListeners {\n\t\tgo p.tcpListener(tcpListener)\n\t}\n\tfor _, dohListener := range p.localDoHListeners {\n\t\tgo p.tcpListener(dohListener)\n\t}\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a Go struct that manages HTTP requests to interact with a community persistence service, including authentication and community creation functionality.\n\nStruct Description: The Manager struct provides methods to interact with a community persistence API, handling authentication and request/response processing. It maintains connection details and context for request cancellation.\n\nFields:\nurl: string - Base URL of the community persistence service\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nctx: context.Context - Context for request cancellation and timeouts\n\nMethods:\nNewManager: (url string, username string, password string, ctx context.Context) -> *Manager - Constructor that initializes a new Manager instance with connection details and context\nCreatePersistentCommunity: (community string, password string) -> (*persisters.Community, error) - Creates a new persistent community by making an authenticated POST request to the service, returning the created community or an error",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/pojntfx/weron/internal/persisters\"\n)\n\nvar (\n\tjson = jsoniter.ConfigCompatibleWithStandardLibrary\n)\n\ntype Manager struct {\n\turl      string\n\tusername string\n\tpassword string\n\tctx      context.Context\n}\n\nfunc NewManager(\n\turl string,\n\tusername string,\n\tpassword string,\n\tctx context.Context,\n) *Manager {\n\treturn &Manager{\n\t\turl:      url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:      ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\thc := &http.Client{}\n\n\tu, err := url.Parse(m.url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := u.Query()\n\tq.Set(\"community\", community)\n\tq.Set(\"password\", password)\n\tu.RawQuery = q.Encode()\n\n\treq, err := http.NewRequest(http.MethodPost, u.String(), http.NoBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\n\tres, err := hc.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(res.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := persisters.Community{}\n\tif err := json.Unmarshal(body, &c); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &c, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/your/package/persisters\"\n)\n\ntype Manager struct {\n\turl    string\n\tusername string\n\tpassword string\n\tctx    context.Context\n}\n\nfunc NewManager(url string, username string, password string, ctx context.Context) *Manager {\n\treturn &Manager{\n\t\turl:    url,\n\t\tusername: username,\n\t\tpassword: password,\n\t\tctx:    ctx,\n\t}\n}\n\nfunc (m *Manager) CreatePersistentCommunity(community string, password string) (*persisters.Community, error) {\n\tclient := &http.Client{Timeout: 10 * time.Second}\n\treq, err := http.NewRequestWithContext(m.ctx, \"POST\", fmt.Sprintf(\"%s/create\", m.url), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(m.username, m.password)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tbody := map[string]string{\"name\": community, \"password\": password}\n\tjsonBody, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Body = io.NopCloser(bytes.NewBuffer(jsonBody))\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar result persisters.Community\n\terr = json.NewDecoder(resp.Body).Decode(&result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &result, nil\n}\n```"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Implement a high-performance TCP server in Go using kqueue for event notification, capable of handling multiple client connections efficiently with non-blocking I/O operations.\n\nStruct Description: The `poller` struct manages a single kqueue instance and handles all I/O operations for its assigned connections. It works as part of an engine (`g *Engine`) to process network events either as a listener (accepting new connections) or as a worker (handling read/write operations).\n\nFields:\n\ng: *Engine - Reference to the parent engine managing all pollers\nmux: sync.Mutex - Mutex for thread-safe access to eventList\nkfd: int - Kqueue file descriptor\nevtfd: int - Event file descriptor (unused in current implementation)\nindex: int - Poller's index in the engine's poller array\nshutdown: bool - Flag to control poller shutdown\nlistener: net.Listener - TCP listener (only for listener pollers)\nisListener: bool - Flag indicating if this is a listener poller\nunixSockAddr: string - Unix socket address (if using UNIX domain sockets)\nReadBuffer: []byte - Buffer for read operations\npollType: string - Type identifier (\"LISTENER\" or \"POLLER\")\neventList: []syscall.Kevent_t - Pending kqueue events to be processed\n\nMethods:\n\naddConn(c *Conn) -> error - Adds a new connection to the poller and registers it for read events\naddDialer(c *Conn) -> error - Adds a dialer connection and registers it for read/write events\ngetConn(fd int) -> *Conn - Retrieves a connection by file descriptor\ndeleteConn(c *Conn) -> - Removes a connection from tracking\ntrigger() -> - Wakes up the kqueue loop\naddRead(fd int) -> - Registers a file descriptor for read events\nresetRead(fd int) -> - Unregisters write events for a file descriptor\nmodWrite(fd int) -> - Registers a file descriptor for write events\naddReadWrite(fd int) -> - Registers a file descriptor for both read and write events\nreadWrite(ev *syscall.Kevent_t) -> - Processes read/write events from kqueue\nstart() -> - Starts the poller's main loop (either acceptorLoop or readWriteLoop)\nacceptorLoop() -> - Listener's main loop that accepts new connections\nreadWriteLoop() -> - Worker's main loop that processes I/O events\nstop() -> - Stops the poller and cleans up resources\nnewPoller(g *Engine, isListener bool, index int) -> (*poller, error) - Constructor that creates either a listener or worker poller",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Conn struct {\n\tfd        int\n\tbuffer    []byte\n\tcloseChan chan struct{}\n}\n\nfunc NewConn(fd int) *Conn {\n\treturn &Conn{\n\t\tfd:        fd,\n\t\tbuffer:    make([]byte, 1024),\n\t\tcloseChan: make(chan struct{}),\n\t}\n}\n\nfunc (c *Conn) Close() {\n\tclose(c.closeChan)\n}\n\ntype Engine struct {\n\tpollers []*poller\n}\n\nfunc NewEngine(numPollers int) *Engine {\n\tengine := &Engine{pollers: make([]*poller, numPollers)}\n\tfor i := range engine.pollers {\n\t\tvar err error\n\t\tif i == 0 {\n\t\t\tengine.pollers[i], err = newPoller(engine, true, i)\n\t\t} else {\n\t\t\tengine.pollers[i], err = newPoller(engine, false, i)\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn engine\n}\n\ntype poller struct {\n\tg         *Engine\n\tmux       sync.Mutex\n\tkfd       int\n\tevtfd     int\n\tindex     int\n\tshutdown  bool\n\tlistener  net.Listener\n\tisListener bool\n\tunixSockAddr string\n\tReadBuffer []byte\n\tpollType   string\n\teventList  []syscall.Kevent_t\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tkfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        kfd,\n\t\tevtfd:      -1,\n\t\tindex:      index,\n\t\tshutdown:   false,\n\t\tisListener: isListener,\n\t\tReadBuffer: make([]byte, 1024),\n\t\tpollType:   \"LISTENER\",\n\t}\n\tif isListener {\n\t\tl, err := net.Listen(\"tcp\", \":8080\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tp.listener = l\n\t\tp.pollType = \"LISTENER\"\n\t} else {\n\t\tp.pollType = \"POLLER\"\n\t}\n\tgo p.start()\n\treturn p, nil\n}\n\nfunc (p *poller) start() {\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tc := NewConn(conn.File().Fd())\n\t\tp.addConn(c)\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tfor !p.shutdown {\n\t\tn, evs, err := syscall.Kevent(p.kfd, nil, nil, nil)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tp.readWrite(&evs[i])\n\t\t}\n\t}\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tp.mux.Lock()\n\tdefer p.mux.Unlock()\n\terr := syscall.SetNonblock(c.fd, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.eventList = append(p.eventList, syscall.Kevent_t{\n\t\tIdent: uint64(c.fd),\n\t\tFflags: syscall.EV_ADD | syscall.EV_ENABLE | syscall.EVFILT_READ,\n\t})\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\t// Implementation omitted for brevity\n\treturn nil\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\t// Implementation omitted for brevity\n}\n\nfunc (p *poller) trigger() {\n\t// Implementation omitted for brevity\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.eventList = append(p.eventList, syscall.Kevent_t{\n\t\tIdent: uint64(fd),\n\t\tFflags: syscall.EV_ADD | syscall.EV_ENABLE | syscall.EVFILT_READ,\n\t})\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.eventList = append(p.eventList, syscall.Kevent_t{\n\t\tIdent: uint64(fd),\n\t\tFflags: syscall.EV_DELETE | syscall.EVFILT_READ,\n\t})\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.eventList = append(p.eventList, syscall.Kevent_t{\n\t\tIdent: uint64(fd),\n\t\tFflags: syscall.EV_ADD | syscall.EV_ENABLE | syscall.EVFILT_WRITE,\n\t})\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.eventList = append(p.eventList, syscall.Kevent_t{\n\t\tIdent: uint64(fd),\n\t\tFflags: syscall.EV_ADD | syscall.EV_ENABLE | syscall.EVFILT_READ | syscall.EVFILT_WRITE,\n\t})\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tswitch ev.Fflags & syscall.EVFILT_MASK {\n\tcase syscall.EVFILT_READ:\n\t\t// Handle read operation\n\tcase syscall.EVFILT_WRITE:\n\t\t// Handle write operation\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tclose(p.eventList)\n}\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a TCP server in Go that can handle multiple client connections concurrently, with support for both plain TCP and TLS-secured connections. The server should manage connection lifecycles, timeouts, and provide hooks for customizing reader/writer behavior.\n\nStruct Description: The Server struct represents a configurable TCP server that can handle DNS queries (though this could be adapted for other protocols). It manages listener lifecycle, connection pooling, and provides various timeout and security configurations.\n\nFields:\n\nAddr: string - The address to listen on (e.g., \":domain\")\nNet: string - Network type (\"tcp\", \"tcp4\", \"tcp6\", or their TLS variants)\nListener: net.Listener - The active TCP listener\nTLSConfig: *tls.Config - Configuration for TLS connections\nPacketConn: net.PacketConn - UDP connection (not used in TCP mode)\nHandler: Handler - Handler for incoming requests\nUDPSize: int - UDP buffer size\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nIdleTimeout: func() time.Duration - Function returning idle timeout duration\nTsigProvider: TsigProvider - TSIG provider for DNS\nTsigSecret: map[string]string - TSIG secrets\nNotifyStartedFunc: func() - Callback when server starts\nDecorateReader: DecorateReader - Function to decorate the reader\nDecorateWriter: DecorateWriter - Function to decorate the writer\nMaxTCPQueries: int - Maximum queries per connection\nReusePort: bool - Enable SO_REUSEPORT\nReuseAddr: bool - Enable SO_REUSEADDR\nMsgAcceptFunc: MsgAcceptFunc - Function to filter incoming messages\nlock: sync.RWMutex - Mutex for concurrent access protection\nstarted: bool - Server running state\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\nudpPool: sync.Pool - Pool for UDP buffers\n\nMethods:\n\nListenAndServe: () -> error - Starts the server and begins accepting connections\nserveTCP: (net.Listener) -> error - Internal method to serve TCP connections\nserveTCPConn: (*sync.WaitGroup, net.Conn) -> () - Handles an individual TCP connection\nisStarted: () -> bool - Checks if server is running (internal)\ninit: () -> () - Initializes server state (internal)\ngetReadTimeout: () -> time.Duration - Gets current read timeout (internal)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr     string\n\tNet      string\n\tListener net.Listener\n\tTLSConfig *tls.Config\n\tPacketConn net.PacketConn\n\tHandler   Handler\n\tUDPSize int\n\tReadTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout func() time.Duration\n\tTsigProvider TsigProvider\n\tTsigSecret map[string]string\n\tNotifyStartedFunc func()\n\tDecorateReader DecorateReader\n\tDecorateWriter DecorateWriter\n\tMaxTCPQueries int\n\tReusePort bool\n\tReuseAddr bool\n\tMsgAcceptFunc MsgAcceptFunc\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n\tudpPool sync.Pool\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\tcase \"tcp-tls\", \"tcp4-tls\", \"tcp6-tls\":\n\t\tif srv.TLSConfig == nil || (len(srv.TLSConfig.Certificates) == 0 && srv.TLSConfig.GetCertificate == nil) {\n\t\t\treturn errors.New(\"dns: neither Certificates nor GetCertificate set in Config\")\n\t\t}\n\t\tnetwork := strings.TrimSuffix(srv.Net, \"-tls\")\n\t\tl, err := listenTCP(network, addr, srv.ReusePort, srv.ReuseAddr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl = tls.NewListener(l, srv.TLSConfig)\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tif srv.NotifyStartedFunc != nil {\n\t\tsrv.NotifyStartedFunc()\n\t}\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tsigProvider: srv.tsigProvider(), tcp: rw}\n\tif srv.DecorateWriter != nil {\n\t\tw.writer = srv.DecorateWriter(w)\n\t} else {\n\t\tw.writer = w\n\t}\n\n\treader := Reader(defaultReader{srv})\n\tif srv.DecorateReader != nil {\n\t\treader = srv.DecorateReader(reader)\n\t}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Handler interface {\n\tHandle(conn net.Conn)\n}\n\ntype TsigProvider interface {\n\tProvideTSIG(keyName string) ([]byte, error)\n}\n\ntype DecorateReader func(r net.Reader) net.Reader\ntype DecorateWriter func(w net.Writer) net.Writer\ntype MsgAcceptFunc func(msg []byte) bool\n\ntype Server struct {\n\tAddr               string\n\tNet                string\n\tListener           net.Listener\n\tTLSConfig          *tls.Config\n\tPacketConn         net.PacketConn\n\tHandler            Handler\n\tUDPSize            int\n\tReadTimeout        time.Duration\n\tWriteTimeout       time.Duration\n\tIdleTimeout        func() time.Duration\n\tTsigProvider       TsigProvider\n\tTsigSecret         map[string]string\n\tNotifyStartedFunc  func()\n\tDecorateReader     DecorateReader\n\tDecorateWriter     DecorateWriter\n\tMaxTCPQueries      int\n\tReusePort          bool\n\tReuseAddr          bool\n\tMsgAcceptFunc      MsgAcceptFunc\n\tlock               sync.RWMutex\n\tstarted            bool\n\tshutdown           chan struct{}\n\tconns              map[net.Conn]struct{}\n\tudpPool            sync.Pool\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.init()\n\tif err := s.Listen(); err != nil {\n\t\treturn err\n\t}\n\tdefer s.shutdownListener()\n\n\tif s.Net == \"tcp\" || s.Net == \"tcp4\" || s.Net == \"tcp6\" {\n\t\treturn s.serveTCP(s.Listener)\n\t}\n\treturn nil\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.shutdown:\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tgo s.serveTCPConn(nil, conn)\n\t}\n}\n\nfunc (s *Server) serveTCPConn(waitGroup *sync.WaitGroup, conn net.Conn) {\n\tif waitGroup != nil {\n\t\twaitGroup.Add(1)\n\t\tdefer waitGroup.Done()\n\t}\n\tdefer conn.Close()\n\n\treader := conn\n\twriter := conn\n\tif s.DecorateReader != nil {\n\t\treader = s.DecorateReader(reader)\n\t}\n\tif s.DecorateWriter != nil {\n\t\twriter = s.DecorateWriter(writer)\n\t}\n\n\tclient := &client{\n\t\tconn:    conn,\n\t\treader:  reader,\n\t\twriter:  writer,\n\t\thandler: s.Handler,\n\t\tserver:  s,\n\t}\n\n\tclient.serve()\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n\nfunc (s *Server) init() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\ts.shutdown = make(chan struct{})\n\ts.conns = make(map[net.Conn]struct{})\n\ts.started = true\n}\n\nfunc (s *Server) getReadTimeout() time.Duration {\n\treturn s.ReadTimeout\n}\n```"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a TCP echo server in Go that listens for incoming connections on a specified port, reads data from clients, and echoes the same data back to them.\n\nFunction Description: The function implements a simple TCP server that continuously accepts client connections, reads data from each connection, and writes the same data back (echo). It handles network errors appropriately and ensures resources are cleaned up.\n\nInput: None (The port number is hardcoded as \":9000\" in the implementation)\n\nOutput: None (The function runs indefinitely until interrupted, with all output being network communication with clients)",
    "Canonical_solution": "import \"net\"\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfor {\n\t\t\tbs := make([]byte, 1024)\n\t\t\tn, err := conn.Read(bs)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t_, err = conn.Write(bs[:n])\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconn.Close()\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading:\", err.Error())\n\t\t\treturn\n\t\t}\n\t\t_, err = conn.Write(buffer[:n])\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing:\", err.Error())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":9000\")\n\tif err != nil {\n\t\tfmt.Println(\"Error listening:\", err.Error())\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tfmt.Println(\"Listening on :9000...\")\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n```"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a TCP server in Go that can handle multiple client connections concurrently, manage server lifecycle, and track active connections.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client communication, and provides server management capabilities.\n\nFields:\n- Addr: string - The network address to listen on (e.g., \":8080\")\n- Net: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\n- Handler: Handler - Interface for custom request handling (implementation not shown)\n- Listener: net.Listener - The underlying network listener\n- conns: map[net.Conn]struct{} - Track active connections\n- lock: sync.RWMutex - Protects concurrent access to server state\n- started: bool - Indicates if server is running\n- shutdown: chan struct{} - Channel for shutdown signaling\n\nMethods:\n- ListenAndServe() error - Starts the server and begins accepting connections\n- init() - Initializes server resources (internal use)\n- serveTCP(net.Listener) error - Main server loop that accepts connections (internal use)\n- serveTCPConn(*sync.WaitGroup, net.Conn) - Handles individual client connections (internal use)\n- isStarted() bool - Thread-safe check of server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tl, err := net.Listen(srv.Net, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Listener = l\n\tsrv.started = true\n\tunlock()\n\treturn srv.serveTCP(l)\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer func() {\n\t\tsrv.lock.Lock()\n\t\tdelete(srv.conns, rw)\n\t\tsrv.lock.Unlock()\n\t\trw.Close()\n\t\twg.Done()\n\t}()\n\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := rw.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = rw.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc unlockOnce(l sync.Locker) func() {\n\tvar once sync.Once\n\treturn func() { once.Do(l.Unlock) }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"sync\"\n)\n\ntype Handler interface {\n\tHandle(conn net.Conn)\n}\n\ntype Server struct {\n\tAddr     string\n\tNet      string\n\tHandler  Handler\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc NewServer(addr, netType string, handler Handler) *Server {\n\treturn &Server{\n\t\tAddr:     addr,\n\t\tNet:      netType,\n\t\tHandler:  handler,\n\t\tconns:    make(map[net.Conn]struct{}),\n\t\tshutdown: make(chan struct{}),\n\t}\n}\n\nfunc (s *Server) ListenAndServe() error {\n\ts.lock.Lock()\n\tif s.started {\n\t\ts.lock.Unlock()\n\t\treturn ErrServerAlreadyStarted\n\t}\n\tlistener, err := net.Listen(s.Net, s.Addr)\n\tif err != nil {\n\t\ts.lock.Unlock()\n\t\treturn err\n\t}\n\ts.Listener = listener\n\ts.started = true\n\ts.lock.Unlock()\n\n\tgo func() {\n\t\tdefer s.Listener.Close()\n\t\tfor {\n\t\t\tconn, err := s.Listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase <-s.shutdown:\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.serveTCPConn(&sync.WaitGroup{}, conn)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (s *Server) init() {\n\t// Initialization logic here\n}\n\nfunc (s *Server) serveTCP(listener net.Listener) error {\n\t// Main server loop logic here\n\treturn nil\n}\n\nfunc (s *Server) serveTCPConn(wg *sync.WaitGroup, conn net.Conn) {\n\twg.Add(1)\n\tdefer wg.Done()\n\ts.lock.Lock()\n\ts.conns[conn] = struct{}{}\n\ts.lock.Unlock()\n\n\ts.Handler.Handle(conn)\n\n\ts.lock.Lock()\n\tdelete(s.conns, conn)\n\ts.lock.Unlock()\n}\n\nfunc (s *Server) isStarted() bool {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.started\n}\n```"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a TLS server in Go that handles incoming TCP connections, performs TLS handshakes, manages connection timeouts, and processes domain-specific data through channels.\n\nStruct Description: The TLSServer struct represents a TLS-enabled TCP server that handles secure connections, manages connection state, and processes domain-specific data through channels. It includes functionality for accepting connections, handling TLS handshakes, managing timeouts, and shutting down gracefully.\n\nFields:\n- HTTPSServer: *HTTPSServer - Reference to the parent HTTPSServer containing configuration\n- Cache: *cache.Cache - Cache for storing active connections\n- TCPListen: *net.TCPListener - TCP listener for incoming connections\n- Done: chan byte - Channel for signaling server shutdown\n- DomainData: chan DomainData - Channel for sending domain-specific data\n- Error: chan error - Channel for reporting errors\n\nMethods:\n- NewTLSServer(*HTTPSServer) (*TLSServer, error) - Constructor that initializes a new TLSServer instance\n- ListenAndServe() error - Main server loop that handles domain data and errors\n- Shutdown() - Gracefully shuts down the server\n- Accept() - Accepts incoming connections and handles TLS handshakes (spawned as a goroutine)",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tcache \"github.com/patrickmn/go-cache\"\n\t\"github.com/txthinking/zoro\"\n)\n\ntype DomainData struct {\n\tDomain string\n\tData   []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(s *HTTPSServer) (*TLSServer, error) {\n\tl, err := net.ListenTCP(\"tcp\", s.TLSAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TLSServer{\n\t\tHTTPSServer: s,\n\t\tCache:       cache.New(cache.NoExpiration, cache.NoExpiration),\n\t\tTCPListen:   l,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tdefer close(s.Done)\n\tdefer s.TCPListen.Close()\n\tgo s.Accept()\n\tfor {\n\t\tselect {\n\t\tcase d := <-s.DomainData:\n\t\t\ti, ok := s.Cache.Get(\"domain:\" + d.Domain)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc := i.(*net.TCPConn)\n\t\t\tif err := c.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, err := c.Write(d.Data); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tselect {\n\tcase <-s.Done:\n\t\treturn\n\tcase s.Error <- nil:\n\t}\n}\n\nfunc (s *TLSServer) Accept() {\n\tfor {\n\t\tc1, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-s.Done:\n\t\t\t\treturn\n\t\t\tcase s.Error <- err:\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif s.HTTPSServer.TLSTimeout != 0 {\n\t\t\tif err := c1.SetKeepAlivePeriod(time.Duration(s.HTTPSServer.TLSTimeout) * time.Second); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\tif err := c1.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\tc1.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\ttc := tls.Server(c1, s.HTTPSServer.TLSConfig)\n\t\tif err := tc.Handshake(); err != nil {\n\t\t\tc1.Close()\n\t\t\tcontinue\n\t\t}\n\t\tcs := tc.ConnectionState()\n\t\tif cs.ServerName == \"\" {\n\t\t\tlog.Println(tc.RemoteAddr().String() + \" no SNI\")\n\t\t\ttc.Close()\n\t\t\tcontinue\n\t\t}\n\t\ts.Cache.Set(tc.RemoteAddr().String(), tc, cache.DefaultExpiration)\n\t\tgo func(tc *tls.Conn) {\n\t\t\tdefer func() {\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x02}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t\ts.Cache.Delete(tc.RemoteAddr().String())\n\t\t\t\ttc.Close()\n\t\t\t}()\n\t\t\tvar bf [1024 * 2]byte\n\t\t\tfor {\n\t\t\t\tif s.HTTPSServer.TLSDeadline != 0 {\n\t\t\t\t\tif err := tc.SetDeadline(time.Now().Add(time.Duration(s.HTTPSServer.TLSDeadline) * time.Second)); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti, err := tc.Read(bf[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp := &zoro.TCPPacket{\n\t\t\t\t\tAddress: tc.RemoteAddr().String(),\n\t\t\t\t\tData:    bf[0:i],\n\t\t\t\t}\n\t\t\t\tb, err := proto.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-s.Done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase s.Error <- err:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbb := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(bb, uint16(len(b)))\n\t\t\t\td := DomainData{\n\t\t\t\t\tDomain: strings.TrimSuffix(cs.ServerName, \".\"+s.HTTPSServer.Domain),\n\t\t\t\t\tData:   append(append([]byte{0x01}, bb...), b...),\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-s.Done:\n\t\t\t\t\treturn\n\t\t\t\tcase s.DomainData <- d:\n\t\t\t\t}\n\t\t\t}\n\t\t}(tc)\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/patrickmn/go-cache\"\n)\n\ntype DomainData struct {\n\tDomain   string\n\tData     []byte\n\tResponse []byte\n}\n\ntype TLSServer struct {\n\tHTTPSServer *HTTPSServer\n\tCache       *cache.Cache\n\tTCPListen   *net.TCPListener\n\tDone        chan byte\n\tDomainData  chan DomainData\n\tError       chan error\n}\n\nfunc NewTLSServer(httpServer *HTTPSServer) (*TLSServer, error) {\n\tlistener, err := net.ListenTCP(\"tcp\", \":443\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tserver := &TLSServer{\n\t\tHTTPSServer: httpServer,\n\t\tCache:       cache.New(5*time.Minute, 10*time.Minute),\n\t\tTCPListen:   listener,\n\t\tDone:        make(chan byte),\n\t\tDomainData:  make(chan DomainData),\n\t\tError:       make(chan error),\n\t}\n\tgo server.Accept()\n\treturn server, nil\n}\n\nfunc (s *TLSServer) ListenAndServe() error {\n\tfor {\n\t\tselect {\n\t\tcase <-s.Done:\n\t\t\treturn nil\n\t\tcase data := <-s.DomainData:\n\t\t\ts.processDomainData(data)\n\t\tcase err := <-s.Error:\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *TLSServer) Shutdown() {\n\tclose(s.Done)\n}\n\nfunc (s *TLSServer) Accept() {\n\tfor {\n\t\tconn, err := s.TCPListen.AcceptTCP()\n\t\tif err != nil {\n\t\t\ts.Error <- err\n\t\t\tcontinue\n\t\t}\n\t\tgo s.handleConnection(conn)\n\t}\n}\n\nfunc (s *TLSServer) handleConnection(conn *net.TCPConn) {\n\tdefer conn.Close()\n\ttlsConfig := &tls.Config{InsecureSkipVerify: true}\n\ttlsConn, err := tls.Server(conn, tlsConfig).Handshake()\n\tif err != nil {\n\t\ts.Error <- err\n\t\treturn\n\t}\n\t// Handle connection after successful TLS handshake\n}\n\nfunc (s *TLSServer) processDomainData(data DomainData) {\n\t// Process domain-specific data here\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement an HTTP transport struct for sending tracing spans to a collector using Thrift serialization and HTTP protocol.\n\nStruct Description: HTTPTransport is a struct that handles batching and sending tracing spans to a remote collector via HTTP. It supports basic authentication and custom HTTP client configuration.\n\nFields:\n- logger: jaeger.Logger - Logger for reporting errors and debug information\n- url: string - The collector endpoint URL\n- client: *http.Client - Custom HTTP client for making requests\n- batchSize: int - Maximum number of spans to batch before flushing\n- batch: []*zipkincore.Span - Current batch of spans waiting to be sent\n- httpCredentials: *HTTPBasicAuthCredentials - Optional basic auth credentials\n\nMethods:\n- NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) - Constructor that creates a new HTTPTransport with default values and applies options\n- Append(span *jaeger.Span) (int, error) - Adds a span to the current batch, flushes if batch size is reached\n- Flush() (int, error) - Sends all batched spans to the collector and resets the batch\n- Close() error - Cleanup method (currently no-op)\n- send(spans []*zipkincore.Span) error - Internal method that serializes and sends spans via HTTP POST\n- httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) - Helper method that serializes spans using Thrift protocol\n\nAdditional Struct:\n- HTTPBasicAuthCredentials: struct - Holds basic authentication credentials\n  Fields:\n  - username: string - Basic auth username\n  - password: string - Basic auth password",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tc := &HTTPTransport{\n\t\tlogger:    log.NullLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{Timeout: defaultHTTPTimeout},\n\t\tbatchSize: 100,\n\t\tbatch:     []*zipkincore.Span{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(c)\n\t}\n\treturn c, nil\n}\n\nfunc (c *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzSpan := jaeger.BuildZipkinThrift(span)\n\tc.batch = append(c.batch, zSpan)\n\tif len(c.batch) >= c.batchSize {\n\t\treturn c.Flush()\n\t}\n\treturn 0, nil\n}\n\nfunc (c *HTTPTransport) Flush() (int, error) {\n\tcount := len(c.batch)\n\tif count == 0 {\n\t\treturn 0, nil\n\t}\n\terr := c.send(c.batch)\n\tc.batch = c.batch[:0]\n\treturn count, err\n}\n\nfunc (c *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (c *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", c.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif c.httpCredentials != nil {\n\t\treq.SetBasicAuth(c.httpCredentials.username, c.httpCredentials.password)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read response from collector: %s\", err)\n\t}\n\n\tif resp.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"error from collector: code=%d body=%q\", resp.StatusCode, string(respBytes))\n\t}\n\n\treturn nil\n}\n\nfunc httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tt := thrift.NewTMemoryBuffer()\n\tp := thrift.NewTBinaryProtocolTransport(t)\n\tctx := context.Background()\n\tif err := p.WriteListBegin(ctx, thrift.STRUCT, len(spans)); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range spans {\n\t\tif err := s.Write(ctx, p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif err := p.WriteListEnd(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn t.Buffer, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/jaegertracing/jaeger-client-go\"\n\t\"github.com/jaegertracing/jaeger-client-go/model/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger       jaeger.Logger\n\turl          string\n\tclient       *http.Client\n\tbatchSize    int\n\tbatch        []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tt := &HTTPTransport{\n\t\turl:      url,\n\t\tclient:   &http.Client{Timeout: 5 * time.Second},\n\t\tbatchSize: 100,\n\t}\n\tfor _, option := range options {\n\t\tif err := option(t); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t, nil\n}\n\nfunc (t *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tt.batch = append(t.batch, span.ToThrift())\n\tif len(t.batch) >= t.batchSize {\n\t\treturn t.Flush()\n\t}\n\treturn len(t.batch), nil\n}\n\nfunc (t *HTTPTransport) Flush() (int, error) {\n\tif len(t.batch) == 0 {\n\t\treturn 0, nil\n\t}\n\terr := t.send(t.batch)\n\tt.batch = make([]*zipkincore.Span, 0, t.batchSize)\n\treturn len(t.batch), err\n}\n\nfunc (t *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (t *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbuf, err := t.httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", t.url, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\tif t.httpCredentials != nil {\n\t\tauth := base64.StdEncoding.EncodeToString([]byte(t.httpCredentials.username + \":\" + t.httpCredentials.password))\n\t\treq.Header.Set(\"Authorization\", \"Basic \"+auth)\n\t}\n\tresp, err := t.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\treturn nil\n}\n\nfunc (t *HTTPTransport) httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tout := thrift.NewTMemoryBuffer()\n\tprotocolFactory := thrift.NewTBinaryProtocolFactoryDefault()\n\twriter := protocolFactory.GetProtocol(out)\n\tif err := zipkincore.WriteBatch(writer, spans); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\ntype HTTPOption func(*HTTPTransport) error\n\nfunc WithLogger(logger jaeger.Logger) HTTPOption {\n\treturn func(t *HTTPTransport) error {\n\t\tt.logger = logger\n\t\treturn nil\n\t}\n}\n\nfunc WithClient(client *http.Client) HTTPOption {\n\treturn func(t *HTTPTransport) error {\n\t\tt.client = client\n\t\treturn nil\n\t}\n}\n\nfunc WithBatchSize(size int) HTTPOption {\n\treturn func(t *HTTPTransport) error {\n\t\tt.batchSize = size\n\t\treturn nil\n\t}\n}\n\nfunc WithBasicAuth(username, password string) HTTPOption {\n\treturn func(t *HTTPTransport) error {\n\t\tt.httpCredentials = &HTTPBasicAuthCredentials{\n\t\t\tusername: username,\n\t\t\tpassword: password,\n\t\t}\n\t\treturn nil\n\t}\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both query and write operations with configurable connection settings, authentication, and request parameters.\n\nStruct Description: The Client struct represents an InfluxDB client with configurable connection settings and methods for executing queries and writing data points.\n\nFields:\n\nurl: url.URL - Base URL of the InfluxDB server\nunixSocket: string - Path to Unix domain socket for connection (alternative to TCP)\nusername: string - Username for basic authentication\npassword: string - Password for basic authentication\nhttpClient: *http.Client - Custom HTTP client with configured transport and timeout\nuserAgent: string - User agent string for HTTP requests\nprecision: string - Default precision for timestamps in queries/writes\n\nMethods:\n\nNewClient: [Name](Config) -> (*Client, error) - Creates a new Client instance with the provided configuration, setting up TLS, proxy, and Unix socket options as needed.\n\nQueryContext: [Name](context.Context, Query) -> (*Response, error) - Executes a query against the InfluxDB server with context support, handling both regular and chunked responses.\n\nWrite: [Name](BatchPoints) -> (*Response, error) - Writes a batch of points to the InfluxDB server, handling serialization and request configuration.\n\nThe Client provides methods for both querying and writing data to InfluxDB with support for:\n- Custom HTTP client configuration (timeouts, TLS, proxies)\n- Unix socket connections\n- Basic authentication\n- Chunked query responses\n- Custom precision for timestamps\n- Context-aware operations\n- Error handling for HTTP and InfluxDB-specific errors",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tunixSocket string\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := new(tls.Config)\n\tif c.TLS != nil {\n\t\ttlsConfig = c.TLS.Clone()\n\t}\n\ttlsConfig.InsecureSkipVerify = c.UnsafeSsl\n\n\ttr := &http.Transport{\n\t\tProxy:           c.Proxy,\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tif c.UnixSocket != \"\" {\n\t\ttr.DisableCompression = true\n\t\ttr.DialContext = func(_ context.Context, _, _ string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", c.UnixSocket)\n\t\t}\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tunixSocket: c.UnixSocket,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"query\")\n\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.RetentionPolicy != \"\" {\n\t\tvalues.Set(\"rp\", q.RetentionPolicy)\n\t}\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif q.NodeID > 0 {\n\t\tvalues.Set(\"node_id\", strconv.Itoa(q.NodeID))\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"POST\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = path.Join(u.Path, \"write\")\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Config struct {\n\tURL          string\n\tUnixSocket   string\n\tUsername     string\n\tPassword     string\n\tTLSConfig    *tls.Config\n\tProxyURL     string\n\tTimeout      time.Duration\n\tUserAgent    string\n\tPrecision    string\n}\n\ntype Client struct {\n\turl         *url.URL\n\tunixSocket  string\n\tusername    string\n\tpassword    string\n\thttpClient  *http.Client\n\tuserAgent   string\n\tprecision   string\n}\n\nfunc NewClient(cfg Config) (*Client, error) {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: cfg.TLSConfig,\n\t\t\tProxy:           http.ProxyURL(url.Parse(cfg.ProxyURL)),\n\t\t},\n\t\tTimeout: cfg.Timeout,\n\t}\n\n\treturn &Client{\n\t\turl:         url.Parse(cfg.URL),\n\t\tunixSocket:  cfg.UnixSocket,\n\t\tusername:    cfg.Username,\n\t\tpassword:    cfg.Password,\n\t\thttpClient:  client,\n\t\tuserAgent:   cfg.UserAgent,\n\t\tprecision:   cfg.Precision,\n\t}, nil\n}\n\nfunc (c *Client) QueryContext(ctx context.Context, q Query) (*Response, error) {\n\t// Implementation here\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\t// Implementation here\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets IP TOS (Type of Service) and TTL (Time To Live) values for IPv4 connections, and sends a greeting message to the client.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For each IPv4 connection, it configures the TOS and TTL values using the ipv4 package. It then sends a greeting message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to \"0.0.0.0:1024\" by default)\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving connections)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"0.0.0.0:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {\n\t\t\t\tp := ipv4.NewConn(c)\n\t\t\t\tif err := p.SetTOS(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetTTL(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv4\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\ttcpConn, ok := conn.(*net.TCPConn)\n\tif !ok {\n\t\tfmt.Println(\"Error casting to TCPConn\")\n\t\treturn\n\t}\n\n\tipConn, err := tcpConn.IP()\n\tif err != nil {\n\t\tfmt.Println(\"Error getting IP address:\", err)\n\t\treturn\n\t}\n\n\ttos := 0x10 // Example TOS value\n\tttl := 64   // Example TTL value\n\terr = ipConn.SetTOS(tos)\n\tif err != nil {\n\t\tfmt.Println(\"Error setting TOS:\", err)\n\t\treturn\n\t}\n\terr = ipConn.SetTTL(ttl)\n\tif err != nil {\n\t\tfmt.Println(\"Error setting TTL:\", err)\n\t\treturn\n\t}\n\n\tmessage := \"HELLO-R-U-THERE-ACK\"\n\t_, err = conn.Write([]byte(message))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending message:\", err)\n\t\treturn\n\t}\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error listening:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"Server started on :1024\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}\n```"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, sets specific IPv6 traffic class and hop limit for IPv6 connections, and sends an acknowledgment message to each client.\n\nFunction Description: The function establishes a TCP server on port 1024 that continuously accepts client connections. For each connection, it checks if the client is using IPv6 and configures specific network parameters (traffic class and hop limit) if so. It then sends a fixed acknowledgment message (\"HELLO-R-U-THERE-ACK\") to the client before closing the connection. Each client connection is handled in a separate goroutine.\n\nInput: None (The function takes no explicit parameters but binds to port 1024 by default)\n\nOutput: None (The function doesn't return any value but maintains persistent network operations and may log fatal errors)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\ttcpConn.SetWriteBuffer(1024)\n\t\ttcpConn.SetReadBuffer(1024)\n\t}\n\tconn.Write([]byte(\"HELLO-R-U-THERE-ACK\"))\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err.Error())\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n```"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a TCP server in Go that listens for incoming connections, handles IPv6 traffic with specific traffic class and hop limit settings, and sends an acknowledgment message to connected clients.\n\nFunction Description: The function sets up a TCP server on port 1024 that accepts incoming connections. For IPv6 clients, it configures specific network parameters (traffic class and hop limit) before sending an acknowledgment message. The server runs indefinitely, handling each connection in a separate goroutine.\n\nInput: None (The function takes no explicit parameters; it binds to a fixed port \"[::]:1024\")\n\nOutput: None (The function doesn't return any value; it runs indefinitely serving clients)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/ipv6\"\n)\nfunc ExampleConn_markingTCP() {\n\tln, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tfor {\n\t\tc, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo func(c net.Conn) {\n\t\t\tdefer c.Close()\n\t\t\tif c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {\n\t\t\t\tp := ipv6.NewConn(c)\n\t\t\t\tif err := p.SetTrafficClass(0x28); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := p.SetHopLimit(128); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := c.Write([]byte(\"HELLO-R-U-THERE-ACK\")); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(c)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 109,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tfmt.Fprintf(conn, \"Acknowledgment received\")\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"[::]:1024\")\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t\treturn\n\t}\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n```"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Create a gRPC client in Go that communicates with a Unix domain socket server for various deployment operations.\n\nStruct Description: The DeployClient struct represents a gRPC client that connects to a deployment agent server via Unix domain socket and provides methods for different deployment operations.\n\nFields:\nsocketPath: string - The filesystem path to the Unix domain socket for connecting to the gRPC server\n\nMethods:\nNewDeployClient: [Name](socketPath string) -> *DeployClient - Creates a new DeployClient instance with the specified socket path\nDeployGuestFs: [Name](ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) -> (*deployapi.DeployGuestFsResponse, error) - Deploys guest filesystem\nResizeFs: [Name](ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Resizes filesystem\nFormatFs: [Name](ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Formats filesystem\nSaveToGlance: [Name](ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) -> (*deployapi.SaveToGlanceResponse, error) - Saves image to Glance\nProbeImageInfo: [Name](ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) -> (*deployapi.ImageInfo, error) - Probes image information\nConnectEsxiDisks: [Name](ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) -> (*deployapi.EsxiDisksConnectionInfo, error) - Connects ESXi disks\nDisconnectEsxiDisks: [Name](ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) -> (*deployapi.Empty, error) - Disconnects ESXi disks",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdeployapi \"yunion.io/x/onecloud/pkg/hostman/hostdeployer/apis\"\n)\n\ntype DeployClient struct {\n\tsocketPath string\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\treturn &DeployClient{socketPath}\n}\n\nfunc grcpDialWithUnixSocket(ctx context.Context, socketPath string) (*grpc.ClientConn, error) {\n\treturn grpc.DialContext(ctx, socketPath, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(time.Second*3),\n\t\tgrpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(\"unix\", addr, timeout)\n\t\t}),\n\t)\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\tret, err := client.DeployGuestFs(ctx, in, opts...)\n\treturn ret, err\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoPramas, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(\n\tctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption,\n) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(\n\tctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption,\n) (*deployapi.Empty, error) {\n\tconn, err := grcpDialWithUnixSocket(ctx, c.socketPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := deployapi.NewDeployAgentClient(conn)\n\treturn client.DisconnectEsxiDisks(ctx, in, opts...)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/yourusername/deployapi\"\n)\n\ntype DeployClient struct {\n\tconn *grpc.ClientConn\n}\n\nfunc NewDeployClient(socketPath string) *DeployClient {\n\tconn, err := grpc.Dial(socketPath, grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\treturn &DeployClient{conn: conn}\n}\n\nfunc (c *DeployClient) DeployGuestFs(ctx context.Context, in *deployapi.DeployParams, opts ...grpc.CallOption) (*deployapi.DeployGuestFsResponse, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.DeployGuestFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ResizeFs(ctx context.Context, in *deployapi.ResizeFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.ResizeFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) FormatFs(ctx context.Context, in *deployapi.FormatFsParams, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.FormatFs(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) SaveToGlance(ctx context.Context, in *deployapi.SaveToGlanceParams, opts ...grpc.CallOption) (*deployapi.SaveToGlanceResponse, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.SaveToGlance(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ProbeImageInfo(ctx context.Context, in *deployapi.ProbeImageInfoParams, opts ...grpc.CallOption) (*deployapi.ImageInfo, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.ProbeImageInfo(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) ConnectEsxiDisks(ctx context.Context, in *deployapi.ConnectEsxiDisksParams, opts ...grpc.CallOption) (*deployapi.EsxiDisksConnectionInfo, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.ConnectEsxiDisks(ctx, in, opts...)\n}\n\nfunc (c *DeployClient) DisconnectEsxiDisks(ctx context.Context, in *deployapi.EsxiDisksConnectionInfo, opts ...grpc.CallOption) (*deployapi.Empty, error) {\n\tclient := deployapi.NewDeploymentServiceClient(c.conn)\n\treturn client.DisconnectEsxiDisks(ctx, in, opts...)\n}\n```"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a function to register a mapper with a gRPC server using the Device Management Interface (DMI) API. The function should establish a connection to the server, send a registration request, and return the list of devices and device models provided by the server.\n\nFunction Description: The `RegisterMapper` function connects to a gRPC server using Unix domain socket, sends a mapper registration request with the provided configuration, and returns the device and device model lists from the server response. It handles connection establishment, timeout context, and proper cleanup of resources.\n\nInput: \n- `withData` [bool]: A flag indicating whether to include data in the registration request.\n\nOutput:\n- `[]*dmiapi.Device`: A slice of pointers to Device objects returned by the server.\n- `[]*dmiapi.DeviceModel`: A slice of pointers to DeviceModel objects returned by the server.\n- `error`: An error object if any step fails, nil otherwise.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tdmiapi \"github.com/kubeedge/api/apis/dmi/v1beta1\"\n\t\"github.com/kubeedge/mapper-framework/pkg/common\"\n\t\"github.com/kubeedge/mapper-framework/pkg/config\"\n)\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n\tcfg := config.Cfg()\n\n\tconn, err := grpc.Dial(cfg.Common.EdgeCoreSock,\n\t\tgrpc.WithInsecure(),\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithContextDialer(\n\t\t\tfunc(ctx context.Context, s string) (net.Conn, error) {\n\t\t\t\tunixAddress, err := net.ResolveUnixAddr(\"unix\", cfg.Common.EdgeCoreSock)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn net.DialUnix(\"unix\", nil, unixAddress)\n\t\t\t},\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tc := dmiapi.NewDeviceManagerServiceClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tresp, err := c.MapperRegister(ctx, &dmiapi.MapperRegisterRequest{\n\t\tWithData: withData,\n\t\tMapper: &dmiapi.MapperInfo{\n\t\t\tName:       cfg.Common.Name,\n\t\t\tVersion:    cfg.Common.Version,\n\t\t\tApiVersion: cfg.Common.APIVersion,\n\t\t\tProtocol:   cfg.Common.Protocol,\n\t\t\tAddress:    []byte(cfg.GrpcServer.SocketPath),\n\t\t\tState:      common.DeviceStatusOK,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn resp.DeviceList, resp.ModelList, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\nfunc RegisterMapper(withData bool) ([]*dmiapi.Device, []*dmiapi.DeviceModel, error) {\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    conn, err := grpc.DialContext(ctx, \"/var/run/dmidev.sock\", grpc.WithInsecure())\n    if err != nil {\n        return nil, nil, fmt.Errorf(\"failed to connect to server: %w\", err)\n    }\n    defer conn.Close()\n\n    client := dmiapi.NewDeviceManagerClient(conn)\n\n    req := &dmiapi.RegisterRequest{\n        WithData: withData,\n    }\n\n    resp, err := client.Register(ctx, req)\n    if err != nil {\n        return nil, nil, fmt.Errorf(\"failed to register mapper: %w\", err)\n    }\n\n    return resp.Devices, resp.DeviceModels, nil\n}\n```"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a function that establishes a secure or insecure gRPC client connection to a server and returns a client instance for making RPC calls.\n\nFunction Description: The function `createGRPCClient` establishes a connection to a gRPC server using the provided server address and security options. It supports both TLS-secured connections (with optional certificate verification) and insecure connections. The function returns a client instance that can be used to make RPC calls to the server.\n\nInput:\n- `serverAddr` (string): The address of the gRPC server in \"host:port\" format\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string, optional): Path to the CA certificate file for TLS verification (required if useTLS is true)\n- `serverHostOverride` (string, optional): Server name used for TLS hostname verification\n\nOutput:\n- `pb.RouteGuideClient`: A gRPC client instance for making RPC calls\n- `*grpc.ClientConn`: The established gRPC connection (should be closed by the caller when done)\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n\t\"google.golang.org/grpc/grpclog\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tvar sn string\n\t\tif *serverHostOverride != \"\" {\n\t\t\tsn = *serverHostOverride\n\t\t}\n\t\tvar creds credentials.TransportAuthenticator\n\t\tif *caFile != \"\" {\n\t\t\tvar err error\n\t\t\tcreds, err = credentials.NewClientTLSFromFile(*caFile, sn)\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Fatalf(\"Failed to create TLS credentials %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tcreds = credentials.NewClientTLSFromCert(nil, sn)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\tconn, err := grpc.Dial(*serverAddr, opts...)\n\tif err != nil {\n\t\tgrpclog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"path/to/routeguidepb\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, *grpc.ClientConn, error) {\n\tvar opts []grpc.DialOption\n\tif useTLS {\n\t\ttlsConfig := &tls.Config{\n\t\t\tInsecureSkipVerify: !useTLS,\n\t\t}\n\t\tif caFile != \"\" {\n\t\t\tcertPool := x509.NewCertPool()\n\t\t\tdata, err := ioutil.ReadFile(caFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to read CA cert: %v\", err)\n\t\t\t}\n\t\t\tif !certPool.AppendCertsFromPEM(data) {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to append CA cert\")\n\t\t\t}\n\t\t\ttlsConfig.RootCAs = certPool\n\t\t}\n\t\tif serverHostOverride != \"\" {\n\t\t\ttlsConfig.ServerName = serverHostOverride\n\t\t}\n\t\tcreds := credentials.NewTLS(tlsConfig)\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithInsecure())\n\t}\n\n\tconn, err := grpc.DialContext(context.Background(), serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\n\tclient := pb.NewRouteGuideClient(conn)\n\treturn client, conn, nil\n}\n```"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a function that connects to a gRPC server, retrieves pod information using the HyperD Public API, and returns the response.\n\nFunction Description: The function establishes an insecure connection to a gRPC server at the specified address, creates a Public API client, sends a PodInfoRequest for a specific pod ID, and returns the pod information response. The connection is automatically closed when the function completes.\n\nInput: \n- server string: The address of the gRPC server (e.g., \"localhost:50051\")\n- podID string: The ID of the pod to query (e.g., \"pod-zpIOTSAjmM\")\n\nOutput:\n- *types.PodInfoResponse: The response containing pod information\n- error: Any error that occurred during the operation",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/hyperhq/hyperd/types\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\nfunc main() {\n\tconn, err := grpc.Dial(server, grpc.WithInsecure())\n\tif err != nil {\n\t\tfmt.Printf(\"Connect server error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tclient := types.NewPublicAPIClient(conn)\n\trequest := types.PodInfoRequest{\n\t\tPodID: \"pod-zpIOTSAjmM\",\n\t}\n\tresponse, err := client.PodInfo(context.Background(), &request)\n\tif err != nil {\n\t\tfmt.Printf(\"Get PodInfo error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Got response: %v\", response)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\tpb \"path/to/hyperd/public/api\" // Replace with the actual package path\n)\n\nfunc GetPodInfo(server, podID string) (*pb.PodInfoResponse, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tconn, err := grpc.Dial(server, grpc.WithInsecure())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewPublicAPIClient(conn)\n\treq := &pb.PodInfoRequest{PodId: podID}\n\n\tresponse, err := client.GetPodInfo(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\nfunc main() {\n\tserver := \"localhost:50051\"\n\tpodID := \"pod-zpIOTSAjmM\"\n\n\tresponse, err := GetPodInfo(server, podID)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get pod info: %v\", err)\n\t}\n\n\tlog.Printf(\"Pod Info: %+v\", response)\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a function to send synchronous HTTP requests with custom configurations including headers, authentication, and transport settings.\n\nFunction Description: The function SendWebRequestSync sends an HTTP request with customizable method, headers, body, and authentication. It handles the response, checks for success status codes, and properly manages resources. The function uses a pre-configured HTTP client with custom transport settings for timeout and TLS configuration.\n\nInput:\n- ctx (context.Context): Context for request cancellation and timeouts\n- webhook (*monitor.SendWebhookSync): Pointer to a struct containing request parameters including:\n  - HttpMethod (string): HTTP method (GET, POST, etc.)\n  - Url (string): Target URL\n  - Body (string): Request body content\n  - ContentType (string): Content-Type header value\n  - User (string): Username for basic auth\n  - Password (string): Password for basic auth\n  - HttpHeader (map[string]string): Additional HTTP headers\n\nOutput:\n- error: Returns nil on success (2xx status code), or an error describing the failure (non-2xx status code or transport error)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/context/ctxhttp\"\n\t\"moul.io/http2curl/v2\"\n\n\t\"yunion.io/x/log\"\n\n\t\"yunion.io/x/onecloud/pkg/apis/monitor\"\n)\nvar netTransport = &http.Transport{\n\tTLSClientConfig: &tls.Config{\n\t\tRenegotiation: tls.RenegotiateFreelyAsClient,\n\t},\n\tProxy: http.ProxyFromEnvironment,\n\tDialContext: (&net.Dialer{\n\t\tTimeout: 30 * time.Second,\n\t}).DialContext,\n\tTLSHandshakeTimeout: 5 * time.Second,\n}\nvar netClient = &http.Client{\n\tTimeout:   time.Second * 30,\n\tTransport: netTransport,\n}\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tif webhook.HttpMethod == \"\" {\n\t\twebhook.HttpMethod = http.MethodPost\n\t}\n\n\trequest, err := http.NewRequest(webhook.HttpMethod, webhook.Url, bytes.NewReader([]byte(webhook.Body)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif webhook.ContentType == \"\" {\n\t\twebhook.ContentType = \"application/json\"\n\t}\n\n\trequest.Header.Add(\"Content-Type\", webhook.ContentType)\n\trequest.Header.Add(\"User-Agent\", \"OneCloud Monitor\")\n\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\trequest.Header.Add(\"Authorization\", GetBasicAuthHeader(webhook.User, webhook.Password))\n\t}\n\n\tfor k, v := range webhook.HttpHeader {\n\t\trequest.Header.Set(k, v)\n\t}\n\n\tcurlCmd, _ := http2curl.GetCurlCommand(request)\n\tlog.Debugf(\"webhook curl: %s\", curlCmd)\n\n\tresp, err := ctxhttp.Do(ctx, netClient, request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 == 2 {\n\t\tif _, err := io.Copy(ioutil.Discard, resp.Body); err != nil {\n\t\t\tlog.Errorf(\"Failed to copy resp.Body to ioutil.Discard: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Errorf(\"Webhook failed statuscode: %s, body: %s\", resp.Status, string(body))\n\treturn fmt.Errorf(\"Webhook response status %v\", resp.Status)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/your/package/monitor\"\n)\n\nfunc SendWebRequestSync(ctx context.Context, webhook *monitor.SendWebhookSync) error {\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t\tTimeout: 10 * time.Second,\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, webhook.HttpMethod, webhook.Url, strings.NewReader(webhook.Body))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", webhook.ContentType)\n\tfor key, value := range webhook.HttpHeader {\n\t\treq.Header.Set(key, value)\n\t}\n\tif webhook.User != \"\" && webhook.Password != \"\" {\n\t\treq.SetBasicAuth(webhook.User, webhook.Password)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn fmt.Errorf(\"HTTP request failed with status code %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a function that establishes a gRPC client connection to a server, with optional TLS security, and returns a client instance for a specified service.\n\nFunction Description: The function `createGRPCClient` initializes a gRPC client connection to a specified server address. It supports both secure (TLS) and insecure connections based on input parameters. After establishing the connection, it creates and returns a client instance for the RouteGuide service.\n\nInput: \n- `serverAddr` (string): The address of the gRPC server to connect to\n- `useTLS` (bool): Flag indicating whether to use TLS for the connection\n- `caFile` (string): Path to the CA certificate file (required if useTLS is true)\n- `serverHostOverride` (string): Server name used for TLS host verification\n\nOutput:\n- `pb.RouteGuideClient`: The generated gRPC client instance for the RouteGuide service\n- `error`: Any error that occurred during connection establishment",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"flag\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/examples/data\"\n\tpb \"google.golang.org/grpc/examples/route_guide/routeguide\"\n)\nfunc main() {\n\tflag.Parse()\n\tvar opts []grpc.DialOption\n\tif *tls {\n\t\tif *caFile == \"\" {\n\t\t\t*caFile = data.Path(\"x509/ca_cert.pem\")\n\t\t}\n\t\tcreds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to create TLS credentials: %v\", err)\n\t\t}\n\t\topts = append(opts, grpc.WithTransportCredentials(creds))\n\t} else {\n\t\topts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t}\n\n\tconn, err := grpc.NewClient(*serverAddr, opts...)\n\tif err != nil {\n\t\tlog.Fatalf(\"fail to dial: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewRouteGuideClient(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"log\"\n\t\"time\"\n\n\tpb \"path/to/routeguide\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc createGRPCClient(serverAddr string, useTLS bool, caFile string, serverHostOverride string) (pb.RouteGuideClient, error) {\n\tvar creds credentials.TransportCredentials\n\tif useTLS {\n\t\tcert, err := tls.LoadX509KeyPair(caFile, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcreds = credentials.NewClientTLSFromCert(cert, serverHostOverride)\n\t} else {\n\t\tcreds = insecure.NewCredentials()\n\t}\n\n\tconn, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(creds), grpc.WithBlock(), grpc.WithTimeout(time.Second))\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\treturn pb.NewRouteGuideClient(conn), nil\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Implement a Go struct that interacts with the Pinecone vector database to upsert embeddings and retrieve similar vectors using HTTP requests with custom headers.\n\nStruct Description: The Pinecone struct represents a client for interacting with the Pinecone vector database API. It handles authentication, request construction, and response processing for vector operations.\n\nFields:\nEndpoint: string - The base URL of the Pinecone API endpoint\nApiKey: string - The API key used for authentication with Pinecone\n\nMethods:\nNew: [endpoint string, apiKey string] -> [*Pinecone, error] - Creates a new Pinecone client instance with the given endpoint and API key\n\nUpsertEmbeddings: [embeddings [][]float32, chunks []chunk.Chunk, uuid string] -> [error] - Upserts multiple embeddings into Pinecone in batches, with associated metadata from chunks, under the specified namespace UUID\n\nRetrieve: [questionEmbedding []float32, topK int, uuid string] -> [[]vectordb.QueryMatch, error] - Retrieves the topK most similar vectors to the questionEmbedding from the specified namespace UUID",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/pashpashpash/vault/chunk\"\n\t\"github.com/pashpashpash/vault/vectordb\"\n)\n\ntype Pinecone struct {\n\tEndpoint string\n\tApiKey   string\n}\n\nfunc New(endpoint string, apiKey string) (*Pinecone, error) {\n\treturn &Pinecone{\n\t\tEndpoint: endpoint,\n\t\tApiKey:   apiKey,\n\t}, nil\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []chunk.Chunk, uuid string) error {\n\turl := p.Endpoint + \"/vectors/upsert\"\n\n\tvectors := make([]PineconeVector, len(embeddings))\n\tfor i, embedding := range embeddings {\n\t\tchunk := chunks[i]\n\t\tvectors[i] = PineconeVector{\n\t\t\tID:     fmt.Sprintf(\"id-%d\", i),\n\t\t\tValues: embedding,\n\t\t\tMetadata: map[string]string{\n\t\t\t\t\"file_name\": chunk.Title,\n\t\t\t\t\"start\":     strconv.Itoa(chunk.Start),\n\t\t\t\t\"end\":       strconv.Itoa(chunk.End),\n\t\t\t\t\"title\":     chunk.Title,\n\t\t\t\t\"text\":      chunk.Text,\n\t\t\t},\n\t\t}\n\t}\n\n\tmaxVectorsPerRequest := 100\n\n\tfor i := 0; i < len(vectors); i += maxVectorsPerRequest {\n\t\tend := i + maxVectorsPerRequest\n\t\tif end > len(vectors) {\n\t\t\tend = len(vectors)\n\t\t}\n\n\t\trequestBody, err := json.Marshal(struct {\n\t\t\tVectors   []PineconeVector `json:\"vectors\"`\n\t\t\tNamespace string           `json:\"namespace\"`\n\t\t}{\n\t\t\tVectors:   vectors[i:end],\n\t\t\tNamespace: uuid,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(requestBody))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\t\treturn errors.New(string(body))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([]vectordb.QueryMatch, error) {\n\trequestBody, _ := json.Marshal(PineconeQueryRequest{\n\t\tTopK:            topK,\n\t\tIncludeMetadata: true,\n\t\tNamespace:       uuid,\n\t\tQueries: []PineconeQueryItem{\n\t\t\t{\n\t\t\t\tValues: questionEmbedding,\n\t\t\t},\n\t\t},\n\t})\n\n\tpineconeIndexURL := p.Endpoint + \"/query\"\n\treq, _ := http.NewRequest(\"POST\", pineconeIndexURL, bytes.NewBuffer(requestBody))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tvar pineconeQueryResponse PineconeQueryResponse\n\tjson.Unmarshal(body, &pineconeQueryResponse)\n\n\tif len(pineconeQueryResponse.Results) > 0 {\n\t\treturn pineconeQueryResponse.Results[0].Matches, nil\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage vectordb\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Pinecone struct {\n\tEndpoint string\n\tApiKey   string\n}\n\nfunc New(endpoint string, apiKey string) (*Pinecone, error) {\n\tif endpoint == \"\" || apiKey == \"\" {\n\t\treturn nil, errors.New(\"endpoint and api key cannot be empty\")\n\t}\n\treturn &Pinecone{Endpoint: endpoint, ApiKey: apiKey}, nil\n}\n\ntype EmbeddingRequest struct {\n\tNamespace string       `json:\"namespace\"`\n\tVectors   []VectorItem `json:\"vectors\"`\n}\n\ntype VectorItem struct {\n\tID    string      `json:\"id\"`\n\tVector []float32 `json:\"vector\"`\n\tMetadata interface{} `json:\"metadata,omitempty\"`\n}\n\nfunc (p *Pinecone) UpsertEmbeddings(embeddings [][]float32, chunks []Chunk, uuid string) error {\n\tvectors := make([]VectorItem, len(embeddings))\n\tfor i, emb := range embeddings {\n\t\tvectors[i] = VectorItem{\n\t\t\tID:     fmt.Sprintf(\"%s-%d\", uuid, i),\n\t\t\tVector: emb,\n\t\t\tMetadata: chunks[i],\n\t\t}\n\t}\n\n\treq := EmbeddingRequest{\n\t\tNamespace: uuid,\n\t\tVectors:   vectors,\n\t}\n\n\tjsonData, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\turl := fmt.Sprintf(\"%s/upsert\", p.Endpoint)\n\treqBody := bytes.NewBuffer(jsonData)\n\n\tclient := &http.Client{}\n\treq, err = http.NewRequest(http.MethodPost, url, requestBody)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusAccepted {\n\t\treturn fmt.Errorf(\"upsert failed with status %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n\ntype QueryRequest struct {\n\tNamespace string `json:\"namespace\"`\n\tQuery     float32 `json:\"query\"`\n\tTopK      int     `json:\"topK\"`\n}\n\ntype QueryResponse struct {\n\tResults []QueryMatch `json:\"results\"`\n}\n\ntype QueryMatch struct {\n\tID        string  `json:\"id\"`\n\tScore     float32 `json:\"score\"`\n\tMetadata  interface{} `json:\"metadata,omitempty\"`\n}\n\nfunc (p *Pinecone) Retrieve(questionEmbedding []float32, topK int, uuid string) ([]QueryMatch, error) {\n\tqueryReq := QueryRequest{\n\t\tNamespace: uuid,\n\t\tQuery:     questionEmbedding[0], // Assuming a single value for simplicity\n\t\tTopK:      topK,\n\t}\n\n\tjsonData, err := json.Marshal(queryReq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\turl := fmt.Sprintf(\"%s/query\", p.Endpoint)\n\treqBody := bytes.NewBuffer(jsonData)\n\n\tclient := &http.Client{}\n\treq, err = http.NewRequest(http.MethodPost, url, requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Api-Key\", p.ApiKey)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar queryResp QueryResponse\n\terr = json.NewDecoder(resp.Body).Decode(&queryResp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn queryResp.Results, nil\n}\n```"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: The task involves creating a gRPC probe client in Go that can establish connections to gRPC servers, perform various probe operations (echo, read, write), and collect metrics about the probe results.\n\nStruct Description: The Probe struct represents a gRPC probe client that manages connections to multiple targets, performs probe operations, and tracks results.\n\nFields:\n\nname: [string] - The name of the probe instance\nsrc: [string] - The source identifier for the probe\nopts: [*options.Options] - Configuration options for the probe\nc: [*configpb.ProbeConf] - gRPC probe-specific configuration\nl: [*logger.Logger] - Logger for recording probe events\ndialOpts: [[]grpc.DialOption] - Options for gRPC dialing\ntargets: [[]endpoint.Endpoint] - List of target endpoints to probe\ncancelFuncs: [map[string]context.CancelFunc] - Map of cancel functions for target operations\ntargetsMu: [sync.Mutex] - Mutex for synchronizing access to targets\nresults: [map[string]*probeRunResult] - Map of probe results by target\n\nMethods:\n\nconnectWithRetry: [func(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn] -> [*grpc.ClientConn] - Establishes a gRPC connection to the target with retry logic, using the specified context, target address, message pattern, and result tracker. Returns the established connection or nil if failed.\n\noneTargetLoop: [func(ctx context.Context, tgt string, index int, result *probeRunResult)] -> [None] - Main probe loop for a single target that continuously performs probe operations (echo/read/write) at regular intervals, using the specified context, target address, target index, and result tracker. Manages connection lifecycle and records metrics.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/google/cloudprober/logger\"\n\t\"github.com/google/cloudprober/metrics\"\n\tconfigpb \"github.com/google/cloudprober/probes/grpc/proto\"\n\t\"github.com/google/cloudprober/probes/options\"\n\t\"github.com/google/cloudprober/probes/probeutils\"\n\t\"github.com/google/cloudprober/targets/endpoint\"\n\n\tgrpcprobepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\tservicepb \"github.com/google/cloudprober/servers/grpc/proto\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/alts\"\n\t\"google.golang.org/grpc/credentials/local\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype Probe struct {\n\tname     string\n\tsrc      string\n\topts     *options.Options\n\tc        *configpb.ProbeConf\n\tl        *logger.Logger\n\tdialOpts []grpc.DialOption\n\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\n\tresults map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\tsync.Mutex\n\ttarget        string\n\ttotal         metrics.Int\n\tsuccess       metrics.Int\n\tlatency       metrics.Value\n\tconnectErrors metrics.Int\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tconnectTimeout := p.opts.Timeout\n\tif p.c.GetConnectTimeoutMsec() > 0 {\n\t\tconnectTimeout = time.Duration(p.c.GetConnectTimeoutMsec()) * time.Millisecond\n\t}\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in connect loop.\", msgPattern)\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\t\tconnCtx, cancelFunc := context.WithTimeout(ctx, connectTimeout)\n\n\t\tif uriScheme := p.c.GetUriScheme(); uriScheme != \"\" {\n\t\t\ttgt = uriScheme + tgt\n\t\t}\n\t\tconn, err = grpc.DialContext(connCtx, tgt, p.dialOpts...)\n\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tp.l.Warningf(\"ProbeId(%v) connect error: %v\", msgPattern, err)\n\t\t} else {\n\t\t\tp.l.Infof(\"ProbeId(%v) connection established.\", msgPattern)\n\t\t\tbreak\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.connectErrors.Inc()\n\t\tresult.Unlock()\n\t}\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tmsgPattern := fmt.Sprintf(\"%s,%s%s,%03d\", p.src, p.c.GetUriScheme(), tgt, index)\n\n\tconn := p.connectWithRetry(ctx, tgt, msgPattern, result)\n\tif conn == nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclient := servicepb.NewProberClient(conn)\n\ttimeout := p.opts.Timeout\n\tmethod := p.c.GetMethod()\n\n\tmsgSize := p.c.GetBlobSize()\n\tmsg := make([]byte, msgSize)\n\tprobeutils.PatternPayload(msg, []byte(msgPattern))\n\tticker := time.NewTicker(p.opts.Interval)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tp.l.Warningf(\"ProbeId(%s): context cancelled in request loop.\", msgPattern)\n\t\t\tticker.Stop()\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t}\n\n\t\treqCtx, cancelFunc := context.WithTimeout(ctx, timeout)\n\t\tvar success int64\n\t\tvar delta time.Duration\n\t\tstart := time.Now()\n\t\tvar err error\n\t\tvar peer peer.Peer\n\t\topts := []grpc.CallOption{\n\t\t\tgrpc.WaitForReady(true),\n\t\t\tgrpc.Peer(&peer),\n\t\t}\n\t\tswitch method {\n\t\tcase configpb.ProbeConf_ECHO:\n\t\t\treq := &grpcprobepb.EchoMessage{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.Echo(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_READ:\n\t\t\treq := &grpcprobepb.BlobReadRequest{\n\t\t\t\tSize: proto.Int32(msgSize),\n\t\t\t}\n\t\t\t_, err = client.BlobRead(reqCtx, req, opts...)\n\t\tcase configpb.ProbeConf_WRITE:\n\t\t\treq := &grpcprobepb.BlobWriteRequest{\n\t\t\t\tBlob: []byte(msg),\n\t\t\t}\n\t\t\t_, err = client.BlobWrite(reqCtx, req, opts...)\n\t\tdefault:\n\t\t\tp.l.Criticalf(\"Method %v not implemented\", method)\n\t\t}\n\t\tcancelFunc()\n\t\tif err != nil {\n\t\t\tpeerAddr := \"unknown\"\n\t\t\tif peer.Addr != nil {\n\t\t\t\tpeerAddr = peer.Addr.String()\n\t\t\t}\n\t\t\tp.l.Warningf(\"ProbeId(%s) request failed: %v. ConnState: %v. Peer: %v\", msgPattern, err, conn.GetState(), peerAddr)\n\t\t} else {\n\t\t\tsuccess = 1\n\t\t\tdelta = time.Since(start)\n\t\t}\n\t\tresult.Lock()\n\t\tresult.total.Inc()\n\t\tresult.success.AddInt64(success)\n\t\tresult.latency.AddFloat64(delta.Seconds() / p.opts.LatencyUnit.Seconds())\n\t\tresult.Unlock()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/grpc/grpc-go/credentials/insecure\"\n)\n\ntype Probe struct {\n\tname        string\n\tsrc         string\n\topts        *options.Options\n\tc           *configpb.ProbeConf\n\tl           *logger.Logger\n\tdialOpts    []grpc.DialOption\n\ttargets     []endpoint.Endpoint\n\tcancelFuncs map[string]context.CancelFunc\n\ttargetsMu   sync.Mutex\n\tresults     map[string]*probeRunResult\n}\n\ntype probeRunResult struct {\n\techoResponse string\n\treadData     string\n\twriteSuccess bool\n\tmetrics      Metrics\n}\n\ntype Metrics struct {\n\tConnectAttempts int\n\tConnectSuccess  int\n\tEchoSuccess     int\n\tReadSuccess     int\n\tWriteSuccess    int\n\tErrors          int\n}\n\nfunc (p *Probe) connectWithRetry(ctx context.Context, tgt, msgPattern string, result *probeRunResult) *grpc.ClientConn {\n\tvar conn *grpc.ClientConn\n\tvar err error\n\tfor i := 0; i < p.c.RetryCount; i++ {\n\t\tconn, err = grpc.Dial(tgt, append(p.dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))...)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tp.l.Errorf(\"Failed to connect to %s, attempt %d: %v\", tgt, i+1, err)\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-time.After(time.Duration(i+1) * time.Second):\n\t\t}\n\t}\n\tif err != nil {\n\t\tresult.metrics.Errors++\n\t\treturn nil\n\t}\n\tresult.metrics.ConnectSuccess++\n\treturn conn\n}\n\nfunc (p *Probe) oneTargetLoop(ctx context.Context, tgt string, index int, result *probeRunResult) {\n\tticker := time.NewTicker(p.c.Interval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tconn := p.connectWithRetry(ctx, tgt, \"echo\", result)\n\t\t\tif conn != nil {\n\t\t\t\t// Perform echo/read/write operations here\n\t\t\t\t// Update result metrics accordingly\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Write a Go function that tests the version retrieval functionality of a gRPC service using the Stripe CLI client. The function should establish a connection to the gRPC server, call the Version method, and verify the response matches the expected version.\n\nFunction Description: The function `TestVersionReturnsCLIVersion` is a test function that verifies the version information returned by a gRPC service. It establishes an authenticated connection to a gRPC server, calls the Version RPC method, and checks that the returned version matches the expected value (\"master\"). The connection is properly closed after the test completes.\n\nInput: \n- `t *testing.T`: The testing context provided by Go's testing framework for reporting test failures and logging.\n- Implicit context from `withAuth(context.Background())`: An authenticated context for the gRPC call.\n\nOutput: \n- The function does not return any value but will fail the test if any of the following occur:\n  - The gRPC connection cannot be established\n  - The Version RPC call fails\n  - The returned version does not match the expected value",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Version(ctx, &rpc.VersionRequest{})\n\tif err != nil {\n\t\tt.Fatalf(\"Version failed: %v\", err)\n\t}\n\n\texpected := rpc.VersionResponse{\n\t\tVersion: \"master\",\n\t}\n\n\tassert.Equal(t, expected.Version, resp.Version)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stripe/stripe-cli/pkg/autocomplete\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\nfunc TestVersionReturnsCLIVersion(t *testing.T) {\n\tctx := withAuth(context.Background())\n\tclient := autocomplete.NewClient(ctx)\n\tresp, err := client.Version(ctx)\n\tif err != nil {\n\t\tt.Errorf(\"Error calling Version: %v\", err)\n\t}\n\tif resp.Version != \"master\" {\n\t\tt.Errorf(\"Expected version master, got %s\", resp.Version)\n\t}\n}\n```"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: The task involves creating a gRPC client in Go that connects to a CloudSlack service, establishes a bidirectional stream, and handles incoming events while managing connection lifecycle and errors.\n\nFunction Description: The `start` function initializes a gRPC connection to a CloudSlack server, establishes a bidirectional stream for communication, sends a connection request, and continuously listens for incoming events. It handles connection errors, server closures, and context cancellations appropriately.\n\nInput: \n- `ctx context.Context`: The context for managing the lifecycle of the gRPC connection and handling cancellations.\n- The function also relies on the struct's fields (`log`, `cfg`, `client`, `commGroupMetadata`, `clusterName`, and `botID`) for configuration and logging.\n\nOutput: \n- `error`: Returns an error if any step in the connection or communication process fails, including gRPC connection errors, credential errors, or stream errors. Returns nil if the context is canceled gracefully.\n\nNote: The function uses deferred calls to ensure proper cleanup of resources (closing the gRPC connection and stream) and includes detailed error handling for various gRPC-specific scenarios.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tpb \"github.com/kubeshop/botkube/pkg/api/cloudslack\"\n\t\"github.com/kubeshop/botkube/pkg/grpcx\"\n\t\"github.com/kubeshop/botkube/pkg/config\"\n\t\"github.com/kubeshop/botkube/pkg/api/cloudplatform\"\n\t\"github.com/kubeshop/botkube/internal/config/remote\"\n)\n\ntype CloudSlack struct {\n\tlog               logrus.FieldLogger\n\tcfg               config.CloudSlack\n\tclient            *slack.Client\n\tcommGroupMetadata CommGroupMetadata\n\tclusterName       string\n}\n\nfunc (b *CloudSlack) start(ctx context.Context) error {\n\tremoteConfig, ok := remote.GetConfig()\n\tif !ok {\n\t\treturn fmt.Errorf(\"while getting remote config for %s\", config.CloudSlackCommPlatformIntegration)\n\t}\n\n\tcreds, err := grpcx.ClientTransportCredentials(b.log, b.cfg.Server)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC credentials: %w\", err)\n\t}\n\n\topts := []grpc.DialOption{\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithStreamInterceptor(cloudplatform.AddStreamingClientCredentials(remoteConfig)),\n\t\tgrpc.WithUnaryInterceptor(cloudplatform.AddUnaryClientCredentials(remoteConfig)),\n\t}\n\n\tconn, err := grpc.Dial(b.cfg.Server.URL, opts...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while creating gRPC connection: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\treq := &pb.ConnectRequest{\n\t\tInstanceId: remoteConfig.Identifier,\n\t\tBotId:      b.botID,\n\t}\n\tc, err := pb.NewCloudSlackClient(conn).Connect(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while initializing gRPC cloud client: %w\", err)\n\t}\n\tdefer func(c pb.CloudSlack_ConnectClient) {\n\t\terr := c.CloseSend()\n\t\tif err != nil {\n\t\t\tb.log.Errorf(\"while closing connection: %s\", err.Error())\n\t\t}\n\t}(c)\n\n\terr = c.Send(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while sending gRPC connection request. %w\", err)\n\t}\n\n\tfor {\n\t\tdata, err := c.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tb.log.Warn(\"gRPC connection was closed by server\")\n\t\t\t\treturn errors.New(\"gRPC connection closed\")\n\t\t\t}\n\t\t\terrStatus, ok := status.FromError(err)\n\t\t\tif ok && errStatus.Code() == codes.Canceled && errStatus.Message() == context.Canceled.Error() {\n\t\t\t\tb.log.Debugf(\"Context was cancelled. Skipping returning error...\")\n\t\t\t\treturn fmt.Errorf(\"while resolving error from gRPC response %s\", errStatus.Err())\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"while receiving cloud slack events: %w\", err)\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\nfunc start(ctx context.Context) error {\n    defer func() {\n        if err := c.client.Close(); err != nil {\n            log.Errorf(\"Failed to close gRPC client: %v\", err)\n        }\n        if err := c.commGroupMetadata.Cancel(); err != nil {\n            log.Errorf(\"Failed to cancel comm group metadata: %v\", err)\n        }\n    }()\n\n    conn, err := grpc.DialContext(ctx, c.cfg.ServerAddress, grpc.WithInsecure())\n    if err != nil {\n        return fmt.Errorf(\"failed to dial server: %w\", err)\n    }\n\n    c.client = cloudslack.NewCloudSlackClient(conn)\n\n    stream, err := c.client.StreamEvents(ctx)\n    if err != nil {\n        return fmt.Errorf(\"failed to create stream: %w\", err)\n    }\n\n    req := &cloudslack.ConnectionRequest{\n        ClusterName: c.clusterName,\n        BotId:       c.botID,\n    }\n\n    if err := stream.Send(req); err != nil {\n        return fmt.Errorf(\"failed to send connection request: %w\", err)\n    }\n\n    go func() {\n        for {\n            select {\n            case <-ctx.Done():\n                return\n            default:\n                resp, err := stream.Recv()\n                if err == io.EOF {\n                    log.Info(\"Server closed the stream\")\n                    return\n                }\n                if err != nil {\n                    log.Errorf(\"Error receiving message: %v\", err)\n                    return\n                }\n                // Handle incoming event\n                handleEvent(resp.Event)\n            }\n        }\n    }()\n\n    <-ctx.Done()\n    return ctx.Err()\n}\n```"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a gRPC client function in Go that connects to a gRPC server, sends a login request, and retrieves an authentication token.\n\nFunction Description: The function establishes a connection to a gRPC server at a specified address, creates a gRPC client for the User service, sends a login request with account credentials, and returns the authentication token received from the server. The function includes error handling and connection cleanup.\n\nInput:\n- serviceAddress (string): The address of the gRPC server in format \"host:port\"\n- account (string): The user account name for login\n- password (string): The user password for login\n\nOutput:\n- token (string): The authentication token returned by the server\n- error: Any error that occurs during the connection or RPC call\n\nNote: The function generates a unique request UUID for tracking purposes and uses insecure connection (for testing purposes only). In production, you should use proper TLS credentials.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/pb\"\n\t\"github.com/hwholiday/learning_tools/go-kit/v6/user_agent/src\"\n\tuuid \"github.com/satori/go.uuid\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\nfunc TestGrpc(t *testing.T) {\n\tserviceAddress := \"127.0.0.1:8881\"\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())\n\tif err != nil {\n\t\tpanic(\"connect error\")\n\t}\n\tdefer conn.Close()\n\tuserClient := pb.NewUserClient(conn)\n\tUUID := uuid.NewV5(uuid.NewV4(), \"req_uuid\").String()\n\tmd := metadata.Pairs(src.ContextReqUUid, UUID)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tres, err := userClient.RpcUserLogin(ctx, &pb.Login{\n\t\tAccount:  \"hw\",\n\t\tPassword: \"123\",\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tt.Log(res.Token)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\tpb \"path/to/your/proto/package\" // Replace with your proto package path\n)\n\nfunc Login(serviceAddress, account, password string) (token string, err error) {\n\tconn, err := grpc.Dial(serviceAddress, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewUserServiceClient(conn)\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\treq := &pb.LoginRequest{\n\t\tAccount: account,\n\t\tPassword: password,\n\t}\n\n\tresp, err := client.Login(ctx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn resp.Token, nil\n}\n\nfunc main() {\n\ttoken, err := Login(\"localhost:50051\", \"user123\", \"pass456\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to login: %v\", err)\n\t}\n\tlog.Printf(\"Authentication Token: %s\", token)\n}\n```\n\nReplace `\"path/to/your/proto/package\"` with the actual path to your generated gRPC protobuf package. This code snippet demonstrates how to establish a secure connection to a gRPC server, send a login request, and handle the response."
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function that establishes a gRPC connection to a server, creates a client, and makes a request to retrieve fixture data for a specific event.\n\nFunction Description: The function `TestFixturesReturnsData` tests the gRPC client's ability to connect to a server and retrieve fixture data for a specified event. It establishes a connection, creates a client, sends a request, and handles potential errors. The connection is automatically closed when the function completes.\n\nInput: \n- `t *testing.T`: The testing context for reporting failures and logging.\n- Implicit context with authentication (via `withAuth`).\n\nOutput: \n- None explicitly returned, but the function will fail the test if any step (connection, client creation, or request) encounters an error. The response from the gRPC server is captured in `resp` but not returned.",
    "Canonical_solution": "import (\n\t\"context\"\n\n\t\"github.com/stripe/stripe-cli/rpc\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n)\nfunc TestFixturesReturnsData(t *testing.T) {\n\tctx := withAuth(context.Background())\n\n\tconn, err := grpc.DialContext(ctx, \"bufnet\", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial bufnet: %v\", err)\n\t}\n\tdefer conn.Close()\n\tclient := rpc.NewStripeCLIClient(conn)\n\n\tresp, err := client.Fixture(ctx, &rpc.FixtureRequest{Event: \"customer.created\"})\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\nfunc TestFixturesReturnsData(t *testing.T) {\n\tctx := context.Background()\n\tctx = withAuth(ctx)\n\n\tconn, err := grpc.Dial(\"server_address\", grpc.WithInsecure())\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewFixtureServiceClient(conn)\n\treq := &pb.GetFixturesRequest{\n\t\tEventId: \"event123\",\n\t}\n\n\tresp, err := client.GetFixtures(ctx, req)\n\tif err != nil {\n\t\tt.Errorf(\"GetFixtures failed: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Go function that establishes a gRPC client connection to a server, sends multiple requests, and processes the responses using the GoFrame framework.\n\nFunction Description: The function connects to a gRPC server using service discovery, creates a client stub, and makes repeated calls to a SayHello RPC method. It handles connection errors and response processing, with built-in logging and graceful connection closure.\n\nInput: None (uses package-level constants and context)\n\nOutput: None (logs results to console via GoFrame's logging system)\n\nNote: The function includes an internal loop that makes 10 RPC calls with a 1-second delay between calls. Connection is automatically closed when function completes.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/gsvc\"\n\t\"github.com/gogf/gf/v2/os/gctx\"\n\n\t\"github.com/gogf/gf/contrib/rpc/grpcx/v2\"\n\n\tpb \"github.com/gogf/gf/example/rpc/grpcx/rawgrpc/helloworld\"\n)\nfunc main() {\n\tvar (\n\t\tctx     = gctx.GetInitCtx()\n\t\tservice = gsvc.NewServiceWithName(`hello`)\n\t)\n\tconn, err := grpc.Dial(\n\t\tfmt.Sprintf(`%s://%s`, gsvc.Schema, service.GetKey()),\n\t\tgrpcx.Balancer.WithRandom(),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\tif err != nil {\n\t\tg.Log().Fatalf(ctx, \"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := pb.NewGreeterClient(conn)\n\tfor i := 0; i < 10; i++ {\n\t\tres, err := client.SayHello(ctx, &pb.HelloRequest{Name: `GoFrame`})\n\t\tif err != nil {\n\t\t\tg.Log().Fatalf(ctx, \"could not greet: %+v\", err)\n\t\t}\n\t\tg.Log().Printf(ctx, \"Greeting: %s\", res.Message)\n\t\ttime.Sleep(time.Second)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 120,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gogf/gf/v2/frame/g\"\n\t\"github.com/gogf/gf/v2/net/gclient\"\n\t\"github.com/gogf/gf/v2/os/gctx\"\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/proto\"\n)\n\nconst (\n\tserverName = \"hello-service\"\n\tserviceKey = \"grpc-server\"\n)\n\nfunc main() {\n\tctx := gctx.New()\n\tclient, err := gclient.NewGrpcClient(g.Map{\n\t\t\"dial\": fmt.Sprintf(\"discovery://%s/%s\", serviceKey, serverName),\n\t})\n\tif err != nil {\n\t\tg.Log().Fatal(ctx, err)\n\t}\n\tdefer client.Close()\n\n\tconn, err := client.Dial(ctx)\n\tif err != nil {\n\t\tg.Log().Fatal(ctx, err)\n\t}\n\n\tc := pb.NewGreeterClient(conn)\n\tfor i := 0; i < 10; i++ {\n\t\tresponse, err := c.SayHello(ctx, &pb.HelloRequest{Name: \"World\"})\n\t\tif err != nil {\n\t\t\tg.Log().Error(ctx, err)\n\t\t} else {\n\t\t\tg.Log().Info(ctx, response.Message)\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t}\n}\n```"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Go struct that implements a gRPC management server for Envoy's xDS (Discovery Service) protocol, supporting dynamic configuration updates and load reporting.\n\nStruct Description: The ManagementServer struct represents a gRPC server that implements Envoy's xDS protocol, including Aggregated Discovery Service (ADS) and optionally Load Reporting Service (LRS). It maintains a snapshot cache of resources and handles gRPC connections.\n\nFields:\n- Address: string - The network address the server is listening on\n- LRSServer: *fakeserver.Server - Optional fake LRS server instance\n- cancel: context.CancelFunc - Function to cancel the server's context\n- xs: v3server.Server - xDS server implementation\n- gs: *grpc.Server - gRPC server instance\n- cache: v3cache.SnapshotCache - Cache for storing configuration snapshots\n- version: int - Current version of the configuration\n- logger: interface{ Logf(format string, args ...any) } - Logger interface for output\n\nMethods:\n- StartManagementServer(*testing.T, ManagementServerOptions) *ManagementServer - Creates and starts a new management server instance. Takes testing context and options, returns initialized server.\n- Update(context.Context, UpdateOptions) error - Updates the server's configuration snapshot with new resources. Takes context and update options, returns error if update fails.\n- Stop() - Stops the server and cleans up resources. No parameters or return values.\n\nThe struct provides dynamic configuration management for Envoy proxies through the xDS protocol, with support for listeners, routes, clusters, and endpoints configuration.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/envoyproxy/go-control-plane/pkg/cache/types\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils/xds/fakeserver\"\n\n\tv3clusterpb \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tv3endpointpb \"github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3\"\n\tv3listenerpb \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tv3routepb \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3cache \"github.com/envoyproxy/go-control-plane/pkg/cache/v3\"\n\tv3resource \"github.com/envoyproxy/go-control-plane/pkg/resource/v3\"\n\tv3server \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n)\n\ntype ManagementServer struct {\n\tAddress   string\n\tLRSServer *fakeserver.Server\n\n\tcancel  context.CancelFunc\n\txs      v3server.Server\n\tgs      *grpc.Server\n\tcache   v3cache.SnapshotCache\n\tversion int\n\n\tlogger interface {\n\t\tLogf(format string, args ...any)\n\t}\n}\n\nfunc StartManagementServer(t *testing.T, opts ManagementServerOptions) *ManagementServer {\n\twait := !opts.AllowResourceSubset\n\tcache := v3cache.NewSnapshotCache(wait, v3cache.IDHash{}, serverLogger{t})\n\n\tlis := opts.Listener\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to listen on localhost:0: %v\", err)\n\t\t}\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcallbacks := v3server.CallbackFuncs{\n\t\tStreamOpenFunc:     opts.OnStreamOpen,\n\t\tStreamClosedFunc:   opts.OnStreamClosed,\n\t\tStreamRequestFunc:  opts.OnStreamRequest,\n\t\tStreamResponseFunc: opts.OnStreamResponse,\n\t}\n\n\txs := v3server.NewServer(ctx, cache, callbacks)\n\tgs := grpc.NewServer()\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(gs, xs)\n\n\tmgmtServer := &ManagementServer{\n\t\tAddress: lis.Addr().String(),\n\t\tcancel:  cancel,\n\t\tversion: 0,\n\t\tgs:      gs,\n\t\txs:      xs,\n\t\tcache:   cache,\n\t\tlogger:  t,\n\t}\n\tif opts.SupportLoadReportingService {\n\t\tlrs := fakeserver.NewServer(lis.Addr().String())\n\t\tv3lrsgrpc.RegisterLoadReportingServiceServer(gs, lrs)\n\t\tmgmtServer.LRSServer = lrs\n\t}\n\n\tgo gs.Serve(lis)\n\tt.Cleanup(mgmtServer.Stop)\n\treturn mgmtServer\n}\n\nfunc (s *ManagementServer) Update(ctx context.Context, opts UpdateOptions) error {\n\ts.version++\n\n\tresources := map[v3resource.Type][]types.Resource{\n\t\tv3resource.ListenerType: resourceSlice(opts.Listeners),\n\t\tv3resource.RouteType:    resourceSlice(opts.Routes),\n\t\tv3resource.ClusterType:  resourceSlice(opts.Clusters),\n\t\tv3resource.EndpointType: resourceSlice(opts.Endpoints),\n\t}\n\tsnapshot, err := v3cache.NewSnapshot(strconv.Itoa(s.version), resources)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create new snapshot cache: %v\", err)\n\t}\n\tif !opts.SkipValidation {\n\t\tif err := snapshot.Consistent(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create new resource snapshot: %v\", err)\n\t\t}\n\t}\n\n\tif err := s.cache.SetSnapshot(ctx, opts.NodeID, snapshot); err != nil {\n\t\treturn fmt.Errorf(\"failed to update resource snapshot in management server: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (s *ManagementServer) Stop() {\n\tif s.cancel != nil {\n\t\ts.cancel()\n\t}\n\ts.gs.Stop()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage envoyxds\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\tv3cache \"github.com/envoyproxy/go-control-plane/pkg/cache/v3\"\n\tv3server \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n\tfakeserver \"github.com/grpc/grpc-go/fakeserver\"\n)\n\ntype ManagementServerOptions struct {\n\tLRSEnabled bool\n}\n\ntype ManagementServer struct {\n\tAddress      string\n\tLRSServer    *fakeserver.Server\n\tcancel       context.CancelFunc\n\txs           v3server.Server\n\tgs           *grpc.Server\n\tcache        v3cache.SnapshotCache\n\tversion      int\n\tlogger       interface {\n\t\tLogf(format string, args ...any)\n\t}\n}\n\nfunc StartManagementServer(t *testing.T, opts ManagementServerOptions) *ManagementServer {\n\tserver := &ManagementServer{\n\t\tAddress: \":50051\",\n\t\tlogger:  t,\n\t}\n\tif opts.LRSEnabled {\n\t\tserver.LRSServer = fakeserver.New()\n\t}\n\tserver.gs = grpc.NewServer()\n\tserver.xs = v3server.New(server.gs)\n\tserver.cache = v3cache.NewSnapshotCache(false, v3cache.IDHash)\n\tctx, cancel := context.WithCancel(context.Background())\n\tserver.cancel = cancel\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", server.Address)\n\t\tif err != nil {\n\t\t\tserver.logger.Logf(\"failed to listen: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif err := server.gs.Serve(lis); err != nil && err != grpc.ErrServerStopped {\n\t\t\tserver.logger.Logf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\treturn server\n}\n\nfunc (ms *ManagementServer) Update(ctx context.Context, opts UpdateOptions) error {\n\tsnap := v3cache.NewSnapshot(opts.Version, opts.Resources)\n\terr := ms.cache.SetSnapshot(opts.TypeURL, snap)\n\tif err != nil {\n\t\treturn err\n\t}\n\tms.version = opts.Version\n\treturn nil\n}\n\nfunc (ms *ManagementServer) Stop() {\n\tif ms.cancel != nil {\n\t\tms.cancel()\n\t}\n\tif ms.gs != nil {\n\t\tms.gs.Stop()\n\t}\n\tif ms.LRSServer != nil {\n\t\tms.LRSServer.Stop()\n\t}\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a function that retrieves metadata from a Google Cloud instance using a custom HTTP client with specific headers and returns both the metadata value and its ETag.\n\nFunction Description: The function `getETag` makes an HTTP GET request to the Google Cloud metadata server to fetch instance metadata. It uses a custom HTTP client with timeout configurations and sets required headers (\"Metadata-Flavor\" and \"User-Agent\"). The function handles various response scenarios including errors and not-found statuses, and returns the metadata value along with its ETag if successful.\n\nInput:\n- `client` (*http.Client): A custom HTTP client configured with specific timeout settings\n- `suffix` (string): The metadata path suffix to append to the base metadata URL\n\nOutput:\n- `value` (string): The retrieved metadata value\n- `etag` (string): The ETag header value from the response\n- `err` (error): Any error encountered during the request or processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tmetaClient = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   2 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tResponseHeaderTimeout: 2 * time.Second,\n\t\t},\n\t}\n)\n\nfunc getETag(client *http.Client, suffix string) (value, etag string, err error) {\n\thost := os.Getenv(metadataHostEnv)\n\tif host == \"\" {\n\t\thost = metadataIP\n\t}\n\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode == http.StatusNotFound {\n\t\treturn \"\", \"\", NotDefinedError(suffix)\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n\t}\n\tall, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn string(all), res.Header.Get(\"Etag\"), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc getETag(client *http.Client, suffix string) (value string, etag string, err error) {\n\tbaseURL := \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n\turl := baseURL + suffix\n\n\treq, err := http.NewRequestWithContext(context.Background(), \"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\treq.Header.Set(\"User-Agent\", \"custom-http-client\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"HTTP request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tswitch resp.StatusCode {\n\tcase http.StatusOK:\n\t\tbuf := new(bytes.Buffer)\n\t\tif _, err := buf.ReadFrom(resp.Body); err != nil {\n\t\t\treturn \"\", \"\", fmt.Errorf(\"failed to read response body: %w\", err)\n\t\t}\n\t\tvalue = buf.String()\n\t\tetag = resp.Header.Get(\"Etag\")\n\tdefault:\n\t\treturn \"\", \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\treturn value, etag, nil\n}\n```"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles both xDS (Discovery Service) and LRS (Load Reporting Service) protocols, with proper request/response channels and connection monitoring capabilities.\n\nStruct Description: The Server struct represents a gRPC server that implements both xDS v3 and LRS v3 services. It manages communication channels for requests/responses and tracks connection state.\n\nFields:\n\nXDSRequestChan: *testutils.Channel - Channel for receiving xDS requests\nXDSResponseChan: chan *Response - Channel for sending xDS responses\nLRSRequestChan: *testutils.Channel - Channel for receiving LRS requests\nLRSResponseChan: chan *Response - Channel for sending LRS responses\nLRSStreamOpenChan: *testutils.Channel - Channel for tracking LRS stream openings\nLRSStreamCloseChan: *testutils.Channel - Channel for tracking LRS stream closings\nNewConnChan: *testutils.Channel - Channel for tracking new connections\nAddress: string - Server's listening address\nxdsServerV3: *xdsServerV3 - xDS v3 server implementation\nlrsServerV3: *lrsServerV3 - LRS v3 server implementation\n\nMethods:\n\nNewServer: (addr string) -> *Server - Creates a new Server instance with initialized channels\nStartServer: (lis net.Listener) -> (*Server, func(), error) - Starts the gRPC server on given listener and returns cleanup function\nStreamAggregatedResources: (s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) -> error - Handles xDS v3 streaming RPC\nStreamLoadStats: (s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) -> error - Handles LRS v3 streaming RPC",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/internal/testutils\"\n\t\"google.golang.org/protobuf/proto\"\n\tv3discoverygrpc \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3discoverypb \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\tv3lrsgrpc \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n\tv3lrspb \"github.com/envoyproxy/go-control-plane/envoy/service/load_stats/v3\"\n)\n\ntype Server struct {\n\tXDSRequestChan *testutils.Channel\n\tXDSResponseChan chan *Response\n\tLRSRequestChan *testutils.Channel\n\tLRSResponseChan chan *Response\n\tLRSStreamOpenChan *testutils.Channel\n\tLRSStreamCloseChan *testutils.Channel\n\tNewConnChan *testutils.Channel\n\tAddress string\n\t*xdsServerV3\n\t*lrsServerV3\n}\n\ntype wrappedListener struct {\n\tnet.Listener\n\tserver *Server\n}\n\nfunc (wl *wrappedListener) Accept() (net.Conn, error) {\n\tc, err := wl.Listener.Accept()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twl.server.NewConnChan.Send(struct{}{})\n\treturn c, err\n}\n\nfunc StartServer(lis net.Listener) (*Server, func(), error) {\n\tif lis == nil {\n\t\tvar err error\n\t\tlis, err = net.Listen(\"tcp\", \"localhost:0\")\n\t\tif err != nil {\n\t\t\treturn nil, func() {}, fmt.Errorf(\"net.Listen() failed: %v\", err)\n\t\t}\n\t}\n\n\ts := NewServer(lis.Addr().String())\n\twp := &wrappedListener{\n\t\tListener: lis,\n\t\tserver:   s,\n\t}\n\n\tserver := grpc.NewServer()\n\tv3lrsgrpc.RegisterLoadReportingServiceServer(server, s)\n\tv3discoverygrpc.RegisterAggregatedDiscoveryServiceServer(server, s)\n\tgo server.Serve(wp)\n\n\treturn s, func() { server.Stop() }, nil\n}\n\nfunc NewServer(addr string) *Server {\n\ts := &Server{\n\t\tXDSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSRequestChan:     testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tNewConnChan:        testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tXDSResponseChan:    make(chan *Response, defaultChannelBufferSize),\n\t\tLRSResponseChan:    make(chan *Response, 1),\n\t\tLRSStreamOpenChan:  testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tLRSStreamCloseChan: testutils.NewChannelWithSize(defaultChannelBufferSize),\n\t\tAddress:            addr,\n\t}\n\ts.xdsServerV3 = &xdsServerV3{reqChan: s.XDSRequestChan, respChan: s.XDSResponseChan}\n\ts.lrsServerV3 = &lrsServerV3{reqChan: s.LRSRequestChan, respChan: s.LRSResponseChan, streamOpenChan: s.LRSStreamOpenChan, streamCloseChan: s.LRSStreamCloseChan}\n\treturn s\n}\n\ntype xdsServerV3 struct {\n\treqChan  *testutils.Channel\n\trespChan chan *Response\n}\n\nfunc (xdsS *xdsServerV3) StreamAggregatedResources(s v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\terrCh := make(chan error, 2)\n\tgo func() {\n\t\tfor {\n\t\t\treq, err := s.Recv()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\txdsS.reqChan.Send(&Request{req, err})\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar retErr error\n\t\tdefer func() {\n\t\t\terrCh <- retErr\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase r := <-xdsS.respChan:\n\t\t\t\tif r.Err != nil {\n\t\t\t\t\tretErr = r.Err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := s.Send(r.Resp.(*v3discoverypb.DiscoveryResponse)); err != nil {\n\t\t\t\t\tretErr = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-s.Context().Done():\n\t\t\t\tretErr = s.Context().Err()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := <-errCh; err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype lrsServerV3 struct {\n\treqChan         *testutils.Channel\n\trespChan        chan *Response\n\tstreamOpenChan  *testutils.Channel\n\tstreamCloseChan *testutils.Channel\n}\n\nfunc (lrsS *lrsServerV3) StreamLoadStats(s v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\tlrsS.streamOpenChan.Send(nil)\n\tdefer lrsS.streamCloseChan.Send(nil)\n\n\treq, err := s.Recv()\n\tlrsS.reqChan.Send(&Request{req, err})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase r := <-lrsS.respChan:\n\t\tif r.Err != nil {\n\t\t\treturn r.Err\n\t\t}\n\t\tif err := s.Send(r.Resp.(*v3lrspb.LoadStatsResponse)); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase <-s.Context().Done():\n\t\treturn s.Context().Err()\n\t}\n\n\tfor {\n\t\treq, err := s.Recv()\n\t\tlrsS.reqChan.Send(&Request{req, err})\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\n\tv3discoverygrpc \"google.golang.org/grpc/services/xdspb/v3/discovery_grpc\"\n\tv3lrsgrpc \"google.golang.org/grpc/services/xdspb/v3/lrs_grpc\"\n\ttestutils \"github.com/example/testutils\"\n)\n\ntype Response struct {\n\t// Define response fields here\n}\n\ntype xdsServerV3 struct{}\n\nfunc (s *xdsServerV3) StreamAggregatedResources(ctx context.Context, s2 v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\t// Implement xDS v3 streaming RPC handling\n\treturn nil\n}\n\ntype lrsServerV3 struct{}\n\nfunc (s *lrsServerV3) StreamLoadStats(s2 v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\t// Implement LRS v3 streaming RPC handling\n\treturn nil\n}\n\ntype Server struct {\n\tXDSRequestChan  *testutils.Channel\n\tXDSResponseChan chan *Response\n\tLRSRequestChan  *testutils.Channel\n\tLRSResponseChan chan *Response\n\tLRSStreamOpenChan *testutils.Channel\n\tLRSStreamCloseChan *testutils.Channel\n\tNewConnChan     *testutils.Channel\n\tAddress         string\n\txdsServerV3     *xdsServerV3\n\tlrsServerV3     *lrsServerV3\n}\n\nfunc NewServer(addr string) *Server {\n\treturn &Server{\n\t\tXDSRequestChan:  testutils.NewChannel(),\n\t\tXDSResponseChan: make(chan *Response),\n\t\tLRSRequestChan:  testutils.NewChannel(),\n\t\tLRSResponseChan: make(chan *Response),\n\t\tLRSStreamOpenChan: testutils.NewChannel(),\n\t\tLRSStreamCloseChan: testutils.NewChannel(),\n\t\tNewConnChan:     testutils.NewChannel(),\n\t\tAddress:         addr,\n\t\txdsServerV3:     &xdsServerV3{},\n\t\tlrsServerV3:     &lrsServerV3{},\n\t}\n}\n\nfunc StartServer(lis net.Listener) (*Server, func(), error) {\n\tserver := NewServer(\"localhost:50051\")\n\tgo func() {\n\t\tif err := server.xdsServerV3.StreamAggregatedResources(server.XDSRequestChan.Recv(), server.XDSResponseChan); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\tgo func() {\n\t\tif err := server.lrsServerV3.StreamLoadStats(server.LRSRequestChan.Recv(), server.LRSResponseChan); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\treturn server, func() {}, nil\n}\n\nfunc (s *Server) StreamAggregatedResources(s2 v3discoverygrpc.AggregatedDiscoveryService_StreamAggregatedResourcesServer) error {\n\tfor {\n\t\treq, err := s2.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.XDSRequestChan.Send(req)\n\t\tresp := <-s.XDSResponseChan\n\t\ts2.Send(resp)\n\t}\n}\n\nfunc (s *Server) StreamLoadStats(s2 v3lrsgrpc.LoadReportingService_StreamLoadStatsServer) error {\n\tfor {\n\t\treq, err := s2.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.LRSRequestChan.Send(req)\n\t\tresp := <-s.LRSResponseChan\n\t\ts2.Send(resp)\n\t}\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a function that sends a multipart/form-data POST request to a specified URL with file upload capabilities and custom headers.\n\nFunction Description: The function performs an HTTP POST request with multipart form data, including file upload functionality. It constructs the request with custom headers, sends it using a custom HTTP client, and returns the response body as a string. The function handles file operations and request/response lifecycle properly with appropriate error handling.\n\nInput:\n- url (string): The target URL for the POST request\n- method (string): HTTP method (typically \"POST\")\n- filePath (string): Path to the file to be uploaded\n- formFields (map[string]string): Key-value pairs for form fields\n- headers (map[string]string): Custom headers to include in the request\n\nOutput:\n- (string): The response body from the server\n- (error): Any error that occurred during the process (nil if successful)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\nfunc main() {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/image/ad/\"\n\tmethod := \"POST\"\n\n\tpayload := &bytes.Buffer{}\n\twriter := multipart.NewWriter(payload)\n\t_ = writer.WriteField(\"advertiser_id\", \"1760312309087432\")\n\t_ = writer.WriteField(\"upload_type\", \"UPLOAD_BY_FILE\")\n\t_ = writer.WriteField(\"image_signature\", \"1faaf9020e0df18fdf0429e0db211f37\")\n\tfile, errFile4 := os.Open(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\")\n\tdefer file.Close()\n\tpart4,\n\t\terrFile4 := writer.CreateFormFile(\"image_file\", filepath.Base(\"/Users/betta/Desktop/\u5e38\u7528/1faaf9020e0df18fdf0429e0db211f37.png\"))\n\t_, errFile4 = io.Copy(part4, file)\n\tif errFile4 != nil {\n\t\tfmt.Println(errFile4)\n\t\treturn\n\t}\n\t_ = writer.WriteField(\"filename\", \"auto4_huchao.1faaf9020e0df18fdf0429e0db211f37_test\u73af\u5883slicess_\u5361\u901a_P_HC_HC_en_1X1_0s\")\n\terr := writer.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Add(\"Content-Type\", \"multipart/form-data\")\n\treq.Header.Add(\"Access-Token\", \"e88f206ab28a97ef494b853982d81739b81a1e37\")\n\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc sendMultipartForm(url, method, filePath string, formFields map[string]string, headers map[string]string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tpart, err := writer.CreateFormFile(\"file\", filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t_, err = io.Copy(part, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor key, value := range formFields {\n\t\terr = writer.WriteField(key, value)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\tfor headerKey, headerValue := range headers {\n\t\treq.Header.Set(headerKey, headerValue)\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponseBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(responseBody), nil\n}\n\nfunc main() {\n\turl := \"https://example.com/upload\"\n\tmethod := \"POST\"\n\tfilePath := \"/path/to/file.txt\"\n\tformFields := map[string]string{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\":  \"30\",\n\t}\n\theaders := map[string]string{\n\t\t\"Authorization\": \"Bearer token123\",\n\t\t\"X-Custom-Header\": \"customValue\",\n\t}\n\n\tresponse, err := sendMultipartForm(url, method, filePath, formFields, headers)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Response:\", response)\n\t}\n}\n```"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles DNS queries and watch functionality, supporting TLS encryption and OpenTracing for distributed tracing.\n\nStruct Description: ServergRPC is a gRPC server implementation that processes DNS queries and provides watch capabilities. It manages server lifecycle, handles TLS configuration, and integrates with tracing systems.\n\nFields:\n\nServer: [*Server] - Embedded DNS server instance that handles core DNS functionality\ngrpcServer: [*grpc.Server] - The gRPC server instance\nlistenAddr: [net.Addr] - Network address the server is listening on\ntlsConfig: [*tls.Config] - TLS configuration for secure connections\nwatch: [watch.Watcher] - Watcher instance for handling watch requests\n\nMethods:\n\nNewServergRPC: [func(addr string, group []*Config) (*ServergRPC, error)] -> Creates a new ServergRPC instance with the given address and configuration group\nServe: [func(l net.Listener) error] -> Starts the gRPC server on the provided listener\nQuery: [func(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error)] -> Handles incoming DNS query requests\nWatch: [func(stream pb.DnsService_WatchServer) error] -> Handles watch stream requests\nStop: [func() error] -> Gracefully stops the server and watcher\nShutdown: [func() error] -> Immediately stops the server without waiting for connections to close",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/coredns/coredns/pb\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/miekg/dns\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/peer\"\n)\n\ntype ServergRPC struct {\n\t*Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ts, err := NewServer(addr, group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar tlsConfig *tls.Config\n\tfor _, conf := range s.zones {\n\t\ttlsConfig = conf.TLSConfig\n\t}\n\treturn &ServergRPC{Server: s, tlsConfig: tlsConfig, watch: watch.NewWatcher(watchables(s.zones))}, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\ts.m.Lock()\n\ts.listenAddr = l.Addr()\n\ts.m.Unlock()\n\n\tif s.Tracer() != nil {\n\t\tonlyIfParent := func(parentSpanCtx opentracing.SpanContext, method string, req, resp interface{}) bool {\n\t\t\treturn parentSpanCtx != nil\n\t\t}\n\t\tintercept := otgrpc.OpenTracingServerInterceptor(s.Tracer(), otgrpc.IncludingSpans(onlyIfParent))\n\t\ts.grpcServer = grpc.NewServer(grpc.UnaryInterceptor(intercept))\n\t} else {\n\t\ts.grpcServer = grpc.NewServer()\n\t}\n\n\tpb.RegisterDnsServiceServer(s.grpcServer, s)\n\n\tif s.tlsConfig != nil {\n\t\tl = tls.NewListener(l, s.tlsConfig)\n\t}\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\tmsg := new(dns.Msg)\n\terr := msg.Unpack(in.Msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, ok := peer.FromContext(ctx)\n\tif !ok {\n\t\treturn nil, errors.New(\"no peer in gRPC context\")\n\t}\n\n\ta, ok := p.Addr.(*net.TCPAddr)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no TCP peer in gRPC context: %v\", p.Addr)\n\t}\n\n\tw := &gRPCresponse{localAddr: s.listenAddr, remoteAddr: a, Msg: msg}\n\n\ts.ServeDNS(ctx, w, msg)\n\n\tpacked, err := w.Msg.Pack()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.DnsPacket{Msg: packed}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\treturn s.watch.Watch(stream)\n}\n\nfunc (s *ServergRPC) Stop() (err error) {\n\ts.m.Lock()\n\tdefer s.m.Unlock()\n\tif s.watch != nil {\n\t\ts.watch.Stop()\n\t}\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.GracefulStop()\n\t}\n\treturn\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\tif s.grpcServer != nil {\n\t\ts.grpcServer.Stop()\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\n\tpb \"path/to/your/proto\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/opentracing/opentracing-go\"\n)\n\ntype ServergRPC struct {\n\tServer    *Server\n\tgrpcServer *grpc.Server\n\tlistenAddr net.Addr\n\ttlsConfig  *tls.Config\n\twatch      watch.Watcher\n}\n\nfunc NewServergRPC(addr string, group []*Config) (*ServergRPC, error) {\n\ts := &ServergRPC{\n\t\tServer: &Server{},\n\t\tlistenAddr: &net.TCPAddr{IP: net.ParseIP(addr), Port: 53},\n\t\ttlsConfig:  &tls.Config{},\n\t}\n\treturn s, nil\n}\n\nfunc (s *ServergRPC) Serve(l net.Listener) error {\n\tif s.tlsConfig != nil {\n\t\tl = tls.NewListener(l, s.tlsConfig)\n\t}\n\treturn s.grpcServer.Serve(l)\n}\n\nfunc (s *ServergRPC) Query(ctx context.Context, in *pb.DnsPacket) (*pb.DnsPacket, error) {\n\t// Handle DNS query logic here\n\treturn &pb.DnsPacket{}, nil\n}\n\nfunc (s *ServergRPC) Watch(stream pb.DnsService_WatchServer) error {\n\t// Handle watch stream logic here\n\treturn nil\n}\n\nfunc (s *ServergRPC) Stop() error {\n\ts.grpcServer.GracefulStop()\n\treturn s.watch.Stop()\n}\n\nfunc (s *ServergRPC) Shutdown() error {\n\ts.grpcServer.Stop()\n\treturn s.watch.Stop()\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a function to push metrics to a Prometheus push gateway using HTTP requests with custom headers and client configuration.\n\nFunction Description: The function `doPush` sends collected metrics to a Prometheus push gateway. It validates the job name and grouping labels, constructs the appropriate URL, encodes the metrics in Protocol Buffer format, and makes an HTTP request with custom headers. It handles errors during the process and checks the response status.\n\nInput:\n- `job` (string): The job name to associate with the pushed metrics\n- `grouping` (map[string]string): Key-value pairs for metric grouping\n- `pushURL` (string): The base URL of the Prometheus push gateway\n- `g` (prometheus.Gatherer): Interface to gather metrics\n- `method` (string): HTTP method to use for the request (e.g., \"POST\")\n\nOutput:\n- `error`: Returns nil on success, or an error describing any failure during the push operation",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n\t\"github.com/prometheus/common/model\"\n)\n\nconst contentTypeHeader = \"Content-Type\"\n\nvar (\n\tclient         = &http.Client{}\n\tdefaultTimeout = time.Second * 15\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif !strings.Contains(pushURL, \"://\") {\n\t\tpushURL = \"http://\" + pushURL\n\t}\n\tif strings.HasSuffix(pushURL, \"/\") {\n\t\tpushURL = pushURL[:len(pushURL)-1]\n\t}\n\n\tif strings.Contains(job, \"/\") {\n\t\treturn fmt.Errorf(\"job contains '/': %s\", job)\n\t}\n\turlComponents := []string{url.QueryEscape(job)}\n\tfor ln, lv := range grouping {\n\t\tif !model.LabelName(ln).IsValid() {\n\t\t\treturn fmt.Errorf(\"grouping label has invalid name: %s\", ln)\n\t\t}\n\t\tif strings.Contains(lv, \"/\") {\n\t\t\treturn fmt.Errorf(\"value of grouping label %s contains '/': %s\", ln, lv)\n\t\t}\n\t\turlComponents = append(urlComponents, ln, lv)\n\t}\n\tpushURL = fmt.Sprintf(\"%s/metrics/job/%s\", pushURL, strings.Join(urlComponents, \"/\"))\n\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtProtoDelim)\n\tfor _, mf := range mfs {\n\t\tfor _, m := range mf.GetMetric() {\n\t\t\tfor _, l := range m.GetLabel() {\n\t\t\t\tif l.GetName() == \"job\" {\n\t\t\t\t\treturn fmt.Errorf(\"pushed metric %s (%s) already contains a job label\", mf.GetName(), m)\n\t\t\t\t}\n\t\t\t\tif _, ok := grouping[l.GetName()]; ok {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"pushed metric %s (%s) already contains grouping label %s\",\n\t\t\t\t\t\tmf.GetName(), m, l.GetName(),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenc.Encode(mf)\n\t}\n\treq, err := http.NewRequest(method, pushURL, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(contentTypeHeader, string(expfmt.FmtProtoDelim))\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 202 {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"unexpected status code %d while pushing to %s: %s\", resp.StatusCode, pushURL, body)\n\t}\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/common/expfmt\"\n)\n\nfunc doPush(job string, grouping map[string]string, pushURL string, g prometheus.Gatherer, method string) error {\n\tif job == \"\" {\n\t\treturn fmt.Errorf(\"job cannot be empty\")\n\t}\n\n\turl := fmt.Sprintf(\"%s/metrics/job/%s\", pushURL, job)\n\tfor key, value := range grouping {\n\t\turl += fmt.Sprintf(\"/%s=%s\", key, value)\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := expfmt.NewEncoder(&buf, expfmt.FmtProtoText)\n\tmfs, err := g.Gather()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, mf := range mfs {\n\t\tif err := enc.Encode(mf); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treq, err := http.NewRequestWithContext(context.Background(), method, url, &buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", expfmt.ContentType(expfmt.FmtProtoText))\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(\"username:password\")))\n\n\tclient := &http.Client{\n\t\tTimeout: 10 * time.Second,\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a gRPC service struct in Go that manages a gRPC server for key management operations, including starting the server, graceful shutdown, and immediate termination capabilities.\n\nStruct Description: GRPCService represents a gRPC server wrapper that handles Unix domain socket communication for key management services. It manages server lifecycle and configuration.\n\nFields:\naddr: string - The Unix domain socket address the server will listen on\ntimeout: time.Duration - Connection timeout duration for gRPC connections\nserver: *grpc.Server - The underlying gRPC server instance\nkmsService: Service - The key management service implementation to be registered with gRPC\n\nMethods:\nNewGRPCService(address string, timeout time.Duration, kmsService Service) -> *GRPCService - Constructor that initializes a new GRPCService instance with the given address, timeout and service implementation\nListenAndServe() -> error - Starts the gRPC server on the configured Unix domain socket address and begins serving requests\nShutdown() -> void - Gracefully stops the gRPC server, allowing existing connections to complete\nClose() -> void - Immediately stops the gRPC server without waiting for connections to complete",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\n\tkmsapi \"k8s.io/kms/apis/v2\"\n)\n\ntype GRPCService struct {\n\taddr    string\n\ttimeout time.Duration\n\tserver  *grpc.Server\n\n\tkmsService Service\n}\n\nfunc NewGRPCService(\n\taddress string,\n\ttimeout time.Duration,\n\tkmsService Service,\n) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tln, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ln.Close()\n\n\tgs := grpc.NewServer(\n\t\tgrpc.ConnectionTimeout(s.timeout),\n\t)\n\ts.server = gs\n\n\tkmsapi.RegisterKeyManagementServiceServer(gs, s)\n\n\treturn gs.Serve(ln)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tif s.server != nil {\n\t\ts.server.GracefulStop()\n\t}\n}\n\nfunc (s *GRPCService) Close() {\n\tif s.server != nil {\n\t\ts.server.Stop()\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype Service interface {\n\t// Define your key management service methods here\n}\n\ntype GRPCService struct {\n\taddr       string\n\ttimeout    time.Duration\n\tserver     *grpc.Server\n\tkmsService Service\n}\n\nfunc NewGRPCService(address string, timeout time.Duration, kmsService Service) *GRPCService {\n\treturn &GRPCService{\n\t\taddr:       address,\n\t\ttimeout:    timeout,\n\t\tserver:     grpc.NewServer(),\n\t\tkmsService: kmsService,\n\t}\n}\n\nfunc (s *GRPCService) ListenAndServe() error {\n\tlistener, err := net.Listen(\"unix\", s.addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer listener.Close()\n\n\ts.kmsService.Register(s.server)\n\n\tlog.Printf(\"gRPC server listening at %v\", s.addr)\n\treturn s.server.Serve(listener)\n}\n\nfunc (s *GRPCService) Shutdown() {\n\tctx, cancel := context.WithTimeout(context.Background(), s.timeout)\n\tdefer cancel()\n\ts.server.GracefulStop()\n}\n\nfunc (s *GRPCService) Close() {\n\ts.server.Stop()\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It includes base URLs, user agent, rate limiting capabilities, and various service clients for different API endpoints.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe rate limiting\nrateLimits: [categories]Rate - Rate limit tracking for different categories\ncommon: service - Shared service implementation\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support and handles response decoding",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Rate struct {\n\tLimit  int\n\tPeriod time.Duration\n}\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\tBaseURL  *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\trateMu    sync.Mutex\n\trateLimits map[string]Rate\n\tcommon     *service\n}\n\nfunc NewClient(client *http.Client) *Client {\n\treturn &Client{\n\t\tclient: client,\n\t}\n}\n\nfunc (c *Client) NewRequest(method string, urlStr string, body interface{}) (*http.Request, error) {\n\treq, err := http.NewRequestWithContext(context.Background(), method, urlStr, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t// Add more headers as needed\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tresp, err := c.client.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\t// Decode response into v\n\treturn &Response{resp}, nil\n}\n```"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a gRPC server in Go that handles log streaming and processing, including batch processing of log events.\n\nStruct Description: The Source struct represents a gRPC server that receives log streams, processes them in batches, and manages the server lifecycle.\n\nFields:\n- name: string - The name identifier for the source\n- eventPool: *event.Pool - Pool for managing event objects\n- config: *Config - Configuration for the source (bind address, port, etc.)\n- grpcServer: *grpc.Server - The gRPC server instance\n- bc: *batchChain - Batch processing chain for handling log events\n\nMethods:\n- ProductLoop: (productFunc api.ProductFunc) -> None - Starts the main processing loop and gRPC server\n  Input: productFunc - Function for processing produced events\n  Output: None (runs indefinitely as goroutine)\n\n- LogStream: (ls pb.LogService_LogStreamServer) -> error - Handles incoming log streams\n  Input: ls - gRPC stream server interface for log messages\n  Output: error - Any error that occurs during stream processing",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/loggie-io/loggie/pkg/pipeline\"\n\tpb \"github.com/loggie-io/loggie/pkg/sink/grpc/pb\"\n\t\"github.com/loggie-io/loggie/pkg/util/json\"\n\t\"github.com/pkg/errors\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Source struct {\n\tpb.UnimplementedLogServiceServer\n\tname       string\n\teventPool  *event.Pool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *batchChain\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", s.String())\n\ts.bc = newBatchChain(productFunc, s.config.MaintenanceInterval)\n\tgo s.bc.run()\n\tip := fmt.Sprintf(\"%s:%s\", s.config.Bind, s.config.Port)\n\tlistener, err := net.Listen(s.config.Network, ip)\n\tif err != nil {\n\t\tlog.Panic(\"grpc server listen ip(%s) err: %v\", ip, err)\n\t}\n\tgrpcServer := grpc.NewServer()\n\tpb.RegisterLogServiceServer(grpcServer, s)\n\tgo grpcServer.Serve(listener)\n\ts.grpcServer = grpcServer\n\tlog.Info(\"grpc server start listing: %s\", ip)\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tb := newBatch(s.config.Timeout)\n\tfor {\n\t\tlogMsg, err := ls.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tsendErr := ls.SendAndClose(&pb.LogResp{\n\t\t\t\tSuccess:  false,\n\t\t\t\tCount:    0,\n\t\t\t\tErrorMsg: err.Error(),\n\t\t\t})\n\t\t\tif sendErr != nil {\n\t\t\t\tlog.Warn(\"send response fail: %s\", sendErr)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\theader := make(map[string]interface{})\n\t\trawHeader := logMsg.GetHeader()\n\t\tif len(rawHeader) > 0 {\n\t\t\tfor k, v := range rawHeader {\n\t\t\t\theader[k] = string(v)\n\t\t\t}\n\t\t}\n\t\tpackedHeader := logMsg.PackedHeader\n\t\tif len(packedHeader) > 0 {\n\t\t\terr = json.Unmarshal(packedHeader, &header)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Unmarshal packedHeader error: %s\", err)\n\t\t\t}\n\t\t}\n\t\te := s.eventPool.Get()\n\t\te.Fill(e.Meta(), header, logMsg.GetRawLog())\n\t\tb.append(e)\n\t}\n\tif b.size() > 0 {\n\t\ts.bc.append(b)\n\t\tlogResp := b.wait()\n\t\terr := ls.SendAndClose(logResp)\n\t\tif err != nil {\n\t\t\tlog.Error(\"send response fail: %s\", err)\n\t\t}\n\t\treturn err\n\t}\n\treturn ls.SendAndClose(&pb.LogResp{\n\t\tSuccess: true,\n\t\tCount:   0,\n\t})\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\tpb \"path/to/your/proto/package\"\n\t\"google.golang.org/grpc\"\n\t\"github.com/your/event/pool\"\n\t\"github.com/your/batch/chain\"\n)\n\ntype Source struct {\n\tname       string\n\teventPool  *pool.EventPool\n\tconfig     *Config\n\tgrpcServer *grpc.Server\n\tbc         *chain.BatchChain\n}\n\nfunc NewSource(name string, eventPool *pool.EventPool, config *Config, bc *chain.BatchChain) *Source {\n\treturn &Source{\n\t\tname:       name,\n\t\teventPool:  eventPool,\n\t\tconfig:     config,\n\t\tgrpcServer: grpc.NewServer(),\n\t\tbc:         bc,\n\t}\n}\n\nfunc (s *Source) ProductLoop(productFunc api.ProductFunc) {\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", s.config.BindAddress+\":\"+s.config.Port)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t\t}\n\t\ts.grpcServer.Serve(lis)\n\t}()\n}\n\nfunc (s *Source) LogStream(ls pb.LogService_LogStreamServer) error {\n\tfor {\n\t\treq, err := ls.Recv()\n\t\tif err == io.EOF {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Process log event\n\t\terr = s.bc.Process(req.Event)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Produce processed event\n\t\tproductFunc(context.Background(), req.Event)\n\t}\n}\n```"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: Implement a gRPC server in Go for a log service that supports append, read, discard, and info operations with concurrent access control and log entry management.\n\nStruct Description: The Server struct represents a gRPC server implementation for a log service that maintains an ordered sequence of log entries with configurable size limits and provides thread-safe operations.\n\nFields:\n- ctx: context.Context - Context for managing server lifecycle\n- options: *Options - Configuration options for the server\n- hardLimit: int - Maximum number of entries before truncation\n- lock: sync.Mutex - Mutex for thread-safe operations\n- locked: struct - Protected data structure containing:\n  - startIndex: Index - First available index in the log\n  - entries: []*logspec.Entry - Slice of log entries\n  - changed: chan struct{} - Channel to notify about log changes\n\nMethods:\n- NewServer: [Name](ctx context.Context, options *Options) -> (*Server, error) - Creates and starts a new Server instance\n- Append: [Name](stream logspec.Log_AppendServer) -> error - Handles append requests via gRPC stream\n- append: [Name](proposals [][]byte) -> []Index - Internal method to append entries to the log\n- lastIndexLocked: [Name]() -> Index - Helper method to get last index (requires lock)\n- Discard: [Name](ctx context.Context, req *logspec.DiscardRequest) -> (*logspec.DiscardReply, error) - Handles discard requests\n- discard: [Name](firstIndex Index) -> - Internal method to discard entries\n- Read: [Name](req *logspec.ReadRequest, stream logspec.Log_ReadServer) -> error - Handles read requests via gRPC stream\n- Info: [Name](ctx context.Context, req *logspec.InfoRequest) -> (*logspec.InfoReply, error) - Returns current log info\n- info: [Name]() -> (*logspec.InfoReply, chan struct{}) - Internal method to get log info\n- InfoStream: [Name](req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) -> error - Streams log info updates",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\n\t\"github.com/ebay/akutan/logspec\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Server struct {\n\tctx       context.Context\n\toptions   *Options\n\thardLimit int\n\tlock      sync.Mutex\n\tlocked    struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\ntype Options struct {\n\tAddress string\n\tLimit   int\n}\n\ntype Index = uint64\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\tserver := &Server{\n\t\tctx:       ctx,\n\t\toptions:   options,\n\t\thardLimit: options.Limit * 3 / 2,\n\t}\n\tserver.locked.startIndex = 1\n\tserver.locked.changed = make(chan struct{})\n\tlistener, err := net.Listen(\"tcp\", options.Address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconst maxMsgSize = 1024 * 1024 * 1024\n\tservice := grpc.NewServer(\n\t\tgrpc.MaxRecvMsgSize(maxMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxMsgSize))\n\tlogspec.RegisterLogServer(service, server)\n\tgo service.Serve(listener)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t\tservice.Stop()\n\t}()\n\treturn server, nil\n}\n\nfunc (server *Server) Append(streams logspec.Log_AppendServer) error {\n\tseq := uint64(0)\n\tfor {\n\t\tseq++\n\t\treq, err := streams.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif req.Sequence != seq {\n\t\t\treturn errors.New(\"out of sequence\")\n\t\t}\n\t\tindexes := server.append(req.Proposals)\n\t\tres := logspec.AppendReply{\n\t\t\tReply: &logspec.AppendReply_Ok{\n\t\t\t\tOk: &logspec.AppendReply_OK{\n\t\t\t\t\tSequence: seq,\n\t\t\t\t\tIndexes:  indexes,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = streams.Send(&res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (server *Server) append(proposals [][]byte) []Index {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tprevLastIndex := server.lastIndexLocked()\n\tnextIndex := prevLastIndex + 1\n\tindexes := make([]Index, len(proposals))\n\tfor i := range proposals {\n\t\tindexes[i] = nextIndex\n\t\tnextIndex++\n\t\tserver.locked.entries = append(server.locked.entries, &logspec.Entry{\n\t\t\tIndex: indexes[i],\n\t\t\tData:  proposals[i],\n\t\t\tSkip:  false,\n\t\t})\n\t}\n\n\tif server.hardLimit > 0 && len(server.locked.entries) >= server.hardLimit {\n\t\tfirstIndex := nextIndex - uint64(server.options.Limit)\n\t\tdiff := firstIndex - server.locked.startIndex\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t\tserver.locked.startIndex = firstIndex\n\t}\n\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n\treturn indexes\n}\n\nfunc (server *Server) lastIndexLocked() Index {\n\treturn server.locked.startIndex + uint64(len(server.locked.entries)) - 1\n}\n\nfunc (server *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\tserver.discard(req.FirstIndex)\n\treturn &logspec.DiscardReply{\n\t\tReply: &logspec.DiscardReply_Ok{\n\t\t\tOk: &logspec.DiscardReply_OK{},\n\t\t},\n\t}, nil\n}\n\nfunc (server *Server) discard(firstIndex Index) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\tif firstIndex <= server.locked.startIndex {\n\t\treturn\n\t}\n\tdiff := firstIndex - server.locked.startIndex\n\tif uint64(len(server.locked.entries)) < diff {\n\t\tserver.locked.entries = nil\n\t} else {\n\t\tserver.locked.entries = append([]*logspec.Entry(nil),\n\t\t\tserver.locked.entries[diff:]...)\n\t}\n\tserver.locked.startIndex = firstIndex\n\tclose(server.locked.changed)\n\tserver.locked.changed = make(chan struct{})\n}\n\nfunc (server *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\tctx := stream.Context()\n\tnextIndex := req.NextIndex\n\tfor {\n\t\tserver.lock.Lock()\n\t\tstartIndex := server.locked.startIndex\n\t\tlastIndex := server.lastIndexLocked()\n\t\tentries := server.locked.entries\n\t\tchangedCh := server.locked.changed\n\t\tserver.lock.Unlock()\n\n\t\tif nextIndex < startIndex {\n\t\t\treturn stream.Send(&logspec.ReadReply{\n\t\t\t\tReply: &logspec.ReadReply_Truncated{\n\t\t\t\t\tTruncated: true,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t\tif nextIndex > lastIndex {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase <-server.ctx.Done():\n\t\t\t\treturn server.ctx.Err()\n\t\t\tcase <-changedCh:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tentries = entries[nextIndex-startIndex:]\n\t\tif len(entries) > 10 {\n\t\t\tentries = entries[:10]\n\t\t}\n\t\terr := stream.Send(&logspec.ReadReply{\n\t\t\tReply: &logspec.ReadReply_Ok{\n\t\t\t\tOk: &logspec.ReadReply_OK{\n\t\t\t\t\tEntries: entries,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnextIndex += uint64(len(entries))\n\t}\n}\n\nfunc (server *Server) Info(context.Context, *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tres, _ := server.info()\n\treturn res, nil\n}\n\nfunc (server *Server) info() (*logspec.InfoReply, chan struct{}) {\n\tserver.lock.Lock()\n\tdefer server.lock.Unlock()\n\treturn &logspec.InfoReply{\n\t\tReply: &logspec.InfoReply_Ok{\n\t\t\tOk: &logspec.InfoReply_OK{\n\t\t\t\tFirstIndex: server.locked.startIndex,\n\t\t\t\tLastIndex:  server.lastIndexLocked(),\n\t\t\t},\n\t\t},\n\t}, server.locked.changed\n}\n\nfunc (server *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tfor {\n\t\tres, changedCh := server.info()\n\t\terr := stream.Send(res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselect {\n\t\tcase <-stream.Context().Done():\n\t\t\treturn stream.Context().Err()\n\t\tcase <-server.ctx.Done():\n\t\t\treturn server.ctx.Err()\n\t\tcase <-changedCh:\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\tlogspec \"path/to/logspec\"\n)\n\ntype Options struct {\n\tHardLimit int\n}\n\ntype Index int64\n\ntype Server struct {\n\tctx      context.Context\n\toptions  *Options\n\thardLimit int\n\tlock     sync.Mutex\n\tlocked   struct {\n\t\tstartIndex Index\n\t\tentries    []*logspec.Entry\n\t\tchanged    chan struct{}\n\t}\n}\n\nfunc NewServer(ctx context.Context, options *Options) (*Server, error) {\n\tserver := &Server{\n\t\tctx:      ctx,\n\t\toptions:  options,\n\t\thardLimit: options.HardLimit,\n\t\tlocked: struct {\n\t\t\tstartIndex Index\n\t\t\tentries    []*logspec.Entry\n\t\t\tchanged    chan struct{}\n\t\t}{\n\t\t\tstartIndex: 0,\n\t\t\tentries:    make([]*logspec.Entry, 0),\n\t\t\tchanged:    make(chan struct{}, 1),\n\t\t},\n\t}\n\treturn server, nil\n}\n\nfunc (s *Server) Append(stream logspec.Log_AppendServer) error {\n\tfor {\n\t\treq, err := stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tindices, err := s.append(req.Entries)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i, idx := range indices {\n\t\t\terr := stream.Send(&logspec.AppendResponse{Index: idx})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Server) append(proposals [][]byte) ([]Index, error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tvar indices []Index\n\tfor _, proposal := range proposals {\n\t\tentry := &logspec.Entry{\n\t\t\tData: proposal,\n\t\t}\n\t\ts.locked.entries = append(s.locked.entries, entry)\n\t\tindices = append(indices, s.lastIndexLocked()+1)\n\t\tif len(s.locked.entries) > s.hardLimit {\n\t\t\ts.discard(1)\n\t\t}\n\t\ts.locked.changed <- struct{}{}\n\t}\n\treturn indices, nil\n}\n\nfunc (s *Server) lastIndexLocked() Index {\n\treturn Index(len(s.locked.entries)) + s.locked.startIndex - 1\n}\n\nfunc (s *Server) Discard(ctx context.Context, req *logspec.DiscardRequest) (*logspec.DiscardReply, error) {\n\tfirstIndex := Index(req.FirstIndex)\n\ts.discard(firstIndex)\n\treturn &logspec.DiscardReply{}, nil\n}\n\nfunc (s *Server) discard(firstIndex Index) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif firstIndex <= s.locked.startIndex {\n\t\ts.locked.entries = s.locked.entries[s.locked.startIndex-firstIndex:]\n\t\ts.locked.startIndex = firstIndex\n\t} else {\n\t\ts.locked.entries = s.locked.entries[firstIndex-s.locked.startIndex:]\n\t\ts.locked.startIndex = firstIndex\n\t}\n\ts.locked.changed <- struct{}{}\n}\n\nfunc (s *Server) Read(req *logspec.ReadRequest, stream logspec.Log_ReadServer) error {\n\tstartIndex := Index(req.StartIndex)\n\tendIndex := Index(req.EndIndex)\n\tfor i := startIndex; i <= endIndex; i++ {\n\t\tentry := s.getEntry(i)\n\t\tif entry == nil {\n\t\t\tbreak\n\t\t}\n\t\terr := stream.Send(entry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Server) getEntry(index Index) *logspec.Entry {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tif index < s.locked.startIndex || index >= s.lastIndexLocked()+1 {\n\t\treturn nil\n\t}\n\treturn s.locked.entries[index-s.locked.startIndex]\n}\n\nfunc (s *Server) Info(ctx context.Context, req *logspec.InfoRequest) (*logspec.InfoReply, error) {\n\tinfo, _ := s.info()\n\treturn info, nil\n}\n\nfunc (s *Server) info() (*logspec.InfoReply, chan struct{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\treturn &logspec.InfoReply{\n\t\tStartIndex: s.locked.startIndex,\n\t\tEndIndex:   s.lastIndexLocked(),\n\t}, s.locked.changed\n}\n\nfunc (s *Server) InfoStream(req *logspec.InfoRequest, stream logspec.Log_InfoStreamServer) error {\n\tinfo, changeChan := s.info()\n\tstream.Send(info)\n\tfor {\n\t\tselect {\n\t\tcase <-changeChan:\n\t\t\tinfo, _ = s.info()\n\t\t\tstream.Send(info)\n\t\tcase <-s.ctx.Done():\n\t\t\treturn s.ctx.Err()\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Create a Go HTTP client struct for interacting with an Okta API, handling authentication, session management, and user data retrieval.\n\nStruct Description: The Client struct represents an HTTP client configured to communicate with Okta's API. It maintains client configuration, organization details, and authentication state, providing methods for various API operations.\n\nFields:\n- client: *http.Client - The underlying HTTP client used for requests\n- org: string - The Okta organization domain\n- Url: string - The base Okta URL (defaults to \"okta.com\")\n- ApiToken: string - The API token for authenticated requests\n\nMethods:\n- NewClient(org string) -> *Client - Constructor that initializes a new Client with the specified organization\n- Authenticate(username string, password string) -> (*AuthnResponse, error) - Performs user authentication with username/password\n- Session(sessionToken string) -> (*SessionResponse, error) - Creates a session using a session token\n- User(userID string) -> (*User, error) - Retrieves user details by ID\n- Groups(userID string) -> (*Groups, error) - Gets groups associated with a user\n- call(endpoint string, method string, request interface{}, response interface{}) -> error - Internal method handling the HTTP request/response cycle",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Client struct {\n\tclient   *http.Client\n\torg      string\n\tUrl      string\n\tApiToken string\n}\n\nfunc NewClient(org string) *Client {\n\tclient := Client{\n\t\tclient: &http.Client{},\n\t\torg:    org,\n\t\tUrl:    \"okta.com\",\n\t}\n\n\treturn &client\n}\n\nfunc (c *Client) Authenticate(username, password string) (*AuthnResponse, error) {\n\tvar request = &AuthnRequest{\n\t\tUsername: username,\n\t\tPassword: password,\n\t}\n\n\tvar response = &AuthnResponse{}\n\terr := c.call(\"authn\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\tvar request = &SessionRequest{\n\t\tSessionToken: sessionToken,\n\t}\n\n\tvar response = &SessionResponse{}\n\terr := c.call(\"sessions\", \"POST\", request, response)\n\treturn response, err\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\tvar response = &User{}\n\terr := c.call(\"users/\"+userID, \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\tvar response = &Groups{}\n\terr := c.call(\"users/\"+userID+\"/groups\", \"GET\", nil, response)\n\treturn response, err\n}\n\nfunc (c *Client) call(endpoint, method string, request, response interface{}) error {\n\tdata, _ := json.Marshal(request)\n\n\tvar url = \"https://\" + c.org + \".\" + c.Url + \"/api/v1/\" + endpoint\n\treq, err := http.NewRequest(method, url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Add(\"Accept\", `application/json`)\n\treq.Header.Add(\"Content-Type\", `application/json`)\n\tif c.ApiToken != \"\" {\n\t\treq.Header.Add(\"Authorization\", \"SSWS \"+c.ApiToken)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode == http.StatusOK {\n\t\terr := json.Unmarshal(body, &response)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tvar errors ErrorResponse\n\t\terr = json.Unmarshal(body, &errors)\n\n\t\treturn &errorResponse{\n\t\t\tHTTPCode: resp.StatusCode,\n\t\t\tResponse: errors,\n\t\t\tEndpoint: url,\n\t\t}\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage oktaclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype AuthnResponse struct {\n\tStatus string `json:\"status\"`\n}\n\ntype SessionResponse struct {\n\tID string `json:\"id\"`\n}\n\ntype User struct {\n\tID       string   `json:\"id\"`\n\tProfile  Profile  `json:\"profile\"`\n\tPrimaryEmail string `json:\"primaryEmail\"`\n}\n\ntype Profile struct {\n\tFirstName string `json:\"firstName\"`\n\tLastName  string `json:\"lastName\"`\n}\n\ntype Groups struct {\n\tValues []Group `json:\"values\"`\n}\n\ntype Group struct {\n\tID    string `json:\"id\"`\n\tLabel string `json:\"label\"`\n}\n\ntype Client struct {\n\tclient  *http.Client\n\torg     string\n\tUrl     string\n\tApiToken string\n}\n\nfunc NewClient(org string) *Client {\n\treturn &Client{\n\t\tclient: http.DefaultClient,\n\t\torg:    org,\n\t\tUrl:    \"https://okta.com\",\n\t}\n}\n\nfunc (c *Client) Authenticate(username string, password string) (*AuthnResponse, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/authn\", c.Url)\n\tpayload := map[string]interface{}{\n\t\t\"username\": username,\n\t\t\"password\": password,\n\t\t\"_embedded\": map[string]interface{}{\n\t\t\t\"credentials\": map[string]interface{}{\n\t\t\t\t\"passcode\": nil,\n\t\t\t},\n\t\t},\n\t}\n\tvar authnResponse AuthnResponse\n\terr := c.call(url, \"POST\", payload, &authnResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &authnResponse, nil\n}\n\nfunc (c *Client) Session(sessionToken string) (*SessionResponse, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/sessions\", c.Url)\n\treq, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer([]byte{}))\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"SSWS %s\", c.ApiToken))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar sessionResponse SessionResponse\n\terr = json.NewDecoder(resp.Body).Decode(&sessionResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &sessionResponse, nil\n}\n\nfunc (c *Client) User(userID string) (*User, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/users/%s\", c.Url, userID)\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"SSWS %s\", c.ApiToken))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar user User\n\terr = json.NewDecoder(resp.Body).Decode(&user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\nfunc (c *Client) Groups(userID string) (*Groups, error) {\n\turl := fmt.Sprintf(\"%s/api/v1/users/%s/groups\", c.Url, userID)\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"SSWS %s\", c.ApiToken))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar groups Groups\n\terr = json.NewDecoder(resp.Body).Decode(&groups)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &groups, nil\n}\n\nfunc (c *Client) call(endpoint string, method string, request interface{}, response interface{}) error {\n\turl := fmt.Sprintf(\"%s%s\", c.Url, endpoint)\n\tjsonRequest, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, _ := http.NewRequest(method, url, bytes.NewBuffer(jsonRequest))\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"SSWS %s\", c.ApiToken))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"HTTP %d\", resp.StatusCode)\n\t}\n\terr = json.NewDecoder(resp.Body).Decode(response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Create a function that initializes and starts a gRPC server for management services, including setting up necessary dependencies and configurations.\n\nFunction Description: The function `startManagement` initializes and starts a gRPC server with management services. It sets up a temporary directory for data storage, configures the server with keepalive policies, initializes various managers and stores, and registers the management service. The server listens on a dynamically assigned port and runs in a goroutine.\n\nInput:\n- `t *testing.T`: Testing context for temporary directory creation and cleanup\n- `signalAddr string`: Address of the signal service\n- `counter *int`: Pointer to a counter for tracking server operations (used in mock implementation)\n\nOutput:\n- `*grpc.Server`: The created gRPC server instance\n- `string`: The address the server is listening on\n- `error`: Any error that occurred during initialization",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\tmgmtProto \"github.com/netbirdio/netbird/management/proto\"\n\t\"github.com/netbirdio/netbird/management/server\"\n\t\"github.com/netbirdio/netbird/management/server/activity\"\n\t\"github.com/netbirdio/netbird/management/server/settings\"\n\t\"github.com/netbirdio/netbird/management/server/store\"\n\t\"github.com/netbirdio/netbird/management/server/telemetry\"\n)\n\nvar (\n\tkaep = keepalive.EnforcementPolicy{\n\t\tMinTime:             15 * time.Second,\n\t\tPermitWithoutStream: true,\n\t}\n\n\tkasp = keepalive.ServerParameters{\n\t\tMaxConnectionIdle:     15 * time.Second,\n\t\tMaxConnectionAgeGrace: 5 * time.Second,\n\t\tTime:                  5 * time.Second,\n\t\tTimeout:               2 * time.Second,\n\t}\n)\n\nfunc startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\tt.Helper()\n\tdataDir := t.TempDir()\n\n\tconfig := &server.Config{\n\t\tStuns:      []*server.Host{},\n\t\tTURNConfig: &server.TURNConfig{},\n\t\tSignal: &server.Host{\n\t\t\tProto: \"http\",\n\t\t\tURI:   signalAddr,\n\t\t},\n\t\tDatadir:    dataDir,\n\t\tHttpConfig: nil,\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\ts := grpc.NewServer(grpc.KeepaliveEnforcementPolicy(kaep), grpc.KeepaliveParams(kasp))\n\tstore, cleanUp, err := store.NewTestStoreFromSQL(context.Background(), \"\", config.Datadir)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tt.Cleanup(cleanUp)\n\n\tpeersUpdateManager := server.NewPeersUpdateManager(nil)\n\teventStore := &activity.InMemoryEventStore{}\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tia, _ := integrations.NewIntegratedValidator(context.Background(), eventStore)\n\n\tmetrics, err := telemetry.NewDefaultAppMetrics(context.Background())\n\trequire.NoError(t, err)\n\n\taccountManager, err := server.BuildManager(context.Background(), store, peersUpdateManager, nil, \"\", \"netbird.selfhosted\", eventStore, nil, false, ia, metrics)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tsecretsManager := server.NewTimeBasedAuthSecretsManager(peersUpdateManager, config.TURNConfig, config.Relay)\n\tmgmtServer, err := server.NewServer(context.Background(), config, accountManager, settings.NewManager(store), peersUpdateManager, secretsManager, nil, nil)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tmock := &mockServer{\n\t\tManagementServiceServer: mgmtServer,\n\t\tcounter:                 counter,\n\t}\n\tmgmtProto.RegisterManagementServiceServer(s, mock)\n\tgo func() {\n\t\tif err = s.Serve(lis); err != nil {\n\t\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn s, lis.Addr().String(), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 119,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\tpb \"path/to/management/proto\"\n)\n\nfunc startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Server, string, error) {\n\t// Setup temporary directory for data storage\n\ttempDir, err := os.MkdirTemp(\"\", \"management-server-test\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Configure server with keepalive policies\n\tkp := keepalive.ServerParameters{\n\t\tTime:    10 * time.Second,\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\t// Initialize managers and stores\n\tdataStore := newDataStore(filepath.Join(tempDir, \"data.db\"))\n\tuserManager := newUserManager()\n\tauthManager := newAuthManager()\n\n\t// Register management service\n\tserver := grpc.NewServer(grpc.KeepaliveParams(kp))\n\tpb.RegisterManagementServiceServer(server, &managementServiceImpl{\n\t\tDataStore:   dataStore,\n\t\tUserManager: userManager,\n\t\tAuthManager: authManager,\n\t})\n\n\t// Listen on a dynamically assigned port\n\tlis, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\t// Start the server in a goroutine\n\tgo func() {\n\t\t*counter++\n\t\terr := server.Serve(lis)\n\t\tif err != nil && err != grpc.ErrServerStopped {\n\t\t\tt.Errorf(\"Failed to serve: %v\", err)\n\t\t}\n\t}()\n\n\treturn server, lis.Addr().String(), nil\n}\n```"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Implement a Redis-based session management system in Go that allows storing, retrieving, and managing HTTP session data using Redis as the backend storage.\n\nStruct Description: The implementation consists of two main structs - `SessionStore` for handling individual session operations and `Provider` for managing the Redis connection pool and session lifecycle.\n\nFields:\n\nSessionStore:\n- p: *redis.Pool - Redis connection pool\n- sid: string - Session ID\n- lock: sync.RWMutex - Read-write lock for thread safety\n- values: map[interface{}]interface{} - Key-value pairs storing session data\n- maxlifetime: int64 - Session expiration time in seconds\n\nProvider:\n- maxlifetime: int64 - Default session expiration time\n- savePath: string - Redis server address\n- poolsize: int - Connection pool size\n- password: string - Redis authentication password\n- dbNum: int - Redis database number\n- poollist: *redis.Pool - Redis connection pool instance\n\nMethods:\n\nSessionStore:\n- Set(key, value interface{}) error - Stores a key-value pair in the session\n- Get(key interface{}) interface{} - Retrieves a value by key from the session\n- Delete(key interface{}) error - Removes a key-value pair from the session\n- Flush() error - Clears all session data\n- SessionID() string - Returns the session ID\n- SessionRelease(w http.ResponseWriter) - Persists session data to Redis before closing\n\nProvider:\n- SessionInit(maxlifetime int64, savePath string) error - Initializes the Redis connection pool with configuration\n- SessionRead(sid string) (session.Store, error) - Retrieves session data from Redis\n- SessionExist(sid string) bool - Checks if a session exists in Redis\n- SessionRegenerate(oldsid, sid string) (session.Store, error) - Creates a new session ID while preserving data\n- SessionDestroy(sid string) error - Removes session data from Redis",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/astaxie/beego/session\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar redispder = &Provider{}\nvar MaxPoolSize = 100\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (rs *SessionStore) Set(key, value interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values[key] = value\n\treturn nil\n}\n\nfunc (rs *SessionStore) Get(key interface{}) interface{} {\n\trs.lock.RLock()\n\tdefer rs.lock.RUnlock()\n\tif v, ok := rs.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (rs *SessionStore) Delete(key interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\tdelete(rs.values, key)\n\treturn nil\n}\n\nfunc (rs *SessionStore) Flush() error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (rs *SessionStore) SessionID() string {\n\treturn rs.sid\n}\n\nfunc (rs *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tb, err := session.EncodeGob(rs.values)\n\tif err != nil {\n\t\treturn\n\t}\n\tc := rs.p.Get()\n\tdefer c.Close()\n\tc.Do(\"SETEX\", rs.sid, rs.maxlifetime, string(b))\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (rp *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\trp.maxlifetime = maxlifetime\n\tconfigs := strings.Split(savePath, \",\")\n\tif len(configs) > 0 {\n\t\trp.savePath = configs[0]\n\t}\n\tif len(configs) > 1 {\n\t\tpoolsize, err := strconv.Atoi(configs[1])\n\t\tif err != nil || poolsize <= 0 {\n\t\t\trp.poolsize = MaxPoolSize\n\t\t} else {\n\t\t\trp.poolsize = poolsize\n\t\t}\n\t} else {\n\t\trp.poolsize = MaxPoolSize\n\t}\n\tif len(configs) > 2 {\n\t\trp.password = configs[2]\n\t}\n\tif len(configs) > 3 {\n\t\tdbnum, err := strconv.Atoi(configs[3])\n\t\tif err != nil || dbnum < 0 {\n\t\t\trp.dbNum = 0\n\t\t} else {\n\t\t\trp.dbNum = dbnum\n\t\t}\n\t} else {\n\t\trp.dbNum = 0\n\t}\n\trp.poollist = redis.NewPool(func() (redis.Conn, error) {\n\t\tc, err := redis.Dial(\"tcp\", rp.savePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.password != \"\" {\n\t\t\tif _, err := c.Do(\"AUTH\", rp.password); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t_, err = c.Do(\"SELECT\", rp.dbNum)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t}, rp.poolsize)\n\n\treturn rp.poollist.Get().Err()\n}\n\nfunc (rp *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionExist(sid string) bool {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, err := redis.Int(c.Do(\"EXISTS\", sid)); err != nil || existed == 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (rp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, _ := redis.Int(c.Do(\"EXISTS\", oldsid)); existed == 0 {\n\t\tc.Do(\"SET\", sid, \"\", \"EX\", rp.maxlifetime)\n\t} else {\n\t\tc.Do(\"RENAME\", oldsid, sid)\n\t\tc.Do(\"EXPIRE\", sid, rp.maxlifetime)\n\t}\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionDestroy(sid string) error {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tc.Do(\"DEL\", sid)\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype SessionStore struct {\n\tp        *redis.Pool\n\tsid      string\n\tlock     sync.RWMutex\n\tvalues   map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc NewSessionStore(p *redis.Pool, sid string, maxlifetime int64) *SessionStore {\n\treturn &SessionStore{\n\t\tp:         p,\n\t\tsid:       sid,\n\t\tlock:      sync.RWMutex{},\n\t\tvalues:    make(map[interface{}]interface{}),\n\t\tmaxlifetime: maxlifetime,\n\t}\n}\n\nfunc (s *SessionStore) Set(key, value interface{}) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\ts.values[key] = value\n\treturn nil\n}\n\nfunc (s *SessionStore) Get(key interface{}) interface{} {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.values[key]\n}\n\nfunc (s *SessionStore) Delete(key interface{}) error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\tdelete(s.values, key)\n\treturn nil\n}\n\nfunc (s *SessionStore) Flush() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\ts.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (s *SessionStore) SessionID() string {\n\treturn s.sid\n}\n\nfunc (s *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tclient := s.p.Get()\n\tdefer client.Close()\n\terr := client.Set(context.Background(), s.sid, s.values, time.Duration(s.maxlifetime)*time.Second).Err()\n\tif err != nil {\n\t\tfmt.Println(\"Error saving session:\", err)\n\t}\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc NewProvider(maxlifetime int64, savePath string, poolsize int, password string, dbNum int) (*Provider, error) {\n\tpoollist := redis.NewPool(&redis.Options{\n\t\tAddr:     savePath,\n\t\tPassword: password,\n\t\tDB:       dbNum,\n\t\tPoolSize: poolsize,\n\t})\n\treturn &Provider{\n\t\tmaxlifetime: maxlifetime,\n\t\tsavePath:    savePath,\n\t\tpoolsize:    poolsize,\n\t\tpassword:    password,\n\t\tdbNum:       dbNum,\n\t\tpoollist:    poollist,\n\t}, nil\n}\n\nfunc (p *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\tp.maxlifetime = maxlifetime\n\tp.savePath = savePath\n\treturn nil\n}\n\nfunc (p *Provider) SessionRead(sid string) (session.Store, error) {\n\tclient := p.poollist.Get()\n\tdefer client.Close()\n\tval, err := client.Get(context.Background(), sid).Result()\n\tif err == redis.Nil {\n\t\treturn nil, fmt.Errorf(\"session not found\")\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewSessionStore(p.poollist, sid, p.maxlifetime), nil\n}\n\nfunc (p *Provider) SessionExist(sid string) bool {\n\tclient := p.poollist.Get()\n\tdefer client.Close()\n\texists, err := client.Exists(context.Background(), sid).Result()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn exists > 0\n}\n\nfunc (p *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tclient := p.poollist.Get()\n\tdefer client.Close()\n\terr := client.Del(context.Background(), oldsid).Err()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewSessionStore(p.poollist, sid, p.maxlifetime), nil\n}\n\nfunc (p *Provider) SessionDestroy(sid string) error {\n\tclient := p.poollist.Get()\n\tdefer client.Close()\n\treturn client.Del(context.Background(), sid).Err()\n}\n```"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool and methods for interacting with Redis, including setting, getting, deleting keys, and flushing the database.\n\nStruct Description: RedisStore is a struct that manages a connection pool to Redis and provides methods for common Redis operations with support for expiration times.\n\nFields:\n- pool: *redis.Pool - A connection pool to Redis for efficient connection reuse\n- defaultExpiration: time.Duration - The default expiration time for keys when not explicitly specified\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method for executing Redis commands with serialization and expiration handling",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage redisstore\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool            *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\treturn &RedisStore{\n\t\tpool: &redis.Pool{\n\t\t\tMaxIdle:     10,\n\t\t\tMinIdle:     2,\n\t\t\tIdleTimeout: 240 * time.Second,\n\t\t\tDialFunc: func() (redis.Conn, error) {\n\t\t\t\treturn redis.Dial(\"tcp\", host, redis.DialPassword(password))\n\t\t\t},\n\t\t},\n\t\tdefaultExpiration: defaultExpiration,\n\t}\n}\n\nfunc (rs *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn rs.invoke(rs.pool.Do, key, value, expires)\n}\n\nfunc (rs *RedisStore) Get(key string, ptrValue interface{}) error {\n\tval, err := rs.pool.Get(context.Background(), key).Result()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal([]byte(val), ptrValue)\n}\n\nfunc (rs *RedisStore) Delete(key string) error {\n\treturn rs.pool.Del(context.Background(), key).Err()\n}\n\nfunc (rs *RedisStore) Flush() error {\n\treturn rs.pool.FlushDB(context.Background()).Err()\n}\n\nfunc (rs *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tconn := rs.pool.Get()\n\tdefer conn.Close()\n\n\tvar val []byte\n\tvar err error\n\tif val, err = json.Marshal(value); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = f(conn, \"SET\", key, val, \"EX\", int(expires.Seconds())); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Redis client struct in Go that manages connections to Redis servers and provides common Redis operations. The implementation should use connection pooling and support thread-safe access to multiple Redis instances.\n\nStruct Description: RedisClient is a struct that encapsulates Redis connection pooling and provides methods for common Redis operations. It maintains a thread-safe map of Redis clients for different server addresses.\n\nFields:\n\npool: *redis.Pool - The connection pool for Redis operations\nAddress: string - The Redis server address (URL)\n\nMethods:\n\nGetRedisClient: (address string, maxIdle int, maxActive int) -> *RedisClient - Retrieves or creates a Redis client for the given address with specified pool settings\nGet: (key string) -> (string, error) - Retrieves the value for a given key from Redis\nSet: (key string, val interface{}) -> (interface{}, error) - Sets the value for a given key in Redis\nLPush: (key string, value ...interface{}) -> (int, error) - Pushes values to the left of a Redis list\nLPop: (key string) -> (string, error) - Pops a value from the left of a Redis list\nHSet: (hashID string, field string, val string) -> error - Sets a field in a Redis hash\nHGet: (hashID string, field string) -> (string, error) - Gets a field from a Redis hash",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar (\n\tredisMap map[string]*RedisClient\n\tmapMutex *sync.RWMutex\n)\n\nconst (\n\tdefaultMaxIdle   = 10\n\tdefaultMaxActive = 50\n)\n\nfunc init() {\n\tredisMap = make(map[string]*RedisClient)\n\tmapMutex = new(sync.RWMutex)\n}\n\nfunc newPool(redisURL string, maxIdle, maxActive int) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxIdle:   maxIdle,\n\t\tMaxActive: maxActive,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(redisURL)\n\t\t\treturn c, err\n\t\t},\n\t}\n}\n\nfunc GetRedisClient(address string, maxIdle, maxActive int) *RedisClient {\n\tif maxIdle <= 0 {\n\t\tmaxIdle = defaultMaxIdle\n\t}\n\tif maxActive <= 0 {\n\t\tmaxActive = defaultMaxActive\n\t}\n\tvar redis *RedisClient\n\tvar mok bool\n\tmapMutex.RLock()\n\tredis, mok = redisMap[address]\n\tmapMutex.RUnlock()\n\tif !mok {\n\t\tredis = &RedisClient{Address: address, pool: newPool(address, maxIdle, maxActive)}\n\t\tmapMutex.Lock()\n\t\tredisMap[address] = redis\n\t\tmapMutex.Unlock()\n\t}\n\treturn redis\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"GET\", key)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"SET\", key, val))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tret, err := redis.Int(conn.Do(\"LPUSH\", key, value))\n\treturn ret, err\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\tval, err := redis.String(conn.Do(\"LPOP\", key))\n\treturn val, err\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"HSET\", hashID, field, val)\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tconn := rc.pool.Get()\n\tdefer conn.Close()\n\treply, errDo := conn.Do(\"HGET\", hashID, field)\n\tval, err := redis.String(reply, errDo)\n\treturn val, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"sync\"\n)\n\ntype RedisClient struct {\n\tpool    *redis.Pool\n\tAddress string\n}\n\nvar redisClients = sync.Map{}\n\nfunc GetRedisClient(address string, maxIdle int, maxActive int) (*RedisClient, error) {\n\tclient, ok := redisClients.Load(address)\n\tif !ok {\n\t\tctx := context.Background()\n\t\trdb := redis.NewClient(&redis.Options{\n\t\t\tAddr:     address,\n\t\t\tPassword: \"\", // no password set\n\t\t\tDB:       0,  // use default DB\n\t\t\tPoolSize: maxActive,\n\t\t})\n\n\t\terr := rdb.Ping(ctx).Err()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tnewClient := &RedisClient{\n\t\t\tpool:    redis.NewPool(func() (redis.Conn, error) { return rdb.DialContext(ctx) }, maxIdle),\n\t\t\tAddress: address,\n\t\t}\n\t\tredisClients.Store(address, newClient)\n\t\tclient = newClient\n\t}\n\treturn client.(*RedisClient), nil\n}\n\nfunc (rc *RedisClient) Get(key string) (string, error) {\n\tctx := context.Background()\n\tval, err := rc.pool.Get().Do(ctx, \"GET\", key).Result()\n\tif err == redis.Nil {\n\t\treturn \"\", fmt.Errorf(\"key %s does not exist\", key)\n\t} else if err != nil {\n\t\treturn \"\", err\n\t}\n\treturn val.(string), nil\n}\n\nfunc (rc *RedisClient) Set(key string, val interface{}) (interface{}, error) {\n\tctx := context.Background()\n\tresult, err := rc.pool.Get().Do(ctx, \"SET\", key, val).Result()\n\treturn result, err\n}\n\nfunc (rc *RedisClient) LPush(key string, value ...interface{}) (int, error) {\n\tctx := context.Background()\n\tresult, err := rc.pool.Get().Do(ctx, \"LPUSH\", key, value).Result()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int(result.(int64)), nil\n}\n\nfunc (rc *RedisClient) LPop(key string) (string, error) {\n\tctx := context.Background()\n\tresult, err := rc.pool.Get().Do(ctx, \"LPOP\", key).Result()\n\tif err == redis.Nil {\n\t\treturn \"\", fmt.Errorf(\"list %s is empty\", key)\n\t} else if err != nil {\n\t\treturn \"\", err\n\t}\n\treturn result.(string), nil\n}\n\nfunc (rc *RedisClient) HSet(hashID string, field string, val string) error {\n\tctx := context.Background()\n\terr := rc.pool.Get().Do(ctx, \"HSET\", hashID, field, val).Err()\n\treturn err\n}\n\nfunc (rc *RedisClient) HGet(hashID string, field string) (string, error) {\n\tctx := context.Background()\n\tval, err := rc.pool.Get().Do(ctx, \"HGET\", hashID, field).Result()\n\tif err == redis.Nil {\n\t\treturn \"\", fmt.Errorf(\"field %s does not exist in hash %s\", field, hashID)\n\t} else if err != nil {\n\t\treturn \"\", err\n\t}\n\treturn val.(string), nil\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Go client for interacting with an InfluxDB server, supporting both querying and writing data with configurable settings like authentication, timeout, and TLS.\n\nStruct Description: The Client struct represents an InfluxDB client with configuration for server connection, authentication, and HTTP transport settings.\n\nFields:\n- url: url.URL - The base URL of the InfluxDB server\n- username: string - Username for basic authentication\n- password: string - Password for basic authentication\n- httpClient: *http.Client - Custom HTTP client with timeout and transport settings\n- userAgent: string - User agent string for HTTP requests\n- precision: string - Precision for timestamps in queries and writes\n\nMethods:\n- NewClient: [Name](Config) -> (*Client, error) - Creates a new InfluxDB client with the given configuration\n- Query: [Name](Query) -> (*Response, error) - Executes a query against the InfluxDB server and returns the response\n- Write: [Name](BatchPoints) -> (*Response, error) - Writes batch points to the InfluxDB server and returns the response",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\turl        url.URL\n\tusername   string\n\tpassword   string\n\thttpClient *http.Client\n\tuserAgent  string\n\tprecision  string\n}\n\nfunc NewClient(c Config) (*Client, error) {\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: c.UnsafeSsl,\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: tlsConfig,\n\t}\n\n\tclient := Client{\n\t\turl:        c.URL,\n\t\tusername:   c.Username,\n\t\tpassword:   c.Password,\n\t\thttpClient: &http.Client{Timeout: c.Timeout, Transport: tr},\n\t\tuserAgent:  c.UserAgent,\n\t\tprecision:  c.Precision,\n\t}\n\tif client.userAgent == \"\" {\n\t\tclient.userAgent = \"InfluxDBClient\"\n\t}\n\treturn &client, nil\n}\n\nfunc (c *Client) Query(q Query) (*Response, error) {\n\tu := c.url\n\n\tu.Path = \"query\"\n\tvalues := u.Query()\n\tvalues.Set(\"q\", q.Command)\n\tvalues.Set(\"db\", q.Database)\n\tif q.Chunked {\n\t\tvalues.Set(\"chunked\", \"true\")\n\t\tif q.ChunkSize > 0 {\n\t\t\tvalues.Set(\"chunk_size\", strconv.Itoa(q.ChunkSize))\n\t\t}\n\t}\n\tif c.precision != \"\" {\n\t\tvalues.Set(\"epoch\", c.precision)\n\t}\n\tu.RawQuery = values.Encode()\n\n\treq, err := http.NewRequest(\"GET\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tif q.Chunked {\n\t\tcr := NewChunkedResponse(resp.Body)\n\t\tfor {\n\t\t\tr, err := cr.NextResponse()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif r == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresponse.Results = append(response.Results, r.Results...)\n\t\t\tif r.Err != nil {\n\t\t\t\tresponse.Err = r.Err\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdec := json.NewDecoder(resp.Body)\n\t\tdec.UseNumber()\n\t\tif err := dec.Decode(&response); err != nil {\n\t\t\tif !(err == io.EOF && resp.StatusCode != http.StatusOK) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif resp.StatusCode != http.StatusOK && response.Error() == nil {\n\t\treturn &response, fmt.Errorf(\"received status code %d from server\", resp.StatusCode)\n\t}\n\treturn &response, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\tu := c.url\n\tu.Path = \"write\"\n\n\tvar b bytes.Buffer\n\tfor _, p := range bp.Points {\n\t\terr := checkPointTypes(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Raw != \"\" {\n\t\t\tif _, err := b.WriteString(p.Raw); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tfor k, v := range bp.Tags {\n\t\t\t\tif p.Tags == nil {\n\t\t\t\t\tp.Tags = make(map[string]string, len(bp.Tags))\n\t\t\t\t}\n\t\t\t\tp.Tags[k] = v\n\t\t\t}\n\n\t\t\tif _, err := b.WriteString(p.MarshalString()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif err := b.WriteByte('\\n'); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(\"POST\", u.String(), &b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"\")\n\treq.Header.Set(\"User-Agent\", c.userAgent)\n\tif c.username != \"\" {\n\t\treq.SetBasicAuth(c.username, c.password)\n\t}\n\n\tprecision := bp.Precision\n\tif precision == \"\" {\n\t\tprecision = c.precision\n\t}\n\n\tparams := req.URL.Query()\n\tparams.Set(\"db\", bp.Database)\n\tparams.Set(\"rp\", bp.RetentionPolicy)\n\tparams.Set(\"precision\", precision)\n\tparams.Set(\"consistency\", bp.WriteConsistency)\n\treq.URL.RawQuery = params.Encode()\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {\n\t\tvar err = fmt.Errorf(string(body))\n\t\tresponse.Err = err\n\t\treturn &response, err\n\t}\n\n\treturn nil, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage influxdb\n\nimport (\n\t\"net/url\"\n\t\"time\"\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\ntype Config struct {\n\tURL      string\n\tUsername string\n\tPassword string\n\tTimeout  time.Duration\n\tTLSConfig *tls.Config\n\tUserAgent string\n\tPrecision string\n}\n\ntype Client struct {\n\turl         *url.URL\n\tusername    string\n\tpassword    string\n\thttpClient  *http.Client\n\tuserAgent   string\n\tprecision   string\n}\n\nfunc NewClient(config Config) (*Client, error) {\n\tu, err := url.Parse(config.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient := &Client{\n\t\turl:        u,\n\t\tusername:   config.Username,\n\t\tpassword:   config.Password,\n\t\thttpClient: &http.Client{Timeout: config.Timeout},\n\t\tuserAgent:  config.UserAgent,\n\t\tprecision:  config.Precision,\n\t}\n\tif config.TLSConfig != nil {\n\t\tclient.httpClient.Transport = &http.Transport{TLSClientConfig: config.TLSConfig}\n\t}\n\treturn client, nil\n}\n\nfunc (c *Client) Query(q Query) (*Response, error) {\n\t// Implementation for executing a query\n\treturn nil, nil\n}\n\nfunc (c *Client) Write(bp BatchPoints) (*Response, error) {\n\t// Implementation for writing batch points\n\treturn nil, nil\n}\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function to fetch video materials from an advertising API using HTTP requests with custom headers and process the response.\n\nFunction Description: The function `getVideo` makes a GET request to a specified API endpoint to retrieve video materials for a given advertiser. It handles request creation, header addition, response processing, and error handling. The response is parsed to extract video information and store it in a global map while returning pagination information.\n\nInput:\n- advertiserId: string - The ID of the advertiser whose videos are being requested\n- page: int - The page number for paginated results\n\nOutput:\n- int - Total number of pages available (for pagination)\n- error - Any error encountered during the HTTP request or response processing",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar videoImageIdMaterialIdMap = map[string]int64{}\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\turl := \"https://ad.oceanengine.com/open_api/2/file/video/get/\"\n\tmethod := \"GET\"\n\tpayload := strings.NewReader(fmt.Sprintf(`{\n    \t\t\t\"advertiser_id\": %s,\n   \t\t\t\t \"page\":%d,\n   \t\t\t\t \"page_size\":100}`, advertiserId, page))\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(method, url, payload)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treq.Header.Add(\"Access-Token\", \"c0bfed085c0dbc19bb2e41920ecd6d2a6d398b32\")\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar getVideoMaterialResp GetVideoMaterialResp\n\terr = json.Unmarshal(body, &getVideoMaterialResp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif getVideoMaterialResp.Code != 0 {\n\t\treturn 0, err\n\t}\n\tfor _, s := range getVideoMaterialResp.Data.List {\n\t\tvideoImageIdMaterialIdMap[s.Id] = s.MaterialId\n\t}\n\treturn getVideoMaterialResp.Data.PageInfo.TotalPage, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype Video struct {\n\tID    string `json:\"id\"`\n\tTitle string `json:\"title\"`\n\tURL   string `json:\"url\"`\n}\n\nvar videoMap = sync.Map{}\n\nfunc getVideo(advertiserId string, page int) (int, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", fmt.Sprintf(\"https://api.advertising.com/videos?advertiser_id=%s&page=%d\", advertiserId, page), nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treq.Header.Add(\"Authorization\", \"Bearer your_access_token\")\n\treq.Header.Add(\"User-Agent\", \"YourAppName\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response struct {\n\t\tVideos []Video `json:\"videos\"`\n\t\tPages  int     `json:\"pages\"`\n\t}\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, v := range response.Videos {\n\t\tvideoMap.Store(uuid.New().String(), v)\n\t}\n\n\treturn response.Pages, nil\n}\n```"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a RedisStore struct in Go that provides a connection pool to interact with a Redis server, supporting common operations like Set, Get, Delete, and Flush with configurable expiration times.\n\nStruct Description: RedisStore is a struct that manages a pool of Redis connections and provides methods to interact with Redis, including setting, getting, deleting keys, and flushing the database. It supports configurable expiration times for cached items.\n\nFields:\n- pool: *redis.Pool - A connection pool to manage Redis connections efficiently\n- defaultExpiration: time.Duration - The default expiration time for cached items\n\nMethods:\n- NewRedisCache: (host string, password string, defaultExpiration time.Duration) -> *RedisStore - Creates a new RedisStore instance with connection pool and default expiration\n- Set: (key string, value interface{}, expires time.Duration) -> error - Sets a key-value pair in Redis with optional expiration\n- Get: (key string, ptrValue interface{}) -> error - Retrieves a value from Redis and deserializes it into ptrValue\n- Delete: (key string) -> error - Deletes a key from Redis\n- Flush: () -> error - Flushes all keys from the Redis database\n- invoke: (f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) -> error - Internal method to handle Redis operations with expiration logic",
    "Canonical_solution": "import (\n\t\"github.com/garyburd/redigo/redis\"\n\t\"time\"\n)\n\ntype RedisStore struct {\n\tpool              *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) *RedisStore {\n\tvar pool = &redis.Pool{\n\t\tMaxIdle:     5,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(password) > 0 {\n\t\t\t\tif _, err := c.Do(\"AUTH\", password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\treturn &RedisStore{pool, defaultExpiration}\n}\n\nfunc (c *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn c.invoke(c.pool.Get().Do, key, value, expires)\n}\n\nfunc (c *RedisStore) Get(key string, ptrValue interface{}) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\traw, err := conn.Do(\"GET\", key)\n\tif raw == nil {\n\t\treturn ErrCacheMiss\n\t}\n\titem, err := redis.Bytes(raw, err)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn deserialize(item, ptrValue)\n}\n\nfunc (c *RedisStore) Delete(key string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif !exists(conn, key) {\n\t\treturn ErrCacheMiss\n\t}\n\t_, err := conn.Do(\"DEL\", key)\n\treturn err\n}\n\nfunc (c *RedisStore) Flush() error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\t_, err := conn.Do(\"FLUSHALL\")\n\treturn err\n}\n\nfunc (c *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error),\n\tkey string, value interface{}, expires time.Duration) error {\n\n\tswitch expires {\n\tcase DEFAULT:\n\t\texpires = c.defaultExpiration\n\tcase FOREVER:\n\t\texpires = time.Duration(0)\n\t}\n\n\tb, err := serialize(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\tif expires > 0 {\n\t\t_, err := f(\"SETEX\", key, int32(expires/time.Second), b)\n\t\treturn err\n\t} else {\n\t\t_, err := f(\"SET\", key, b)\n\t\treturn err\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 126,
    "wrong_result": "```go\npackage redisstore\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\ntype RedisStore struct {\n\tpool            *redis.Pool\n\tdefaultExpiration time.Duration\n}\n\nfunc NewRedisCache(host string, password string, defaultExpiration time.Duration) (*RedisStore, error) {\n\tctx := context.Background()\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     host,\n\t\tPassword: password,\n\t\tDB:       0,\n\t})\n\n\tif err := client.Ping(ctx).Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to Redis: %w\", err)\n\t}\n\n\treturn &RedisStore{\n\t\tpool:            &redis.Pool{MaxIdle: 10, MinIdle: 2, Dial: func() (redis.Conn, error) { return client.Dial() }},\n\t\tdefaultExpiration: defaultExpiration,\n\t}, nil\n}\n\nfunc (rs *RedisStore) Set(key string, value interface{}, expires time.Duration) error {\n\treturn rs.invoke(func(k string, v interface{}) (interface{}, error) {\n\t\treturn rs.pool.Get(context.Background()).Set(k, v, expires).Result()\n\t}, key, value, expires)\n}\n\nfunc (rs *RedisStore) Get(key string, ptrValue interface{}) error {\n\treturn rs.invoke(func(k string, _ interface{}) (interface{}, error) {\n\t\tval, err := rs.pool.Get(context.Background()).Get(k).Result()\n\t\tif err == redis.Nil {\n\t\t\treturn nil, fmt.Errorf(\"key does not exist\")\n\t\t}\n\t\treturn val, err\n\t}, key, ptrValue, 0)\n}\n\nfunc (rs *RedisStore) Delete(key string) error {\n\treturn rs.invoke(func(k string, _ interface{}) (interface{}, error) {\n\t\treturn rs.pool.Get(context.Background()).Del(k).Result()\n\t}, key, nil, 0)\n}\n\nfunc (rs *RedisStore) Flush() error {\n\treturn rs.invoke(func(_ string, _ interface{}) (interface{}, error) {\n\t\treturn rs.pool.Get(context.Background()).FlushDB().Result()\n\t}, \"\", nil, 0)\n}\n\nfunc (rs *RedisStore) invoke(f func(string, ...interface{}) (interface{}, error), key string, value interface{}, expires time.Duration) error {\n\tconn := rs.pool.Get(context.Background())\n\tdefer conn.Close()\n\n\tresult, err := f(key, value)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Redis operation failed: %w\", err)\n\t}\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Go struct that implements a RocketMQ push consumer with configurable options, message handling, and tracing capabilities.\n\nStruct Description: The PushConsumer struct encapsulates a RocketMQ push consumer with additional features like rate limiting, tracing, and message processing. It manages consumer lifecycle and message subscription.\n\nFields:\n\nname: string - Name identifier for the consumer  \nPushConsumer: rocketmq.PushConsumer - Embedded RocketMQ push consumer instance  \nPushConsumerConfig: PushConsumerConfig - Configuration for the consumer  \nsubscribers: map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error) - Map of topic to message handler functions  \ninterceptors: []primitive.Interceptor - List of interceptors for message processing  \nbucket: *ratelimit.Bucket - Rate limiter bucket for controlling consumption rate  \nstarted: bool - Flag indicating if consumer is running  \n\nMethods:\n\nRegisterSingleMessage: (f func(context.Context, *primitive.MessageExt) error) -> *PushConsumer - Registers a single message handler function with tracing and panic recovery  \nStart: () -> error - Initializes and starts the RocketMQ consumer with configured options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"runtime/debug\"\n\n\t\"github.com/apache/rocketmq-client-go/v2\"\n\t\"github.com/apache/rocketmq-client-go/v2/consumer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/juju/ratelimit\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\tsemconv \"go.opentelemetry.io/otel/semconv/v1.12.0\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype PushConsumer struct {\n\trocketmq.PushConsumer\n\tname string\n\tPushConsumerConfig\n\n\tsubscribers  map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)\n\tinterceptors []primitive.Interceptor\n\tbucket       *ratelimit.Bucket\n\tstarted      bool\n}\n\nfunc (cc *PushConsumer) RegisterSingleMessage(f func(context.Context, *primitive.MessageExt) error) *PushConsumer {\n\ttracer := xtrace.NewTracer(trace.SpanKindConsumer)\n\tattrs := []attribute.KeyValue{\n\t\tsemconv.MessagingSystemKey.String(\"rocketmq\"),\n\t\tsemconv.MessagingRocketmqClientGroupKey.String(cc.Group),\n\t\tsemconv.MessagingRocketmqClientIDKey.String(cc.InstanceName),\n\t\tsemconv.MessagingRocketmqConsumptionModelKey.String(cc.MessageModel),\n\t}\n\n\tfn := func(ctx context.Context, msgs ...*primitive.MessageExt) (result consumer.ConsumeResult, err error) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tresult, err = consumer.ConsumeRetryLater, errors.New(\"consumer message panic\")\n\t\t\t}\n\t\t}()\n\t\tfor _, msg := range msgs {\n\t\t\tvar (\n\t\t\t\tspan trace.Span\n\t\t\t)\n\n\t\t\tif cc.EnableTrace {\n\t\t\t\tcarrier := propagation.MapCarrier{}\n\t\t\t\tfor key, value := range msg.GetProperties() {\n\t\t\t\t\tcarrier[key] = value\n\t\t\t\t}\n\t\t\t\tctx, span = tracer.Start(ctx, msg.Topic, carrier, trace.WithAttributes(attrs...))\n\t\t\t\tspan.SetAttributes(\n\t\t\t\t\tsemconv.MessagingRocketmqNamespaceKey.String(msg.Topic),\n\t\t\t\t\tsemconv.MessagingRocketmqMessageTagKey.String(msg.GetTags()),\n\t\t\t\t)\n\t\t\t\tdefer span.End()\n\t\t\t}\n\n\t\t\tif cc.bucket != nil {\n\t\t\t\tif ok := cc.bucket.WaitMaxDuration(1, cc.WaitMaxDuration); !ok {\n\t\t\t\t\treturn consumer.ConsumeRetryLater, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := f(ctx, msg); err != nil {\n\t\t\t\tif cc.EnableTrace && span != nil {\n\t\t\t\t\tspan.RecordError(err)\n\t\t\t\t}\n\t\t\t\treturn consumer.ConsumeRetryLater, err\n\t\t\t}\n\t\t}\n\t\treturn consumer.ConsumeSuccess, nil\n\t}\n\tcc.subscribers[cc.Topic] = fn\n\treturn cc\n}\n\nfunc (cc *PushConsumer) Start() error {\n\tif cc.started {\n\t\treturn nil\n\t}\n\n\tvar opts = []consumer.Option{\n\t\tconsumer.WithGroupName(cc.Group),\n\t\tconsumer.WithInstance(cc.InstanceName),\n\t\tconsumer.WithNameServer(cc.Addr),\n\t\tconsumer.WithMaxReconsumeTimes(cc.Reconsume),\n\t\tconsumer.WithInterceptor(cc.interceptors...),\n\t\tconsumer.WithConsumeMessageBatchMaxSize(cc.ConsumeMessageBatchMaxSize),\n\t\tconsumer.WithPullBatchSize(cc.PullBatchSize),\n\t\tconsumer.WithConsumeGoroutineNums(cc.ConsumeGoroutineNums),\n\t\tconsumer.WithCredentials(primitive.Credentials{\n\t\t\tAccessKey: cc.AccessKey,\n\t\t\tSecretKey: cc.SecretKey,\n\t\t}),\n\t}\n\tif cc.PushConsumerConfig.MessageModel == \"BroadCasting\" {\n\t\topts = append(opts, consumer.WithConsumerModel(consumer.BroadCasting))\n\t}\n\n\tclient, err := rocketmq.NewPushConsumer(opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcc.PushConsumer = client\n\n\tselector := consumer.MessageSelector{\n\t\tType:       consumer.TAG,\n\t\tExpression: \"\",\n\t}\n\tif cc.PushConsumerConfig.SubExpression != \"*\" {\n\t\tselector.Expression = cc.PushConsumerConfig.SubExpression\n\t}\n\n\tfor topic, fn := range cc.subscribers {\n\t\tif err := cc.PushConsumer.Subscribe(topic, selector, fn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif cc.Enable {\n\t\tif err := client.Start(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcc.started = true\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 128,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"github.com/apache/rocketmq-client-go/v2/consumer\"\n\t\"github.com/apache/rocketmq-client-go/v2/primitive\"\n\t\"github.com/uber-go/tally/v4\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype PushConsumerConfig struct {\n\tName         string\n\tBrokerAddr   string\n\tGroupName    string\n\tRetry        int\n\tConcurrency  int\n\tTraceEnabled bool\n}\n\ntype PushConsumer struct {\n\tname            string\n\tPushConsumer     consumer.PushConsumer\n\tPushConsumerConfig PushConsumerConfig\n\tsubscribers      map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)\n\tinterceptors     []primitive.Interceptor\n\tbucket           *rate.Limiter\n\tstarted          bool\n}\n\nfunc NewPushConsumer(config PushConsumerConfig) (*PushConsumer, error) {\n\tpushConsumer, err := consumer.NewPushConsumer(\n\t\tconsumer.WithNsResolver(primitive.NewPassthroughResolver([]string{config.BrokerAddr})),\n\t\tconsumer.WithRetry(config.Retry),\n\t\tconsumer.WithConcurrentConsumers(config.Concurrency),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PushConsumer{\n\t\tname:            config.Name,\n\t\tPushConsumer:     pushConsumer,\n\t\tPushConsumerConfig: config,\n\t\tsubscribers:      make(map[string]func(context.Context, ...*primitive.MessageExt) (consumer.ConsumeResult, error)),\n\t\tinterceptors:     []primitive.Interceptor{},\n\t\tbucket:           rate.NewLimiter(rate.Inf, 0),\n\t\tstarted:          false,\n\t}, nil\n}\n\nfunc (c *PushConsumer) RegisterSingleMessage(topic string, f func(context.Context, *primitive.MessageExt) error) *PushConsumer {\n\tc.subscribers[topic] = func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) {\n\t\tfor _, msg := range msgs {\n\t\t\tif c.bucket.Allow() {\n\t\t\t\terr := f(ctx, msg)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn consumer.ConsumeFailure, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn consumer.ConsumeFailure, tally.NewError(\"Rate limit exceeded\", nil)\n\t\t\t}\n\t\t}\n\t\treturn consumer.ConsumeSuccess, nil\n\t}\n\treturn c\n}\n\nfunc (c *PushConsumer) Start() error {\n\tif c.started {\n\t\treturn nil\n\t}\n\ttopics := make([]string, 0, len(c.subscribers))\n\tfor topic := range c.subscribers {\n\t\ttopics = append(topics, topic)\n\t}\n\terr := c.PushConsumer.Subscribe(topics, c.subscribers)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.started = true\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a stock quote service that retrieves stock information from an external API and processes the response.\n\nStruct Description: The Stock struct represents a service for fetching stock quotes. It contains configuration fields for API access and implements methods to retrieve quote information.\n\nFields:\nApi: [string] - The base URL of the stock API service\nKey: [string] - The API key used for authentication with the stock service\n\nMethods:\nQuote: [Name](ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) -> [error] - Retrieves stock quote information for a given symbol. Validates the input symbol, makes an HTTP GET request to the stock API, processes the response, and populates the response object with the quote data. Returns error if any step fails.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/stock/proto\"\n)\n\ntype Stock struct {\n\tApi   string\n\tKey   string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif len(req.Symbol) <= 0 || len(req.Symbol) > 5 {\n\t\treturn errors.BadRequest(\"stock.quote\", \"invalid symbol\")\n\t}\n\n\turi := fmt.Sprintf(\"%slast/stock/%s?apikey=%s\", s.Api, req.Symbol, s.Key)\n\n\tresp, err := http.Get(uri)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to get quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\tdefer resp.Body.Close()\n\n\tb, _ := ioutil.ReadAll(resp.Body)\n\n\tif resp.StatusCode != 200 {\n\t\tlogger.Errorf(\"Failed to get quote (non 200): %d %v\\n\", resp.StatusCode, string(b))\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\tvar respBody struct {\n\t\tSymbol    string\n\t\tAsk       float64\n\t\tBid       float64\n\t\tAsize     int32\n\t\tBsize     int32\n\t\tTimestamp int64\n\t}\n\n\tif err := json.Unmarshal(b, &respBody); err != nil {\n\t\tlogger.Errorf(\"Failed to unmarshal quote: %v\\n\", err)\n\t\treturn errors.InternalServerError(\"stock.quote\", \"failed to get quote\")\n\t}\n\n\trsp.Symbol = respBody.Symbol\n\trsp.AskPrice = respBody.Ask\n\trsp.BidPrice = respBody.Bid\n\trsp.AskSize = respBody.Asize\n\trsp.BidSize = respBody.Bsize\n\trsp.Timestamp = respBody.Timestamp\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\tpb \"path/to/protobuf/package\"\n)\n\ntype Stock struct {\n\tApi string\n\tKey string\n}\n\nfunc (s *Stock) Quote(ctx context.Context, req *pb.QuoteRequest, rsp *pb.QuoteResponse) error {\n\tif len(req.Symbol) == 0 {\n\t\treturn fmt.Errorf(\"symbol cannot be empty\")\n\t}\n\n\turl := fmt.Sprintf(\"%s/%s?api_key=%s\", s.Api, req.Symbol, s.Key)\n\tclient := &http.Client{Timeout: 5 * time.Second}\n\tresp, err := client.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Process the response and populate rsp with the quote data\n\t// Example: json.NewDecoder(resp.Body).Decode(rsp)\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL with optional custom headers and client configuration, while implementing safety measures like response size limiting and proper resource cleanup.\n\nFunction Description: The function `ReadURL` makes an HTTP GET request to the specified URL using a provided HTTP client and optional headers. It ensures proper resource cleanup, checks for successful response status, limits the maximum readable response size, and returns the response body or an error if any step fails.\n\nInput:\n- `url` [string] - The URL to send the GET request to\n- `client` [*http.Client] - The HTTP client to use for the request (can be nil to use http.DefaultClient)\n- `header` [*http.Header] - Optional headers to include in the request (can be nil)\n\nOutput:\n- `body` [[]byte] - The response body if the request is successful\n- `err` [error] - An error object if any step fails, including:\n  - Request creation failure\n  - Network errors\n  - Non-200 status codes (wrapped in HTTPError)\n  - Read errors\n  - Response size exceeding limit",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tmaxReadLength = 10 * 1 << 20\n)\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) (body []byte, err error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{\n\t\t\tStatusCode: resp.StatusCode,\n\t\t\tURL:        url,\n\t\t}\n\t}\n\n\tlimitedReader := &io.LimitedReader{R: resp.Body, N: maxReadLength}\n\tcontents, err := ioutil.ReadAll(limitedReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif limitedReader.N <= 0 {\n\t\treturn nil, errors.New(\"the read limit is reached\")\n\t}\n\n\treturn contents, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype HTTPError struct {\n\tStatus string\n\tCode   int\n}\n\nfunc (e *HTTPError) Error() string {\n\treturn e.Status\n}\n\nconst MaxResponseSize = 10 * 1024 * 1024 // 10MB\n\nfunc ReadURL(url string, client *http.Client, header *http.Header) ([]byte, error) {\n\tif client == nil {\n\t\tclient = &http.Client{Timeout: time.Second * 30}\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif header != nil {\n\t\treq.Header = *header\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, &HTTPError{Status: resp.Status, Code: resp.StatusCode}\n\t}\n\n\tvar buf bytes.Buffer\n\tlimitReader := io.LimitReader(resp.Body, MaxResponseSize)\n\t_, err = buf.ReadFrom(limitReader)\n\tif err != nil && err != io.EOF {\n\t\treturn nil, err\n\t}\n\n\tif limitReader.(*io.LimitedReader).N < MaxResponseSize {\n\t\treturn buf.Bytes(), nil\n\t} else {\n\t\treturn nil, fmt.Errorf(\"response size exceeds limit\")\n\t}\n}\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: The task involves creating a struct and associated method to handle chunked file uploads to a remote server using HTTP PUT requests with proper content range headers.\n\nStruct Description: The UploadSession struct represents an ongoing file upload session, tracking upload state, metadata, and providing methods for chunked upload operations.\n\nFields:\n\nID: string - Unique identifier for the upload session\nOldID: string - Previous session ID (if applicable)\nParentID: string - ID of parent directory\nNodeID: uint64 - Filesystem node identifier\nName: string - Name of the file being uploaded\nExpirationDateTime: time.Time - When the upload session expires\nSize: uint64 - Total size of the file in bytes\nData: []byte - File content data being uploaded\nQuickXORHash: string - File content hash\nModTime: time.Time - File modification time\nretries: int - Number of upload retry attempts\nUploadURL: string - Server endpoint for chunk uploads\nETag: string - Entity tag from server response\nstate: int - Current upload state\nerror: error - Last encountered error\nsync.Mutex: - Mutex for thread-safe operations\n\nMethods:\n\nuploadChunk: (auth *graph.Auth, offset uint64) -> ([]byte, int, error) - Uploads a file chunk starting at specified offset. Returns response body, HTTP status code, and error if any. Handles authentication refresh and proper Content-Range headers.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/jstaf/onedriver/fs/graph\"\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype UploadSession struct {\n\tID                 string    `json:\"id\"`\n\tOldID              string    `json:\"oldID\"`\n\tParentID           string    `json:\"parentID\"`\n\tNodeID             uint64    `json:\"nodeID\"`\n\tName               string    `json:\"name\"`\n\tExpirationDateTime time.Time `json:\"expirationDateTime\"`\n\tSize               uint64    `json:\"size,omitempty\"`\n\tData               []byte    `json:\"data,omitempty\"`\n\tQuickXORHash       string    `json:\"quickxorhash,omitempty\"`\n\tModTime            time.Time `json:\"modTime,omitempty\"`\n\tretries            int\n\n\tsync.Mutex\n\tUploadURL string `json:\"uploadUrl\"`\n\tETag      string `json:\"eTag,omitempty\"`\n\tstate     int\n\terror\n}\n\nfunc (u *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tu.Lock()\n\turl := u.UploadURL\n\tif url == \"\" {\n\t\tu.Unlock()\n\t\treturn nil, -1, errors.New(\"UploadSession UploadURL cannot be empty\")\n\t}\n\tu.Unlock()\n\n\tend := offset + uploadChunkSize\n\tvar reqChunkSize uint64\n\tif end > u.Size {\n\t\tend = u.Size\n\t\treqChunkSize = end - offset + 1\n\t}\n\tif offset > u.Size {\n\t\treturn nil, -1, errors.New(\"offset cannot be larger than DriveItem size\")\n\t}\n\n\tauth.Refresh()\n\n\tclient := &http.Client{}\n\trequest, _ := http.NewRequest(\n\t\t\"PUT\",\n\t\turl,\n\t\tbytes.NewReader((u.Data)[offset:end]),\n\t)\n\trequest.Header.Add(\"Content-Length\", strconv.Itoa(int(reqChunkSize)))\n\tfrags := fmt.Sprintf(\"bytes %d-%d/%d\", offset, end-1, u.Size)\n\tlog.Info().Str(\"id\", u.ID).Msg(\"Uploading \" + frags)\n\trequest.Header.Add(\"Content-Range\", frags)\n\n\tresp, err := client.Do(request)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\tdefer resp.Body.Close()\n\tresponse, _ := ioutil.ReadAll(resp.Body)\n\treturn response, resp.StatusCode, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go/auth\"\n)\n\ntype UploadSession struct {\n\tID               string\n\tOldID            string\n\tParentID         string\n\tNodeID           uint64\n\tName             string\n\tExpirationDateTime time.Time\n\tSize             uint64\n\tData             []byte\n\tQuickXORHash     string\n\tModTime          time.Time\n\tretries          int\n\tUploadURL        string\n\tETag             string\n\tstate            int\n\terror            error\n\tsync.Mutex       `json:\"-\"`\n}\n\nfunc (us *UploadSession) uploadChunk(auth *graph.Auth, offset uint64) ([]byte, int, error) {\n\tif us.error != nil {\n\t\treturn nil, 0, us.error\n\t}\n\n\tchunk := us.Data[offset:]\n\treq, err := http.NewRequest(\"PUT\", fmt.Sprintf(\"%s?offset=%d\", us.UploadURL, offset), bytes.NewBuffer(chunk))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", len(chunk)))\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+len(chunk)-1, us.Size))\n\n\tauth.SetHeaders(req)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusUnauthorized {\n\t\tnewAuth, err := auth.Refresh()\n\t\tif err != nil {\n\t\t\treturn nil, resp.StatusCode, err\n\t\t}\n\t\tauth = newAuth\n\t\treq.Header.Del(\"Authorization\")\n\t\tauth.SetHeaders(req)\n\t\tresp, err = client.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, 0, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treturn body, resp.StatusCode, nil\n}\n```"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a function to fetch file contents from a given URL with optional caching capabilities to improve performance on repeated requests.\n\nFunction Description: The function `fetchFile` retrieves the contents of a file from a specified URL using HTTP GET. It supports caching of downloaded files to avoid redundant network requests. The function handles HTTP errors, manages resource cleanup, and provides verbose logging options.\n\nInput: \n- `fileurl` [string]: The URL of the file to be fetched\n\nOutput: \n- `[]byte`: The contents of the file as a byte slice if successful\n- `error`: An error object if any step fails (network error, HTTP error, etc.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar fileCache map[string][]byte\nvar fileCacheMutex sync.Mutex\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tvar bytes []byte\n\tinitializeFileCache()\n\tif fileCacheEnable {\n\t\tbytes, ok := fileCache[fileurl]\n\t\tif ok {\n\t\t\tif verboseReader {\n\t\t\t\tlog.Printf(\"Cache hit %s\", fileurl)\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\tif verboseReader {\n\t\t\tlog.Printf(\"Fetching %s\", fileurl)\n\t\t}\n\t}\n\tresponse, err := http.Get(fileurl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Error downloading %s: %s\", fileurl, response.Status)\n\t}\n\tbytes, err = ioutil.ReadAll(response.Body)\n\tif fileCacheEnable && err == nil {\n\t\tfileCache[fileurl] = bytes\n\t}\n\treturn bytes, err\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc fetchFile(fileurl string) ([]byte, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", fileurl, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP request failed with status: %s\", resp.Status)\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bodyBytes, nil\n}\n\nfunc main() {\n\tfileurl := \"https://example.com/file.txt\"\n\tcontent, err := fetchFile(fileurl)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error fetching file: %v\", err)\n\t}\n\tfmt.Println(string(content))\n}\n```"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Create a function that retrieves the version information from an etcd server using a simple HTTP GET request.\n\nFunction Description: The function `GetEtcdVersion` makes an HTTP GET request to the specified etcd server's `/version` endpoint, reads the response, and returns the version information as a string. It handles errors for connection issues, unsuccessful HTTP responses, and response body reading failures.\n\nInput: \n- `host` (string): The base URL of the etcd server (e.g., \"http://localhost:2379\")\n\nOutput: \n- (string): The version information returned by the etcd server\n- (error): An error object if any step fails (connection, non-200 response, or body reading error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\nfunc GetEtcdVersion(host string) (string, error) {\n\tresponse, err := http.Get(host + \"/version\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unsuccessful response from etcd server %q: %v\", host, err)\n\t}\n\tversionBytes, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(versionBytes), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc GetEtcdVersion(host string) (string, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"%s/version\", host))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect to etcd server: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tversion := resp.Header.Get(\"X-Etcd-Version\")\n\tif version == \"\" {\n\t\treturn \"\", fmt.Errorf(\"version information not found in response header\")\n\t}\n\n\treturn version, nil\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: The task involves creating a Go struct that encapsulates functionality for sending push notifications through a push service, handling HTTP communication, and processing responses. The struct should manage HTTP client configuration, request construction, and response handling for push notification delivery.\n\nStruct Description: PushServiceBase is a struct that provides base functionality for push notification services. It manages HTTP client configuration, constructs requests to a push service endpoint, handles authentication, processes responses, and manages delivery results. The struct is designed to be extended by specific push service implementations.\n\nFields:\n\nclient: [*http.Client] - Custom HTTP client configured with TLS settings and timeouts\ninitialism: [string] - Short identifier for the push service\nrawPayloadKey: [string] - Key for raw payload in notification data\nrawNotificationKey: [string] - Key for raw notification in notification data\nserviceURL: [string] - Base URL for the push service endpoint\npushServiceName: [string] - Name of the push service\n\nMethods:\n\nMakePushServiceBase: [func(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase] - Constructor that initializes the PushServiceBase with configuration and creates a custom HTTP client\n\nmulticast: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification)] - Sends push notifications to multiple devices, handles HTTP communication, and processes responses. Takes push service provider, delivery points, result channel, and notification as input, and writes results to the channel\n\nToCMPayload: [func(notif *push.Notification, regIds []string) ([]byte, error)] - Converts notification to payload format (implementation not shown in reference code)\n\nhandleCMMulticastResults: [func(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult)] - Processes multicast results from push service (implementation not shown in reference code)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uniqush/uniqush-push/push\"\n\t\"github.com/uniqush/uniqush-push/util\"\n)\n\ntype PushServiceBase struct {\n\tclient             HTTPClient\n\tinitialism         string\n\trawPayloadKey      string\n\trawNotificationKey string\n\tserviceURL         string\n\tpushServiceName    string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\tconf := &tls.Config{InsecureSkipVerify: false}\n\ttr := &http.Transport{\n\t\tTLSClientConfig:     conf,\n\t\tTLSHandshakeTimeout: time.Second * 5,\n\t\tMaxIdleConnsPerHost: 500,\n\t}\n\tclient := &http.Client{\n\t\tTransport: tr,\n\t\tTimeout:   time.Second * 10,\n\t}\n\treturn PushServiceBase{\n\t\tclient:             client,\n\t\tinitialism:         initialism,\n\t\trawPayloadKey:      rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:         serviceURL,\n\t\tpushServiceName:    pushServiceName,\n\t}\n}\n\nfunc (psb *PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tif len(dpList) == 0 {\n\t\treturn\n\t}\n\tregIds := extractRegIds(dpList)\n\n\tjpayload, e0 := psb.ToCMPayload(notif, regIds)\n\n\tif e0 != nil {\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, e0)\n\t\treturn\n\t}\n\n\treq, e1 := http.NewRequest(\"POST\", psb.serviceURL, bytes.NewReader(jpayload))\n\tif req != nil {\n\t\tdefer req.Body.Close()\n\t}\n\tif e1 != nil {\n\t\thttpErr := push.NewErrorf(\"Error constructing HTTP request: %v\", e1)\n\t\tsendErrToEachDP(psp, dpList, resQueue, notif, httpErr)\n\t\treturn\n\t}\n\n\tapikey := psp.VolatileData[\"apikey\"]\n\n\treq.Header.Set(\"Authorization\", \"key=\"+apikey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tr, e2 := psb.client.Do(req)\n\tif r != nil {\n\t\tdefer r.Body.Close()\n\t}\n\tif e2 != nil {\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\n\t\t\tres.Destination = dp\n\t\t\tif err, ok := e2.(net.Error); ok {\n\t\t\t\tif err.Temporary() {\n\t\t\t\t\tafter := 3 * time.Second\n\t\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t\t}\n\t\t\t} else if err, ok := e2.(*net.DNSError); ok {\n\t\t\t\tafter := 3 * time.Second\n\t\t\t\tres.Err = push.NewRetryErrorWithReason(psp, dp, notif, after, err)\n\t\t\t} else {\n\t\t\t\tres.Err = push.NewErrorf(\"Unrecoverable HTTP error sending to %s: %v\", psb.pushServiceName, e2)\n\t\t\t}\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\t}\n\n\tnewAuthToken := r.Header.Get(\"Update-Client-Auth\")\n\tif newAuthToken != \"\" && apikey != newAuthToken {\n\t\tpsp.VolatileData[\"apikey\"] = newAuthToken\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewPushServiceProviderUpdate(psp)\n\t\tresQueue <- res\n\t}\n\n\tswitch r.StatusCode {\n\tcase 500, 503:\n\t\tafter := 0 * time.Second\n\t\tfor _, dp := range dpList {\n\t\t\tres := new(push.Result)\n\t\t\tres.Provider = psp\n\t\t\tres.Content = notif\n\t\t\tres.Destination = dp\n\t\t\terr := push.NewRetryError(psp, dp, notif, after)\n\t\t\tres.Err = err\n\t\t\tresQueue <- res\n\t\t}\n\t\treturn\n\tcase 401:\n\t\terr := push.NewBadPushServiceProviderWithDetails(psp, fmt.Sprintf(\"push service credentials rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\tcase 400:\n\t\terr := push.NewBadNotificationWithDetails(fmt.Sprintf(\"push notification payload rejected by %s\", psb.initialism))\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = err\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tcontents, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to read %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tvar result CMResult\n\terr = json.Unmarshal(contents, &result)\n\n\tif err != nil {\n\t\tres := new(push.Result)\n\t\tres.Provider = psp\n\t\tres.Content = notif\n\t\tres.Err = push.NewErrorf(\"Failed to decode %s response: %v\", psb.initialism, err)\n\t\tresQueue <- res\n\t\treturn\n\t}\n\n\tpsb.handleCMMulticastResults(psp, dpList, resQueue, notif, result.Results)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/yourcompany/push\"\n)\n\ntype PushServiceBase struct {\n\tclient          *http.Client\n\tinitialism      string\n\trawPayloadKey   string\n\trawNotificationKey string\n\tserviceURL      string\n\tpushServiceName string\n}\n\nfunc MakePushServiceBase(initialism string, rawPayloadKey string, rawNotificationKey string, serviceURL string, pushServiceName string) PushServiceBase {\n\treturn PushServiceBase{\n\t\tclient: &http.Client{\n\t\t\tTimeout: 10 * time.Second,\n\t\t},\n\t\tinitialism:      initialism,\n\t\trawPayloadKey:   rawPayloadKey,\n\t\trawNotificationKey: rawNotificationKey,\n\t\tserviceURL:      serviceURL,\n\t\tpushServiceName: pushServiceName,\n\t}\n}\n\nfunc (psb PushServiceBase) multicast(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification) {\n\tfor _, dp := range dpList {\n\t\tpayload, err := psb.ToCMPayload(notif, []string{dp.RegistrationID})\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(context.Background(), \"POST\", psb.serviceURL, bytes.NewBuffer(payload))\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t\tresp, err := psb.client.Do(req)\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tvar cmResult CMResult\n\t\terr = json.NewDecoder(resp.Body).Decode(&cmResult)\n\t\tif err != nil {\n\t\t\tresQueue <- &push.Result{\n\t\t\t\tDeliveryPoint: dp,\n\t\t\t\tError:         err,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tpsb.handleCMMulticastResults(psp, []*push.DeliveryPoint{dp}, resQueue, notif, []CMResult{cmResult})\n\t}\n}\n\nfunc (psb PushServiceBase) ToCMPayload(notif *push.Notification, regIds []string) ([]byte, error) {\n\t// Implementation not shown\n\treturn nil, fmt.Errorf(\"not implemented\")\n}\n\nfunc (psb PushServiceBase) handleCMMulticastResults(psp *push.PushServiceProvider, dpList []*push.DeliveryPoint, resQueue chan<- *push.Result, notif *push.Notification, results []CMResult) {\n\t// Implementation not shown\n}\n```"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response validation, and resource cleanup. The function is designed to work with metadata services like Google Cloud's metadata server.\n\nInput:  \n- `key` (string): The metadata key to retrieve from the metadata server. This is appended to the base metadata path.\n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nconst metadataBasePath = \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n\nfunc getMetadata(key string) ([]byte, error) {\n\turl := fmt.Sprintf(\"%s%s\", metadataBasePath, key)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvar buf bytes.Buffer\n\t_, err = buf.ReadFrom(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}\n\nfunc main() {\n\tkey := \"attributes/example-key\"\n\tdata, err := getMetadata(key)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Response:\", string(data))\n}\n```"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Implement a function to fetch the contents of a file from a given URL and return it as an io.Reader for further processing.  \n\nFunction Description: The function `fetchFile` takes a URL as input, sends an HTTP GET request to fetch the file, reads the response body, and returns it as an `io.Reader`. It handles errors during the HTTP request and response reading.  \n\nInput:  \n- `URL` (string) - The URL of the file to be fetched.  \n\nOutput:  \n- `io.Reader` - A reader containing the contents of the fetched file.  \n\n(Note: The `checkErr` function is assumed to handle errors by panicking or logging.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc fetchFile(URL string) io.Reader {\n\tresp, err := http.Get(URL)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tcheckErr(err)\n\treturn strings.NewReader(string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc fetchFile(url string) io.Reader {\n\tresp, err := http.Get(url)\n\tcheckErr(err)\n\tdefer resp.Body.Close()\n\treturn resp.Body\n}\n```"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a function that reads data from a given location, supporting HTTP/HTTPS protocols. The function should handle URL parsing, make HTTP requests, and return the response body or appropriate errors.\n\nFunction Description: The function `ReadLocation` takes a location string (URL) as input, parses it to determine the protocol, and if it's HTTP/HTTPS, makes a GET request to fetch the data. It handles response status checks, reads the response body, and ensures proper resource cleanup.\n\nInput: \n- `loc` (string): A URL string specifying the location to read from (e.g., \"http://example.com/data\")\n\nOutput: \n- `[]byte`: The response body as a byte slice if successful\n- `error`: An error object describing any issues encountered during URL parsing, HTTP request, or response handling",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tu, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch u.Scheme {\n\tcase \"http\", \"https\":\n\t\tres, err := http.Get(loc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer res.Body.Close()\n\t\tif res.StatusCode != http.StatusOK {\n\t\t\treturn nil, fmt.Errorf(\"%s\", res.Status)\n\t\t}\n\t\tb, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn b, nil\n\t}\n\treturn nil, fmt.Errorf(\"Unsupported location to load: %s\", loc)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc ReadLocation(loc string) ([]byte, error) {\n\tu, err := url.Parse(loc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", loc, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HTTP request failed with status: %s\", resp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n```"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Implement a GIF search functionality using the Giphy API in Go, handling HTTP requests, response parsing, and error management.\n\nStruct Description: The Gifs struct represents a service for searching GIFs using the Giphy API. It maintains configuration and provides methods to interact with the API.\n\nFields:\n- conf: [conf] - Configuration containing the Giphy API key\n\nMethods:\n- New: [func() *Gifs] - Initializes a new Gifs instance by loading configuration\n- Search: [func(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error] - Searches for GIFs using the Giphy API with the provided query and parameters\n\nInput:\n- ctx: [context.Context] - Context for request cancellation and timeouts\n- request: [*gifs.SearchRequest] - Contains search parameters (query, limit, offset, rating, language)\n- response: [*gifs.SearchResponse] - Will be populated with search results\n\nOutput:\n- error: Returns nil on success or an appropriate error on failure",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/micro/micro/v5/service/config\"\n\t\"github.com/micro/micro/v5/service/errors\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tgifs \"github.com/micro/services/gifs/proto\"\n)\n\ntype conf struct {\n\tAPIKey string `json:\"api_key\"`\n}\n\ntype Gifs struct {\n\tconf conf\n}\n\nfunc New() *Gifs {\n\tv, err := config.Get(\"micro.gifs\")\n\tif err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\tvar c conf\n\tif err := v.Scan(&c); err != nil {\n\t\tlogger.Fatalf(\"Failed to load config %s\", err)\n\t}\n\n\treturn &Gifs{conf: c}\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *gifs.SearchRequest, response *gifs.SearchResponse) error {\n\tif len(request.Query) == 0 {\n\t\treturn errors.BadRequest(\"gifs.Search\", \"Missing query field\")\n\t}\n\tlimit := defaultLimit\n\tif request.Limit > 0 {\n\t\tlimit = request.Limit\n\t}\n\toffset := defaultOffset\n\tif request.Offset > 0 {\n\t\toffset = request.Offset\n\t}\n\n\trating := defaultRating\n\tif len(request.Rating) > 0 {\n\t\trating = request.Rating\n\t}\n\tlan := defaultLang\n\tif len(request.Lang) > 0 {\n\t\tlan = request.Lang\n\t}\n\trsp, err := http.Get(fmt.Sprintf(giphySearch, g.conf.APIKey, request.Query, limit, offset, rating, lan))\n\tif err != nil {\n\t\tlogger.Errorf(\"Error querying giphy %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tdefer rsp.Body.Close()\n\tb, err := ioutil.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tvar gRsp searchResponse\n\tif err := json.Unmarshal(b, &gRsp); err != nil {\n\t\tlogger.Errorf(\"Error marshalling giphy response %s\", err)\n\t\treturn errors.InternalServerError(\"gifs.Search\", \"Error querying for gifs\")\n\t}\n\tresponse.Data = marshalGifs(gRsp.Data)\n\tresponse.Pagination = &gifs.Pagination{\n\t\tOffset:     gRsp.Pagination.Offset,\n\t\tTotalCount: gRsp.Pagination.TotalCount,\n\t\tCount:      gRsp.Pagination.Count,\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage gifs\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Gifs struct {\n\tconf Config\n}\n\ntype Config struct {\n\tAPIKey string\n}\n\nfunc New(conf Config) *Gifs {\n\treturn &Gifs{conf: conf}\n}\n\ntype SearchRequest struct {\n\tQuery    string `json:\"q\"`\n\tLimit    int    `json:\"limit\"`\n\tOffset   int    `json:\"offset\"`\n\tRating   string `json:\"rating\"`\n\tLanguage string `json:\"lang\"`\n}\n\ntype SearchResponse struct {\n\tData []struct {\n\t\tType        string `json:\"type\"`\n\t\tID          string `json:\"id\"`\n\t\tURL         string `json:\"url\"`\n\t\tImageURL    string `json:\"image_url\"`\n\t\tImages      struct {\n\t\t\tFixedHeight struct {\n\t\t\t\tURL string `json:\"url\"`\n\t\t\t} `json:\"fixed_height\"`\n\t\t} `json:\"images\"`\n\t} `json:\"data\"`\n\tPagination struct {\n\t\tCount  int `json:\"count\"`\n\t\tOffset int `json:\"offset\"`\n\t\tTotal  int `json:\"total\"`\n\t} `json:\"pagination\"`\n\tMeta struct {\n\t\tMessage string `json:\"message\"`\n\t\tStatus  int    `json:\"status\"`\n\t} `json:\"meta\"`\n}\n\nfunc (g *Gifs) Search(ctx context.Context, request *SearchRequest, response *SearchResponse) error {\n\turl := fmt.Sprintf(\"https://api.giphy.com/v1/gifs/search?api_key=%s&q=%s&limit=%d&offset=%d&rating=%s&lang=%s\",\n\t\tg.conf.APIKey, request.Query, request.Limit, request.Offset, request.Rating, request.Language)\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"HTTP error: %s\", resp.Status)\n\t}\n\n\terr = json.NewDecoder(resp.Body).Decode(response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 327,
    "Instruction": "Task Description: Implement a function that sets up a cron job to make periodic HTTP GET requests to a specified callback URL and logs the results.\n\nFunction Description: The function `Setup` initializes a new cron scheduler, adds a job that makes HTTP GET requests to a specified callback URL at a given interval, and logs the success or failure of each request. The function starts the cron scheduler and returns it for further management.\n\nInput: \n- `job` [*pb.Job] - A protobuf message containing the job details, including:\n  - `Id` [string] - Unique identifier for the job\n  - `Interval` [string] - Cron-formatted interval at which the job should run\n  - `Callback` [string] - URL to which the HTTP GET request will be made\n\nOutput: \n- [*cron.Cron] - A pointer to the started cron scheduler instance, which can be used to stop or manage the scheduled job.",
    "Canonical_solution": "import (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"github.com/micro/micro/v5/service/logger\"\n\tpb \"github.com/micro/services/cron/proto\"\n\t\"github.com/robfig/cron/v3\"\n)\nfunc (c *Cron) Setup(job *pb.Job) *cron.Cron {\n\tlogger.Infof(\"Setting up job id: %s\", job.Id)\n\tcr := cron.New()\n\tcr.AddFunc(job.Interval, func() {\n\t\tlogger.Infof(\"Running job id: %s\", job.Id)\n\t\trsp, err := http.Get(job.Callback)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed job id: %s error: %v\", job.Id, err)\n\t\t\treturn\n\t\t}\n\t\tdefer rsp.Body.Close()\n\t\tb, _ := ioutil.ReadAll(rsp.Body)\n\t\tif rsp.StatusCode != 200 {\n\t\t\tlogger.Errorf(\"Non 200 job id: %s error: %s\", job.Id, string(b))\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Successful job id: %s\", job.Id)\n\t})\n\tcr.Start()\n\treturn cr\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n\tpb \"path/to/your/proto/package\"\n)\n\nfunc Setup(job *pb.Job) (*cron.Cron, error) {\n\tc := cron.New()\n\tentryID, err := c.AddFunc(job.Interval, func() {\n\t\tresp, err := http.Get(job.Callback)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Job %s failed: %v\\n\", job.Id, err)\n\t\t} else {\n\t\t\tdefer resp.Body.Close()\n\t\t\tfmt.Printf(\"Job %s succeeded: status %d\\n\", job.Id, resp.StatusCode)\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Start()\n\treturn c, nil\n}\n\nfunc main() {\n\tjob := &pb.Job{\n\t\tId:      \"123\",\n\t\tInterval: \"@every 5m\",\n\t\tCallback: \"http://example.com/callback\",\n\t}\n\tcronScheduler, _ := Setup(job)\n\ttime.Sleep(10 * time.Minute)\n\tcronScheduler.Stop()\n}\n```"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified address with JSON payload and room parameters, then processes the response.\n\nFunction Description: The function sends a POST request to a server endpoint with room information and a JSON payload containing a test value. It handles the response by reading the body and printing the result along with a timestamp.\n\nInput:\n- addr (string): The server address to which the POST request will be sent.\n- i (int64): A numeric value that will be included in the JSON payload.\n\nOutput: None (prints response details to stdout, returns nothing)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc post(addr string, i int64) {\n\tresp, err := http.Post(\"http://\"+addr+\"/goim/push/room?operation=1000&type=test&room=\"+os.Args[1], \"application/json\", bytes.NewBufferString(fmt.Sprintf(\"{\\\"test\\\":%d}\", i)))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: http.post() error(%v)\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%s postId:%d, response:%s\\n\", time.Now().Format(\"2006-01-02 15:04:05\"), i, string(body))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc sendPostRequest(addr string, i int64) {\n\tpayload := map[string]interface{}{\n\t\t\"test\": i,\n\t}\n\n\tjsonPayload, err := json.Marshal(payload)\n\tif err != nil {\n\t\tfmt.Println(\"Error marshalling JSON:\", err)\n\t\treturn\n\t}\n\n\treq, err := http.NewRequest(\"POST\", addr, bytes.NewBuffer(jsonPayload))\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbodyBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Response at %s:\\n%s\\n\", time.Now().Format(time.RFC3339), bodyBytes)\n}\n\nfunc main() {\n\tsendPostRequest(\"https://example.com/api\", 12345)\n}\n```"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Implement a function to retrieve metadata from a metadata server using HTTP GET requests with custom headers.\n\nFunction Description: The function `getMetadata` sends an HTTP GET request to a metadata server with specific headers and retrieves the response. It handles the request creation, response processing, and error checking. The function ensures proper resource cleanup by deferring the closing of the response body.\n\nInput:  \n- `key` (string): The metadata key to be appended to the metadata server's base path.  \n\nOutput:  \n- `[]byte`: The raw response body from the metadata server if the request is successful.  \n- `error`: An error object if the request fails or if the server returns a non-200 status code.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar (\n\tmetadataRequestHeaders = http.Header{\n\t\t\"Metadata-Flavor\": []string{\"Google\"},\n\t}\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\treq := &http.Request{\n\t\tMethod: \"GET\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   metadataHost,\n\t\t\tPath:   metadataPath + key,\n\t\t},\n\t\tHeader: metadataRequestHeaders,\n\t\tHost:   metadataHost,\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"metadata server returned HTTP %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 101,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc getMetadata(key string) ([]byte, error) {\n\tbaseURL := \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n\turl := fmt.Sprintf(\"%s%s\", baseURL, key)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Metadata-Flavor\", \"Google\")\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Failed to fetch metadata: %s\", resp.Status)\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}\n\nfunc main() {\n\tmetadata, err := getMetadata(\"attributes/my-key\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Metadata:\", string(metadata))\n\t}\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a Proxy struct that manages different types of servers (UDS, mTLS, admin, and health) for handling proxy connections with various protocols (HTTP and gRPC).\n\nStruct Description: The Proxy struct provides methods to run different server types with configurable options, including Unix Domain Socket (UDS) servers, mTLS-secured servers, admin servers for metrics and profiling, and health servers for liveness/readiness checks.\n\nMethods:\n\nMethod1: runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a master server using Unix Domain Socket (UDS) for communication. Supports both gRPC and HTTP modes based on configuration. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod2: runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) -> (StopFunc, error) - Starts a mTLS-secured master server listening on a TCP port. Supports both gRPC and HTTP modes. Returns a stop function for graceful shutdown and any error encountered.\n\nMethod3: runAdminServer(o *options.ProxyRunOptions) -> void - Starts an admin server for metrics and optional profiling endpoints. Runs on a localhost port specified in options.\n\nMethod4: runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) -> void - Starts a health server providing liveness (/healthz) and readiness (/ready) endpoints. Runs on a port specified in options.\n\nNote: StopFunc is a function type defined as: type StopFunc func()",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype Proxy struct {\n}\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tif o.DeleteUDSFile {\n\t\tif err := os.Remove(o.UdsName); err != nil && !os.IsNotExist(err) {\n\t\t\tklog.ErrorS(err, \"failed to delete file\", \"file\", o.UdsName)\n\t\t}\n\t}\n\tvar stop StopFunc\n\tif o.Mode == \"grpc\" {\n\t\tgrpcServer := grpc.NewServer()\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := getUDSListener(ctx, o.UdsName)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get uds listener: %v\", err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\tserver := &http.Server{\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tklog.ErrorS(err, \"error shutting down server\")\n\t\t}\n\t\tgo func() {\n\t\t\tudsListener, err := getUDSListener(ctx, o.UdsName)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to get uds listener\")\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\terr := udsListener.Close()\n\t\t\t\tklog.ErrorS(err, \"failed to close uds listener\")\n\t\t\t}()\n\t\t\terr = server.Serve(udsListener)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to serve uds requests\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *options.ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tvar stop StopFunc\n\n\tvar tlsConfig *tls.Config\n\tvar err error\n\tif tlsConfig, err = p.getTLSConfig(o.ServerCaCert, o.ServerCert, o.ServerKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", o.ServerPort)\n\n\tif o.Mode == grpcMode {\n\t\tserverOption := grpc.Creds(credentials.NewTLS(tlsConfig))\n\t\tgrpcServer := grpc.NewServer(serverOption)\n\t\tclient.RegisterProxyServiceServer(grpcServer, s)\n\t\tlis, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to listen on %s: %v\", addr, err)\n\t\t}\n\t\tgo grpcServer.Serve(lis)\n\t\tstop = grpcServer.GracefulStop\n\t} else {\n\t\thttpServer := &http.Server{\n\t\t\tAddr: \":8088\",\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t}\n\t\tserver := &http.Server{\n\t\t\tAddr:      addr,\n\t\t\tTLSConfig: tlsConfig,\n\t\t\tHandler: &server.Tunnel{\n\t\t\t\tServer: s,\n\t\t\t},\n\t\t\tTLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),\n\t\t}\n\n\t\tstop = func() {\n\t\t\terr := server.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown server\")\n\t\t\t}\n\t\t\terr = httpServer.Shutdown(ctx)\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to shutdown httpServer\")\n\t\t\t}\n\t\t}\n\t\tgo func() {\n\t\t\terr := server.ListenAndServeTLS(\"\", \"\")\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on master port\")\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\terr := httpServer.ListenAndServe()\n\t\t\tif err != nil {\n\t\t\t\tklog.ErrorS(err, \"failed to listen on http master port\")\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn stop, nil\n}\n\nfunc (p *Proxy) runAdminServer(o *options.ProxyRunOptions) {\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.Handle(\"/metrics\", promhttp.Handler())\n\tif o.EnableProfiling {\n\t\tmuxHandler.HandleFunc(\"/debug/pprof\", util.RedirectTo(\"/debug/pprof/\"))\n\t\tmuxHandler.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\tif o.EnableContentionProfiling {\n\t\t\truntime.SetBlockProfileRate(1)\n\t\t}\n\t}\n\tadminServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\"127.0.0.1:%d\", o.AdminPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := adminServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"admin server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Admin server stopped listening\")\n\t}()\n}\n\nfunc (p *Proxy) runHealthServer(o *options.ProxyRunOptions, server *server.ProxyServer) {\n\tlivenessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\treadinessHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tready, msg := server.Readiness.Ready()\n\t\tif ready {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tfmt.Fprintf(w, \"ok\")\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(w, msg)\n\t})\n\n\tmuxHandler := http.NewServeMux()\n\tmuxHandler.HandleFunc(\"/healthz\", livenessHandler)\n\tmuxHandler.HandleFunc(\"/ready\", readinessHandler)\n\thealthServer := &http.Server{\n\t\tAddr:           fmt.Sprintf(\":%d\", o.HealthPort),\n\t\tHandler:        muxHandler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tgo func() {\n\t\terr := healthServer.ListenAndServe()\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"health server could not listen\")\n\t\t}\n\t\tklog.V(1).Infoln(\"Health server stopped listening\")\n\t}()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/grpc/grpc-go\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\ntype Proxy struct{}\n\ntype StopFunc func()\n\nfunc (p *Proxy) runUDSMasterServer(ctx context.Context, o *ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\tudsPath := filepath.Join(o.DataDir, \"uds.sock\")\n\tlistener, err := net.Listen(\"unix\", udsPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer os.Remove(udsPath)\n\n\tvar handler http.Handler\n\tif o.HTTPMode {\n\t\thandler = http.HandlerFunc(s.ServeHTTP)\n\t} else {\n\t\thandler = grpcHandlerFunc(s.GRPCServer())\n\t}\n\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t}()\n\n\treturn func() {\n\t\tlistener.Close()\n\t}, http.Serve(listener, handler)\n}\n\nfunc (p *Proxy) runMTLSMasterServer(ctx context.Context, o *ProxyRunOptions, s *server.ProxyServer) (StopFunc, error) {\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\tCipherSuites: []uint16{tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},\n\t}\n\n\tlistener, err := tls.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", o.BindAddress, o.Port), tlsConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar handler http.Handler\n\tif o.HTTPMode {\n\t\thandler = http.HandlerFunc(s.ServeHTTP)\n\t} else {\n\t\thandler = grpcHandlerFunc(s.GRPCServer())\n\t}\n\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tlistener.Close()\n\t}()\n\n\treturn func() {\n\t\tlistener.Close()\n\t}, http.Serve(listener, handler)\n}\n\nfunc (p *Proxy) runAdminServer(o *ProxyRunOptions) {\n\thttp.Handle(\"/metrics\", promhttp.Handler())\n\tif o.ProfilingEnabled {\n\t\thttp.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\thttp.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n\t\thttp.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n\t\thttp.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n\t\thttp.HandleFunc(\"/debug/pprof/trace\", pprof.Trace)\n\t}\n\n\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\"localhost:%d\", o.AdminPort), nil))\n}\n\nfunc (p *Proxy) runHealthServer(o *ProxyRunOptions, server *server.ProxyServer) {\n\thttp.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\thttp.HandleFunc(\"/ready\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif server.IsReady() {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t}\n\t})\n\n\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", o.HealthPort), nil))\n}\n```"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a RabbitMQ consumer in Go that connects to a RabbitMQ server, declares necessary exchanges and queues, binds them, and consumes messages from the queue. The consumer should be able to gracefully shut down when requested.\n\nStruct Description: The Consumer struct represents a RabbitMQ consumer with connection and channel management capabilities. It handles the lifecycle of consuming messages from a RabbitMQ queue and provides shutdown functionality.\n\nFields:\n- conn: *amqp.Connection - The connection to the RabbitMQ server\n- channel: *amqp.Channel - The communication channel for RabbitMQ operations\n- tag: string - The consumer tag for identifying this consumer\n- done: chan error - Channel for signaling when the consumer has finished shutting down\n\nMethods:\n- NewConsumer: (amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) -> (*Consumer, error) - Creates a new Consumer instance, establishes connection, declares exchange and queue, binds them, and starts consuming messages\n- Shutdown: () -> error - Gracefully shuts down the consumer by canceling consumption and closing the connection\n- handle: (deliveries <-chan amqp.Delivery, done chan error) -> () - Internal method for processing incoming messages (note: this is not exported as it starts with lowercase)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI, exchange, exchangeType, queueName, key, ctag string) (*Consumer, error) {\n\tc := &Consumer{\n\t\tconn:    nil,\n\t\tchannel: nil,\n\t\ttag:     ctag,\n\t\tdone:    make(chan error),\n\t}\n\n\tvar err error\n\n\tlog.Printf(\"dialing %q\", amqpURI)\n\tc.conn, err = amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Dial: %s\", err)\n\t}\n\n\tgo func() {\n\t\tfmt.Printf(\"closing: %s\", <-c.conn.NotifyClose(make(chan *amqp.Error)))\n\t}()\n\n\tlog.Printf(\"got Connection, getting Channel\")\n\tc.channel, err = c.conn.Channel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Channel: %s\", err)\n\t}\n\n\tlog.Printf(\"got Channel, declaring Exchange (%q)\", exchange)\n\tif err = c.channel.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Exchange Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Exchange, declaring Queue %q\", queueName)\n\tqueue, err := c.channel.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Declare: %s\", err)\n\t}\n\n\tlog.Printf(\"declared Queue (%q %d messages, %d consumers), binding to Exchange (key %q)\",\n\t\tqueue.Name, queue.Messages, queue.Consumers, key)\n\n\tif err = c.channel.QueueBind(\n\t\tqueue.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t); err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Bind: %s\", err)\n\t}\n\n\tlog.Printf(\"Queue bound to Exchange, starting Consume (consumer tag %q)\", c.tag)\n\tdeliveries, err := c.channel.Consume(\n\t\tqueue.Name,\n\t\tc.tag,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Queue Consume: %s\", err)\n\t}\n\n\tgo handle(deliveries, c.done)\n\n\treturn c, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tif err := c.channel.Cancel(c.tag, true); err != nil {\n\t\treturn fmt.Errorf(\"Consumer cancel failed: %s\", err)\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn fmt.Errorf(\"AMQP connection close error: %s\", err)\n\t}\n\n\treturn <-c.done\n}\n\nfunc handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\n\t\t\t\"got %dB delivery: [%v] %q\",\n\t\t\tlen(d.Body),\n\t\t\td.DeliveryTag,\n\t\t\td.Body,\n\t\t)\n\t\td.Ack(false)\n\t}\n\tdone <- nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 122,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Consumer struct {\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\ttag     string\n\tdone    chan error\n}\n\nfunc NewConsumer(amqpURI string, exchange string, exchangeType string, queueName string, key string, ctag string) (*Consumer, error) {\n\tconn, err := amqp.Dial(amqpURI)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = ch.ExchangeDeclare(\n\t\texchange,\n\t\texchangeType,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tq, err := ch.QueueDeclare(\n\t\tqueueName,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = ch.QueueBind(\n\t\tq.Name,\n\t\tkey,\n\t\texchange,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconsumer := &Consumer{\n\t\tconn:  conn,\n\t\tchannel: ch,\n\t\ttag:   ctag,\n\t\tdone:  make(chan error),\n\t}\n\tgo consumer.handle(ch.Consume(q.Name, ctag, true, false, false, false, nil))\n\treturn consumer, nil\n}\n\nfunc (c *Consumer) Shutdown() error {\n\tc.channel.Cancel(c.tag, true)\n\tclose(c.done)\n\treturn c.conn.Close()\n}\n\nfunc (c *Consumer) handle(deliveries <-chan amqp.Delivery, done chan error) {\n\tfor d := range deliveries {\n\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t}\n\tdone <- nil\n}\n\nfunc main() {\n\tconsumer, err := NewConsumer(\"amqp://guest:guest@localhost:5672/\", \"test_exchange\", \"direct\", \"test_queue\", \"test_key\", \"consumer_tag\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create consumer: %v\", err)\n\t}\n\tdefer consumer.Shutdown()\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigChan\n\tlog.Println(\"Shutting down consumer...\")\n}\n```"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a robust RabbitMQ producer in Go that handles connection management, channel initialization, and message publishing with automatic reconnection capabilities.\n\nStruct Description: The Session struct represents a RabbitMQ producer session that maintains connection state and provides message publishing functionality with automatic reconnection.\n\nFields:\n- name: string - The name of the queue to publish to\n- logger: *log.Logger - Logger for session events\n- connection: *amqp.Connection - RabbitMQ connection object\n- channel: *amqp.Channel - RabbitMQ channel object\n- done: chan bool - Channel to signal shutdown\n- notifyConnClose: chan *amqp.Error - Channel for connection close notifications\n- notifyChanClose: chan *amqp.Error - Channel for channel close notifications\n- notifyConfirm: chan amqp.Confirmation - Channel for publish confirmations\n- isReady: bool - Flag indicating if session is ready to publish\n\nMethods:\n- New(name string, addr string) -> *Session - Creates a new Session instance and starts connection management\n- handleReconnect(addr string) - Manages reconnection logic in a goroutine\n- connect(addr string) -> (*amqp.Connection, error) - Establishes connection to RabbitMQ server\n- handleReInit(conn *amqp.Connection) -> bool - Handles channel reinitialization after connection\n- init(conn *amqp.Connection) -> error - Initializes channel and declares queue\n- changeConnection(connection *amqp.Connection) - Updates connection and sets up close notifications\n- changeChannel(channel *amqp.Channel) - Updates channel and sets up close/confirm notifications\n- Push(data []byte) -> error - Safely publishes message with retry logic\n- UnsafePush(data []byte) -> error - Publishes message without safety checks (used internally)",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string) *Session {\n\tsession := Session{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tname:   name,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn &session\n}\n\nfunc (session *Session) handleReconnect(addr string) {\n\tfor {\n\t\tsession.isReady = false\n\t\tlog.Println(\"Attempting to connect\")\n\n\t\tconn, err := session.connect(addr)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to connect. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif done := session.handleReInit(conn); done {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (session *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.changeConnection(conn)\n\tlog.Println(\"Connected!\")\n\treturn conn, nil\n}\n\nfunc (session *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\tsession.isReady = false\n\n\t\terr := session.init(conn)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to initialize channel. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn true\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-session.done:\n\t\t\treturn true\n\t\tcase <-session.notifyConnClose:\n\t\t\tlog.Println(\"Connection closed. Reconnecting...\")\n\t\t\treturn false\n\t\tcase <-session.notifyChanClose:\n\t\t\tlog.Println(\"Channel closed. Re-running init...\")\n\t\t}\n\t}\n}\n\nfunc (session *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = ch.QueueDeclare(\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.changeChannel(ch)\n\tsession.isReady = true\n\tlog.Println(\"Setup!\")\n\n\treturn nil\n}\n\nfunc (session *Session) changeConnection(connection *amqp.Connection) {\n\tsession.connection = connection\n\tsession.notifyConnClose = make(chan *amqp.Error)\n\tsession.connection.NotifyClose(session.notifyConnClose)\n}\n\nfunc (session *Session) changeChannel(channel *amqp.Channel) {\n\tsession.channel = channel\n\tsession.notifyChanClose = make(chan *amqp.Error)\n\tsession.notifyConfirm = make(chan amqp.Confirmation, 1)\n\tsession.channel.NotifyClose(session.notifyChanClose)\n\tsession.channel.NotifyPublish(session.notifyConfirm)\n}\n\nfunc (session *Session) Push(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"failed to push: not connected\")\n\t}\n\tfor {\n\t\terr := session.UnsafePush(data)\n\t\tif err != nil {\n\t\t\tsession.logger.Println(\"Push failed. Retrying...\")\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn errors.New(\"session is shutting down\")\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-session.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\tsession.logger.Println(\"Push confirmed!\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t}\n\t\tsession.logger.Println(\"Push didn't confirm. Retrying...\")\n\t}\n}\n\nfunc (session *Session) UnsafePush(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"not connected to a server\")\n\t}\n\treturn session.channel.Publish(\n\t\t\"\",\n\t\tsession.name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 121,
    "wrong_result": "```go\npackage rabbitmq\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nfunc New(name string, addr string) *Session {\n\ts := &Session{\n\t\tname:            name,\n\t\tlogger:          log.New(os.Stdout, \"rabbitmq: \", log.LstdFlags),\n\t\tdone:            make(chan bool),\n\t\tnotifyConnClose: make(chan *amqp.Error),\n\t\tnotifyChanClose: make(chan *amqp.Error),\n\t\tnotifyConfirm:   make(chan amqp.Confirmation),\n\t}\n\tgo s.handleReconnect(addr)\n\treturn s\n}\n\nfunc (s *Session) handleReconnect(addr string) {\n\tfor {\n\t\tconn, err := s.connect(addr)\n\t\tif err != nil {\n\t\t\ts.logger.Printf(\"Failed to connect: %v\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\ts.changeConnection(conn)\n\t\tif !s.handleReInit(conn) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (s *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn.NotifyClose(s.notifyConnClose)\n\treturn conn, nil\n}\n\nfunc (s *Session) handleReInit(conn *amqp.Connection) bool {\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\ts.logger.Printf(\"Failed to open channel: %v\", err)\n\t\treturn false\n\t}\n\ts.changeChannel(ch)\n\terr = ch.Confirm(false)\n\tif err != nil {\n\t\ts.logger.Printf(\"Failed to set publisher confirms: %v\", err)\n\t\treturn false\n\t}\n\tch.NotifyPublish(s.notifyConfirm)\n\tch.NotifyClose(s.notifyChanClose)\n\ts.isReady = true\n\treturn true\n}\n\nfunc (s *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.changeChannel(ch)\n\terr = ch.Confirm(false)\n\tif err != nil {\n\t\treturn err\n\t}\n\tch.NotifyPublish(s.notifyConfirm)\n\tch.NotifyClose(s.notifyChanClose)\n\ts.isReady = true\n\treturn nil\n}\n\nfunc (s *Session) changeConnection(connection *amqp.Connection) {\n\ts.connection = connection\n\ts.connection.NotifyClose(s.notifyConnClose)\n}\n\nfunc (s *Session) changeChannel(channel *amqp.Channel) {\n\ts.channel = channel\n\ts.channel.NotifyClose(s.notifyChanClose)\n\ts.channel.NotifyPublish(s.notifyConfirm)\n}\n\nfunc (s *Session) Push(data []byte) error {\n\tfor {\n\t\tif !s.isReady {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tcontinue\n\t\t\tcase <-s.done:\n\t\t\t\treturn errors.New(\"session closed\")\n\t\t\t}\n\t\t}\n\t\terr := s.UnsafePush(data)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\ts.logger.Printf(\"Publish failed: %v\", err)\n\t\tselect {\n\t\tcase <-time.After(time.Second):\n\t\t\tcontinue\n\t\tcase <-s.done:\n\t\t\treturn errors.New(\"session closed\")\n\t\t}\n\t}\n}\n\nfunc (s *Session) UnsafePush(data []byte) error {\n\tmsg := amqp.Publishing{\n\t\tContentType: \"application/json\",\n\t\tBody:        data,\n\t}\n\treturn s.channel.Publish(\"\", s.name, false, false, msg)\n}\n```"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Implement a WebSocket client function in Go that handles OAuth-based headless authentication by establishing a connection to a server, receiving authentication instructions, and returning a JWT token upon successful authentication.\n\nFunction Description: The `ssoLogin` function establishes a WebSocket connection to a specified endpoint for headless OAuth authentication. It listens for server messages, displays authentication instructions to the user, and waits for the JWT token to be returned. The function handles connection closure and interrupts gracefully.\n\nInput: \n- `endpoint` (string): The URL endpoint of the authentication server (e.g., \"https://example.com\")\n\nOutput: \n- `string`: The JWT authentication token received from the server after successful authentication. Returns an empty string if authentication fails or is interrupted.\n\nNote: The function includes proper error handling and connection cleanup, and it displays the authentication URL to the user when received from the server.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"golang.org/x/exp/slog\"\n)\n\nfunc ssoLogin(endpoint string) string {\n\tvar (\n\t\tauthToken string\n\t\tinterrupt = make(chan os.Signal, 1)\n\t\turl, _    = url.Parse(endpoint)\n\t\tsocketURL = fmt.Sprintf(\"wss://%s/api/oauth/headless\", url.Host)\n\t)\n\tsignal.Notify(interrupt, os.Interrupt)\n\tconn, _, err := websocket.DefaultDialer.Dial(socketURL, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"error connecting to endpoint \", socketURL, err.Error())\n\t}\n\tdefer conn.Close()\n\t_, msg, err := conn.ReadMessage()\n\tif err != nil {\n\t\tlog.Fatal(\"error reading from server: \", err.Error())\n\t}\n\tfmt.Printf(\"Please visit:\\n %s \\n to authenticate\\n\", string(msg))\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tgo func() {\n\t\tfor {\n\t\t\tmsgType, msg, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif msgType < 0 {\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(err.Error(), \"normal\") {\n\t\t\t\t\tlog.Fatal(\"read error: \", err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif msgType == websocket.CloseMessage {\n\t\t\t\tdone <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(string(msg), \"JWT: \") {\n\t\t\t\tauthToken = strings.TrimPrefix(string(msg), \"JWT: \")\n\t\t\t} else {\n\t\t\t\tlogger.Log(0, \"Message from server:\", string(msg))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn authToken\n\t\tcase <-interrupt:\n\t\t\terr := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlogger.Log(0, \"write close:\", err.Error())\n\t\t\t}\n\t\t\treturn authToken\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc ssoLogin(endpoint string) (string, error) {\n\tu, err := url.Parse(endpoint)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid endpoint: %w\", err)\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tdialer := websocket.Dialer{}\n\tconn, resp, err := dialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to connect to server: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tfor {\n\t\t\tmt, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\tclose(done)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tswitch mt {\n\t\t\tcase websocket.TextMessage:\n\t\t\t\tfmt.Printf(\"Received: %s\\n\", message)\n\t\t\t\tif string(message) == \"AUTH_URL\" {\n\t\t\t\t\tvar authURL string\n\t\t\t\t\tfmt.Print(\"Please open this URL in your browser to authenticate: \")\n\t\t\t\t\tfmt.Scanln(&authURL)\n\t\t\t\t\terr = conn.WriteMessage(websocket.TextMessage, []byte(authURL))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\t\t}\n\t\t\t\t} else if string(message) == \"JWT_TOKEN\" {\n\t\t\t\t\tvar jwtToken string\n\t\t\t\t\tfmt.Print(\"Enter JWT Token: \")\n\t\t\t\t\tfmt.Scanln(&jwtToken)\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn jwtToken, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn \"\", nil\n\tcase <-ctx.Done():\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\nfunc main() {\n\tjwtToken, err := ssoLogin(\"wss://example.com/auth\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Authentication successful. JWT Token:\", jwtToken)\n}\n```"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a PKCE (Proof Key for Code Exchange) authorization flow in Go that handles OAuth2 token retrieval through a temporary HTTP server.\n\nStruct Description: PKCEAuthorizationFlow represents an OAuth2 authorization flow using PKCE (Proof Key for Code Exchange) mechanism. It manages the state, code verifier, and OAuth configuration needed for the flow, and provides methods to wait for and handle tokens.\n\nFields:\nproviderConfig: [internal.PKCEAuthProviderConfig] - Configuration for the PKCE auth provider\nstate: [string] - CSRF protection state value\ncodeVerifier: [string] - PKCE code verifier string\noAuthConfig: [*oauth2.Config] - OAuth2 configuration including client ID, secret, and endpoints\n\nMethods:\nWaitToken: [Name](ctx context.Context, _ AuthFlowInfo) -> (TokenInfo, error) - Main method that waits for token retrieval by starting a temporary HTTP server and handling the OAuth callback\nstartServer: [Name](server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) - Starts an HTTP server to handle OAuth callback and sends results through channels\nhandleRequest: [Name](req *http.Request) -> (*oauth2.Token, error) - Handles incoming OAuth callback request, validates state, and exchanges code for token",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc (p *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\ttokenChan := make(chan *oauth2.Token, 1)\n\terrChan := make(chan error, 1)\n\n\tparsedURL, err := url.Parse(p.oAuthConfig.RedirectURL)\n\tif err != nil {\n\t\treturn TokenInfo{}, fmt.Errorf(\"failed to parse redirect URL: %v\", err)\n\t}\n\n\tserver := &http.Server{Addr: fmt.Sprintf(\":%s\", parsedURL.Port())}\n\tdefer func() {\n\t\tshutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := server.Shutdown(shutdownCtx); err != nil {\n\t\t\tlog.Errorf(\"failed to close the server: %v\", err)\n\t\t}\n\t}()\n\n\tgo p.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\treturn p.parseOAuthToken(token)\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tcert := p.providerConfig.ClientCertPair\n\t\tif cert != nil {\n\t\t\ttr := &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\tCertificates: []tls.Certificate{*cert},\n\t\t\t\t},\n\t\t\t}\n\t\t\tsslClient := &http.Client{Transport: tr}\n\t\t\tctx := context.WithValue(req.Context(), oauth2.HTTPClient, sslClient)\n\t\t\treq = req.WithContext(ctx)\n\t\t}\n\n\t\ttoken, err := p.handleRequest(req)\n\t\tif err != nil {\n\t\t\trenderPKCEFlowTmpl(w, err)\n\t\t\terrChan <- fmt.Errorf(\"PKCE authorization flow failed: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\trenderPKCEFlowTmpl(w, nil)\n\t\ttokenChan <- token\n\t})\n\n\tserver.Handler = mux\n\tif err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\terrChan <- err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\n\tif authError := query.Get(queryError); authError != \"\" {\n\t\tauthErrorDesc := query.Get(queryErrorDesc)\n\t\treturn nil, fmt.Errorf(\"%s.%s\", authError, authErrorDesc)\n\t}\n\n\tif state := query.Get(queryState); subtle.ConstantTimeCompare([]byte(p.state), []byte(state)) == 0 {\n\t\treturn nil, fmt.Errorf(\"invalid state\")\n\t}\n\n\tcode := query.Get(queryCode)\n\tif code == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing code\")\n\t}\n\n\treturn p.oAuthConfig.Exchange(\n\t\treq.Context(),\n\t\tcode,\n\t\toauth2.SetAuthURLParam(\"code_verifier\", p.codeVerifier),\n\t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 104,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\ntype PKCEAuthorizationFlow struct {\n\tproviderConfig internal.PKCEAuthProviderConfig\n\tstate          string\n\tcodeVerifier   string\n\toAuthConfig    *oauth2.Config\n}\n\nfunc NewPKCEAuthorizationFlow(providerConfig internal.PKCEAuthProviderConfig, oAuthConfig *oauth2.Config) *PKCEAuthorizationFlow {\n\tverifier := make([]byte, 32)\n\trand.Read(verifier)\n\treturn &PKCEAuthorizationFlow{\n\t\tproviderConfig: providerConfig,\n\t\tstate:          generateState(),\n\t\tcodeVerifier:   base64.RawURLEncoding.EncodeToString(verifier),\n\t\toAuthConfig:    oAuthConfig,\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) WaitToken(ctx context.Context, _ AuthFlowInfo) (TokenInfo, error) {\n\ttokenChan := make(chan *oauth2.Token)\n\terrChan := make(chan error)\n\n\tserver := &http.Server{Addr: \":0\"}\n\tgo p.startServer(server, tokenChan, errChan)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn TokenInfo{}, ctx.Err()\n\tcase token := <-tokenChan:\n\t\treturn TokenInfo{AccessToken: token.AccessToken}, nil\n\tcase err := <-errChan:\n\t\treturn TokenInfo{}, err\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) startServer(server *http.Server, tokenChan chan<- *oauth2.Token, errChan chan<- error) {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif token, err := p.handleRequest(r); err != nil {\n\t\t\terrChan <- err\n\t\t} else {\n\t\t\ttokenChan <- token\n\t\t}\n\t\tclose(tokenChan)\n\t\tclose(errChan)\n\t})\n\n\tgo func() {\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\t// Wait for the server to start and get the address\n\ttime.Sleep(100 * time.Millisecond)\n\turl := fmt.Sprintf(\"http://%s/auth/callback\", server.Addr)\n\tp.providerConfig.RedirectURL = url\n\n\t// Start the OAuth2 authorization process\n\tauthURL := p.oAuthConfig.AuthCodeURL(p.state, oauth2.AccessTypeOffline, oauth2.SetAuthURLParam(\"code_challenge_method\", \"S256\"), oauth2.SetAuthURLParam(\"code_challenge\", p.codeVerifier))\n\tfmt.Println(\"Please visit:\", authURL)\n\n\t// This part would typically involve user interaction to open the URL and authorize the application\n\t// For demonstration purposes, we'll skip this step\n\t// Normally, you would use a web browser or a headless browser control library to automate this step\n\t// Once authorized, the user will be redirected back to the redirect URI with the authorization code\n\t// You would then exchange the authorization code for a token\n\t// Here we simulate the redirection with a dummy authorization code\n\t// In practice, this should be handled by the HTTP server\n\t// Replace \"dummy_authorization_code\" with the actual authorization code received from the user\n\t// Replace \"dummy_state\" with the actual state received from the user\n\tdummyAuthorizationCode := \"dummy_authorization_code\"\n\tdummyState := \"dummy_state\"\n\n\tif r := http.NewRequest(http.MethodGet, \"/auth/callback?code=\"+dummyAuthorizationCode+\"&state=\"+dummyState, nil); r != nil {\n\t\tp.handleRequest(r)\n\t}\n}\n\nfunc (p *PKCEAuthorizationFlow) handleRequest(req *http.Request) (*oauth2.Token, error) {\n\tquery := req.URL.Query()\n\tstate := query.Get(\"state\")\n\tcode := query.Get(\"code\")\n\n\tif state != p.state {\n\t\treturn nil, fmt.Errorf(\"invalid state parameter\")\n\t}\n\n\ttoken, err := p.oAuthConfig.Exchange(context.Background(), code)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn token, nil\n}\n\nfunc generateState() string {\n\tb := make([]byte, 16)\n\trand.Read(b)\n\treturn base64.StdEncoding.EncodeToString(b)\n}\n\ntype TokenInfo struct {\n\tAccessToken string `json:\"access_token\"`\n}\n\ntype AuthFlowInfo struct{}\n\ntype internal struct {\n\tPKCEAuthProviderConfig struct {\n\t\tRedirectURL string\n\t}\n}\n```"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that establishes multiple concurrent connections to a WebSocket server, maintains these connections, and handles incoming messages. The client should be able to gracefully handle connection errors and properly close connections when done.\n\nFunction Description: The function establishes WebSocket connections to a specified server endpoint with unique identifiers, maintains these connections in separate goroutines, and continuously reads incoming messages. Each connection includes user identification and authentication parameters in the URL query string.\n\nInput: \n- None (The function uses hardcoded values for demonstration, but could be modified to accept parameters like host, port, path, and connection count)\n\nOutput: \n- None (The function primarily logs its activities and errors to stdout)\n\nNote: The function runs indefinitely until 100,000 connections are established (for testing purposes), with each connection attempt spaced by 1 second. Each connection runs in its own goroutine and includes error handling for both connection establishment and message reading.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"log\"\n\t\"net/url\"\n\t\"time\"\n)\n\nfunc Test(t *testing.T) {\n\ti := 0\n\tfor {\n\t\ti++\n\t\tif i == 100000 {\n\t\t\tfmt.Println(\"\u5df2\u7ecf\u4e86\u89e310000\u4e2a\u94fe\u63a5\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tgo func(id int) {\n\t\t\tu := url.URL{Scheme: \"ws\", Host: \"127.0.0.1:8182\", Path: \"/v1/push\", RawQuery: fmt.Sprintf(\"uid=%d&sign=2&time=%d\", id, time.Now().Unix())}\n\t\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"\u94fe\u63a5\u5730\u5740%s,\u5931\u8d25\u539f\u56e0%s\", u.String(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tfor {\n\t\t\t\t_, _, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"ERR_ERR_ERR_ERR_ERR_ERR_read:\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\ttotalConnections := 100000\n\turlString := \"ws://localhost:8080/socket?userId=123&authToken=abc\"\n\tu, err := url.Parse(urlString)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse URL: %v\", err)\n\t}\n\n\tfor i := 0; i < totalConnections; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tdialer := websocket.Dialer{\n\t\t\t\tReadBufferSize:  1024,\n\t\t\t\tWriteBufferSize: 1024,\n\t\t\t}\n\t\t\tconn, resp, err := dialer.Dial(u.String(), nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Connection %d failed: %v\", i, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\tif resp != nil {\n\t\t\t\tlog.Printf(\"Response received from server: %+v\\n\", resp.Status)\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\t_, message, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Connection %d read error: %v\", i, err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfmt.Printf(\"Received message on connection %d: %s\\n\", i, message)\n\t\t\t}\n\t\t}(i)\n\t\ttime.Sleep(time.Second)\n\t}\n\n\twg.Wait()\n\tlog.Println(\"All connections have been established and maintained.\")\n}\n```"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a WebSocket client in Go that can establish a connection to a server, handle bidirectional communication (sending and receiving messages), and properly manage connection lifecycle.\n\nStruct Description: The Listener struct represents a WebSocket client that connects to a specified URL, handles message processing with optional schema transformation, and manages concurrent read/write operations.\n\nFields:\n- URL: *url.URL - The WebSocket server URL to connect to\n- Token: string - Authentication token to be included in the connection URL\n- SchemaFunc: func([]byte) (io.Reader, error) - Optional function to transform incoming messages\n- Out: io.Writer - Output writer for received messages\n- InCh: <-chan []byte - Input channel for sending messages to the server\n\nMethods:\n- NewListener: (url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) -> *Listener - Creates a new Listener instance with the specified configuration\n- Listen: (ctx context.Context) -> error - Establishes WebSocket connection, handles concurrent message reading/writing, and manages connection lifecycle until context cancellation or normal closure",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype Listener struct {\n\tURL        *url.URL\n\tToken      string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut        io.Writer\n\tInCh       <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:        url,\n\t\tToken:      token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:        out,\n\t\tInCh:       inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tif l.Token != \"\" {\n\t\tparams := l.URL.Query()\n\t\tparams.Set(\"token\", l.Token)\n\t\tl.URL.RawQuery = params.Encode()\n\t}\n\n\tc, _, err := websocket.DefaultDialer.Dial(l.URL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating websocket connection: %w\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tgrp.Go(func() error {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"error reading from websocket: %w\", err)\n\t\t\t}\n\n\t\t\tvar r io.Reader\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\tr, err = l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = bytes.NewReader(message)\n\t\t\t}\n\n\t\t\tio.Copy(l.Out, r)\n\t\t}\n\t})\n\n\tgrp.Go(func() error {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-l.InCh:\n\t\t\t\tif err := c.WriteMessage(websocket.TextMessage, data); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing to websocket: %w\", err)\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing close message: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\tcase <-done:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t})\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 115,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Listener struct {\n\tURL      *url.URL\n\tToken    string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut      io.Writer\n\tInCh     <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:      url,\n\t\tToken:    token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:      out,\n\t\tInCh:     inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tdialer := websocket.Dialer{Timeout: 5 * time.Second}\n\tconn, resp, err := dialer.Dial(l.URL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to %s: %w\", l.URL, err)\n\t}\n\tdefer conn.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tcase msg := <-l.InCh:\n\t\t\t\terr := conn.WriteMessage(websocket.TextMessage, msg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(l.Out, \"Failed to send message: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\t_, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(l.Out, \"Failed to receive message: %v\\n\", err)\n\t\t\t\tclose(done)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\treader, err := l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(l.Out, \"Schema transformation failed: %v\\n\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmessage, _ = io.ReadAll(reader)\n\t\t\t}\n\t\t\tfmt.Fprintf(l.Out, \"Received message: %s\\n\", message)\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\tclose(done)\n\treturn ctx.Err()\n}\n```"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: The task involves testing a WebSocket connection to a runtime service, verifying the connection establishment, message exchange, and validating the received runtime information against expected values.\n\nFunction Description: The function `TestRuntimeGetRuntime` tests the WebSocket-based communication with a runtime service. It establishes a connection, sends a request message, receives and parses the response, then validates the response contents including protocol, version, capabilities, and runtime ID.\n\nInput: \n- None (This is a test function that takes a testing.T pointer as per Go testing conventions)\n\nOutput: \n- None (The function reports errors through the testing.T parameter if any assertions fail)\n- Side effect: The test will pass if all validations succeed or fail with appropriate error messages if any checks don't match expected values",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\tensureRuntimeStarted()\n\tws, _, err := websocket.DefaultDialer.Dial(\"ws://localhost:13014/\", nil)\n\tdefer ws.Close()\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif err = sendJSONE(ws, &Message{\"runtime\", \"getruntime\", nil}); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tvar msg runtimeMessage\n\tvar bytes []byte\n\tif _, bytes, err = ws.ReadMessage(); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif err = json.Unmarshal(bytes, &msg); err != nil {\n\t\tt.Error(err.Error())\n\t\treturn\n\t}\n\tif msg.Protocol != \"runtime\" || msg.Command != \"runtime\" {\n\t\tt.Errorf(\"Invalid protocol (%s) or command (%s)\", msg.Protocol, msg.Command)\n\t\treturn\n\t}\n\tres := msg.Payload\n\tif res.Type != \"goflow\" {\n\t\tt.Errorf(\"Invalid protocol type: %s\\n\", res.Type)\n\t}\n\tif res.Version != \"0.4\" {\n\t\tt.Errorf(\"Invalid protocol version: %s\\n\", res.Version)\n\t}\n\tif len(res.Capabilities) != 5 {\n\t\tt.Errorf(\"Invalid number of supported capabilities: %v\\n\", res.Capabilities)\n\t}\n\tif res.Id == \"\" {\n\t\tt.Error(\"Runtime Id is empty\")\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"testing\"\n\t\"net/url\"\n\t\"github.com/gorilla/websocket\"\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype RuntimeInfo struct {\n\tProtocol  string   `json:\"protocol\"`\n\tVersion   string   `json:\"version\"`\n\tCapabilities []string `json:\"capabilities\"`\n\tRuntimeID string   `json:\"runtime_id\"`\n}\n\nfunc TestRuntimeGetRuntime(t *testing.T) {\n\tu := url.URL{Scheme: \"ws\", Host: \"localhost:8080\", Path: \"/runtime\"}\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to connect: %v\", err)\n\t}\n\tdefer c.Close()\n\n\tmessage := json.RawMessage(`{\"command\": \"get_runtime\"}`)\n\terr = c.WriteJSON(message)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to send message: %v\", err)\n\t}\n\n\tvar resp RuntimeInfo\n\terr = c.ReadJSON(&resp)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to receive message: %v\", err)\n\t}\n\n\texpectedProtocol := \"websocket\"\n\texpectedVersion := \"1.0\"\n\texpectedCapabilities := []string{\"debug\", \"trace\"}\n\texpectedRuntimeID := \"runtime-123\"\n\n\tif resp.Protocol != expectedProtocol {\n\t\tt.Errorf(\"Expected protocol '%s', got '%s'\", expectedProtocol, resp.Protocol)\n\t}\n\tif resp.Version != expectedVersion {\n\t\tt.Errorf(\"Expected version '%s', got '%s'\", expectedVersion, resp.Version)\n\t}\n\tif !reflect.DeepEqual(resp.Capabilities, expectedCapabilities) {\n\t\tt.Errorf(\"Expected capabilities '%v', got '%v'\", expectedCapabilities, resp.Capabilities)\n\t}\n\tif resp.RuntimeID != expectedRuntimeID {\n\t\tt.Errorf(\"Expected runtime ID '%s', got '%s'\", expectedRuntimeID, resp.RuntimeID)\n\t}\n}\n```"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a WebSocket client in Go that connects to a server, handles incoming messages, and manages connection lifecycle including reconnection logic and graceful shutdown.\n\nFunction Description: The function establishes a WebSocket connection to a specified server endpoint, listens for incoming messages, and prints them to stdout/stderr based on message content. It handles connection errors by implementing automatic reconnection logic and supports graceful shutdown upon receiving an interrupt signal.\n\nInput: None (uses package-level configuration variables for connection details)\n\nOutput: None (writes directly to stdout/stderr, logs to console)\n\nNote: The function relies on several external configuration variables:\n- config.Config.Tap.Proxy.Host (string) - Server hostname\n- config.Config.Tap.Proxy.Front.Port (int) - Server port\n- config.Config.License (string) - License key for authentication\n- kubernetes.GetHubUrl() (string) - Function to get hub URL for health checks",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/kubeshark/kubeshark/config\"\n\t\"github.com/kubeshark/kubeshark/utils\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc runConsoleWithoutProxy() {\n\tlog.Info().Msg(\"Starting scripting console ...\")\n\ttime.Sleep(5 * time.Second)\n\thubUrl := kubernetes.GetHubUrl()\n\tfor {\n\t\tresponse, err := http.Get(fmt.Sprintf(\"%s/echo\", hubUrl))\n\t\tif err != nil || response.StatusCode != 200 {\n\t\t\tlog.Info().Msg(fmt.Sprintf(utils.Yellow, \"Couldn't connect to Hub.\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tinterrupt := make(chan os.Signal, 1)\n\t\tsignal.Notify(interrupt, os.Interrupt)\n\n\t\tlog.Info().Str(\"host\", config.Config.Tap.Proxy.Host).Str(\"url\", hubUrl).Msg(\"Connecting to:\")\n\t\tu := url.URL{\n\t\t\tScheme: \"ws\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%d\", config.Config.Tap.Proxy.Host, config.Config.Tap.Proxy.Front.Port),\n\t\t\tPath:   \"/api/scripts/logs\",\n\t\t}\n\t\theaders := http.Header{}\n\t\theaders.Set(utils.X_KUBESHARK_CAPTURE_HEADER_KEY, utils.X_KUBESHARK_CAPTURE_HEADER_IGNORE_VALUE)\n\t\theaders.Set(\"License-Key\", config.Config.License)\n\n\t\tc, _, err := websocket.DefaultDialer.Dial(u.String(), headers)\n\t\tif err != nil {\n\t\t\tlog.Error().Err(err).Msg(\"Websocket dial error, retrying in 5 seconds...\")\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tdefer c.Close()\n\n\t\tdone := make(chan struct{})\n\n\t\tgo func() {\n\t\t\tdefer close(done)\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error().Err(err).Msg(\"Error reading websocket message, reconnecting...\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tmsg := string(message)\n\t\t\t\tif strings.Contains(msg, \":ERROR]\") {\n\t\t\t\t\tmsg = fmt.Sprintf(utils.Red, msg)\n\t\t\t\t\tfmt.Fprintln(os.Stderr, msg)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintln(os.Stdout, msg)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tticker := time.NewTicker(time.Second)\n\t\tdefer ticker.Stop()\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\tlog.Warn().Msg(fmt.Sprintf(utils.Yellow, \"Connection closed, reconnecting...\"))\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tcontinue\n\t\tcase <-interrupt:\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Error().Err(err).Send()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 115,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"k8s.io/client-go/kubernetes\"\n)\n\nvar (\n\thost = flag.String(\"host\", \"\", \"Server hostname\")\n\tport = flag.Int(\"port\", 0, \"Server port\")\n\tlicense = flag.String(\"license\", \"\", \"License key for authentication\")\n\thubURL = flag.String(\"hub-url\", \"\", \"Hub URL for health checks\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tif *host == \"\" || *port == 0 || *license == \"\" || *hubURL == \"\" {\n\t\tlog.Fatal(\"Missing required flags\")\n\t}\n\n\tu := url.URL{Scheme: \"ws\", Host: fmt.Sprintf(\"%s:%d\", *host, *port), Path: \"/\"}\n\tdialer := websocket.Dialer{}\n\tconn, resp, err := dialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\tlog.Println(\"Connected to server\")\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-interrupt:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error reading message: %v\", err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tswitch messageType {\n\t\t\t\tcase websocket.TextMessage:\n\t\t\t\t\tlog.Println(string(message))\n\t\t\t\tcase websocket.BinaryMessage:\n\t\t\t\t\tlog.Println(\"Binary message received\")\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Println(\"Unknown message type\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tticker := time.NewTicker(time.Second * 30)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\terr := conn.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error sending ping: %v\", err)\n\t\t\t\t}\n\t\t\tcase <-interrupt:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n\tlog.Println(\"Gracefully shutting down\")\n}\n```"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Implement a WebSocket handler for shell communication that manages bidirectional data transfer between local and remote connections, including connection upgrading, message forwarding, and proper connection cleanup.\n\nStruct Description: The Shell struct represents a shell session manager that maintains active connections and handles WebSocket communication for shell data transfer.\n\nFields:\n- Name: string - Identifier for the shell session\n- links: map[string]*Link - Map of active connections indexed by connection ID\n- RWMutex: sync.RWMutex - Synchronization primitive for thread-safe access to the links map\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages bidirectional data forwarding between local and remote connections\n- localForward: (id string, local *websocket.Conn) -> None - Reads data from local WebSocket connection and forwards to remote\n- remoteForward: (id string, local *websocket.Conn) -> None - Reads data from remote connection and forwards to local WebSocket",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype Shell struct {\n\tName string\n\tlinks map[string]*Link\n\tsync.RWMutex\n}\n\nfunc (shell *Shell) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogging.Error(\"upgrade websocket failed: %s, err=%v\", shell.Name, err)\n\t\thttp.Error(w, err.Error(), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tdefer local.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.localForward(id, local)\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tshell.remoteForward(id, local)\n\t}()\n\twg.Wait()\n}\n\nfunc (shell *Shell) localForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"localForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tdefer link.Close(true)\n\tfor {\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"read local data for %s failed: %v\", shell.Name, err)\n\t\t\treturn\n\t\t}\n\t\tlink.SendData(data)\n\t\tlogging.Debug(\"local read %d bytes: name=%s, id=%s\", len(data), shell.Name, id)\n\t}\n}\n\nfunc (shell *Shell) remoteForward(id string, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteForward\")\n\tdefer local.Close()\n\tshell.RLock()\n\tlink := shell.links[id]\n\tshell.RUnlock()\n\tch := link.remote.ChanRead(id)\n\tdefer link.Close(true)\n\tfor {\n\t\tmsg := <-ch\n\t\tif msg == nil {\n\t\t\treturn\n\t\t}\n\t\tdata, _ := proto.Marshal(msg)\n\t\tlink.recvBytes += uint64(len(data))\n\t\tlink.recvPacket++\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_shell_data:\n\t\t\terr := local.WriteMessage(websocket.TextMessage, msg.GetSdata().GetData())\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write data for %s failed: %v\", shell.Name, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogging.Debug(\"remote read %d bytes: name=%s, id=%s\",\n\t\t\t\tlen(msg.GetSdata().GetData()), shell.Name, id)\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Link struct {\n\tremote *websocket.Conn\n\tlocal  *websocket.Conn\n}\n\ntype Shell struct {\n\tName    string\n\tlinks   map[string]*Link\n\tRWMutex sync.RWMutex\n}\n\nfunc (s *Shell) WS(conn *websocket.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := r.URL.Query().Get(\"id\")\n\tif id == \"\" {\n\t\thttp.Error(w, \"Missing connection ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ts.RWMutex.Lock()\n\tif _, exists := s.links[id]; exists {\n\t\ts.RWMutex.Unlock()\n\t\thttp.Error(w, \"Connection already exists\", http.StatusConflict)\n\t\treturn\n\t}\n\ts.links[id] = &Link{}\n\ts.RWMutex.Unlock()\n\n\tdefer func() {\n\t\ts.RWMutex.Lock()\n\t\tdelete(s.links, id)\n\t\ts.RWMutex.Unlock()\n\t}()\n\n\ts.links[id].local = conn\n\n\tgo s.remoteForward(id, conn)\n\ts.localForward(id, conn)\n}\n\nfunc (s *Shell) localForward(id string, local *websocket.Conn) {\n\tfor {\n\t\tmessageType, message, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ts.RWMutex.RLock()\n\t\tlink, exists := s.links[id]\n\t\ts.RWMutex.RUnlock()\n\t\tif !exists {\n\t\t\treturn\n\t\t}\n\t\terr = link.remote.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *Shell) remoteForward(id string, local *websocket.Conn) {\n\tfor {\n\t\tmessageType, message, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ts.RWMutex.RLock()\n\t\tlink, exists := s.links[id]\n\t\ts.RWMutex.RUnlock()\n\t\tif !exists {\n\t\t\treturn\n\t\t}\n\t\terr = link.remote.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n```"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that manages WebSocket connections, including upgrading HTTP connections, reading incoming messages, writing periodic messages, and properly closing the connection.\n\nFunction Description: The `wsHandler` function creates an HTTP handler that upgrades incoming HTTP requests to WebSocket connections. It continuously writes numbered messages to the client while concurrently reading any incoming messages from the client. The function stops after sending a specified number of messages and closes the connection gracefully.\n\nInput:\n- `t *testing.T`: Testing context for error reporting\n- `recvBuffer *bytes.Buffer`: Buffer to store received messages from the WebSocket client\n\nOutput:\n- Returns an `http.HandlerFunc` that implements the WebSocket handling logic\n\nNote: The function doesn't directly return values but rather creates a handler function that manages WebSocket communication through the provided buffer and testing context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{}\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\trequire.NoError(t, err)\n\t\tdefer c.Close()\n\t\ti := 0\n\t\tfinish := 5\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trecvBuffer.Write(message)\n\t\t\t}\n\t\t}()\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\n\t\t\ti++\n\t\t\tdata := struct {\n\t\t\t\tMessage string `json:\"message\"`\n\t\t\t}{\n\t\t\t\tMessage: fmt.Sprintf(\"%d\\n\", i),\n\t\t\t}\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\terr := json.NewEncoder(buf).Encode(data)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = c.WriteMessage(websocket.TextMessage, buf.Bytes())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif i == finish {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\terr = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\trequire.NoError(t, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage websocket_test\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc wsHandler(t *testing.T, recvBuffer *bytes.Buffer) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := websocket.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to upgrade connection: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\twriteMessages(conn, t)\n\t\treadMessages(conn, recvBuffer, t)\n\t}\n}\n\nfunc writeMessages(conn *websocket.Conn, t *testing.T) {\n\tfor i := 1; i <= 5; i++ {\n\t\terr := conn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf(\"message %d\", i)))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to send message: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc readMessages(conn *websocket.Conn, recvBuffer *bytes.Buffer, t *testing.T) {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\t\tt.Errorf(\"Error during read: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif messageType == websocket.TextMessage {\n\t\t\t\trecvBuffer.WriteString(string(message))\n\t\t\t}\n\t\t}\n\t}()\n\n\t<-done\n}\n```"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Implement a WebSocket handler for processing VNC-related messages, including image capture data and clipboard events, using gorilla WebSocket library in Go.\n\nStruct Description: The Process struct manages WebSocket connections for VNC operations, handling message passing between the WebSocket connection and internal channels.\n\nFields:\n- srv: *http.Server - HTTP server instance\n- chWrite: chan *vncnetwork.VncMsg - Channel for outgoing VNC messages\n- chImage: chan *vncnetwork.ImageData - Channel for incoming image data\n- chClipboard: chan *vncnetwork.ClipboardData - Channel for incoming clipboard data\n\nMethods:\n- ws: (w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket connections, upgrades HTTP to WebSocket, and manages message reading/writing\n- Close: () -> None - Closes the WebSocket connection and cleans up resources (implied by defer p.Close() in ws method)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/rule/vnc/vncnetwork\"\n\t\"github.com/lwch/natpass/code/utils\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype Process struct {\n\tsrv         *http.Server\n\tchWrite     chan *vncnetwork.VncMsg\n\tchImage     chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nvar upgrader = websocket.Upgrader{EnableCompression: true}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tlogging.Info(\"child process connected\")\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tdefer p.Close()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer utils.Recover(\"ws read\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\t_, data, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"read message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar msg vncnetwork.VncMsg\n\t\t\terr = proto.Unmarshal(data, &msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch msg.GetXType() {\n\t\t\tcase vncnetwork.VncMsg_capture_data:\n\t\t\t\tp.chImage <- msg.GetData()\n\t\t\tcase vncnetwork.VncMsg_clipboard_event:\n\t\t\t\tp.chClipboard <- msg.GetClipboard()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer utils.Recover(\"ws write\")\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tmsg := <-p.chWrite\n\t\t\tdata, err := proto.Marshal(msg)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = conn.WriteMessage(websocket.BinaryMessage, data)\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"write message: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\twg.Wait()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n\t\"vncnetwork\"\n)\n\ntype Process struct {\n\tsrv       *http.Server\n\tchWrite   chan *vncnetwork.VncMsg\n\tchImage   chan *vncnetwork.ImageData\n\tchClipboard chan *vncnetwork.ClipboardData\n}\n\nfunc (p *Process) ws(w http.ResponseWriter, r *http.Request) {\n\tconn, err := websocket.Upgrade(w, r, nil)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch messageType {\n\t\tcase websocket.TextMessage:\n\t\t\tvar vncMsg vncnetwork.VncMsg\n\t\t\terr = json.Unmarshal(message, &vncMsg)\n\t\t\tif err == nil {\n\t\t\t\tp.chWrite <- &vncMsg\n\t\t\t}\n\t\tcase websocket.BinaryMessage:\n\t\t\tvar imageData vncnetwork.ImageData\n\t\t\terr = json.Unmarshal(message, &imageData)\n\t\t\tif err == nil {\n\t\t\t\tp.chImage <- &imageData\n\t\t\t}\n\t\tcase websocket.ApplicationMessage:\n\t\t\tvar clipboardData vncnetwork.ClipboardData\n\t\t\terr = json.Unmarshal(message, &clipboardData)\n\t\t\tif err == nil {\n\t\t\t\tp.chClipboard <- &clipboardData\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *Process) Close() {\n\t// Cleanup logic here\n}\n\nfunc main() {\n\tprocess := &Process{\n\t\tsrv:       &http.Server{Addr: \":8080\"},\n\t\tchWrite:   make(chan *vncnetwork.VncMsg),\n\t\tchImage:   make(chan *vncnetwork.ImageData),\n\t\tchClipboard: make(chan *vncnetwork.ClipboardData),\n\t}\n\n\thttp.HandleFunc(\"/ws\", process.ws)\n\tgo func() {\n\t\tprocess.srv.ListenAndServe()\n\t}()\n\n\t// Additional logic to handle channels and other processes\n}\n```"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Create a test WebSocket server that echoes received messages back to the client while notifying a channel for each received message.\n\nFunction Description: The function creates an HTTP test server with WebSocket support. It upgrades incoming HTTP connections to WebSocket, reads incoming messages, notifies a channel when a message is received, and echoes the message back to the client. The server runs until the connection is closed.\n\nInput:\n- t *testing.T: Testing context for error reporting\n- received chan struct{}: Channel to notify when a message is received\n\nOutput:\n- *httptest.Server: Pointer to the created HTTP test server instance",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\n\tgorillawebsocket \"github.com/gorilla/websocket\"\n)\n\nfunc testService(t *testing.T, received chan struct{}) *httptest.Server {\n\tvar httpHandler http.HandlerFunc = func(w http.ResponseWriter, r *http.Request) {\n\t\tvar upgrader gorillawebsocket.Upgrader\n\n\t\tconn, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error upgrading websocket:\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\t\tfor {\n\t\t\tt, b, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treceived <- struct{}{}\n\n\t\t\tconn.WriteMessage(t, b)\n\t\t}\n\t}\n\n\treturn httptest.NewServer(httpHandler)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nfunc TestWebSocketServer(t *testing.T) {\n\treceived := make(chan struct{})\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, err := websocket.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to upgrade connection: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmessageType, message, err := conn.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-received:\n\t\t\t\t// Notify that a message has been received\n\t\t\tdefault:\n\t\t\t\tclose(received)\n\t\t\t}\n\n\t\t\terr = conn.WriteMessage(messageType, message)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to write message: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}))\n\tdefer server.Close()\n\n\t// Simulate sending a message to the WebSocket server\n\tconn, _, err := websocket.DefaultDialer.Dial(server.URL, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to dial WebSocket server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\terr = conn.WriteMessage(websocket.TextMessage, []byte(\"test message\"))\n\tif err != nil {\n\t\tt.Errorf(\"Failed to send message: %v\", err)\n\t}\n\n\t<-received // Wait for the message to be received\n}\n```"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Implement a WebSocket handler function in Go that upgrades an HTTP connection to a WebSocket connection, manages WebSocket connections, and handles message reading.\n\nFunction Description: The function `NotifyWS` handles WebSocket connections by upgrading an HTTP request to a WebSocket connection using the Gorilla WebSocket upgrader. It adds the new WebSocket connection to a global list of connections and ensures a message-sending service is running. The function then continuously reads messages from the WebSocket connection until it is closed.\n\nInput: \n- `ctx echo.Context`: An Echo framework context object representing the HTTP request and response. This is used to access the underlying HTTP connection for WebSocket upgrade.\n\nOutput: \n- `error`: Returns an error if the WebSocket upgrade fails, otherwise returns `nil` after the WebSocket connection is closed.\n\nNote: The function does not explicitly return any output other than potential errors, but it interacts with global state (`service.WebSocketConns` and `service.SocketRun`) and performs I/O operations on the WebSocket connection.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar upGrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc NotifyWS(ctx echo.Context) error {\n\tws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdefer ws.Close()\n\tservice.WebSocketConns = append(service.WebSocketConns, ws)\n\n\tif !service.SocketRun {\n\t\tservice.SocketRun = true\n\t\tservice.SendMeg()\n\t}\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tfmt.Println(mt, message, err)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\nfunc NotifyWS(ctx echo.Context) error {\n    ws, err := service.Upgrader.Upgrade(ctx.Response().Writer(), ctx.Request(), nil)\n    if err != nil {\n        return err\n    }\n    defer ws.Close()\n\n    service.WebSocketConns <- ws\n\n    go func() {\n        for {\n            _, message, err := ws.ReadMessage()\n            if err != nil {\n                break\n            }\n            // Handle received message\n        }\n    }()\n\n    select {}\n}\n```"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Create a WebSocket handler function that establishes an SSH connection through a WebSocket interface, allowing for terminal-like interaction with a remote host.\n\nFunction Description: The function `ConnectSshPmExec` handles WebSocket connections to facilitate SSH terminal sessions. It upgrades an HTTP connection to WebSocket, validates host credentials, establishes an SSH connection, and manages bidirectional communication between the WebSocket client and SSH server. The function includes error handling and resource cleanup.\n\nInput:\n- `c` (gin.Context) - Gin framework context for HTTP request handling\n- `username` (string) - Username for authentication (unused in current implementation)\n- `envName` (string) - Environment name (unused in current implementation)\n- `productName` (string) - Product name (unused in current implementation)\n- `ip` (string) - IP address of the target host\n- `hostId` (string) - Identifier for the host's private key\n- `cols` (int) - Terminal column size\n- `rows` (int) - Terminal row size\n- `log` (*zap.SugaredLogger) - Logger for error reporting\n\nOutput:\n- `error` - Returns nil on success, or an error object if any step fails",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ssh\"\n\n\tcommonrepo \"github.com/koderover/zadig/v2/pkg/microservice/aslan/core/common/repository/mongodb\"\n\t\"github.com/koderover/zadig/v2/pkg/setting\"\n\te \"github.com/koderover/zadig/v2/pkg/tool/errors\"\n\ttoolssh \"github.com/koderover/zadig/v2/pkg/tool/ssh\"\n\t\"github.com/koderover/zadig/v2/pkg/tool/wsconn\"\n\t\"github.com/koderover/zadig/v2/pkg/util\"\n)\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\nfunc ConnectSshPmExec(c *gin.Context, username, envName, productName, ip, hostId string, cols, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"ws upgrade err:%s\", err)\n\t\treturn e.ErrLoginPm.AddErr(err)\n\t}\n\n\tdefer ws.Close()\n\tresp, err := commonrepo.NewPrivateKeyColl().Find(commonrepo.FindPrivateKeyOption{\n\t\tID: hostId,\n\t})\n\tif err != nil {\n\t\tlog.Errorf(\"PrivateKey.Find ip %s id %s error: %s\", ip, hostId, err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrGetPrivateKey.Error()))\n\t\treturn e.ErrGetPrivateKey\n\n\t}\n\tif resp.Status != setting.PMHostStatusNormal {\n\t\tlog.Errorf(\"host %s status %s, is not normal\", ip, resp.Status)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s status %s,is not normal\", ip, resp.Status))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.ScheduleWorkflow {\n\t\tlog.Errorf(\"host %s is not enable login\", ip)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s is not enable ssh\", ip))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.Port == 0 {\n\t\tresp.Port = setting.PMHostDefaultPort\n\t}\n\n\tsDec, err := base64.StdEncoding.DecodeString(resp.PrivateKey)\n\tif err != nil {\n\t\tlog.Errorf(\"base64 decode failed ip:%s, error:%s\", ip, err)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"base64 decode failed ip:%s, error:%s\", ip, err))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\n\tsshCli, err := toolssh.NewSshCli(sDec, resp.UserName, resp.IP, resp.Port)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshCli err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshCli.Close()\n\n\tsshConn, err := wsconn.NewSshConn(cols, rows, sshCli)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshConn err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshConn.Close()\n\n\tstopChan := make(chan bool, 3)\n\tgo sshConn.ReadWsMessage(ws, stopChan)\n\tgo sshConn.SendWsWriteMessage(ws, stopChan)\n\tgo sshConn.SessionWait(stopChan)\n\n\t<-stopChan\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc ConnectSshPmExec(c *gin.Context, username string, envName string, productName string, ip string, hostId string, cols int, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to set websocket upgrade: %v\", err)\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tprivateKeyPath := \"/path/to/private/key/\" + hostId + \".pem\"\n\tsigner, err := ssh.ParsePrivateKeyFile(privateKeyPath)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to parse private key: %v\", err)\n\t\treturn err\n\t}\n\n\tconfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(signer),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\n\tclient, err := ssh.Dial(\"tcp\", ip+\":22\", config)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to dial SSH: %v\", err)\n\t\treturn err\n\t}\n\tdefer client.Close()\n\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to create session: %v\", err)\n\t\treturn err\n\t}\n\tdefer session.Close()\n\n\tmodes := ssh.TerminalModes{\n\t\tssh.ECHO:          1,\n\t\tssh.TTY_OP_ISPEED: 14400,\n\t\tssh.TTY_OP_OSPEED: 14400,\n\t}\n\n\terr = session.RequestPty(\"xterm\", rows, cols, modes)\n\tif err != nil {\n\t\tlog.Errorf(\"Request for pseudo terminal failed: %v\", err)\n\t\treturn err\n\t}\n\n\tstdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to obtain stdin pipe: %v\", err)\n\t\treturn err\n\t}\n\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to obtain stdout pipe: %v\", err)\n\t\treturn err\n\t}\n\n\tstderr, err := session.StderrPipe()\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to obtain stderr pipe: %v\", err)\n\t\treturn err\n\t}\n\n\tgo func() {\n\t\tbuf := make([]byte, 1024)\n\t\tfor {\n\t\t\tn, err := stdout.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Error reading stdout: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tws.WriteMessage(websocket.TextMessage, buf[:n])\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tbuf := make([]byte, 1024)\n\t\tfor {\n\t\t\tn, err := stderr.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Error reading stderr: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tws.WriteMessage(websocket.TextMessage, buf[:n])\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tmessageType, message, err := ws.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Error reading from websocket: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif messageType == websocket.TextMessage {\n\t\t\t\t_, err := stdin.Write(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Errorf(\"Error writing to stdin: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\terr = session.Shell()\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to start shell: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Implement a WebSocket echo server function in Go that handles WebSocket connections, reads incoming messages, and echoes them back to the client.\n\nFunction Description: The `echo` function upgrades an HTTP connection to a WebSocket connection, continuously reads messages from the client, and echoes them back. It handles connection errors and ensures proper cleanup by closing the connection when done.\n\nInput: \n- `ctx *gin.Context`: A Gin context object containing the HTTP request and response writer needed for WebSocket upgrade.\n\nOutput: \n- None (void function), but it performs the following operations:\n  - Upgrades the HTTP connection to WebSocket\n  - Reads and echoes messages until connection is closed\n  - Handles and logs errors\n  - Closes the WebSocket connection when done",
    "Canonical_solution": "import (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\nfunc echo(ctx *gin.Context) {\n\tw,r := ctx.Writer, ctx.Request\n\tc, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"upgrade:\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tfor {\n\t\tmt, message, err := c.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv:%s\", message)\n\t\terr = c.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 114,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc echo(ctx *gin.Context) {\n\tconn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)\n\tif err != nil {\n\t\tlog.Println(\"Failed to set websocket upgrade:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.GET(\"/ws\", echo)\n\tr.Run(\":8080\")\n}\n```"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Implement a Go struct that tests the health of an NTP (Network Time Protocol) server by checking its stratum level through UDP communication.\n\nStruct Description: The NtpHealthTester struct is responsible for verifying the health of an NTP server by establishing a UDP connection, sending a query, and validating the server's response based on its stratum level. The struct includes methods for testing the server and providing a string representation of the maximum allowed stratum.\n\nFields:\nmaxStratum: int - The maximum acceptable stratum level for the NTP server to be considered healthy.\n\nMethods:\nTest: (ht *HealthTest) -> bool - Tests the health of an NTP server by sending a UDP packet and validating the response. Returns true if the server's stratum is within the acceptable range, false otherwise.\nString: () -> string - Returns a string representation of the maximum allowed stratum level.\nnewNtpHealthTester: (params map[string]interface{}, htp *HealthTestParameters) -> HealthTester - A constructor function that creates a new NtpHealthTester instance with the specified maximum stratum level.",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"time\"\n)\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (t *NtpHealthTester) Test(ht *HealthTest) bool {\n\tudpAddress, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(ht.ipAddress.String(), \"123\"))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdata := make([]byte, 48)\n\tdata[0] = 4<<3 | 3\n\n\tconn, err := net.DialUDP(\"udp\", nil, udpAddress)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tdefer conn.Close()\n\n\t_, err = conn.Write(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tconn.SetDeadline(time.Now().Add(ht.timeout))\n\n\t_, err = conn.Read(data)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := data[1]\n\n\tif stratum == 0 || stratum > byte(t.maxStratum) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (t *NtpHealthTester) String() string {\n\treturn fmt.Sprintf(\"%d\", t.maxStratum)\n}\n\nfunc newNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) HealthTester {\n\tmaxStratum := 3\n\tif v, ok := params[\"max_stratum\"]; ok {\n\t\tmaxStratum = typeutil.ToInt(v)\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage ntphealth\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype HealthTest struct{}\n\ntype HealthTestParameters struct {\n\tMaxStratum int\n}\n\ntype NtpHealthTester struct {\n\tmaxStratum int\n}\n\nfunc (ht *HealthTest) Test(ntpServer string) bool {\n\tconn, err := net.Dial(\"udp\", ntpServer+\":123\")\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 48)\n\t_, err = conn.Write([]byte{0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})\n\tif err != nil {\n\t\treturn false\n\t}\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\t_, _, err = conn.ReadFromUDP(buffer)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstratum := int(buffer[6] & 0x7F)\n\treturn stratum <= ht.maxStratum\n}\n\nfunc (ht *NtpHealthTester) String() string {\n\treturn \"Maximum Stratum: \" + strconv.Itoa(ht.maxStratum)\n}\n\nfunc NewNtpHealthTester(params map[string]interface{}, htp *HealthTestParameters) (*NtpHealthTester, error) {\n\tmaxStratum, ok := params[\"max_stratum\"].(int)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid max_stratum parameter\")\n\t}\n\treturn &NtpHealthTester{maxStratum: maxStratum}, nil\n}\n```"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Implement a UDP client in Go that can send data to a KDC (Key Distribution Center) server and receive responses, with error handling and connection management.\n\nStruct Description: The Client struct represents a UDP client for communicating with KDC servers. It maintains configuration and provides methods for sending data over UDP.\n\nFields:\n\nConfig: [*Config] - Configuration object containing KDC server information and settings\n\nMethods:\n\nsendKDCUDP: [func(realm string, b []byte) -> ([]byte, error)] - Sends data to a KDC server over UDP for a specific realm. Returns the response or error.\ndialKDCUDP: [func(count int, kdcs map[int]string) -> (*net.UDPConn, error)] - Internal method to establish UDP connection to a KDC server from a list of addresses. Returns the connection or error.\nsendUDP: [func(conn *net.UDPConn, b []byte) -> ([]byte, error)] - Internal method to send data over an established UDP connection and read the response. Returns the response data or error.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (cl *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tvar r []byte\n\tcount, kdcs, err := cl.Config.GetKDCs(realm, false)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tconn, err := dialKDCUDP(count, kdcs)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\tr, err = cl.sendUDP(conn, b)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn checkForKRBError(r)\n}\n\nfunc dialKDCUDP(count int, kdcs map[int]string) (conn *net.UDPConn, err error) {\n\ti := 1\n\tfor i <= count {\n\t\tudpAddr, e := net.ResolveUDPAddr(\"udp\", kdcs[i])\n\t\tif e != nil {\n\t\t\terr = fmt.Errorf(\"error resolving KDC address: %v\", e)\n\t\t\treturn\n\t\t}\n\t\tconn, err = net.DialUDP(\"udp\", nil, udpAddr)\n\t\tif err == nil {\n\t\t\terr = conn.SetDeadline(time.Now().Add(5 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti++\n\t}\n\terr = errors.New(\"error in getting a UDP connection to any of the KDCs\")\n\treturn\n}\n\nfunc (cl *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\tvar r []byte\n\tdefer conn.Close()\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"error sending to (%s): %v\", conn.RemoteAddr().String(), err)\n\t}\n\tudpbuf := make([]byte, 4096)\n\tn, _, err := conn.ReadFrom(udpbuf)\n\tr = udpbuf[:n]\n\tif err != nil {\n\t\treturn r, fmt.Errorf(\"sending over UDP failed to %s: %v\", conn.RemoteAddr().String(), err)\n\t}\n\tif len(r) < 1 {\n\t\treturn r, fmt.Errorf(\"no response data from %s\", conn.RemoteAddr().String())\n\t}\n\treturn r, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"errors\"\n)\n\ntype Config struct {\n\tServerIP   string\n\tServerPort string\n}\n\ntype Client struct {\n\tConfig *Config\n}\n\nfunc (c *Client) sendKDCUDP(realm string, b []byte) ([]byte, error) {\n\tconn, err := c.dialKDCUDP(1, map[int]string{0: c.Config.ServerIP + \":\" + c.Config.ServerPort})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tresponse, err := c.sendUDP(conn, append([]byte(realm), b...))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, nil\n}\n\nfunc (c *Client) dialKDCUDP(count int, kdcs map[int]string) (*net.UDPConn, error) {\n\tfor i := 0; i < count; i++ {\n\t\taddr, err := net.ResolveUDPAddr(\"udp\", kdcs[i])\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tconn, err := net.DialUDP(\"udp\", nil, addr)\n\t\tif err == nil {\n\t\t\treturn conn, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"failed to connect to KDC\")\n}\n\nfunc (c *Client) sendUDP(conn *net.UDPConn, b []byte) ([]byte, error) {\n\t_, err := conn.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuffer := make([]byte, 4096)\n\tn, _, err := conn.ReadFromUDP(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer[:n], nil\n}\n```"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a function that establishes a UDP connection to a target server, sends a payload, and reads the server's response.\n\nFunction Description: The function `connectUDP` initiates a UDP connection to a specified target address, sends a given payload, and reads the response from the server. It handles local and remote address resolution, connection establishment, and error handling for network operations.\n\nInput: \n- `target` [string] - The target server address in the format \"host:port\" (e.g., \"127.0.0.1:8080\").\n- `payload` [string] - The data to be sent to the server.\n\nOutput: \n- None (prints the server's response to stdout). The function panics on errors during connection setup, sending, or receiving.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc connectUDP(target, payload string) {\n\tLocalAddr, err := net.ResolveUDPAddr(\"udp\", \":54321\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP local address on port 54321 %v\", err))\n\t}\n\tRemoteAddr, err := net.ResolveUDPAddr(\"udp\", target)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to resolve UDP remote address [%s] %v\", target, err))\n\t}\n\tconn, err := net.DialUDP(\"udp\", LocalAddr, RemoteAddr)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Failed to open connection to [%s] %v\", target, err))\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\t_, err = conn.Write([]byte(\"\\n\"))\n\tif err != nil {\n\t\tpanic(\"Failed to send payload\")\n\t}\n\n\tbuf := make([]byte, 1024)\n\tn, err := conn.Read(buf)\n\tif err != nil {\n\t\tpanic(\"Failed to read from socket\")\n\t}\n\tfmt.Print(string(buf[:n]))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc connectUDP(target string, payload string) {\n\tconn, err := net.Dial(\"udp\", target)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer conn.Close()\n\n\t_, err = conn.Write([]byte(payload))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tn, _, err := conn.ReadFrom(buffer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(buffer[:n]))\n}\n\nfunc main() {\n\ttarget := \"127.0.0.1:8080\"\n\tpayload := \"Hello, Server!\"\n\tconnectUDP(target, payload)\n}\n```"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a function that establishes UDP connections between two remote endpoints, optionally encrypts the initial handshake packets, and forwards traffic between them.\n\nFunction Description: The function `remote2remoteUDP` creates two UDP connections to specified remote endpoints, handles optional encryption of initialization packets, and sets up bidirectional forwarding between the connections. It uses custom networking and crypto utilities for connection management and encryption.\n\nInput:\n- remoteA: string - First remote endpoint address in \"host:port\" format\n- remoteB: string - Second remote endpoint address in \"host:port\" format\n- raenc: bool - Flag to enable encryption for first remote endpoint\n- rbenc: bool - Flag to enable encryption for second remote endpoint\n\nOutput: None (The function runs indefinitely forwarding traffic or returns on error)",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"iox/netio\"\n\t\"iox/crypto\"\n)\n\nfunc remote2remoteUDP(remoteA string, remoteB string, raenc bool, rbenc bool) {\n\tremoteAddrA, err := net.ResolveUDPAddr(\"udp\", remoteA)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnA, err := net.DialUDP(\"udp\", nil, remoteAddrA)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnA.Close()\n\n\tremoteAddrB, err := net.ResolveUDPAddr(\"udp\", remoteB)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteConnB, err := net.DialUDP(\"udp\", nil, remoteAddrB)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer remoteConnB.Close()\n\n\tremoteCtxA, err := netio.NewUDPCtx(remoteConnA, raenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\tremoteCtxB, err := netio.NewUDPCtx(remoteConnB, rbenc, true)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif raenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxA.Write(b)\n\t} else {\n\t\tremoteCtxA.Write(netio.UDP_INIT_PACKET)\n\t}\n\tif rbenc {\n\t\tiv, err := crypto.RandomNonce()\n\t\tcipher, err := crypto.NewCipher(iv)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tb := make([]byte, 4, 20)\n\t\tcopy(b, netio.UDP_INIT_PACKET)\n\n\t\tcipher.StreamXOR(b, b)\n\t\tb = append(b, iv...)\n\t\tremoteCtxB.Write(b)\n\t} else {\n\t\tremoteCtxB.Write(netio.UDP_INIT_PACKET)\n\t}\n\n\tnetio.ForwardUDP(remoteCtxA, remoteCtxB)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 113,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/yourusername/customnet\"\n\t\"github.com/yourusername/cryptoutils\"\n)\n\nfunc remote2remoteUDP(remoteA, remoteB string, raenc, rbenc bool) {\n\tconnA, err := net.Dial(\"udp\", remoteA)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to remote A:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer connA.Close()\n\n\tconnB, err := net.Dial(\"udp\", remoteB)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to remote B:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer connB.Close()\n\n\tvar encA, encB *cryptoutils.Encryption\n\n\tif raenc {\n\t\tencA = cryptoutils.NewEncryption()\n\t}\n\n\tif rbenc {\n\t\tencB = cryptoutils.NewEncryption()\n\t}\n\n\tbuffer := make([]byte, 4096)\n\n\tfor {\n\t\tn, addrA, err := connA.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from remote A:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tif raenc {\n\t\t\tdata, err := encA.Encrypt(buffer[:n])\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error encrypting data from remote A:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, err = connB.WriteTo(data, addrA)\n\t\t} else {\n\t\t\t_, err = connB.WriteTo(buffer[:n], addrA)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to remote B:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tn, addrB, err := connB.ReadFrom(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from remote B:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tif rbenc {\n\t\t\tdata, err := encB.Decrypt(buffer[:n])\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error decrypting data from remote B:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, err = connA.WriteTo(data, addrB)\n\t\t} else {\n\t\t\t_, err = connA.WriteTo(buffer[:n], addrB)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error writing to remote A:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tremote2remoteUDP(\"remoteAHost:port\", \"remoteBHost:port\", true, false)\n}\n```"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Implement a UDP server in Go that listens for incoming packets, manages client sessions, and proxies the traffic to a remote destination using a provided proxy dialer.\n\nStruct Description: The UDP struct represents a UDP server that handles incoming connections, manages sessions, and proxies traffic. It maintains session state and coordinates communication between clients and the proxy server.\n\nFields:\n- addr: string - The local address to listen on\n- uaddr: *net.UDPAddr - The resolved UDP address\n- dialer: proxy.Dialer - The dialer used to establish connections\n- proxy: proxy.Proxy - The proxy implementation for forwarding traffic\n\nMethods:\n- NewUDP: (s string, d proxy.Dialer, p proxy.Proxy) -> (*UDP, error) - Creates a new UDP instance by parsing the URL and resolving the address\n- ListenAndServe: () -> () - Starts listening on the UDP port and handles incoming packets\n- serveSession: (session *session) -> () - Handles an individual client session and proxies its traffic\n- DialUDP: (network string, addr string) -> (net.PacketConn, error) - Creates a new packet connection for outbound traffic\n\nAdditional Structs:\n- session: Represents a client session with its communication channels\n  Fields:\n    - key: string - Session identifier\n    - src: *net.UDPAddr - Client address\n    - PacketConn: net.PacketConn - Underlying connection\n    - msgCh: chan []byte - Channel for incoming messages\n    - finCh: chan struct{} - Channel for session termination\n\n- PktConn: Wraps a net.PacketConn with a predefined destination address\n  Fields:\n    - PacketConn: net.PacketConn - Underlying connection\n    - uaddr: *net.UDPAddr - Destination address\n  Methods:\n    - WriteTo: (b []byte, addr net.Addr) -> (int, error) - Writes data to the predefined address",
    "Canonical_solution": "import (\n\t\"net\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/nadoo/glider/pkg/log\"\n\t\"github.com/nadoo/glider/pkg/pool\"\n\t\"github.com/nadoo/glider/proxy\"\n)\n\nvar nm sync.Map\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu, err := url.Parse(s)\n\tif err != nil {\n\t\tlog.F(\"[udp] parse url err: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tt := &UDP{\n\t\tdialer: d,\n\t\tproxy:  p,\n\t\taddr:   u.Host,\n\t}\n\n\tt.uaddr, err = net.ResolveUDPAddr(\"udp\", t.addr)\n\treturn t, err\n}\n\nfunc (s *UDP) ListenAndServe() {\n\tc, err := net.ListenPacket(\"udp\", s.addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"[udp] failed to listen on UDP %s: %v\", s.addr, err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\n\tlog.F(\"[udp] listening UDP on %s\", s.addr)\n\n\tfor {\n\t\tbuf := pool.GetBuffer(proxy.UDPBufSize)\n\t\tn, srcAddr, err := c.ReadFrom(buf)\n\t\tif err != nil {\n\t\t\tlog.F(\"[udp] read error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar sess *session\n\t\tsessKey := srcAddr.String()\n\n\t\tv, ok := nm.Load(sessKey)\n\t\tif !ok || v == nil {\n\t\t\tsess = newSession(sessKey, srcAddr, c)\n\t\t\tnm.Store(sessKey, sess)\n\t\t\tgo s.serveSession(sess)\n\t\t} else {\n\t\t\tsess = v.(*session)\n\t\t}\n\n\t\tsess.msgCh <- buf[:n]\n\t}\n}\n\nfunc (s *UDP) serveSession(session *session) {\n\tdstPC, dialer, err := s.proxy.DialUDP(\"udp\", session.src.String())\n\tif err != nil {\n\t\tlog.F(\"[udp] remote dial error: %v\", err)\n\t\tnm.Delete(session.key)\n\t\treturn\n\t}\n\tdefer dstPC.Close()\n\n\tgo func() {\n\t\tproxy.CopyUDP(session, session.src, dstPC, 2*time.Minute, 5*time.Second)\n\t\tnm.Delete(session.key)\n\t\tclose(session.finCh)\n\t}()\n\n\tlog.F(\"[udp] %s <-> %s\", session.src, dialer.Addr())\n\n\tfor {\n\t\tselect {\n\t\tcase p := <-session.msgCh:\n\t\t\t_, err = dstPC.WriteTo(p, nil)\n\t\t\tif err != nil {\n\t\t\t\tlog.F(\"[udp] writeTo error: %v\", err)\n\t\t\t}\n\t\t\tpool.PutBuffer(p)\n\t\tcase <-session.finCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype session struct {\n\tkey string\n\tsrc *net.UDPAddr\n\tnet.PacketConn\n\tmsgCh chan []byte\n\tfinCh chan struct{}\n}\n\nfunc newSession(key string, src net.Addr, srcPC net.PacketConn) *session {\n\tsrcAddr, _ := net.ResolveUDPAddr(\"udp\", src.String())\n\treturn &session{key, srcAddr, srcPC, make(chan []byte, 32), make(chan struct{})}\n}\n\nfunc (s *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\tpc, err := s.dialer.DialUDP(network, s.addr)\n\treturn &PktConn{pc, s.uaddr}, err\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (pc *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn pc.PacketConn.WriteTo(b, pc.uaddr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 111,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"log\"\n)\n\ntype UDP struct {\n\taddr   string\n\tuaddr  *net.UDPAddr\n\tdialer proxy.Dialer\n\tproxy  proxy.Proxy\n}\n\nfunc NewUDP(s string, d proxy.Dialer, p proxy.Proxy) (*UDP, error) {\n\tu := &UDP{dialer: d, proxy: p}\n\tvar err error\n\tu.uaddr, err = net.ResolveUDPAddr(\"udp\", s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn u, nil\n}\n\nfunc (u *UDP) ListenAndServe() {\n\tconn, err := net.ListenUDP(\"udp\", u.uaddr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, src, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading from UDP:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tsession := &session{\n\t\t\tkey:     generateKey(src),\n\t\t\tsrc:     src,\n\t\t\tPacketConn: conn,\n\t\t\tmsgCh:   make(chan []byte),\n\t\t\tfinCh:   make(chan struct{}),\n\t\t}\n\n\t\tgo u.serveSession(session)\n\t\tgo u.proxy.ProxyTraffic(session, buffer[:n])\n\t}\n}\n\nfunc (u *UDP) serveSession(session *session) {\n\tdefer close(session.finCh)\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-session.msgCh:\n\t\t\t_, err := session.WriteTo(msg, session.src)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error writing to session:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-session.finCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (u *UDP) DialUDP(network, addr string) (net.PacketConn, error) {\n\treturn net.DialPacket(network, \"\", &net.UDPAddr{IP: net.ParseIP(addr)})\n}\n\ntype session struct {\n\tkey     string\n\tsrc     *net.UDPAddr\n\tPacketConn net.PacketConn\n\tmsgCh   chan []byte\n\tfinCh   chan struct{}\n}\n\nfunc generateKey(addr *net.UDPAddr) string {\n\treturn addr.String()\n}\n\ntype PktConn struct {\n\tnet.PacketConn\n\tuaddr *net.UDPAddr\n}\n\nfunc (p *PktConn) WriteTo(b []byte, addr net.Addr) (int, error) {\n\treturn p.PacketConn.WriteTo(b, p.uaddr)\n}\n```"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Implement a UDP-based trap listener for SNMP (Simple Network Management Protocol) messages, capable of receiving and processing traps/informs, with support for SNMPv3 security features and proper resource cleanup.\n\nStruct Description: TrapListener is a struct that manages a UDP listener for SNMP traps, handling incoming messages, security validation, and response generation.\n\nFields:\n- done: chan bool - Channel to signal completion of listener shutdown\n- listening: chan bool - Channel to signal when listener is active\n- Mutex: sync.Mutex - Mutex for thread-safe operations\n- Params: *GoSNMP - Configuration parameters for SNMP handling\n- OnNewTrap: TrapHandlerFunc - Callback function for new trap processing\n- CloseTimeout: time.Duration - Timeout for graceful shutdown\n- conn: *net.UDPConn - UDP connection object\n- proto: string - Protocol type (typically \"udp\")\n- usmStatsUnknownEngineIDsCount: uint32 - Counter for unknown engine IDs (SNMPv3)\n- finish: int32 - Atomic flag for shutdown state\n\nMethods:\n- NewTrapListener() -> *TrapListener - Creates and initializes a new TrapListener instance\n- Close() - Gracefully shuts down the listener and cleans up resources\n- SendUDP(packet *SnmpPacket, addr *net.UDPAddr) -> error - Sends an SNMP packet via UDP\n- listenUDP(addr string) -> error - Main listening loop for incoming traps\n- reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) -> error - Handles SNMPv3 engine ID mismatch reporting",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype TrapListener struct {\n\tdone      chan bool\n\tlistening chan bool\n\tsync.Mutex\n\n\tParams *GoSNMP\n\n\tOnNewTrap TrapHandlerFunc\n\n\tCloseTimeout time.Duration\n\n\tconn  *net.UDPConn\n\tproto string\n\n\tusmStatsUnknownEngineIDsCount uint32\n\n\tfinish int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\ttl := &TrapListener{\n\t\tfinish:       0,\n\t\tdone:         make(chan bool),\n\t\tlistening:    make(chan bool, 1),\n\t\tCloseTimeout: defaultCloseTimeout,\n\t}\n\n\treturn tl\n}\n\nfunc (t *TrapListener) Close() {\n\tif atomic.CompareAndSwapInt32(&t.finish, 0, 1) {\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\n\t\tif t.conn == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err := t.conn.Close(); err != nil {\n\t\t\tt.Params.Logger.Printf(\"failed to Close() the TrapListener socket: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-t.done:\n\t\tcase <-time.After(t.CloseTimeout):\n\t\t\tt.Params.Logger.Printf(\"timeout while awaiting done signal on TrapListener Close()\")\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\tob, err := packet.marshalMsg()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling SnmpPacket: %w\", err)\n\t}\n\n\tcount, err := t.conn.WriteTo(ob, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending SnmpPacket: %w\", err)\n\t}\n\n\tif count != len(ob) {\n\t\tt.Params.Logger.Printf(\"Failed to send all bytes of SnmpPacket!\\n\")\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn, err = net.ListenUDP(udp, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer t.conn.Close()\n\n\tt.listening <- true\n\n\tfor {\n\t\tswitch {\n\t\tcase atomic.LoadInt32(&t.finish) == 1:\n\t\t\tt.done <- true\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tvar buf [4096]byte\n\t\t\trlen, remote, err := t.conn.ReadFromUDP(buf[:])\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&t.finish) == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in read %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg := buf[:rlen]\n\t\t\ttrap, err := t.Params.UnmarshalTrap(msg, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in UnmarshalTrap %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif trap.Version == Version3 && trap.SecurityModel == UserSecurityModel && t.Params.SecurityModel == UserSecurityModel {\n\t\t\t\tsecurityParams, ok := t.Params.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tpacketSecurityParams, ok := trap.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tsnmpEngineID := securityParams.AuthoritativeEngineID\n\t\t\t\tmsgAuthoritativeEngineID := packetSecurityParams.AuthoritativeEngineID\n\t\t\t\tif msgAuthoritativeEngineID != snmpEngineID {\n\t\t\t\t\tif len(msgAuthoritativeEngineID) < 5 || len(msgAuthoritativeEngineID) > 32 {\n\t\t\t\t\t\tatomic.AddUint32(&t.usmStatsUnknownEngineIDsCount, 1)\n\t\t\t\t\t\terr := t.reportAuthoritativeEngineID(trap, snmpEngineID, remote)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.OnNewTrap(trap, remote)\n\n\t\t\tif trap.PDUType == InformRequest {\n\t\t\t\ttrap.PDUType = GetResponse\n\t\t\t\ttrap.Error = NoError\n\t\t\t\ttrap.ErrorIndex = 0\n\t\t\t\terr := t.SendUDP(trap, remote)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tnewSecurityParams, ok := trap.SecurityParameters.Copy().(*UsmSecurityParameters)\n\tif !ok {\n\t\treturn errors.New(\"unable to cast SecurityParams to UsmSecurityParameters\")\n\t}\n\tnewSecurityParams.AuthoritativeEngineID = snmpEngineID\n\treportPacket := trap\n\treportPacket.PDUType = Report\n\treportPacket.MsgFlags &= AuthPriv\n\treportPacket.SecurityParameters = newSecurityParams\n\treportPacket.Variables = []SnmpPDU{\n\t\t{\n\t\t\tName:  usmStatsUnknownEngineIDs,\n\t\t\tValue: int(atomic.LoadUint32(&t.usmStatsUnknownEngineIDsCount)),\n\t\t\tType:  Integer,\n\t\t},\n\t}\n\treturn t.SendUDP(reportPacket, addr)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype TrapHandlerFunc func(*SnmpPacket, *net.UDPAddr)\n\ntype SnmpPacket struct {\n\t// Define fields as per SNMP protocol requirements\n}\n\ntype GoSNMP struct {\n\t// Define fields as per GoSNMP configuration\n}\n\ntype TrapListener struct {\n\tdone                  chan bool\n\tlistening             chan bool\n\tMutex                 sync.Mutex\n\tParams                *GoSNMP\n\tOnNewTrap             TrapHandlerFunc\n\tCloseTimeout          time.Duration\n\tconn                  *net.UDPConn\n\tproto                 string\n\tusmStatsUnknownEngineIDsCount uint32\n\tfinish                int32\n}\n\nfunc NewTrapListener(params *GoSNMP, handler TrapHandlerFunc, timeout time.Duration) *TrapListener {\n\treturn &TrapListener{\n\t\tdone:                  make(chan bool),\n\t\tlistening:             make(chan bool),\n\t\tParams:                params,\n\t\tOnNewTrap:             handler,\n\t\tCloseTimeout:          timeout,\n\t\tconn:                  nil,\n\t\tproto:                 \"udp\",\n\t\tusmStatsUnknownEngineIDsCount: 0,\n\t\tfinish:                0,\n\t}\n}\n\nfunc (tl *TrapListener) Close() {\n\ttl.done <- true\n\tselect {\n\tcase <-time.After(tl.CloseTimeout):\n\t\tfmt.Println(\"Graceful shutdown timed out\")\n\tcase <-tl.listening:\n\t\tfmt.Println(\"Trap listener gracefully shut down\")\n\t}\n\tif tl.conn != nil {\n\t\ttl.conn.Close()\n\t}\n}\n\nfunc (tl *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\t// Implementation to send SNMP packet via UDP\n\treturn nil\n}\n\nfunc (tl *TrapListener) listenUDP(addr string) error {\n\tvar err error\n\ttl.conn, err = net.ListenUDP(tl.proto, &net.UDPAddr{Port: 162})\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tdefer close(tl.listening)\n\t\tbuf := make([]byte, 4096)\n\t\tfor {\n\t\t\tn, src, err := tl.conn.ReadFromUDP(buf)\n\t\t\tif err != nil {\n\t\t\t\tif !tl.isClosed() {\n\t\t\t\t\tfmt.Println(\"Error reading from UDP:\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpacket := &SnmpPacket{}\n\t\t\t// Parse packet here\n\t\t\tif tl.OnNewTrap != nil {\n\t\t\t\ttl.OnNewTrap(packet, src)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (tl *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\t// Handle SNMPv3 engine ID mismatch reporting\n\treturn nil\n}\n\nfunc (tl *TrapListener) isClosed() bool {\n\treturn atomic.LoadInt32(&tl.finish) == 1\n}\n\nfunc main() {\n\tparams := &GoSNMP{}\n\thandler := func(packet *SnmpPacket, addr *net.UDPAddr) {\n\t\tfmt.Printf(\"Received trap from %s\\n\", addr.String())\n\t}\n\tlistener := NewTrapListener(params, handler, 5*time.Second)\n\terr := listener.listenUDP(\":162\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to start listener:\", err)\n\t\treturn\n\t}\n\t<-listener.done\n\tlistener.Close()\n}\n```"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a UDP server for handling SOCKS5 proxy requests, including UDP association and data relay between clients and a Hysteria proxy client.\n\nStruct Description: The Server struct represents a SOCKS5 proxy server with UDP support, handling client connections and relaying UDP traffic through a Hysteria proxy.\n\nFields:\n\nHyClient: [client.Client] - The Hysteria client used for establishing proxy connections\nAuthFunc: [func(username, password string) bool] - Authentication function for SOCKS5 clients\nDisableUDP: [bool] - Flag to disable UDP functionality\nEventLogger: [EventLogger] - Interface for logging server events\n\nMethods:\n\nhandleUDP: [func(conn net.Conn, req *socks5.Request)] - none - Handles a new UDP association request from a SOCKS5 client\nudpServer: [func(udpConn *net.UDPConn, hyUDP client.HyUDPConn)] -> [error] - Manages the UDP relay between client and Hysteria proxy\nsendUDPReply: [func(conn net.Conn, addr *net.UDPAddr)] -> [error] - Sends a UDP association reply to the SOCKS5 client\n\nInterface Description:\n\nEventLogger: Interface for logging UDP-related events\nMethods:\nUDPRequest: [func(addr net.Addr)] - Logs incoming UDP requests\nUDPError: [func(addr net.Addr, err error)] - Logs UDP-related errors",
    "Canonical_solution": "import (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/txthinking/socks5\"\n\n\t\"github.com/apernet/hysteria/core/v2/client\"\n)\n\ntype Server struct {\n\tHyClient    client.Client\n\tAuthFunc    func(username, password string) bool\n\tDisableUDP  bool\n\tEventLogger EventLogger\n}\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\tdefer conn.Close()\n\n\tif s.EventLogger != nil {\n\t\ts.EventLogger.UDPRequest(conn.RemoteAddr())\n\t}\n\tvar closeErr error\n\tdefer func() {\n\t\tif s.EventLogger != nil {\n\t\t\ts.EventLogger.UDPError(conn.RemoteAddr(), closeErr)\n\t\t}\n\t}()\n\n\thost, _, err := net.SplitHostPort(conn.LocalAddr().String())\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(host, \"0\"))\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer udpConn.Close()\n\n\thyUDP, err := s.HyClient.UDP()\n\tif err != nil {\n\t\t_ = sendSimpleReply(conn, socks5.RepServerFailure)\n\t\tcloseErr = err\n\t\treturn\n\t}\n\tdefer hyUDP.Close()\n\n\t_ = sendUDPReply(conn, udpConn.LocalAddr().(*net.UDPAddr))\n\n\terrChan := make(chan error, 2)\n\tgo func() {\n\t\terr := s.udpServer(udpConn, hyUDP)\n\t\terrChan <- err\n\t}()\n\tgo func() {\n\t\t_, err := io.Copy(io.Discard, conn)\n\t\terrChan <- err\n\t}()\n\tcloseErr = <-errChan\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\tvar clientAddr *net.UDPAddr\n\tbuf := make([]byte, udpBufferSize)\n\tfor {\n\t\tn, cAddr, err := udpConn.ReadFromUDP(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td, err := socks5.NewDatagramFromBytes(buf[:n])\n\t\tif err != nil || d.Frag != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif clientAddr == nil {\n\t\t\tclientAddr = cAddr\n\t\t\tgo func() {\n\t\t\t\tfor {\n\t\t\t\t\tbs, from, err := hyUDP.Receive()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t_ = udpConn.Close()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tatyp, addr, port, err := socks5.ParseAddress(from)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif atyp == socks5.ATYPDomain {\n\t\t\t\t\t\taddr = addr[1:]\n\t\t\t\t\t}\n\t\t\t\t\td := socks5.NewDatagram(atyp, addr, port, bs)\n\t\t\t\t\t_, _ = udpConn.WriteToUDP(d.Bytes(), clientAddr)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else if !clientAddr.IP.Equal(cAddr.IP) || clientAddr.Port != cAddr.Port {\n\t\t\tcontinue\n\t\t}\n\t\t_ = hyUDP.Send(d.Data, d.Address())\n\t}\n}\n\nfunc sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\tvar atyp byte\n\tvar bndAddr, bndPort []byte\n\tif ip4 := addr.IP.To4(); ip4 != nil {\n\t\tatyp = socks5.ATYPIPv4\n\t\tbndAddr = ip4\n\t} else {\n\t\tatyp = socks5.ATYPIPv6\n\t\tbndAddr = addr.IP\n\t}\n\tbndPort = make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bndPort, uint16(addr.Port))\n\tp := socks5.NewReply(socks5.RepSuccess, atyp, bndAddr, bndPort)\n\t_, err := p.WriteTo(conn)\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"log\"\n)\n\ntype Client struct {\n\t// Define fields for Hysteria client\n}\n\ntype EventLogger interface {\n\tUDPRequest(addr net.Addr)\n\tUDPError(addr net.Addr, err error)\n}\n\ntype Server struct {\n\tHyClient   *Client\n\tAuthFunc   func(username, password string) bool\n\tDisableUDP bool\n\tEventLogger EventLogger\n}\n\nfunc (s *Server) handleUDP(conn net.Conn, req *socks5.Request) {\n\t// Handle a new UDP association request\n}\n\nfunc (s *Server) udpServer(udpConn *net.UDPConn, hyUDP client.HyUDPConn) error {\n\t// Manage the UDP relay between client and Hysteria proxy\n\treturn nil\n}\n\nfunc (s *Server) sendUDPReply(conn net.Conn, addr *net.UDPAddr) error {\n\t// Send a UDP association reply to the SOCKS5 client\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Implement a UDP server in Go that handles incoming UDP packets, performs authentication checks, and manages communication with clients through specified ports. The server should include functionality for initialization, packet handling, listening for incoming data, and graceful shutdown.\n\nStruct Description: The UDPServer struct represents a UDP server instance that manages UDP connections, handles authentication, and processes incoming/outgoing packets. It maintains connection state and integrates with a parent Server instance.\n\nFields:\n\nServer: [*Server] - Reference to the parent Server instance containing shared resources\nUDPConn: [*net.UDPConn] - Active UDP connection for the server\nAddr: [*net.UDPAddr] - Address information for the server's UDP endpoint\n\nMethods:\n\nNewUDPServer: [func(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error)] -> [*UDPServer, error] - Initializes a new UDP server instance with authentication checks and port validation. Returns the server instance or error if initialization fails.\n\nListenAndServe: [func(s *UDPServer) error] -> [error] - Starts listening for incoming UDP packets and handles them in a loop until an error occurs or the server is shut down. Automatically closes the connection when finished.\n\nShutdown: [func(s *UDPServer)] -> [void] - Gracefully shuts down the UDP server by closing the active connection.\n\nHandlePacket: [func(s *UDPServer, p *UDPPacket) error] -> [error] - Processes an incoming UDP packet, either forwarding data to the specified address or updating the connection deadline. Returns error if processing fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tbye := func(err error) {\n\t\tp := &UDPPacket{\n\t\t\tAddress: err.Error(),\n\t\t}\n\t\tb, err1 := proto.Marshal(p)\n\t\tif err1 != nil {\n\t\t\tlog.Println(err1)\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\tif p.Port == 0 {\n\t\tbye(errors.New(\"Missed port\"))\n\t\treturn nil, errors.New(addr.String() + \" missed port\")\n\t}\n\tif len(s.PortCkv) == 0 {\n\t\ttmp, err := s.Ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tif len(s.PortCkv) != 0 {\n\t\tckv, ok := s.PortCkv[p.Port]\n\t\tif !ok {\n\t\t\tbye(errors.New(\"Not allowed port\"))\n\t\t\treturn nil, errors.New(addr.String() + \" try to open not allowed UDP port: \" + strconv.FormatInt(p.Port, 10))\n\t\t}\n\t\ttmp, err := ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.FormatInt(p.Port, 10))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc1, err := net.ListenUDP(\"udp\", uaddr)\n\tif err != nil {\n\t\tbye(err)\n\t\treturn nil, err\n\t}\n\tif err := c1.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tp = &UDPPacket{\n\t\tAddress: \"0\",\n\t}\n\tb, err := proto.Marshal(p)\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{\n\t\tServer:  s,\n\t\tUDPConn: c1,\n\t\tAddr:    addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\ti, a, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tp := &UDPPacket{\n\t\t\tAddress: a.String(),\n\t\t\tData:    b[0:i],\n\t\t}\n\t\tb, err = proto.Marshal(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.Server.UDPConn.WriteToUDP(b, s.Addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.UDPConn.Close()\n}\n\nfunc (s *UDPServer) HandlePacket(p *UDPPacket) error {\n\tif p.Address != \"0\" {\n\t\tuaddr, err := net.ResolveUDPAddr(\"udp\", p.Address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(p.Data, uaddr); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := s.UDPConn.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 112,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype Server struct {\n\t// Shared resources and configurations\n}\n\ntype UDPPacket struct {\n\tData []byte\n\tAddr *net.UDPAddr\n}\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tif err := authenticate(p); err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{Server: s, UDPConn: conn, Addr: addr}, nil\n}\n\nfunc ListenAndServe(s *UDPServer) error {\n\tdefer s.Shutdown()\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, remoteAddr, err := s.UDPConn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp := &UDPPacket{Data: buffer[:n], Addr: remoteAddr}\n\t\tif err := s.HandlePacket(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc Shutdown(s *UDPServer) {\n\ts.UDPConn.Close()\n}\n\nfunc HandlePacket(s *UDPServer, p *UDPPacket) error {\n\tselect {\n\tcase <-s.Server.ctx.Done():\n\t\treturn s.Server.ctx.Err()\n\tdefault:\n\t\t_, err := s.UDPConn.WriteToUDP(p.Data, p.Addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.UDPConn.SetDeadline(time.Now().Add(5 * time.Second))\n\t\treturn nil\n\t}\n}\n\nfunc authenticate(p *UDPPacket) error {\n\t// Authentication logic here\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: The provided code demonstrates a WebSocket client implementation in Go for tracker communication in a peer-to-peer network, handling WebSocket connections, message exchange, and WebRTC offer/answer negotiation.\n\nStruct Description: TrackerClient represents a client for interacting with a WebSocket tracker server, managing WebSocket connections, peer connections, and message handling.\n\nFields:\n\nUrl: string - The WebSocket tracker server URL to connect to\nGetAnnounceRequest: func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error) - Function to generate announce requests\nPeerId: [20]byte - The client's peer identifier\nOnConn: onDataChannelOpen - Callback for when data channels open\nLogger: log.Logger - Logger for client operations\nDialer: *websocket.Dialer - WebSocket dialer configuration\nmu: sync.Mutex - Mutex for thread-safe operations\ncond: sync.Cond - Condition variable for connection state changes\noutboundOffers: map[string]outboundOfferValue - Track outbound WebRTC offers\nwsConn: *websocket.Conn - Active WebSocket connection\nclosed: bool - Connection closed flag\npingTicker: *time.Ticker - Timer for sending ping messages\nWebsocketTrackerHttpHeader: func() http.Header - Function to generate WebSocket headers\nICEServers: []webrtc.ICEServer - List of ICE servers for WebRTC\nrtcPeerConns: map[string]*wrappedPeerConnection - Active WebRTC peer connections\n\nMethods:\n\ndoWebsocket: () -> error - Establishes and maintains WebSocket connection to tracker\ntrackerReadLoop: (*websocket.Conn) -> error - Handles incoming WebSocket messages\nwriteMessage: ([]byte) -> error - Writes message to WebSocket connection\nhandleOffer: (offerContext, string) -> error - Processes incoming WebRTC offers\nhandleAnswer: (string, webrtc.SessionDescription) -> void - Processes incoming WebRTC answers",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/anacrolix/log\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v4\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype TrackerClient struct {\n\tUrl                string\n\tGetAnnounceRequest func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId             [20]byte\n\tOnConn             onDataChannelOpen\n\tLogger             log.Logger\n\tDialer             *websocket.Dialer\n\n\tmu             sync.Mutex\n\tcond           sync.Cond\n\toutboundOffers map[string]outboundOfferValue\n\twsConn         *websocket.Conn\n\tclosed         bool\n\tpingTicker     *time.Ticker\n\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers                 []webrtc.ICEServer\n\n\trtcPeerConns map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\ttc.mu.Unlock()\n\n\tvar header http.Header\n\tif tc.WebsocketTrackerHttpHeader != nil {\n\t\theader = tc.WebsocketTrackerHttpHeader()\n\t}\n\n\tc, _, err := tc.Dialer.Dial(tc.Url, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing tracker: %w\", err)\n\t}\n\tdefer c.Close()\n\ttc.Logger.WithDefaultLevel(log.Info).Printf(\"connected\")\n\ttc.mu.Lock()\n\ttc.wsConn = c\n\ttc.cond.Broadcast()\n\ttc.mu.Unlock()\n\tcloseChan := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tc.pingTicker.C:\n\t\t\t\ttc.mu.Lock()\n\t\t\t\terr := c.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\ttc.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-closeChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\terr = tc.trackerReadLoop(tc.wsConn)\n\tclose(closeChan)\n\ttc.mu.Lock()\n\tc.Close()\n\ttc.mu.Unlock()\n\treturn err\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(tracker *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := tracker.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read message error: %w\", err)\n\t\t}\n\t\ttc.Logger.Levelf(log.Debug, \"received message: %q\", message)\n\n\t\tvar ar AnnounceResponse\n\t\tif err := json.Unmarshal(message, &ar); err != nil {\n\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error unmarshalling announce response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase ar.Offer != nil:\n\t\t\tih, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error decoding info_hash in offer: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = tc.handleOffer(offerContext{\n\t\t\t\tSessDesc: *ar.Offer,\n\t\t\t\tId:       ar.OfferID,\n\t\t\t\tInfoHash: ih,\n\t\t\t}, ar.PeerID)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Error, \"handling offer for infohash %x: %v\", ih, err)\n\t\t\t}\n\t\tcase ar.Answer != nil:\n\t\t\ttc.handleAnswer(ar.OfferID, *ar.Answer)\n\t\tdefault:\n\t\t\t_, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Warning, \"unexpected announce response %q\", message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(data []byte) error {\n\tfor tc.wsConn == nil {\n\t\tif tc.closed {\n\t\t\treturn fmt.Errorf(\"%T closed\", tc)\n\t\t}\n\t\ttc.cond.Wait()\n\t}\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, data)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype TrackerClient struct {\n\tUrl                  string\n\tGetAnnounceRequest   func(tracker.AnnounceEvent, [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId               [20]byte\n\tOnConn               onDataChannelOpen\n\tLogger               log.Logger\n\tDialer               *websocket.Dialer\n\tmu                   sync.Mutex\n\tcond                 *sync.Cond\n\toutboundOffers       map[string]outboundOfferValue\n\twsConn               *websocket.Conn\n\tclosed               bool\n\tpingTicker           *time.Ticker\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers         []webrtc.ICEServer\n\trtcPeerConns         map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\t// Implementation of WebSocket connection establishment and maintenance\n\treturn nil\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(wsConn *websocket.Conn) error {\n\t// Implementation of handling incoming WebSocket messages\n\treturn nil\n}\n\nfunc (tc *TrackerClient) writeMessage(message []byte) error {\n\t// Implementation of writing message to WebSocket connection\n\treturn nil\n}\n\nfunc (tc *TrackerClient) handleOffer(offerContext offerContext, offer string) error {\n\t// Implementation of processing incoming WebRTC offers\n\treturn nil\n}\n\nfunc (tc *TrackerClient) handleAnswer(id string, answer webrtc.SessionDescription) {\n\t// Implementation of processing incoming WebRTC answers\n}\n```"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that can establish secure connections, handle protocol negotiation, and manage message transmission between client and server. The solution should support TLS configuration, proxy settings, and proper connection cleanup.\n\nStruct Description: The RoundTripper struct implements http.RoundTripper interface to handle WebSocket connections with additional capabilities for Kubernetes API server communication. It manages WebSocket connections with TLS support and proxy configuration.\n\nFields:\n- TLSConfig: *tls.Config - Configuration for TLS/SSL connections\n- Proxier: func(req *http.Request) (*url.URL, error) - Function to determine proxy for requests\n- Conn: *gwebsocket.Conn - Active WebSocket connection\n\nMethods:\n- Connection: () -> *gwebsocket.Conn - Returns the active WebSocket connection\n- DataBufferSize: () -> int - Returns the buffer size for data transmission (32KB by default)\n- TLSClientConfig: () -> *tls.Config - Returns the TLS configuration\n- RoundTrip: (*http.Request) -> (*http.Response, error) - Main method that establishes WebSocket connection, handles protocol negotiation, and returns the HTTP response\n\nAdditional Function:\n- RoundTripperFor: (*restclient.Config) -> (http.RoundTripper, ConnectionHolder, error) - Factory function that creates a configured RoundTripper instance with proper TLS and proxy settings from Kubernetes client configuration",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tgwebsocket \"github.com/gorilla/websocket\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream/wsstream\"\n\tutilnet \"k8s.io/apimachinery/pkg/util/net\"\n\trestclient \"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/transport\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *gwebsocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *gwebsocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(request *http.Request) (retResp *http.Response, retErr error) {\n\tdefer func() {\n\t\tif request.Body != nil {\n\t\t\terr := request.Body.Close()\n\t\t\tif retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}\n\t}()\n\n\tprotocolVersions := request.Header[wsstream.WebSocketProtocolHeader]\n\tdelete(request.Header, wsstream.WebSocketProtocolHeader)\n\n\tdialer := gwebsocket.Dialer{\n\t\tProxy:           rt.Proxier,\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tSubprotocols:    protocolVersions,\n\t\tReadBufferSize:  rt.DataBufferSize() + 1024,\n\t\tWriteBufferSize: rt.DataBufferSize() + 1024,\n\t}\n\tswitch request.URL.Scheme {\n\tcase \"https\":\n\t\trequest.URL.Scheme = \"wss\"\n\tcase \"http\":\n\t\trequest.URL.Scheme = \"ws\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown url scheme: %s\", request.URL.Scheme)\n\t}\n\twsConn, resp, err := dialer.DialContext(request.Context(), request.URL.String(), request.Header)\n\tif err != nil {\n\t\tif errors.Is(err, gwebsocket.ErrBadHandshake) {\n\t\t\tcause := err\n\t\t\tif resp != nil && len(resp.Status) > 0 {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tcause = fmt.Errorf(\"%w (%s)\", err, resp.Status)\n\t\t\t\tresponseErrorBytes, readErr := io.ReadAll(io.LimitReader(resp.Body, 64*1024))\n\t\t\t\tif readErr != nil {\n\t\t\t\t\tcause = fmt.Errorf(\"%w: unable to read error from server response\", cause)\n\t\t\t\t} else {\n\t\t\t\t\tresponseError := strings.TrimSpace(string(responseErrorBytes))\n\t\t\t\t\tif len(responseError) > 0 {\n\t\t\t\t\t\tif obj, _, decodeErr := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); decodeErr == nil {\n\t\t\t\t\t\t\tif status, ok := obj.(*metav1.Status); ok {\n\t\t\t\t\t\t\t\tcause = &apierrors.StatusError{ErrStatus: *status}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcause = fmt.Errorf(\"%w: %s\", cause, responseError)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, &httpstream.UpgradeFailureError{Cause: cause}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tfoundProtocol := false\n\tfor _, protocolVersion := range protocolVersions {\n\t\tif protocolVersion == wsConn.Subprotocol() {\n\t\t\tfoundProtocol = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !foundProtocol {\n\t\twsConn.Close()\n\t\treturn nil, &httpstream.UpgradeFailureError{Cause: fmt.Errorf(\"invalid protocol, expected one of %q, got %q\", protocolVersions, wsConn.Subprotocol())}\n\t}\n\n\trt.Conn = wsConn\n\n\treturn resp, nil\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttransportCfg, err := config.TransportConfig()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttlsConfig, err := transport.TLSConfigFor(transportCfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxy := config.Proxy\n\tif proxy == nil {\n\t\tproxy = utilnet.NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)\n\t}\n\n\tupgradeRoundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxy,\n\t}\n\twrapper, err := transport.HTTPWrappersForConfig(transportCfg, upgradeRoundTripper)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn wrapper, upgradeRoundTripper, nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"k8s.io/client-go/rest\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig  *tls.Config\n\tProxier    func(req *http.Request) (*url.URL, error)\n\tConn       *websocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *websocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024 // 32KB\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif req.URL.Scheme != \"wss\" && req.URL.Scheme != \"ws\" {\n\t\treturn nil, errors.New(\"only ws and wss schemes supported\")\n\t}\n\tconn, resp, err := websocket.DefaultDialer.Dial(req.URL.String(), nil)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\trt.Conn = conn\n\treturn resp, nil\n}\n\ntype ConnectionHolder interface {\n\tConnection() *websocket.Conn\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttlsConfig, err := rest.TLSConfigFor(config)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxier := config.ProxyFunc\n\troundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxier,\n\t}\n\treturn roundTripper, roundTripper, nil\n}\n```"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a WebSocket client connection wrapper in Go that provides a simplified interface for reading and writing binary messages over a WebSocket connection, with proper error handling and connection management.\n\nStruct Description: The Conn struct wraps a WebSocket connection and provides io.Reader/io.Writer compatible methods for binary message communication, along with standard net.Conn interface methods.\n\nFields:\nwsConn: *websocket.Conn - The underlying WebSocket connection\nreader: io.Reader - Current message reader for streaming message content\n\nMethods:\nNew: (wsConn *websocket.Conn) -> *Conn - Creates a new Conn wrapper instance\nDial: (ctx context.Context, url string, opts ...DialOption) -> (*Conn, error) - Establishes a new WebSocket connection with optional configuration\nRead: (b []byte) -> (int, error) - Reads binary data from the WebSocket connection (implements io.Reader)\nWrite: (b []byte) -> (int, error) - Writes binary data to the WebSocket connection (implements io.Writer)\nClose: () -> error - Closes the WebSocket connection\nLocalAddr: () -> net.Addr - Returns local network address\nRemoteAddr: () -> net.Addr - Returns remote network address\nSetDeadline: (t time.Time) -> error - Sets both read and write deadlines\nSetReadDeadline: (t time.Time) -> error - Sets read deadline\nSetWriteDeadline: (t time.Time) -> error - Sets write deadline",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: nil,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\toptions := dialOptions{}\n\tfor _, o := range opts {\n\t\to.apply(&options)\n\t}\n\n\tdialer := &websocket.Dialer{\n\t\tHandshakeTimeout: 60 * time.Second,\n\t}\n\n\tif options.tlsConfig != nil {\n\t\tdialer.TLSClientConfig = options.tlsConfig\n\t}\n\n\theader := make(http.Header)\n\tif options.token != \"\" {\n\t\theader.Set(\"Authorization\", \"Bearer \"+options.token)\n\t}\n\n\twsConn, resp, err := dialer.DialContext(\n\t\tctx, url, header,\n\t)\n\tif err == nil {\n\t\treturn New(wsConn), nil\n\t}\n\tif resp == nil {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\tdefer resp.Body.Close()\n\n\terr = fmt.Errorf(\"%d: %w\", resp.StatusCode, err)\n\tif _, ok := retryableStatusCodes[resp.StatusCode]; ok {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\treturn nil, err\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tfor {\n\t\tif c.reader == nil {\n\t\t\tmt, r, err := c.wsConn.NextReader()\n\t\t\tif err != nil {\n\t\t\t\tvar closeErr *websocket.CloseError\n\t\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\t\treturn 0, net.ErrClosed\n\t\t\t\t}\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif mt != websocket.BinaryMessage {\n\t\t\t\treturn 0, fmt.Errorf(\"unexpected message type: %d\", mt)\n\t\t\t}\n\t\t\tc.reader = r\n\t\t}\n\n\t\tn, err := c.reader.Read(b)\n\t\tif n > 0 {\n\t\t\tif err != nil {\n\t\t\t\tc.reader = nil\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err\n\t\t}\n\t\tif err != io.EOF {\n\t\t\tvar closeErr *websocket.CloseError\n\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\treturn 0, net.ErrClosed\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc.reader = nil\n\t}\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tif err := c.wsConn.WriteMessage(websocket.BinaryMessage, b); err != nil {\n\t\tvar closeErr *websocket.CloseError\n\t\tif errors.As(err, &closeErr) {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 117,
    "wrong_result": "```go\npackage websocketconn\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype DialOption func(*websocket.DialOptions)\n\nfunc WithHeader(header http.Header) DialOption {\n\treturn func(opts *websocket.DialOptions) {\n\t\topts.Header = header\n\t}\n}\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{wsConn: wsConn}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\tdialer := websocket.Dialer{}\n\tfor _, opt := range opts {\n\t\topt(&dialer.Options)\n\t}\n\tconn, resp, err := dialer.DialContext(ctx, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn New(conn), resp.Close()\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tmessageType, reader, err := c.wsConn.NextReader()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif messageType != websocket.BinaryMessage {\n\t\treturn 0, fmt.Errorf(\"unexpected message type: %v\", messageType)\n\t}\n\tc.reader = reader\n\treturn reader.Read(b)\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\terr := c.wsConn.WriteMessage(websocket.BinaryMessage, b)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.wsConn.SetDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}\n```"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: The task involves creating a WebSocket handler in Go that upgrades HTTP connections to WebSocket connections, manages the connection lifecycle, and handles message exchange between client and server.\n\nStruct Description: The WsHandler struct is responsible for managing WebSocket connections, including upgrading HTTP connections, handling incoming messages, and managing connection state.\n\nFields:\n- svcCtx: *svc.ServiceContext - A reference to the service context containing dependencies and configuration\n\nMethods:\n- Upgrade: (ginCtx *gin.Context) -> void - Upgrades an HTTP connection to a WebSocket connection and manages the connection lifecycle\n  Input: ginCtx *gin.Context - The Gin context containing HTTP request and response objects\n  Output: None (handles connection directly)\n\n- onReceive: (ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) -> (pb.ResponseCode, error) - Handles incoming WebSocket messages\n  Input: \n    - ctx context.Context - Context for the operation\n    - connection *gatewayservicelogic.Connection - The WebSocket connection object\n    - typ websocket.MessageType - Type of the WebSocket message\n    - msg []byte - The message content\n  Output:\n    - pb.ResponseCode - Response code indicating processing result\n    - error - Any error that occurred during processing",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tgatewayservicelogic \"github.com/cherish-chat/xxim-server/app/gateway/internal/logic/gatewayservice\"\n\t\"github.com/cherish-chat/xxim-server/common/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/zeromicro/go-zero/core/logx\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/codes\"\n\t\"go.opentelemetry.io/otel/propagation\"\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"io\"\n\t\"math\"\n\t\"nhooyr.io/websocket\"\n\t\"strings\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tr := ginCtx.Request\n\tw := ginCtx.Writer\n\tlogger := logx.WithContext(r.Context())\n\theaders := make(map[string]string)\n\tfor k, v := range r.Header {\n\t\tif len(v) > 0 {\n\t\t\theaders[k] = v[0]\n\t\t}\n\t}\n\theader := &pb.RequestHeader{\n\t\tClientIp: utils.Http.GetClientIP(r),\n\t}\n\tcompressionMode := websocket.CompressionNoContextTakeover\n\tif strings.Contains(r.UserAgent(), \"Safari\") {\n\t\tcompressionMode = websocket.CompressionDisabled\n\t}\n\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\tSubprotocols:         nil,\n\t\tInsecureSkipVerify:   true,\n\t\tOriginPatterns:       nil,\n\t\tCompressionMode:      compressionMode,\n\t\tCompressionThreshold: 0,\n\t})\n\tif err != nil {\n\t\tif r.URL.Path == \"/\" {\n\t\t\treturn\n\t\t}\n\t\tlogger.Errorf(\"failed to accept websocket connection: %v\", err)\n\t\treturn\n\t}\n\tc.SetReadLimit(math.MaxInt32)\n\tbeforeConnectResp, err := h.svcCtx.CallbackService.UserBeforeConnect(r.Context(), &pb.UserBeforeConnectReq{Header: header})\n\tif err != nil {\n\t\tlogger.Errorf(\"beforeConnect error: %v\", err)\n\t\tc.Close(websocket.StatusCode(pb.WebsocketCustomCloseCode_CloseCodeServerInternalError), err.Error())\n\t\treturn\n\t}\n\tif !beforeConnectResp.Success {\n\t\tc.Close(websocket.StatusCode(beforeConnectResp.CloseCode), beforeConnectResp.CloseReason)\n\t\treturn\n\t}\n\n\theader.UserId = beforeConnectResp.UserId\n\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\tctx, cancelFunc := context.WithCancel(r.Context())\n\tconnection := gatewayservicelogic.NewWebsocketConnect(ctx, header, c)\n\tdefer func() {\n\t\tgatewayservicelogic.ConnectionLogic.OnDisconnect(connection)\n\t}()\n\tgo func() {\n\t\tdefer cancelFunc()\n\t\tfor {\n\t\t\tlogger.Debugf(\"start read\")\n\t\t\ttyp, msg, err := c.Read(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t} else if websocket.CloseStatus(err) == websocket.StatusNormalClosure ||\n\t\t\t\t\twebsocket.CloseStatus(err) == websocket.StatusGoingAway {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"connection reset by peer\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else if strings.Contains(err.Error(), \"corrupt input\") {\n\t\t\t\t\tlogx.Infof(\"websocket closed: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlogx.Errorf(\"failed to read message: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\t_, _ = h.onReceive(ctx, connection, typ, msg)\n\t\t\t}()\n\t\t}\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *gatewayservicelogic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\tvar aesKey []byte\n\tvar aesIv []byte\n\tvar isEncrypt bool\n\n\tconnection.PublicKeyLock.RLock()\n\t{\n\t\tif len(connection.SharedSecret) == 0 {\n\t\t\tisEncrypt = false\n\t\t} else {\n\t\t\tisEncrypt = true\n\t\t\taesKey = connection.SharedSecret[:]\n\t\t\taesIv = connection.SharedSecret[8:24]\n\t\t}\n\t}\n\tconnection.PublicKeyLock.RUnlock()\n\n\tif isEncrypt {\n\t\tvar err error\n\t\tmsg, err = utils.Aes.Decrypt(aesKey, aesIv, msg)\n\t\tif err != nil {\n\t\t\tlogx.Errorf(\"decrypt message error: %v\", err)\n\t\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t\t}\n\t}\n\n\tapiRequest := &pb.GatewayApiRequest{}\n\terr := proto.Unmarshal(msg, apiRequest)\n\tif err != nil {\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", err)\n\t}\n\tapiRequest.Header = connection.GetHeader()\n\troute, ok := universalRouteMap[apiRequest.Path]\n\ttracer := otel.Tracer(common.TraceName)\n\tpropagator := otel.GetTextMapPropagator()\n\tspanName := apiRequest.Path\n\tcarrier := propagation.MapCarrier{\n\t\t\"appId\":       apiRequest.Header.AppId,\n\t\t\"userId\":      apiRequest.Header.UserId,\n\t\t\"clientIp\":    apiRequest.Header.ClientIp,\n\t\t\"installId\":   apiRequest.Header.InstallId,\n\t\t\"platform\":    apiRequest.Header.Platform.String(),\n\t\t\"deviceModel\": apiRequest.Header.DeviceModel,\n\t\t\"osVersion\":   apiRequest.Header.OsVersion,\n\t\t\"appVersion\":  apiRequest.Header.AppVersion,\n\t\t\"connectTime\": connection.ConnectedTime.Format(\"2006-01-02 15:04:05\"),\n\t\t\"extra\":       apiRequest.Header.Extra,\n\t}\n\tspanCtx := propagator.Extract(ctx, carrier)\n\tspanCtx, span := tracer.Start(spanCtx, spanName,\n\t\toteltrace.WithSpanKind(oteltrace.SpanKindServer),\n\t)\n\tdefer span.End()\n\tpropagator.Inject(spanCtx, carrier)\n\tif !ok {\n\t\tlogx.Errorf(\"path 404 not found: %s\", apiRequest.Path)\n\t\tspan.SetStatus(codes.Error, \"path\"+apiRequest.Path+\"404 not found\")\n\t\treturn pb.ResponseCode_INVALID_DATA, fmt.Errorf(\"handle message error: %v\", \"path 404 not found\")\n\t}\n\tcode, responseBody, err := route(spanCtx, connection, apiRequest)\n\tif len(responseBody) > 0 {\n\t\terr := connection.SendMessage(ctx, responseBody)\n\t\tif err != nil {\n\t\t\tlogx.Infof(\"failed to write message: %v\", err)\n\t\t}\n\t}\n\tspan.SetAttributes(attribute.Int(\"responseBody.length\", len(responseBody)))\n\tif err != nil {\n\t\tspan.SetStatus(codes.Error, err.Error())\n\t} else {\n\t\tspan.SetStatus(codes.Ok, \"\")\n\t}\n\treturn code, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 116,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tpb \"path/to/your/proto/package\"\n\t\"path/to/your/service/logic\"\n\t\"path/to/your/service/svc\"\n)\n\ntype WsHandler struct {\n\tsvcCtx *svc.ServiceContext\n}\n\nfunc NewWsHandler(svcCtx *svc.ServiceContext) *WsHandler {\n\treturn &WsHandler{svcCtx: svcCtx}\n}\n\nfunc (h *WsHandler) Upgrade(ginCtx *gin.Context) {\n\tconn, err := upgrader.Upgrade(ginCtx.Writer, ginCtx.Request, nil)\n\tif err != nil {\n\t\tginCtx.JSON(500, gin.H{\"error\": \"Failed to upgrade connection\"})\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\twsConnection := logic.NewConnection(conn, h.svcCtx)\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\th.svcCtx.Logger.Errorf(\"read error: %v\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tresponseCode, err := h.onReceive(context.Background(), wsConnection, messageType, message)\n\t\tif err != nil {\n\t\t\th.svcCtx.Logger.Errorf(\"on receive error: %v\", err)\n\t\t} else if responseCode != pb.ResponseCode_OK {\n\t\t\th.svcCtx.Logger.Errorf(\"response code: %d\", responseCode)\n\t\t}\n\t}\n}\n\nfunc (h *WsHandler) onReceive(ctx context.Context, connection *logic.Connection, typ websocket.MessageType, msg []byte) (pb.ResponseCode, error) {\n\tswitch typ {\n\tcase websocket.TextMessage:\n\t\th.svcCtx.Logger.Infof(\"Received text message: %s\", string(msg))\n\t\t// Process text message\n\tcase websocket.BinaryMessage:\n\t\th.svcCtx.Logger.Infof(\"Received binary message\")\n\t\t// Process binary message\n\tdefault:\n\t\treturn pb.ResponseCode_UnknownMessageType, status.Errorf(codes.InvalidArgument, \"unknown message type\")\n\t}\n\t// Handle message and return response code\n\treturn pb.ResponseCode_OK, nil\n}\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n```"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawnUserNamespaceCat creates a child process in a new user namespace to read a specified file. It establishes two pipes (one for standard output and one for standard error) to communicate between the parent and child processes. The function handles process creation, data transfer through pipes, process waiting, and error handling.\n\nInput:\n- nsPath (string): Path to the user namespace to spawn the process in\n- path (string): Path to the file that should be read by the child process\n\nOutput:\n- ([]byte, error): Returns the file contents as a byte slice if successful, or an error if any step fails. The error contains detailed information about the failure.\n\nNote: The function relies on an external C function spawn_userns_cat which handles the actual process creation in the new namespace. The function manages proper resource cleanup through defer statements and handles both successful and error cases with appropriate return values.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/sirupsen/logrus\"\n)\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os/exec\"\n)\n\nfunc spawnUserNamespaceCat(nsPath, path string) ([]byte, error) {\n\tcmd := exec.Command(\"spawn_userns_cat\", nsPath, path)\n\tvar stdout bytes.Buffer\n\tvar stderr bytes.Buffer\n\tcmd.Stdout = &stdout\n\tcmd.Stderr = &stderr\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, errors.New(\"failed to start command: \" + err.Error() + \"\\n\" + stderr.String())\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\treturn nil, errors.New(\"command failed: \" + err.Error() + \"\\n\" + stderr.String())\n\t}\n\n\treturn stdout.Bytes(), nil\n}\n```"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: The task involves creating a proxy command handler that manages inter-process communication between a parent process and a child process using Go's pipe mechanism. The handler should start the child process, monitor its initialization status through the pipe, and handle potential errors or timeouts.\n\nStruct Description: The `proxyCommand` struct encapsulates a child process command and provides methods to manage its execution and IPC communication.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as a child process.\n\nMethods:\nStart: Start() -> error - Initializes the child process, establishes a pipe for communication, monitors the child's initialization status, and returns any errors encountered during startup or a timeout if the child process fails to initialize within the specified duration.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (pc *proxyCommand) Start(ctx context.Context, initTimeout time.Duration) error {\n\tpc.cmd = exec.CommandContext(ctx, \"your_command\", \"arg1\", \"arg2\")\n\n\tstdout, err := pc.cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create stdout pipe: %w\", err)\n\t}\n\tdefer stdout.Close()\n\n\tstderr, err := pc.cmd.StderrPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create stderr pipe: %w\", err)\n\t}\n\tdefer stderr.Close()\n\n\tif err := pc.cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"failed to start command: %w\", err)\n\t}\n\n\tdone := make(chan error, 1)\n\tgo func() {\n\t\tdone <- pc.cmd.Wait()\n\t}()\n\n\tselect {\n\tcase <-time.After(initTimeout):\n\t\tif err := pc.cmd.Process.Kill(); err != nil {\n\t\t\treturn fmt.Errorf(\"command failed to initialize, killed: %w\", err)\n\t\t}\n\t\treturn fmt.Errorf(\"command failed to initialize within %s\", initTimeout)\n\tcase err := <-done:\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"command exited with error: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tctx := context.Background()\n\tcommandHandler := &proxyCommand{}\n\terr := commandHandler.Start(ctx, 5*time.Second)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Command started successfully\")\n\t}\n}\n```"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Go function that securely copies a password to the system clipboard using osascript (AppleScript) via a pipe, ensuring the password is handled safely and the clipboard is cleared after use.\n\nFunction Description: The function `copyViaOsascript` uses an inter-process communication mechanism (pipe) to securely pass a password to the AppleScript command `osascript`, which then sets the password in the system clipboard. The function ensures proper resource cleanup and checks for successful execution.\n\nInput:\n- `ctx context.Context`: Context for managing the command's lifecycle and cancellation.\n- `password string`: The password string to be copied to the clipboard.\n\nOutput:\n- `error`: Returns an error if any step fails (pipe creation, command execution, or clipboard setting). Returns nil on success.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\targs := []string{\n\t\t\"-e\", `use framework \"Foundation\"`,\n\t\t\"-e\", \"use scripting additions\",\n\t\t\"-e\", \"set type to current application's NSPasteboardTypeString\",\n\t\t\"-e\", \"set pb to current application's NSPasteboard's generalPasteboard()\",\n\t\t\"-e\", \"pb's clearContents()\",\n\t\t\"-e\", `pb's setString:\"\" forType:\"org.nspasteboard.ConcealedType\"`,\n\t\t\"-e\", `pb's setString:(do shell script \"cat 0<&3\") forType:type`,\n\t}\n\tcmd := exec.CommandContext(ctx, \"osascript\", args...)\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.ExtraFiles = []*os.File{r}\n\tgo func() {\n\t\tdefer w.Close()\n\t\t_, _ = io.WriteString(w, password)\n\t}()\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(out) != \"true\\n\" {\n\t\treturn fmt.Errorf(\"osascript failed to set password: %s\", string(out))\n\t}\n\n\treturn nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc copyViaOsascript(ctx context.Context, password string) error {\n\tcmd := exec.CommandContext(ctx, \"osascript\", \"-e\", fmt.Sprintf(\"tell application \\\"System Events\\\" to keystroke \\\"%s\\\" using {command down}\", strings.Replace(password, \"\\n\", \"\", -1)))\n\tcmd.Stdin = unix.Stdin\n\tcmd.Stdout = unix.Stdout\n\tcmd.Stderr = unix.Stderr\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"failed to start osascript command: %w\", err)\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\treturn fmt.Errorf(\"osascript command failed: %w\", err)\n\t}\n\n\treturn nil\n}\n```"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Go struct that manages a proxy command process with inter-process communication capabilities using pipes for error handling and status reporting.\n\nStruct Description: The proxyCommand struct represents a proxy process manager that uses os.Pipe for IPC to monitor the startup status of a userland proxy. It handles process execution, pipe communication, and timeout management.\n\nFields:\ncmd: *exec.Cmd - The command to be executed as the proxy process\n\nMethods:\nStart: () -> error - Starts the proxy command and monitors its initialization status through a pipe. Returns nil if successful or an error if the proxy fails to start or times out. Uses a pipe to communicate startup status from the child process and implements a 16-second timeout.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc (p *proxyCommand) Start() error {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"proxy unable to open os.Pipe %s\", err)\n\t}\n\tdefer r.Close()\n\tp.cmd.ExtraFiles = []*os.File{w}\n\tif err := p.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\tw.Close()\n\n\terrchan := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 2)\n\t\tr.Read(buf)\n\n\t\tif string(buf) != \"0\\n\" {\n\t\t\terrStr, err := ioutil.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\terrchan <- fmt.Errorf(\"Error reading exit status from userland proxy: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrchan <- fmt.Errorf(\"Error starting userland proxy: %s\", errStr)\n\t\t\treturn\n\t\t}\n\t\terrchan <- nil\n\t}()\n\n\tselect {\n\tcase err := <-errchan:\n\t\treturn err\n\tcase <-time.After(16 * time.Second):\n\t\treturn fmt.Errorf(\"Timed out proxy starting the userland proxy\")\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype proxyCommand struct {\n\tcmd *exec.Cmd\n}\n\nfunc NewProxyCommand(command string, args ...string) *proxyCommand {\n\treturn &proxyCommand{\n\t\tcmd: exec.Command(command, args...),\n\t}\n}\n\nfunc (pc *proxyCommand) Start() error {\n\tstderrPipe, err := pc.cmd.StderrPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create stderr pipe: %w\", err)\n\t}\n\n\tif err := pc.cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"failed to start proxy command: %w\", err)\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 16*time.Second)\n\tdefer cancel()\n\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\tvar buf bytes.Buffer\n\t\t_, err := buf.ReadFrom(stderrPipe)\n\t\tif err != nil {\n\t\t\terrChan <- fmt.Errorf(\"failed to read from stderr pipe: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tif buf.String() == \"Initialization complete\\n\" {\n\t\t\terrChan <- nil\n\t\t} else {\n\t\t\terrChan <- fmt.Errorf(\"proxy initialization failed\")\n\t\t}\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase <-ctx.Done():\n\t\treturn fmt.Errorf(\"proxy initialization timed out\")\n\t}\n\n\tif err := pc.cmd.Wait(); err != nil {\n\t\treturn fmt.Errorf(\"proxy command exited with error: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tpc := NewProxyCommand(\"path/to/proxy\", \"arg1\", \"arg2\")\n\tif err := pc.Start(); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Proxy started successfully\")\n\t}\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Go struct that represents a basic HTTP server capable of serving static files from a specified directory, with fallback to a default page when files are not found.\n\nStruct Description: The Site struct represents a simple HTTP server that serves static files from a \"./site\" directory. It handles file requests and falls back to serving \"index.html\" when the requested file is not found.\n\nFields: (This struct has no explicit fields as it's used purely for organizing HTTP server functionality)\n\nMethods:\n\nMethod1: New() -> *Site - A constructor function that creates and returns a new instance of the Site struct.\n\nMethod2: Run() - Starts the HTTP server on the port specified in the configuration. It sets up a file server handler with custom 404 behavior and begins listening for requests.\n\nMethod3: notFound(http.ResponseWriter, *http.Request) - A helper function that serves the \"./site/index.html\" file when a requested resource is not found. Takes standard HTTP handler parameters and returns nothing.\n\nMethod4: server(http.FileSystem) -> http.Handler - A helper function that creates a custom file server handler with fallback behavior. Takes a filesystem interface and returns an HTTP handler.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\ntype Site struct {\n}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\tdata, _ := ioutil.ReadFile(\"./site/index.html\")\n\t_, _ = fmt.Fprintf(w, string(data))\n\treturn\n}\n\nfunc server(fs http.FileSystem) http.Handler {\n\tfileServer := http.FileServer(fs)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfilePath := path.Clean(\"./site\" + r.URL.Path)\n\t\t_, err := os.Stat(filePath)\n\t\tif err != nil {\n\t\t\tnotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfileServer.ServeHTTP(w, r)\n\t})\n}\n\nfunc (s *Site) Run() {\n\tport := config.Conf.Site.SiteBase.ListenPort\n\taddr := fmt.Sprintf(\":%d\", port)\n\thttp.ListenAndServe(addr, server(http.Dir(\"./site\")))\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\ntype Site struct{}\n\nfunc New() *Site {\n\treturn &Site{}\n}\n\nfunc (s *Site) Run(port int) {\n\tfs := s.server(http.Dir(\"./site\"))\n\thttp.Handle(\"/\", fs)\n\thttp.ListenAndServe(fmt.Sprintf(\":%d\", port), nil)\n}\n\nfunc (s *Site) notFound(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, \"./site/index.html\")\n}\n\nfunc (s *Site) server(fs http.FileSystem) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tf, err := fs.Open(r.URL.Path[1:])\n\t\tif err != nil {\n\t\t\ts.notFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\n\tstat, err := f.Stat()\n\tif err != nil {\n\t\ts.notFound(w, r)\n\t\treturn\n\t}\n\n\tif stat.IsDir() {\n\t\thttp.ServeContent(w, r, \"index.html\", stat.ModTime(), f)\n\t} else {\n\t\thttp.ServeContent(w, r, r.URL.Path[1:], stat.ModTime(), f)\n\t}\n})\n```"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Write a Go function that spawns a process in a new user namespace to read a file's contents, using pipes for inter-process communication to capture both standard output and error streams.\n\nFunction Description: The function spawns a child process (via CGO) that runs in a new user namespace, reads the specified file, and returns its contents. It uses two pipes for IPC - one for standard output and another for standard error. The function handles process creation, pipe management, error handling, and cleanup of resources.\n\nInput:\n- nsPath (string): Path to the user namespace configuration\n- path (string): Path to the file to be read\n\nOutput:\n- ([]byte, error): Returns the file contents as bytes if successful, or an error if any step fails (pipe creation, process spawning, reading output, or process execution)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\n/*\n#include <stdlib.h>\nextern int spawn_userns_cat(char *userns_path, char *path, int outfd, int errfd);\n*/\nimport \"C\"\n\nfunc spawnUserNamespaceCat(nsPath string, path string) ([]byte, error) {\n\trdr, wtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer rdr.Close()\n\tdefer wtr.Close()\n\n\terrRdr, errWtr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create error pipe for userns spawn failed: %w\", err)\n\t}\n\tdefer errRdr.Close()\n\tdefer errWtr.Close()\n\n\tcNsPath := C.CString(nsPath)\n\tdefer C.free(unsafe.Pointer(cNsPath))\n\tcPath := C.CString(path)\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tchildPid := C.spawn_userns_cat(cNsPath, cPath, C.int(wtr.Fd()), C.int(errWtr.Fd()))\n\n\tif childPid < 0 {\n\t\treturn nil, fmt.Errorf(\"failed to spawn fork for userns\")\n\t} else if childPid == 0 {\n\t\tpanic(\"runc executing inside fork child -- unsafe state!\")\n\t}\n\n\twtr.Close()\n\toutput, err := io.ReadAll(rdr)\n\trdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn failed: %w\", err)\n\t}\n\n\terrWtr.Close()\n\terrOutput, err := io.ReadAll(errRdr)\n\terrRdr.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading from userns spawn error pipe failed: %w\", err)\n\t}\n\terrOutput = bytes.TrimSpace(errOutput)\n\n\tchild, err := os.FindProcess(int(childPid))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find userns spawn process: %w\", err)\n\t}\n\tstate, err := child.Wait()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to wait for userns spawn process: %w\", err)\n\t}\n\tif !state.Success() {\n\t\terrStr := string(errOutput)\n\t\tif errStr == \"\" {\n\t\t\terrStr = fmt.Sprintf(\"unknown error (status code %d)\", state.ExitCode())\n\t\t}\n\t\treturn nil, fmt.Errorf(\"userns spawn: %s\", errStr)\n\t} else if len(errOutput) > 0 {\n\t\tlogrus.Debugf(\"userns spawn succeeded but unexpected error message found: %s\", string(errOutput))\n\t}\n\treturn output, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\n/*\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint run_in_namespace(const char* ns_path, const char* path, int stdout_pipe[2], int stderr_pipe[2]) {\n    pid_t pid = fork();\n    if (pid == 0) {\n        if (chroot(ns_path) != 0 || chdir(\"/\") != 0) {\n            _exit(1);\n        }\n        close(stdout_pipe[0]);\n        dup2(stdout_pipe[1], STDOUT_FILENO);\n        close(stderr_pipe[0]);\n        dup2(stderr_pipe[1], STDERR_FILENO);\n        close(stdout_pipe[1]);\n        close(stderr_pipe[1]);\n        execl(\"/usr/bin/cat\", \"cat\", path, NULL);\n        _exit(1);\n    } else if (pid > 0) {\n        close(stdout_pipe[1]);\n        close(stderr_pipe[1]);\n        return pid;\n    } else {\n        return -1;\n    }\n}\n*/\nimport \"C\"\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc readFileInNamespace(nsPath, path string) ([]byte, error) {\n    var stdoutPipe [2]int\n    var stderrPipe [2]int\n    if err := syscall.Pipe(stdoutPipe[:]); err != nil {\n        return nil, fmt.Errorf(\"failed to create stdout pipe: %w\", err)\n    }\n    defer syscall.Close(stdoutPipe[0])\n    defer syscall.Close(stdoutPipe[1])\n\n    if err := syscall.Pipe(stderrPipe[:]); err != nil {\n        return nil, fmt.Errorf(\"failed to create stderr pipe: %w\", err)\n    }\n    defer syscall.Close(stderrPipe[0])\n    defer syscall.Close(stderrPipe[1])\n\n    pid := C.run_in_namespace(C.CString(nsPath), C.CString(path), (*C.int)(unsafe.Pointer(&stdoutPipe[0])), (*C.int)(unsafe.Pointer(&stderrPipe[0])))\n    if pid < 0 {\n        return nil, fmt.Errorf(\"failed to spawn process in namespace\")\n    }\n\n    stdoutReader := os.NewFile(uintptr(stdoutPipe[0]), \"stdout\")\n    stderrReader := os.NewFile(uintptr(stderrPipe[0]), \"stderr\")\n\n    stdoutBytes, _ := ioutil.ReadAll(stdoutReader)\n    stderrBytes, _ := ioutil.ReadAll(stderrReader)\n\n    stdoutReader.Close()\n    stderrReader.Close()\n\n    if len(stderrBytes) > 0 {\n        return nil, fmt.Errorf(\"error from subprocess: %s\", stderrBytes)\n    }\n\n    return stdoutBytes, nil\n}\n\nfunc main() {\n    nsPath := \"/path/to/user/ns\"\n    filePath := \"/path/to/file.txt\"\n\n    content, err := readFileInNamespace(nsPath, filePath)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(\"Content:\", string(content))\n    }\n}\n```"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Go struct that implements a log retrieval mechanism using pipes for inter-process communication, allowing for reading logs from a file and writing them to a pipe for consumption by another process.\n\nStruct Description: The `logRetriever` struct provides a way to read logs from a file and write them to a pipe, implementing `io.ReadCloser` for standard read and close operations. It also includes methods to manage the pipe's writer and output.\n\nFields:\n- reader: *os.File - The read end of the pipe used to consume log data.\n- writer: *os.File - The write end of the pipe used to send log data.\n- output: *fileCloner - A helper component that clones the writer's output to a log file.\n\nMethods:\n- newlogRetriever: (logFile string) -> (*logRetriever, error) - Initializes a new logRetriever instance, creates a pipe, and sets up file cloning. If the log file exists, copies its contents to the pipe.\n- Read: (p []byte) -> (int, error) - Implements io.Reader to read data from the pipe's reader.\n- CloseWriter: () -> error - Closes the pipe's writer to signal the end of data transmission.\n- Close: () -> error - Implements io.Closer to close the pipe's reader and release resources.\n- Opt: () -> cio.Opt - Returns an option for configuring IO streams, using a null reader and the output cloner.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (l *logRetriever, err error) {\n\tl = &logRetriever{}\n\tif l.reader, l.writer, err = os.Pipe(); err != nil {\n\t\treturn\n\t}\n\n\tif l.output, err = newFileCloner(l.writer, logFile); err != nil {\n\t\treturn\n\t}\n\n\tif util.FileExists(logFile) {\n\t\tvar reader io.ReadCloser\n\t\tif reader, err = os.Open(logFile); err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer util.DeferErr(&err, reader.Close)\n\n\t\tif _, err = io.Copy(l.writer, reader); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nvar _ io.ReadCloser = &logRetriever{}\n\nfunc (l *logRetriever) Opt() cio.Opt {\n\treturn cio.WithStreams(&nullReader{}, l.output, l.output)\n}\n\nfunc (l *logRetriever) Read(p []byte) (n int, err error) {\n\treturn l.reader.Read(p)\n}\n\nfunc (l *logRetriever) CloseWriter() (err error) {\n\treturn l.writer.Close()\n}\n\nfunc (l *logRetriever) Close() error {\n\treturn l.reader.Close()\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 118,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype logRetriever struct {\n\treader *os.File\n\twriter *os.File\n\toutput *fileCloner\n}\n\nfunc newlogRetriever(logFile string) (*logRetriever, error) {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toutput, err := newFileCloner(w)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tret := &logRetriever{reader: r, writer: w, output: output}\n\tif _, err = ret.output.WriteFile(logFile); err != nil {\n\t\treturn nil, err\n\t}\n\treturn ret, nil\n}\n\nfunc (lr *logRetriever) Read(p []byte) (int, error) {\n\treturn lr.reader.Read(p)\n}\n\nfunc (lr *logRetriever) CloseWriter() error {\n\treturn lr.writer.Close()\n}\n\nfunc (lr *logRetriever) Close() error {\n\treturn lr.reader.Close()\n}\n\nfunc (lr *logRetriever) Opt() cio.Opt {\n\treturn cio.Opt{\n\t\tIn:  io.NopCloser(nil),\n\t\tOut: lr.output,\n\t}\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It maintains client state, base URLs, user agent, rate limits, and provides access to various API services. The struct includes methods for creating new requests and executing them.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe access to rate limits\nrateLimits: [categories]Rate - Rate limit tracking for different API categories\ncommon: service - Shared service instance used by all API services\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support, rate limiting, and response handling",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype Rate struct {\n\tLimit  int\n\tRemaining int\n\tReset    int64\n}\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\tBaseURL  *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\trateMu   sync.Mutex\n\trateLimits map[string]Rate\n\tcommon     *service\n}\n\nfunc NewClient(client *http.Client) *Client {\n\treturn &Client{\n\t\tclient: client,\n\t\tBaseURL:  mustParseURL(\"https://api.example.com\"),\n\t\tUploadURL: mustParseURL(\"https://upload.example.com\"),\n\t\tUserAgent: \"MyApp/1.0\",\n\t\trateLimits: make(map[string]Rate),\n\t}\n}\n\nfunc (c *Client) NewRequest(method string, urlStr string, body interface{}) (*http.Request, error) {\n\treq, err := http.NewRequestWithContext(context.Background(), method, urlStr, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t// Add other headers as needed\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tc.clientMu.Lock()\n\tdefer c.clientMu.Unlock()\n\n\t// Apply rate limiting logic here\n\t// ...\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Handle response parsing and validation\n\t// ...\n\n\treturn &Response{resp}, nil\n}\n\nfunc mustParseURL(s string) *url.URL {\n\tu, err := url.Parse(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn u\n}\n\ntype Response struct {\n\thttp.Response\n}\n\nfunc main() {\n\tclient := NewClient(nil)\n\treq, _ := client.NewRequest(\"GET\", \"/endpoint\", nil)\n\tresp, _ := client.Do(context.Background(), req, nil)\n\t// Process the response\n}\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a Go struct that represents a metric sink for sending metrics to a Cortex metrics server using HTTP with advanced configuration options.\n\nStruct Description: The CortexMetricSink struct is responsible for batching and sending metrics to a Cortex server via HTTP with support for custom headers, basic authentication, proxy configuration, and connection pooling.\n\nFields:\n\nURL: string - The endpoint URL of the Cortex server to send metrics to\nRemoteTimeout: time.Duration - Timeout for HTTP requests to Cortex\nProxyURL: string - URL of the proxy server to use (optional)\nClient: *http.Client - Custom HTTP client for making requests\nlogger: *logrus.Entry - Logger for the sink\nname: string - Name identifier for the sink\ntraceClient: *trace.Client - Tracing client for distributed tracing\naddHeaders: map[string]string - Additional headers to include in requests\nbasicAuth: *BasicAuthType - Basic authentication credentials (optional)\nbatchWriteSize: int - Maximum number of metrics to batch before sending\ncounters: map[counterMapKey]float64 - Internal counter storage\nconvertCountersToMonotonic: bool - Flag to convert counters to monotonic values\nexcludedTags: map[string]struct{} - Tags to exclude from metrics\nhost: string - Host identifier for metrics\n\nMethods:\n\nStart: (tc *trace.Client) -> error - Initializes the sink with tracing and HTTP client configuration\nwriteMetrics: (ctx context.Context, metrics []samplers.InterMetric) -> error - Processes and sends a batch of metrics to Cortex\n\nBasicAuthType Struct Description: Nested struct for storing basic authentication credentials\n\nFields:\n\nUsername: util.StringSecret - Basic auth username (secret type)\nPassword: util.StringSecret - Basic auth password (secret type)",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/golang/snappy\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/prometheus/prometheus/prompb\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/veneur/v14/samplers\"\n\t\"github.com/stripe/veneur/v14/sinks\"\n\t\"github.com/stripe/veneur/v14/trace\"\n)\n\ntype CortexMetricSink struct {\n\tURL                        string\n\tRemoteTimeout              time.Duration\n\tProxyURL                   string\n\tClient                     *http.Client\n\tlogger                     *logrus.Entry\n\tname                       string\n\ttraceClient                *trace.Client\n\taddHeaders                 map[string]string\n\tbasicAuth                  *BasicAuthType\n\tbatchWriteSize             int\n\tcounters                   map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags               map[string]struct{}\n\thost                       string\n}\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret `yaml:\"username\"`\n\tPassword util.StringSecret `yaml:\"password\"`\n}\n\nfunc (s *CortexMetricSink) Start(tc *trace.Client) error {\n\ts.logger.Infof(\"Starting sink for %s\", s.URL)\n\tt := http.DefaultTransport.(*http.Transport).Clone()\n\tt.MaxIdleConns = MaxConns\n\tt.MaxConnsPerHost = MaxConns\n\tt.MaxIdleConnsPerHost = MaxConns\n\n\tif len(s.ProxyURL) > 0 {\n\t\tp, err := url.Parse(s.ProxyURL)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"malformed cortex_proxy_url\")\n\t\t}\n\t\tt.Proxy = http.ProxyURL(p)\n\t}\n\n\ts.Client = &http.Client{\n\t\tTimeout:   s.RemoteTimeout,\n\t\tTransport: t,\n\t}\n\n\ts.traceClient = tc\n\treturn nil\n}\n\nfunc (s *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\tspan, _ := trace.StartSpanFromContext(ctx, \"\")\n\tdefer span.ClientFinish(s.traceClient)\n\n\twr := s.makeWriteRequest(metrics)\n\n\tdata, err := wr.Marshal()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to marshal proto\\\"\")\n\t}\n\n\tvar buf bytes.Buffer\n\tencoded := snappy.Encode(nil, data)\n\tbuf.Write(encoded)\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", s.URL, &buf)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: failed to create http request\\\"\")\n\t}\n\n\treq.Header.Set(\"Content-Encoding\", \"snappy\")\n\treq.Header.Set(\"Content-Type\", \"application/x-protobuf\")\n\treq.Header.Set(\"User-Agent\", \"veneur/cortex\")\n\treq.Header.Set(\"X-Prometheus-Remote-Write-Version\", \"0.1.0\")\n\tfor key, value := range s.addHeaders {\n\t\treq.Header.Set(key, value)\n\t}\n\tif s.basicAuth != nil {\n\t\treq.SetBasicAuth(s.basicAuth.Username.Value, s.basicAuth.Password.Value)\n\t}\n\n\tts := time.Now()\n\tr, err := s.Client.Do(req)\n\tif err != nil {\n\t\tspan.Error(err)\n\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: misc http client error\\\" duration_secs=%.2f\", time.Since(ts).Seconds())\n\t}\n\tdefer r.Body.Close()\n\n\tif r.StatusCode >= 300 {\n\t\tb, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cortex_err=\\\"failed to write batch: downstream returned error response with unreadable body\\\" response_code=%d\", r.StatusCode)\n\t\t}\n\t\treturn fmt.Errorf(\"cortex_err=\\\"failed to write batch: error response\\\", response_code=%d response_body=\\\"%s\\\"\", r.StatusCode, b)\n\t}\n\n\treturn nil\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/cortexproject/cortex/pkg/util\"\n\t\"github.com/opentracing/opentracing-go\"\n)\n\ntype BasicAuthType struct {\n\tUsername util.StringSecret\n\tPassword util.StringSecret\n}\n\ntype CortexMetricSink struct {\n\tURL                     string\n\tRemoteTimeout           time.Duration\n\tProxyURL                string\n\tClient                  *http.Client\n\tlogger                  *logrus.Entry\n\tname                    string\n\ttraceClient             opentracing.Tracer\n\taddHeaders              map[string]string\n\tbasicAuth               *BasicAuthType\n\tbatchWriteSize          int\n\tcounters                map[counterMapKey]float64\n\tconvertCountersToMonotonic bool\n\texcludedTags            map[string]struct{}\n\thost                    string\n}\n\nfunc (cs *CortexMetricSink) Start(tc opentracing.Tracer) error {\n\tcs.traceClient = tc\n\tif cs.basicAuth != nil {\n\t\tauth := cs.basicAuth.Username.Get() + \":\" + cs.basicAuth.Password.Get()\n\t\tcs.addHeaders[\"Authorization\"] = \"Basic \" + base64.StdEncoding.EncodeToString([]byte(auth))\n\t}\n\treturn nil\n}\n\nfunc (cs *CortexMetricSink) writeMetrics(ctx context.Context, metrics []samplers.InterMetric) error {\n\t// Implementation for processing and sending metrics to Cortex\n\treturn nil\n}\n\ntype counterMapKey struct {\n\tmetricName string\n\ttags       string\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a simple HTTP server in Go that handles user authentication through cookies, displaying different HTML content based on login status.\n\nFunction Description: The main function sets up an HTTP server with a single route handler that manages user authentication. It checks for a \"logged-in\" cookie, processes login/logout requests, and serves different HTML content based on the authentication status.\n\nInput: None (The function takes no direct input parameters, but handles HTTP requests through the net/http package)\n\nOutput: None (The function doesn't return any value, but serves HTTP responses and maintains server state)\n\nNote: The function handles three main scenarios:\n1. Initial visit (no cookie set)\n2. Successful login (POST with correct password)\n3. Logout request (/logout path)\nFor each scenario, it sets appropriate cookies and returns corresponding HTML content.",
    "Canonical_solution": "import (\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tcookie, err := req.Cookie(\"logged-in\")\n\t\tif err == http.ErrNoCookie {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:  \"logged-in\",\n\t\t\t\tValue: \"0\",\n\t\t\t}\n\t\t}\n\n\t\tif req.Method == \"POST\" {\n\t\t\tpassword := req.FormValue(\"password\")\n\t\t\tif password == \"secret\" {\n\t\t\t\tcookie = &http.Cookie{\n\t\t\t\t\tName:  \"logged-in\",\n\t\t\t\t\tValue: \"1\",\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif req.URL.Path == \"/logout\" {\n\t\t\tcookie = &http.Cookie{\n\t\t\t\tName:   \"logged-in\",\n\t\t\t\tValue:  \"0\",\n\t\t\t\tMaxAge: -1,\n\t\t\t}\n\t\t}\n\n\t\thttp.SetCookie(res, cookie)\n\t\tvar html string\n\n\t\tif cookie.Value == strconv.Itoa(0) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1>LOG IN</h1>\n\t\t\t<form method=\"post\" action=\"http://localhost:9000/\">\n\t\t\t\t<h3>User name</h3>\n\t\t\t\t<input type=\"text\" name=\"userName\" id=\"userName\">\n\t\t\t\t<h3>Password</h3>\n\t\t\t\t<input type=\"text\" name=\"password\" id=\"password\">\n\t\t\t\t<br>\n\t\t\t\t<input type=\"submit\">\n\t\t\t\t<input type=\"submit\" name=\"logout\" value=\"logout\">\n\t\t\t</form>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tif cookie.Value == strconv.Itoa(1) {\n\t\t\thtml = `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<title></title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t<h1><a href=\"http://localhost:9000/logout\">LOG OUT</a></h1>\n\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\n\t\tio.WriteString(res, html)\n\t})\n\thttp.ListenAndServe(\":9000\", nil)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleAuth)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc handleAuth(w http.ResponseWriter, r *http.Request) {\n\tcookie, err := r.Cookie(\"logged-in\")\n\tif err != nil && err != http.ErrNoCookie {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\t\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif cookie != nil {\n\t\t\tw.Write([]byte(\"<h1>Welcome back!</h1>\"))\n\t\t} else {\n\t\t\tw.Write([]byte(\"<form method='post' action='/'>Username: <input type='text' name='username'><br>Password: <input type='password' name='password'><br><input type='submit' value='Login'></form>\"))\n\t\t}\n\tcase http.MethodPost:\n\t\tusername := r.FormValue(\"username\")\n\t\tpassword := r.FormValue(\"password\")\n\t\tif username == \"admin\" && password == \"password\" {\n\t\t\thttp.SetCookie(w, &http.Cookie{Name: \"logged-in\", Value: \"true\", Path: \"/\"})\n\t\t\tw.Write([]byte(\"<h1>Login successful!</h1>\"))\n\t\t} else {\n\t\t\tw.Write([]byte(\"<h1>Invalid credentials</h1>\"))\n\t\t}\n\tcase http.MethodDelete:\n\t\thttp.SetCookie(w, &http.Cookie{Name: \"logged-in\", Value: \"\", MaxAge: -1, Path: \"/\"})\n\t\tw.Write([]byte(\"<h1>Logged out successfully!</h1>\"))\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"<h1>Method not allowed</h1>\"))\n\t}\n}\n```"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Implement a function to start an HTTP server with configurable parameters including authentication, TLS, and database integration. The function should handle routing, authentication wrapping, and server startup with both HTTP and HTTPS support.\n\nFunction Description: The `Start` function initializes and starts an HTTP server with various endpoints for database operations. It supports optional authentication via a pre-shared token and can be configured to use TLS for secure connections. The server connects to a tiedot database and provides RESTful endpoints for database operations.\n\nInput:\n- `dir` (string): Directory path for the tiedot database\n- `port` (int): Port number to listen on\n- `tlsCrt` (string): Path to TLS certificate file (empty for HTTP)\n- `tlsKey` (string): Path to TLS private key file (empty for HTTP)\n- `jwtPubKey` (string): JWT public key (unused in reference code)\n- `jwtPrivateKey` (string): JWT private key (unused in reference code)\n- `bind` (string): Network interface to bind to (empty for all interfaces)\n- `authToken` (string): Pre-shared token for authentication (empty to disable)\n\nOutput: None (the function runs indefinitely serving HTTP requests or panics on error)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/HouzuoGuo/tiedot/db\"\n\t\"github.com/HouzuoGuo/tiedot/tdlog\"\n)\n\nvar (\n\tHttpDB *db.DB\n)\n\nfunc Start(dir string, port int, tlsCrt, tlsKey, jwtPubKey, jwtPrivateKey, bind, authToken string) {\n\tvar err error\n\tHttpDB, err = db.OpenDB(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thttp.HandleFunc(\"/\", Welcome)\n\thttp.HandleFunc(\"/version\", Version)\n\thttp.HandleFunc(\"/memstats\", MemStats)\n\n\tvar authWrap func(http.HandlerFunc) http.HandlerFunc\n\tif authToken != \"\" {\n\t\ttdlog.Noticef(\"API endpoints now require the pre-shared token in Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tif \"token \"+authToken != r.Header.Get(\"Authorization\") {\n\t\t\t\t\thttp.Error(w, \"\", http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\toriginalHandler(w, r)\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"API endpoints do not require Authorization header.\")\n\t\tauthWrap = func(originalHandler http.HandlerFunc) http.HandlerFunc {\n\t\t\treturn originalHandler\n\t\t}\n\t}\n\n\thttp.HandleFunc(\"/create\", authWrap(Create))\n\thttp.HandleFunc(\"/rename\", authWrap(Rename))\n\thttp.HandleFunc(\"/drop\", authWrap(Drop))\n\thttp.HandleFunc(\"/all\", authWrap(All))\n\thttp.HandleFunc(\"/scrub\", authWrap(Scrub))\n\thttp.HandleFunc(\"/sync\", authWrap(Sync))\n\thttp.HandleFunc(\"/query\", authWrap(Query))\n\thttp.HandleFunc(\"/count\", authWrap(Count))\n\thttp.HandleFunc(\"/insert\", authWrap(Insert))\n\thttp.HandleFunc(\"/get\", authWrap(Get))\n\thttp.HandleFunc(\"/getpage\", authWrap(GetPage))\n\thttp.HandleFunc(\"/update\", authWrap(Update))\n\thttp.HandleFunc(\"/delete\", authWrap(Delete))\n\thttp.HandleFunc(\"/approxdoccount\", authWrap(ApproxDocCount))\n\thttp.HandleFunc(\"/index\", authWrap(Index))\n\thttp.HandleFunc(\"/indexes\", authWrap(Indexes))\n\thttp.HandleFunc(\"/unindex\", authWrap(Unindex))\n\thttp.HandleFunc(\"/shutdown\", authWrap(Shutdown))\n\thttp.HandleFunc(\"/dump\", authWrap(Dump))\n\n\tiface := \"all interfaces\"\n\tif bind != \"\" {\n\t\tiface = bind\n\t}\n\n\tif tlsCrt != \"\" {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTPS), port %d.\", iface, port)\n\t\tif err := http.ListenAndServeTLS(fmt.Sprintf(\"%s:%d\", bind, port), tlsCrt, tlsKey, nil); err != nil {\n\t\t\ttdlog.Panicf(\"Failed to start HTTPS service - %s\", err)\n\t\t}\n\t} else {\n\t\ttdlog.Noticef(\"Will listen on %s (HTTP), port %d.\", iface, port)\n\t\thttp.ListenAndServe(fmt.Sprintf(\"%s:%d\", bind, port), nil)\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/djimenez/tiedot\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\ntype dbHandler struct {\n\tdb *tiedot.DB\n}\n\nfunc (h *dbHandler) Get(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tcollectionName := vars[\"collection\"]\n\tdocumentID := vars[\"document\"]\n\n\tcol := h.db.Use(collectionName)\n\tif col == nil {\n\t\thttp.Error(w, \"Collection not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdoc, err := json.Marshal(col.Get(documentID))\n\tif err != nil {\n\t\thttp.Error(w, \"Error fetching document\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(doc)\n}\n\nfunc (h *dbHandler) Post(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tcollectionName := vars[\"collection\"]\n\n\tcol := h.db.Use(collectionName)\n\tif col == nil {\n\t\thttp.Error(w, \"Collection not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tvar doc map[string]interface{}\n\terr := json.NewDecoder(r.Body).Decode(&doc)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tid := col.Insert(doc)\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"%d\\n\", id)\n}\n\nfunc authenticate(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauthToken := r.Header.Get(\"Authorization\")\n\t\tif authToken != \"\" && authToken != os.Getenv(\"AUTH_TOKEN\") {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc Start(dir string, port int, tlsCrt string, tlsKey string, jwtPubKey string, jwtPrivateKey string, bind string, authToken string) {\n\tdb := tiedot.NewDB(dir)\n\tdefer db.Close()\n\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"/collections/{collection}/documents/{document}\", &dbHandler{db}.Get).Methods(\"GET\")\n\trouter.HandleFunc(\"/collections/{collection}/documents\", &dbHandler{db}.Post).Methods(\"POST\")\n\n\tif authToken != \"\" {\n\t\trouter.Use(authenticate)\n\t}\n\n\tserver := &http.Server{\n\t\tAddr:         fmt.Sprintf(\"%s:%d\", bind, port),\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t}\n\n\tif tlsCrt != \"\" && tlsKey != \"\" {\n\t\ttlsConfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{tls.LoadX509KeyPair(tlsCrt, tlsKey)},\n\t\t}\n\t\tserver.TLSConfig = tlsConfig\n\t\tgo func() {\n\t\t\tlog.Println(\"Starting HTTPS server...\")\n\t\t\tif err := server.ListenAndServeTLS(\"\", \"\"); err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to start HTTPS server: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tlog.Println(\"Starting HTTP server...\")\n\tif err := server.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"Failed to start HTTP server: %v\", err)\n\t}\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a function that checks the health status of a Kubernetes cluster by making an HTTP GET request to the cluster's livez endpoint using a custom HTTP client with TLS configuration.\n\nFunction Description: The function `GetClusterStatusByAPI` verifies the health of a Kubernetes cluster by sending an HTTPS request to the cluster's `/livez` endpoint. It uses a custom `http.Client` with TLS configuration loaded from the cluster's connection settings. The function returns a boolean indicating the cluster's health status and a string containing any error messages or the response body if the check fails.\n\nInput: \n- `addr` [string]: The address of the Kubernetes cluster API server.\n- `cluster` [*model.Cluster]: A pointer to a cluster object containing connection configuration details.\n\nOutput: \n- [bool]: `true` if the cluster is healthy (HTTP status code 200), `false` otherwise.\n- [string]: An empty string if the cluster is healthy, otherwise an error message or the response body.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/client-go/rest\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\treqURL := fmt.Sprintf(\"https://%s/livez\", addr)\n\tconf, err := clusterUtil.LoadConnConf(cluster, addr)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"load cluster config error %s\", err.Error())\n\t}\n\ttls2, err := rest.TransportFor(conf)\n\tif err != nil {\n\t\t_, _ = false, fmt.Sprintf(\"config transport error %s\", err.Error())\n\t}\n\tclient := &http.Client{Timeout: 1 * time.Second, Transport: tls2}\n\trequest, _ := http.NewRequest(\"GET\", reqURL, nil)\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Https get error %s\", err.Error())\n\t}\n\tdefer response.Body.Close()\n\tif response.StatusCode == 200 {\n\t\treturn true, \"\"\n\t}\n\ts, _ := ioutil.ReadAll(response.Body)\n\treturn false, fmt.Sprintf(\"Api check error %s\", string(s))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/client-go/rest\"\n)\n\nfunc GetClusterStatusByAPI(addr string, cluster *model.Cluster) (bool, string) {\n\ttlsConfig := &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t}\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t\tTimeout:         5 * time.Second,\n\t\t},\n\t}\n\n\treq, err := http.NewRequest(\"GET\", fmt.Sprintf(\"%s/livez\", addr), nil)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\treturn true, \"\"\n\t} else {\n\t\treturn false, resp.Status\n\t}\n}\n```"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that serves Prometheus metrics via an HTTP server, updating custom metrics (uptime and packet count) on each request.\n\nFunction Description: The ServeMetricsAt function starts an HTTP server to expose Prometheus metrics. It registers custom metrics (uptime and packet count), updates them on each request to the metrics endpoint, and serves the metrics using the Prometheus HTTP handler. The function runs the server in a goroutine to avoid blocking the main program.\n\nInput:\n- addr (string): The network address (including port) where the metrics server should listen (e.g., \":8080\")\n- c (*collector.Collector): A pointer to a collector instance used to get the current packet count (can be nil)\n\nOutput: None (the function runs indefinitely in a background goroutine)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\n\t\"github.com/dreadl0ck/netcap/collector\"\n)\nfunc ServeMetricsAt(addr string, c *collector.Collector) {\n\tprometheus.MustRegister(upTime)\n\tprometheus.MustRegister(numPackets)\n\n\tfmt.Println(\"starting to serve metrics at:\", addr+metricsRoute)\n\n\tgo func() {\n\t\tmetricsHandler := promhttp.Handler()\n\n\t\thttp.HandleFunc(metricsRoute, func(w http.ResponseWriter, r *http.Request) {\n\t\t\tupTime.WithLabelValues().Set(math.RoundToEven(time.Since(startTime).Seconds())\n\n\t\t\tif c != nil {\n\t\t\t\tnumPackets.WithLabelValues().Set(float64(c.GetNumPackets()))\n\t\t\t}\n\n\t\t\tmetricsHandler.ServeHTTP(w, r)\n\t\t})\n\t\tlog.Fatal(\"failed to serve metrics: \", http.ListenAndServe(addr, nil))\n\t}()\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n\tuptimeCounter = prometheus.NewCounter(prometheus.CounterOpts{\n\t\tName: \"uptime_seconds_total\",\n\t\tHelp: \"Total uptime in seconds.\",\n\t})\n\tpacketCountGauge = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"packet_count_total\",\n\t\tHelp: \"Total number of packets processed.\",\n\t})\n)\n\nfunc init() {\n\tprometheus.MustRegister(uptimeCounter)\n\tprometheus.MustRegister(packetCountGauge)\n}\n\nfunc ServeMetricsAt(addr string, c *Collector) {\n\tgo func() {\n\t\thttp.Handle(\"/metrics\", promhttp.Handler())\n\t\thttp.ListenAndServe(addr, nil)\n\t}()\n}\n\ntype Collector struct{}\n\nfunc (c *Collector) GetPacketCount() int64 {\n\t// Mock implementation\n\treturn 123\n}\n\nfunc main() {\n\tc := &Collector{}\n\tServeMetricsAt(\":8080\", c)\n\tselect {}\n}\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a WebSocket server in Go that handles WebSocket connections, upgrades HTTP connections to WebSocket, and manages the connections.\n\nFunction Description: The code consists of two main functions: `StartWSServer` and `wsHandler`. `StartWSServer` initializes and starts an HTTP server that listens for WebSocket connections on a specified address. `wsHandler` is the HTTP handler function that upgrades incoming HTTP requests to WebSocket connections and processes them.\n\nInput: \n- `StartWSServer`: `address` (string) - The network address (e.g., \":8080\") on which the server will listen for incoming connections.\n- `wsHandler`: `w` (http.ResponseWriter) - Used to construct the HTTP response. `r` (*http.Request) - The HTTP request to be upgraded to a WebSocket connection.\n\nOutput: \n- `StartWSServer`: None (panics on error).\n- `wsHandler`: None (logs errors if the WebSocket upgrade fails).",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 65536,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\terr := http.ListenAndServe(address, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\twsConn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlogger.Sugar.Error(err)\n\t\treturn\n\t}\n\n\tconn := &Conn{\n\t\tCoonType: ConnTypeWS,\n\t\tWS:       wsConn,\n\t}\n\tDoConn(conn)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{} // use default options\n\nfunc StartWSServer(address string) {\n\thttp.HandleFunc(\"/ws\", wsHandler)\n\tlog.Println(\"Starting WebSocket server on\", address)\n\tif err := http.ListenAndServe(address, nil); err != nil {\n\t\tlog.Fatal(\"ListenAndServe:\", err)\n\t}\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(\"Failed to set websocket upgrade:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, message, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received: %s\", message)\n\t\terr = conn.WriteMessage(messageType, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error writing message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc main() {\n\tStartWSServer(\":8080\")\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a function that performs an HTTP request with custom headers and handles the response, including error handling and logging for debugging purposes.\n\nFunction Description: The function `realRequest` performs an HTTP request with custom headers, handles authentication, and processes the response. It includes validation of required headers, adds security tokens and user agents, computes signatures for authentication, and handles response errors. Debug logging is available for both requests and responses.\n\nInput:\n- `ctx` (context.Context): Context for the request, allowing cancellation and timeouts.\n- `project` (*LogProject): A struct containing project-specific details like base URL, access keys, and user agent.\n- `method` (string): HTTP method (e.g., \"GET\", \"POST\").\n- `uri` (string): The URI path for the request.\n- `headers` (map[string]string): A map of HTTP headers to include in the request.\n- `body` ([]byte): The request body as a byte slice.\n\nOutput:\n- (*http.Response, error): Returns the HTTP response and an error if any occurred during the request or response handling. The error is wrapped in custom error types for better context.",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"time\"\n\n\t\"github.com/go-kit/kit/log/level\"\n)\n\nvar (\n\tdefaultRequestTimeout = 60 * time.Second\n\tdefaultRetryTimeout   = 90 * time.Second\n\tdefaultHttpClient     = &http.Client{\n\t\tTimeout: defaultRequestTimeout,\n\t}\n)\n\nfunc realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif _, ok := headers[\"x-log-bodyrawsize\"]; !ok {\n\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'x-log-bodyrawsize' header\"))\n\t}\n\n\tbaseURL := project.getBaseURL()\n\theaders[\"Host\"] = baseURL\n\theaders[\"Date\"] = nowRFC1123()\n\theaders[\"x-log-apiversion\"] = version\n\theaders[\"x-log-signaturemethod\"] = signatureMethod\n\tif len(project.UserAgent) > 0 {\n\t\theaders[\"User-Agent\"] = project.UserAgent\n\t} else {\n\t\theaders[\"User-Agent\"] = DefaultLogUserAgent\n\t}\n\n\tif project.SecurityToken != \"\" {\n\t\theaders[\"x-acs-security-token\"] = project.SecurityToken\n\t}\n\n\tif body != nil {\n\t\tbodyMD5 := fmt.Sprintf(\"%X\", md5.Sum(body))\n\t\theaders[\"Content-MD5\"] = bodyMD5\n\t\tif _, ok := headers[\"Content-Type\"]; !ok {\n\t\t\treturn nil, NewClientError(fmt.Errorf(\"Can't find 'Content-Type' header\"))\n\t\t}\n\t}\n\n\tdigest, err := signature(project.AccessKeySecret, method, uri, headers)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tauth := fmt.Sprintf(\"SLS %v:%v\", project.AccessKeyID, digest)\n\theaders[\"Authorization\"] = auth\n\n\treader := bytes.NewReader(body)\n\turlStr := fmt.Sprintf(\"%s%s\", baseURL, uri)\n\treq, err := http.NewRequest(method, urlStr, reader)\n\tif err != nil {\n\t\treturn nil, NewClientError(err)\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Add(k, v)\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpRequest(req, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Request:\\n%v\", string(dump))\n\t}\n\n\tresp, err := project.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\terr := &Error{}\n\t\terr.HTTPCode = (int32)(resp.StatusCode)\n\t\tdefer resp.Body.Close()\n\t\tbuf, ioErr := ioutil.ReadAll(resp.Body)\n\t\tif ioErr != nil {\n\t\t\treturn nil, NewBadResponseError(ioErr.Error(), resp.Header, resp.StatusCode)\n\t\t}\n\t\tif jErr := json.Unmarshal(buf, err); jErr != nil {\n\t\t\treturn nil, NewBadResponseError(string(buf), resp.Header, resp.StatusCode)\n\t\t}\n\t\terr.RequestID = resp.Header.Get(RequestIDHeader)\n\t\treturn nil, err\n\t}\n\tif IsDebugLevelMatched(5) {\n\t\tdump, e := httputil.DumpResponse(resp, true)\n\t\tif e != nil {\n\t\t\tlevel.Info(Logger).Log(\"msg\", e)\n\t\t}\n\t\tlevel.Info(Logger).Log(\"msg\", \"HTTP Response:\\n%v\", string(dump))\n\t}\n\treturn resp, nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n)\n\ntype LogProject struct {\n\tBaseURL   string\n\tAccessKey string\n\tSecretKey string\n\tUserAgent string\n}\n\nfunc realRequest(ctx context.Context, project *LogProject, method, uri string, headers map[string]string, body []byte) (*http.Response, error) {\n\tif _, ok := headers[\"Content-Type\"]; !ok {\n\t\treturn nil, errors.New(\"missing Content-Type header\")\n\t}\n\tif _, ok := headers[\"Authorization\"]; !ok {\n\t\treturn nil, errors.New(\"missing Authorization header\")\n\t}\n\n\tclient := &http.Client{Timeout: 30 * time.Second}\n\treq, err := http.NewRequestWithContext(ctx, method, fmt.Sprintf(\"%s%s\", project.BaseURL, uri), bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tauthToken, err := computeSignature(project.AccessKey, project.SecretKey, method, uri, headers, body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to compute signature: %w\", err)\n\t}\n\treq.Header.Set(\"Authorization\", authToken)\n\n\tuserAgent := project.UserAgent\n\tif userAgent == \"\" {\n\t\tuserAgent = \"default-user-agent\"\n\t}\n\treq.Header.Set(\"User-Agent\", userAgent)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"HTTP request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"HTTP error: %d %s\", resp.StatusCode, resp.Status)\n\t}\n\n\treturn resp, nil\n}\n\nfunc computeSignature(accessKey, secretKey, method, uri string, headers map[string]string, body []byte) (string, error) {\n\tmessage := fmt.Sprintf(\"%s\\n%s\\n%s\", method, uri, string(body))\n\thmacSha256 := hmac.New(sha256.New, []byte(secretKey))\n\thmacSha256.Write([]byte(message))\n\tsignature := base64.StdEncoding.EncodeToString(hmacSha256.Sum(nil))\n\n\treturn fmt.Sprintf(\"Bearer %s:%s\", accessKey, signature), nil\n}\n```"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that starts a debug HTTP server with various endpoints for monitoring and debugging purposes, including standard debug endpoints (pprof, metrics, trace) and custom endpoints.\n\nFunction Description: The function `Start` initializes and launches an HTTP server with multiple debugging and monitoring endpoints. It sets up handlers for standard endpoints like pprof, expvar, trace, and metrics, along with any additional custom endpoints provided. The server runs on a predefined address and serves an index page with links to all available endpoints.\n\nInput: \n- `extra ...Endpoint`: Variadic parameter accepting zero or more custom endpoint objects. Each Endpoint should have:\n  - `Path`: string - The URL path for the endpoint\n  - `Name`: string - Display name for the endpoint\n  - `Handler`: http.Handler - The handler function for the endpoint\n\nOutput: None (the function runs indefinitely serving HTTP requests, or returns if no address is configured)\n\nNote: The function uses package-level variables (not shown in the reference code) including `addr` for the server address, and assumes the existence of handler functions like `expvarHandler`, `gcHandler`, and `freeOSMemoryHandler`.",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"strings\"\n\n\t\"golang.org/x/net/trace\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\nfunc Start(extra ...Endpoint) {\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tpp := http.NewServeMux()\n\tindex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(`\n\t\t\t\t<a href=\"vars\">Vars</a><br>\n\t\t\t\t<a href=\"debug/pprof/\">PProf</a><br>\n\t\t\t\t<a href=\"metrics\">Metrics</a><br>\n\t\t\t\t<a href=\"debug/requests\">Requests</a><br>\n\t\t\t\t<a href=\"debug/events\">Events</a><br>\n\t\t\t`))\n\t\tfor _, e := range extra {\n\t\t\tfmt.Fprintf(w, `<a href=\"%s\">%s</a><br>`, strings.TrimPrefix(e.Path, \"/\"), e.Name)\n\t\t}\n\t\tw.Write([]byte(`\n\t\t\t\t<br>\n\t\t\t\t<form method=\"post\" action=\"gc\" style=\"display: inline;\"><input type=\"submit\" value=\"GC\"></form>\n\t\t\t\t<form method=\"post\" action=\"freeosmemory\" style=\"display: inline;\"><input type=\"submit\" value=\"Free OS Memory\"></form>\n\t\t\t`))\n\t})\n\tpp.Handle(\"/\", index)\n\tpp.Handle(\"/debug\", index)\n\tpp.Handle(\"/vars\", http.HandlerFunc(expvarHandler))\n\tpp.Handle(\"/gc\", http.HandlerFunc(gcHandler))\n\tpp.Handle(\"/freeosmemory\", http.HandlerFunc(freeOSMemoryHandler))\n\tpp.Handle(\"/debug/pprof/\", http.HandlerFunc(pprof.Index))\n\tpp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\tpp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\tpp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\tpp.Handle(\"/debug/pprof/trace\", http.HandlerFunc(pprof.Trace))\n\tpp.Handle(\"/debug/requests\", http.HandlerFunc(trace.Traces))\n\tpp.Handle(\"/debug/events\", http.HandlerFunc(trace.Events))\n\tpp.Handle(\"/metrics\", promhttp.Handler())\n\tfor _, e := range extra {\n\t\tpp.Handle(e.Path, e.Handler)\n\t}\n\tlog.Println(\"warning: could not start debug HTTP server:\", http.ListenAndServe(addr, pp))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\nfunc Start(extra ...Endpoint) {\n    mux := http.NewServeMux()\n    \n    // Add standard endpoints\n    mux.HandleFunc(\"/debug/pprof/\", pprof.Index)\n    mux.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n    mux.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n    mux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n    mux.HandleFunc(\"/debug/pprof/trace\", pprof.Trace)\n    mux.HandleFunc(\"/metrics\", expvarHandler)\n    mux.HandleFunc(\"/gc\", gcHandler)\n    mux.HandleFunc(\"/freeosmemory\", freeOSMemoryHandler)\n    \n    // Add custom endpoints\n    for _, e := range extra {\n        mux.Handle(e.Path, e.Handler)\n    }\n    \n    // Serve index page\n    indexPage := `\n<!DOCTYPE html>\n<html>\n<head><title>Debug Server</title></head>\n<body>\n<h1>Debug Server</h1>\n<ul>\n<li><a href=\"/debug/pprof/\">pprof</a></li>\n<li><a href=\"/debug/pprof/cmdline\">cmdline</a></li>\n<li><a href=\"/debug/pprof/profile\">profile</a></li>\n<li><a href=\"/debug/pprof/symbol\">symbol</a></li>\n<li><a href=\"/debug/pprof/trace\">trace</a></li>\n<li><a href=\"/metrics\">metrics</a></li>\n<li><a href=\"/gc\">gc</a></li>\n<li><a href=\"/freeosmemory\">freeosmemory</a></li>\n`\n    for _, e := range extra {\n        indexPage += fmt.Sprintf(\"<li><a href=\\\"%s\\\">%s</a></li>\", e.Path, e.Name)\n    }\n    indexPage += \"</ul></body></html>\"\n    \n    mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        io.WriteString(w, indexPage)\n    })\n    \n    if addr != \"\" {\n        log.Println(\"Starting debug server at\", addr)\n        err := http.ListenAndServe(addr, mux)\n        if err != nil {\n            log.Fatalf(\"Failed to start server: %v\", err)\n        }\n    } else {\n        log.Println(\"No address configured, not starting server\")\n    }\n}\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement an HTTP worker struct that can process jobs by making HTTP requests with custom headers and handling the responses appropriately.\n\nStruct Description: HTTPWorker is a struct that handles HTTP job processing with configurable user agent and logging capabilities. It implements job execution by making POST requests to specified URLs with JSON payloads and processing the responses.\n\nFields:\nUserAgent: string - The User-Agent header value to be used in HTTP requests\nLogger: *zerolog.Logger - Logger instance for debug and error logging\n\nMethods:\nWork: (job jobqueue.Job) -> *jobqueue.Result - Processes a job by making an HTTP POST request to the job's URL with the job's payload as JSON. Handles request creation, execution, response reading, and result parsing. Returns a jobqueue.Result indicating the outcome of the job processing.\n\nInput Parameters:\n- job: jobqueue.Job - Contains the job details including URL, payload, and timeout\n\nOutput:\n- *jobqueue.Result - The result of the job processing, including status, code, and message",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fireworq/fireworq/jobqueue\"\n\t\"github.com/rs/zerolog\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *zerolog.Logger\n}\n\nfunc (worker *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\tclient := &http.Client{\n\t\tTimeout: time.Duration(job.Timeout()) * time.Second,\n\t}\n\treq, err := http.NewRequest(\n\t\t\"POST\",\n\t\tjob.URL(),\n\t\tstrings.NewReader(job.Payload()),\n\t)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Cannot create http request: %v\", err),\n\t\t}\n\t}\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\n\tuserAgent := worker.UserAgent\n\tif userAgent == \"\" {\n\t\tuserAgent = defaultUserAgent\n\t}\n\treq.Header.Add(\"User-Agent\", userAgent)\n\n\tresp, err := client.Do(req)\n\n\tworker.Logger.Debug().\n\t\tStr(\"action\", \"dispatch\").\n\t\tStr(\"worker\", \"HTTPWorker\").\n\t\tStr(\"url\", job.URL()).\n\t\tStr(\"payload\", job.Payload()).\n\t\tMsg(\"Dispatched via HTTP\")\n\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusInternalFailure,\n\t\t\tMessage: fmt.Sprintf(\"Request failed: %v\", err),\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Cannot read body: %v\", err),\n\t\t}\n\t}\n\n\tvar rslt jobqueue.Result\n\terr = json.Unmarshal(body, &rslt)\n\tif err != nil {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus: jobqueue.ResultStatusFailure,\n\t\t\tCode:   resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Cannot parse body as JSON: %v\\nOriginal response body:\\n%s\",\n\t\t\t\terr,\n\t\t\t\tstring(body),\n\t\t\t),\n\t\t}\n\t}\n\n\tif !rslt.IsValid() {\n\t\treturn &jobqueue.Result{\n\t\t\tStatus:  jobqueue.ResultStatusFailure,\n\t\t\tCode:    resp.StatusCode,\n\t\t\tMessage: fmt.Sprintf(\"Invalid result status: %s\\nOriginal response body:\\n%s\", rslt.Status, string(body)),\n\t\t}\n\t}\n\n\trslt.Code = resp.StatusCode\n\treturn &rslt\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog/log\"\n)\n\ntype HTTPWorker struct {\n\tUserAgent string\n\tLogger    *log.Logger\n}\n\nfunc (w *HTTPWorker) Work(job jobqueue.Job) *jobqueue.Result {\n\treq, err := http.NewRequest(\"POST\", job.URL, bytes.NewBuffer(job.Payload))\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"Failed to create HTTP request\")\n\t\treturn &jobqueue.Result{Status: \"error\", Code: 500, Message: \"Failed to create HTTP request\"}\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", w.UserAgent)\n\tclient := &http.Client{Timeout: time.Duration(job.Timeout) * time.Second}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"Failed to execute HTTP request\")\n\t\treturn &jobqueue.Result{Status: \"error\", Code: 500, Message: \"Failed to execute HTTP request\"}\n\t}\n\tdefer resp.Body.Close()\n\n\tvar responseBody map[string]interface{}\n\terr = json.NewDecoder(resp.Body).Decode(&responseBody)\n\tif err != nil {\n\t\tw.Logger.Error().Err(err).Msg(\"Failed to parse HTTP response body\")\n\t\treturn &jobqueue.Result{Status: \"error\", Code: 500, Message: \"Failed to parse HTTP response body\"}\n\t}\n\n\treturn &jobqueue.Result{\n\t\tStatus: \"success\",\n\t\tCode:   resp.StatusCode,\n\t\tMessage: responseBody[\"message\"].(string),\n\t}\n}\n```"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Go struct that represents local network services capable of running both a DNS server and an HTTP server concurrently. The DNS server should resolve a specific domain to a local IP address, while the HTTP server should serve predefined webpages.\n\nStruct Description: The `localNetworkServices` struct encapsulates functionality for running concurrent DNS and HTTP servers. The DNS server resolves a configured domain to a local IP address, and the HTTP server serves static web content mapped to specific paths.\n\nFields:\n- domain: string - The domain name that will be resolved by the DNS server\n- webpages: map[string]string - A map of URL paths to their corresponding webpage content\n- ipAddr: string - The local IP address that both servers will bind to\n\nMethods:\n- DNSServerIP() -> string - Returns the IP address of the DNS server\n- URL(subpath string) -> string - Constructs a full URL for a given subpath using the configured domain\n- Serve(ctx context.Context) -> error - Starts both DNS and HTTP servers concurrently using an errgroup, returns any error that occurs during execution\n\nAdditional Helper Struct:\n- dnsHandler: Implements the dns.Handler interface to handle DNS queries\n\nFields:\n- records: map[string]string - A map of domain names to their corresponding IP addresses\n\nMethods:\n- ServeDNS(w dns.ResponseWriter, r *dns.Msg) - Handles incoming DNS queries, responding with A records for configured domains",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"github.com/miekg/dns\"\n)\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (l localNetworkServices) DNSServerIP() string {\n\treturn l.ipAddr\n}\n\nfunc (l localNetworkServices) URL(subpath string) string {\n\treturn fmt.Sprintf(\"http://%s/%s\", l.domain, subpath)\n}\n\nfunc (l localNetworkServices) Serve(ctx context.Context) error {\n\terrGroup, _ := errgroup.WithContext(ctx)\n\n\terrGroup.Go(func() error {\n\t\tdnsSrv := &dns.Server{\n\t\t\tAddr: l.ipAddr + \":53\",\n\t\t\tNet:  \"udp\",\n\t\t\tHandler: &dnsHandler{\n\t\t\t\trecords: map[string]string{\n\t\t\t\t\tl.domain + \".\": l.ipAddr,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treturn dnsSrv.ListenAndServe()\n\t})\n\n\terrGroup.Go(func() error {\n\t\tfor path, contents := range l.webpages {\n\t\t\twebpage := contents\n\t\t\thttp.HandleFunc(\"/\"+path, func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tio.WriteString(w, webpage)\n\t\t\t})\n\t\t}\n\n\t\treturn http.ListenAndServe(l.ipAddr+\":80\", nil)\n\t})\n\n\treturn errGroup.Wait()\n}\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tmsg := dns.Msg{}\n\tmsg.SetReply(r)\n\tif r.Question[0].Qtype == dns.TypeA {\n\t\tmsg.Authoritative = true\n\t\tdomain := msg.Question[0].Name\n\t\taddress, ok := h.records[domain]\n\t\tif ok {\n\t\t\tmsg.Answer = append(msg.Answer, &dns.A{\n\t\t\t\tHdr: dns.RR_Header{Name: domain, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 3600},\n\t\t\t\tA:   net.ParseIP(address),\n\t\t\t})\n\t\t} else {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t}\n\n\tw.WriteMsg(&msg)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/miekg/dns\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype dnsHandler struct {\n\trecords map[string]string\n}\n\nfunc (h *dnsHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\tif r.Question[0].Qtype == dns.TypeA {\n\t\tip, exists := h.records[r.Question[0].Name]\n\t\tif exists {\n\t\t\tm.Answer = append(m.Answer, &dns.A{\n\t\t\t\tHdr: dns.RRHeader{Name: r.Question[0].Name, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 3600},\n\t\t\t\tA:   net.ParseIP(ip),\n\t\t\t})\n\t\t}\n\t}\n\tw.WriteMsg(m)\n}\n\ntype localNetworkServices struct {\n\tdomain   string\n\twebpages map[string]string\n\tipAddr   string\n}\n\nfunc (s *localNetworkServices) DNSServerIP() string {\n\treturn s.ipAddr\n}\n\nfunc (s *localNetworkServices) URL(subpath string) string {\n\treturn \"http://\" + s.domain + \"/\" + strings.TrimPrefix(subpath, \"/\")\n}\n\nfunc (s *localNetworkServices) Serve(ctx context.Context) error {\n\tgroup, ctx := errgroup.WithContext(ctx)\n\n\tserver := &http.Server{\n\t\tAddr:    s.ipAddr,\n\t\tHandler: http.FileServer(http.Dir(\"webpages\")),\n\t}\n\n\tgroup.Go(func() error {\n\t\treturn server.ListenAndServe()\n\t})\n\n\tresolver := dns.NewServeMux()\n\thandler := &dnsHandler{records: map[string]string{s.domain: s.ipAddr}}\n\tresolver.HandleFunc(\".\", handler.ServeDNS)\n\n\tdnsServer := &dns.Server{Addr: s.ipAddr, Net: \"udp\", Handler: resolver}\n\n\tgroup.Go(func() error {\n\t\treturn dnsServer.ListenAndServe()\n\t})\n\n\treturn group.Wait()\n}\n```"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Go HTTP server that handles requests with tracing capabilities using OpenCensus. The server should respond to requests with a simple message, perform tracing operations, and make an external HTTP request while propagating the trace context.\n\nFunction Description: The main function sets up an HTTP server with tracing middleware. It registers a root handler (\"/\") that responds with \"hello world\", creates trace spans, adds annotations/attributes, and makes an external HTTP request to example.com while maintaining trace context.\n\nInput: None (The function takes no direct input parameters. HTTP requests come through the server's routing mechanism.)\n\nOutput: None (The function doesn't return anything directly. It starts an HTTP server that listens indefinitely on port 50030 and handles incoming requests by writing responses to http.ResponseWriter.)",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go.opencensus.io/trace\"\n\t\"go.opencensus.io/plugin/ochttp\"\n)\n\nfunc main() {\n\tclient := &http.Client{Transport: &ochttp.Transport{}}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"hello world\")\n\n\t\t_, span := trace.StartSpan(req.Context(), \"child\")\n\t\tdefer span.End()\n\t\tspan.Annotate([]trace.Attribute{trace.StringAttribute(\"key\", \"value\")}, \"something happened\")\n\t\tspan.AddAttributes(trace.StringAttribute(\"hello\", \"world\"))\n\t\ttime.Sleep(time.Millisecond * 125)\n\n\t\tr, _ := http.NewRequest(\"GET\", \"https://example.com\", nil)\n\n\t\tr = r.WithContext(req.Context())\n\t\tresp, err := client.Do(r)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t} else {\n\t\t\tresp.Body.Close()\n\t\t}\n\t})\n\tlog.Fatal(http.ListenAndServe(\":50030\", &ochttp.Handler{}))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 103,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"go.opencensus.io/plugin/ochttp\"\n\t\"go.opencensus.io/trace\"\n)\n\nfunc main() {\n\ttrace.RegisterExporter(&trace.StackdriverExporter{})\n\ttrace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tctx, span := trace.StartSpan(r.Context(), \"example-span\")\n\t\tdefer span.End()\n\n\t\tspan.Annotate([]trace.Attribute{\n\t\t\ttrace.StringAttribute(\"method\", r.Method),\n\t\t\ttrace.StringAttribute(\"path\", r.URL.Path),\n\t\t}, \"request details\")\n\n\t\tresp, err := http.Get(ctx, \"https://example.com\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tbodyBytes, _ := ioutil.ReadAll(resp.Body)\n\t\tfmt.Fprintf(w, \"Hello World\\nExternal response: %s\", bodyBytes)\n\t})\n\n\tserver := &http.Server{\n\t\tAddr:    \":50030\",\n\t\tHandler: ochttp.NewHandler(mux, \"/\"),\n\t}\n\n\tfmt.Println(\"Starting server at :50030\")\n\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tpanic(err)\n\t}\n}\n```"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Implement a Certificate Authority (CA) service in Go using the Chi router for HTTP routing, supporting both secure and insecure servers, with background jobs and proper shutdown handling.\n\nStruct Description: The CA struct represents a Certificate Authority service that manages HTTP servers (secure and insecure), configuration, authentication, and background tasks.\n\nFields:\n\nauth: [*authority.Authority] - The authority component handling certificate operations  \nconfig: [*config.Config] - Configuration settings for the CA service  \nsrv: [*server.Server] - The main secure HTTP server  \ninsecureSrv: [*server.Server] - Optional insecure HTTP server for certain endpoints  \nmetricsSrv: [*server.Server] - Optional metrics server  \nopts: [*options] - Additional service options  \nrenewer: [*TLSRenewer] - Component handling TLS certificate renewal  \ncompactStop: [chan struct{}] - Channel for stopping the background compaction job  \n\nMethods:\n\nInit: [func(cfg *config.Config) (*CA, error)] - Initializes the CA service with configuration, sets up routers, and prepares servers  \nRun: [func() error] - Starts all servers and background jobs, handles graceful shutdown on errors  \nshouldServeInsecureServer: [func() bool] - (implied private method) Determines if insecure server should be started  \nrunCompactJob: [func()] - (implied private method) Runs background compaction task  \nStop: [func() error] - (implied method) Handles service shutdown and cleanup",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype CA struct {\n\tauth        *authority.Authority\n\tconfig      *config.Config\n\tsrv         *server.Server\n\tinsecureSrv *server.Server\n\tmetricsSrv  *server.Server\n\topts        *options\n\trenewer     *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc (ca *CA) Init(cfg *config.Config) (*CA, error) {\n\tmux := chi.NewRouter()\n\thandler := http.Handler(mux)\n\n\tinsecureMux := chi.NewRouter()\n\tinsecureHandler := http.Handler(insecureMux)\n\n\tmux.Use(middleware.GetHead)\n\tinsecureMux.Use(middleware.GetHead)\n\n\tapi.Route(mux)\n\tmux.Route(\"/1.0\", func(r chi.Router) {\n\t\tapi.Route(r)\n\t})\n\n\tinsecureMux.Get(\"/crl\", api.CRL)\n\tinsecureMux.Get(\"/1.0/crl\", api.CRL)\n\n\tbaseContext := buildContext(auth, scepAuthority, acmeDB, acmeLinker)\n\n\tca.srv = server.New(cfg.Address, handler, tlsConfig)\n\tca.srv.BaseContext = func(net.Listener) context.Context {\n\t\treturn baseContext\n\t}\n\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = server.New(cfg.InsecureAddress, insecureHandler, nil)\n\t\tca.insecureSrv.BaseContext = func(net.Listener) context.Context {\n\t\t\treturn baseContext\n\t\t}\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\tvar wg sync.WaitGroup\n\terrs := make(chan error, 1)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tca.runCompactJob()\n\t}()\n\n\tif ca.insecureSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.insecureSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\tif ca.metricsSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.metricsSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terrs <- ca.srv.ListenAndServe()\n\t}()\n\n\terr := <-errs\n\n\tif !errors.Is(err, http.ErrServerClosed) {\n\t\tlog.Println(\"shutting down due to startup error ...\")\n\t\tif stopErr := ca.Stop(); stopErr != nil {\n\t\t\terr = fmt.Errorf(\"failed stopping CA after error occurred: %w: %w\", err, stopErr)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"stopped CA after error occurred: %w\", err)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn err\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 108,
    "wrong_result": "```go\npackage ca\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/yourusername/authority\"\n\t\"github.com/yourusername/config\"\n\t\"github.com/yourusername/server\"\n\t\"github.com/yourusername/options\"\n)\n\ntype CA struct {\n\tauth         *authority.Authority\n\tconfig       *config.Config\n\tsrv          *server.Server\n\tinsecureSrv  *server.Server\n\tmetricsSrv   *server.Server\n\topts         *options.Options\n\trenewer      *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc Init(cfg *config.Config) (*CA, error) {\n\tca := &CA{\n\t\tconfig:    cfg,\n\t\tauth:      authority.NewAuthority(),\n\t\topts:      options.NewOptions(),\n\t\tcompactStop: make(chan struct{}),\n\t}\n\n\tr := chi.NewRouter()\n\t// Setup routes here...\n\n\tca.srv = server.NewServer(\"https://\"+cfg.SecureAddress, r)\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = server.NewServer(\"http://\"+cfg.InsecureAddress, r)\n\t}\n\tif cfg.MetricsEnabled {\n\t\tca.metricsSrv = server.NewServer(\"http://\"+cfg.MetricsAddress, chi.NewRouter())\n\t\t// Setup metrics routes here...\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\tgo ca.runCompactJob()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tif err := ca.srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"Secure server: %v\", err)\n\t\t}\n\t}()\n\tif ca.insecureSrv != nil {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif err := ca.insecureSrv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\t\tlog.Fatalf(\"Insecure server: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\tif ca.metricsSrv != nil {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif err := ca.metricsSrv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\t\tlog.Fatalf(\"Metrics server: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tsignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)\n\t<-signalChan\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := ca.srv.Shutdown(ctx); err != nil {\n\t\tlog.Fatalf(\"Error shutting down secure server: %v\", err)\n\t}\n\tif ca.insecureSrv != nil {\n\t\tif err := ca.insecureSrv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatalf(\"Error shutting down insecure server: %v\", err)\n\t\t}\n\t}\n\tif ca.metricsSrv != nil {\n\t\tif err := ca.metricsSrv.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatalf(\"Error shutting down metrics server: %v\", err)\n\t\t}\n\t}\n\n\tclose(ca.compactStop)\n\twg.Wait()\n\treturn nil\n}\n\nfunc (ca *CA) shouldServeInsecureServer() bool {\n\t// Determine if insecure server should be started based on config\n\treturn ca.config.InsecureEnabled\n}\n\nfunc (ca *CA) runCompactJob() {\n\tticker := time.NewTicker(24 * time.Hour)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// Perform compaction task here\n\t\t\tlog.Println(\"Running compaction job\")\n\t\tcase <-ca.compactStop:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (ca *CA) Stop() error {\n\tclose(ca.compactStop)\n\treturn ca.srv.Shutdown(context.Background())\n}\n```"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that performs HTTP requests with customizable options including TLS configuration, request method, headers, and payload.\n\nFunction Description: The function DoRequest executes HTTP requests with various configurable options. It handles TLS configuration (including insecure mode), sets request headers, processes different HTTP methods, and manages response reading. The function is designed to be flexible for different API interaction scenarios while maintaining security and error handling.\n\nInput:\n- opt (EtcdRequestOption struct) - Configuration options for the HTTP request containing:\n  - Endpoint (string): Base URL for the request\n  - Api (string): API endpoint path\n  - PostData (string): Request payload data\n  - TlsConfig (*tls.Config): TLS configuration (nil for insecure)\n  - Method (string): HTTP method (GET, POST, etc.)\n  - Silent (bool): Unused in current implementation\n\nOutput:\n- (string) - Response body content as string\n- (error) - Error object if request fails, nil on success",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/cdk-team/CDK/pkg/errors\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint  string\n\tApi       string\n\tPostData  string\n\tTlsConfig *tls.Config\n\tMethod    string\n\tSilent    bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\tif opt.TlsConfig == nil || len(opt.TlsConfig.Certificates) == 0 || opt.TlsConfig.RootCAs == nil {\n\t\topt.TlsConfig = &tls.Config{InsecureSkipVerify: true}\n\t}\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: opt.TlsConfig,\n\t\t},\n\t\tTimeout: time.Duration(5) * time.Second,\n\t}\n\n\trequest, err := http.NewRequest(opt.Method, opt.Endpoint+opt.Api, bytes.NewBuffer([]byte(opt.PostData)))\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found while generate post request in net.http .\"}\n\t}\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := client.Do(request)\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t} else if err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\tcontent, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", &errors.CDKRuntimeError{Err: err, CustomMsg: \"err found in post request.\"}\n\t}\n\n\treturn string(content), nil\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 102,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype EtcdRequestOption struct {\n\tEndpoint   string\n\tApi        string\n\tPostData   string\n\tTlsConfig  *tls.Config\n\tMethod     string\n\tSilent     bool\n}\n\nfunc DoRequest(opt EtcdRequestOption) (string, error) {\n\turl := fmt.Sprintf(\"%s/%s\", opt.Endpoint, opt.Api)\n\treq, err := http.NewRequest(opt.Method, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif opt.PostData != \"\" {\n\t\treq.Body = ioutil.NopCloser(strings.NewReader(opt.PostData))\n\t}\n\tif opt.TlsConfig != nil {\n\t\ttr := &http.Transport{TLSClientConfig: opt.TlsConfig}\n\t\tclient := &http.Client{Transport: tr}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn string(body), nil\n\t} else {\n\t\tresp, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn string(body), nil\n\t}\n}\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create an HTTP server using the Echo framework in Go that serves static files from an embedded filesystem using the go.rice package.\n\nFunction Description: The main function initializes an Echo web server, sets up route handlers for serving static files from an embedded directory (\"app\"), and starts the server on port 1323. The static files are served under the root path (\"/\") and a static prefix path (\"/static/*\").\n\nInput: None (The function takes no explicit parameters)\n\nOutput: None (The function doesn't return anything explicitly but starts an HTTP server that runs indefinitely until interrupted)\n\nNote: The reference code shows the complete implementation at the package level (main function) rather than as an isolated function or struct. The instruction follows the function-level format as the code primarily demonstrates functional behavior rather than object-oriented structure.",
    "Canonical_solution": "import (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/labstack/echo\"\n)\nfunc main() {\n\te := echo.New()\n\tassetHandler := http.FileServer(rice.MustFindBox(\"app\").HTTPBox())\n\te.GET(\"/\", echo.WrapHandler(assetHandler))\n\te.GET(\"/static/*\", echo.WrapHandler(http.StripPrefix(\"/static/\", assetHandler)))\n\te.Logger.Fatal(e.Start(\":1323\"))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 106,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/gobuffalo/packr/v2\"\n)\n\nfunc main() {\n\te := echo.New()\n\n\tbox := packr.New(\"app\", \"./app\")\n\te.Static(\"/\", box)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n```"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a Go struct that implements an HTTP server using the Echo framework, supporting both HTTP/2 and HTTPS configurations, with customizable timeouts and root path handling.\n\nStruct Description: The Api struct represents an HTTP server configuration with support for TLS, HTTP/2, and customizable timeouts. It provides methods to start and stop the server gracefully.\n\nFields:\nport: int - The port number on which the server will listen\nbindIp: string - The IP address to bind the server to\ntlsCertFile: string - Path to TLS certificate file (empty for non-HTTPS)\ntlsKeyFile: string - Path to TLS private key file (empty for non-HTTPS)\ntimeout: time.Duration - Server timeout duration for read/write operations\nrootPath: string - The root path for the server's default route\nsrv: *echo.Echo - The Echo server instance\n\nMethods:\nStart: () -> error - Initializes and starts the HTTP server in a goroutine, supporting both TLS and HTTP/2 configurations. Returns nil on successful startup.\nStop: (ctx context.Context) -> error - Gracefully shuts down the server using the provided context. Returns any error that occurs during shutdown.",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype Api struct {\n\tport        int\n\tbindIp      string\n\ttlsCertFile string\n\ttlsKeyFile  string\n\ttimeout     time.Duration\n\trootPath    string\n\tsrv         *echo.Echo\n}\n\nfunc (a *Api) Start() error {\n\ta.srv = echo.New()\n\ta.srv.HideBanner = true\n\ta.srv.HidePort = true\n\ta.srv.Server.ReadTimeout = a.timeout\n\ta.srv.Server.IdleTimeout = a.timeout\n\ta.srv.Server.WriteTimeout = a.timeout + a.timeout\n\n\ta.srv.GET(\n\t\ta.rootPath,\n\t\tfunc(c echo.Context) error {\n\t\t\treturn c.HTML(http.StatusOK, `Hey, Gotenberg has no UI, it's an API. Head to the <a href=\"https://gotenberg.dev\">documentation</a> to learn how to interact with it \ud83d\ude80`)\n\t\t},\n\t)\n\n\tgo func() {\n\t\tvar err error\n\t\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\t\terr = a.srv.StartTLS(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), a.tlsCertFile, a.tlsKeyFile)\n\t\t} else {\n\t\t\tserver := &http2.Server{}\n\t\t\terr = a.srv.StartH2CServer(fmt.Sprintf(\"%s:%d\", a.bindIp, a.port), server)\n\t\t}\n\t\tif !errors.Is(err, http.ErrServerClosed) {\n\t\t\ta.logger.Fatal(err.Error())\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\treturn a.srv.Shutdown(ctx)\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 106,
    "wrong_result": "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype Api struct {\n\tport         int\n\tbindIp       string\n\ttlsCertFile  string\n\ttlsKeyFile   string\n\ttimeout      time.Duration\n\trootPath     string\n\tsrv          *echo.Echo\n}\n\nfunc NewApi(port int, bindIp string, tlsCertFile, tlsKeyFile string, timeout time.Duration, rootPath string) *Api {\n\treturn &Api{\n\t\tport:         port,\n\t\tbindIp:       bindIp,\n\t\ttlsCertFile:  tlsCertFile,\n\t\ttlsKeyFile:   tlsKeyFile,\n\t\ttimeout:      timeout,\n\t\trootPath:     rootPath,\n\t\tsrv:          echo.New(),\n\t}\n}\n\nfunc (a *Api) Start() error {\n\ta.srv.Server.Addr = net.JoinHostPort(a.bindIp, strconv.Itoa(a.port))\n\ta.srv.Server.ReadTimeout = a.timeout\n\ta.srv.Server.WriteTimeout = a.timeout\n\n\tif a.tlsCertFile != \"\" && a.tlsKeyFile != \"\" {\n\t\tgo func() {\n\t\t\tif err := a.srv.StartTLS(\":8443\", a.tlsCertFile, a.tlsKeyFile); err != http.ErrServerClosed {\n\t\t\t\tlog.Fatalf(\"HTTP server failed: %v\", err)\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tgo func() {\n\t\t\tif err := a.srv.Start(\":8080\"); err != http.ErrServerClosed {\n\t\t\t\tlog.Fatalf(\"HTTP server failed: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn nil\n}\n\nfunc (a *Api) Stop(ctx context.Context) error {\n\treturn a.srv.Shutdown(ctx)\n}\n```"
  }
]