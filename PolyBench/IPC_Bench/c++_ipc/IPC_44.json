{
  "Task_id": 44,
  "Github_ID": "2345629",
  "Github_Project_Name": "websocketpp",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "Websocket Server based on WebSocket++ in C++",
  "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
  "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
  "FSMID_for_test": 154,
  "Code_level": "Class-level"
}