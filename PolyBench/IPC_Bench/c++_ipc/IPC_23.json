{
  "Task_id": 23,
  "Github_ID": "433303514",
  "Github_Project_Name": "30dayMakeCppServer",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server based on socket+inet in C++",
  "Instruction": "Task Description: Create a TCP server in C++ that listens for incoming connections, receives data from clients, and echoes the data back to the clients. The server should handle one client at a time and properly clean up resources when the connection is terminated.\n\nFunction Description: The function `create_tcp_server` establishes a TCP server that binds to a specified IP address and port, listens for incoming connections, and handles client communication. It reads data from the client and sends the same data back (echo). The server runs until the client disconnects or an error occurs.\n\nInput: \n- `ip`: [const char*] - The IP address the server should bind to (e.g., \"127.0.0.1\" for localhost).\n- `port`: [int] - The port number the server should listen on (e.g., 8080).\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any step fails (socket creation, binding, listening, or accepting connections).",
  "Canonical_solution": "#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(bind(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    if(listen(sockfd, SOMAXCONN) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    bzero(&clnt_addr, sizeof(clnt_addr));\n\n    int clnt_sockfd = accept(sockfd, (sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sockfd == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));\n    \n    char buf[1024];\n    while (true) {\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(clnt_sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from client fd %d: %s\\n\", clnt_sockfd, buf);\n            write(clnt_sockfd, buf, sizeof(buf));\n        } else if(read_bytes == 0){\n            printf(\"client fd %d disconnected\\n\", clnt_sockfd);\n            close(clnt_sockfd);\n            break;\n        } else if(read_bytes == -1){\n            close(clnt_sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n    return 0;\n}",
  "FSMID_for_test": 148,
  "Code_level": "Function-level"
}