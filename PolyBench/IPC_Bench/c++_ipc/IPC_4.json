{
  "Task_id": 4,
  "Github_ID": "305539431",
  "Github_Project_Name": "WechatExporter",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "Http based on libcurl in C++",
  "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
  "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
  "FSMID_for_test": 146,
  "Code_level": "Class-level"
}