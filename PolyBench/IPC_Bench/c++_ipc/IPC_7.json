{
  "Task_id": 7,
  "Github_ID": "7589945",
  "Github_Project_Name": "asio",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client based on Boost.Asio in C++",
  "Instruction": "Task Description: Create a TCP client class using Boost.Asio that handles asynchronous communication with a chat server, including reading from standard input and writing to standard output.\n\nClass Description: The posix_chat_client class implements an asynchronous TCP client for a chat application. It manages socket connections, handles message reading/writing, and processes user input/output asynchronously using Boost.Asio.\n\nAttributes:\n- socket_: [tcp::socket] - The TCP socket for communication with the server\n- input_: [posix::stream_descriptor] - Handles asynchronous reading from standard input\n- output_: [posix::stream_descriptor] - Handles asynchronous writing to standard output\n- read_msg_: [chat_message] - Stores the message being read from the server\n- write_msg_: [chat_message] - Stores the message to be written to the server\n- input_buffer_: [boost::asio::streambuf] - Buffer for storing input data\n\nMethods:\n- Constructor: [posix_chat_client]([boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints]) -> [void] - Initializes the client with IO context and server endpoints\n- do_connect: [do_connect]([const tcp::resolver::results_type& endpoints]) -> [void] - Asynchronously connects to the server endpoints\n- do_read_header: [do_read_header]() -> [void] - Asynchronously reads the message header from the server\n- do_read_body: [do_read_body]() -> [void] - Asynchronously reads the message body from the server after header is processed\n- do_write_output: [do_write_output]() -> [void] - Asynchronously writes received messages to standard output\n- do_read_input: [do_read_input]() -> [void] - Asynchronously reads input from standard input\n- do_write_message: [do_write_message]() -> [void] - Asynchronously writes the composed message to the server\n- close: [close]() -> [void] - Closes all connections and cleans up resources",
  "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\n#include \"chat_message.hpp\"\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_(chat_message::max_body_length)\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    static char eol[] = { '\\n' };\n    std::array<boost::asio::const_buffer, 2> buffers = {{\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      boost::asio::buffer(eol) }};\n    boost::asio::async_write(output_, buffers,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            write_msg_.body_length(length - 1);\n            input_buffer_.sgetn(write_msg_.body(), length - 1);\n            input_buffer_.consume(1);\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else if (ec == boost::asio::error::not_found)\n          {\n            write_msg_.body_length(input_buffer_.size());\n            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
  "FSMID_for_test": 151,
  "Code_level": "Class-level"
}