{
  "Task_id": 40,
  "Github_ID": "2345629",
  "Github_Project_Name": "websocketpp",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "Websocket Server based on WebSocket++ in C++",
  "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
  "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
  "FSMID_for_test": 154,
  "Code_level": "Class-level"
}