{
  "Task_id": 27,
  "Github_ID": "58727800",
  "Github_Project_Name": "phxpaxos",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "UDP Server based on socket+inet in C++",
  "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
  "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
  "FSMID_for_test": 152,
  "Code_level": "Class-level"
}