{
  "Task_id": 39,
  "Github_ID": "7589945",
  "Github_Project_Name": "asio",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "UDP based on Boost.Asio in C++",
  "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
  "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
  "FSMID_for_test": 153,
  "Code_level": "Class-level"
}