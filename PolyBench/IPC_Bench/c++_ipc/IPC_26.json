{
  "Task_id": 26,
  "Github_ID": "139059389",
  "Github_Project_Name": "oomd",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server based on socket+inet in C++",
  "Instruction": "Task Description: Implement a TCP server using UNIX domain sockets for inter-process communication that manages and provides access to statistics data. The server should handle multiple client connections concurrently, process different types of requests (get, reset, etc.), and maintain thread safety.\n\nClass Description: The Stats class implements a TCP server using UNIX domain sockets to manage and provide access to statistics data. It handles client connections, processes requests, and maintains thread safety for concurrent access to statistics.\n\nAttributes:\n- stats_socket_path_: std::string - Path to the UNIX domain socket file\n- sockfd_: int - File descriptor for the server socket\n- serv_addr_: sockaddr_un - Server address structure\n- stats_thread_: std::thread - Thread for running the socket server\n- statsThreadRunning_: std::atomic<bool> - Flag to control the server thread's execution\n- stats_mutex_: std::mutex - Mutex for protecting access to statistics data\n- thread_mutex_: std::mutex - Mutex for protecting thread count\n- thread_exited_: std::condition_variable - Condition variable for thread synchronization\n- thread_count_: int - Count of active threads\n- stats_: std::unordered_map<std::string, int> - Container for storing statistics data\n\nMethods:\n- Stats(const std::string& stats_socket_path) -> None - Constructor that initializes the socket server\n- ~Stats() -> None - Destructor that cleans up resources\n- get(const std::string& stats_socket_path) -> Stats& - Static method to get the singleton instance\n- get_for_unittest(const std::string& stats_socket_path) -> std::unique_ptr<Stats> - Static method to get an instance for unit testing\n- init(const std::string& stats_socket_path) -> bool - Static method to initialize the singleton\n- isInit() -> bool - Static method to check if the singleton is initialized\n- getAll() -> std::unordered_map<std::string, int> - Returns all statistics data\n- increment(const std::string& key, int val) -> int - Increments a statistic value\n- set(const std::string& key, int val) -> int - Sets a statistic value\n- reset() -> int - Resets all statistics\n- startSocket() -> bool - Starts the socket server\n- runSocket() -> void - Main server loop that accepts connections\n- processMsg(int sockfd) -> void - Processes a client message\n- isInitInternal() -> bool& - Internal static method for initialization status",
  "Canonical_solution": "#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <json/value.h>\n\nnamespace Oomd {\n\nclass Stats {\npublic:\n  Stats(const std::string& stats_socket_path);\n  ~Stats();\n\n  static Stats& get(const std::string& stats_socket_path);\n  static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n  static bool init(const std::string& stats_socket_path);\n  static bool isInit();\n\n  std::unordered_map<std::string, int> getAll();\n  int increment(const std::string& key, int val);\n  int set(const std::string& key, int val);\n  int reset();\n\nprivate:\n  bool startSocket();\n  void runSocket();\n  void processMsg(int sockfd);\n  static bool& isInitInternal();\n\n  std::string stats_socket_path_;\n  int sockfd_{-1};\n  sockaddr_un serv_addr_{};\n  std::thread stats_thread_;\n  std::atomic<bool> statsThreadRunning_{true};\n  std::mutex stats_mutex_;\n  std::unordered_map<std::string, int> stats_;\n  std::mutex thread_mutex_;\n  std::condition_variable thread_exited_;\n  int thread_count_{0};\n};\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path) {\n  if (!this->startSocket()) {\n    throw std::runtime_error(\"Socket thread failed to start\");\n  }\n}\n\nStats::~Stats() {\n  std::array<char, 64> err_buf = {};\n  statsThreadRunning_ = false;\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  if (!thread_exited_.wait_for(lock, std::chrono::seconds(5), [this] {\n        return this->thread_count_ == 0;\n      })) {\n    OCHECK(false);\n  }\n  lock.unlock();\n  if (stats_thread_.joinable()) {\n    stats_thread_.join();\n  }\n  if (::unlink(serv_addr_.sun_path) < 0) {\n    OLOG << \"Closing stats error: unlinking socket path: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  if (::close(sockfd_) < 0) {\n    OLOG << \"Closing stats error: closing stats socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n}\n\nbool Stats::startSocket() {\n  std::array<char, 64> err_buf = {};\n\n  sockfd_ = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sockfd_ < 0) {\n    OLOG << \"Error creating socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size() - 1);\n    return false;\n  }\n  ::memset(&serv_addr_, '\\0', sizeof(serv_addr_));\n  serv_addr_.sun_family = AF_UNIX;\n  ::strcpy(serv_addr_.sun_path, stats_socket_path_.c_str());\n  if (::unlink(serv_addr_.sun_path) < 0 && errno != ENOENT) {\n    OLOG << \"Pre-unlinking of socket path failed. \" << serv_addr_.sun_path\n         << \". Errno: \" << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) < 0) {\n    OLOG << \"Error binding stats collection socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::listen(sockfd_, 5) < 0) {\n    OLOG << \"Error listening at socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  stats_thread_ = std::thread([this] { this->runSocket(); });\n  return true;\n}\n\nvoid Stats::runSocket() {\n  sockaddr_un cli_addr;\n  socklen_t clilen = sizeof(cli_addr);\n  std::array<char, 64> err_buf = {};\n  while (statsThreadRunning_) {\n    int sockfd = ::accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n    if (sockfd < 0) {\n      OLOG << \"Stats server error: accepting connection: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      continue;\n    }\n    std::unique_lock<std::mutex> lock(thread_mutex_);\n    ++thread_count_;\n    std::thread msg_thread_ =\n        std::thread([this, sockfd] { this->processMsg(sockfd); });\n    msg_thread_.detach();\n    lock.unlock();\n    thread_exited_.notify_one();\n  }\n}\n\nvoid Stats::processMsg(int sockfd) {\n  std::array<char, 64> err_buf = {};\n  OOMD_SCOPE_EXIT {\n    if (::close(sockfd) < 0) {\n      OLOG << \"Stats server error: closing file descriptor: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    }\n  };\n  char mode = 'a';\n  char byte_buf;\n  int num_read = 0;\n  for (; num_read < 32; num_read++) {\n    int res = ::read(sockfd, &byte_buf, 1);\n    if (res < 0) {\n      OLOG << \"Stats server error: reading from socket: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      return;\n    } else if (res == 0) {\n      break;\n    }\n    if (byte_buf == '\\n' || byte_buf == '\\0') {\n      break;\n    }\n    if (num_read == 0) {\n      mode = byte_buf;\n    }\n  }\n\n  Json::Value root;\n  root[\"error\"] = 0;\n  Json::Value body(Json::objectValue);\n  switch (mode) {\n    case 'g':\n      for (auto const& pair : getAll()) {\n        body[pair.first] = pair.second;\n      }\n      break;\n    case 'r':\n      Stats::reset();\n      break;\n    case '0':\n      break;\n    default:\n      root[\"error\"] = 1;\n      OLOG << \"Stats server error: received unknown request: \" << mode;\n  }\n  root[\"body\"] = body;\n  std::string ret = root.toStyledString();\n  if (Util::writeFull(sockfd, ret.c_str(), strlen(ret.c_str())) < 0) {\n    OLOG << \"Stats server error: writing to socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  thread_count_--;\n  lock.unlock();\n  thread_exited_.notify_one();\n}\n\n} // namespace Oomd",
  "FSMID_for_test": 148,
  "Code_level": "Class-level"
}