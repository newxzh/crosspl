{
  "Task_id": 35,
  "Github_ID": "767152575",
  "Github_Project_Name": "citra",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "UDP based on Boost.Asio in C++",
  "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
  "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
  "FSMID_for_test": 153,
  "Code_level": "Class-level"
}