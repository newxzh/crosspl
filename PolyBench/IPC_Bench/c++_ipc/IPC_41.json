{
  "Task_id": 41,
  "Github_ID": "2345629",
  "Github_Project_Name": "websocketpp",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "Websocket Server based on WebSocket++ in C++",
  "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
  "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
  "FSMID_for_test": 154,
  "Code_level": "Class-level"
}