{
  "Task_id": 9,
  "Github_ID": "7589945",
  "Github_Project_Name": "asio",
  "Programming_Language": "C++",
  "suffix": ".cpp",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client based on Boost.Asio in C++",
  "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
  "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
  "FSMID_for_test": 151,
  "Code_level": "Class-level"
}