{
  "Task_id": 251,
  "Github_ID": "86213415",
  "Github_Project_Name": "AriaNg-Native",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on browser native API in JavaScript",
  "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections, handles message queuing, automatic reconnection, and provides event callbacks for connection status changes and incoming messages.\n\nClass Description: The WebSocketClient class provides a robust WebSocket client implementation with connection management, message queuing, automatic reconnection capabilities, and event callbacks. It maintains connection state and handles various WebSocket events while providing methods for sending messages and checking connection status.\n\nAttributes:\n- wsClient: [WebSocket] - The underlying WebSocket connection instance\n- sendQueue: [Array] - Queue of messages to be sent when connection is available\n- pendingReconnect: [Timeout] - Timer handle for pending reconnection attempts\n\nMethods:\n- constructor() -> [void] - Initializes a new WebSocketClient instance\n- fireSendQueue() -> [void] - Sends all queued messages when connection is open\n- clearSendQueue() -> [void] - Clears all queued messages and rejects their promises\n- planToReconnect(rpcUrl: String, options: Object) -> [void] - Schedules a reconnection attempt\n- init() -> [void] - Cleans up existing connection and message queue\n- connect(rpcUrl: String, options: Object, onOpenCallback: Function, onCloseCallback: Function, onMessageCallback: Function) -> [void] - Establishes new WebSocket connection with event handlers\n- reconnect(rpcUrl: String, options: Object) -> [void] - Re-establishes connection using existing callbacks\n- send(requestContext: Object) -> [Promise] - Queues a message for sending and returns a promise\n- getReadyState() -> [Number|null] - Returns current WebSocket readyState or null if no connection",
  "Canonical_solution": "const WebSocket = require('ws');\nconst ipcRender = require('../ipc/render-proecss');\n\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        while (this.sendQueue.length && this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            const request = this.sendQueue.shift();\n            this.wsClient.send(request.data);\n            request.deferred.resolve();\n        }\n    }\n\n    clearSendQueue() {\n        for (let i = this.sendQueue.length - 1; i >= 0; i--) {\n            this.sendQueue[i].deferred.reject();\n            this.sendQueue.splice(i, 1);\n        }\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] another reconnection is pending');\n            return;\n        }\n\n        this.pendingReconnect = setTimeout(() => {\n            if (this.wsClient == null) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket is null');\n                this.pendingReconnect = null;\n                return;\n            }\n\n            if (this.wsClient.readyState === WebSocket.CONNECTING || this.wsClient.readyState === WebSocket.OPEN) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket current state is already ' + this.wsClient.readyState);\n                this.pendingReconnect = null;\n                return;\n            }\n\n            this.reconnect(rpcUrl, options);\n            this.pendingReconnect = null;\n        }, options.reconnectInterval);\n\n        ipcRender.notifyRenderProcessLogDebug('[lib/websocket.planToReconnect] next reconnection is pending in ' + options.reconnectInterval + \"ms\");\n    }\n\n    init() {\n        if (this.sendQueue.length) {\n            this.clearSendQueue();\n        }\n\n        if (this.wsClient) {\n            this.wsClient.onopen = null;\n            this.wsClient.onclose = null;\n            this.wsClient.onmessage = null;\n            this.wsClient.terminate();\n            this.wsClient = null;\n        }\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n\n        this.wsClient.onopen = () => {\n            onOpenCallback({\n                client: this.wsClient,\n                url: rpcUrl\n            });\n            this.fireSendQueue();\n        };\n\n        this.wsClient.onclose = () => {\n            let autoReconnect = false;\n\n            if (options.reconnectInterval > 0) {\n                autoReconnect = true;\n                this.planToReconnect(rpcUrl, options);\n            }\n\n            onCloseCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                autoReconnect: autoReconnect\n            });\n        };\n\n        this.wsClient.onmessage = (event) => {\n            let message = null;\n\n            if (event) {\n                message = event.data;\n            }\n\n            onMessageCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                success: true,\n                message: message\n            });\n        };\n\n        this.wsClient.onerror = (event) => {\n            // Do Nothing\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        if (!this.wsClient) {\n            return;\n        }\n\n        const onOpenFn = this.wsClient.onopen;\n        const onCloseFn = this.wsClient.onclose;\n        const onMessageFn = this.wsClient.onmessage;\n        const onErrorFn = this.wsClient.onerror;\n\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n        this.wsClient.onopen = onOpenFn;\n        this.wsClient.onclose = onCloseFn;\n        this.wsClient.onmessage = onMessageFn;\n        this.wsClient.onerror = onErrorFn;\n    }\n\n    send(requestContext) {\n        const deferred = {};\n        deferred.promise = new Promise((resolve, reject) => {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n\n        this.sendQueue.push({\n            url: requestContext.url,\n            data: requestContext.data,\n            deferred: deferred\n        });\n\n        if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            this.fireSendQueue();\n        }\n\n        return deferred.promise;\n    }\n\n    getReadyState() {\n        if (!this.wsClient) {\n            return null;\n        }\n\n        return this.wsClient.readyState;\n    }\n}",
  "FSMID_for_test": 89,
  "Code_level": "Class-level"
}