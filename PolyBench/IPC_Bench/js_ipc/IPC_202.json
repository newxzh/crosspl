{
  "Task_id": 202,
  "Github_ID": "10020773",
  "Github_Project_Name": "gekko",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on browser native API in JavaScript",
  "Instruction": "Task Description: Implement a ReconnectingWebSocket class in JavaScript that provides a WebSocket client with automatic reconnection capabilities, customizable reconnection strategies, and event handling for connection states, messages, and errors.\n\nClass Description: The ReconnectingWebSocket class extends basic WebSocket functionality by automatically reconnecting when the connection is lost, with configurable reconnection intervals and exponential backoff. It provides event handlers for connection states (open, close, connecting), message reception, and errors.\n\nAttributes:\n- debug: Boolean - Enables debug logging when true\n- automaticOpen: Boolean - Automatically opens connection when instantiated if true\n- reconnectInterval: Number - Initial delay before reconnection attempt (ms)\n- maxReconnectInterval: Number - Maximum delay between reconnection attempts (ms)\n- reconnectDecay: Number - Multiplier for increasing reconnect delay\n- timeoutInterval: Number - Connection timeout duration (ms)\n- url: String - WebSocket server URL\n- reconnectAttempts: Number - Count of reconnection attempts\n- readyState: Number - Current connection state (matching WebSocket constants)\n- protocol: String|null - Selected subprotocol\n\nMethods:\n- constructor(url, protocols, options) -> ReconnectingWebSocket - Initializes the WebSocket connection with specified URL, optional subprotocols, and configuration options\n- addEventListener(type, listener) -> void - Adds event listener for WebSocket events\n- removeEventListener(type, listener) -> void - Removes event listener\n- dispatchEvent(event) -> void - Dispatches custom event\n- open(wasReconnect) -> void - Opens WebSocket connection (internal use)\n- send(data) -> void - Sends data through WebSocket connection\n- close(code, reason) -> void - Closes WebSocket connection and stops reconnection attempts\n- refresh() -> void - Forces reconnection by closing current connection\n- createEvent(eventName, detail) -> CustomEvent - Creates custom event object\n- onopen(event) -> void - Placeholder for open event handler\n- onclose(event) -> void - Placeholder for close event handler\n- onconnecting(event) -> void - Placeholder for connecting event handler\n- onmessage(event) -> void - Placeholder for message event handler\n- onerror(event) -> void - Placeholder for error event handler",
  "Canonical_solution": "class ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.debug = false;\n        this.automaticOpen = true;\n        this.reconnectInterval = 1000;\n        this.maxReconnectInterval = 30000;\n        this.reconnectDecay = 1.5;\n        this.timeoutInterval = 2000;\n        \n        if (options) {\n            for (var key in options) {\n                this[key] = options[key];\n            }\n        }\n        \n        this.url = url;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CONNECTING;\n        this.protocol = null;\n        \n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n        \n        eventTarget.addEventListener('open', (event) => { this.onopen(event); });\n        eventTarget.addEventListener('close', (event) => { this.onclose(event); });\n        eventTarget.addEventListener('connecting', (event) => { this.onconnecting(event); });\n        eventTarget.addEventListener('message', (event) => { this.onmessage(event); });\n        eventTarget.addEventListener('error', (event) => { this.onerror(event); });\n        \n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n        \n        this.open = function(wasReconnect) {\n            var ws = new WebSocket(this.url, protocols || []);\n            if (!wasReconnect) {\n                eventTarget.dispatchEvent(this.createEvent('connecting'));\n            }\n            \n            var timeout = setTimeout(() => {\n                timedOut = true;\n                ws.close();\n                timedOut = false;\n            }, this.timeoutInterval);\n            \n            ws.onopen = () => {\n                clearTimeout(timeout);\n                this.protocol = ws.protocol;\n                this.readyState = WebSocket.OPEN;\n                this.reconnectAttempts = 0;\n                var event = this.createEvent('open');\n                event.isReconnect = wasReconnect;\n                wasReconnect = false;\n                eventTarget.dispatchEvent(event);\n            };\n            \n            ws.onclose = (event) => {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    this.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(this.createEvent('close'));\n                } else {\n                    this.readyState = WebSocket.CONNECTING;\n                    var connectingEvent = this.createEvent('connecting');\n                    connectingEvent.code = event.code;\n                    connectingEvent.reason = event.reason;\n                    connectingEvent.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(connectingEvent);\n                    \n                    if (!wasReconnect && !timedOut) {\n                        eventTarget.dispatchEvent(this.createEvent('close'));\n                    }\n                    \n                    var reconnectTimeout = this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts);\n                    setTimeout(() => {\n                        this.reconnectAttempts++;\n                        this.open(true);\n                    }, Math.min(reconnectTimeout, this.maxReconnectInterval));\n                }\n            };\n            \n            ws.onmessage = (event) => {\n                var messageEvent = this.createEvent('message');\n                messageEvent.data = event.data;\n                eventTarget.dispatchEvent(messageEvent);\n            };\n            \n            ws.onerror = (event) => {\n                eventTarget.dispatchEvent(this.createEvent('error'));\n            };\n        };\n        \n        if (this.automaticOpen) {\n            this.open(false);\n        }\n        \n        this.send = function(data) {\n            if (ws) {\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n        \n        this.close = function(code, reason) {\n            forcedClose = true;\n            if (ws) {\n                ws.close(code || 1000, reason);\n            }\n        };\n        \n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n    \n    createEvent(eventName, detail) {\n        var event = document.createEvent('CustomEvent');\n        event.initCustomEvent(eventName, false, false, detail);\n        return event;\n    }\n    \n    onopen(event) {}\n    onclose(event) {}\n    onconnecting(event) {}\n    onmessage(event) {}\n    onerror(event) {}\n}\n\nReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\nReconnectingWebSocket.OPEN = WebSocket.OPEN;\nReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\nReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\nReconnectingWebSocket.debugAll = false;",
  "FSMID_for_test": 89,
  "Code_level": "Class-level"
}