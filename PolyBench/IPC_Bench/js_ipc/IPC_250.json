{
  "Task_id": 250,
  "Github_ID": "414824130",
  "Github_Project_Name": "cocogoat",
  "Programming_Language": "JavaScript",
  "suffix": ".ts",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on browser native API in JavaScript",
  "Instruction": "Task Description: \nCreate a WebSocket-based control class for managing connections and communication between a client and a local server, including authorization, message handling, and API invocation.\n\nClass Description: \nThe `CocogoatWebControl` class provides functionality to establish and manage WebSocket connections to a local server, handle authorization, send/receive messages, and invoke API methods through WebSocket communication.\n\nAttributes:\n- port: number - The port number for the local server connection (default: 32333)\n- token: string - The authorization token for authenticated requests\n- hwnd: number - A window handle identifier (default: 0)\n- version: string - Version information (currently unused in the reference code)\n- ev: Mitt - An event emitter for handling WebSocket messages\n- client: FlyType - An HTTP client for initial authorization\n- ws: WebSocket | undefined - The active WebSocket connection instance\n\nMethods:\n- constructor(_port?: number) -> void - Initializes the control instance with optional port specification\n- authorize() -> Promise<boolean> - Establishes WebSocket connection and obtains authorization token\n- wsInvoke(method: string, path: string, querystring?: Record<string, any>) -> Promise<{status: number, body: any}> - Invokes an API method through WebSocket connection",
  "Canonical_solution": "import mitt from 'mitt'\nimport { stringify } from 'qs'\nimport Fly from 'flyio/dist/npm/fly'\nimport type { Fly as FlyType, FlyError } from 'flyio'\n\nexport class CocogoatWebControl {\n    port = 32333\n    token = ''\n    hwnd = 0\n    version = ''\n    ev = mitt()\n    client: FlyType = new Fly()\n    ws: WebSocket | undefined\n\n    constructor(_port = 32333) {\n        this.port = _port\n        this.client.config.baseURL = `http://localhost:${this.port}`\n        this.client.interceptors.request.use((request) => {\n            if (this.token) {\n                request.headers['Authorization'] = `Bearer ${this.token}`\n            }\n            if (request.headers['Content-Type'] === '') {\n                delete request.headers['Content-Type']\n            }\n            return request\n        })\n        this.client.interceptors.response.use(undefined, (e) => {\n            const er = e as unknown as FlyError\n            if (er.status === 410) {\n                console.warn('Control stopped by user')\n                return new Error('ECANCEL')\n            }\n            return e\n        })\n    }\n\n    async authorize() {\n        if (this.ws) {\n            return true\n        }\n        try {\n            const { data } = await this.client.post('/token')\n            this.token = data.token\n            this.hwnd = data.hwnd || 0\n            const ws = new WebSocket(`ws://localhost:${this.port}/ws/${this.token}`)\n            ws.onmessage = (e) => {\n                const data = JSON.parse(e.data)\n                this.ev.emit(data.id || data.action, data.data)\n            }\n            ws.onclose = () => {\n                this.ws = undefined\n            }\n            await new Promise((resolve) => {\n                ws.onopen = resolve\n            })\n            this.ws = ws\n            return true\n        } catch (e) {\n            const er = e as FlyError\n            if (er.status === 401) {\n                return false\n            }\n            throw e\n        }\n    }\n\n    wsInvoke(method: string, path: string, querystring?: Record<string, any>) {\n        if (!this.ws) throw new Error('WebSocket not connected')\n        const url = path + (querystring ? `?${stringify(querystring)}` : '')\n        const id = Math.round(Date.now() * 1000 + Math.random() * 1000).toString(16)\n        const reqjson = {\n            id,\n            action: 'api',\n            data: {\n                url,\n                method,\n            },\n        }\n        const resp = new Promise((resolve) => {\n            this.ev.on(id, resolve)\n        })\n        this.ws.send(JSON.stringify(reqjson))\n        return resp as Promise<{\n            status: number\n            body: any\n        }>\n    }\n}",
  "FSMID_for_test": 89,
  "Code_level": "Class-level"
}