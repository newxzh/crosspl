{
  "Task_id": 137,
  "Github_ID": "34136758",
  "Github_Project_Name": "dom-to-image",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "Pipe Server-side based on fs+http in JavaScript",
  "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
  "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
  "FSMID_for_test": 100,
  "Code_level": "Class-level"
}