{
  "Task_id": 197,
  "Github_ID": "184366",
  "Github_Project_Name": "opal",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on Node.js",
  "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
  "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
  "FSMID_for_test": 91,
  "Code_level": "Class-level"
}