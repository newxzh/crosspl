{
  "Task_id": 111,
  "Github_ID": "166514296",
  "Github_Project_Name": "cloudquery",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "HTTP based on express in javascript",
  "Instruction": "Task Description: Create a function that sets up an Express server with rate limiting, CORS support, and route handlers for querying webpage elements and retrieving full HTML content using Chrome DevTools Protocol.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with middleware configuration and defines three routes:\n1. `/query` - Extracts specified elements' innerText and href attributes from a given URL\n2. `/fullHtml` - Retrieves the complete HTML of a given URL\n3. `/` - Serves a static index.html file\n\nThe function implements rate limiting, CORS, and proper error handling while using Chrome DevTools Protocol to interact with web pages programmatically.\n\nInput: None (The function doesn't take any parameters. Configuration is loaded from external files.)\n\nOutput: None (The function's output is the running Express server listening on the specified port, which defaults to 3000 if not provided via environment variables.)",
  "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const rateLimit = require('express-rate-limit');\n    const config = require('./config');\n\n    const app = express();\n    app.enable('trust proxy');\n    const limiter = rateLimit(config.rateLimit);\n    app.use('/fullHtml', limiter);\n    app.use('/query', limiter);\n    app.use(cors());\n    app.set('json replacer', null);\n    app.set('json spaces', 2);\n\n    app.get('/query', async (req, res) => {\n        const { url, selectors } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        if (!selectors) {\n            res.status(400).send('must provide selectors');\n            throw new Error('throwing as selectors not valid');\n        }\n        const selectorArr = selectors.split(',');\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const promiseArr = selectorArr.map(async (selector) => {\n                const innerTextRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').innerText`,\n                });\n                const hrefRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').href`,\n                });\n                return {\n                    innerText: innerTextRes.result.value,\n                    href: hrefRes.result.value,\n                };\n            });\n            const queryRes = await Promise.all(promiseArr.map(p => p.catch(e => e.message)));\n            res.json({\n                url,\n                selectors,\n                contents: queryRes,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/fullHtml', async (req, res) => {\n        const { url } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const result = await Runtime.evaluate({\n                expression: 'document.documentElement.outerHTML',\n            });\n            const html = result.result.value;\n            res.send({\n                url,\n                html,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/', function(req, res) {\n        res.sendFile(path.join(__dirname, '../public/index.html'));\n    });\n\n    const { PORT = 3000 } = process.env;\n    app.listen(PORT);\n}",
  "FSMID_for_test": 96,
  "Code_level": "Function-level"
}