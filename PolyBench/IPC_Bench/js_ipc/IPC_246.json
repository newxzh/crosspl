{
  "Task_id": 246,
  "Github_ID": "636344889",
  "Github_Project_Name": "WhisperLive",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on browser native API in JavaScript",
  "Instruction": "Task Description: Implement a WebSocket client for audio streaming and transcription that connects to a server, handles real-time audio capture, and processes server responses for transcription and status updates.\n\nFunction Description: The `startRecording` function initializes a WebSocket connection to a specified server, configures audio capture from the user's microphone, and handles bidirectional communication with the server for audio streaming and transcription services. It manages connection events, server status updates, and transcription results while handling errors and disconnections gracefully.\n\nInput:\n- `data`: [Object] - Configuration object containing:\n  - `host`: [String] - WebSocket server host address\n  - `port`: [String|Number] - WebSocket server port\n  - `language`: [String] - Preferred language for transcription\n  - `task`: [String] - Task type (e.g., \"transcription\")\n  - `modelSize`: [String] - Model size specification\n  - `useVad`: [Boolean] - Flag for voice activity detection\n\nOutput:\n- None (Void) - The function establishes persistent connections and event handlers but doesn't return a value. Results are handled through:\n  - Browser runtime messages (via `browser.runtime.sendMessage`)\n  - WebSocket events (onmessage, onerror, etc.)\n  - Audio processing callbacks\n\nSide Effects:\n- Creates a WebSocket connection to the specified server\n- Requests microphone permissions and initializes audio capture\n- Modifies browser state through runtime messages\n- Maintains connection state internally through variables (`isServerReady`, `isCapturing`, etc.)",
  "Canonical_solution": "function startRecording(data) {\n    socket = new WebSocket(`ws://${data.host}:${data.port}/`);\n    language = data.language;\n\n    const uuid = generateUUID();\n    socket.onopen = function(e) { \n      socket.send(\n        JSON.stringify({\n            uid: uuid,\n            language: data.language,\n            task: data.task,\n            model: data.modelSize,\n            use_vad: data.useVad\n        })\n      );\n    };\n\n    let isServerReady = false;\n    socket.onmessage = async (event) => {\n      const data = JSON.parse(event.data);\n      if (data[\"uid\"] !== uuid)\n        return;\n      \n      if (data[\"status\"] === \"WAIT\"){\n        await browser.runtime.sendMessage({ action: \"showPopup\", data: data[\"message\"] })\n        return;\n      }\n      \n      if (!isServerReady && data[\"message\"] === \"SERVER_READY\"){\n        isServerReady = true;\n        return;\n      }\n\n      if (language === null ){\n        language = data[\"language\"];\n        await browser.runtime.sendMessage({ action: \"updateSelectedLanguage\", data: language })      \n        return\n      }\n\n      if (data[\"message\"] === \"DISCONNECT\"){\n        await browser.runtime.sendMessage({ action: \"toggleCaptureButtons\", data: false })        \n        return\n      }\n\n      await browser.runtime.sendMessage({ action: \"transcript\", data: event.data })\n          .catch(function(error) {\n            console.error(\"Error sending message:\", error);\n          });\n    };\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then(function(stream) {\n      const audioDataCache = [];\n      audioContext = new AudioContext();\n      mediaStream = audioContext.createMediaStreamSource(stream);\n      recorder = audioContext.createScriptProcessor(4096, 1, 1);\n\n      recorder.onaudioprocess = async (event) => {\n        if (!audioContext || !isCapturing || !isServerReady || isPaused) return;\n\n        const inputData = event.inputBuffer.getChannelData(0);\n        const audioData16kHz = resampleTo16kHZ(inputData, audioContext.sampleRate);\n\n        audioDataCache.push(inputData);\n        \n        socket.send(audioData16kHz);\n      };\n\n      mediaStream.connect(recorder);\n      recorder.connect(audioContext.destination);\n    })\n}",
  "FSMID_for_test": 89,
  "Code_level": "Function-level"
}