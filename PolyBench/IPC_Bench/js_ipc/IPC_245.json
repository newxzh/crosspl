{
  "Task_id": 245,
  "Github_ID": "337042139",
  "Github_Project_Name": "arduino-ide",
  "Programming_Language": "JavaScript",
  "suffix": ".ts",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side based on browser native API in JavaScript",
  "Instruction": "Task Description: Implement a WebSocket client class for managing connections, sending messages, and handling events in a browser environment using JavaScript.\n\nClass Description: MonitorManagerProxyClientImpl is a WebSocket client implementation that manages WebSocket connections, handles incoming messages, and provides methods for sending data and changing settings. It uses event emitters to notify about received messages and settings changes.\n\nAttributes:\n- webSocket: WebSocket | undefined - The active WebSocket connection instance\n- wsPort: number | undefined - The port number used for the WebSocket connection\n\nMethods:\n- connect(addressPort: number) -> Promise<void> - Establishes a WebSocket connection to the specified port. Returns a promise that resolves when connected or rejects on error.\n- disconnect() -> void - Closes the active WebSocket connection if it exists.\n- send(message: string) -> void - Sends a message through the WebSocket connection after formatting it with a command structure.\n- changeSettings(settings: MonitorSettings) -> void - Sends settings changes through the WebSocket connection.\n- isWSConnected() -> Promise<boolean> - Checks if the WebSocket connection is active.\n- getWebSocketPort() -> number | undefined - Returns the port number used for the current WebSocket connection.",
  "Canonical_solution": "@injectable()\nexport class MonitorManagerProxyClientImpl implements MonitorManagerProxyClient {\n  private webSocket?: WebSocket;\n  private wsPort?: number;\n\n  async connect(addressPort: number): Promise<void> {\n    if (this.webSocket) {\n      if (this.wsPort === addressPort) {\n        return;\n      }\n      this.disconnect();\n    }\n    try {\n      this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n    } catch {\n      throw new Error('Unable to connect to websocket');\n    }\n\n    const opened = new Deferred<void>();\n    this.webSocket.onopen = () => opened.resolve();\n    this.webSocket.onerror = () => opened.reject();\n    this.webSocket.onmessage = (message) => {\n      const parsedMessage = JSON.parse(message.data);\n      if (Array.isArray(parsedMessage)) {\n        this.onMessagesReceivedEmitter.fire({ messages: parsedMessage });\n      } else if (\n        parsedMessage.command === Monitor.MiddlewareCommand.ON_SETTINGS_DID_CHANGE\n      ) {\n        this.onMonitorSettingsDidChangeEmitter.fire(parsedMessage.data);\n      }\n    };\n    this.wsPort = addressPort;\n    return opened.promise;\n  }\n\n  disconnect(): void {\n    if (!this.webSocket) {\n      return;\n    }\n    try {\n      this.webSocket.close();\n      this.webSocket = undefined;\n    } catch (err) {\n      console.error('Could not close the websocket connection for the monitor.', err);\n      throw new Error('Unable to close websocket');\n    }\n  }\n\n  send(message: string): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.SEND_MESSAGE,\n        data: message,\n      })\n    );\n  }\n\n  changeSettings(settings: MonitorSettings): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.CHANGE_SETTINGS,\n        data: settings,\n      })\n    );\n  }\n\n  async isWSConnected(): Promise<boolean> {\n    return !!this.webSocket;\n  }\n\n  getWebSocketPort(): number | undefined {\n    return this.wsPort;\n  }\n}",
  "FSMID_for_test": 89,
  "Code_level": "Class-level"
}