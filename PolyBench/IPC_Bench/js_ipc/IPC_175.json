{
  "Task_id": 175,
  "Github_ID": "82289483",
  "Github_Project_Name": "moleculer",
  "Programming_Language": "JavaScript",
  "suffix": ".js",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server - side based on node.js net",
  "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, manage socket communication, and process incoming messages.\n\nClass Description: The TcpReader class is responsible for establishing a TCP server, managing client connections, handling socket events, and processing incoming messages through a custom parser. It provides methods to start/stop the server and manage connected clients.\n\nAttributes:\n- transporter: [Object] - The parent transporter object that handles incoming messages\n- opts: [Object] - Configuration options including the port to listen on\n- sockets: [Array] - Array of currently connected client sockets\n- logger: [Object] - Logger instance from the transporter for error logging\n- server: [Object] - The TCP server instance\n- connected: [Boolean] - Flag indicating if the server is currently listening\n\nMethods:\n- constructor(transporter, opts) -> [void] - Initializes the TcpReader with transporter and options\n- listen() -> [Promise] - Starts the TCP server and begins listening for connections\n- onTcpClientConnected(socket) -> [void] - Handles new client connections and sets up event listeners\n- closeSocket(socket, err) -> [void] - Closes and removes a specific socket from the connections\n- close() -> [void] - Stops the server and closes all connected sockets",
  "Canonical_solution": "const net = require(\"net\");\n\nclass TcpReader {\n    constructor(transporter, opts) {\n        this.transporter = transporter;\n        this.opts = opts;\n        this.sockets = [];\n        this.logger = transporter.logger;\n    }\n\n    listen() {\n        return new Promise((resolve, reject) => {\n            this.server = net.createServer(socket => {\n                this.onTcpClientConnected(socket);\n            });\n\n            this.server.on(\"error\", err => {\n                reject(err);\n            });\n\n            const listenOptions = process.versions.node.split(\".\")[0] >= 8 \n                ? { port: this.opts.port, exclusive: true }\n                : this.opts.port;\n\n            this.server.listen(listenOptions, () => {\n                this.opts.port = this.server.address().port;\n                this.connected = true;\n                resolve();\n            });\n        });\n    }\n\n    onTcpClientConnected(socket) {\n        socket.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        socket.on(\"close\", () => {\n            this.closeSocket(socket);\n        });\n\n        socket.setNoDelay(true);\n\n        const parser = require(\"../../../../src/transporters/tcp/parser\")();\n        socket.pipe(parser);\n\n        parser.on(\"data\", (type, message) => {\n            this.transporter.onIncomingMessage(type, message, socket);\n        });\n\n        parser.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        this.sockets.push(socket);\n    }\n\n    closeSocket(socket, err) {\n        if (err) {\n            this.logger.warn(`TCP socket error: ${err.message}`);\n        }\n\n        const index = this.sockets.indexOf(socket);\n        if (index !== -1) {\n            this.sockets.splice(index, 1);\n            socket.destroy();\n        }\n    }\n\n    close() {\n        if (this.server && this.server.listening) {\n            this.server.close();\n        }\n\n        this.sockets.forEach(socket => {\n            socket.destroy();\n        });\n        this.sockets = [];\n    }\n}",
  "FSMID_for_test": 97,
  "Code_level": "Class-level"
}