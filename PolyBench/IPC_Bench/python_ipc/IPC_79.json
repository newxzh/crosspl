{
  "Task_id": 79,
  "Github_ID": "7812229",
  "Github_Project_Name": "tapiriik",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client-side by using requests in python",
  "Instruction": "Task Description: Create a Python class that implements HTTP client functionality for interacting with the RunKeeper API, including rate limiting, authorization handling, and standard HTTP methods (GET, POST, DELETE).\n\nClass Description: The RunKeeperAPI class provides methods to interact with the RunKeeper web service API. It handles rate limiting, authorization, and provides wrapper methods for common HTTP operations. The class includes rate limit tracking and proper error handling for API responses.\n\nAttributes:\n_RATE_LIMIT_KEY: str - Redis key used for tracking global rate limit status\n\nMethods:\n_rate_limit: [Name](endpoint: str, req_lambda: Callable) -> requests.Response - Handles rate limiting logic by checking Redis for existing rate limits and processing API responses for rate limit errors\n_api_headers: [Name](service_record: object) -> dict - Generates authorization headers for API requests using the service record's token\nget_request: [Name](url: str, service_record: object) -> dict - Performs an HTTP GET request to the specified URL with authorization headers and returns parsed JSON response\npost_request: [Name](url: str, service_record: object, data: Optional[dict]) -> requests.Response - Performs an HTTP POST request to the specified URL with optional data and authorization headers\ndelete_request: [Name](url: str, service_record: object) -> requests.Response - Performs an HTTP DELETE request to the specified URL with authorization headers\noauth_token_request: [Name](params: dict) -> str - Handles OAuth token requests by posting to the RunKeeper token endpoint and returns the access token",
  "Canonical_solution": "from tapiriik.settings import WEB_ROOT, RUNKEEPER_CLIENT_ID, RUNKEEPER_CLIENT_SECRET\nfrom tapiriik.services.api import APIException, UserException, UserExceptionType\nimport requests\nimport urllib.parse\nimport json\nfrom datetime import timedelta\nimport re\n\nclass RunKeeperAPI:\n    _RATE_LIMIT_KEY = \"rk:rate_limit:hit\"\n\n    def _rate_limit(self, endpoint, req_lambda):\n        if redis.get(self._RATE_LIMIT_KEY) is not None:\n            raise APIException(\"RK global rate limit previously reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n        response = req_lambda()\n        if response.status_code == 429:\n            if \"user\" not in response.text:\n                timeout = timedelta(minutes=15)\n                timeout_match = re.search(r\"(\\d+) (second|minute|hour|day)\", response.text)\n                if timeout_match:\n                    timeout = timedelta(**{\"%ss\" % timeout_match.group(2): float(timeout_match.group(1))}\n                redis.setex(self._RATE_LIMIT_KEY, response.text, timeout)\n                raise APIException(\"RK global rate limit reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n            else:\n                raise APIException(\"RK user rate limit reached on %s\" % endpoint, user_exception=UserException(UserExceptionType.RateLimited))\n        return response\n\n    def _api_headers(self, service_record):\n        return {\"Authorization\": \"Bearer \" + service_record.Authorization[\"Token\"],\n                \"Accept-Charset\": \"UTF-8\"}\n\n    def get_request(self, url, service_record):\n        response = self._rate_limit(\"get_request\",\n                                  lambda: requests.get(url,\n                                                      headers=self._api_headers(service_record)))\n        if response.status_code != 200:\n            if response.status_code in [401, 403]:\n                raise APIException(\"No authorization\", block=True, user_exception=UserException(UserExceptionType.Authorization, intervention_required=True))\n            raise APIException(\"Request failed: %s %s\" % (response.status_code, response.text))\n        return response.json()\n\n    def post_request(self, url, service_record, data=None):\n        response = self._rate_limit(\"post_request\",\n                                  lambda: requests.post(url,\n                                                       headers=self._api_headers(service_record),\n                                                       data=data))\n        response.raise_for_status()\n        return response\n\n    def delete_request(self, url, service_record):\n        response = self._rate_limit(\"delete_request\",\n                                  lambda: requests.delete(url,\n                                                         headers=self._api_headers(service_record)))\n        response.raise_for_status()\n        return response\n\n    def oauth_token_request(self, params):\n        response = self._rate_limit(\"auth_token\",\n                                  lambda: requests.post(\"https://runkeeper.com/apps/token\",\n                                                      data=urllib.parse.urlencode(params),\n                                                      headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}))\n        if response.status_code != 200:\n            raise APIException(\"Invalid code\")\n        return response.json()[\"access_token\"]",
  "FSMID_for_test": 57,
  "Code_level": "Class-level"
}