{
  "Task_id": 480,
  "Github_ID": "537827151",
  "Github_Project_Name": "CodeGeeX",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "ZeroMQ Consumer in Python(REQ/REP)",
  "Instruction": "Task Description: Implement a ZeroMQ-based server that handles task distribution and status updates between multiple workers using the REQ/REP pattern.\n\nFunction Description: The server function establishes a ZeroMQ REP socket to listen for worker requests. It manages a pool of tasks (remaining_entries) and distributes them to workers. Workers can request tasks (\"pull\") or report task completion status (\"success\"/\"failure\"). The server responds accordingly and tracks active workers. The loop continues until all tasks are completed and all workers have finished.\n\nInput:\n- --channel-ip (str, optional): IP address for ZeroMQ channel (default: None)\n- --channel-port (int): Port number for ZeroMQ channel (default: 5555)\n\nOutput: None (The function runs indefinitely until all tasks are completed and all workers have disconnected)\n\nNote: The function uses two global variables:\n- remaining_entries: List of pending task IDs\n- running_workers: Count of currently active workers\n\nThe server expects and sends JSON messages with the following formats:\nReceived messages:\n- {\"rank\": [worker_id], \"action\": \"pull\"}\n- {\"rank\": [worker_id], \"action\": \"success\"/\"failure\", \"task_id\": [task_id]}\n\nSent responses:\n- {\"task_id\": [task_id]} (for pull requests)\n- {\"task_id\": None} (when no tasks remain)\n- {\"pong\": 1} (acknowledgment for status updates)\n\nThe server maintains task state by:\n1. Removing tasks when assigned\n2. Re-adding tasks if workers report failure\n3. Tracking active workers until all complete their tasks",
  "Canonical_solution": "import zmq\nimport time\nimport torch\n\ndef server():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--channel-ip\",\n        type=str,\n        default=None,\n        help=\"IP for ZeroMQ channel\",\n    )\n    parser.add_argument(\n        \"--channel-port\",\n        type=int,\n        default=5555,\n        help=\"Port for ZeroMQ channel\",\n    )\n    args = parser.parse_known_args()[0]\n\n    context = zmq.Context()\n    socket = context.socket(zmq.REP)\n    socket.bind(f\"tcp://*:{args.channel_port}\")\n\n    while True:\n        msg = socket.recv_json()\n        rank = msg[\"rank\"]\n        action = msg[\"action\"]\n\n        if action == \"pull\":\n            if len(remaining_entries) == 0:\n                socket.send_json({\"task_id\": None})\n                running_workers -= 1\n                if running_workers == 0:\n                    break\n            else:\n                entry = remaining_entries.pop()\n                socket.send_json({\"task_id\": entry})\n        else:\n            if action == \"success\":\n                socket.send_json({\"pong\": 1})\n            else:\n                remaining_entries.append(msg['task_id'])\n                socket.send_json({\"pong\": 1})\n                break",
  "FSMID_for_test": 87,
  "Code_level": "Function-level"
}