{
  "Task_id": 415,
  "Github_ID": "440580214",
  "Github_Project_Name": "log4j-scanner",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server - side by using socketserver in python",
  "Instruction": "Task Description: Implement a TCP server using Python's socketserver module to handle client requests with proper data framing and error handling.\n\nClass Description: TCPRequestHandler is a custom request handler class that inherits from socketserver.BaseRequestHandler. It handles TCP client connections by implementing methods to receive and send framed data, and processes client requests in the handle() method.\n\nAttributes:\n- request: [socket.socket] - The client connection socket object inherited from BaseRequestHandler\n- client_address: [tuple] - The client address (host, port) inherited from BaseRequestHandler\n- server: [socketserver.BaseServer] - The server instance inherited from BaseRequestHandler\n\nMethods:\n- get_data() -> bytes - Receives and validates framed data from the client. The data is expected to be prefixed with a 2-byte big-endian size field.\n  Input: None\n  Output: bytes - The received payload data (without size prefix)\n  \n- send_data(data: bytes) -> None - Sends framed data to the client by prefixing the payload with a 2-byte big-endian size field.\n  Input: data [bytes] - The payload data to send\n  Output: None\n  \n- handle() -> None - Main request handling method that coordinates receiving and processing client data.\n  Input: None\n  Output: None\n\nClass Description: DNSServer is a server management class that creates and manages TCP/UDP server instances for handling DNS requests.\n\nAttributes:\n- port: [int] - The port number to listen on (default: 53)\n- use_tcp: [bool] - Flag to enable TCP server (default: True)\n- use_udp: [bool] - Flag to enable UDP server (default: False)\n- servers: [list] - List of active server instances\n\nMethods:\n- __init__(port: int = 53, use_tcp: bool = True, use_udp: bool = False) -> None - Initializes the server configuration.\n  Input: \n    port [int] - Server port number\n    use_tcp [bool] - Enable TCP server\n    use_udp [bool] - Enable UDP server\n  Output: None\n  \n- start() -> None - Starts the configured servers in separate threads.\n  Input: None\n  Output: None\n  \n- shutdown() -> None - Shuts down all running server instances.\n  Input: None\n  Output: None",
  "Canonical_solution": "import socketserver\nimport struct\nimport threading\n\nclass TCPRequestHandler(socketserver.BaseRequestHandler):\n    def get_data(self):\n        data = self.request.recv(8192).strip()\n        sz = struct.unpack('>H', data[:2])[0]\n        if sz < len(data) - 2:\n            raise Exception(\"Wrong size of TCP packet\")\n        elif sz > len(data) - 2:\n            raise Exception(\"Too big TCP packet\")\n        return data[2:]\n\n    def send_data(self, data):\n        sz = struct.pack('>H', len(data))\n        return self.request.sendall(sz + data)\n\n    def handle(self):\n        try:\n            data = self.get_data()\n            self.send_data(dns_response(data))\n        except Exception:\n            pass\n\nclass DNSServer:\n    def __init__(self, port=53, use_tcp=True, use_udp=False):\n        self.port = port\n        self.use_tcp = use_tcp\n        self.use_udp = use_udp\n        self.servers = []\n\n    def start(self):\n        if self.use_tcp:\n            self.servers.append(socketserver.ThreadingTCPServer(('', self.port), TCPRequestHandler))\n        if self.use_udp:\n            self.servers.append(socketserver.ThreadingUDPServer(('', self.port), UDPRequestHandler))\n\n        for s in self.servers:\n            thread = threading.Thread(target=s.serve_forever)\n            thread.daemon = True\n            thread.start()\n\n    def shutdown(self):\n        for s in self.servers:\n            s.shutdown()",
  "FSMID_for_test": 70,
  "Code_level": "Class-level"
}