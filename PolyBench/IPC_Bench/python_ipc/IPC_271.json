{
  "Task_id": 271,
  "Github_ID": "109144395",
  "Github_Project_Name": "tavern",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "Mosquitto Consumer based on mqtt in Python",
  "Instruction": "Task Description: Create a Python function that establishes an MQTT client connection, subscribes to specified topics, and continuously processes incoming messages using callback functions.\n\nFunction Description: The function `wait_for_messages` initializes an MQTT client, sets up a message callback handler, subscribes to predefined topics, and enters an infinite loop to process incoming MQTT messages. It handles different message types through topic-specific callback functions.\n\nInput: None (The function uses predefined configuration and topics internally)\n\nOutput: None (The function runs indefinitely, processing messages through callbacks)\n\n---\n\nTask Description: Create a helper function to initialize and configure an MQTT client with WebSocket transport.\n\nFunction Description: The function `get_client` creates and configures an MQTT client instance with WebSocket transport, sets authentication credentials, and establishes an asynchronous connection to the broker.\n\nInput: None (Uses hardcoded connection parameters)\n\nOutput: paho.mqtt.client.Client - Returns a configured MQTT client instance\n\n---\n\nTask Description: Create a callback function to handle incoming MQTT messages and route them to appropriate handlers based on topic.\n\nFunction Description: The function `on_message_callback` processes incoming MQTT messages, logs receipt, and routes them to specific handler functions based on topic patterns. It includes error handling for message processing.\n\nInput:\n- client: paho.mqtt.client.Client - The MQTT client instance\n- userdata: Any - User-defined data passed to the callback\n- message: paho.mqtt.client.MQTTMessage - The received message object\n\nOutput: None (Messages are processed through side effects in handler functions)",
  "Canonical_solution": "import json\nimport logging\nimport paho.mqtt.client as paho\n\ndef get_client():\n    mqtt_client = paho.Client(transport=\"websockets\", client_id=\"listener\")\n    mqtt_client.enable_logger()\n    mqtt_client.username_pw_set(username=\"tavern\", password=\"tavern\")\n    mqtt_client.connect_async(host=\"broker\", port=9001)\n    return mqtt_client\n\ndef on_message_callback(client, userdata, message):\n    try:\n        logging.info(\"Received message on %s\", message.topic)\n\n        if \"devices/status\" in message.topic:\n            handle_full_status_topic(client, message)\n        elif \"lights\" in message.topic:\n            handle_lights_topic(message)\n        elif \"echo\" in message.topic:\n            handle_echo_topic(client, message)\n        elif \"ping\" in message.topic:\n            handle_ping_topic(client, message)\n        elif \"status\" in message.topic:\n            handle_status_topic(client, message)\n        else:\n            logging.warning(\"Got unexpected MQTT topic '%s'\", message.topic)\n    except Exception as e:\n        logging.exception(\"error handling message: {}\".format(e))\n\ndef wait_for_messages():\n    mqtt_client = get_client()\n    mqtt_client.on_message = on_message_callback\n    mqtt_client.reconnect()\n\n    topics = [\"lights\", \"ping\", \"echo\", \"status\"]\n\n    for t in topics:\n        device_topic = \"/device/+/{}\".format(t)\n        logging.debug(\"Subscribing to '%s'\", device_topic)\n        mqtt_client.subscribe(device_topic)\n\n    mqtt_client.subscribe(\"/devices/status\")\n\n    mqtt_client.loop_forever()",
  "FSMID_for_test": 84,
  "Code_level": "Function-level"
}