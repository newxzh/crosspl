{
  "Task_id": 461,
  "Github_ID": "703411624",
  "Github_Project_Name": "letta",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Server-side by using asyncio+websockets in python",
  "Instruction": "Task Description: Implement a WebSocket server interface that manages client connections and facilitates message broadcasting in a synchronous manner using asyncio and threading.\n\nClass Description: SyncWebSocketInterface is a class that provides a synchronous interface to an asynchronous WebSocket server. It manages client connections, handles message broadcasting to all connected clients, and runs the asyncio event loop in a separate thread to maintain responsiveness.\n\nAttributes:\n\nclients: [set] - A set of connected WebSocket clients.\nloop: [asyncio.AbstractEventLoop] - The asyncio event loop used for WebSocket operations.\nthread: [threading.Thread] - The thread running the asyncio event loop.\n\nMethods:\n\n__init__: [Name]() -> [None] - Initializes the WebSocket interface, creates a new event loop, and starts it in a separate thread.\n_run_event_loop: [Name]() -> [None] - Internal method that runs the asyncio event loop in the dedicated thread.\n_run_async: [Name](coroutine) -> [None] - Runs a coroutine in the asyncio event loop from another thread.\n_send_to_all_clients: [Name](clients, msg) -> [None] - Internal async method to send a message to all specified clients.\nregister_client: [Name](websocket) -> [None] - Registers a new WebSocket client to the set of connected clients.\nunregister_client: [Name](websocket) -> [None] - Removes a WebSocket client from the set of connected clients.\ninternal_monologue: [Name](msg) -> [None] - Prints and broadcasts an internal monologue message to all clients.\nassistant_message: [Name](msg) -> [None] - Prints and broadcasts an assistant message to all clients.\nfunction_message: [Name](msg) -> [None] - Prints and broadcasts a function message to all clients.\nclose: [Name]() -> [None] - Stops the event loop and joins the thread, cleaning up resources.",
  "Canonical_solution": "import asyncio\nimport threading\nimport letta.server.ws_api.protocol as protocol\n\nclass SyncWebSocketInterface:\n    def __init__(self):\n        self.clients = set()\n        self.loop = asyncio.new_event_loop()\n        self.thread = threading.Thread(target=self._run_event_loop, daemon=True)\n        self.thread.start()\n\n    def _run_event_loop(self):\n        asyncio.set_event_loop(self.loop)\n        try:\n            self.loop.run_forever()\n        finally:\n            self.loop.run_until_complete(self.loop.shutdown_asyncgens())\n            self.loop.close()\n\n    def _run_async(self, coroutine):\n        if not self.loop.is_closed():\n            asyncio.run_coroutine_threadsafe(coroutine, self.loop)\n\n    async def _send_to_all_clients(self, clients, msg):\n        if clients:\n            await asyncio.gather(*(client.send_text(msg) for client in clients))\n\n    def register_client(self, websocket):\n        self.clients.add(websocket)\n\n    def unregister_client(self, websocket):\n        self.clients.remove(websocket)\n\n    def internal_monologue(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_internal_monologue(msg)))\n\n    def assistant_message(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_assistant_message(msg)))\n\n    def function_message(self, msg):\n        print(msg)\n        if self.clients:\n            self._run_async(self._send_to_all_clients(self.clients, protocol.server_agent_function_message(msg)))\n\n    def close(self):\n        self.loop.call_soon_threadsafe(self.loop.stop)\n        self.thread.join()",
  "FSMID_for_test": 45,
  "Code_level": "Class-level"
}