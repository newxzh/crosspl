{
  "Task_id": 322,
  "Github_ID": "39558861",
  "Github_Project_Name": "aliyun-openapi-python-sdk",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client - side by using socket in python",
  "Instruction": "Task Description: Create a SOCKS-enabled socket class that extends Python's built-in socket functionality to support proxy connections through SOCKS4, SOCKS5, and HTTP proxies.\n\nClass Description: The `socksocket` class extends Python's `socket.socket` class to provide proxy support. It handles connection establishment through various proxy types while maintaining standard socket functionality. The class manages proxy configuration, connection negotiation, and error handling for proxy-related operations.\n\nAttributes:\n- default_proxy: [Class Variable] - Default proxy configuration used when no specific proxy is set\n- _proxyconn: [socket.socket] - TCP connection used to maintain UDP relay (for SOCKS5 UDP)\n- proxy: [tuple] - Current proxy configuration (type, addr, port, rdns, username, password)\n- proxy_sockname: [tuple] - The bound address (IP, port) of the proxy connection\n- proxy_peername: [tuple] - The destination address (IP, port) through the proxy\n- _timeout: [float] - Socket timeout value\n\nMethods:\n- __init__(family, type, proto, *args, **kwargs) -> None - Initializes the socket with optional proxy support. Validates socket type and sets up proxy attributes.\n- set_proxy(proxy_type, addr, port, rdns, username, password) -> None - Configures proxy settings for the socket.\n- connect(dest_pair) -> None - Establishes connection to destination through configured proxy. Handles both direct and proxied connections.\n- _readall(file, count) -> bytes - Internal method to read exact number of bytes from a file object.\n- _proxy_addr() -> tuple - Internal method to resolve proxy address and port.\n- _negotiate_SOCKS4(dest_addr, dest_port) -> None - Internal method to handle SOCKS4 proxy negotiation.\n- _negotiate_SOCKS5(dest_addr, dest_port) -> None - Internal method to handle SOCKS5 proxy negotiation.\n- _negotiate_HTTP(dest_addr, dest_port) -> None - Internal method to handle HTTP proxy negotiation.",
  "Canonical_solution": "import socket\nfrom errno import EOPNOTSUPP, EINVAL, EAGAIN\nimport struct\nfrom io import BytesIO\nfrom base64 import b64encode\n\nclass socksocket(socket.socket):\n    \"\"\"socksocket([family[, type[, proto]]]) -> socket object\n\n    Open a SOCKS enabled socket. The parameters are the same as\n    those of the standard socket init. In order for SOCKS to work,\n    you must specify family=AF_INET and proto=0.\n    The \"type\" argument must be either SOCK_STREAM or SOCK_DGRAM.\n    \"\"\"\n\n    default_proxy = None\n\n    def __init__(self, family=socket.AF_INET, type=socket.SOCK_STREAM,\n                 proto=0, *args, **kwargs):\n        if type not in (socket.SOCK_STREAM, socket.SOCK_DGRAM):\n            msg = \"Socket type must be stream or datagram, not {!r}\"\n            raise ValueError(msg.format(type))\n\n        super(socksocket, self).__init__(family, type, proto, *args, **kwargs)\n        self._proxyconn = None  # TCP connection to keep UDP relay alive\n\n        if self.default_proxy:\n            self.proxy = self.default_proxy\n        else:\n            self.proxy = (None, None, None, None, None, None)\n        self.proxy_sockname = None\n        self.proxy_peername = None\n\n        self._timeout = None\n\n    def _readall(self, file, count):\n        \"\"\"Receive EXACTLY the number of bytes requested from the file object.\"\"\"\n        data = b\"\"\n        while len(data) < count:\n            d = file.read(count - len(data))\n            if not d:\n                raise GeneralProxyError(\"Connection closed unexpectedly\")\n            data += d\n        return data\n\n    def set_proxy(self, proxy_type=None, addr=None, port=None, rdns=True,\n                  username=None, password=None):\n        \"\"\"Sets the proxy to be used.\"\"\"\n        self.proxy = (proxy_type, addr, port, rdns,\n                      username.encode() if username else None,\n                      password.encode() if password else None)\n\n    def connect(self, dest_pair):\n        \"\"\"\n        Connects to the specified destination through a proxy.\n        Uses the same API as socket's connect().\n\n        dest_pair - 2-tuple of (IP/hostname, port).\n        \"\"\"\n        if len(dest_pair) != 2 or dest_pair[0].startswith(\"[\"):\n            raise socket.error(\"PySocks doesn't support IPv6: %s\" % str(dest_pair))\n\n        dest_addr, dest_port = dest_pair\n\n        if self.type == socket.SOCK_DGRAM:\n            if not self._proxyconn:\n                self.bind((\"\", 0))\n            dest_addr = socket.gethostbyname(dest_addr)\n\n            if dest_addr == \"0.0.0.0\" and not dest_port:\n                self.proxy_peername = None\n            else:\n                self.proxy_peername = (dest_addr, dest_port)\n            return\n\n        (proxy_type, proxy_addr, proxy_port, rdns, username,\n         password) = self.proxy\n\n        if (not isinstance(dest_pair, (list, tuple))\n                or len(dest_pair) != 2\n                or not dest_addr\n                or not isinstance(dest_port, int)):\n            raise GeneralProxyError(\n                \"Invalid destination-connection (host, port) pair\")\n\n        super(socksocket, self).settimeout(self._timeout)\n\n        if proxy_type is None:\n            self.proxy_peername = dest_pair\n            super(socksocket, self).settimeout(self._timeout)\n            super(socksocket, self).connect((dest_addr, dest_port))\n            return\n\n        proxy_addr = self._proxy_addr()\n\n        try:\n            super(socksocket, self).connect(proxy_addr)\n        except socket.error as error:\n            self.close()\n            proxy_addr, proxy_port = proxy_addr\n            proxy_server = \"{0}:{1}\".format(proxy_addr, proxy_port)\n            printable_type = PRINTABLE_PROXY_TYPES[proxy_type]\n\n            msg = \"Error connecting to {0} proxy {1}\".format(printable_type,\n                                                             proxy_server)\n            raise ProxyConnectionError(msg, error)\n        else:\n            try:\n                negotiate = self._proxy_negotiators[proxy_type]\n                negotiate(self, dest_addr, dest_port)\n            except socket.error as error:\n                self.close()\n                raise GeneralProxyError(\"Socket error\", error)\n            except ProxyError:\n                self.close()\n                raise\n\n    def _proxy_addr(self):\n        \"\"\"Return proxy address to connect to as tuple object\"\"\"\n        (proxy_type, proxy_addr, proxy_port, rdns, username,\n         password) = self.proxy\n        proxy_port = proxy_port or DEFAULT_PORTS.get(proxy_type)\n        if not proxy_port:\n            raise GeneralProxyError(\"Invalid proxy type\")\n        return proxy_addr, proxy_port\n\n    def _negotiate_SOCKS5(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through a SOCKS5 server.\"\"\"\n        self.proxy_peername, self.proxy_sockname = self._SOCKS5_request(\n            self, b\"\\x01\", (dest_addr, dest_port))\n\n    def _negotiate_SOCKS4(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through a SOCKS4 server.\"\"\"\n        proxy_type, addr, port, rdns, username, password = self.proxy\n\n        writer = self.makefile(\"wb\")\n        reader = self.makefile(\"rb\", 0)\n        try:\n            remote_resolve = False\n            try:\n                addr_bytes = socket.inet_aton(dest_addr)\n            except socket.error:\n                if rdns:\n                    addr_bytes = b\"\\x00\\x00\\x00\\x01\"\n                    remote_resolve = True\n                else:\n                    addr_bytes = socket.inet_aton(\n                        socket.gethostbyname(dest_addr))\n\n            writer.write(struct.pack(\">BBH\", 0x04, 0x01, dest_port))\n            writer.write(addr_bytes)\n\n            if username:\n                writer.write(username)\n            writer.write(b\"\\x00\")\n\n            if remote_resolve:\n                writer.write(dest_addr.encode(\"idna\") + b\"\\x00\")\n            writer.flush()\n\n            resp = self._readall(reader, 8)\n            if resp[0:1] != b\"\\x00\":\n                raise GeneralProxyError(\n                    \"SOCKS4 proxy server sent invalid data\")\n\n            status = ord(resp[1:2])\n            if status != 0x5A:\n                error = SOCKS4_ERRORS.get(status, \"Unknown error\")\n                raise SOCKS4Error(\"{0:#04x}: {1}\".format(status, error))\n\n            self.proxy_sockname = (socket.inet_ntoa(resp[4:]),\n                                   struct.unpack(\">H\", resp[2:4])[0])\n            if remote_resolve:\n                self.proxy_peername = socket.inet_ntoa(addr_bytes), dest_port\n            else:\n                self.proxy_peername = dest_addr, dest_port\n        finally:\n            reader.close()\n            writer.close()\n\n    def _negotiate_HTTP(self, dest_addr, dest_port):\n        \"\"\"Negotiates a connection through an HTTP server.\"\"\"\n        proxy_type, addr, port, rdns, username, password = self.proxy\n\n        addr = dest_addr if rdns else socket.gethostbyname(dest_addr)\n\n        http_headers = [\n            (b\"CONNECT \" + addr.encode(\"idna\") + b\":\" +\n             str(dest_port).encode() + b\" HTTP/1.1\"),\n            b\"Host: \" + dest_addr.encode(\"idna\")\n        ]\n\n        if username and password:\n            http_headers.append(b\"Proxy-Authorization: basic \" +\n                                b64encode(username + b\":\" + password))\n\n        http_headers.append(b\"\\r\\n\")\n\n        self.sendall(b\"\\r\\n\".join(http_headers))\n\n        fobj = self.makefile()\n        status_line = fobj.readline()\n        fobj.close()\n\n        if not status_line:\n            raise GeneralProxyError(\"Connection closed unexpectedly\")\n\n        try:\n            proto, status_code, status_msg = status_line.split(\" \", 2)\n        except ValueError:\n            raise GeneralProxyError(\"HTTP proxy server sent invalid response\")\n\n        if not proto.startswith(\"HTTP/\"):\n            raise GeneralProxyError(\n                \"Proxy server does not appear to be an HTTP proxy\")\n\n        try:\n            status_code = int(status_code)\n        except ValueError:\n            raise HTTPError(\n                \"HTTP proxy server did not return a valid HTTP status\")\n\n        if status_code != 200:\n            error = \"{0}: {1}\".format(status_code, status_msg)\n            raise HTTPError(error)\n\n        self.proxy_sockname = (b\"0.0.0.0\", 0)\n        self.proxy_peername = addr, dest_port\n\n    _proxy_negotiators = {\n        SOCKS4: _negotiate_SOCKS4,\n        SOCKS5: _negotiate_SOCKS5,\n        HTTP: _negotiate_HTTP\n    }",
  "FSMID_for_test": 67,
  "Code_level": "Class-level"
}