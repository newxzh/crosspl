{
  "Task_id": 139,
  "Github_ID": "645381450",
  "Github_Project_Name": "EmbedAI",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using Flask in python",
  "Instruction": "Task Description: Create a Flask-based API service that handles document ingestion, question answering using a language model, and model downloading functionality.\n\nClass Description: FlaskAPI is a class that encapsulates a Flask web service for document processing and question answering. It provides endpoints for ingesting documents, querying an AI model, and downloading the required model files.\n\nAttributes:\n- app: Flask - The Flask application instance\n- embeddings_model_name: str - Name of the embeddings model to use\n- persist_directory: str - Directory to store persistent data\n- model_type: str - Type of the language model\n- model_path: str - Path to the model file\n- model_n_ctx: str - Context size for the model\n- llm: GPT4All - The language model instance\n\nMethods:\n- __init__() -> None - Initializes the Flask application and sets up CORS\n- _setup_routes() -> None - Defines all API routes and their handlers\n- _load_documents(source_dir: str) -> List[Document] - Loads documents from a directory\n- _load_single_document(file_path: str) -> Document - Loads a single document\n- run() -> None - Starts the Flask server\n- _load_model() -> None - Loads the language model if available\n\nRoute Handlers (internal methods):\n- ingest_data() -> Response - Handles document ingestion (GET /ingest)\n- get_answer() -> Response - Handles question answering (POST /get_answer)\n- download_and_save() -> Response - Handles model downloading (GET /download_model)\n\nThe class integrates with LangChain for document processing and GPT4All for local language model inference, providing a complete API for document-based question answering.",
  "Canonical_solution": "from flask import Flask, jsonify, request\nfrom flask_cors import CORS\nimport os\nimport glob\nfrom typing import List\nimport requests\nfrom langchain.chains import RetrievalQA\nfrom langchain.embeddings import HuggingFaceEmbeddings\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.vectorstores import Chroma\nfrom langchain.llms import GPT4All\nfrom constants import CHROMA_SETTINGS\n\nclass FlaskAPI:\n    def __init__(self):\n        self.app = Flask(__name__)\n        CORS(self.app)\n        self.embeddings_model_name = os.environ.get(\"EMBEDDINGS_MODEL_NAME\")\n        self.persist_directory = os.environ.get('PERSIST_DIRECTORY')\n        self.model_type = os.environ.get('MODEL_TYPE')\n        self.model_path = os.environ.get('MODEL_PATH')\n        self.model_n_ctx = os.environ.get('MODEL_N_CTX')\n        self.llm = None\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.route('/ingest', methods=['GET'])\n        def ingest_data():\n            source_directory = os.environ.get('SOURCE_DIRECTORY', 'source_documents')\n            print(f\"Loading documents from {source_directory}\")\n            chunk_size = 500\n            chunk_overlap = 50\n            documents = self._load_documents(source_directory)\n            text_splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)\n            texts = text_splitter.split_documents(documents)\n            print(f\"Loaded {len(documents)} documents from {source_directory}\")\n            print(f\"Split into {len(texts)} chunks of text (max. {chunk_size} characters each)\")\n\n            embeddings = HuggingFaceEmbeddings(model_name=self.embeddings_model_name)\n            db = Chroma.from_documents(texts, embeddings, persist_directory=self.persist_directory, client_settings=CHROMA_SETTINGS)\n            db.persist()\n            db = None\n            return jsonify(response=\"Success\")\n\n        @self.app.route('/get_answer', methods=['POST'])\n        def get_answer():\n            query = request.json\n            embeddings = HuggingFaceEmbeddings(model_name=self.embeddings_model_name)\n            db = Chroma(persist_directory=self.persist_directory, embedding_function=embeddings, client_settings=CHROMA_SETTINGS)\n            retriever = db.as_retriever()\n            if self.llm is None:\n                return \"Model not downloaded\", 400    \n            qa = RetrievalQA.from_chain_type(llm=self.llm, chain_type=\"stuff\", retriever=retriever, return_source_documents=True)\n            if query is not None and query != \"\":\n                res = qa(query)\n                answer, docs = res['result'], res['source_documents']\n                source_data = [{\"name\": document.metadata[\"source\"]} for document in docs]\n                return jsonify(query=query, answer=answer, source=source_data)\n            return \"Empty Query\", 400\n\n        @self.app.route('/download_model', methods=['GET'])\n        def download_and_save():\n            url = 'https://gpt4all.io/models/ggml-gpt4all-j-v1.3-groovy.bin'\n            filename = 'ggml-gpt4all-j-v1.3-groovy.bin'\n            models_folder = 'models'\n\n            if not os.path.exists(models_folder):\n                os.makedirs(models_folder)\n            response = requests.get(url, stream=True)\n            total_size = int(response.headers.get('content-length', 0))\n            bytes_downloaded = 0\n            file_path = f'{models_folder}/{filename}'\n            if os.path.exists(file_path):\n                return jsonify(response=\"Download completed\")\n\n            with open(file_path, 'wb') as file:\n                for chunk in response.iter_content(chunk_size=4096):\n                    file.write(chunk)\n                    bytes_downloaded += len(chunk)\n                    progress = round((bytes_downloaded / total_size) * 100, 2)\n                    print(f'Download Progress: {progress}%')\n            callbacks = [StreamingStdOutCallbackHandler()]\n            self.llm = GPT4All(model=self.model_path, n_ctx=self.model_n_ctx, backend='gptj', callbacks=callbacks, verbose=False)\n            return jsonify(response=\"Download completed\")\n\n    def _load_documents(self, source_dir: str) -> List[Document]:\n        all_files = []\n        for ext in LOADER_MAPPING:\n            all_files.extend(glob.glob(os.path.join(source_dir, f\"**/*{ext}\"), recursive=True))\n        return [self._load_single_document(file_path) for file_path in all_files]\n\n    def _load_single_document(self, file_path: str) -> Document:\n        ext = \".\" + file_path.rsplit(\".\", 1)[-1]\n        if ext in LOADER_MAPPING:\n            loader_class, loader_args = LOADER_MAPPING[ext]\n            loader = loader_class(file_path, **loader_args)\n            return loader.load()[0]\n        raise ValueError(f\"Unsupported file extension '{ext}'\")\n\n    def run(self):\n        self._load_model()\n        self.app.run(host=\"0.0.0.0\", debug=False)\n\n    def _load_model(self):\n        filename = 'ggml-gpt4all-j-v1.3-groovy.bin'\n        models_folder = 'models'\n        file_path = f'{models_folder}/{filename}'\n        if os.path.exists(file_path):\n            callbacks = [StreamingStdOutCallbackHandler()]\n            self.llm = GPT4All(model=self.model_path, n_ctx=self.model_n_ctx, backend='gptj', callbacks=callbacks, verbose=False)",
  "FSMID_for_test": 60,
  "Code_level": "Class-level"
}