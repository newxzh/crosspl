{
  "Task_id": 267,
  "Github_ID": "48129918",
  "Github_Project_Name": "paho.mqtt.python",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "Mosquitto Consumer based on mqtt in Python",
  "Instruction": "Task Description: Create a Python class that implements an MQTT subscriber client using the Paho MQTT library, capable of connecting to an MQTT broker, subscribing to topics, and handling incoming messages with configurable authentication and TLS options.\n\nClass Description: The MQTTSubscriber class provides a configurable MQTT client implementation for subscribing to topics and processing messages from an MQTT broker. It supports various connection options including TLS encryption and authentication.\n\nAttributes:\n- host: str - The MQTT broker host address (default: \"mqtt.eclipseprojects.io\")\n- topic: str - The topic to subscribe to (default: \"$SYS/#\")\n- qos: int - Quality of Service level for the subscription (default: 0)\n- clientid: str - Client identifier for the MQTT connection (default: None)\n- username: str - Username for broker authentication (default: None)\n- password: str - Password for broker authentication (default: None)\n- port: int - Broker connection port (default: None, auto-detected)\n- keepalive: int - Connection keepalive period in seconds (default: 60)\n- use_tls: bool - Flag to enable TLS encryption (default: False)\n- insecure: bool - Flag to disable certificate verification (default: False)\n- cacerts: str - Path to CA certificate file (default: None)\n- tls_version: str - TLS protocol version (default: None)\n- debug: bool - Flag to enable debug logging (default: False)\n- disable_clean_session: bool - Flag to disable clean session (default: False)\n- mqttc: mqtt.Client - The Paho MQTT client instance\n\nMethods:\n- __init__(host, topic, qos, clientid, username, password, port, keepalive, use_tls, insecure, cacerts, tls_version, debug, disable_clean_session) -> None - Initializes the MQTT subscriber with configuration parameters\n- _setup_callbacks() -> None - Sets up the MQTT client callback functions\n- _configure_tls() -> None - Configures TLS settings for secure connections\n- _configure_authentication() -> None - Configures username/password authentication\n- on_connect(mqttc, obj, flags, reason_code, properties) -> None - Callback for connection events\n- on_message(mqttc, obj, msg) -> None - Callback for incoming messages\n- on_publish(mqttc, obj, mid) -> None - Callback for publish events\n- on_subscribe(mqttc, obj, mid, reason_code_list, properties) -> None - Callback for subscription events\n- on_log(mqttc, obj, level, string) -> None - Callback for debug logging\n- connect_and_subscribe() -> None - Connects to the broker and starts the message loop",
  "Canonical_solution": "import argparse\nimport ssl\nimport paho.mqtt.client as mqtt\n\nclass MQTTSubscriber:\n    def __init__(self, host=\"mqtt.eclipseprojects.io\", topic=\"$SYS/#\", qos=0, clientid=None,\n                 username=None, password=None, port=None, keepalive=60, use_tls=False,\n                 insecure=False, cacerts=None, tls_version=None, debug=False,\n                 disable_clean_session=False):\n        self.host = host\n        self.topic = topic\n        self.qos = qos\n        self.clientid = clientid\n        self.username = username\n        self.password = password\n        self.port = port\n        self.keepalive = keepalive\n        self.use_tls = use_tls\n        self.insecure = insecure\n        self.cacerts = cacerts\n        self.tls_version = tls_version\n        self.debug = debug\n        self.disable_clean_session = disable_clean_session\n\n        self.mqttc = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, self.clientid,\n                                clean_session=not self.disable_clean_session)\n\n        self._setup_callbacks()\n        self._configure_tls()\n        self._configure_authentication()\n\n    def _setup_callbacks(self):\n        self.mqttc.on_message = self.on_message\n        self.mqttc.on_connect = self.on_connect\n        self.mqttc.on_publish = self.on_publish\n        self.mqttc.on_subscribe = self.on_subscribe\n        if self.debug:\n            self.mqttc.on_log = self.on_log\n\n    def _configure_tls(self):\n        if self.use_tls or self.cacerts:\n            if self.tls_version == \"tlsv1.2\":\n                tlsVersion = ssl.PROTOCOL_TLSv1_2\n            elif self.tls_version == \"tlsv1.1\":\n                tlsVersion = ssl.PROTOCOL_TLSv1_1\n            elif self.tls_version == \"tlsv1\":\n                tlsVersion = ssl.PROTOCOL_TLSv1\n            else:\n                tlsVersion = None\n\n            cert_required = ssl.CERT_NONE if self.insecure else ssl.CERT_REQUIRED\n            self.mqttc.tls_set(ca_certs=self.cacerts, certfile=None, keyfile=None,\n                              cert_reqs=cert_required, tls_version=tlsVersion)\n            if self.insecure:\n                self.mqttc.tls_insecure_set(True)\n\n    def _configure_authentication(self):\n        if self.username or self.password:\n            self.mqttc.username_pw_set(self.username, self.password)\n\n    def on_connect(self, mqttc, obj, flags, reason_code, properties):\n        print(\"reason_code: \" + str(reason_code))\n\n    def on_message(self, mqttc, obj, msg):\n        print(msg.topic + \" \" + str(msg.qos) + \" \" + str(msg.payload))\n\n    def on_publish(self, mqttc, obj, mid):\n        print(\"mid: \" + str(mid))\n\n    def on_subscribe(self, mqttc, obj, mid, reason_code_list, properties):\n        print(\"Subscribed: \" + str(mid) + \" \" + str(reason_code_list))\n\n    def on_log(self, mqttc, obj, level, string):\n        print(string)\n\n    def connect_and_subscribe(self):\n        if self.port is None:\n            self.port = 8883 if (self.use_tls or self.cacerts) else 1883\n\n        print(f\"Connecting to {self.host} port: {self.port}\")\n        self.mqttc.connect(self.host, self.port, self.keepalive)\n        self.mqttc.subscribe(self.topic, self.qos)\n        self.mqttc.loop_forever()",
  "FSMID_for_test": 84,
  "Code_level": "Class-level"
}