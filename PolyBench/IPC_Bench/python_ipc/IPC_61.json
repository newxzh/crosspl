{
  "Task_id": 61,
  "Github_ID": "877212130",
  "Github_Project_Name": "pdf-extract-api",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client-side by using requests in python",
  "Instruction": "Task Description: Implement a set of functions for interacting with an OCR (Optical Character Recognition) service through HTTP requests, including uploading files for OCR processing, making OCR requests, and retrieving results.\n\nFunction Description: The functions provide a client-side interface to communicate with an OCR service API, handling file uploads, processing requests, and result retrieval.\n\nInput:\n- ocr_upload():\n  - file_path: str - Path to the file to be processed\n  - ocr_cache: bool - Whether to cache the OCR results\n  - prompt: str - Optional prompt text for the OCR processing\n  - prompt_file: str - Optional path to a file containing the prompt\n  - model: str - Model to use for OCR (default: 'llama3.1')\n  - strategy: str - Processing strategy (default: 'llama_vision')\n  - storage_profile: str - Storage profile to use (default: 'default')\n  - storage_filename: str - Optional custom filename for storage\n  - language: str - Language for OCR processing (default: 'en')\n\n- ocr_request():\n  - file_path: str - Path to the file to be processed\n  - ocr_cache: bool - Whether to cache the OCR results\n  - prompt: str - Optional prompt text for the OCR processing\n  - prompt_file: str - Optional path to a file containing the prompt\n  - model: str - Model to use for OCR (default: 'llama3.1')\n  - strategy: str - Processing strategy (default: 'llama_vision')\n  - storage_profile: str - Storage profile to use (default: 'default')\n  - storage_filename: str - Optional custom filename for storage\n  - language: str - Language for OCR processing (default: 'en')\n\n- get_result():\n  - task_id: str - The task ID returned from upload/request\n  - print_progress: bool - Whether to print progress updates (default: False)\n\nOutput:\n- ocr_upload() and ocr_request():\n  - Returns: dict - Either contains 'task_id' for async processing or 'text' for immediate results\n  - Returns None on failure\n\n- get_result():\n  - Returns: dict - The final OCR result when state is 'SUCCESS'\n  - Returns None if task failed or encountered errors",
  "Canonical_solution": "import os\nimport requests\nimport base64\n\ndef ocr_upload(file_path, ocr_cache, prompt, prompt_file=None, model='llama3.1', strategy='llama_vision', storage_profile='default', storage_filename=None, language='en'):\n    ocr_url = os.getenv('OCR_UPLOAD_URL', 'http://localhost:8000/ocr/upload')\n    files = {'file': open(file_path, 'rb')}\n    data = {'ocr_cache': ocr_cache, 'model': model, 'strategy': strategy, 'storage_profile': storage_profile, 'language': language}\n\n    if storage_filename:\n        data['storage_filename'] = storage_filename\n    \n    try:\n        if prompt_file:\n            prompt = open(prompt_file, 'r').read()\n    except FileNotFoundError:\n        print(f\"Prompt file not found: {prompt_file}\")\n        return None\n    \n    if prompt:\n        data['prompt'] = prompt\n\n    response = requests.post(ocr_url, files=files, data=data)\n    if response.status_code == 200:\n        respObject = response.json()\n        if respObject.get('task_id'):\n            return {\n                \"task_id\": respObject.get('task_id')\n            }\n        else:\n            return {\n                \"text\": respObject.get('text')\n            }\n    else:\n        print(f\"Failed to upload file: {response.text}\")\n        return None\n\ndef ocr_request(file_path, ocr_cache, prompt, prompt_file=None, model='llama3.1', strategy='llama_vision', storage_profile='default', storage_filename=None, language='en'):\n    ocr_url = os.getenv('OCR_REQUEST_URL', 'http://localhost:8000/ocr/request')\n    with open(file_path, 'rb') as f:\n        file_content = base64.b64encode(f.read()).decode('utf-8')\n    \n    data = {\n        'ocr_cache': ocr_cache,\n        'model': model,\n        'strategy': strategy,\n        'storage_profile': storage_profile,\n        'file': file_content,\n        'language': language\n    }\n\n    if storage_filename:\n        data['storage_filename'] = storage_filename\n    \n    if prompt_file:\n        try:\n            prompt = open(prompt_file, 'r').read()\n        except FileNotFoundError:\n            print(f\"Prompt file not found: {prompt_file}\")\n            return None\n    \n    if prompt:\n        data['prompt'] = prompt\n    \n    response = requests.post(ocr_url, json=data)\n    if response.status_code == 200:\n        respObject = response.json()\n        if respObject.get('task_id'):\n            return {\n                \"task_id\": respObject.get('task_id')\n            }\n        else:\n            return {\n                \"text\": respObject.get('text')\n            }\n    else:\n        print(f\"Error: {response.status_code} - {response.text}\")\n        return None\n\ndef get_result(task_id, print_progress = False):\n    extracted_text_printed_once = False\n    result_url = os.getenv('RESULT_URL', f'http://localhost:8000/ocr/result/')\n    while True:\n        response = requests.get(result_url + task_id)\n        result = response.json()\n        if result['state'] != 'SUCCESS' and print_progress:\n            task_info = result.get('info')\n            if task_info is not None:\n                if task_info.get('extracted_text'):\n                    if not extracted_text_printed_once:\n                        extracted_text_printed_once = True\n                        print(\"Extracted text: \" + task_info.get('extracted_text'))\n                    else:\n                        del task_info['extracted_text']\n                del task_info['start_time']\n            print(result)\n        if response.status_code == 200:\n            if result['state'] == 'SUCCESS':\n                return result['result']\n            elif result['state'] == 'FAILURE':\n                print(\"OCR task failed.\")\n                return None\n        time.sleep(2)",
  "FSMID_for_test": 57,
  "Code_level": "Function-level"
}