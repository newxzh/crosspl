{
  "Task_id": 292,
  "Github_ID": "157110528",
  "Github_Project_Name": "USBMap",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "Pipe based on subprocess in python",
  "Instruction": "Task Description: Create a Python class that facilitates executing system commands with options for streaming output, sudo execution, and handling both string and list-based commands.\n\nClass Description: The ProcessRunner class provides a flexible way to execute system commands with various configurations. It handles command execution with options for streaming output in real-time, sudo privileges, and supports both string and list-formatted commands. The class manages subprocess creation, output capture, error handling, and return code collection.\n\nAttributes:\n- None (This class doesn't maintain persistent attributes between method calls)\n\nMethods:\n- _read_output(pipe, q) -> None - Private method that continuously reads from a pipe and puts data into a queue for output streaming.\n- _stream_output(comm, shell) -> tuple - Executes a command with streaming output capability, returns (stdout, stderr, returncode).\n- _decode(value) -> str - Helper method to decode byte strings to unicode (Python 3 compatibility).\n- _run_command(comm, shell) -> tuple - Executes a command and returns output after completion, returns (stdout, stderr, returncode).\n- execute(command_list, leave_on_fail) -> tuple/list - Main interface for command execution, handles multiple commands with various options. Returns single result tuple or list of tuples depending on input.\n\nInput Parameters:\n- For execute():\n  - command_list: dict/list - Either a single command dictionary or list of command dictionaries\n  - leave_on_fail: bool - Whether to stop execution if a command fails (default: False)\n- Command dictionary structure:\n  - args: list/str - The command to execute (either as list or string)\n  - shell: bool - Whether to use shell execution (default: False)\n  - stream: bool - Whether to stream output in real-time (default: False)\n  - sudo: bool - Whether to execute with sudo (default: False)\n\nOutput:\n- For single command: tuple (stdout_output, stderr_output, return_code)\n- For multiple commands: list of tuples [(stdout, stderr, returncode), ...]\n- On error: tuple (\"\", \"Command not found!\", 1)",
  "Canonical_solution": "import sys\nimport subprocess\nimport threading\nimport shlex\ntry:\n    from Queue import Queue, Empty\nexcept:\n    from queue import Queue, Empty\n\nON_POSIX = 'posix' in sys.builtin_module_names\n\nclass ProcessRunner:\n    def __init__(self):\n        pass\n\n    def _read_output(self, pipe, q):\n        try:\n            for line in iter(lambda: pipe.read(1), b''):\n                q.put(line)\n        except ValueError:\n            pass\n        pipe.close()\n\n    def _stream_output(self, comm, shell=False):\n        output = error = \"\"\n        p = ot = et = None\n        try:\n            if shell and type(comm) is list:\n                comm = \" \".join(shlex.quote(x) for x in comm)\n            if not shell and type(comm) is str:\n                comm = shlex.split(comm)\n            p = subprocess.Popen(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, \n                                bufsize=0, universal_newlines=True, close_fds=ON_POSIX)\n            \n            q = Queue()\n            t = threading.Thread(target=self._read_output, args=(p.stdout, q))\n            t.daemon = True\n            \n            qe = Queue()\n            te = threading.Thread(target=self._read_output, args=(p.stderr, qe))\n            te.daemon = True\n            \n            t.start()\n            te.start()\n\n            while True:\n                c = z = \"\"\n                try:\n                    c = q.get_nowait()\n                except Empty:\n                    pass\n                else:\n                    sys.stdout.write(c)\n                    output += c\n                    sys.stdout.flush()\n                try:\n                    z = qe.get_nowait()\n                except Empty:\n                    pass\n                else:\n                    sys.stderr.write(z)\n                    error += z\n                    sys.stderr.flush()\n                p.poll()\n                if c==z==\"\" and p.returncode != None:\n                    break\n\n            o, e = p.communicate()\n            return (output+o, error+e, p.returncode)\n        except:\n            if p:\n                return (output, error, p.returncode)\n            return (\"\", \"Command not found!\", 1)\n\n    def _decode(self, value):\n        if sys.version_info >= (3,0) and isinstance(value, bytes):\n            return value.decode(\"utf-8\",\"ignore\")\n        return value\n\n    def _run_command(self, comm, shell=False):\n        try:\n            if shell and type(comm) is list:\n                comm = \" \".join(shlex.quote(x) for x in comm)\n            if not shell and type(comm) is str:\n                comm = shlex.split(comm)\n            p = subprocess.Popen(comm, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            c = p.communicate()\n            return (self._decode(c[0]), self._decode(c[1]), p.returncode)\n        except:\n            return (\"\", \"Command not found!\", 1)\n\n    def execute(self, command_list, leave_on_fail=False):\n        if type(command_list) is dict:\n            command_list = [command_list]\n        output_list = []\n        for comm in command_list:\n            args = comm.get(\"args\", [])\n            shell = comm.get(\"shell\", False)\n            stream = comm.get(\"stream\", False)\n            sudo = comm.get(\"sudo\", False)\n            \n            if not len(args):\n                continue\n                \n            if sudo:\n                out = self._run_command([\"which\", \"sudo\"])\n                if \"sudo\" in out[0]:\n                    if type(args) is list:\n                        args.insert(0, out[0].replace(\"\\n\", \"\"))\n                    elif type(args) is str:\n                        args = out[0].replace(\"\\n\", \"\") + \" \" + args\n\n            if stream:\n                out = self._stream_output(args, shell)\n            else:\n                out = self._run_command(args, shell)\n                \n            output_list.append(out)\n            if leave_on_fail and out[2] != 0:\n                break\n                \n        return output_list[0] if len(output_list) == 1 else output_list",
  "FSMID_for_test": 76,
  "Code_level": "Class-level"
}