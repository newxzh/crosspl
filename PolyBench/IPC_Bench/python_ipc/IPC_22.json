{
  "Task_id": 22,
  "Github_ID": "74162540",
  "Github_Project_Name": "whatsapp-framework",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client - side by using http.client in python",
  "Instruction": "Task Description: Implement a class for handling HTTP requests to a server, supporting both GET and POST methods, with optional proxy support and response parsing capabilities.\n\nClass Description: WARequest is a class designed to facilitate HTTP communication with a server. It provides methods for sending GET and POST requests, handling response parsing, and managing request parameters and headers. The class supports both direct connections and proxy connections.\n\nAttributes:\n\npvars: [list] - List of variables that can be parsed from the response\nport: [int] - Port number for the HTTP connection (default: 443)\ntype: [str] - HTTP request type (GET or POST)\nparser: [ResponseParser] - Parser object for processing the response\nparams: [list] - List of tuples containing request parameters\nheaders: [dict] - Dictionary of HTTP headers to be sent with the request\nsent: [bool] - Flag indicating if the request has been sent\nresponse: [HTTPResponse] - The response object from the server\nurl: [str] - The target URL for the request\n\nMethods:\n\nsetParsableVariables: [setParsableVariables](pvars: list) -> None - Sets the list of variables that can be parsed from the response\naddParam: [addParam](name: str, value: str) -> None - Adds a parameter to the request\nremoveParam: [removeParam](name: str) -> None - Removes a parameter from the request\naddHeaderField: [addHeaderField](name: str, value: str) -> None - Adds a header field to the request\nclearParams: [clearParams]() -> None - Clears all request parameters\ngetUserAgent: [getUserAgent]() -> str - Returns the user agent string\nsend: [send](parser: ResponseParser = None) -> dict - Sends the request (GET or POST based on type) and returns parsed response\nsetParser: [setParser](parser: ResponseParser) -> None - Sets the response parser\ngetConnectionParameters: [getConnectionParameters]() -> tuple - Returns host, port, and path from the URL\nsendGetRequest: [sendGetRequest](parser: ResponseParser = None) -> dict - Sends a GET request and returns parsed response\nsendPostRequest: [sendPostRequest](parser: ResponseParser = None) -> dict - Sends a POST request and returns parsed response\nsendRequest: [sendRequest](host: str, port: int, path: str, headers: dict, params: list, reqType: str = \"GET\") -> HTTPResponse - Static method to send a direct HTTP request\nsendRequestWithProxy: [sendRequestWithProxy](host: str, port: int, path: str, headers: dict, params: list, proxy: HttpProxy) -> dict - Static method to send a request through a proxy\nbuild_get_url: [build_get_url](host: str, path: str, params: list) -> str - Static method to build a GET URL\nbuild_headers: [build_headers](headers_tuple: dict) -> list - Static method to convert headers dictionary to curl format",
  "Canonical_solution": "import urllib\nimport sys\nimport os\nimport logging\nfrom http import client as httplib\nfrom urllib.parse import urlencode\nfrom .httpproxy import HttpProxy\nfrom yowsup.env import YowsupEnv\n\nlogger = logging.getLogger(__name__)\n\nclass WARequest:\n    OK = 200\n\n    def __init__(self):\n        self.pvars = []\n        self.port = 443\n        self.type = \"GET\"\n        self.parser = None\n        self.params = []\n        self.headers = {}\n        self.sent = False\n        self.response = None\n\n    def setParsableVariables(self, pvars):\n        self.pvars = pvars\n\n    def addParam(self, name, value):\n        self.params.append((name, value))\n\n    def removeParam(self, name):\n        for i in range(0, len(self.params)):\n            if self.params[i][0] == name:\n                del self.params[i]\n\n    def addHeaderField(self, name, value):\n        self.headers[name] = value\n\n    def clearParams(self):\n        self.params = []\n\n    def getUserAgent(self):\n        return YowsupEnv.getCurrent().getUserAgent()\n\n    def send(self, parser=None):\n        if self.type == \"POST\":\n            return self.sendPostRequest(parser)\n        return self.sendGetRequest(parser)\n\n    def setParser(self, parser):\n        if isinstance(parser, ResponseParser):\n            self.parser = parser\n        else:\n            logger.error(\"Invalid parser\")\n\n    def getConnectionParameters(self):\n        if not self.url:\n            return \"\", \"\", self.port\n\n        try:\n            url = self.url.split(\"://\", 1)\n            url = url[0] if len(url) == 1 else url[1]\n            host, path = url.split('/', 1)\n        except ValueError:\n            host = url\n            path = \"\"\n\n        path = \"/\" + path\n        return host, self.port, path\n\n    def sendGetRequest(self, parser=None):\n        self.response = None\n        params = self.params\n        parser = parser or self.parser or ResponseParser()\n        headers = dict(list({\"User-Agent\": self.getUserAgent(),\n                           \"Accept\": parser.getMeta()\n                          }.items()) + list(self.headers.items()))\n\n        host, port, path = self.getConnectionParameters()\n        proxy = HttpProxy.getFromEnviron()\n        if proxy is None:\n            self.response = WARequest.sendRequest(host, port, path, headers, params, \"GET\")\n            if not self.response.status == WARequest.OK:\n                logger.error(\"Request not success, status was %s\" % self.response.status)\n                return {}\n\n            data = self.response.read()\n            logger.info(data)\n            self.sent = True\n            return parser.parse(data.decode(), self.pvars)\n        else:\n            logger.info(\"Request with proxy\")\n            self.response = WARequest.sendRequestWithProxy(host, port, path, headers, params, proxy)\n            logger.info(self.response)\n            return self.response\n\n    def sendPostRequest(self, parser=None):\n        self.response = None\n        params = self.params\n        parser = parser or self.parser or ResponseParser()\n        headers = dict(list({\"User-Agent\": self.getUserAgent(),\n                           \"Accept\": parser.getMeta(),\n                           \"Content-Type\": \"application/x-www-form-urlencoded\"\n                          }.items()) + list(self.headers.items()))\n\n        host, port, path = self.getConnectionParameters()\n        self.response = WARequest.sendRequest(host, port, path, headers, params, \"POST\")\n\n        if not self.response.status == WARequest.OK:\n            logger.error(\"Request not success, status was %s\" % self.response.status)\n            return {}\n\n        data = self.response.read()\n        logger.info(data)\n        self.sent = True\n        return parser.parse(data.decode(), self.pvars)\n\n    @staticmethod\n    def sendRequest(host, port, path, headers, params, reqType=\"GET\"):\n        params = urlencode(params)\n        path = path + \"?\" + params if reqType == \"GET\" and params else path\n\n        if len(headers):\n            logger.debug(headers)\n        if len(params):\n            logger.debug(params)\n\n        logger.debug(\"Opening connection to %s\" % host)\n        conn = httplib.HTTPSConnection(host, port) if port == 443 else httplib.HTTPConnection(host, port)\n\n        logger.debug(\"Sending %s request to %s\" % (reqType, path))\n        conn.request(reqType, path, params, headers)\n        response = conn.getresponse()\n        return response\n\n    @staticmethod\n    def sendRequestWithProxy(host, port, path, headers, params, proxy):\n        import pycurl\n        import json\n        from io import BytesIO\n        logger.info(\"SENDING PROXY REQUEST WITH %s\" % proxy.getHost())\n        bytes_buffer = BytesIO()\n        c = pycurl.Curl()\n        c.setopt(pycurl.URL, WARequest.build_get_url(host, path, params))\n        c.setopt(pycurl.PROXY, proxy.getHost())\n        c.setopt(pycurl.PROXYPORT, proxy.getPort())\n        if proxy.getUserName() is not None:\n            c.setopt(pycurl.PROXYUSERPWD, \"%s:%s\" % (proxy.getUser(), proxy.getPassword()))\n        c.setopt(pycurl.PORT, port)\n        c.setopt(pycurl.HTTPHEADER, WARequest.build_headers(headers))\n        c.setopt(pycurl.WRITEDATA, bytes_buffer)\n        c.perform()\n        c.close()\n        data = bytes_buffer.getvalue().decode('utf-8')\n        return json.loads(data)\n\n    @staticmethod\n    def build_get_url(host, path, params):\n        params = urlencode(params)\n        url = 'https://' + host + path + \"?\" + params\n        return url\n\n    @staticmethod\n    def build_headers(headers_tuple):\n        headers_array = []\n        for idx in headers_tuple:\n            headers_array.append(idx + \":\" + headers_tuple[idx])\n        return headers_array",
  "FSMID_for_test": 56,
  "Code_level": "Class-level"
}