{
  "Task_id": 31,
  "Github_ID": "8768978",
  "Github_Project_Name": "python-bitcoinlib",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client - side by using http.client in python",
  "Instruction": "Task Description: Create a Python class that implements an HTTP client for making JSON-RPC requests to a server, handling authentication, connection management, and response processing.\n\nClass Description: The BaseProxy class provides functionality to establish HTTP/HTTPS connections to a JSON-RPC server, send requests with proper authentication, and process responses. It handles connection lifecycle, request formatting, error handling, and response parsing.\n\nAttributes:\n\n__conn: [httplib.HTTPConnection or httplib.HTTPSConnection] - The underlying HTTP connection object\n__service_url: [str] - The complete service URL including protocol, host, port, and path\n__url: [urllib.parse.ParseResult] - Parsed URL components of the service URL\n__id_count: [int] - Counter for JSON-RPC request IDs\n__auth_header: [bytes or None] - Basic authentication header if credentials are provided\n\nMethods:\n\n__init__: [constructor](service_url=None, service_port=None, btc_conf_file=None, timeout=DEFAULT_HTTP_TIMEOUT, connection=None) -> [None] - Initializes the proxy with connection parameters, parses the URL, and sets up authentication\n_call: [_call](service_name, *args) -> [Any] - Makes a JSON-RPC call to the specified service method with given arguments\n_get_response: [_get_response]() -> [dict] - Retrieves and parses the HTTP response from the server\nclose: [close]() -> [None] - Closes the active connection\n__del__: [destructor]() -> [None] - Ensures connection is closed when the object is destroyed",
  "Canonical_solution": "import http.client as httplib\nimport base64\nimport json\nimport urllib.parse as urlparse\n\nDEFAULT_USER_AGENT = \"AuthServiceProxy/0.1\"\nDEFAULT_HTTP_TIMEOUT = 30\n\nclass BaseProxy:\n    def __init__(self, service_url=None, service_port=None, btc_conf_file=None, timeout=DEFAULT_HTTP_TIMEOUT, connection=None):\n        self.__conn = None\n        authpair = None\n\n        if service_url is None:\n            # Configuration and URL setup logic omitted for brevity\n            pass\n        else:\n            url = urlparse.urlparse(service_url)\n            authpair = \"%s:%s\" % (url.username, url.password)\n\n        self.__service_url = service_url\n        self.__url = urlparse.urlparse(service_url)\n\n        if self.__url.scheme not in ('http', 'https'):\n            raise ValueError('Unsupported URL scheme %r' % self.__url.scheme)\n\n        if self.__url.port is None:\n            port = httplib.HTTPS_PORT if self.__url.scheme == 'https' else httplib.HTTP_PORT\n        else:\n            port = self.__url.port\n        self.__id_count = 0\n\n        if authpair is None:\n            self.__auth_header = None\n        else:\n            authpair = authpair.encode('utf8')\n            self.__auth_header = b\"Basic \" + base64.b64encode(authpair)\n\n        if connection:\n            self.__conn = connection\n        else:\n            if self.__url.scheme == 'https':\n                self.__conn = httplib.HTTPSConnection(self.__url.hostname, port=port, timeout=timeout)\n            else:\n                self.__conn = httplib.HTTPConnection(self.__url.hostname, port=port, timeout=timeout)\n\n    def _call(self, service_name, *args):\n        self.__id_count += 1\n\n        postdata = json.dumps({\n            'version': '1.1',\n            'method': service_name,\n            'params': args,\n            'id': self.__id_count\n        })\n\n        headers = {\n            'Host': self.__url.hostname,\n            'User-Agent': DEFAULT_USER_AGENT,\n            'Content-type': 'application/json',\n        }\n\n        if self.__auth_header is not None:\n            headers['Authorization'] = self.__auth_header\n\n        self.__conn.request('POST', self.__url.path, postdata, headers)\n        response = self._get_response()\n        \n        err = response.get('error')\n        if err is not None:\n            if isinstance(err, dict):\n                raise JSONRPCError({\n                    'code': err.get('code', -345),\n                    'message': err.get('message', 'error message not specified')\n                })\n            raise JSONRPCError({'code': -344, 'message': str(err)})\n        elif 'result' not in response:\n            raise JSONRPCError({\n                'code': -343, 'message': 'missing JSON-RPC result'\n            })\n        else:\n            return response['result']\n\n    def _get_response(self):\n        http_response = self.__conn.getresponse()\n        if http_response is None:\n            raise JSONRPCError({\n                'code': -342, 'message': 'missing HTTP response from server'\n            })\n\n        rdata = http_response.read().decode('utf8')\n        try:\n            return json.loads(rdata)\n        except Exception:\n            raise JSONRPCError({\n                'code': -342,\n                'message': ('non-JSON HTTP response with \\'%i %s\\' from server: \\'%.20s%s\\''\n                            % (http_response.status, http_response.reason,\n                               rdata, '...' if len(rdata) > 20 else ''))\n            })\n\n    def close(self):\n        if self.__conn is not None:\n            self.__conn.close()\n\n    def __del__(self):\n        if self.__conn is not None:\n            self.__conn.close()",
  "FSMID_for_test": 56,
  "Code_level": "Class-level"
}