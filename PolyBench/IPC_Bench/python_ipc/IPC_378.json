{
  "Task_id": 378,
  "Github_ID": "173708338",
  "Github_Project_Name": "podman-compose",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server - side by using socket in python",
  "Instruction": "Task Description: Implement a mock SSH agent that simulates the behavior of a real SSH agent, handling client requests for key management and authentication. The agent should support Unix domain sockets for IPC and provide functionality to start, stop, and manage client connections.\n\nClass Description: The `MockSSHAgent` class simulates an SSH agent that can load an ED25519 private key, handle client connections, and respond to SSH agent protocol requests. It uses threading to handle multiple clients and supports graceful shutdown.\n\nAttributes:\n\n- `sock_path`: [str] - The path to the Unix domain socket used for communication.\n- `server_sock`: [socket.socket] - The server socket object for accepting client connections.\n- `running`: [threading.Event] - A threading event to control the agent's running state.\n- `keys`: [list] - A list of tuples containing key information (key_type, key_blob, comment).\n- `agent_thread`: [threading.Thread] - The thread handling client connections.\n\nMethods:\n\n- `_load_ed25519_private_key(private_key_path: str) -> tuple`: Loads an ED25519 private key from a file and returns a tuple containing key information (key_type, key_blob, comment).\n- `start_agent(sock_path: str) -> None`: Starts the SSH agent by creating a Unix domain socket, binding it, and listening for client connections. Sets the `SSH_AUTH_SOCK` environment variable.\n- `_accept_connections() -> None`: Continuously accepts client connections and delegates handling to `_handle_client`.\n- `_handle_client(client_sock: socket.socket) -> None`: Handles a client connection by processing incoming messages and sending appropriate responses.\n- `_mock_list_keys_response() -> bytes`: Constructs a mock response to the `SSH_AGENTC_REQUEST_IDENTITIES` request.\n- `stop_agent() -> None`: Stops the SSH agent by sending a stop command, cleaning up resources, and removing the socket file.",
  "Canonical_solution": "import os\nimport socket\nimport struct\nimport threading\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey\n\nSSH_AGENTC_REQUEST_IDENTITIES = 11\nSSH_AGENT_IDENTITIES_ANSWER = 12\nSSH_AGENT_FAILURE = 5\nSTOP_REQUEST = 0xFF\n\nclass MockSSHAgent:\n    def __init__(self, private_key_path):\n        self.sock_path = None\n        self.server_sock = None\n        self.running = threading.Event()\n        self.keys = [self._load_ed25519_private_key(private_key_path)]\n        self.agent_thread = None\n\n    def _load_ed25519_private_key(self, private_key_path):\n        with open(private_key_path, 'rb') as key_file:\n            private_key = serialization.load_ssh_private_key(key_file.read(), password=None)\n\n        if not isinstance(private_key, Ed25519PrivateKey):\n            raise ValueError(\"Invalid key type, expected ED25519 private key.\")\n\n        public_key = private_key.public_key()\n        public_key_blob = public_key.public_bytes(\n            encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw\n        )\n\n        key_type = b\"ssh-ed25519\"\n        key_blob_full = (\n            struct.pack(\">I\", len(key_type))\n            + key_type\n            + struct.pack(\">I\", len(public_key_blob))\n            + public_key_blob\n        )\n\n        comment = \"\"\n        return (\"ssh-ed25519\", key_blob_full, comment)\n\n    def start_agent(self, sock_path):\n        self.sock_path = sock_path\n        if os.path.exists(self.sock_path):\n            os.remove(self.sock_path)\n\n        self.server_sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        self.server_sock.bind(self.sock_path)\n        self.server_sock.listen(5)\n\n        os.environ['SSH_AUTH_SOCK'] = self.sock_path\n        self.running.set()\n\n        self.agent_thread = threading.Thread(target=self._accept_connections, daemon=True)\n        self.agent_thread.start()\n\n    def _accept_connections(self):\n        while self.running.is_set():\n            try:\n                client_sock, _ = self.server_sock.accept()\n                self._handle_client(client_sock)\n            except Exception as e:\n                print(f\"Error accepting connection: {e}\")\n\n    def _handle_client(self, client_sock):\n        try:\n            length_message = client_sock.recv(4)\n            if not length_message:\n                raise \"no length message received\"\n\n            msg_len = struct.unpack(\">I\", length_message)[0]\n            request_message = client_sock.recv(msg_len)\n\n            if request_message[0] == STOP_REQUEST:\n                client_sock.close()\n                self.running.clear()\n                return\n\n            if request_message[0] == SSH_AGENTC_REQUEST_IDENTITIES:\n                response = self._mock_list_keys_response()\n                client_sock.sendall(response)\n            else:\n                response = struct.pack(\">I\", 1) + struct.pack(\">B\", SSH_AGENT_FAILURE)\n                client_sock.sendall(response)\n\n        except socket.error:\n            pass\n        finally:\n            client_sock.close()\n\n    def _mock_list_keys_response(self):\n        response = struct.pack(\">B\", SSH_AGENT_IDENTITIES_ANSWER)\n        response += struct.pack(\">I\", len(self.keys))\n\n        for key_type, key_blob, comment in self.keys:\n            response += struct.pack(\">I\", len(key_blob)) + key_blob\n            comment_encoded = comment.encode()\n            response += struct.pack(\">I\", len(comment_encoded)) + comment_encoded\n\n        response = struct.pack(\">I\", len(response)) + response\n        return response\n\n    def stop_agent(self):\n        if self.running.is_set():\n            with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as client_sock:\n                client_sock.connect(self.sock_path)\n                stop_command = struct.pack(\">B\", STOP_REQUEST)\n                message_length = struct.pack(\">I\", len(stop_command))\n                client_sock.sendall(message_length)\n                client_sock.sendall(stop_command)\n\n            self.running.clear()\n\n            if self.agent_thread:\n                self.agent_thread.join()\n                self.agent_thread = None\n\n            if self.server_sock:\n                self.server_sock.close()\n                os.remove(self.sock_path)",
  "FSMID_for_test": 66,
  "Code_level": "Class-level"
}