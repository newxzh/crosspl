{
  "Task_id": 318,
  "Github_ID": "98542246",
  "Github_Project_Name": "shadowsocksr",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client - side by using socket in python",
  "Instruction": "Task Description: Implement a TCP relay handler class that manages communication between a local client and a remote server, handling socket connections, data encryption, and protocol obfuscation.\n\nClass Description: The TCPRelayHandler class is responsible for managing the relay of TCP traffic between a local client and a remote server. It handles socket creation, connection management, data encryption/decryption, and protocol obfuscation. The class integrates with an event loop for asynchronous I/O operations.\n\nAttributes:\n- _server: [object] - Reference to the parent server instance\n- _fd_to_handlers: [dict] - Mapping of file descriptors to handler instances\n- _loop: [object] - Event loop instance for I/O multiplexing\n- _local_sock: [socket.socket] - Local client socket\n- _remote_sock: [socket.socket] - Remote server socket (IPv4)\n- _remote_sock_v6: [socket.socket] - Remote server socket (IPv6)\n- _remote_udp: [bool] - Flag indicating UDP mode\n- _config: [dict] - Configuration parameters\n- _dns_resolver: [object] - DNS resolver instance\n- _is_local: [bool] - Flag indicating local mode\n- _stage: [int] - Current connection stage\n- _encryptor: [object] - Encryption handler\n- _encrypt_correct: [bool] - Encryption status flag\n- _obfs: [object] - Obfuscation handler\n- _protocol: [object] - Protocol handler\n- _fastopen_connected: [bool] - TCP Fast Open status\n- _data_to_write_to_local: [list] - Buffer for data to local client\n- _data_to_write_to_remote: [list] - Buffer for data to remote server\n- _udp_data_send_buffer: [bytes] - UDP data buffer\n- _upstream_status: [int] - Upstream connection status\n- _downstream_status: [int] - Downstream connection status\n- _client_address: [tuple] - Local client address\n- _remote_address: [tuple] - Remote server address\n- _forbidden_iplist: [list] - List of blocked IP addresses\n- _chosen_server: [object] - Selected server instance\n- last_activity: [int] - Timestamp of last activity\n\nMethods:\n- __init__(server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local) -> None - Initializes the handler with server configuration and sockets\n- _create_remote_socket(ip, port) -> socket.socket - Creates and configures a remote socket connection\n- _write_to_sock(data, sock) -> bool - Writes data to a socket with encryption/obfuscation\n- destroy() -> None - Cleans up resources and closes all connections\n- _update_activity() -> None - Updates the last activity timestamp\n- _get_a_server() -> object - Selects an appropriate server from configuration\n- _handle_dns_resolved(result, error) -> None - Callback for DNS resolution\n- _update_stream(stream, status) -> None - Updates stream status in event loop\n- _on_local_read() -> None - Handles local socket read events\n- _on_remote_read() -> None - Handles remote socket read events\n- _on_local_write() -> None - Handles local socket write events\n- _on_remote_write() -> None - Handles remote socket write events",
  "Canonical_solution": "import socket\nimport errno\nimport struct\nimport logging\nimport binascii\nimport traceback\nimport random\nfrom shadowsocks import encrypt, obfs, eventloop, shell, common\nfrom shadowsocks.common import pre_parse_header, parse_header\n\nclass TCPRelayHandler:\n    def __init__(self, server, fd_to_handlers, loop, local_sock, config, dns_resolver, is_local):\n        self._server = server\n        self._fd_to_handlers = fd_to_handlers\n        self._loop = loop\n        self._local_sock = local_sock\n        self._remote_sock = None\n        self._remote_sock_v6 = None\n        self._remote_udp = False\n        self._config = config\n        self._dns_resolver = dns_resolver\n        self._is_local = is_local\n        self._stage = STAGE_INIT\n        self._encryptor = encrypt.Encryptor(config['password'], config['method'])\n        self._encrypt_correct = True\n        self._obfs = obfs.obfs(config['obfs'])\n        server_info = obfs.server_info(server.obfs_data)\n        server_info.host = config['server']\n        server_info.port = server._listen_port\n        server_info.tcp_mss = 1440\n        server_info.param = config['obfs_param']\n        self._obfs.set_server_info(server_info)\n        self._protocol = obfs.obfs(config['protocol'])\n        server_info = obfs.server_info(server.protocol_data)\n        server_info.host = config['server']\n        server_info.port = server._listen_port\n        server_info.tcp_mss = 1440\n        server_info.param = ''\n        self._protocol.set_server_info(server_info)\n        self._fastopen_connected = False\n        self._data_to_write_to_local = []\n        self._data_to_write_to_remote = []\n        self._udp_data_send_buffer = b''\n        self._upstream_status = WAIT_STATUS_READING\n        self._downstream_status = WAIT_STATUS_INIT\n        self._client_address = local_sock.getpeername()[:2]\n        self._remote_address = None\n        if 'forbidden_ip' in config:\n            self._forbidden_iplist = config['forbidden_ip']\n        else:\n            self._forbidden_iplist = None\n        if is_local:\n            self._chosen_server = self._get_a_server()\n        fd_to_handlers[local_sock.fileno()] = self\n        local_sock.setblocking(False)\n        local_sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)\n        loop.add(local_sock, eventloop.POLL_IN | eventloop.POLL_ERR, self._server)\n        self.last_activity = 0\n        self._update_activity()\n        self._server.add_connection(1)\n\n    def _create_remote_socket(self, ip, port):\n        if self._remote_udp:\n            addrs_v6 = socket.getaddrinfo(\"::\", 0, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n            addrs = socket.getaddrinfo(\"0.0.0.0\", 0, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n        else:\n            addrs = socket.getaddrinfo(ip, port, 0, socket.SOCK_STREAM, socket.SOL_TCP)\n        if len(addrs) == 0:\n            raise Exception(\"getaddrinfo failed for %s:%d\" % (ip, port))\n        af, socktype, proto, canonname, sa = addrs[0]\n        if self._forbidden_iplist:\n            if common.to_str(sa[0]) in self._forbidden_iplist:\n                raise Exception('IP %s is in forbidden list, reject' % common.to_str(sa[0]))\n        remote_sock = socket.socket(af, socktype, proto)\n        self._remote_sock = remote_sock\n        self._fd_to_handlers[remote_sock.fileno()] = self\n\n        if self._remote_udp:\n            af, socktype, proto, canonname, sa = addrs_v6[0]\n            remote_sock_v6 = socket.socket(af, socktype, proto)\n            self._remote_sock_v6 = remote_sock_v6\n            self._fd_to_handlers[remote_sock_v6.fileno()] = self\n            remote_sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 32)\n            remote_sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1024 * 32)\n            remote_sock_v6.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 32)\n            remote_sock_v6.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1024 * 32)\n\n        remote_sock.setblocking(False)\n        if self._remote_udp:\n            remote_sock_v6.setblocking(False)\n        else:\n            remote_sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)\n        return remote_sock\n\n    def _write_to_sock(self, data, sock):\n        if not sock:\n            return False\n        uncomplete = False\n        if self._remote_udp and sock == self._remote_sock:\n            try:\n                self._udp_data_send_buffer += data\n                while len(self._udp_data_send_buffer) > 6:\n                    length = struct.unpack('>H', self._udp_data_send_buffer[:2])[0]\n                    if length > len(self._udp_data_send_buffer):\n                        break\n                    data = self._udp_data_send_buffer[:length]\n                    self._udp_data_send_buffer = self._udp_data_send_buffer[length:]\n                    frag = common.ord(data[2])\n                    if frag != 0:\n                        logging.warn('drop a message since frag is %d' % (frag,))\n                        continue\n                    else:\n                        data = data[3:]\n                    header_result = parse_header(data)\n                    if header_result is None:\n                        continue\n                    connecttype, dest_addr, dest_port, header_length = header_result\n                    addrs = socket.getaddrinfo(dest_addr, dest_port, 0, socket.SOCK_DGRAM, socket.SOL_UDP)\n                    if addrs:\n                        af, socktype, proto, canonname, server_addr = addrs[0]\n                        data = data[header_length:]\n                        if af == socket.AF_INET6:\n                            self._remote_sock_v6.sendto(data, (server_addr[0], dest_port))\n                        else:\n                            sock.sendto(data, (server_addr[0], dest_port))\n            except Exception as e:\n                error_no = eventloop.errno_from_exception(e)\n                if error_no in (errno.EAGAIN, errno.EINPROGRESS, errno.EWOULDBLOCK):\n                    uncomplete = True\n                else:\n                    shell.print_exception(e)\n                    self.destroy()\n                    return False\n            return True\n        else:\n            try:\n                if self._is_local:\n                    pass\n                else:\n                    if sock == self._local_sock and self._encrypt_correct:\n                        obfs_encode = self._obfs.server_encode(data)\n                        data = obfs_encode\n                if data:\n                    l = len(data)\n                    s = sock.send(data)\n                    if s < l:\n                        data = data[s:]\n                        uncomplete = True\n                else:\n                    return\n            except (OSError, IOError) as e:\n                error_no = eventloop.errno_from_exception(e)\n                if error_no in (errno.EAGAIN, errno.EINPROGRESS, errno.EWOULDBLOCK):\n                    uncomplete = True\n                else:\n                    shell.print_exception(e)\n                    self.destroy()\n                    return False\n            except Exception as e:\n                shell.print_exception(e)\n                self.destroy()\n                return False\n        if uncomplete:\n            if sock == self._local_sock:\n                self._data_to_write_to_local.append(data)\n                self._update_stream(STREAM_DOWN, WAIT_STATUS_WRITING)\n            elif sock == self._remote_sock:\n                self._data_to_write_to_remote.append(data)\n                self._update_stream(STREAM_UP, WAIT_STATUS_WRITING)\n            else:\n                logging.error('write_all_to_sock:unknown socket')\n        else:\n            if sock == self._local_sock:\n                self._update_stream(STREAM_DOWN, WAIT_STATUS_READING)\n            elif sock == self._remote_sock:\n                self._update_stream(STREAM_UP, WAIT_STATUS_READING)\n            else:\n                logging.error('write_all_to_sock:unknown socket')\n        return True\n\n    def destroy(self):\n        if self._stage == STAGE_DESTROYED:\n            return\n        self._stage = STAGE_DESTROYED\n        if self._remote_sock:\n            try:\n                self._loop.remove(self._remote_sock)\n            except Exception as e:\n                pass\n            del self._fd_to_handlers[self._remote_sock.fileno()]\n            self._remote_sock.close()\n            self._remote_sock = None\n        if self._remote_sock_v6:\n            try:\n                self._loop.remove(self._remote_sock_v6)\n            except Exception as e:\n                pass\n            del self._fd_to_handlers[self._remote_sock_v6.fileno()]\n            self._remote_sock_v6.close()\n            self._remote_sock_v6 = None\n        if self._local_sock:\n            self._loop.remove(self._local_sock)\n            del self._fd_to_handlers[self._local_sock.fileno()]\n            self._local_sock.close()\n            self._local_sock = None\n        if self._obfs:\n            self._obfs.dispose()\n            self._obfs = None\n        if self._protocol:\n            self._protocol.dispose()\n            self._protocol = None\n        self._dns_resolver.remove_callback(self._handle_dns_resolved)\n        self._server.remove_handler(self)\n        self._server.add_connection(-1)",
  "FSMID_for_test": 67,
  "Code_level": "Class-level"
}