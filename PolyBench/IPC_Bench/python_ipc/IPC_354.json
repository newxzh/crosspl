{
  "Task_id": 354,
  "Github_ID": "34197682",
  "Github_Project_Name": "im_service",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client - side by using socket in python",
  "Instruction": "Task Description: Implement a TCP client class in Python that handles secure connections, message synchronization, and various types of message exchanges with a server.\n\nClass Description: The Client class represents a TCP client that connects to a server, authenticates, sends and receives messages, and handles message synchronization. It supports both plain and SSL-encrypted connections.\n\nAttributes:\n- seq: [int] - Sequence number for message tracking\n- sock: [socket.socket] - Socket object for server communication\n- sync_key: [int] - Current synchronization key\n- syncing: [bool] - Flag indicating if synchronization is in progress\n- sync_timestamp: [int] - Timestamp of last synchronization attempt\n- next_sync_key: [int] - Next synchronization key to use\n\nMethods:\n- __init__() -> [None] - Initializes the client with default values\n- connect_server(device_id: str, token: str, host: str=None, port: int=24430, use_ssl: bool=True) -> [bool] - Connects to the server, authenticates using device ID and token, and returns connection status\n- close() -> [None] - Closes the connection with the server\n- recv_message() -> [tuple] - Receives messages from server and handles timeouts with ping messages\n- handle_message(cmd: int, s: int, m: any) -> [None] - Handles different types of incoming messages and triggers appropriate actions\n- ack_message(s: int) -> [None] - Sends acknowledgment for received messages\n- send_peer_message(msg: any) -> [None] - Sends a peer-to-peer message to the server\n- send_group_message(msg: any) -> [None] - Sends a group message to the server\n- send_sync() -> [None] - Initiates synchronization with the server\n- send_sync_key() -> [None] - Sends current synchronization key to the server",
  "Canonical_solution": "import struct\nimport socket\nimport select\nimport ssl\n\nclass Client:\n    def __init__(self):\n        self.seq = 0\n        self.sock = None\n        self.sync_key = 0\n        self.syncing = False\n        self.sync_timestamp = 0\n        self.next_sync_key = 0\n\n    def connect_server(self, device_id, token, host=None, port=24430, use_ssl=True):\n        address = (host if host else \"imnode2.gobelieve.io\", port)\n        if use_ssl:\n            sock_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            context = ssl.create_default_context()\n            sock = context.wrap_socket(sock_fd, server_hostname=address[0])\n        else:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            \n        sock.connect(address)\n        auth = AuthenticationToken()\n        auth.token = token\n        auth.device_id = device_id\n        self.seq = self.seq + 1\n        send_message(MSG_AUTH_TOKEN, self.seq, auth, sock)\n        cmd, _, _, msg = recv_message(sock)\n        if cmd != MSG_AUTH_STATUS or msg != 0:\n            return False\n\n        self.sock = sock\n        return True\n\n    def close(self):\n        if self.sock:\n            self.sock.close()\n\n    def recv_message(self):\n        while True:\n            rlist, _, xlist = select.select([self.sock], [], [self.sock], 60)\n            if not rlist and not xlist:\n                self.seq += 1\n                send_message(MSG_PING, self.seq, None, self.sock)\n                continue\n            if xlist:\n                return 0, 0, None\n            if rlist:\n                cmd, s, _, m = recv_message(self.sock)\n                self.handle_message(cmd, s, m)\n                return cmd, s, m\n\n    def handle_message(self, cmd, s, m):\n        if cmd == MSG_IM:\n            self.ack_message(s)\n        elif cmd == MSG_GROUP_IM:\n            self.ack_message(s)\n        elif cmd == MSG_SYSTEM:\n            self.ack_message(s)\n        elif cmd == MSG_SYNC_NOTIFY:\n            new_sync_key = m\n            now = int(time.time())\n            if new_sync_key > self.sync_key and (not self.syncing or now - self.sync_timestamp > 3):\n                self.send_sync()\n                self.syncing = True\n                self.sync_timestamp = int(time.time())\n            elif new_sync_key > self.next_sync_key:\n                self.next_sync_key = new_sync_key\n        elif cmd == MSG_SYNC_END:\n            new_sync_key = m\n            if new_sync_key > self.sync_key:\n                self.sync_key = new_sync_key\n                self.send_sync_key()\n            self.syncing = False\n            if self.next_sync_key > self.sync_key:\n                self.send_sync()\n                self.syncing = True\n                self.sync_timestamp = int(time.time())\n                self.next_sync_key = 0\n\n    def ack_message(self, s):\n        self.seq += 1\n        send_message(MSG_ACK, self.seq, s, self.sock)\n\n    def send_peer_message(self, msg):\n        self.seq += 1\n        send_message(MSG_IM, self.seq, msg, self.sock)\n\n    def send_group_message(self, msg):\n        self.seq += 1\n        send_message(MSG_GROUP_IM, self.seq, msg, self.sock)\n\n    def send_sync(self):\n        self.seq += 1\n        send_message(MSG_SYNC, self.seq, self.sync_key, self.sock)\n\n    def send_sync_key(self):\n        self.seq += 1\n        send_message(MSG_SYNC_KEY, self.seq, self.sync_key, self.sock)",
  "FSMID_for_test": 67,
  "Code_level": "Class-level"
}