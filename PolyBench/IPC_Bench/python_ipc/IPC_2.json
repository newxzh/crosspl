{
  "Task_id": 2,
  "Github_ID": "685048844",
  "Github_Project_Name": "Adala",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "Async Kafka consumer in python",
  "Instruction": "Task Description: Create an asynchronous function that consumes messages from a Kafka topic, processes them in batches, and handles the results using a provided callback function. The function should handle connection retries and gracefully manage the consumer lifecycle.\n\nFunction Description: The function `async_process_streaming_output` asynchronously consumes messages from a specified Kafka topic, processes them in configurable batch sizes, and passes the processed data to a result handler function. It includes retry logic for topic availability and proper consumer startup/shutdown management.\n\nInput:\n- `input_done`: asyncio.Event - Event flag to signal when message consumption should stop\n- `output_topic_name`: str - Name of the Kafka topic to consume messages from\n- `result_handler`: Callable - Function to handle processed message batches\n- `batch_size`: int - Maximum number of records to fetch in each batch\n- `kafka_bootstrap_servers`: str - Comma-separated list of Kafka bootstrap servers\n- `kafka_output_consumer_timeout_ms`: int - Timeout in milliseconds for consumer operations\n\nOutput: None (The function runs continuously until the input_done event is set, processing messages through the result_handler callback)",
  "Canonical_solution": "import asyncio\nimport json\nimport time\nimport traceback\nfrom aiokafka import AIOKafkaConsumer\nfrom aiokafka.errors import UnknownTopicOrPartitionError\n\nasync def async_process_streaming_output(\n    input_done: asyncio.Event,\n    output_topic_name,\n    result_handler,\n    batch_size: int,\n    kafka_bootstrap_servers: str,\n    kafka_output_consumer_timeout_ms: int\n):\n    timeout_ms = kafka_output_consumer_timeout_ms\n\n    # Retry to workaround race condition of topic creation\n    retries = 5\n    while retries > 0:\n        try:\n            consumer = AIOKafkaConsumer(\n                output_topic_name,\n                bootstrap_servers=kafka_bootstrap_servers,\n                value_deserializer=lambda v: json.loads(v.decode(\"utf-8\")),\n                auto_offset_reset=\"earliest\",\n                max_partition_fetch_bytes=3000000,\n            )\n            await consumer.start()\n            break\n        except UnknownTopicOrPartitionError as e:\n            await consumer.stop()\n            retries -= 1\n            time.sleep(1)\n\n    try:\n        while not input_done.is_set():\n            data = await consumer.getmany(timeout_ms=timeout_ms, max_records=batch_size)\n            for topic_partition, messages in data.items():\n                topic = topic_partition.topic\n                if messages:\n                    batches = [msg.value for msg in messages]\n                    for records in batches:\n                        result_handler(records)\n    finally:\n        await consumer.stop()",
  "FSMID_for_test": 80,
  "Code_level": "Function-level"
}