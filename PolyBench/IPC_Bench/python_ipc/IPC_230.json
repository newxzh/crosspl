{
  "Task_id": 230,
  "Github_ID": "311715246",
  "Github_Project_Name": "scrapy-playwright",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using http.server in python",
  "Instruction": "Task Description: Create a mock HTTP server for testing purposes that can handle various types of requests (GET, POST) and responses (JSON, redirects, status codes).\n\nClass Description: MockServer is a context manager class that creates and manages a lightweight HTTP server in a separate thread for testing HTTP client functionality. It provides endpoints for testing different HTTP scenarios.\n\nAttributes:\n- httpd: [HTTPServer] - The HTTP server instance\n- address: [str] - The server's IP address (127.0.0.1)\n- port: [int] - The dynamically assigned port number\n- thread: [Thread] - The thread running the server\n\nMethods:\n- __enter__() -> [MockServer] - Starts the server in a new thread when entering the context\n- __exit__(exc_type, exc_value, traceback) -> [None] - Shuts down the server and cleans up when exiting the context\n- urljoin(url: Optional[str]) -> [str] - Constructs a full URL by joining the base server URL with an optional path\n\nNested Class: _RequestHandler (BaseHTTPRequestHandler) - Handles incoming HTTP requests\n\nMethods:\n- do_POST() -> [None] - Handles POST requests by echoing back the request body\n- do_GET() -> [None] - Handles GET requests with various endpoints:\n  * /headers - Returns request headers as JSON\n  * /status/204 - Returns empty 204 response\n  * /redirect - Chain of redirect responses\n  * Default - Returns 404 for unknown paths\n- _send_json(body: dict, status: int = 200) -> [None] - Helper method to send JSON responses",
  "Canonical_solution": "from http.server import HTTPServer, BaseHTTPRequestHandler\nfrom threading import Thread\nfrom urllib.parse import urljoin\nfrom typing import Optional\n\nclass _RequestHandler(BaseHTTPRequestHandler):\n    def do_POST(self) -> None:\n        content_length = int(self.headers.get(\"Content-Length\") or 0)\n        body_bytes = b\"Request body: \" + self.rfile.read(content_length)\n        self.send_response(200)\n        self.send_header(\"Content-Length\", str(len(body_bytes)))\n        self.end_headers()\n        self.wfile.write(body_bytes)\n\n    def do_GET(self) -> None:\n        if self.path == \"/headers\":\n            self._send_json(dict(self.headers))\n        elif self.path == \"/status/204\":\n            self.send_response(204)\n            self.end_headers()\n        elif self.path == \"/redirect2\":\n            self.send_response(302)\n            self.send_header(\"Content-Length\", \"0\")\n            self.send_header(\"Location\", \"/redirect\")\n            self.end_headers()\n        elif self.path == \"/redirect\":\n            self.send_response(301)\n            self.send_header(\"Content-Length\", \"0\")\n            self.send_header(\"Location\", \"/headers\")\n            self.end_headers()\n        else:\n            self._send_json({\"error\": \"unknown path\"}, status=404)\n\n    def _send_json(self, body: dict, status: int = 200) -> None:\n        body_bytes = json.dumps(body, indent=2).encode(\"utf8\")\n        self.send_response(status)\n        self.send_header(\"Content-Length\", str(len(body_bytes)))\n        self.send_header(\"Content-Type\", \"application/json\")\n        self.end_headers()\n        self.wfile.write(body_bytes)\n\nclass MockServer:\n    def __enter__(self):\n        self.httpd = HTTPServer((\"127.0.0.1\", 0), _RequestHandler)\n        self.address, self.port = self.httpd.server_address\n        self.thread = Thread(target=self.httpd.serve_forever)\n        self.thread.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.httpd.shutdown()\n        self.thread.join()\n\n    def urljoin(self, url: Optional[str] = None) -> str:\n        return urljoin(f\"http://{self.address}:{self.port}\", url)",
  "FSMID_for_test": 55,
  "Code_level": "Class-level"
}