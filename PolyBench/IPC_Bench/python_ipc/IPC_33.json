{
  "Task_id": 33,
  "Github_ID": "615510678",
  "Github_Project_Name": "camel",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client-side by using httpx in python",
  "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with the SambaVerse API, handling request construction, response processing, and error management.\n\nClass Description: The SambaVerseClient class provides an interface to communicate with the SambaVerse API, sending chat messages and receiving completions. It handles API authentication, request formatting, and response conversion.\n\nAttributes:\n_api_key: str - The API key for authentication with the SambaVerse service\nmodel_type: str - The model type/name to be used for completions\n_url: str - The endpoint URL for the SambaVerse API\nmodel_config_dict: Dict[str, Any] - Configuration parameters for the model (temperature, max_tokens, etc.)\n\nMethods:\n__init__(api_key: str, model_type: str, url: str, model_config_dict: Dict[str, Any]) -> None - Initializes the client with API credentials and configuration\nsend_request(messages: List[OpenAIMessage]) -> ChatCompletion - Sends a chat completion request to the API and returns the processed response\n_convert_response(samba_response: Dict[str, Any]) -> ChatCompletion - Converts the raw API response into a standardized ChatCompletion object",
  "Canonical_solution": "import json\nimport uuid\nfrom typing import Any, Dict, List, Optional, Union\n\nimport httpx\nfrom camel.messages import OpenAIMessage\nfrom camel.types import ChatCompletion, CompletionUsage\n\nclass SambaVerseClient:\n    def __init__(self, api_key: str, model_type: str, url: str, model_config_dict: Dict[str, Any]):\n        self._api_key = api_key\n        self.model_type = model_type\n        self._url = url\n        self.model_config_dict = model_config_dict\n\n    def send_request(self, messages: List[OpenAIMessage]) -> ChatCompletion:\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"key\": str(self._api_key),\n            \"modelName\": self.model_type,\n        }\n\n        data = {\n            \"instance\": json.dumps({\n                \"conversation_id\": str(uuid.uuid4()),\n                \"messages\": messages,\n            }),\n            \"params\": {\n                \"do_sample\": {\"type\": \"bool\", \"value\": \"true\"},\n                \"max_tokens_to_generate\": {\n                    \"type\": \"int\",\n                    \"value\": str(self.model_config_dict.get(\"max_tokens\")),\n                },\n                \"process_prompt\": {\"type\": \"bool\", \"value\": \"true\"},\n                \"repetition_penalty\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"repetition_penalty\")),\n                },\n                \"return_token_count_only\": {\"type\": \"bool\", \"value\": \"false\"},\n                \"select_expert\": {\n                    \"type\": \"str\",\n                    \"value\": self.model_type.split('/')[1],\n                },\n                \"stop_sequences\": {\n                    \"type\": \"str\",\n                    \"value\": self.model_config_dict.get(\"stop_sequences\"),\n                },\n                \"temperature\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"temperature\")),\n                },\n                \"top_k\": {\n                    \"type\": \"int\",\n                    \"value\": str(self.model_config_dict.get(\"top_k\")),\n                },\n                \"top_p\": {\n                    \"type\": \"float\",\n                    \"value\": str(self.model_config_dict.get(\"top_p\")),\n                },\n            },\n        }\n\n        with httpx.Client() as client:\n            response = client.post(\n                self._url,\n                headers=headers,\n                json=data,\n            )\n\n        raw_text = response.text\n        dicts = raw_text.split('}\\n{')\n        last_dict = '{' + dicts[-1]\n        last_dict = json.loads(last_dict)\n        return self._convert_response(last_dict)\n\n    def _convert_response(self, samba_response: Dict[str, Any]) -> ChatCompletion:\n        choices = [\n            dict(\n                index=0,\n                message={\n                    \"role\": 'assistant',\n                    \"content\": samba_response['result']['responses'][0]['completion'],\n                },\n                finish_reason=samba_response['result']['responses'][0]['stop_reason'],\n            )\n        ]\n\n        return ChatCompletion.construct(\n            id=None,\n            choices=choices,\n            created=int(time.time()),\n            model=self.model_type,\n            object=\"chat.completion\",\n            usage=CompletionUsage(\n                completion_tokens=0,\n                prompt_tokens=0,\n                total_tokens=int(samba_response['result']['responses'][0]['total_tokens_count']),\n            ),\n        )",
  "FSMID_for_test": 58,
  "Code_level": "Class-level"
}