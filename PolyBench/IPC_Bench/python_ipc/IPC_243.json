{
  "Task_id": 243,
  "Github_ID": "59971825",
  "Github_Project_Name": "xsshunter",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server-side based on Tornado in python",
  "Instruction": "Task Description: Implement a Tornado-based HTTP server with request handlers for processing JavaScript callbacks and serving dynamic homepage content.\n\nClass Description: The TornadoHTTPServer class initializes and runs a Tornado web application with two main handlers: CallbackHandler for processing POST requests containing callback data, and HomepageHandler for serving dynamic JavaScript content based on user-specific configurations.\n\nAttributes:\n- settings: [dict] - Configuration dictionary containing server settings like cookie_secret\n- app: [tornado.web.Application] - The Tornado web application instance\n\nMethods:\n- __init__: [Name](settings: dict) -> [None] - Initializes the server with given settings and sets up URL routing\n- start: [Name](port: int = 8888) -> [None] - Starts the server listening on the specified port and begins the I/O loop\n\nClass Description: BaseHandler serves as the base request handler class providing common functionality for all handlers.\n\nAttributes:\n- (Inherited from tornado.web.RequestHandler)\n\nMethods:\n- __init__: [Name](*args, **kwargs) -> [None] - Initializes the handler and sets Content-Type header based on URI\n- options: [Name]() -> [None] - Handles OPTIONS requests (empty implementation)\n- throw_404: [Name]() -> [None] - Sends a 404 response with \"Resource not found\" message\n- on_finish: [Name]() -> [None] - Cleanup method called when request finishes (closes session)\n\nClass Description: CallbackHandler processes POST requests containing callback data, either in PGP-encrypted or plain JSON format.\n\nAttributes:\n- (Inherited from BaseHandler)\n\nMethods:\n- post: [Name]() -> [None] - Processes POST requests, validates user, and handles callback data (PGP or JSON)\n\nClass Description: HomepageHandler serves dynamic JavaScript content customized for each user.\n\nAttributes:\n- (Inherited from BaseHandler)\n\nMethods:\n- get: [Name](path: str) -> [None] - Serves customized JavaScript content based on user configuration and request path",
  "Canonical_solution": "import tornado.web\nimport tornado.ioloop\nfrom tornado import gen\n\nclass BaseHandler(tornado.web.RequestHandler):\n    def __init__(self, *args, **kwargs):\n        super(BaseHandler, self).__init__(*args, **kwargs)\n        if self.request.uri.startswith(\"/api/\"):\n            self.set_header(\"Content-Type\", \"application/json\")\n        else:\n            self.set_header(\"Content-Type\", \"application/javascript\")\n\n    def options(self):\n        pass\n\n    def throw_404(self):\n        self.set_status(404)\n        self.write(\"Resource not found\")\n\n    def on_finish(self):\n        session.close()\n\nclass CallbackHandler(BaseHandler):\n    def post(self):\n        self.set_header('Access-Control-Allow-Origin', '*')\n        self.set_header('Access-Control-Allow-Methods', 'POST, GET, HEAD, OPTIONS')\n        self.set_header('Access-Control-Allow-Headers', 'X-Requested-With')\n\n        owner_user = self.get_user_from_subdomain()\n        if owner_user == None:\n            self.throw_404()\n            return\n\n        if \"-----BEGIN PGP MESSAGE-----\" in self.request.body:\n            if owner_user.email_enabled:\n                send_javascript_pgp_encrypted_callback_message(self.request.body, owner_user.email)\n        else:\n            callback_data = json.loads(self.request.body)\n            callback_data['ip'] = self.request.remote_ip\n            injection_db_record = record_callback_in_database(callback_data, self)\n            if owner_user.email_enabled:\n                send_javascript_callback_message(owner_user.email, injection_db_record)\n            self.write('{}')\n\nclass HomepageHandler(BaseHandler):\n    def get(self, path):\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Methods\", \"OPTIONS, PUT, DELETE, POST, GET\")\n        self.set_header(\"Access-Control-Allow-Headers\", \"X-Requested-With, Content-Type, Origin, Authorization, Accept, Accept-Encoding\")\n\n        user = self.get_user_from_subdomain()\n        if user == None:\n            self.throw_404()\n            return\n\n        new_probe = probejs\n        new_probe = new_probe.replace('[HOST_URL]', \"https://\" + self.request.headers.get('Host'))\n        new_probe = new_probe.replace('[PGP_REPLACE_ME]', json.dumps(user.pgp_key))\n        new_probe = new_probe.replace('[CHAINLOAD_REPLACE_ME]', json.dumps(user.chainload_uri))\n        new_probe = new_probe.replace('[COLLECT_PAGE_LIST_REPLACE_ME]', json.dumps(user.get_page_collection_path_list()))\n\n        if user.pgp_key != \"\":\n            with open(\"templates/pgp_encrypted_template.txt\", \"r\") as template_handler:\n                new_probe = new_probe.replace('[TEMPLATE_REPLACE_ME]', json.dumps(template_handler.read()))\n        else:\n            new_probe = new_probe.replace('[TEMPLATE_REPLACE_ME]', json.dumps(\"\"))\n\n        if self.request.uri != \"/\":\n            probe_id = self.request.uri.split(\"/\")[1]\n            self.write(new_probe.replace(\"[PROBE_ID]\", probe_id))\n        else:\n            self.write(new_probe)\n\nclass TornadoHTTPServer:\n    def __init__(self, settings):\n        self.settings = settings\n        self.app = tornado.web.Application([\n            (r\"/js_callback\", CallbackHandler),\n            (r\"/(.*)\", HomepageHandler),\n        ], cookie_secret=settings[\"cookie_secret\"])\n\n    def start(self, port=8888):\n        self.app.listen(port)\n        tornado.ioloop.IOLoop.current().start()",
  "FSMID_for_test": 64,
  "Code_level": "Class-level"
}