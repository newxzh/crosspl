{
  "Task_id": 153,
  "Github_ID": "47010479",
  "Github_Project_Name": "arxiv-sanity-preserver",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using Flask in python",
  "Instruction": "Task Description: Create a Flask-based HTTP server class that handles user authentication, request rate limiting, and database interactions, with the ability to run in both development and production environments.\n\nClass Description: FlaskServer is a class that encapsulates a Flask web application with user authentication, rate limiting, and database connectivity features. It provides routes for main page display and user login functionality, along with supporting methods for database operations and request handling.\n\nAttributes:\n- app: Flask - The Flask application instance\n- limiter: Limiter - Rate limiting controller for the application\n- SECRET_KEY: str - Secret key for session management\n\nMethods:\n- __init__() -> None - Initializes the Flask application, sets up rate limiting, and configures routes and secret key\n- _setup_routes() -> None - Defines all application routes and request handlers (internal method)\n- connect_db() -> sqlite3.Connection - Establishes connection to SQLite database\n- query_db(query: str, args: tuple = (), one: bool = False) -> Union[list, dict, None] - Executes database query and returns results\n- get_user_id(username: str) -> Union[int, None] - Retrieves user ID from database by username\n- papers_filter_version(papers: list, v: str) -> list - Filters papers by version number\n- default_context(papers: list, **kws) -> dict - Creates default template context with papers data\n- run(port: int = 5000, debug: bool = False, prod: bool = False) -> None - Starts the server in either development or production mode\n\nRoute Handlers (defined in _setup_routes):\n- before_request() -> None - Sets up database connection and user session before each request\n- teardown_request(exception: Exception) -> None - Closes database connection after each request\n- intmain() -> str - Handles root route, displays main page with papers\n- login() -> Response - Handles user login POST requests, manages authentication",
  "Canonical_solution": "from flask import Flask, request, session, url_for, redirect, render_template, abort, g, flash, _app_ctx_stack\nfrom flask_limiter import Limiter\nfrom werkzeug import check_password_hash, generate_password_hash\nimport pymongo\nimport time\nfrom sqlite3 import dbapi2 as sqlite3\n\nclass FlaskServer:\n    def __init__(self):\n        self.app = Flask(__name__)\n        self.limiter = Limiter(self.app, global_limits=[\"100 per hour\", \"20 per minute\"])\n        self._setup_routes()\n        \n        # Database configuration\n        if os.path.isfile('secret_key.txt'):\n            SECRET_KEY = open('secret_key.txt', 'r').read()\n        else:\n            SECRET_KEY = 'devkey, should be in a file'\n        self.app.config['SECRET_KEY'] = SECRET_KEY\n\n    def _setup_routes(self):\n        @self.app.before_request\n        def before_request():\n            g.db = self.connect_db()\n            g.user = None\n            if 'user_id' in session:\n                g.user = self.query_db('select * from user where user_id = ?',\n                                    [session['user_id']], one=True)\n\n        @self.app.teardown_request\n        def teardown_request(exception):\n            db = getattr(g, 'db', None)\n            if db is not None:\n                db.close()\n\n        @self.app.route(\"/\")\n        def intmain():\n            vstr = request.args.get('vfilter', 'all')\n            papers = [db[pid] for pid in DATE_SORTED_PIDS]\n            papers = self.papers_filter_version(papers, vstr)\n            ctx = self.default_context(papers, render_format='recent',\n                                    msg='Showing most recent Arxiv papers:')\n            return render_template('main.html', **ctx)\n\n        @self.app.route('/login', methods=['POST'])\n        def login():\n            if not request.form['username']:\n                flash('You have to enter a username')\n            elif not request.form['password']:\n                flash('You have to enter a password')\n            elif self.get_user_id(request.form['username']) is not None:\n                user = self.query_db('''select * from user where\n                    username = ?''', [request.form['username']], one=True)\n                if check_password_hash(user['pw_hash'], request.form['password']):\n                    session['user_id'] = self.get_user_id(request.form['username'])\n                    flash('User ' + request.form['username'] + ' logged in.')\n                else:\n                    flash('User ' + request.form['username'] + ' already exists, wrong password.')\n            else:\n                creation_time = int(time.time())\n                g.db.execute('''insert into user (username, pw_hash, creation_time) values (?, ?, ?)''',\n                    [request.form['username'], \n                    generate_password_hash(request.form['password']), \n                    creation_time])\n                user_id = g.db.execute('select last_insert_rowid()').fetchall()[0][0]\n                g.db.commit()\n                session['user_id'] = user_id\n                flash('New account %s created' % (request.form['username'], ))\n            return redirect(url_for('intmain'))\n\n    def connect_db(self):\n        sqlite_db = sqlite3.connect(Config.database_path)\n        sqlite_db.row_factory = sqlite3.Row\n        return sqlite_db\n\n    def query_db(self, query, args=(), one=False):\n        cur = g.db.execute(query, args)\n        rv = cur.fetchall()\n        return (rv[0] if rv else None) if one else rv\n\n    def get_user_id(self, username):\n        rv = self.query_db('select user_id from user where username = ?',\n                        [username], one=True)\n        return rv[0] if rv else None\n\n    def papers_filter_version(self, papers, v):\n        if v != '1': \n            return papers\n        intv = int(v)\n        filtered = [p for p in papers if p['_version'] == intv]\n        return filtered\n\n    def default_context(self, papers, **kws):\n        top_papers = self.encode_json(papers, args.num_results)\n        ans = dict(papers=top_papers, numresults=len(papers), totpapers=len(db), tweets=[], msg='', show_prompt='no', pid_to_users={})\n        ans.update(kws)\n        return ans\n\n    def run(self, port=5000, debug=False, prod=False):\n        if prod:\n            from tornado.wsgi import WSGIContainer\n            from tornado.httpserver import HTTPServer\n            from tornado.ioloop import IOLoop\n            from tornado.log import enable_pretty_logging\n            enable_pretty_logging()\n            http_server = HTTPServer(WSGIContainer(self.app))\n            http_server.listen(port)\n            IOLoop.instance().start()\n        else:\n            self.app.debug = debug\n            self.app.run(port=port, host='0.0.0.0')",
  "FSMID_for_test": 60,
  "Code_level": "Class-level"
}