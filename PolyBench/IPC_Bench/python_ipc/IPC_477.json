{
  "Task_id": 477,
  "Github_ID": "176048362",
  "Github_Project_Name": "vidgear",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "ZeroMQ Consumer in Python(PUB/SUB)",
  "Instruction": "Task Description: Implement a ZeroMQ-based network communication class that supports PUB/SUB pattern for sending and receiving messages between processes, with optional frame compression and message handling.\n\nClass Description: NetGear is a ZeroMQ wrapper class that facilitates network communication using various messaging patterns, with a focus on PUB/SUB pattern. It handles socket creation, connection management, message serialization, and frame compression/decompression.\n\nAttributes:\n- __logging: bool - Enables/disables logging functionality\n- __msg_context: zmq.Context - ZeroMQ context instance for socket management\n- __receive_mode: bool - Flag indicating if instance is in receive mode\n- __pattern: int - Selected messaging pattern (0: PAIR, 1: REQ/REP, 2: PUB/SUB)\n- __terminate: bool - Flag for graceful termination\n- __msg_socket: zmq.Socket - ZeroMQ socket instance\n- __subscriber_timeout: int - Timeout value for subscriber socket (in seconds)\n- __queue: deque - Buffer for storing received frames (receiver only)\n- __thread: Thread - Background thread for message handling (receiver only)\n\nMethods:\n- __init__(address=None, port=None, protocol=None, pattern=0, receive_mode=False, logging=False, **options) -> None - Initializes the NetGear instance with specified parameters\n- __recv_handler() -> None - Internal thread handler for receiving messages (receiver only)\n- recv() -> np.ndarray|None - Receives and returns a frame from the queue (receiver only)\n- send(frame, message=None) -> None - Sends a frame with optional metadata (sender only)\n- close(kill=False) -> None - Closes the connection and cleans up resources",
  "Canonical_solution": "import os\nimport time\nimport asyncio\nimport platform\nimport string\nimport secrets\nimport numpy as np\nimport logging as log\nfrom threading import Thread\nfrom collections import deque\nfrom os.path import expanduser\nimport zmq\nfrom zmq import auth\nfrom zmq.auth.thread import ThreadAuthenticator\nfrom zmq.error import ZMQError\n\nclass NetGear:\n    def __init__(\n        self,\n        address=None,\n        port=None,\n        protocol=None,\n        pattern=0,\n        receive_mode=False,\n        logging=False,\n        **options\n    ):\n        self.__logging = logging if isinstance(logging, bool) else False\n        self.__msg_context = zmq.Context.instance()\n        self.__receive_mode = receive_mode\n        self.__pattern = pattern\n        self.__terminate = False\n\n        valid_messaging_patterns = {\n            0: (zmq.PAIR, zmq.PAIR),\n            1: (zmq.REQ, zmq.REP),\n            2: (zmq.PUB, zmq.SUB),\n        }\n\n        msg_pattern = valid_messaging_patterns[pattern]\n        self.__msg_socket = self.__msg_context.socket(msg_pattern[1 if receive_mode else 0])\n\n        if pattern == 2:  # PUB/SUB pattern\n            if receive_mode:  # SUB socket\n                self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, \"\")\n                self.__subscriber_timeout = options.get('subscriber_timeout', None)\n                if self.__subscriber_timeout:\n                    self.__msg_socket.setsockopt(zmq.RCVTIMEO, self.__subscriber_timeout * 1000)\n                    self.__msg_socket.setsockopt(zmq.LINGER, 0)\n            else:  # PUB socket\n                self.__msg_socket.set_hwm(1)\n\n        if receive_mode:\n            address = \"*\" if address is None else address\n            port = \"5555\" if port is None else port\n            self.__msg_socket.bind(f\"{protocol}://{address}:{port}\")\n        else:\n            address = \"localhost\" if address is None else address\n            port = \"5555\" if port is None else port\n            self.__msg_socket.connect(f\"{protocol}://{address}:{port}\")\n\n        if receive_mode and pattern == 2:\n            self.__queue = deque(maxlen=96)\n            self.__thread = Thread(target=self.__recv_handler, name=\"NetGear\")\n            self.__thread.daemon = True\n            self.__thread.start()\n\n    def __recv_handler(self):\n        while not self.__terminate:\n            try:\n                msg_json = self.__msg_socket.recv_json(flags=zmq.NOBLOCK)\n                msg_data = self.__msg_socket.recv(flags=zmq.NOBLOCK)\n                \n                if msg_json[\"terminate_flag\"]:\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n\n                if msg_json[\"compression\"]:\n                    frame = simplejpeg.decode_jpeg(\n                        msg_data,\n                        colorspace=msg_json[\"compression\"][\"colorspace\"],\n                        fastdct=msg_json[\"compression\"][\"dct\"],\n                        fastupsample=msg_json[\"compression\"][\"ups\"],\n                    )\n                else:\n                    frame_buffer = np.frombuffer(msg_data, dtype=msg_json[\"dtype\"])\n                    frame = frame_buffer.reshape(msg_json[\"shape\"])\n\n                self.__queue.append(frame)\n\n            except zmq.ZMQError as e:\n                if e.errno == zmq.EAGAIN:\n                    time.sleep(0.00001)\n                    continue\n                else:\n                    self.__terminate = True\n                    self.__queue.append(None)\n                    break\n\n    def recv(self):\n        if not self.__receive_mode or self.__pattern != 2:\n            raise ValueError(\"recv() can only be used in receive mode with PUB/SUB pattern\")\n\n        while not self.__terminate:\n            if len(self.__queue) > 0:\n                return self.__queue.popleft()\n            time.sleep(0.00001)\n        return None\n\n    def send(self, frame, message=None):\n        if self.__receive_mode or self.__pattern != 2:\n            raise ValueError(\"send() can only be used in send mode with PUB/SUB pattern\")\n\n        exit_flag = True if (frame is None or self.__terminate) else False\n\n        msg_dict = {\n            \"terminate_flag\": exit_flag,\n            \"compression\": False,\n            \"message\": message,\n            \"pattern\": str(self.__pattern),\n            \"dtype\": str(frame.dtype),\n            \"shape\": frame.shape\n        }\n\n        self.__msg_socket.send_json(msg_dict, zmq.SNDMORE)\n        self.__msg_socket.send(frame, copy=False)\n\n    def close(self, kill=False):\n        self.__terminate = True\n        if self.__receive_mode and self.__pattern == 2:\n            if self.__thread is not None:\n                if kill:\n                    self.__msg_context.destroy()\n                self.__thread.join()\n                self.__thread = None\n        self.__msg_socket.close(linger=0)",
  "FSMID_for_test": 85,
  "Code_level": "Class-level"
}