{
  "Task_id": 439,
  "Github_ID": "124611126",
  "Github_Project_Name": "alpaca-trade-api-python",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Client-side by using asyncio+websockets in python",
  "Instruction": "Task Description: Implement a WebSocket client class for streaming financial market data with authentication, subscription management, and message handling capabilities.\n\nClass Description: The _DataStream class establishes and maintains a WebSocket connection to a financial data streaming service. It handles authentication, manages subscriptions to different types of market data (trades, quotes, bars), processes incoming messages, and provides methods for controlling the connection lifecycle.\n\nAttributes:\n- _endpoint: str - WebSocket server URL\n- _key_id: str - API key for authentication\n- _secret_key: str - API secret for authentication\n- _ws: WebSocketClientProtocol - Active WebSocket connection\n- _running: bool - Connection status flag\n- _loop: asyncio.AbstractEventLoop - Event loop reference\n- _raw_data: bool - Flag for raw data processing\n- _stop_stream_queue: queue.Queue - Queue for stop signals\n- _handlers: Dict[str, Dict] - Dictionary of message handlers per data type\n- _name: str - Connection name identifier\n- _should_run: bool - Control flag for main loop\n- _max_frame_size: int - Maximum WebSocket frame size\n- _websocket_params: Dict - WebSocket connection parameters\n\nMethods:\n- __init__(endpoint: str, key_id: str, secret_key: str, raw_data: bool = False, websocket_params: Optional[Dict] = None) -> None - Initialize the data stream with connection parameters\n- _connect() -> None - Establish WebSocket connection\n- _auth() -> None - Authenticate with the server\n- _start_ws() -> None - Combined connection and authentication\n- close() -> None - Close the WebSocket connection\n- stop_ws() -> None - Signal to stop the WebSocket connection\n- _consume() -> None - Main message processing loop\n- _dispatch(msg: Dict) -> None - Route messages to appropriate handlers\n- _subscribe(handler: Callable, symbols: List[str], handlers: Dict) -> None - Internal subscription management\n- _subscribe_all() -> None - Send all active subscriptions to server\n- _run_forever() -> None - Main connection management loop\n- subscribe_trades(handler: Callable, *symbols: str) -> None - Subscribe to trade data\n- subscribe_quotes(handler: Callable, *symbols: str) -> None - Subscribe to quote data\n- subscribe_bars(handler: Callable, *symbols: str) -> None - Subscribe to bar data\n- subscribe_updated_bars(handler: Callable, *symbols: str) -> None - Subscribe to updated bar data\n- subscribe_daily_bars(handler: Callable, *symbols: str) -> None - Subscribe to daily bar data\n- stop() -> None - Stop the WebSocket connection and processing",
  "Canonical_solution": "import asyncio\nimport websockets\nimport msgpack\nimport queue\nfrom typing import Dict, Optional\n\nclass _DataStream:\n    def __init__(self,\n                 endpoint: str,\n                 key_id: str,\n                 secret_key: str,\n                 raw_data: bool = False,\n                 websocket_params: Optional[Dict] = None) -> None:\n        self._endpoint = endpoint\n        self._key_id = key_id\n        self._secret_key = secret_key\n        self._ws = None\n        self._running = False\n        self._loop = None\n        self._raw_data = raw_data\n        self._stop_stream_queue = queue.Queue()\n        self._handlers = {\n            'trades':      {},\n            'quotes':      {},\n            'bars':        {},\n            'updatedBars': {},\n            'dailyBars':   {},\n        }\n        self._name = 'data'\n        self._should_run = True\n        self._max_frame_size = 32768\n        self._websocket_params = websocket_params or {\n            \"ping_interval\": 10,\n            \"ping_timeout\": 180,\n            \"max_queue\": 1024,\n        }\n\n    async def _connect(self):\n        self._ws = await websockets.connect(\n            self._endpoint,\n            extra_headers={'Content-Type': 'application/msgpack'},\n            **self._websocket_params\n        )\n        r = await self._ws.recv()\n        msg = msgpack.unpackb(r)\n        if msg[0]['T'] != 'success' or msg[0]['msg'] != 'connected':\n            raise ValueError('connected message not received')\n\n    async def _auth(self):\n        await self._ws.send(\n            msgpack.packb({\n                'action': 'auth',\n                'key':    self._key_id,\n                'secret': self._secret_key,\n            }))\n        r = await self._ws.recv()\n        msg = msgpack.unpackb(r)\n        if msg[0]['T'] == 'error':\n            raise ValueError(msg[0].get('msg', 'auth failed'))\n        if msg[0]['T'] != 'success' or msg[0]['msg'] != 'authenticated':\n            raise ValueError('failed to authenticate')\n\n    async def _start_ws(self):\n        await self._connect()\n        await self._auth()\n\n    async def close(self):\n        if self._ws:\n            await self._ws.close()\n            self._ws = None\n            self._running = False\n\n    async def stop_ws(self):\n        self._should_run = False\n        if self._stop_stream_queue.empty():\n            self._stop_stream_queue.put_nowait({\"should_stop\": True})\n\n    async def _consume(self):\n        while True:\n            if not self._stop_stream_queue.empty():\n                self._stop_stream_queue.get(timeout=1)\n                await self.close()\n                break\n            else:\n                try:\n                    r = await asyncio.wait_for(self._ws.recv(), 5)\n                    msgs = msgpack.unpackb(r)\n                    for msg in msgs:\n                        await self._dispatch(msg)\n                except asyncio.TimeoutError:\n                    pass\n\n    async def _dispatch(self, msg):\n        msg_type = msg.get('T')\n        symbol = msg.get('S')\n        if msg_type == 't':\n            handler = self._handlers['trades'].get(\n                symbol, self._handlers['trades'].get('*', None))\n            if handler:\n                await handler(self._cast(msg_type, msg))\n        elif msg_type == 'q':\n            handler = self._handlers['quotes'].get(\n                symbol, self._handlers['quotes'].get('*', None))\n            if handler:\n                await handler(self._cast(msg_type, msg))\n        elif msg_type == 'b':\n            handler = self._handlers['bars'].get(\n                symbol, self._handlers['bars'].get('*', None))\n            if handler:\n                await handler(self._cast(msg_type, msg))\n        elif msg_type == 'u':\n            handler = self._handlers['updatedBars'].get(\n                symbol, self._handlers['updatedBars'].get('*', None))\n            if handler:\n                await handler(self._cast(msg_type, msg))\n        elif msg_type == 'd':\n            handler = self._handlers['dailyBars'].get(\n                symbol, self._handlers['dailyBars'].get('*', None))\n            if handler:\n                await handler(self._cast(msg_type, msg))\n        elif msg_type == 'error':\n            log.error(f'error: {msg.get(\"msg\")} ({msg.get(\"code\")})')\n\n    def _subscribe(self, handler, symbols, handlers):\n        for symbol in symbols:\n            handlers[symbol] = handler\n        if self._running:\n            asyncio.run_coroutine_threadsafe(\n                self._subscribe_all(), self._loop\n            ).result()\n\n    async def _subscribe_all(self):\n        msg = defaultdict(list)\n        for k, v in self._handlers.items():\n            if v:\n                for s in v.keys():\n                    msg[k].append(s)\n        msg['action'] = 'subscribe'\n        bs = msgpack.packb(msg)\n        frames = (bs[i:i+self._max_frame_size]\n                  for i in range(0, len(bs), self._max_frame_size))\n        await self._ws.send(frames)\n\n    async def _run_forever(self):\n        self._loop = asyncio.get_running_loop()\n        while not any(v for k, v in self._handlers.items()):\n            if not self._stop_stream_queue.empty():\n                self._stop_stream_queue.get(timeout=1)\n                return\n            await asyncio.sleep(0.1)\n        self._should_run = True\n        self._running = False\n        while True:\n            try:\n                if not self._should_run:\n                    return\n                if not self._running:\n                    await self._start_ws()\n                    await self._subscribe_all()\n                    self._running = True\n                await self._consume()\n            except websockets.WebSocketException as wse:\n                await self.close()\n                self._running = False\n            finally:\n                await asyncio.sleep(0.01)\n\n    def subscribe_trades(self, handler, *symbols):\n        self._subscribe(handler, symbols, self._handlers['trades'])\n\n    def subscribe_quotes(self, handler, *symbols):\n        self._subscribe(handler, symbols, self._handlers['quotes'])\n\n    def subscribe_bars(self, handler, *symbols):\n        self._subscribe(handler, symbols, self._handlers['bars'])\n\n    def subscribe_updated_bars(self, handler, *symbols):\n        self._subscribe(handler, symbols, self._handlers['updatedBars'])\n\n    def subscribe_daily_bars(self, handler, *symbols):\n        self._subscribe(handler, symbols, self._handlers['dailyBars'])\n\n    def stop(self):\n        if self._loop.is_running():\n            asyncio.run_coroutine_threadsafe(\n                self.stop_ws(),\n                self._loop).result()",
  "FSMID_for_test": 46,
  "Code_level": "Class-level"
}