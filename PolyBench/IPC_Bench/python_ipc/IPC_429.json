{
  "Task_id": 429,
  "Github_ID": "24043280",
  "Github_Project_Name": "sshuttle",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "UDP communication by using socket in python",
  "Instruction": "Task Description: Implement a UDP socket handler class that facilitates UDP communication with support for IP transparent proxying and original destination address retrieval.\n\nClass Description: The UDPSocketHandler class provides methods for receiving and sending UDP packets while maintaining information about both source and destination addresses. It supports both IPv4 and IPv6 protocols and includes special handling for transparent proxying scenarios.\n\nAttributes:\n[No explicit attributes are defined in the class, as it primarily operates through its methods]\n\nMethods:\n\nMethod1: recv_udp(listener: socket.socket, bufsize: int) -> tuple - Receives UDP packets and extracts both source and destination address information. Uses recvmsg() to get ancillary data containing the original destination address.\n  Input:\n    - listener: A bound UDP socket object\n    - bufsize: Maximum buffer size for received data\n  Output:\n    - tuple: (srcip: tuple, dstip: tuple, data: bytes) containing source address, destination address, and received data\n\nMethod2: send_udp(sock: socket.socket, srcip: tuple, dstip: tuple, data: bytes) -> None - Sends UDP packets while maintaining source address information through IP transparent option.\n  Input:\n    - sock: The socket to use for sending\n    - srcip: Source address tuple (IP, port)\n    - dstip: Destination address tuple (IP, port)\n    - data: The data to send\n  Output: None\n\nMethod3: setup_udp_listener(udp_listener: object) -> None - Configures UDP listener sockets for transparent proxying and original destination address retrieval.\n  Input:\n    - udp_listener: An object containing v4 and v6 socket instances\n  Output: None\n\nMethod4: setsockopt_error(e: Exception) -> None - Handles permission errors related to socket options and raises a fatal error.\n  Input:\n    - e: The caught PermissionError exception\n  Output: None (raises Fatal exception)",
  "Canonical_solution": "import socket\nimport os\nimport struct\nfrom sshuttle.helpers import debug1, debug3, Fatal\n\nIP_TRANSPARENT = 19\nIP_ORIGDSTADDR = 20\nIP_RECVORIGDSTADDR = IP_ORIGDSTADDR\nSOL_IPV6 = 41\nIPV6_ORIGDSTADDR = 74\nIPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR\n\nclass UDPSocketHandler:\n    def __init__(self):\n        pass\n\n    def recv_udp(self, listener, bufsize):\n        debug3('Accept UDP python using recvmsg.')\n        data, ancdata, _, srcip = listener.recvmsg(\n            4096, socket.CMSG_SPACE(24))\n        dstip = None\n        family = None\n        for cmsg_level, cmsg_type, cmsg_data in ancdata:\n            if cmsg_level == socket.SOL_IP and cmsg_type == IP_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET:\n                    start = 4\n                    length = 4\n                else:\n                    raise Fatal(\"Unsupported socket type '%s'\" % family)\n                ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                dstip = (ip, port)\n                break\n            elif cmsg_level == SOL_IPV6 and cmsg_type == IPV6_ORIGDSTADDR:\n                family, port = struct.unpack('=HH', cmsg_data[0:4])\n                port = socket.htons(port)\n                if family == socket.AF_INET6:\n                    start = 8\n                    length = 16\n                else:\n                    raise Fatal(\"Unsupported socket type '%s'\" % family)\n                ip = socket.inet_ntop(family, cmsg_data[start:start + length])\n                dstip = (ip, port)\n                break\n        return (srcip, dstip, data)\n\n    def send_udp(self, sock, srcip, dstip, data):\n        if not srcip:\n            debug1(\n                \"-- ignored UDP to %r: \"\n                \"couldn't determine source IP address\\n\" % (dstip,))\n            return\n        sender = socket.socket(sock.family, socket.SOCK_DGRAM)\n        sender.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        try:\n            sender.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        except PermissionError as e:\n            self.setsockopt_error(e)\n        sender.bind(srcip)\n        sender.sendto(data, dstip)\n        sender.close()\n\n    def setup_udp_listener(self, udp_listener):\n        try:\n            udp_listener.setsockopt(socket.SOL_IP, IP_TRANSPARENT, 1)\n        except PermissionError as e:\n            self.setsockopt_error(e)\n\n        if udp_listener.v4 is not None:\n            udp_listener.v4.setsockopt(\n                socket.SOL_IP, IP_RECVORIGDSTADDR, 1)\n        if udp_listener.v6 is not None:\n            udp_listener.v6.setsockopt(SOL_IPV6, IPV6_RECVORIGDSTADDR, 1)\n\n    def setsockopt_error(self, e):\n        raise Fatal(\"Insufficient permissions for tproxy method.\\n\"\n                   \"Your effective UID is %d, not 0. Try rerunning as root.\\n\"\n                   % os.geteuid())",
  "FSMID_for_test": 71,
  "Code_level": "Class-level"
}