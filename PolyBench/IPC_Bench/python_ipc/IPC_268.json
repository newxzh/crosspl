{
  "Task_id": 268,
  "Github_ID": "70590564",
  "Github_Project_Name": "kalliope",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "Mosquitto Consumer based on mqtt in Python",
  "Instruction": "Task Description: Create a Python class that implements an MQTT client using the Paho MQTT library to subscribe to topics, handle incoming messages, and trigger appropriate actions based on the received messages.\n\nClass Description: The `MqttClient` class is a threaded MQTT client that connects to a broker, subscribes to specified topics, and processes incoming messages. It supports secure connections with TLS and authentication. Messages can be in JSON format and are routed to designated synapses (processing units) based on the topic.\n\nAttributes:\n\n- broker: [object] - Contains broker configuration details (client_id, protocol, username, password, ca_cert, certfile, keyfile, tls_insecure, broker_ip, port, keepalive, topics)\n- brain: [object] - Reference to the main processing unit that manages synapses\n- client: [paho.mqtt.client.Client] - The MQTT client instance\n\nMethods:\n\n- __init__(broker=None, brain=None) -> [None] - Initializes the MQTT client with broker configuration and brain reference. Sets up connection callbacks and security parameters.\n- run() -> [None] - Connects to the broker and starts the MQTT loop in a separate thread. Handles socket errors gracefully.\n- on_connect(client, userdata, flags, rc) -> [None] - Callback for connection events. Subscribes to all configured topics on successful connection (rc=0).\n- on_message(client, userdata, msg) -> [None] - Callback for incoming messages. Routes messages to concerned synapses based on topic.\n- on_subscribe(mqttc, obj, mid, granted_qos) -> [None] - Callback for subscription confirmation (currently no operation).\n- call_concerned_synapses(topic_name, message) -> [None] - Processes incoming messages, converts JSON if needed, and triggers appropriate synapses.\n- _get_protocol(protocol) -> [int] - Static method that converts protocol string to Paho MQTT protocol constant.",
  "Canonical_solution": "import json\nimport logging\nimport socket\nfrom threading import Thread\nimport paho.mqtt.client as mqtt\n\nclass MqttClient(Thread):\n    def __init__(self, broker=None, brain=None):\n        super(MqttClient, self).__init__()\n        self.broker = broker\n        self.brain = brain\n\n        self.client = mqtt.Client(client_id=self.broker.client_id, protocol=self._get_protocol(self.broker.protocol))\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_subscribe = self.on_subscribe\n\n        if self.broker.username is not None and self.broker.password is not None:\n            self.client.username_pw_set(self.broker.username, self.broker.password)\n\n        if self.broker.ca_cert is not None and self.broker.certfile is not None and self.broker.keyfile is not None:\n            self.client.tls_set(ca_certs=self.broker.ca_cert,\n                               certfile=self.broker.certfile,\n                               keyfile=self.broker.keyfile)\n            self.client.tls_insecure_set(self.broker.tls_insecure)\n        elif self.broker.ca_cert is not None:\n            self.client.tls_set(ca_certs=self.broker.ca_cert)\n            self.client.tls_insecure_set(self.broker.tls_insecure)\n\n    def run(self):\n        try:\n            self.client.connect(self.broker.broker_ip, self.broker.port, self.broker.keepalive)\n            self.client.loop_forever()\n        except socket.error:\n            pass\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            for topic in self.broker.topics:\n                client.subscribe(topic.name)\n        else:\n            self.client.disconnect()\n\n    def on_message(self, client, userdata, msg):\n        self.call_concerned_synapses(msg.topic, msg.payload)\n\n    def on_subscribe(self, mqttc, obj, mid, granted_qos):\n        pass\n\n    def call_concerned_synapses(self, topic_name, message):\n        target_topic = next(topic for topic in self.broker.topics if topic.name == topic_name)\n        if target_topic.is_json:\n            message = json.loads(message)\n        \n        for synapse in target_topic.synapses:\n            overriding_parameter_dict = dict()\n            overriding_parameter_dict[\"mqtt_subscriber_message\"] = message\n            SynapseLauncher.start_synapse_by_list_name([synapse.name],\n                                                     brain=self.brain,\n                                                     overriding_parameter_dict=overriding_parameter_dict)\n\n    @staticmethod\n    def _get_protocol(protocol):\n        if protocol == \"MQTTv31\":\n            return paho.mqtt.client.MQTTv31\n        return paho.mqtt.client.MQTTv311",
  "FSMID_for_test": 84,
  "Code_level": "Class-level"
}