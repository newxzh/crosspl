{
  "Task_id": 38,
  "Github_ID": "703411624",
  "Github_Project_Name": "letta",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client-side by using httpx in python",
  "Instruction": "Task Description: Implement a function that handles Server-Sent Events (SSE) from an HTTP POST request, processes the incoming data streams, and yields appropriate message objects or raises errors when encountered.\n\nFunction Description: The function `_sse_post` establishes an SSE connection to a specified URL, sends a POST request with provided data and headers, and processes the incoming event stream. It handles different message types by yielding appropriate message objects (ReasoningMessage, ToolCallMessage, ToolReturnMessage, LettaUsageStatistics) or stream status updates (MessageStreamStatus). It also handles errors, including context window errors and JSON parsing errors, by raising appropriate exceptions.\n\nInput:\n- url: str - The URL to which the POST request will be sent.\n- data: dict - The JSON data to be sent in the POST request body.\n- headers: dict - The headers to be included in the POST request.\n\nOutput:\n- Generator[LettaStreamingResponse, None, None] - A generator that yields objects of type LettaStreamingResponse (which can be ReasoningMessage, ToolCallMessage, ToolReturnMessage, LettaUsageStatistics, or MessageStreamStatus) as the events are received from the server. Raises LLMError for context window errors or other appropriate exceptions for other errors.",
  "Canonical_solution": "import json\nfrom typing import Generator\nimport httpx\nfrom httpx_sse import SSEError, connect_sse\nfrom letta.constants import OPENAI_CONTEXT_WINDOW_ERROR_SUBSTRING\nfrom letta.errors import LLMError\nfrom letta.schemas.enums import MessageStreamStatus\nfrom letta.schemas.letta_message import ReasoningMessage, ToolCallMessage, ToolReturnMessage\nfrom letta.schemas.letta_response import LettaStreamingResponse\nfrom letta.schemas.usage import LettaUsageStatistics\n\ndef _sse_post(url: str, data: dict, headers: dict) -> Generator[LettaStreamingResponse, None, None]:\n    with httpx.Client() as client:\n        with connect_sse(client, method=\"POST\", url=url, json=data, headers=headers) as event_source:\n            if not event_source.response.is_success:\n                response_bytes = event_source.response.read()\n                response_dict = json.loads(response_bytes.decode(\"utf-8\"))\n                error_message = response_dict[\"error\"][\"message\"]\n                if OPENAI_CONTEXT_WINDOW_ERROR_SUBSTRING in error_message:\n                    raise LLMError(error_message)\n                event_source.response.raise_for_status()\n\n            try:\n                for sse in event_source.iter_sse():\n                    if sse.data in [status.value for status in MessageStreamStatus]:\n                        yield MessageStreamStatus(sse.data)\n                    else:\n                        chunk_data = json.loads(sse.data)\n                        if \"reasoning\" in chunk_data:\n                            yield ReasoningMessage(**chunk_data)\n                        elif \"tool_call\" in chunk_data:\n                            yield ToolCallMessage(**chunk_data)\n                        elif \"tool_return\" in chunk_data:\n                            yield ToolReturnMessage(**chunk_data)\n                        elif \"step_count\" in chunk_data:\n                            yield LettaUsageStatistics(**chunk_data)\n                        else:\n                            raise ValueError(f\"Unknown message type in chunk_data: {chunk_data}\")\n\n            except SSEError as e:\n                if \"application/json\" in str(e):\n                    response = client.post(url=url, json=data, headers=headers)\n                    if response.headers[\"Content-Type\"].startswith(\"application/json\"):\n                        error_details = response.json()\n                raise e\n\n            except Exception as e:\n                raise e",
  "FSMID_for_test": 58,
  "Code_level": "Function-level"
}