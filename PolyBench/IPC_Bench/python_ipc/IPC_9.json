{
  "Task_id": 9,
  "Github_ID": "39558861",
  "Github_Project_Name": "aliyun-openapi-python-sdk",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client - side by using http.client in python",
  "Instruction": "Task Description: Implement an HTTP connection pool class that manages reusable HTTP connections to a server, handling connection creation, retrieval, and release, with support for retries and timeouts.\n\nClass Description: HTTPConnectionPool is a connection pool manager for HTTP connections that maintains a pool of reusable connections to a specified host and port. It handles connection lifecycle, retries on failures, and timeout management.\n\nAttributes:\n- scheme: [str] - The URL scheme (default 'http')\n- ConnectionCls: [class] - The connection class to use (default HTTPConnection)\n- host: [str] - The target host for connections\n- port: [int] - The target port for connections\n- timeout: [Timeout] - Default timeout configuration\n- retries: [Retry] - Retry configuration for failed requests\n- pool: [LifoQueue] - Queue holding the connection pool\n- block: [bool] - Whether to block when pool is empty\n- proxy: [dict] - Proxy configuration\n- proxy_headers: [dict] - Headers for proxy requests\n- conn_kw: [dict] - Additional connection parameters\n\nMethods:\n- __init__(host, port=None, strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False, headers=None, retries=None, _proxy=None, _proxy_headers=None, **conn_kw) -> None - Initializes the connection pool with given configuration\n- _new_conn() -> HTTPConnection - Creates a new connection instance\n- _get_conn(timeout=None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn) -> None - Returns a connection to the pool\n- _make_request(conn, method, url, timeout=_Default, **httplib_request_kw) -> HTTPResponse - Makes an HTTP request using the given connection\n- urlopen(method, url, body=None, headers=None, retries=None, redirect=True, timeout=_Default, **response_kw) -> HTTPResponse - Main method to execute HTTP requests with retry and timeout handling\n- close() -> None - Closes all connections in the pool",
  "Canonical_solution": "from socket import error as SocketError, timeout as SocketTimeout\nimport socket\nfrom .connection import HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection\nfrom .exceptions import (\n    MaxRetryError,\n    ProtocolError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n    HTTPException,\n    BaseSSLError,\n    NewConnectionError,\n    ProxyError\n)\nfrom .util.timeout import Timeout\nfrom .util.retry import Retry\nfrom .util.queue import LifoQueue\nimport queue\nimport sys\nimport warnings\n\nclass HTTPConnectionPool:\n    scheme = 'http'\n    ConnectionCls = HTTPConnection\n\n    def __init__(self, host, port=None, strict=False,\n                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,\n                 headers=None, retries=None,\n                 _proxy=None, _proxy_headers=None,\n                 **conn_kw):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.pool = LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.conn_kw = conn_kw\n\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n    def _new_conn(self):\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw\n        )\n\n    def _get_conn(self, timeout=None):\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n            if conn and is_connection_dropped(conn):\n                conn.close()\n                conn = None\n            return conn or self._new_conn()\n        except queue.Empty:\n            raise EmptyPoolError(self, \"Pool is empty.\")\n\n    def _put_conn(self, conn):\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            conn.close()\n\n    def _make_request(self, conn, method, url, timeout=_Default, **httplib_request_kw):\n        timeout_obj = self._get_timeout(timeout)\n        conn.timeout = timeout_obj.connect_timeout\n\n        try:\n            conn.request(method, url, **httplib_request_kw)\n            httplib_response = conn.getresponse()\n            return httplib_response\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n    def urlopen(self, method, url, body=None, headers=None, retries=None,\n                redirect=True, timeout=_Default, **response_kw):\n        if retries is None:\n            retries = self.retries\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        try:\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=timeout_obj.connect_timeout)\n            conn.timeout = timeout_obj.connect_timeout\n\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers\n            )\n\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=conn,\n                retries=retries,\n                **response_kw\n            )\n\n            return response\n\n        except (TimeoutError, HTTPException, SocketError, ProtocolError,\n                BaseSSLError, SSLError) as e:\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                e = SSLError(e)\n            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n                e = ProxyError('Cannot connect to proxy.', e)\n            elif isinstance(e, (SocketError, HTTPException)):\n                e = ProtocolError('Connection aborted.', e)\n\n            retries = retries.increment(method, url, error=e, _pool=self)\n            retries.sleep()\n            return self.urlopen(\n                method, url, body, headers,\n                retries=retries, redirect=redirect,\n                timeout=timeout, **response_kw\n            )\n\n    def close(self):\n        while True:\n            try:\n                conn = self.pool.get(block=False)\n                if conn:\n                    conn.close()\n            except queue.Empty:\n                break",
  "FSMID_for_test": 56,
  "Code_level": "Class-level"
}