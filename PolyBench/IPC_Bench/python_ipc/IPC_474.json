{
  "Task_id": 474,
  "Github_ID": "159004094",
  "Github_Project_Name": "BERT-BiLSTM-CRF-NER",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "ZeroMQ Consumer in Python(PUB/SUB)",
  "Instruction": "Task Description: Implement a ZeroMQ-based client class for bidirectional communication with a server, capable of sending text data and receiving processed results as NumPy arrays.\n\nClass Description: BertClient is a ZeroMQ client that establishes PUSH-SUB pattern communication with a server. It sends text data for processing and subscribes to receive the processed results as NumPy arrays.\n\nAttributes:\n- context: zmq.Context - ZeroMQ context for socket management\n- sender: zmq.Socket - PUSH socket for sending requests to server\n- receiver: zmq.Socket - SUB socket for receiving responses from server\n- identity: bytes - Unique client identifier\n- request_id: int - Counter for tracking pending requests\n- timeout: int - Timeout setting for operations\n- pending_request: set - Set of outstanding request IDs\n\nMethods:\n- __init__(ip='localhost', port=5555, port_out=5556, identity=None, timeout=-1) -> None - Initializes the client with server connection details\n- close() -> None - Closes sockets and terminates context\n- _send(msg, msg_len=0) -> None - Internal method for sending messages to server\n- _recv() -> Response - Internal method for receiving raw responses\n- _recv_ndarray() -> Response - Internal method for receiving and decoding NumPy array responses\n- encode(texts, blocking=True) -> Optional[np.ndarray] - Sends texts for encoding and returns processed arrays\n- fetch(delay=0.0) -> Generator[Response, None, None] - Yields pending responses with optional delay\n- fetch_all(sort=True, concat=False) -> Union[List[np.ndarray], np.ndarray] - Retrieves all pending responses with sorting and concatenation options",
  "Canonical_solution": "import sys\nimport uuid\nimport zmq\nfrom zmq.utils import jsonapi\nimport numpy as np\nimport pickle\nfrom collections import namedtuple\n\nResponse = namedtuple('Response', ['id', 'content'])\n\nclass BertClient:\n    def __init__(self, ip='localhost', port=5555, port_out=5556, identity=None, timeout=-1):\n        self.context = zmq.Context()\n        self.sender = self.context.socket(zmq.PUSH)\n        self.sender.setsockopt(zmq.LINGER, 0)\n        self.identity = identity or str(uuid.uuid4()).encode('ascii')\n        self.sender.connect('tcp://%s:%d' % (ip, port))\n\n        self.receiver = self.context.socket(zmq.SUB)\n        self.receiver.setsockopt(zmq.LINGER, 0)\n        self.receiver.setsockopt(zmq.SUBSCRIBE, self.identity)\n        self.receiver.connect('tcp://%s:%d' % (ip, port_out))\n\n        self.request_id = 0\n        self.timeout = timeout\n        self.pending_request = set()\n\n    def close(self):\n        self.sender.close()\n        self.receiver.close()\n        self.context.term()\n\n    def _send(self, msg, msg_len=0):\n        self.sender.send_multipart([self.identity, msg, b'%d' % self.request_id, b'%d' % msg_len])\n        self.pending_request.add(self.request_id)\n        self.request_id += 1\n\n    def _recv(self):\n        response = self.receiver.recv_multipart()\n        request_id = int(response[-1])\n        self.pending_request.remove(request_id)\n        return Response(request_id, response)\n\n    def _recv_ndarray(self):\n        request_id, response = self._recv()\n        arr_info, arr_val = jsonapi.loads(response[1]), response[2]\n        X = np.frombuffer(memoryview(arr_val), dtype=str(arr_info['dtype']))\n        return Response(request_id, X.reshape(arr_info['shape']))\n\n    def encode(self, texts, blocking=True):\n        self._send(jsonapi.dumps(texts), len(texts))\n        rst = self._recv_ndarray().content if blocking else None\n        return rst\n\n    def fetch(self, delay=.0):\n        time.sleep(delay)\n        while self.pending_request:\n            yield self._recv_ndarray()\n\n    def fetch_all(self, sort=True, concat=False):\n        if self.pending_request:\n            tmp = list(self.fetch())\n            if sort:\n                tmp = sorted(tmp, key=lambda v: v.id)\n            tmp = [v.content for v in tmp]\n            if concat:\n                tmp = np.concatenate(tmp, axis=0)\n            return tmp",
  "FSMID_for_test": 85,
  "Code_level": "Class-level"
}