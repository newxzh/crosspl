{
  "Task_id": 14,
  "Github_ID": "60844169",
  "Github_Project_Name": "DDNS",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client - side by using http.client in python",
  "Instruction": "Task Description: Create a Python class to interact with Cloudflare's API for managing DNS records, including retrieving zone IDs, listing DNS records, and updating DNS records.\n\nClass Description: The CloudflareAPI class provides methods to interact with Cloudflare's API v4 for DNS management. It handles authentication, request/response processing, and includes caching for DNS records to optimize performance.\n\nAttributes:\n- ID: [str] - Cloudflare account email used for authentication\n- TOKEN: [str] - Cloudflare API key or bearer token for authentication\n- PROXY: [str] - Optional proxy server address\n- TTL: [int] - Time-to-live value for DNS records\n- SITE: [str] - Cloudflare API endpoint (default: \"api.cloudflare.com\")\n- _records_cache: [dict] - Internal cache for storing DNS records to reduce API calls\n\nMethods:\n- _request: [method](method: str, action: str, param: dict=None, **params: dict) -> dict - Internal method to make HTTP requests to Cloudflare API. Handles connection, authentication, request formatting, and response processing.\n- get_zone_id: [method](domain: str) -> str - Retrieves the zone ID for a given domain by checking progressively broader subdomains.\n- get_records: [method](zoneid: str, **conditions: dict) -> dict - Retrieves DNS records matching given conditions from a specified zone, using cache when possible.\n- update_record: [method](domain: str, value: str, record_type: str=\"A\") -> dict - Updates or creates a DNS record for the specified domain with the given value and record type.",
  "Canonical_solution": "from http.client import HTTPSConnection\nfrom urllib.parse import urlencode\nfrom json import loads as jsondecode, dumps as jsonencode\nfrom logging import debug, info, warning\n\nclass CloudflareAPI:\n    def __init__(self, auth_email=None, api_key=None, proxy=None, ttl=None):\n        self.ID = auth_email\n        self.TOKEN = api_key\n        self.PROXY = proxy\n        self.TTL = ttl\n        self.SITE = \"api.cloudflare.com\"\n        self._records_cache = {}\n\n    def _request(self, method, action, param=None, **params):\n        if param:\n            params.update(param)\n\n        params = dict((k, params[k]) for k in params if params[k] is not None)\n        info(\"%s/%s : %s\", self.SITE, action, params)\n        \n        if self.PROXY:\n            conn = HTTPSConnection(self.PROXY)\n            conn.set_tunnel(self.SITE, 443)\n        else:\n            conn = HTTPSConnection(self.SITE)\n\n        if method in ['PUT', 'POST', 'PATCH']:\n            params['content'] = str(params.get('content'))\n            params = jsonencode(params)\n        else:\n            if params:\n                action += '?' + urlencode(params)\n            params = None\n\n        if not self.ID:\n            headers = {\"Content-type\": \"application/json\",\n                      \"Authorization\": \"Bearer \" + self.TOKEN}\n        else:\n            headers = {\"Content-type\": \"application/json\",\n                      \"X-Auth-Email\": self.ID, \"X-Auth-Key\": self.TOKEN}\n\n        conn.request(method, '/client/v4/zones' + action, params, headers)\n        response = conn.getresponse()\n        res = response.read().decode('utf8')\n        conn.close()\n\n        if response.status < 200 or response.status >= 300:\n            warning('%s : error[%d]:%s', action, response.status, res)\n            raise Exception(res)\n        else:\n            data = jsondecode(res)\n            debug('%s : result:%s', action, data)\n            if not data:\n                raise Exception(\"Empty Response\")\n            elif data.get('success'):\n                return data.get('result', [{}])\n            else:\n                raise Exception(data.get('errors', [{}]))\n\n    def get_zone_id(self, domain):\n        zoneid = None\n        domain_slice = domain.split('.')\n        index = 2\n        while (not zoneid) and (index <= len(domain_slice)):\n            zones = self._request('GET', '', name='.'.join(domain_slice[-index:]))\n            zone = next((z for z in zones if domain.endswith(z.get('name'))), None)\n            zoneid = zone and zone['id']\n            index += 1\n        return zoneid\n\n    def get_records(self, zoneid, **conditions):\n        cache_key = zoneid + \"_\" + conditions.get('name', \"\") + \"_\" + conditions.get('type', \"\")\n        if cache_key not in self._records_cache:\n            self._records_cache[cache_key] = {}\n            data = self._request('GET', '/' + zoneid + '/dns_records', per_page=100, **conditions)\n            if data:\n                for record in data:\n                    self._records_cache[cache_key][record['id']] = {\n                        'id': record['id'],\n                        'type': record['type'],\n                        'name': record['name'],\n                        'content': record['content'],\n                        'proxied': record['proxied'],\n                        'ttl': record['ttl']\n                    }\n\n        records = {}\n        for (zid, record) in self._records_cache[cache_key].items():\n            for (k, value) in conditions.items():\n                if record.get(k) != value:\n                    break\n            else:\n                records[zid] = record\n        return records\n\n    def update_record(self, domain, value, record_type=\"A\"):\n        zoneid = self.get_zone_id(domain)\n        if not zoneid:\n            raise Exception(\"invalid domain: [ %s ] \" % domain)\n\n        records = self.get_records(zoneid, name=domain, type=record_type)\n        cache_key = zoneid + \"_\" + domain + \"_\" + record_type\n        result = {}\n\n        if records:\n            for (rid, record) in records.items():\n                if record['content'] != value:\n                    res = self._request('PUT', '/' + zoneid + '/dns_records/' + record['id'],\n                                      type=record_type, content=value, name=domain, \n                                      proxied=record['proxied'], ttl=self.TTL)\n                    if res:\n                        self._records_cache[cache_key][rid]['content'] = value\n                        result[rid] = res.get(\"name\")\n                    else:\n                        result[rid] = \"Update fail!\\n\" + str(res)\n                else:\n                    result[rid] = domain\n        else:\n            res = self._request('POST', '/' + zoneid + '/dns_records',\n                              type=record_type, name=domain, content=value, \n                              proxied=False, ttl=self.TTL)\n            if res:\n                self._records_cache[cache_key][res['id']] = res\n                result = res\n            else:\n                result = domain + \" created fail!\"\n        return result",
  "FSMID_for_test": 56,
  "Code_level": "Class-level"
}