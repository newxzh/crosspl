{
  "Task_id": 23,
  "Github_ID": "633174709",
  "Github_Project_Name": "NonSteamLaunchers-On-Steam-Deck",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client - side by using http.client in python",
  "Instruction": "Task Description: Implement an HTTP connection pool class to manage and reuse HTTP connections efficiently, reducing the overhead of establishing new connections for each request.\n\nClass Description: HTTPConnectionPool is a connection pooling mechanism for HTTP clients that maintains a pool of connections to a specific host, allowing for connection reuse and efficient resource management.\n\nAttributes:\n- host: str - The target host for the connections\n- port: int | None - The target port (defaults to None for standard ports)\n- timeout: Timeout | float | None - Connection and read timeout settings\n- maxsize: int - Maximum number of connections in the pool (default 1)\n- block: bool - Whether to block when pool is full (default False)\n- headers: typing.Mapping[str, str] | None - Default headers for connections\n- retries: Retry | bool | int | None - Retry configuration for failed requests\n- proxy: Url | None - Proxy server configuration\n- proxy_headers: typing.Mapping[str, str] | None - Headers for proxy connections\n- pool: queue.LifoQueue - The connection pool storage\n- num_connections: int - Count of total connections created\n- num_requests: int - Count of total requests made\n- conn_kw: typing.Any - Additional connection parameters\n\nMethods:\n- __init__(host: str, port: int | None = None, timeout: Timeout | float | None = None, maxsize: int = 1, block: bool = False, headers: typing.Mapping[str, str] | None = None, retries: Retry | bool | int | None = None, _proxy: Url | None = None, _proxy_headers: typing.Mapping[str, str] | None = None, **conn_kw: typing.Any) -> None - Initializes the connection pool with given parameters\n- _new_conn() -> HTTPConnection - Creates and returns a new connection\n- _get_conn(timeout: float | None = None) -> HTTPConnection - Retrieves a connection from the pool or creates a new one\n- _put_conn(conn: HTTPConnection | None) -> None - Returns a connection to the pool\n- _make_request(conn: HTTPConnection, method: str, url: str, timeout: Timeout = None, body: typing.Any = None, headers: typing.Mapping[str, str] | None = None, **response_kw: typing.Any) -> BaseHTTPResponse - Makes an HTTP request using the given connection\n- urlopen(method: str, url: str, body: typing.Any = None, headers: typing.Mapping[str, str] | None = None, retries: Retry | bool | int | None = None, timeout: Timeout | float | None = None, **response_kw: typing.Any) -> BaseHTTPResponse - Main method to make HTTP requests with connection pooling and retry logic\n- close() -> None - Closes all connections in the pool\n- _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None - Static method to close all connections in a given pool",
  "Canonical_solution": "from socket import timeout as SocketTimeout\nfrom types import TracebackType\nfrom typing import Literal, TypeVar, Union, overload\nimport typing\nimport queue\nimport weakref\nfrom .connection import HTTPConnection, HTTPSConnection\nfrom .exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    FullPoolError,\n    HostChangedError,\n    MaxRetryError,\n    NewConnectionError,\n    ProtocolError,\n    ReadTimeoutError,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import Url, parse_url\nfrom .util.util import to_str\n\n_SelfT = TypeVar(\"_SelfT\")\n\nclass HTTPConnectionPool:\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: Timeout | float | None = None,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        **conn_kw: typing.Any,\n    ):\n        self.host = host\n        self.port = port\n        self.timeout = Timeout.from_float(timeout) if not isinstance(timeout, Timeout) else timeout\n        self.retries = retries if retries is not None else Retry.DEFAULT\n        self.pool = queue.LifoQueue(maxsize)\n        self.block = block\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n        weakref.finalize(self, self._close_pool_connections, self.pool)\n\n    def _new_conn(self) -> HTTPConnection:\n        self.num_connections += 1\n        return self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw,\n        )\n\n    def _get_conn(self, timeout: float | None = None) -> HTTPConnection:\n        conn = None\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(self, \"Pool is empty and blocking mode is enabled.\")\n            pass\n\n        if conn and is_connection_dropped(conn):\n            conn.close()\n            conn = None\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn: HTTPConnection | None) -> None:\n        try:\n            self.pool.put(conn, block=False)\n        except queue.Full:\n            if conn:\n                conn.close()\n\n    def _make_request(\n        self,\n        conn: HTTPConnection,\n        method: str,\n        url: str,\n        timeout: Timeout = None,\n        body: typing.Any = None,\n        headers: typing.Mapping[str, str] | None = None,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        try:\n            conn.request(method, url, body=body, headers=headers)\n            response = conn.getresponse()\n            response._pool = self\n            return response\n        except (SocketTimeout, BaseException) as e:\n            conn.close()\n            raise\n\n    def urlopen(\n        self,\n        method: str,\n        url: str,\n        body: typing.Any = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        timeout: Timeout | float | None = None,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        if retries is None:\n            retries = self.retries\n        elif not isinstance(retries, Retry):\n            retries = Retry.from_int(retries)\n\n        conn = None\n        try:\n            conn = self._get_conn(timeout=timeout)\n            response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout,\n                body=body,\n                headers=headers,\n                **response_kw,\n            )\n            return response\n        except (EmptyPoolError, MaxRetryError, HostChangedError) as e:\n            raise\n        except (ProtocolError, OSError) as e:\n            retries = retries.increment(method, url, error=e, _pool=self)\n            retries.sleep()\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                timeout,\n                **response_kw,\n            )\n        finally:\n            if conn:\n                self._put_conn(conn)\n\n    def close(self) -> None:\n        if self.pool:\n            self._close_pool_connections(self.pool)\n            self.pool = None\n\n    @staticmethod\n    def _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:\n        try:\n            while True:\n                conn = pool.get(block=False)\n                if conn:\n                    conn.close()\n        except queue.Empty:\n            pass",
  "FSMID_for_test": 56,
  "Code_level": "Class-level"
}