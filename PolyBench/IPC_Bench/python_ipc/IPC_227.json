{
  "Task_id": 227,
  "Github_ID": "138811196",
  "Github_Project_Name": "tuna",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using http.server in python",
  "Instruction": "Task Description: Create a Python class that implements an HTTP server to serve static files and render dynamic content from a profile file, with optional browser auto-launch functionality.\n\nClass Description: ProfileHTTPServer is a class that creates and manages an HTTP server to serve both static files from a 'web' directory and dynamically rendered content from profile data. It handles port selection, profile data reading, and optional browser launching.\n\nAttributes:\nprof_filename: str - The filename of the profile to be read and served\nstart_browser: bool - Flag indicating whether to automatically open a browser tab\nport: Optional[int] - The port number to use for the server (None for auto-selection)\ndata: Any - The profile data read from the file\n\nMethods:\n__init__(prof_filename: str, start_browser: bool = False, port: Optional[int] = None) -> None - Initializes the server with profile filename, browser flag, and optional port\n_read_profile() -> Any - Reads and returns profile data from the specified file\n_is_port_in_use(port: int) -> bool - Checks if a port is already in use\nstart() -> None - Starts the HTTP server on the selected port, optionally launching a browser\n\nStaticServer (nested class):\n__init__(data: Any, prof_filename: str, *args, **kwargs) -> None - Initializes the request handler with profile data and filename\ndo_GET() -> None - Handles GET requests, serving either static files or rendered HTML\n_render() -> str - Renders the HTML template with profile data and version information",
  "Canonical_solution": "import html\nimport json\nimport mimetypes\nimport socket\nimport threading\nimport webbrowser\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom pathlib import Path\nfrom typing import Optional\n\nclass StaticServer(BaseHTTPRequestHandler):\n    def __init__(self, data, prof_filename, *args, **kwargs):\n        self.data = data\n        self.prof_filename = prof_filename\n        super().__init__(*args, **kwargs)\n\n    def do_GET(self):\n        self.send_response(200)\n\n        if self.path == \"/\":\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(self._render().encode())\n        else:\n            this_dir = Path(__file__).resolve().parent\n            filepath = this_dir / \"web\" / self.path[1:]\n\n            mimetype, _ = mimetypes.guess_type(str(filepath))\n            assert mimetype is not None\n            self.send_header(\"Content-type\", mimetype)\n            self.end_headers()\n\n            with open(filepath, \"rb\") as fh:\n                content = fh.read()\n            self.wfile.write(content)\n\n    def _render(self):\n        this_dir = Path(__file__).resolve().parent\n        with open(this_dir / \"web\" / \"index.html\", encoding=\"utf-8\") as _file:\n            template = string.Template(_file.read())\n\n        return template.substitute(\n            data=html.escape(json.dumps(self.data).replace(\"</\", \"<\\\\/\")),\n            version=html.escape(__version__),\n            filename=html.escape(self.prof_filename.replace(\"</\", \"<\\\\/\")),\n        )\n\nclass ProfileHTTPServer:\n    def __init__(self, prof_filename: str, start_browser: bool = False, port: Optional[int] = None):\n        self.prof_filename = prof_filename\n        self.start_browser = start_browser\n        self.port = port\n        self.data = self._read_profile()\n\n    def _read_profile(self):\n        try:\n            return read_import_profile(self.prof_filename)\n        except (TunaError, StopIteration):\n            pass\n        return read_runtime_profile(self.prof_filename)\n\n    def _is_port_in_use(self, port: int) -> bool:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            return s.connect_ex((\"localhost\", port)) == 0\n\n    def start(self):\n        if self.port is None:\n            self.port = 8000\n            while self._is_port_in_use(self.port):\n                self.port += 1\n\n        handler = lambda *args: StaticServer(self.data, self.prof_filename, *args)\n        httpd = HTTPServer((\"\", self.port), handler)\n\n        if self.start_browser:\n            address = f\"http://localhost:{self.port}\"\n            threading.Thread(target=lambda: webbrowser.open_new_tab(address)).start()\n\n        print(f\"Starting httpd on port {self.port}\")\n        httpd.serve_forever()",
  "FSMID_for_test": 55,
  "Code_level": "Class-level"
}