{
  "Task_id": 173,
  "Github_ID": "88980374",
  "Github_Project_Name": "Nettacker",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Server - side by using Flask in python",
  "Instruction": "Task Description: Create a Flask-based API server for the OWASP Nettacker security tool that handles scan requests, retrieves results, and manages logs through HTTP endpoints.\n\nClass Description: The NettackerAPI class implements a RESTful API service using Flask framework to control and interact with the OWASP Nettacker security scanning tool. It provides endpoints for initiating scans, retrieving results in JSON format, and accessing scan logs.\n\nAttributes:\n- app: [Flask] - The Flask application instance\n- options: [SimpleNamespace] - Configuration options for the API server\n- app.config[\"OWASP_NETTACKER_CONFIG\"]: [dict] - Configuration dictionary containing API security settings and options\n\nMethods:\n- __init__(options) -> [None] - Initializes the Flask app with configuration options\n- _setup_routes() -> [None] - Defines all API endpoints and their handlers\n- _sanitize_report_path_filename(report_path_filename) -> [Path|bool] - Sanitizes and validates report filenames\n- run() -> [None] - Starts the Flask server with SSL/TLS configuration\n- start_api_server() -> [None] - Runs the API server in a separate process\n\nEndpoint Methods:\n- new_scan() -> [Response] - Handles POST requests to start new scans (returns scan arguments or error)\n- get_results_json() -> [Response] - Retrieves scan results in JSON format (returns file download)\n- get_logs() -> [Response] - Retrieves scan logs in JSON format (returns file download)",
  "Canonical_solution": "from flask import Flask, jsonify, request as flask_request, Response, make_response\nfrom werkzeug.utils import secure_filename\nimport os\nimport json\nimport csv\nimport random\nimport string\nimport multiprocessing\nimport time\nfrom threading import Thread\nfrom types import SimpleNamespace\n\nclass NettackerAPI:\n    def __init__(self, options):\n        self.app = Flask(__name__, template_folder=str(options.web_static_dir))\n        self.app.config[\"OWASP_NETTACKER_CONFIG\"] = {\n            \"api_access_key\": options.api_access_key,\n            \"api_client_whitelisted_ips\": options.api_client_whitelisted_ips,\n            \"api_access_log\": options.api_access_log,\n            \"api_cert\": options.api_cert,\n            \"api_cert_key\": options.api_cert_key,\n            \"language\": options.language,\n            \"options\": options,\n        }\n        \n        self._setup_routes()\n        self.options = options\n\n    def _setup_routes(self):\n        @self.app.route(\"/new/scan\", methods=[\"GET\", \"POST\"])\n        def new_scan():\n            api_key_is_valid(self.app, flask_request)\n            form_values = dict(flask_request.form)\n            raw_report_path_filename = form_values.get(\"report_path_filename\")\n            report_path_filename = self._sanitize_report_path_filename(raw_report_path_filename)\n            if not report_path_filename:\n                return jsonify(structure(status=\"error\", msg=\"Invalid report filename\")), 400\n            form_values[\"report_path_filename\"] = str(report_path_filename)\n            for key in nettacker_application_config:\n                if key not in form_values:\n                    form_values[key] = nettacker_application_config[key]\n\n            nettacker_app = Nettacker(api_arguments=SimpleNamespace(**form_values))\n            self.app.config[\"OWASP_NETTACKER_CONFIG\"][\"options\"] = nettacker_app.arguments\n            thread = Thread(target=nettacker_app.run)\n            thread.start()\n\n            return jsonify(vars(nettacker_app.arguments)), 200\n\n        @self.app.route(\"/results/get_json\", methods=[\"GET\"])\n        def get_results_json():\n            api_key_is_valid(self.app, flask_request)\n            session = create_connection()\n            result_id = get_value(flask_request, \"id\")\n            if not result_id:\n                return jsonify(structure(status=\"error\", msg=_(\"invalid_scan_id\"))), 400\n            scan_details = session.query(Report).filter(Report.id == result_id).first()\n            json_object = json.dumps(get_logs_by_scan_id(scan_details.scan_unique_id))\n            filename = \".\".join(scan_details.report_path_filename.split(\".\")[:-1])[1:] + \".json\"\n            return Response(\n                json_object,\n                mimetype=\"application/json\",\n                headers={\"Content-Disposition\": \"attachment;filename=\" + filename},\n            )\n\n        @self.app.route(\"/logs/get_json\", methods=[\"GET\"])\n        def get_logs():\n            api_key_is_valid(self.app, flask_request)\n            target = get_value(flask_request, \"target\")\n            data = logs_to_report_json(target)\n            json_object = json.dumps(data)\n            filename = (\n                \"report-\"\n                + now(format=\"%Y_%m_%d_%H_%M_%S\")\n                + \"\".join(random.choice(string.ascii_lowercase) for _ in range(10))\n            )\n            return Response(\n                json_object,\n                mimetype=\"application/json\",\n                headers={\"Content-Disposition\": \"attachment;filename=\" + filename + \".json\"},\n            )\n\n    def _sanitize_report_path_filename(self, report_path_filename):\n        filename = secure_filename(os.path.basename(report_path_filename))\n        if not filename:\n            return False\n        VALID_EXTENSIONS = (\".html\", \".htm\", \".txt\", \".json\", \".csv\")\n        if \".\" in filename:\n            if filename.endswith(VALID_EXTENSIONS):\n                safe_report_path = nettacker_path_config.results_dir / filename\n            else:\n                return False\n        else:\n            safe_report_path = nettacker_path_config.results_dir / filename\n        if not safe_report_path.is_relative_to(nettacker_path_config.results_dir):\n            return False\n        return safe_report_path\n\n    def run(self):\n        if self.options.api_cert and self.options.api_cert_key:\n            self.app.run(\n                host=self.options.api_hostname,\n                port=self.options.api_port,\n                debug=self.options.api_debug_mode,\n                ssl_context=(self.options.api_cert, self.options.api_cert_key),\n                threaded=True,\n            )\n        else:\n            self.app.run(\n                host=self.options.api_hostname,\n                port=self.options.api_port,\n                debug=self.options.api_debug_mode,\n                ssl_context=\"adhoc\",\n                threaded=True,\n            )\n\n    def start_api_server(self):\n        p = multiprocessing.Process(target=self.run)\n        p.start()\n        while len(multiprocessing.active_children()) != 0:\n            try:\n                time.sleep(0.3)\n            except KeyboardInterrupt:\n                for process in multiprocessing.active_children():\n                    process.terminate()\n                break",
  "FSMID_for_test": 60,
  "Code_level": "Class-level"
}