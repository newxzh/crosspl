{
  "Task_id": 106,
  "Github_ID": "686364232",
  "Github_Project_Name": "openllmetry",
  "Programming_Language": "Python",
  "suffix": ".py",
  "Interface_class": "IPC",
  "Interface_name": "HTTP Client-side by using requests in python",
  "Instruction": "Task Description: Create a Python class that implements an HTTP client for interacting with a remote API, featuring automatic retries for failed requests, background polling for data refresh, and graceful shutdown handling.\n\nClass Description: The Fetcher class provides a robust HTTP client implementation for API interactions with features like exponential backoff retries, periodic background data refreshing, and proper thread cleanup on program exit.\n\nAttributes:\n- _base_url: str - The base URL for API endpoints\n- _api_key: str - API key for authentication\n- _stop_polling_event: Event - Threading event to control polling thread lifecycle\n- _exit_monitor: Thread - Thread that monitors main thread for program exit\n- _poller_thread: Thread - Thread that handles periodic data refreshing\n\nMethods:\n- __init__(base_url: str, api_key: str) -> None - Initializes the fetcher with API configuration\n- run() -> None - Starts the background polling and exit monitoring threads\n- post(api: str, body: Dict[str, str]) -> None - Sends a POST request to specified API endpoint\n- _fetch_url(url: str, api_key: str) -> Dict - Performs a GET request with retry logic (private)\n- _post_url(url: str, api_key: str, body: Dict[str, str]) -> None - Performs a POST request (private)\n- _thread_func(base_url: str, api_key: str, stop_polling_event: Event, seconds_interval: Optional[int]) -> None - Background polling thread function (private)\n- _refresh_data(base_url: str, api_key: str) -> None - Refreshes data from multiple endpoints (private)\n- _monitor_exit(exit_event: Event) -> None - Monitors main thread for program exit (private)",
  "Canonical_solution": "import logging\nimport os\nimport threading\nimport time\nimport typing\nimport requests\n\nfrom threading import Thread, Event\nfrom typing import Dict, Optional\nfrom tenacity import (\n    RetryError,\n    retry,\n    stop_after_attempt,\n    wait_exponential,\n    retry_if_exception,\n)\n\nclass Fetcher:\n    def __init__(self, base_url: str, api_key: str):\n        self._base_url = base_url\n        self._api_key = api_key\n        self._stop_polling_event = Event()\n        self._exit_monitor = Thread(\n            target=self._monitor_exit, args=(self._stop_polling_event,), daemon=True\n        )\n        self._poller_thread = Thread(\n            target=self._thread_func,\n            args=(\n                self._base_url,\n                self._api_key,\n                self._stop_polling_event,\n                int(os.getenv(\"TRACELOOP_PROMPT_MANAGER_POLLING_INTERVAL\") or 5),\n            ),\n        )\n\n    def run(self):\n        self._refresh_data(self._base_url, self._api_key)\n        self._exit_monitor.start()\n        self._poller_thread.start()\n\n    def post(self, api: str, body: Dict[str, str]):\n        self._post_url(f\"{self._base_url}/v1/traceloop/{api}\", self._api_key, body)\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=4),\n        stop=stop_after_attempt(int(os.getenv(\"TRACELOOP_PROMPT_MANAGER_MAX_RETRIES\") or 3)),\n        retry=retry_if_exception(lambda e: isinstance(e, requests.exceptions.HTTPError) and (500 <= e.response.status_code < 600),\n    )\n    def _fetch_url(self, url: str, api_key: str):\n        response = requests.get(\n            url,\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"X-Traceloop-SDK-Version\": \"1.0.0\",\n            },\n        )\n\n        if response.status_code != 200:\n            if response.status_code == 401 or response.status_code == 403:\n                logging.error(\"Authorization error: Invalid Traceloop API key.\")\n                raise requests.exceptions.HTTPError(response=response)\n            else:\n                logging.error(\"Request failed: %s\", response.status_code)\n                raise requests.exceptions.HTTPError(response=response)\n        else:\n            return response.json()\n\n    def _post_url(self, url: str, api_key: str, body: Dict[str, str]):\n        response = requests.post(\n            url,\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"X-Traceloop-SDK-Version\": \"1.0.0\",\n            },\n            json=body,\n        )\n\n        if response.status_code != 200:\n            raise requests.exceptions.HTTPError(response=response)\n\n    def _thread_func(self, base_url: str, api_key: str, stop_polling_event: Event, seconds_interval: Optional[int] = 5):\n        while not stop_polling_event.is_set():\n            try:\n                self._refresh_data(base_url, api_key)\n            except RetryError:\n                logging.error(\"Request failed after retries : stopped polling\")\n                break\n\n            time.sleep(seconds_interval)\n\n    def _refresh_data(self, base_url: str, api_key: str):\n        self._fetch_url(f\"{base_url}/v1/traceloop/prompts\", api_key)\n        self._fetch_url(f\"{base_url}/v1/traceloop/pii/tracing-allow-list\", api_key)\n\n    def _monitor_exit(self, exit_event: Event):\n        main_thread = threading.main_thread()\n        main_thread.join()\n        exit_event.set()",
  "FSMID_for_test": 57,
  "Code_level": "Class-level"
}