{
    "Task_id": 190,
    "Github_ID": "236162999",
    "Github_Project_Name": "nbio",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Net-based TCP Server in Go",
    "Instruction": "Task Description: Implement a high-performance TCP server in Go using kqueue for event notification, capable of handling multiple client connections efficiently with non-blocking I/O operations.\n\nStruct Description: The `poller` struct manages a single kqueue instance and handles all I/O operations for its assigned connections. It works as part of an engine (`g *Engine`) to process network events either as a listener (accepting new connections) or as a worker (handling read/write operations).\n\nFields:\n\ng: *Engine - Reference to the parent engine managing all pollers\nmux: sync.Mutex - Mutex for thread-safe access to eventList\nkfd: int - Kqueue file descriptor\nevtfd: int - Event file descriptor (unused in current implementation)\nindex: int - Poller's index in the engine's poller array\nshutdown: bool - Flag to control poller shutdown\nlistener: net.Listener - TCP listener (only for listener pollers)\nisListener: bool - Flag indicating if this is a listener poller\nunixSockAddr: string - Unix socket address (if using UNIX domain sockets)\nReadBuffer: []byte - Buffer for read operations\npollType: string - Type identifier (\"LISTENER\" or \"POLLER\")\neventList: []syscall.Kevent_t - Pending kqueue events to be processed\n\nMethods:\n\naddConn(c *Conn) -> error - Adds a new connection to the poller and registers it for read events\naddDialer(c *Conn) -> error - Adds a dialer connection and registers it for read/write events\ngetConn(fd int) -> *Conn - Retrieves a connection by file descriptor\ndeleteConn(c *Conn) -> - Removes a connection from tracking\ntrigger() -> - Wakes up the kqueue loop\naddRead(fd int) -> - Registers a file descriptor for read events\nresetRead(fd int) -> - Unregisters write events for a file descriptor\nmodWrite(fd int) -> - Registers a file descriptor for write events\naddReadWrite(fd int) -> - Registers a file descriptor for both read and write events\nreadWrite(ev *syscall.Kevent_t) -> - Processes read/write events from kqueue\nstart() -> - Starts the poller's main loop (either acceptorLoop or readWriteLoop)\nacceptorLoop() -> - Listener's main loop that accepts new connections\nreadWriteLoop() -> - Worker's main loop that processes I/O events\nstop() -> - Stops the poller and cleans up resources\nnewPoller(g *Engine, isListener bool, index int) -> (*poller, error) - Constructor that creates either a listener or worker poller",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *poller) stop() {\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}",
    "FSMID_for_test": 109,
    "Code_level": "Class-level"
}