{
    "Task_id": 375,
    "Github_ID": "183399164",
    "Github_Project_Name": "zoro",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "net-based UDP Server with listenUDP in Go",
    "Instruction": "Task Description: Implement a UDP server in Go that handles incoming UDP packets, performs authentication checks, and manages communication with clients through specified ports. The server should include functionality for initialization, packet handling, listening for incoming data, and graceful shutdown.\n\nStruct Description: The UDPServer struct represents a UDP server instance that manages UDP connections, handles authentication, and processes incoming/outgoing packets. It maintains connection state and integrates with a parent Server instance.\n\nFields:\n\nServer: [*Server] - Reference to the parent Server instance containing shared resources\nUDPConn: [*net.UDPConn] - Active UDP connection for the server\nAddr: [*net.UDPAddr] - Address information for the server's UDP endpoint\n\nMethods:\n\nNewUDPServer: [func(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error)] -> [*UDPServer, error] - Initializes a new UDP server instance with authentication checks and port validation. Returns the server instance or error if initialization fails.\n\nListenAndServe: [func(s *UDPServer) error] -> [error] - Starts listening for incoming UDP packets and handles them in a loop until an error occurs or the server is shut down. Automatically closes the connection when finished.\n\nShutdown: [func(s *UDPServer)] -> [void] - Gracefully shuts down the UDP server by closing the active connection.\n\nHandlePacket: [func(s *UDPServer, p *UDPPacket) error] -> [error] - Processes an incoming UDP packet, either forwarding data to the specified address or updating the connection deadline. Returns error if processing fails.",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\ntype UDPServer struct {\n\tServer  *Server\n\tUDPConn *net.UDPConn\n\tAddr    *net.UDPAddr\n}\n\nfunc NewUDPServer(s *Server, p *UDPPacket, addr *net.UDPAddr) (*UDPServer, error) {\n\tbye := func(err error) {\n\t\tp := &UDPPacket{\n\t\t\tAddress: err.Error(),\n\t\t}\n\t\tb, err1 := proto.Marshal(p)\n\t\tif err1 != nil {\n\t\t\tlog.Println(err1)\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\tif p.Port == 0 {\n\t\tbye(errors.New(\"Missed port\"))\n\t\treturn nil, errors.New(addr.String() + \" missed port\")\n\t}\n\tif len(s.PortCkv) == 0 {\n\t\ttmp, err := s.Ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tif len(s.PortCkv) != 0 {\n\t\tckv, ok := s.PortCkv[p.Port]\n\t\tif !ok {\n\t\t\tbye(errors.New(\"Not allowed port\"))\n\t\t\treturn nil, errors.New(addr.String() + \" try to open not allowed UDP port: \" + strconv.FormatInt(p.Port, 10))\n\t\t}\n\t\ttmp, err := ckv.Decrypt(p.Key, \"Mr.2\", 3*60)\n\t\tif err != nil || tmp != \"UDPPacket\" {\n\t\t\tbye(errors.New(\"Try another password\"))\n\t\t\treturn nil, errors.New(addr.String() + \" Hacking\")\n\t\t}\n\t}\n\tuaddr, err := net.ResolveUDPAddr(\"udp\", \":\"+strconv.FormatInt(p.Port, 10))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc1, err := net.ListenUDP(\"udp\", uaddr)\n\tif err != nil {\n\t\tbye(err)\n\t\treturn nil, err\n\t}\n\tif err := c1.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tp = &UDPPacket{\n\t\tAddress: \"0\",\n\t}\n\tb, err := proto.Marshal(p)\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\tif _, err := s.UDPConn.WriteToUDP(b, addr); err != nil {\n\t\tc1.Close()\n\t\treturn nil, err\n\t}\n\treturn &UDPServer{\n\t\tServer:  s,\n\t\tUDPConn: c1,\n\t\tAddr:    addr,\n\t}, nil\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tdefer s.UDPConn.Close()\n\tfor {\n\t\tb := make([]byte, 65536)\n\t\ti, a, err := s.UDPConn.ReadFromUDP(b)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tp := &UDPPacket{\n\t\t\tAddress: a.String(),\n\t\t\tData:    b[0:i],\n\t\t}\n\t\tb, err = proto.Marshal(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.Server.UDPConn.WriteToUDP(b, s.Addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *UDPServer) Shutdown() {\n\ts.UDPConn.Close()\n}\n\nfunc (s *UDPServer) HandlePacket(p *UDPPacket) error {\n\tif p.Address != \"0\" {\n\t\tuaddr, err := net.ResolveUDPAddr(\"udp\", p.Address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := s.UDPConn.WriteToUDP(p.Data, uaddr); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := s.UDPConn.SetDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "FSMID_for_test": 112,
    "Code_level": "Class-level"
}