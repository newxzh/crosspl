{
    "Task_id": 197,
    "Github_ID": "179326472",
    "Github_Project_Name": "ignite",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Net-based TCP Server in Go",
    "Instruction": "Task Description: Create a TCP server in Go that can handle multiple client connections concurrently, manage server lifecycle, and track active connections.\n\nStruct Description: The Server struct represents a TCP server that listens for incoming connections, handles client communication, and provides server management capabilities.\n\nFields:\n- Addr: string - The network address to listen on (e.g., \":8080\")\n- Net: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\n- Handler: Handler - Interface for custom request handling (implementation not shown)\n- Listener: net.Listener - The underlying network listener\n- conns: map[net.Conn]struct{} - Track active connections\n- lock: sync.RWMutex - Protects concurrent access to server state\n- started: bool - Indicates if server is running\n- shutdown: chan struct{} - Channel for shutdown signaling\n\nMethods:\n- ListenAndServe() error - Starts the server and begins accepting connections\n- init() - Initializes server resources (internal use)\n- serveTCP(net.Listener) error - Main server loop that accepts connections (internal use)\n- serveTCPConn(*sync.WaitGroup, net.Conn) - Handles individual client connections (internal use)\n- isStarted() bool - Thread-safe check of server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tListener net.Listener\n\tconns    map[net.Conn]struct{}\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tl, err := net.Listen(srv.Net, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Listener = l\n\tsrv.started = true\n\tunlock()\n\treturn srv.serveTCP(l)\n}\n\nfunc (srv *Server) init() {\n\tsrv.shutdown = make(chan struct{})\n\tsrv.conns = make(map[net.Conn]struct{})\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tdefer func() {\n\t\tsrv.lock.Lock()\n\t\tdelete(srv.conns, rw)\n\t\tsrv.lock.Unlock()\n\t\trw.Close()\n\t\twg.Done()\n\t}()\n\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := rw.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = rw.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (srv *Server) isStarted() bool {\n\tsrv.lock.RLock()\n\tstarted := srv.started\n\tsrv.lock.RUnlock()\n\treturn started\n}\n\nfunc unlockOnce(l sync.Locker) func() {\n\tvar once sync.Once\n\treturn func() { once.Do(l.Unlock) }\n}",
    "FSMID_for_test": 109,
    "Code_level": "Class-level"
}