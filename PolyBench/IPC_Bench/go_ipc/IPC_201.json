{
    "Task_id": 201,
    "Github_ID": "218706050",
    "Github_Project_Name": "gochat",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Net-based TCP Server in Go",
    "Instruction": "Task Description: Implement a TCP server in Go that handles multiple client connections concurrently, with configurable timeouts and graceful shutdown capabilities.\n\nStruct Description: The Server struct represents a TCP server with configurable network settings, timeouts, and connection management.\n\nFields:\n\nAddr: string - The network address to listen on (e.g., \":8080\")\nNet: string - The network type (e.g., \"tcp\", \"tcp4\", \"tcp6\")\nHandler: Handler - Interface for handling incoming requests\nReadTimeout: time.Duration - Maximum duration for reading a request\nWriteTimeout: time.Duration - Maximum duration for writing a response\nIdleTimeout: func() time.Duration - Function returning idle connection timeout\nlock: sync.RWMutex - Protects concurrent access to server state\nstarted: bool - Indicates if server is running\nshutdown: chan struct{} - Channel for shutdown signaling\nconns: map[net.Conn]struct{} - Active connections map\n\nMethods:\n\nListenAndServe() error - Starts the server and begins accepting connections\nserveTCP(net.Listener) error - Internal method to handle TCP connections\nserveTCPConn(*sync.WaitGroup, net.Conn) - Handles an individual TCP connection\nShutdownContext(context.Context) error - Gracefully shuts down the server with context support\nisStarted() bool - Helper method to check server status (internal use)",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Server struct {\n\tAddr    string\n\tNet     string\n\tHandler Handler\n\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout  func() time.Duration\n\n\tlock     sync.RWMutex\n\tstarted  bool\n\tshutdown chan struct{}\n\tconns    map[net.Conn]struct{}\n}\n\nfunc (srv *Server) ListenAndServe() error {\n\tunlock := unlockOnce(&srv.lock)\n\tsrv.lock.Lock()\n\tdefer unlock()\n\n\tif srv.started {\n\t\treturn &Error{err: \"server already started\"}\n\t}\n\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":domain\"\n\t}\n\n\tsrv.init()\n\n\tswitch srv.Net {\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\tl, err := listenTCP(srv.Net, addr, srv.ReusePort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.Listener = l\n\t\tsrv.started = true\n\t\tunlock()\n\t\treturn srv.serveTCP(l)\n\t}\n\treturn &Error{err: \"bad network\"}\n}\n\nfunc (srv *Server) serveTCP(l net.Listener) error {\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\tdefer func() {\n\t\twg.Wait()\n\t\tclose(srv.shutdown)\n\t}()\n\n\tfor srv.isStarted() {\n\t\trw, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif !srv.isStarted() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif neterr, ok := err.(net.Error); ok && neterr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tsrv.lock.Lock()\n\t\tsrv.conns[rw] = struct{}{}\n\t\tsrv.lock.Unlock()\n\t\twg.Add(1)\n\t\tgo srv.serveTCPConn(&wg, rw)\n\t}\n\n\treturn nil\n}\n\nfunc (srv *Server) serveTCPConn(wg *sync.WaitGroup, rw net.Conn) {\n\tw := &response{tcp: rw, writer: w}\n\n\tidleTimeout := tcpIdleTimeout\n\tif srv.IdleTimeout != nil {\n\t\tidleTimeout = srv.IdleTimeout()\n\t}\n\n\ttimeout := srv.getReadTimeout()\n\n\tlimit := srv.MaxTCPQueries\n\tif limit == 0 {\n\t\tlimit = maxTCPQueries\n\t}\n\n\tfor q := 0; (q < limit || limit == -1) && srv.isStarted(); q++ {\n\t\tm, err := reader.ReadTCP(w.tcp, timeout)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tsrv.serveDNS(m, w)\n\t\tif w.closed {\n\t\t\tbreak\n\t\t}\n\t\tif w.hijacked {\n\t\t\tbreak\n\t\t}\n\t\ttimeout = idleTimeout\n\t}\n\n\tif !w.hijacked {\n\t\tw.Close()\n\t}\n\n\tsrv.lock.Lock()\n\tdelete(srv.conns, w.tcp)\n\tsrv.lock.Unlock()\n\n\twg.Done()\n}\n\nfunc (srv *Server) ShutdownContext(ctx context.Context) error {\n\tsrv.lock.Lock()\n\tif !srv.started {\n\t\tsrv.lock.Unlock()\n\t\treturn &Error{err: \"server not started\"}\n\t}\n\n\tsrv.started = false\n\n\tif srv.Listener != nil {\n\t\tsrv.Listener.Close()\n\t}\n\n\tfor rw := range srv.conns {\n\t\trw.SetReadDeadline(aLongTimeAgo)\n\t}\n\n\tsrv.lock.Unlock()\n\n\tvar ctxErr error\n\tselect {\n\tcase <-srv.shutdown:\n\tcase <-ctx.Done():\n\t\tctxErr = ctx.Err()\n\t}\n\n\treturn ctxErr\n}",
    "FSMID_for_test": 109,
    "Code_level": "Class-level"
}