{
    "Task_id": 50,
    "Github_ID": "20545279",
    "Github_Project_Name": "stripe-go",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Basic HTTP server using net/http with HandleFunc and ListenAndServe",
    "Instruction": "Task Description: Create a Go HTTP server that handles Stripe webhook events, specifically processing billing meter error reports and other event types.\n\nFunction Description: The main function sets up an HTTP server with a \"/webhook\" endpoint that receives and processes Stripe webhook events. It validates the webhook signature, retrieves full event details from Stripe, and handles specific event types (particularly \"v1.billing.meter.error_report_triggered\").\n\nInput:\n- HTTP POST requests to \"/webhook\" endpoint containing:\n  - Request body with Stripe event payload (JSON format)\n  - \"Stripe-Signature\" header for webhook validation\n- Environment variables:\n  - apiKey: Stripe API key for authentication\n  - webhookSecret: Secret for validating webhook signatures\n\nOutput:\n- HTTP responses:\n  - 200 OK for successful processing\n  - 500 Internal Server Error for any processing failures\n- Console output:\n  - Success messages with meter IDs for handled events\n  - Error messages for any processing failures\n  - Notifications for unhandled event types\n\nThe function does not explicitly return values but writes to the HTTP response and console.",
    "Canonical_solution": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/stripe/stripe-go/v81\"\n\tbillingMeters \"github.com/stripe/stripe-go/v81/billing/meter\"\n\t\"github.com/stripe/stripe-go/v81/rawrequest\"\n\twebhook \"github.com/stripe/stripe-go/v81/webhook\"\n)\nfunc main() {\n\tb, err := stripe.GetRawRequestBackend(stripe.APIBackend)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tclient := rawrequest.Client{B: b, Key: apiKey}\n\n\thttp.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) {\n\t\tconst MaxBodyBytes = int64(65536)\n\t\treq.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes)\n\t\tpayload, err := ioutil.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\terr = webhook.ValidatePayload(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tvar thinEvent map[string]interface{}\n\n\t\tif err := json.Unmarshal(payload, &thinEvent); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse thin event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\teventID := thinEvent[\"id\"].(string)\n\n\t\tvar event map[string]interface{}\n\n\t\tresp, err := client.RawRequest(http.MethodGet, \"/v2/core/events/\"+eventID, \"\", nil)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get pull event: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := json.Unmarshal(resp.RawJSON, &event); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Failed to parse pull event body json: %v\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tswitch t := event[\"type\"].(string); t {\n\t\tcase \"v1.billing.meter.error_report_triggered\":\n\t\t\trelatedObject := event[\"related_object\"].(map[string]interface{})\n\t\t\tmeter, err := billingMeters.Get(relatedObject[\"id\"].(string), nil)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Failed to get related meter object: %v\\n\", err.Error())\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmeterID := meter.ID\n\t\t\tfmt.Printf(\"Success! %s\\n\", meterID)\n\t\t\tfmt.Println(fmt.Sprint(event[\"data\"]))\n\t\tdefault:\n\t\t\tfmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", t)\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\terr = http.ListenAndServe(\":4242\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}",
    "FSMID_for_test": 103,
    "Code_level": "Function-level"
}