{
    "Task_id": 342,
    "Github_ID": "173227087",
    "Github_Project_Name": "examples",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "gorilla-based websocket client in Go",
    "Instruction": "Task Description: Create a WebSocket client in Go that connects to a server, sends periodic messages, receives messages from the server, and handles graceful shutdown upon interruption.\n\nFunction Description: The main function establishes a WebSocket connection to a specified server, sets up message reading and writing routines, and handles interrupt signals for graceful termination. It continuously sends timestamp messages at regular intervals while concurrently listening for incoming messages from the server.\n\nInput:\n- Command line argument (flag): addr - string - WebSocket server address (e.g., \"localhost:8080\")\n- Implicit input: System interrupt signal (SIGINT)\n\nOutput:\n- Console logs: Connection status, received messages, and error messages\n- WebSocket messages: Sends timestamp messages to server and receives messages from server\n- Return value: None (program runs until interrupted)\n\nNote: The function uses goroutines for concurrent operations and channels for synchronization and interrupt handling.",
    "Canonical_solution": "import (\n\t\"flag\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\n\tinterrupt := make(chan os.Signal, 1)\n\tsignal.Notify(interrupt, os.Interrupt)\n\n\tu := url.URL{Scheme: \"ws\", Host: *addr, Path: \"/echo\"}\n\tlog.Printf(\"connecting to %s\", u.String())\n\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"dial:\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"recv: %s\", message)\n\t\t}\n\t}()\n\n\tticker := time.NewTicker(time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\treturn\n\t\tcase t := <-ticker.C:\n\t\t\terr := c.WriteMessage(websocket.TextMessage, []byte(t.String()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-interrupt:\n\t\t\tlog.Println(\"interrupt\")\n\n\t\t\terr := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"write close:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-time.After(time.Second):\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}",
    "FSMID_for_test": 115,
    "Code_level": "Function-level"
}