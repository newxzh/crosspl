{
    "Task_id": 245,
    "Github_ID": "354515412",
    "Github_Project_Name": "devzat",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Official-based gRPC server in Go",
    "Instruction": "Task Description: Implement a gRPC server in Go that handles plugin registration and message streaming between clients and middleware components.\n\nStruct Description: The pluginServer struct implements a gRPC service for plugin registration and message handling, managing concurrent access with synchronization and supporting both middleware and non-middleware listeners.\n\nFields:\n- UnimplementedPluginServer: pb.UnimplementedPluginServer - Embedded type for forward compatibility\n- lock: sync.Mutex - Synchronization primitive for thread-safe operations\n\nMethods:\n- RegisterListener: (stream pb.Plugin_RegisterListenerServer) -> error - Handles client registration and message streaming\n  - Input: gRPC bidirectional stream of pb.Plugin_RegisterListenerServer\n  - Output: error indicating operation status\n  - Description: Registers listeners, processes incoming messages, matches against regex patterns, handles middleware responses, and manages one-time listeners\n\n- rpcInit: () -> () - Initializes and starts the gRPC server\n  - Input: None (uses package-level Integrations.RPC configuration)\n  - Output: None (runs as goroutine)\n  - Description: Creates TCP listener, configures gRPC server with interceptors and keepalive, registers service, and starts serving requests",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/keepalive\"\n\t\"google.golang.org/grpc/metadata\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype pluginServer struct {\n\tpb.UnimplementedPluginServer\n\tlock sync.Mutex\n}\n\nfunc (s *pluginServer) RegisterListener(stream pb.Plugin_RegisterListenerServer) error {\n\ts.lock.Lock()\n\tinitialData, err := stream.Recv()\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistener := initialData.GetListener()\n\tif listener == nil {\n\t\treturn status.Error(codes.InvalidArgument, \"First message must be a listener\")\n\t}\n\n\tisMiddleware := listener.Middleware != nil && *listener.Middleware\n\tisOnce := listener.Once != nil && *listener.Once\n\n\tvar regex *regexp.Regexp\n\tif listener.Regex != nil {\n\t\tregex, err = regexp.Compile(*listener.Regex)\n\t\tif err != nil {\n\t\t\treturn status.Error(codes.InvalidArgument, \"Invalid regex\")\n\t\t}\n\t}\n\n\tvar listenerList *[]chan pb.MiddlewareChannelMessage\n\n\tif isMiddleware {\n\t\tlistenerList = &ListenersMiddleware\n\t} else {\n\t\tlistenerList = &ListenersNonMiddleware\n\t}\n\n\tc := make(chan pb.MiddlewareChannelMessage)\n\t*listenerList = append(*listenerList, c)\n\n\ts.lock.Unlock()\n\tdefer func() {\n\t\tfor i := range *listenerList {\n\t\t\tif (*listenerList)[i] == c {\n\t\t\t\t*listenerList = append((*listenerList)[:i], (*listenerList)[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tmessage := <-c\n\n\t\tsendNilResponse := func() {\n\t\t\tc <- &pb.ListenerClientData_Response{\n\t\t\t\tResponse: &pb.MiddlewareResponse{\n\t\t\t\t\tMsg: nil,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif listener.Regex != nil && !regex.MatchString(message.(*pb.Event).Msg) {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\terr = stream.Send(message.(*pb.Event))\n\t\tif err != nil {\n\t\t\tif isMiddleware {\n\t\t\t\tsendNilResponse()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif isMiddleware {\n\t\t\tmwRes, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tswitch data := mwRes.Data.(type) {\n\t\t\tcase *pb.ListenerClientData_Listener:\n\t\t\t\tsendNilResponse()\n\t\t\t\treturn status.Error(codes.InvalidArgument, \"Middleware returned a listener instead of a response\")\n\t\t\tcase *pb.ListenerClientData_Response:\n\t\t\t\tc <- data\n\t\t\t}\n\t\t}\n\n\t\tif isOnce {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc rpcInit() {\n\tif Integrations.RPC == nil {\n\t\treturn\n\t}\n\tgo func() {\n\t\tlis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", Integrations.RPC.Port))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgrpcServer := grpc.NewServer(\n\t\t\tgrpc.UnaryInterceptor(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\t\t\tif err := authorize(ctx); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn handler(ctx, req)\n\t\t\t}),\n\t\t\tgrpc.StreamInterceptor(func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n\t\t\t\tif err := authorize(stream.Context()); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn handler(srv, stream)\n\t\t\t}),\n\t\t\tgrpc.KeepaliveParams(keepalive.ServerParameters{Time: time.Second * 10}),\n\t\t)\n\t\tpb.RegisterPluginServer(grpcServer, &pluginServer{})\n\t\tgrpcServer.Serve(lis)\n\t}()\n}",
    "FSMID_for_test": 119,
    "Code_level": "Class-level"
}