{
    "Task_id": 269,
    "Github_ID": "150713223",
    "Github_Project_Name": "kubeedge",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Official-based gRPC server in Go",
    "Instruction": "Task Description: Implement a gRPC server for a CSI (Container Storage Interface) driver in Go, including server lifecycle management, request interception, and authentication.\n\nStruct Description: CSIDriver represents a gRPC server implementation for CSI driver operations, managing server lifecycle, intercepting requests, and handling authentication.\n\nFields:\n- listener: net.Listener - Network listener for incoming connections\n- server: *grpc.Server - gRPC server instance\n- servers: *CSIDriverServers - CSI service implementations (Controller, Identity, Node)\n- wg: sync.WaitGroup - Synchronization for graceful shutdown\n- running: bool - Server running state flag\n- lock: sync.Mutex - Mutex for thread-safe operations\n- creds: *CSICreds - Authentication credentials\n- logGRPC: LogGRPC - Callback for logging gRPC calls\n\nMethods:\n- NewCSIDriver(*CSIDriverServers) -> *CSIDriver - Constructor that creates a new CSIDriver instance with given service implementations\n- Start(net.Listener, grpc.UnaryServerInterceptor) -> error - Starts the gRPC server with optional interceptor\n- goServe(chan<- bool) -> - Internal method to start server in goroutine\n- Stop() -> - Stops the server gracefully\n- callInterceptor(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) -> (interface{}, error) - Request interceptor handling authentication and logging",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype CSIDriver struct {\n\tlistener net.Listener\n\tserver   *grpc.Server\n\tservers  *CSIDriverServers\n\twg       sync.WaitGroup\n\trunning  bool\n\tlock     sync.Mutex\n\tcreds    *CSICreds\n\tlogGRPC  LogGRPC\n}\n\ntype LogGRPC func(method string, request, reply interface{}, err error)\n\nfunc NewCSIDriver(servers *CSIDriverServers) *CSIDriver {\n\treturn &CSIDriver{\n\t\tservers: servers,\n\t}\n}\n\nfunc (c *CSIDriver) Start(l net.Listener, interceptor grpc.UnaryServerInterceptor) error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.listener = l\n\n\tif interceptor == nil {\n\t\tinterceptor = c.callInterceptor\n\t}\n\tc.server = grpc.NewServer(grpc.UnaryInterceptor(interceptor))\n\n\tif c.servers.Controller != nil {\n\t\tcsi.RegisterControllerServer(c.server, c.servers.Controller)\n\t}\n\tif c.servers.Identity != nil {\n\t\tcsi.RegisterIdentityServer(c.server, c.servers.Identity)\n\t}\n\tif c.servers.Node != nil {\n\t\tcsi.RegisterNodeServer(c.server, c.servers.Node)\n\t}\n\n\twaitForServer := make(chan bool)\n\tc.goServe(waitForServer)\n\t<-waitForServer\n\tc.running = true\n\treturn nil\n}\n\nfunc (c *CSIDriver) goServe(started chan<- bool) {\n\tgo func() {\n\t\tc.wg.Add(1)\n\t\tdefer c.wg.Done()\n\t\tstarted <- true\n\t\tc.server.Serve(c.listener)\n\t}()\n}\n\nfunc (c *CSIDriver) Stop() {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif !c.running {\n\t\treturn\n\t}\n\n\tc.server.Stop()\n\tc.wg.Wait()\n}\n\nfunc (c *CSIDriver) callInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\terr := authInterceptor(c.creds, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trsp, err := handler(ctx, req)\n\tif c.logGRPC != nil {\n\t\tc.logGRPC(info.FullMethod, req, rsp, err)\n\t}\n\treturn rsp, err\n}",
    "FSMID_for_test": 119,
    "Code_level": "Class-level"
}