{
    "Task_id": 358,
    "Github_ID": "390982669",
    "Github_Project_Name": "natpass",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "gorilla-based websocket server in Go",
    "Instruction": "Task Description: Implement a WebSocket handler for VNC (Virtual Network Computing) functionality that enables remote desktop interaction through a WebSocket connection, including image transmission, clipboard sharing, and input event handling.\n\nStruct Description: The VNC struct represents a VNC over WebSocket handler that manages the connection between a client and a remote VNC server, facilitating bidirectional communication for remote desktop operations.\n\nFields:\n- link: *network.Link - Represents the network link to the remote VNC server\n- chClipboard: chan string - Channel for transmitting clipboard content between client and server\n\nMethods:\n- WS: (conn *conn.Conn, w http.ResponseWriter, r *http.Request) -> None - Handles WebSocket upgrade and manages the VNC session lifecycle\n- remoteRead: (ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) -> None - Processes incoming messages from the remote VNC server\n- localRead: (ctx context.Context, local *websocket.Conn, remote *conn.Conn) -> None - Handles messages received from the WebSocket client\n- mouseEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse movement and click events\n- keyboardEvent: (remote *conn.Conn, data []byte) -> None - Handles keyboard input events\n- cadEvent: (remote *conn.Conn) -> None - Manages Ctrl+Alt+Del special key combination\n- scrollEvent: (remote *conn.Conn, data []byte) -> None - Processes mouse scroll wheel events",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/jpeg\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/lwch/logging\"\n\t\"github.com/lwch/natpass/code/client/conn\"\n\t\"github.com/lwch/natpass/code/network\"\n\t\"github.com/lwch/runtime\"\n)\n\nvar upgrader = websocket.Upgrader{}\n\ntype VNC struct {\n\tlink         *network.Link\n\tchClipboard  chan string\n}\n\nfunc (v *VNC) WS(conn *conn.Conn, w http.ResponseWriter, r *http.Request) {\n\tid := strings.TrimPrefix(r.URL.Path, \"/ws/\")\n\tlocal, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer local.Close()\n\tch := conn.ChanRead(id)\n\tdefer conn.SendDisconnect(v.link.target, v.link.id)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.remoteRead(ctx, ch, local)\n\t}()\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer wg.Done()\n\t\tv.localRead(ctx, local, conn)\n\t}()\n\twg.Wait()\n}\n\nfunc (v *VNC) remoteRead(ctx context.Context, ch <-chan *network.Msg, local *websocket.Conn) {\n\tdefer utils.Recover(\"remoteRead\")\n\tfor {\n\t\tvar msg *network.Msg\n\t\tselect {\n\t\tcase msg = <-ch:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t\tswitch msg.GetXType() {\n\t\tcase network.Msg_vnc_image:\n\t\t\tdata, err := decodeImage(msg.GetVimg())\n\t\t\truntime.Assert(err)\n\t\t\treplyImage(local, msg.GetVimg(), data, len(msg.GetVimg().GetData()))\n\t\tcase network.Msg_vnc_clipboard:\n\t\t\tv.chClipboard <- msg.GetVclipboard()\n\t\tdefault:\n\t\t\tlogging.Error(\"on message: %s\", msg.GetXType().String())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (v *VNC) localRead(ctx context.Context, local *websocket.Conn, remote *conn.Conn) {\n\tdefer utils.Recover(\"localRead\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\t_, data, err := local.ReadMessage()\n\t\tif err != nil {\n\t\t\tlogging.Error(\"local read: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg struct {\n\t\t\tAction string `json:\"action\"`\n\t\t}\n\t\terr = json.Unmarshal(data, &msg)\n\t\tif err != nil {\n\t\t\tlogging.Error(\"unmarshal: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch msg.Action {\n\t\tcase \"mouse\":\n\t\t\tv.mouseEvent(remote, data)\n\t\tcase \"keyboard\":\n\t\t\tv.keyboardEvent(remote, data)\n\t\tcase \"cad\":\n\t\t\tv.cadEvent(remote)\n\t\tcase \"scroll\":\n\t\t\tv.scrollEvent(remote, data)\n\t\t}\n\t}\n}\n\nfunc decodeImage(data *network.VncImage) ([]byte, error) {\n\tswitch data.GetEncode() {\n\tcase network.VncImage_raw:\n\t\treturn data.GetData(), nil\n\tcase network.VncImage_jpeg:\n\t\timg, err := jpeg.Decode(bytes.NewReader(data.GetData()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trect := img.Bounds()\n\t\traw := image.NewRGBA(rect)\n\t\tdraw.Draw(raw, rect, img, rect.Min, draw.Src)\n\t\treturn raw.Pix, nil\n\tcase network.VncImage_png:\n\t}\n\treturn nil, errors.New(\"unsupported\")\n}\n\nfunc replyImage(conn *websocket.Conn, msg *network.VncImage, data []byte, srcSize int) {\n\tinfo := msg.GetXInfo()\n\tbuf := make([]byte, len(data)+28)\n\tbinary.BigEndian.PutUint32(buf, info.GetScreenWidth())\n\tbinary.BigEndian.PutUint32(buf[4:], info.GetScreenHeight())\n\tbinary.BigEndian.PutUint32(buf[8:], info.GetRectX())\n\tbinary.BigEndian.PutUint32(buf[12:], info.GetRectY())\n\tbinary.BigEndian.PutUint32(buf[16:], info.GetRectWidth())\n\tbinary.BigEndian.PutUint32(buf[20:], info.GetRectHeight())\n\tbinary.BigEndian.PutUint32(buf[24:], uint32(srcSize))\n\tcopy(buf[28:], data)\n\tconn.WriteMessage(websocket.BinaryMessage, buf)\n}",
    "FSMID_for_test": 114,
    "Code_level": "Class-level"
}