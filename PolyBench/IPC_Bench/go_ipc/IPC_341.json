{
    "Task_id": 341,
    "Github_ID": "36529854",
    "Github_Project_Name": "doctl",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "gorilla-based websocket client in Go",
    "Instruction": "Task Description: Create a WebSocket client in Go that can establish a connection to a server, handle bidirectional communication (sending and receiving messages), and properly manage connection lifecycle.\n\nStruct Description: The Listener struct represents a WebSocket client that connects to a specified URL, handles message processing with optional schema transformation, and manages concurrent read/write operations.\n\nFields:\n- URL: *url.URL - The WebSocket server URL to connect to\n- Token: string - Authentication token to be included in the connection URL\n- SchemaFunc: func([]byte) (io.Reader, error) - Optional function to transform incoming messages\n- Out: io.Writer - Output writer for received messages\n- InCh: <-chan []byte - Input channel for sending messages to the server\n\nMethods:\n- NewListener: (url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) -> *Listener - Creates a new Listener instance with the specified configuration\n- Listen: (ctx context.Context) -> error - Establishes WebSocket connection, handles concurrent message reading/writing, and manages connection lifecycle until context cancellation or normal closure",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype Listener struct {\n\tURL        *url.URL\n\tToken      string\n\tSchemaFunc func([]byte) (io.Reader, error)\n\tOut        io.Writer\n\tInCh       <-chan []byte\n}\n\nfunc NewListener(url *url.URL, token string, schemaFunc func([]byte) (io.Reader, error), out io.Writer, inCh <-chan []byte) *Listener {\n\treturn &Listener{\n\t\tURL:        url,\n\t\tToken:      token,\n\t\tSchemaFunc: schemaFunc,\n\t\tOut:        out,\n\t\tInCh:       inCh,\n\t}\n}\n\nfunc (l *Listener) Listen(ctx context.Context) error {\n\tif l.Token != \"\" {\n\t\tparams := l.URL.Query()\n\t\tparams.Set(\"token\", l.Token)\n\t\tl.URL.RawQuery = params.Encode()\n\t}\n\n\tc, _, err := websocket.DefaultDialer.Dial(l.URL.String(), nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating websocket connection: %w\", err)\n\t}\n\tdefer c.Close()\n\n\tdone := make(chan struct{})\n\tgrp, ctx := errgroup.WithContext(ctx)\n\tgrp.Go(func() error {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"error reading from websocket: %w\", err)\n\t\t\t}\n\n\t\t\tvar r io.Reader\n\t\t\tif l.SchemaFunc != nil {\n\t\t\t\tr, err = l.SchemaFunc(message)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr = bytes.NewReader(message)\n\t\t\t}\n\n\t\t\tio.Copy(l.Out, r)\n\t\t}\n\t})\n\n\tgrp.Go(func() error {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase data := <-l.InCh:\n\t\t\t\tif err := c.WriteMessage(websocket.TextMessage, data); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing to websocket: %w\", err)\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error writing close message: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\tcase <-done:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t})\n\tif err := grp.Wait(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "FSMID_for_test": 115,
    "Code_level": "Class-level"
}