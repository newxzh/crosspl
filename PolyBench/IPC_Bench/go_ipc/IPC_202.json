{
    "Task_id": 202,
    "Github_ID": "430536935",
    "Github_Project_Name": "loggie",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Net-based TCP Server in Go",
    "Instruction": "Task Description: Create a Unix domain socket server in Go that listens for incoming connections, handles client communication, and processes received data through a product function. The server should manage connection limits, timeouts, and proper resource cleanup.\n\nStruct Description: The `unix` struct represents a Unix domain socket server with configuration options for path, permissions, and connection handling. It manages the socket lifecycle and processes incoming data.\n\nFields:\n- name: string - Identifier for the server instance\n- config: *Config - Pointer to configuration containing path, mode, timeout, max connections, and max bytes\n- done: chan struct{} - Channel to signal server shutdown\n- eventPool: *event.Pool - Pool for managing event objects\n\nMethods:\n- ProductLoop(productFunc api.ProductFunc) -> void - Main server loop that listens for connections and delegates handling to worker goroutines. Takes a product function for processing events.\n- handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) -> void - Handles individual client connections, reads data, and passes it to the product function. Manages connection timeouts and cleanup.\n- checkBind(path string) -> error - Validates and prepares the socket path by removing existing files if necessary\n- chmod(path string, mode string) -> error - Sets filesystem permissions on the socket file",
    "Canonical_solution": "import (\n\t\"bufio\"\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\t\"github.com/loggie-io/loggie/pkg/core/api\"\n\t\"github.com/loggie-io/loggie/pkg/core/event\"\n\t\"github.com/loggie-io/loggie/pkg/core/log\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/netutil\"\n)\n\ntype unix struct {\n\tname      string\n\tconfig    *Config\n\tdone      chan struct{}\n\teventPool *event.Pool\n}\n\nfunc (k *unix) ProductLoop(productFunc api.ProductFunc) {\n\tlog.Info(\"%s start product loop\", k.String())\n\n\tif err := checkBind(k.config.Path); err != nil {\n\t\tlog.Error(\"check unix sock path error: %+v\", err)\n\t\treturn\n\t}\n\n\tlistener, err := net.Listen(\"unix\", k.config.Path)\n\tif err != nil {\n\t\tlog.Error(\"setup unix listener failed: %v\", err)\n\t\treturn\n\t}\n\n\tif err := chmod(k.config.Path, k.config.Mode); err != nil {\n\t\tlog.Error(\"chmod unix path %s with %s failed: %v\", k.config.Path, k.config.Mode, err)\n\t\treturn\n\t}\n\n\tif k.config.MaxConnections > 0 {\n\t\tlistener = netutil.LimitListener(listener, k.config.MaxConnections)\n\t}\n\n\tdefer listener.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfor {\n\t\tselect {\n\t\tcase <-k.done:\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"unix sock listener accept connection failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo k.handleConn(ctx, conn, productFunc)\n\t}\n}\n\nfunc (k *unix) handleConn(ctx context.Context, conn net.Conn, productFunc api.ProductFunc) {\n\tdefer conn.Close()\n\n\tbuf := bufio.NewReader(conn)\n\tscan := bufio.NewScanner(buf)\n\n\tinitBuffer := make([]byte, k.config.MaxBytes/4)\n\tscan.Buffer(initBuffer, k.config.MaxBytes)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tdefault:\n\t\t}\n\n\t\tif err := conn.SetDeadline(time.Now().Add(k.config.Timeout)); err != nil {\n\t\t\tlog.Warn(\"set connection timeout error: %v\", err)\n\t\t}\n\n\t\tif !scan.Scan() {\n\t\t\tif scan.Err() != nil {\n\t\t\t\tlog.Warn(\"scan connection error: %v\", scan.Err())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tbody := scan.Bytes()\n\t\tcopyBody := make([]byte, len(body))\n\t\tcopy(copyBody, body)\n\t\te := k.eventPool.Get()\n\t\te.Fill(e.Meta(), e.Header(), copyBody)\n\n\t\tproductFunc(e)\n\t}\n}\n\nfunc checkBind(path string) error {\n\t_, err := os.Lstat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn errors.WithMessagef(err, \"stat path %s failed\", path)\n\t}\n\n\tif err := os.Remove(path); err != nil {\n\t\treturn errors.WithMessagef(err, \"remove path %s failed\", path)\n\t}\n\n\treturn nil\n}\n\nfunc chmod(path string, mode string) error {\n\tparsed, err := strconv.ParseUint(mode, 8, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(path, os.FileMode(parsed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "FSMID_for_test": 109,
    "Code_level": "Class-level"
}