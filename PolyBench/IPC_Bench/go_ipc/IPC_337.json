{
    "Task_id": 337,
    "Github_ID": "53171300",
    "Github_Project_Name": "tile38",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Simple Rabbitmq producer in go",
    "Instruction": "Task Description: Implement a thread-safe RabbitMQ producer in Go that handles connection management, queue/exchange declaration, and message publishing.\n\nStruct Description: AMQPConn represents a RabbitMQ connection with built-in connection pooling and thread safety. It manages the AMQP connection, channel, and provides message sending capability.\n\nFields:\n\nmu: [sync.Mutex] - Mutex for thread-safe operations\nep: [Endpoint] - Configuration endpoint containing AMQP settings\nconn: [*amqp.Connection] - Underlying AMQP connection\nchannel: [*amqp.Channel] - AMQP channel for message operations\nex: [bool] - Flag indicating if connection is expired\nt: [time.Time] - Timestamp of last operation\n\nMethods:\n\nSend: [Name](msg string) -> [error] - Publishes a message to RabbitMQ. Handles connection establishment, channel creation, and queue/exchange declaration if not already done. Returns error if operation fails.\n[Input Parameters]:\n- msg: string - The message to be published\n[Return Type]:\n- error - Returns nil on success, error on failure",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\ntype AMQPConn struct {\n\tmu      sync.Mutex\n\tep      Endpoint\n\tconn    *amqp.Connection\n\tchannel *amqp.Channel\n\tex      bool\n\tt       time.Time\n}\n\nfunc (conn *AMQPConn) Send(msg string) error {\n\tconn.mu.Lock()\n\tdefer conn.mu.Unlock()\n\n\tif conn.ex {\n\t\treturn errExpired\n\t}\n\tconn.t = time.Now()\n\n\tif conn.conn == nil {\n\t\tprefix := \"amqp://\"\n\t\tif conn.ep.AMQP.SSL {\n\t\t\tprefix = \"amqps://\"\n\t\t}\n\n\t\tvar cfg amqp.Config\n\t\tcfg.Dial = func(network, addr string) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(network, addr, time.Second)\n\t\t}\n\t\tc, err := amqp.DialConfig(fmt.Sprintf(\"%s%s\", prefix, conn.ep.AMQP.URI), cfg)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := channel.ExchangeDeclare(\n\t\t\tconn.ep.AMQP.QueueName,\n\t\t\tconn.ep.AMQP.Type,\n\t\t\tconn.ep.AMQP.Durable,\n\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\tconn.ep.AMQP.Internal,\n\t\t\tconn.ep.AMQP.NoWait,\n\t\t\tnil,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif conn.ep.AMQP.Type != \"topic\" {\n\t\t\tif _, err := channel.QueueDeclare(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.Durable,\n\t\t\t\tconn.ep.AMQP.AutoDelete,\n\t\t\t\tfalse,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := channel.QueueBind(\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.RouteKey,\n\t\t\t\tconn.ep.AMQP.QueueName,\n\t\t\t\tconn.ep.AMQP.NoWait,\n\t\t\t\tnil,\n\t\t\t); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tconn.conn = c\n\t\tconn.channel = channel\n\t}\n\n\treturn conn.channel.Publish(\n\t\tconn.ep.AMQP.QueueName,\n\t\tconn.ep.AMQP.RouteKey,\n\t\tconn.ep.AMQP.Mandatory,\n\t\tconn.ep.AMQP.Immediate,\n\t\tamqp.Publishing{\n\t\t\tHeaders:         amqp.Table{},\n\t\t\tContentType:     \"application/json\",\n\t\t\tContentEncoding: \"\",\n\t\t\tBody:            []byte(msg),\n\t\t\tDeliveryMode:    conn.ep.AMQP.DeliveryMode,\n\t\t\tPriority:        conn.ep.AMQP.Priority,\n\t\t},\n\t)\n}",
    "FSMID_for_test": 121,
    "Code_level": "Class-level"
}