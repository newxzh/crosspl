{
    "Task_id": 378,
    "Github_ID": "28986292",
    "Github_Project_Name": "torrent",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "nhooyr.io-based websocket client in Go",
    "Instruction": "Task Description: The provided code demonstrates a WebSocket client implementation in Go for tracker communication in a peer-to-peer network, handling WebSocket connections, message exchange, and WebRTC offer/answer negotiation.\n\nStruct Description: TrackerClient represents a client for interacting with a WebSocket tracker server, managing WebSocket connections, peer connections, and message handling.\n\nFields:\n\nUrl: string - The WebSocket tracker server URL to connect to\nGetAnnounceRequest: func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error) - Function to generate announce requests\nPeerId: [20]byte - The client's peer identifier\nOnConn: onDataChannelOpen - Callback for when data channels open\nLogger: log.Logger - Logger for client operations\nDialer: *websocket.Dialer - WebSocket dialer configuration\nmu: sync.Mutex - Mutex for thread-safe operations\ncond: sync.Cond - Condition variable for connection state changes\noutboundOffers: map[string]outboundOfferValue - Track outbound WebRTC offers\nwsConn: *websocket.Conn - Active WebSocket connection\nclosed: bool - Connection closed flag\npingTicker: *time.Ticker - Timer for sending ping messages\nWebsocketTrackerHttpHeader: func() http.Header - Function to generate WebSocket headers\nICEServers: []webrtc.ICEServer - List of ICE servers for WebRTC\nrtcPeerConns: map[string]*wrappedPeerConnection - Active WebRTC peer connections\n\nMethods:\n\ndoWebsocket: () -> error - Establishes and maintains WebSocket connection to tracker\ntrackerReadLoop: (*websocket.Conn) -> error - Handles incoming WebSocket messages\nwriteMessage: ([]byte) -> error - Writes message to WebSocket connection\nhandleOffer: (offerContext, string) -> error - Processes incoming WebRTC offers\nhandleAnswer: (string, webrtc.SessionDescription) -> void - Processes incoming WebRTC answers",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/anacrolix/log\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/pion/webrtc/v4\"\n\t\"go.opentelemetry.io/otel/trace\"\n)\n\ntype TrackerClient struct {\n\tUrl                string\n\tGetAnnounceRequest func(_ tracker.AnnounceEvent, infoHash [20]byte) (tracker.AnnounceRequest, error)\n\tPeerId             [20]byte\n\tOnConn             onDataChannelOpen\n\tLogger             log.Logger\n\tDialer             *websocket.Dialer\n\n\tmu             sync.Mutex\n\tcond           sync.Cond\n\toutboundOffers map[string]outboundOfferValue\n\twsConn         *websocket.Conn\n\tclosed         bool\n\tpingTicker     *time.Ticker\n\n\tWebsocketTrackerHttpHeader func() http.Header\n\tICEServers                 []webrtc.ICEServer\n\n\trtcPeerConns map[string]*wrappedPeerConnection\n}\n\nfunc (tc *TrackerClient) doWebsocket() error {\n\ttc.mu.Lock()\n\ttc.mu.Unlock()\n\n\tvar header http.Header\n\tif tc.WebsocketTrackerHttpHeader != nil {\n\t\theader = tc.WebsocketTrackerHttpHeader()\n\t}\n\n\tc, _, err := tc.Dialer.Dial(tc.Url, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing tracker: %w\", err)\n\t}\n\tdefer c.Close()\n\ttc.Logger.WithDefaultLevel(log.Info).Printf(\"connected\")\n\ttc.mu.Lock()\n\ttc.wsConn = c\n\ttc.cond.Broadcast()\n\ttc.mu.Unlock()\n\tcloseChan := make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tc.pingTicker.C:\n\t\t\t\ttc.mu.Lock()\n\t\t\t\terr := c.WriteMessage(websocket.PingMessage, []byte{})\n\t\t\t\ttc.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-closeChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\terr = tc.trackerReadLoop(tc.wsConn)\n\tclose(closeChan)\n\ttc.mu.Lock()\n\tc.Close()\n\ttc.mu.Unlock()\n\treturn err\n}\n\nfunc (tc *TrackerClient) trackerReadLoop(tracker *websocket.Conn) error {\n\tfor {\n\t\t_, message, err := tracker.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"read message error: %w\", err)\n\t\t}\n\t\ttc.Logger.Levelf(log.Debug, \"received message: %q\", message)\n\n\t\tvar ar AnnounceResponse\n\t\tif err := json.Unmarshal(message, &ar); err != nil {\n\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error unmarshalling announce response: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase ar.Offer != nil:\n\t\t\tih, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.WithDefaultLevel(log.Warning).Printf(\"error decoding info_hash in offer: %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr = tc.handleOffer(offerContext{\n\t\t\t\tSessDesc: *ar.Offer,\n\t\t\t\tId:       ar.OfferID,\n\t\t\t\tInfoHash: ih,\n\t\t\t}, ar.PeerID)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Error, \"handling offer for infohash %x: %v\", ih, err)\n\t\t\t}\n\t\tcase ar.Answer != nil:\n\t\t\ttc.handleAnswer(ar.OfferID, *ar.Answer)\n\t\tdefault:\n\t\t\t_, err := jsonStringToInfoHash(ar.InfoHash)\n\t\t\tif err != nil {\n\t\t\t\ttc.Logger.Levelf(log.Warning, \"unexpected announce response %q\", message)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tc *TrackerClient) writeMessage(data []byte) error {\n\tfor tc.wsConn == nil {\n\t\tif tc.closed {\n\t\t\treturn fmt.Errorf(\"%T closed\", tc)\n\t\t}\n\t\ttc.cond.Wait()\n\t}\n\treturn tc.wsConn.WriteMessage(websocket.TextMessage, data)\n}",
    "FSMID_for_test": 117,
    "Code_level": "Class-level"
}