{
    "Task_id": 382,
    "Github_ID": "774198099",
    "Github_Project_Name": "piko",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "nhooyr.io-based websocket client in Go",
    "Instruction": "Task Description: Create a WebSocket client connection wrapper in Go that provides a simplified interface for reading and writing binary messages over a WebSocket connection, with proper error handling and connection management.\n\nStruct Description: The Conn struct wraps a WebSocket connection and provides io.Reader/io.Writer compatible methods for binary message communication, along with standard net.Conn interface methods.\n\nFields:\nwsConn: *websocket.Conn - The underlying WebSocket connection\nreader: io.Reader - Current message reader for streaming message content\n\nMethods:\nNew: (wsConn *websocket.Conn) -> *Conn - Creates a new Conn wrapper instance\nDial: (ctx context.Context, url string, opts ...DialOption) -> (*Conn, error) - Establishes a new WebSocket connection with optional configuration\nRead: (b []byte) -> (int, error) - Reads binary data from the WebSocket connection (implements io.Reader)\nWrite: (b []byte) -> (int, error) - Writes binary data to the WebSocket connection (implements io.Writer)\nClose: () -> error - Closes the WebSocket connection\nLocalAddr: () -> net.Addr - Returns local network address\nRemoteAddr: () -> net.Addr - Returns remote network address\nSetDeadline: (t time.Time) -> error - Sets both read and write deadlines\nSetReadDeadline: (t time.Time) -> error - Sets read deadline\nSetWriteDeadline: (t time.Time) -> error - Sets write deadline",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Conn struct {\n\twsConn *websocket.Conn\n\treader io.Reader\n}\n\nfunc New(wsConn *websocket.Conn) *Conn {\n\treturn &Conn{\n\t\twsConn: wsConn,\n\t\treader: nil,\n\t}\n}\n\nfunc Dial(ctx context.Context, url string, opts ...DialOption) (*Conn, error) {\n\toptions := dialOptions{}\n\tfor _, o := range opts {\n\t\to.apply(&options)\n\t}\n\n\tdialer := &websocket.Dialer{\n\t\tHandshakeTimeout: 60 * time.Second,\n\t}\n\n\tif options.tlsConfig != nil {\n\t\tdialer.TLSClientConfig = options.tlsConfig\n\t}\n\n\theader := make(http.Header)\n\tif options.token != \"\" {\n\t\theader.Set(\"Authorization\", \"Bearer \"+options.token)\n\t}\n\n\twsConn, resp, err := dialer.DialContext(\n\t\tctx, url, header,\n\t)\n\tif err == nil {\n\t\treturn New(wsConn), nil\n\t}\n\tif resp == nil {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\tdefer resp.Body.Close()\n\n\terr = fmt.Errorf(\"%d: %w\", resp.StatusCode, err)\n\tif _, ok := retryableStatusCodes[resp.StatusCode]; ok {\n\t\treturn nil, NewRetryableError(err)\n\t}\n\treturn nil, err\n}\n\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tfor {\n\t\tif c.reader == nil {\n\t\t\tmt, r, err := c.wsConn.NextReader()\n\t\t\tif err != nil {\n\t\t\t\tvar closeErr *websocket.CloseError\n\t\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\t\treturn 0, net.ErrClosed\n\t\t\t\t}\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif mt != websocket.BinaryMessage {\n\t\t\t\treturn 0, fmt.Errorf(\"unexpected message type: %d\", mt)\n\t\t\t}\n\t\t\tc.reader = r\n\t\t}\n\n\t\tn, err := c.reader.Read(b)\n\t\tif n > 0 {\n\t\t\tif err != nil {\n\t\t\t\tc.reader = nil\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err\n\t\t}\n\t\tif err != io.EOF {\n\t\t\tvar closeErr *websocket.CloseError\n\t\t\tif errors.As(err, &closeErr) {\n\t\t\t\treturn 0, net.ErrClosed\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc.reader = nil\n\t}\n}\n\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tif err := c.wsConn.WriteMessage(websocket.BinaryMessage, b); err != nil {\n\t\tvar closeErr *websocket.CloseError\n\t\tif errors.As(err, &closeErr) {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\nfunc (c *Conn) Close() error {\n\treturn c.wsConn.Close()\n}\n\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.wsConn.LocalAddr()\n}\n\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.wsConn.RemoteAddr()\n}\n\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn c.SetWriteDeadline(t)\n}\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.wsConn.SetReadDeadline(t)\n}\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.wsConn.SetWriteDeadline(t)\n}",
    "FSMID_for_test": 117,
    "Code_level": "Class-level"
}