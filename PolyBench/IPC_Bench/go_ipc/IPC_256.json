{
    "Task_id": 256,
    "Github_ID": "66573241",
    "Github_Project_Name": "fabric",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Official-based gRPC server in Go",
    "Instruction": "Task Description: Create a gRPC server for chaincode communication in a Hyperledger Fabric network, supporting both secure (TLS) and insecure connections, with the ability to handle chaincode registration and message echoing.\n\nStruct Description: ccSrv represents a chaincode gRPC server that listens for incoming connections, handles chaincode registration, and echoes received messages back to the client.\n\nFields:\nl: net.Listener - The network listener for incoming connections\ngrpcSrv: *grpc.Server - The gRPC server instance\nt: *testing.T - Testing context for assertions\nexpectedCCname: string - The expected chaincode name for validation during registration\n\nMethods:\nRegister: (stream pb.ChaincodeSupport_RegisterServer) -> error - Handles the chaincode registration stream, validates the chaincode name, and echoes messages back to the client\nstop: () -> () - Stops the gRPC server and closes the listener\nnewCCServer: (t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) -> *ccSrv - Creates and configures a new chaincode server instance with optional TLS support",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\tpb \"github.com/hyperledger/fabric-protos-go-apiv2/peer\"\n\t\"github.com/hyperledger/fabric/common/crypto/tlsgen\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype ccSrv struct {\n\tl              net.Listener\n\tgrpcSrv        *grpc.Server\n\tt              *testing.T\n\texpectedCCname string\n}\n\nfunc (cs *ccSrv) Register(stream pb.ChaincodeSupport_RegisterServer) error {\n\tmsg, err := stream.Recv()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequire.Equal(cs.t, pb.ChaincodeMessage_REGISTER.String(), msg.Type.String())\n\tchaincodeID := &pb.ChaincodeID{}\n\terr = proto.Unmarshal(msg.Payload, chaincodeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequire.Equal(cs.t, cs.expectedCCname, chaincodeID.Name)\n\tfor {\n\t\tmsg, _ = stream.Recv()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = stream.Send(msg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (cs *ccSrv) stop() {\n\tcs.grpcSrv.Stop()\n\tcs.l.Close()\n}\n\nfunc newCCServer(t *testing.T, port int, expectedCCname string, withTLS bool, ca tlsgen.CA) *ccSrv {\n\tvar s *grpc.Server\n\tif withTLS {\n\t\tkeyPair, err := ca.NewServerCertKeyPair(\"localhost\")\n\t\trequire.NoError(t, err)\n\t\tcert, err := tls.X509KeyPair(keyPair.Cert, keyPair.Key)\n\t\trequire.NoError(t, err)\n\t\ttlsConf := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t\tClientCAs:    x509.NewCertPool(),\n\t\t}\n\t\ttlsConf.ClientCAs.AppendCertsFromPEM(ca.CertBytes())\n\t\ts = grpc.NewServer(grpc.Creds(credentials.NewTLS(tlsConf)))\n\t} else {\n\t\ts = grpc.NewServer()\n\t}\n\n\tl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", \"\", port))\n\trequire.NoError(t, err, \"%v\", err)\n\treturn &ccSrv{\n\t\tt:              t,\n\t\texpectedCCname: expectedCCname,\n\t\tl:              l,\n\t\tgrpcSrv:        s,\n\t}\n}",
    "FSMID_for_test": 119,
    "Code_level": "Class-level"
}