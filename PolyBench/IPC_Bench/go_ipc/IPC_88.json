{
    "Task_id": 88,
    "Github_ID": "155658556",
    "Github_Project_Name": "certificates",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Chi-based HTTP Server in Go",
    "Instruction": "Task Description: Implement a Certificate Authority (CA) service in Go using the Chi router for HTTP routing, supporting both secure and insecure servers, with background jobs and proper shutdown handling.\n\nStruct Description: The CA struct represents a Certificate Authority service that manages HTTP servers (secure and insecure), configuration, authentication, and background tasks.\n\nFields:\n\nauth: [*authority.Authority] - The authority component handling certificate operations  \nconfig: [*config.Config] - Configuration settings for the CA service  \nsrv: [*server.Server] - The main secure HTTP server  \ninsecureSrv: [*server.Server] - Optional insecure HTTP server for certain endpoints  \nmetricsSrv: [*server.Server] - Optional metrics server  \nopts: [*options] - Additional service options  \nrenewer: [*TLSRenewer] - Component handling TLS certificate renewal  \ncompactStop: [chan struct{}] - Channel for stopping the background compaction job  \n\nMethods:\n\nInit: [func(cfg *config.Config) (*CA, error)] - Initializes the CA service with configuration, sets up routers, and prepares servers  \nRun: [func() error] - Starts all servers and background jobs, handles graceful shutdown on errors  \nshouldServeInsecureServer: [func() bool] - (implied private method) Determines if insecure server should be started  \nrunCompactJob: [func()] - (implied private method) Runs background compaction task  \nStop: [func() error] - (implied method) Handles service shutdown and cleanup",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype CA struct {\n\tauth        *authority.Authority\n\tconfig      *config.Config\n\tsrv         *server.Server\n\tinsecureSrv *server.Server\n\tmetricsSrv  *server.Server\n\topts        *options\n\trenewer     *TLSRenewer\n\tcompactStop chan struct{}\n}\n\nfunc (ca *CA) Init(cfg *config.Config) (*CA, error) {\n\tmux := chi.NewRouter()\n\thandler := http.Handler(mux)\n\n\tinsecureMux := chi.NewRouter()\n\tinsecureHandler := http.Handler(insecureMux)\n\n\tmux.Use(middleware.GetHead)\n\tinsecureMux.Use(middleware.GetHead)\n\n\tapi.Route(mux)\n\tmux.Route(\"/1.0\", func(r chi.Router) {\n\t\tapi.Route(r)\n\t})\n\n\tinsecureMux.Get(\"/crl\", api.CRL)\n\tinsecureMux.Get(\"/1.0/crl\", api.CRL)\n\n\tbaseContext := buildContext(auth, scepAuthority, acmeDB, acmeLinker)\n\n\tca.srv = server.New(cfg.Address, handler, tlsConfig)\n\tca.srv.BaseContext = func(net.Listener) context.Context {\n\t\treturn baseContext\n\t}\n\n\tif ca.shouldServeInsecureServer() {\n\t\tca.insecureSrv = server.New(cfg.InsecureAddress, insecureHandler, nil)\n\t\tca.insecureSrv.BaseContext = func(net.Listener) context.Context {\n\t\t\treturn baseContext\n\t\t}\n\t}\n\n\treturn ca, nil\n}\n\nfunc (ca *CA) Run() error {\n\tvar wg sync.WaitGroup\n\terrs := make(chan error, 1)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tca.runCompactJob()\n\t}()\n\n\tif ca.insecureSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.insecureSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\tif ca.metricsSrv != nil {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terrs <- ca.metricsSrv.ListenAndServe()\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terrs <- ca.srv.ListenAndServe()\n\t}()\n\n\terr := <-errs\n\n\tif !errors.Is(err, http.ErrServerClosed) {\n\t\tlog.Println(\"shutting down due to startup error ...\")\n\t\tif stopErr := ca.Stop(); stopErr != nil {\n\t\t\terr = fmt.Errorf(\"failed stopping CA after error occurred: %w: %w\", err, stopErr)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"stopped CA after error occurred: %w\", err)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn err\n}",
    "FSMID_for_test": 108,
    "Code_level": "Class-level"
}