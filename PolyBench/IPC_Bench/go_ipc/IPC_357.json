{
    "Task_id": 357,
    "Github_ID": "366764229",
    "Github_Project_Name": "zadig",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "gorilla-based websocket server in Go",
    "Instruction": "Task Description: Create a WebSocket handler function that establishes an SSH connection through a WebSocket interface, allowing for terminal-like interaction with a remote host.\n\nFunction Description: The function `ConnectSshPmExec` handles WebSocket connections to facilitate SSH terminal sessions. It upgrades an HTTP connection to WebSocket, validates host credentials, establishes an SSH connection, and manages bidirectional communication between the WebSocket client and SSH server. The function includes error handling and resource cleanup.\n\nInput:\n- `c` (gin.Context) - Gin framework context for HTTP request handling\n- `username` (string) - Username for authentication (unused in current implementation)\n- `envName` (string) - Environment name (unused in current implementation)\n- `productName` (string) - Product name (unused in current implementation)\n- `ip` (string) - IP address of the target host\n- `hostId` (string) - Identifier for the host's private key\n- `cols` (int) - Terminal column size\n- `rows` (int) - Terminal row size\n- `log` (*zap.SugaredLogger) - Logger for error reporting\n\nOutput:\n- `error` - Returns nil on success, or an error object if any step fails",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ssh\"\n\n\tcommonrepo \"github.com/koderover/zadig/v2/pkg/microservice/aslan/core/common/repository/mongodb\"\n\t\"github.com/koderover/zadig/v2/pkg/setting\"\n\te \"github.com/koderover/zadig/v2/pkg/tool/errors\"\n\ttoolssh \"github.com/koderover/zadig/v2/pkg/tool/ssh\"\n\t\"github.com/koderover/zadig/v2/pkg/tool/wsconn\"\n\t\"github.com/koderover/zadig/v2/pkg/util\"\n)\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\nfunc ConnectSshPmExec(c *gin.Context, username, envName, productName, ip, hostId string, cols, rows int, log *zap.SugaredLogger) error {\n\tws, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tlog.Errorf(\"ws upgrade err:%s\", err)\n\t\treturn e.ErrLoginPm.AddErr(err)\n\t}\n\n\tdefer ws.Close()\n\tresp, err := commonrepo.NewPrivateKeyColl().Find(commonrepo.FindPrivateKeyOption{\n\t\tID: hostId,\n\t})\n\tif err != nil {\n\t\tlog.Errorf(\"PrivateKey.Find ip %s id %s error: %s\", ip, hostId, err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrGetPrivateKey.Error()))\n\t\treturn e.ErrGetPrivateKey\n\n\t}\n\tif resp.Status != setting.PMHostStatusNormal {\n\t\tlog.Errorf(\"host %s status %s, is not normal\", ip, resp.Status)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s status %s,is not normal\", ip, resp.Status))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.ScheduleWorkflow {\n\t\tlog.Errorf(\"host %s is not enable login\", ip)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"host %s is not enable ssh\", ip))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tif resp.Port == 0 {\n\t\tresp.Port = setting.PMHostDefaultPort\n\t}\n\n\tsDec, err := base64.StdEncoding.DecodeString(resp.PrivateKey)\n\tif err != nil {\n\t\tlog.Errorf(\"base64 decode failed ip:%s, error:%s\", ip, err)\n\t\te.ErrLoginPm.AddDesc(fmt.Sprintf(\"base64 decode failed ip:%s, error:%s\", ip, err))\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\n\tsshCli, err := toolssh.NewSshCli(sDec, resp.UserName, resp.IP, resp.Port)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshCli err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshCli.Close()\n\n\tsshConn, err := wsconn.NewSshConn(cols, rows, sshCli)\n\tif err != nil {\n\t\tlog.Errorf(\"NewSshConn err:%s\", err)\n\t\te.ErrLoginPm.AddErr(err)\n\t\tws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseInternalServerErr, e.ErrLoginPm.Error()))\n\t\treturn e.ErrLoginPm\n\t}\n\tdefer sshConn.Close()\n\n\tstopChan := make(chan bool, 3)\n\tgo sshConn.ReadWsMessage(ws, stopChan)\n\tgo sshConn.SendWsWriteMessage(ws, stopChan)\n\tgo sshConn.SessionWait(stopChan)\n\n\t<-stopChan\n\treturn nil\n}",
    "FSMID_for_test": 114,
    "Code_level": "Function-level"
}