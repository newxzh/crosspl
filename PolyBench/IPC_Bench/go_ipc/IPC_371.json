{
    "Task_id": 371,
    "Github_ID": "5567243",
    "Github_Project_Name": "gosnmp",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "net-based UDP Server with listenUDP in Go",
    "Instruction": "Task Description: Implement a UDP-based trap listener for SNMP (Simple Network Management Protocol) messages, capable of receiving and processing traps/informs, with support for SNMPv3 security features and proper resource cleanup.\n\nStruct Description: TrapListener is a struct that manages a UDP listener for SNMP traps, handling incoming messages, security validation, and response generation.\n\nFields:\n- done: chan bool - Channel to signal completion of listener shutdown\n- listening: chan bool - Channel to signal when listener is active\n- Mutex: sync.Mutex - Mutex for thread-safe operations\n- Params: *GoSNMP - Configuration parameters for SNMP handling\n- OnNewTrap: TrapHandlerFunc - Callback function for new trap processing\n- CloseTimeout: time.Duration - Timeout for graceful shutdown\n- conn: *net.UDPConn - UDP connection object\n- proto: string - Protocol type (typically \"udp\")\n- usmStatsUnknownEngineIDsCount: uint32 - Counter for unknown engine IDs (SNMPv3)\n- finish: int32 - Atomic flag for shutdown state\n\nMethods:\n- NewTrapListener() -> *TrapListener - Creates and initializes a new TrapListener instance\n- Close() - Gracefully shuts down the listener and cleans up resources\n- SendUDP(packet *SnmpPacket, addr *net.UDPAddr) -> error - Sends an SNMP packet via UDP\n- listenUDP(addr string) -> error - Main listening loop for incoming traps\n- reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) -> error - Handles SNMPv3 engine ID mismatch reporting",
    "Canonical_solution": "import (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype TrapListener struct {\n\tdone      chan bool\n\tlistening chan bool\n\tsync.Mutex\n\n\tParams *GoSNMP\n\n\tOnNewTrap TrapHandlerFunc\n\n\tCloseTimeout time.Duration\n\n\tconn  *net.UDPConn\n\tproto string\n\n\tusmStatsUnknownEngineIDsCount uint32\n\n\tfinish int32\n}\n\nfunc NewTrapListener() *TrapListener {\n\ttl := &TrapListener{\n\t\tfinish:       0,\n\t\tdone:         make(chan bool),\n\t\tlistening:    make(chan bool, 1),\n\t\tCloseTimeout: defaultCloseTimeout,\n\t}\n\n\treturn tl\n}\n\nfunc (t *TrapListener) Close() {\n\tif atomic.CompareAndSwapInt32(&t.finish, 0, 1) {\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\n\t\tif t.conn == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err := t.conn.Close(); err != nil {\n\t\t\tt.Params.Logger.Printf(\"failed to Close() the TrapListener socket: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-t.done:\n\t\tcase <-time.After(t.CloseTimeout):\n\t\t\tt.Params.Logger.Printf(\"timeout while awaiting done signal on TrapListener Close()\")\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) SendUDP(packet *SnmpPacket, addr *net.UDPAddr) error {\n\tob, err := packet.marshalMsg()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling SnmpPacket: %w\", err)\n\t}\n\n\tcount, err := t.conn.WriteTo(ob, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending SnmpPacket: %w\", err)\n\t}\n\n\tif count != len(ob) {\n\t\tt.Params.Logger.Printf(\"Failed to send all bytes of SnmpPacket!\\n\")\n\t}\n\treturn nil\n}\n\nfunc (t *TrapListener) listenUDP(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(t.proto, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.conn, err = net.ListenUDP(udp, udpAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer t.conn.Close()\n\n\tt.listening <- true\n\n\tfor {\n\t\tswitch {\n\t\tcase atomic.LoadInt32(&t.finish) == 1:\n\t\t\tt.done <- true\n\t\t\treturn nil\n\n\t\tdefault:\n\t\t\tvar buf [4096]byte\n\t\t\trlen, remote, err := t.conn.ReadFromUDP(buf[:])\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&t.finish) == 1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in read %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg := buf[:rlen]\n\t\t\ttrap, err := t.Params.UnmarshalTrap(msg, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Params.Logger.Printf(\"TrapListener: error in UnmarshalTrap %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif trap.Version == Version3 && trap.SecurityModel == UserSecurityModel && t.Params.SecurityModel == UserSecurityModel {\n\t\t\t\tsecurityParams, ok := t.Params.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tpacketSecurityParams, ok := trap.SecurityParameters.(*UsmSecurityParameters)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: Invalid SecurityParameters types\")\n\t\t\t\t}\n\t\t\t\tsnmpEngineID := securityParams.AuthoritativeEngineID\n\t\t\t\tmsgAuthoritativeEngineID := packetSecurityParams.AuthoritativeEngineID\n\t\t\t\tif msgAuthoritativeEngineID != snmpEngineID {\n\t\t\t\t\tif len(msgAuthoritativeEngineID) < 5 || len(msgAuthoritativeEngineID) > 32 {\n\t\t\t\t\t\tatomic.AddUint32(&t.usmStatsUnknownEngineIDsCount, 1)\n\t\t\t\t\t\terr := t.reportAuthoritativeEngineID(trap, snmpEngineID, remote)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.OnNewTrap(trap, remote)\n\n\t\t\tif trap.PDUType == InformRequest {\n\t\t\t\ttrap.PDUType = GetResponse\n\t\t\t\ttrap.Error = NoError\n\t\t\t\ttrap.ErrorIndex = 0\n\t\t\t\terr := t.SendUDP(trap, remote)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Params.Logger.Printf(\"TrapListener: %s\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *TrapListener) reportAuthoritativeEngineID(trap *SnmpPacket, snmpEngineID string, addr *net.UDPAddr) error {\n\tnewSecurityParams, ok := trap.SecurityParameters.Copy().(*UsmSecurityParameters)\n\tif !ok {\n\t\treturn errors.New(\"unable to cast SecurityParams to UsmSecurityParameters\")\n\t}\n\tnewSecurityParams.AuthoritativeEngineID = snmpEngineID\n\treportPacket := trap\n\treportPacket.PDUType = Report\n\treportPacket.MsgFlags &= AuthPriv\n\treportPacket.SecurityParameters = newSecurityParams\n\treportPacket.Variables = []SnmpPDU{\n\t\t{\n\t\t\tName:  usmStatsUnknownEngineIDs,\n\t\t\tValue: int(atomic.LoadUint32(&t.usmStatsUnknownEngineIDsCount)),\n\t\t\tType:  Integer,\n\t\t},\n\t}\n\treturn t.SendUDP(reportPacket, addr)\n}",
    "FSMID_for_test": 112,
    "Code_level": "Class-level"
}