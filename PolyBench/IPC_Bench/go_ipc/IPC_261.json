{
    "Task_id": 261,
    "Github_ID": "143965255",
    "Github_Project_Name": "dubbo-go",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Official-based gRPC server in Go",
    "Instruction": "Task Description: Implement a gRPC server in Go that can handle incoming requests with configurable message size limits, TLS support, and OpenTracing integration.\n\nStruct Description: The Server struct represents a gRPC server instance with configurable settings for buffer size and server options.\n\nFields:\ngrpcServer: *grpc.Server - The underlying gRPC server instance\nbufferSize: int - The buffer size for server operations (currently unused in reference code)\n\nMethods:\nNewServer: () -> *Server - Creates and returns a new Server instance with default values\n\nStart: (url *common.URL) -> () - Starts the gRPC server with the specified URL configuration. Handles:\n  - Network listener setup\n  - Message size configuration\n  - TLS setup if configured\n  - OpenTracing integration\n  - Service registration\n  - Server reflection\n\nStop: () -> () - Immediately stops the gRPC server\n\nGracefulStop: () -> () - Gracefully stops the gRPC server, allowing existing RPCs to complete",
    "Canonical_solution": "import (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nimport (\n\t\"github.com/dubbogo/gost/log/logger\"\n\t\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\t\"google.golang.org/grpc/reflection\"\n)\n\nimport (\n\t\"dubbo.apache.org/dubbo-go/v3/common\"\n\t\"dubbo.apache.org/dubbo-go/v3/common/constant\"\n\t\"dubbo.apache.org/dubbo-go/v3/config\"\n\t\"dubbo.apache.org/dubbo-go/v3/protocol\"\n)\n\ntype Server struct {\n\tgrpcServer *grpc.Server\n\tbufferSize int\n}\n\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\nfunc (s *Server) Start(url *common.URL) {\n\tvar (\n\t\taddr string\n\t\terr  error\n\t)\n\taddr = url.Location\n\tlis, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmaxServerRecvMsgSize := constant.DefaultMaxServerRecvMsgSize\n\tif recvMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerRecvMsgSize, \"\")); convertErr == nil && recvMsgSize != 0 {\n\t\tmaxServerRecvMsgSize = int(recvMsgSize)\n\t}\n\tmaxServerSendMsgSize := constant.DefaultMaxServerSendMsgSize\n\tif sendMsgSize, convertErr := humanize.ParseBytes(url.GetParam(constant.MaxServerSendMsgSize, \"\")); err == convertErr && sendMsgSize != 0 {\n\t\tmaxServerSendMsgSize = int(sendMsgSize)\n\t}\n\n\ttracer := opentracing.GlobalTracer()\n\tvar serverOpts []grpc.ServerOption\n\tserverOpts = append(serverOpts,\n\t\tgrpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer)),\n\t\tgrpc.StreamInterceptor(otgrpc.OpenTracingStreamServerInterceptor(tracer)),\n\t\tgrpc.MaxRecvMsgSize(maxServerRecvMsgSize),\n\t\tgrpc.MaxSendMsgSize(maxServerSendMsgSize),\n\t)\n\n\ttlsConfig := config.GetRootConfig().TLSConfig\n\tif tlsConfig != nil {\n\t\tvar cfg *tls.Config\n\t\tcfg, err = config.GetServerTlsConfig(&config.TLSConfig{\n\t\t\tCACertFile:    tlsConfig.CACertFile,\n\t\t\tTLSCertFile:   tlsConfig.TLSCertFile,\n\t\t\tTLSKeyFile:    tlsConfig.TLSKeyFile,\n\t\t\tTLSServerName: tlsConfig.TLSServerName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"Grpc Server initialized the TLSConfig configuration\")\n\t\tserverOpts = append(serverOpts, grpc.Creds(credentials.NewTLS(cfg)))\n\t} else {\n\t\tserverOpts = append(serverOpts, grpc.Creds(insecure.NewCredentials()))\n\t}\n\tserver := grpc.NewServer(serverOpts...)\n\ts.grpcServer = server\n\n\tgo func() {\n\t\tproviderServices := config.GetProviderConfig().Services\n\n\t\tif len(providerServices) == 0 {\n\t\t\tpanic(\"provider service map is null\")\n\t\t}\n\t\twaitGrpcExporter(providerServices)\n\t\tregisterService(providerServices, server)\n\t\treflection.Register(server)\n\n\t\tif err = server.Serve(lis); err != nil {\n\t\t\tlogger.Errorf(\"server serve failed with err: %v\", err)\n\t\t}\n\t}()\n}\n\nfunc (s *Server) Stop() {\n\ts.grpcServer.Stop()\n}\n\nfunc (s *Server) GracefulStop() {\n\ts.grpcServer.GracefulStop()\n}",
    "FSMID_for_test": 119,
    "Code_level": "Class-level"
}