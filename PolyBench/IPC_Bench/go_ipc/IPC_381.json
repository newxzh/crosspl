{
    "Task_id": 381,
    "Github_ID": "80172100",
    "Github_Project_Name": "cri-tools",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "nhooyr.io-based websocket client in Go",
    "Instruction": "Task Description: The task involves creating a WebSocket client in Go that can establish secure connections, handle protocol negotiation, and manage message transmission between client and server. The solution should support TLS configuration, proxy settings, and proper connection cleanup.\n\nStruct Description: The RoundTripper struct implements http.RoundTripper interface to handle WebSocket connections with additional capabilities for Kubernetes API server communication. It manages WebSocket connections with TLS support and proxy configuration.\n\nFields:\n- TLSConfig: *tls.Config - Configuration for TLS/SSL connections\n- Proxier: func(req *http.Request) (*url.URL, error) - Function to determine proxy for requests\n- Conn: *gwebsocket.Conn - Active WebSocket connection\n\nMethods:\n- Connection: () -> *gwebsocket.Conn - Returns the active WebSocket connection\n- DataBufferSize: () -> int - Returns the buffer size for data transmission (32KB by default)\n- TLSClientConfig: () -> *tls.Config - Returns the TLS configuration\n- RoundTrip: (*http.Request) -> (*http.Response, error) - Main method that establishes WebSocket connection, handles protocol negotiation, and returns the HTTP response\n\nAdditional Function:\n- RoundTripperFor: (*restclient.Config) -> (http.RoundTripper, ConnectionHolder, error) - Factory function that creates a configured RoundTripper instance with proper TLS and proxy settings from Kubernetes client configuration",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tgwebsocket \"github.com/gorilla/websocket\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream\"\n\t\"k8s.io/apimachinery/pkg/util/httpstream/wsstream\"\n\tutilnet \"k8s.io/apimachinery/pkg/util/net\"\n\trestclient \"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/transport\"\n)\n\ntype RoundTripper struct {\n\tTLSConfig *tls.Config\n\tProxier   func(req *http.Request) (*url.URL, error)\n\tConn      *gwebsocket.Conn\n}\n\nfunc (rt *RoundTripper) Connection() *gwebsocket.Conn {\n\treturn rt.Conn\n}\n\nfunc (rt *RoundTripper) DataBufferSize() int {\n\treturn 32 * 1024\n}\n\nfunc (rt *RoundTripper) TLSClientConfig() *tls.Config {\n\treturn rt.TLSConfig\n}\n\nfunc (rt *RoundTripper) RoundTrip(request *http.Request) (retResp *http.Response, retErr error) {\n\tdefer func() {\n\t\tif request.Body != nil {\n\t\t\terr := request.Body.Close()\n\t\t\tif retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}\n\t}()\n\n\tprotocolVersions := request.Header[wsstream.WebSocketProtocolHeader]\n\tdelete(request.Header, wsstream.WebSocketProtocolHeader)\n\n\tdialer := gwebsocket.Dialer{\n\t\tProxy:           rt.Proxier,\n\t\tTLSClientConfig: rt.TLSConfig,\n\t\tSubprotocols:    protocolVersions,\n\t\tReadBufferSize:  rt.DataBufferSize() + 1024,\n\t\tWriteBufferSize: rt.DataBufferSize() + 1024,\n\t}\n\tswitch request.URL.Scheme {\n\tcase \"https\":\n\t\trequest.URL.Scheme = \"wss\"\n\tcase \"http\":\n\t\trequest.URL.Scheme = \"ws\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown url scheme: %s\", request.URL.Scheme)\n\t}\n\twsConn, resp, err := dialer.DialContext(request.Context(), request.URL.String(), request.Header)\n\tif err != nil {\n\t\tif errors.Is(err, gwebsocket.ErrBadHandshake) {\n\t\t\tcause := err\n\t\t\tif resp != nil && len(resp.Status) > 0 {\n\t\t\t\tdefer resp.Body.Close()\n\t\t\t\tcause = fmt.Errorf(\"%w (%s)\", err, resp.Status)\n\t\t\t\tresponseErrorBytes, readErr := io.ReadAll(io.LimitReader(resp.Body, 64*1024))\n\t\t\t\tif readErr != nil {\n\t\t\t\t\tcause = fmt.Errorf(\"%w: unable to read error from server response\", cause)\n\t\t\t\t} else {\n\t\t\t\t\tresponseError := strings.TrimSpace(string(responseErrorBytes))\n\t\t\t\t\tif len(responseError) > 0 {\n\t\t\t\t\t\tif obj, _, decodeErr := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); decodeErr == nil {\n\t\t\t\t\t\t\tif status, ok := obj.(*metav1.Status); ok {\n\t\t\t\t\t\t\t\tcause = &apierrors.StatusError{ErrStatus: *status}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcause = fmt.Errorf(\"%w: %s\", cause, responseError)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, &httpstream.UpgradeFailureError{Cause: cause}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tfoundProtocol := false\n\tfor _, protocolVersion := range protocolVersions {\n\t\tif protocolVersion == wsConn.Subprotocol() {\n\t\t\tfoundProtocol = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !foundProtocol {\n\t\twsConn.Close()\n\t\treturn nil, &httpstream.UpgradeFailureError{Cause: fmt.Errorf(\"invalid protocol, expected one of %q, got %q\", protocolVersions, wsConn.Subprotocol())}\n\t}\n\n\trt.Conn = wsConn\n\n\treturn resp, nil\n}\n\nfunc RoundTripperFor(config *restclient.Config) (http.RoundTripper, ConnectionHolder, error) {\n\ttransportCfg, err := config.TransportConfig()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttlsConfig, err := transport.TLSConfigFor(transportCfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproxy := config.Proxy\n\tif proxy == nil {\n\t\tproxy = utilnet.NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)\n\t}\n\n\tupgradeRoundTripper := &RoundTripper{\n\t\tTLSConfig: tlsConfig,\n\t\tProxier:   proxy,\n\t}\n\twrapper, err := transport.HTTPWrappersForConfig(transportCfg, upgradeRoundTripper)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn wrapper, upgradeRoundTripper, nil\n}",
    "FSMID_for_test": 117,
    "Code_level": "Class-level"
}