{
    "Task_id": 2,
    "Github_ID": "56550961",
    "Github_Project_Name": "jaeger-client-go",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Advanced HTTP client with custom http.Client and request headers",
    "Instruction": "Task Description: Implement an HTTP transport struct for sending tracing spans to a collector using Thrift serialization and HTTP protocol.\n\nStruct Description: HTTPTransport is a struct that handles batching and sending tracing spans to a remote collector via HTTP. It supports basic authentication and custom HTTP client configuration.\n\nFields:\n- logger: jaeger.Logger - Logger for reporting errors and debug information\n- url: string - The collector endpoint URL\n- client: *http.Client - Custom HTTP client for making requests\n- batchSize: int - Maximum number of spans to batch before flushing\n- batch: []*zipkincore.Span - Current batch of spans waiting to be sent\n- httpCredentials: *HTTPBasicAuthCredentials - Optional basic auth credentials\n\nMethods:\n- NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) - Constructor that creates a new HTTPTransport with default values and applies options\n- Append(span *jaeger.Span) (int, error) - Adds a span to the current batch, flushes if batch size is reached\n- Flush() (int, error) - Sends all batched spans to the collector and resets the batch\n- Close() error - Cleanup method (currently no-op)\n- send(spans []*zipkincore.Span) error - Internal method that serializes and sends spans via HTTP POST\n- httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) - Helper method that serializes spans using Thrift protocol\n\nAdditional Struct:\n- HTTPBasicAuthCredentials: struct - Holds basic authentication credentials\n  Fields:\n  - username: string - Basic auth username\n  - password: string - Basic auth password",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/log\"\n\t\"github.com/uber/jaeger-client-go/thrift\"\n\t\"github.com/uber/jaeger-client-go/thrift-gen/zipkincore\"\n)\n\ntype HTTPTransport struct {\n\tlogger          jaeger.Logger\n\turl             string\n\tclient          *http.Client\n\tbatchSize       int\n\tbatch           []*zipkincore.Span\n\thttpCredentials *HTTPBasicAuthCredentials\n}\n\ntype HTTPBasicAuthCredentials struct {\n\tusername string\n\tpassword string\n}\n\nfunc NewHTTPTransport(url string, options ...HTTPOption) (*HTTPTransport, error) {\n\tc := &HTTPTransport{\n\t\tlogger:    log.NullLogger,\n\t\turl:       url,\n\t\tclient:    &http.Client{Timeout: defaultHTTPTimeout},\n\t\tbatchSize: 100,\n\t\tbatch:     []*zipkincore.Span{},\n\t}\n\n\tfor _, option := range options {\n\t\toption(c)\n\t}\n\treturn c, nil\n}\n\nfunc (c *HTTPTransport) Append(span *jaeger.Span) (int, error) {\n\tzSpan := jaeger.BuildZipkinThrift(span)\n\tc.batch = append(c.batch, zSpan)\n\tif len(c.batch) >= c.batchSize {\n\t\treturn c.Flush()\n\t}\n\treturn 0, nil\n}\n\nfunc (c *HTTPTransport) Flush() (int, error) {\n\tcount := len(c.batch)\n\tif count == 0 {\n\t\treturn 0, nil\n\t}\n\terr := c.send(c.batch)\n\tc.batch = c.batch[:0]\n\treturn count, err\n}\n\nfunc (c *HTTPTransport) Close() error {\n\treturn nil\n}\n\nfunc (c *HTTPTransport) send(spans []*zipkincore.Span) error {\n\tbody, err := httpSerialize(spans)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", c.url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-thrift\")\n\n\tif c.httpCredentials != nil {\n\t\treq.SetBasicAuth(c.httpCredentials.username, c.httpCredentials.password)\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read response from collector: %s\", err)\n\t}\n\n\tif resp.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"error from collector: code=%d body=%q\", resp.StatusCode, string(respBytes))\n\t}\n\n\treturn nil\n}\n\nfunc httpSerialize(spans []*zipkincore.Span) (*bytes.Buffer, error) {\n\tt := thrift.NewTMemoryBuffer()\n\tp := thrift.NewTBinaryProtocolTransport(t)\n\tctx := context.Background()\n\tif err := p.WriteListBegin(ctx, thrift.STRUCT, len(spans)); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range spans {\n\t\tif err := s.Write(ctx, p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif err := p.WriteListEnd(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn t.Buffer, nil\n}",
    "FSMID_for_test": 102,
    "Code_level": "Class-level"
}