{
    "Task_id": 185,
    "Github_ID": "179326472",
    "Github_Project_Name": "ignite",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Net-based TCP Client in Go",
    "Instruction": "Task Description: Implement a TCP client in Go that can establish connections to servers, handle TLS if required, and manage timeouts for network operations.\n\nStruct Description: The Client struct represents a configurable TCP client capable of handling both plain TCP and TLS connections, with various timeout controls and DNS message exchange functionality.\n\nFields:\n\nNet: string - Network type (e.g., \"tcp\", \"tcp-tls\", \"udp\")\nUDPSize: uint16 - UDP buffer size for DNS messages\nTLSConfig: *tls.Config - TLS configuration for secure connections\nDialer: *net.Dialer - Custom dialer for connection establishment\nTimeout: time.Duration - Overall operation timeout\nDialTimeout: time.Duration - Timeout specifically for connection establishment\nReadTimeout: time.Duration - Timeout for read operations\nWriteTimeout: time.Duration - Timeout for write operations\nTsigSecret: map[string]string - TSIG authentication secrets\nSingleInflight: bool - Whether to use singleflight for duplicate request suppression\ngroup: singleflight - Internal singleflight group for request deduplication\n\nMethods:\n\nDial: (address string) -> (*Conn, error) - Establishes a connection to the specified address, handling TLS if configured\nExchange: (m *Msg, address string) -> (*Msg, time.Duration, error) - Performs a complete DNS message exchange with timeout handling\nexchange: (m *Msg, a string) -> (*Msg, time.Duration, error) - Internal method for performing the actual message exchange\ngetTimeoutForRequest: (timeout time.Duration) -> time.Duration - Calculates the appropriate timeout for a request considering various configuration options",
    "Canonical_solution": "import (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\ntype Client struct {\n\tNet       string\n\tUDPSize   uint16\n\tTLSConfig *tls.Config\n\tDialer    *net.Dialer\n\tTimeout   time.Duration\n\tDialTimeout    time.Duration\n\tReadTimeout    time.Duration\n\tWriteTimeout   time.Duration\n\tTsigSecret     map[string]string\n\tSingleInflight bool\n\tgroup          singleflight\n}\n\nfunc (c *Client) Dial(address string) (conn *Conn, err error) {\n\tvar d net.Dialer\n\tif c.Dialer == nil {\n\t\td = net.Dialer{Timeout: c.getTimeoutForRequest(c.dialTimeout())}\n\t} else {\n\t\td = *c.Dialer\n\t}\n\n\tnetwork := c.Net\n\tif network == \"\" {\n\t\tnetwork = \"udp\"\n\t}\n\n\tuseTLS := strings.HasPrefix(network, \"tcp\") && strings.HasSuffix(network, \"-tls\")\n\n\tconn = new(Conn)\n\tif useTLS {\n\t\tnetwork = strings.TrimSuffix(network, \"-tls\")\n\t\tconn.Conn, err = tls.DialWithDialer(&d, network, address, c.TLSConfig)\n\t} else {\n\t\tconn.Conn, err = d.Dial(network, address)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc (c *Client) Exchange(m *Msg, address string) (r *Msg, rtt time.Duration, err error) {\n\tif !c.SingleInflight {\n\t\treturn c.exchange(m, address)\n\t}\n\n\tq := m.Question[0]\n\tkey := fmt.Sprintf(\"%s:%d:%d\", q.Name, q.Qtype, q.Qclass)\n\tr, rtt, err, shared := c.group.Do(key, func() (*Msg, time.Duration, error) {\n\t\treturn c.exchange(m, address)\n\t})\n\tif r != nil && shared {\n\t\tr = r.Copy()\n\t}\n\n\treturn r, rtt, err\n}\n\nfunc (c *Client) exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {\n\tvar co *Conn\n\n\tco, err = c.Dial(a)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer co.Close()\n\n\topt := m.IsEdns0()\n\tif opt != nil && opt.UDPSize() >= MinMsgSize {\n\t\tco.UDPSize = opt.UDPSize()\n\t}\n\tif opt == nil && c.UDPSize >= MinMsgSize {\n\t\tco.UDPSize = c.UDPSize\n\t}\n\n\tco.TsigSecret = c.TsigSecret\n\tt := time.Now()\n\tco.SetWriteDeadline(t.Add(c.getTimeoutForRequest(c.writeTimeout())))\n\tif err = co.WriteMsg(m); err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tco.SetReadDeadline(time.Now().Add(c.getTimeoutForRequest(c.readTimeout())))\n\tr, err = co.ReadMsg()\n\tif err == nil && r.Id != m.Id {\n\t\terr = ErrId\n\t}\n\trtt = time.Since(t)\n\treturn r, rtt, err\n}\n\nfunc (c *Client) getTimeoutForRequest(timeout time.Duration) time.Duration {\n\tvar requestTimeout time.Duration\n\tif c.Timeout != 0 {\n\t\trequestTimeout = c.Timeout\n\t} else {\n\t\trequestTimeout = timeout\n\t}\n\tif c.Dialer != nil && c.Dialer.Timeout != 0 {\n\t\tif c.Dialer.Timeout < requestTimeout {\n\t\t\trequestTimeout = c.Dialer.Timeout\n\t\t}\n\t}\n\treturn requestTimeout\n}",
    "FSMID_for_test": 110,
    "Code_level": "Class-level"
}