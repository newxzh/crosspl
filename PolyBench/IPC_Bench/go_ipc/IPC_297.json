{
    "Task_id": 297,
    "Github_ID": "25102239",
    "Github_Project_Name": "seagull",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Redis in Go",
    "Instruction": "Task Description: Implement a Redis-based session management system in Go that allows storing, retrieving, and managing HTTP session data using Redis as the backend storage.\n\nStruct Description: The implementation consists of two main structs - `SessionStore` for handling individual session operations and `Provider` for managing the Redis connection pool and session lifecycle.\n\nFields:\n\nSessionStore:\n- p: *redis.Pool - Redis connection pool\n- sid: string - Session ID\n- lock: sync.RWMutex - Read-write lock for thread safety\n- values: map[interface{}]interface{} - Key-value pairs storing session data\n- maxlifetime: int64 - Session expiration time in seconds\n\nProvider:\n- maxlifetime: int64 - Default session expiration time\n- savePath: string - Redis server address\n- poolsize: int - Connection pool size\n- password: string - Redis authentication password\n- dbNum: int - Redis database number\n- poollist: *redis.Pool - Redis connection pool instance\n\nMethods:\n\nSessionStore:\n- Set(key, value interface{}) error - Stores a key-value pair in the session\n- Get(key interface{}) interface{} - Retrieves a value by key from the session\n- Delete(key interface{}) error - Removes a key-value pair from the session\n- Flush() error - Clears all session data\n- SessionID() string - Returns the session ID\n- SessionRelease(w http.ResponseWriter) - Persists session data to Redis before closing\n\nProvider:\n- SessionInit(maxlifetime int64, savePath string) error - Initializes the Redis connection pool with configuration\n- SessionRead(sid string) (session.Store, error) - Retrieves session data from Redis\n- SessionExist(sid string) bool - Checks if a session exists in Redis\n- SessionRegenerate(oldsid, sid string) (session.Store, error) - Creates a new session ID while preserving data\n- SessionDestroy(sid string) error - Removes session data from Redis",
    "Canonical_solution": "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/astaxie/beego/session\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar redispder = &Provider{}\nvar MaxPoolSize = 100\n\ntype SessionStore struct {\n\tp           *redis.Pool\n\tsid         string\n\tlock        sync.RWMutex\n\tvalues      map[interface{}]interface{}\n\tmaxlifetime int64\n}\n\nfunc (rs *SessionStore) Set(key, value interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values[key] = value\n\treturn nil\n}\n\nfunc (rs *SessionStore) Get(key interface{}) interface{} {\n\trs.lock.RLock()\n\tdefer rs.lock.RUnlock()\n\tif v, ok := rs.values[key]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (rs *SessionStore) Delete(key interface{}) error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\tdelete(rs.values, key)\n\treturn nil\n}\n\nfunc (rs *SessionStore) Flush() error {\n\trs.lock.Lock()\n\tdefer rs.lock.Unlock()\n\trs.values = make(map[interface{}]interface{})\n\treturn nil\n}\n\nfunc (rs *SessionStore) SessionID() string {\n\treturn rs.sid\n}\n\nfunc (rs *SessionStore) SessionRelease(w http.ResponseWriter) {\n\tb, err := session.EncodeGob(rs.values)\n\tif err != nil {\n\t\treturn\n\t}\n\tc := rs.p.Get()\n\tdefer c.Close()\n\tc.Do(\"SETEX\", rs.sid, rs.maxlifetime, string(b))\n}\n\ntype Provider struct {\n\tmaxlifetime int64\n\tsavePath    string\n\tpoolsize    int\n\tpassword    string\n\tdbNum       int\n\tpoollist    *redis.Pool\n}\n\nfunc (rp *Provider) SessionInit(maxlifetime int64, savePath string) error {\n\trp.maxlifetime = maxlifetime\n\tconfigs := strings.Split(savePath, \",\")\n\tif len(configs) > 0 {\n\t\trp.savePath = configs[0]\n\t}\n\tif len(configs) > 1 {\n\t\tpoolsize, err := strconv.Atoi(configs[1])\n\t\tif err != nil || poolsize <= 0 {\n\t\t\trp.poolsize = MaxPoolSize\n\t\t} else {\n\t\t\trp.poolsize = poolsize\n\t\t}\n\t} else {\n\t\trp.poolsize = MaxPoolSize\n\t}\n\tif len(configs) > 2 {\n\t\trp.password = configs[2]\n\t}\n\tif len(configs) > 3 {\n\t\tdbnum, err := strconv.Atoi(configs[3])\n\t\tif err != nil || dbnum < 0 {\n\t\t\trp.dbNum = 0\n\t\t} else {\n\t\t\trp.dbNum = dbnum\n\t\t}\n\t} else {\n\t\trp.dbNum = 0\n\t}\n\trp.poollist = redis.NewPool(func() (redis.Conn, error) {\n\t\tc, err := redis.Dial(\"tcp\", rp.savePath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.password != \"\" {\n\t\t\tif _, err := c.Do(\"AUTH\", rp.password); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t_, err = c.Do(\"SELECT\", rp.dbNum)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t}, rp.poolsize)\n\n\treturn rp.poollist.Get().Err()\n}\n\nfunc (rp *Provider) SessionRead(sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionExist(sid string) bool {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, err := redis.Int(c.Do(\"EXISTS\", sid)); err != nil || existed == 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (rp *Provider) SessionRegenerate(oldsid, sid string) (session.Store, error) {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tif existed, _ := redis.Int(c.Do(\"EXISTS\", oldsid)); existed == 0 {\n\t\tc.Do(\"SET\", sid, \"\", \"EX\", rp.maxlifetime)\n\t} else {\n\t\tc.Do(\"RENAME\", oldsid, sid)\n\t\tc.Do(\"EXPIRE\", sid, rp.maxlifetime)\n\t}\n\n\tkvs, err := redis.String(c.Do(\"GET\", sid))\n\tvar kv map[interface{}]interface{}\n\tif len(kvs) == 0 {\n\t\tkv = make(map[interface{}]interface{})\n\t} else {\n\t\tkv, err = session.DecodeGob([]byte(kvs))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trs := &SessionStore{p: rp.poollist, sid: sid, values: kv, maxlifetime: rp.maxlifetime}\n\treturn rs, nil\n}\n\nfunc (rp *Provider) SessionDestroy(sid string) error {\n\tc := rp.poollist.Get()\n\tdefer c.Close()\n\n\tc.Do(\"DEL\", sid)\n\treturn nil\n}",
    "FSMID_for_test": 126,
    "Code_level": "Class-level"
}