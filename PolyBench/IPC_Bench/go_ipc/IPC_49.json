{
    "Task_id": 49,
    "Github_ID": "302670797",
    "Github_Project_Name": "scorecard",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Basic HTTP server using net/http with HandleFunc and ListenAndServe",
    "Instruction": "Task Description: Create a Go HTTP server that serves as an interface for running and displaying scorecard results for GitHub repositories. The server should handle requests, process repository information, execute scorecard checks, and return results in either JSON or HTML format based on the request's content type.\n\nFunction Description: The `serveCmd` function creates and configures a Cobra command that starts an HTTP server. The server listens for requests, processes GitHub repository URLs, runs scorecard checks on those repositories, and returns the results. The function handles template parsing, route registration, and server startup.\n\nInput: \n- `o *options.Options`: A pointer to an options struct containing configuration settings like log level and commit depth\n\nOutput: \n- `*cobra.Command`: Returns a configured Cobra command that can be executed to start the HTTP server\n\nThe function does not explicitly return any values from its Run method, but it does:\n1. Write HTTP responses to the client (through http.ResponseWriter)\n2. Output logs through the logger\n3. May panic in case of critical errors during template parsing or server startup",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/ossf/scorecard/v5/clients/githubrepo\"\n\t\"github.com/ossf/scorecard/v5/clients/ossfuzz\"\n\t\"github.com/ossf/scorecard/v5/log\"\n\t\"github.com/ossf/scorecard/v5/options\"\n\t\"github.com/ossf/scorecard/v5/pkg/scorecard\"\n)\nfunc serveCmd(o *options.Options) *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:   \"serve\",\n\t\tShort: \"Serve the scorecard program over http\",\n\t\tLong:  ``,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tlogger := log.NewLogger(log.ParseLevel(o.LogLevel))\n\n\t\t\tt, err := template.New(\"webpage\").Parse(tpl)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"parsing webpage template\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\thttp.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\trepoParam := r.URL.Query().Get(\"repo\")\n\t\t\t\tconst length = 3\n\t\t\t\ts := strings.SplitN(repoParam, \"/\", length)\n\t\t\t\tif len(s) != length {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\trepo, err := githubrepo.MakeGithubRepo(repoParam)\n\t\t\t\tif err != nil {\n\t\t\t\t\trw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t}\n\t\t\t\tctx := r.Context()\n\t\t\t\trepoClient := githubrepo.CreateGithubRepoClient(ctx, logger)\n\t\t\t\tossFuzzRepoClient, err := ossfuzz.CreateOSSFuzzClientEager(ossfuzz.StatusURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"initializing clients\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t\tdefer ossFuzzRepoClient.Close()\n\t\t\t\trepoResult, err := scorecard.Run(ctx, repo,\n\t\t\t\t\tscorecard.WithCommitDepth(o.CommitDepth),\n\t\t\t\t\tscorecard.WithRepoClient(repoClient),\n\t\t\t\t\tscorecard.WithOSSFuzzClient(ossFuzzRepoClient),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(err, \"running enabled scorecard checks on repo\")\n\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t}\n\n\t\t\t\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\t\t\t\tif err := repoResult.AsJSON(o.ShowDetails, log.ParseLevel(o.LogLevel), rw); err != nil {\n\t\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := t.Execute(rw, repoResult); err != nil {\n\t\t\t\t\tlogger.Error(err, \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tport := os.Getenv(\"PORT\")\n\t\t\tif port == \"\" {\n\t\t\t\tport = \"8080\"\n\t\t\t}\n\t\t\tlogger.Info(\"Listening on localhost:\" + port + \"\\n\")\n\t\t\terr = http.ListenAndServe(fmt.Sprintf(\"0.0.0.0:%s\", port), nil)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err, \"listening and serving\")\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t},\n\t}\n}",
    "FSMID_for_test": 103,
    "Code_level": "Function-level"
}