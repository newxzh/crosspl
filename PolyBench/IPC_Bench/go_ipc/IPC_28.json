{
    "Task_id": 28,
    "Github_ID": "355946670",
    "Github_Project_Name": "vcluster",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Advanced HTTP client with custom http.Client and request headers",
    "Instruction": "Task Description: Create a comprehensive HTTP client in Go that can handle various API requests with custom configurations, including base URLs, request headers, and rate limiting. The client should support multiple API services and provide methods for creating and executing HTTP requests.\n\nStruct Description: The Client struct represents an HTTP client with configuration for making API requests. It includes base URLs, user agent, rate limiting capabilities, and various service clients for different API endpoints.\n\nFields:\n\nclientMu: sync.Mutex - Mutex for thread-safe access to the HTTP client\nclient: *http.Client - The underlying HTTP client used for requests\nBaseURL: *url.URL - Base URL for API requests\nUploadURL: *url.URL - Base URL for upload requests\nUserAgent: string - User agent string for requests\nrateMu: sync.Mutex - Mutex for thread-safe rate limiting\nrateLimits: [categories]Rate - Rate limit tracking for different categories\ncommon: service - Shared service implementation\n\nMethods:\n\nNewClient: (*http.Client) -> *Client - Creates a new Client instance with optional custom HTTP client\nNewRequest: (method string, urlStr string, body interface{}) -> (*http.Request, error) - Creates a new HTTP request with proper headers and body encoding\nDo: (ctx context.Context, req *http.Request, v interface{}) -> (*Response, error) - Executes an HTTP request with context support and handles response decoding",
    "Canonical_solution": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Client struct {\n\tclientMu sync.Mutex\n\tclient   *http.Client\n\n\tBaseURL   *url.URL\n\tUploadURL *url.URL\n\tUserAgent string\n\n\trateMu     sync.Mutex\n\trateLimits [categories]Rate\n\n\tcommon service\n\n\tActions        *ActionsService\n\tActivity       *ActivityService\n\tAdmin          *AdminService\n\tApps           *AppsService\n\tAuthorizations *AuthorizationsService\n\tChecks         *ChecksService\n\tGists          *GistsService\n\tGit            *GitService\n\tGitignores     *GitignoresService\n\tInteractions   *InteractionsService\n\tIssues         *IssuesService\n\tLicenses       *LicensesService\n\tMarketplace    *MarketplaceService\n\tMigrations     *MigrationService\n\tOrganizations  *OrganizationsService\n\tProjects       *ProjectsService\n\tPullRequests   *PullRequestsService\n\tReactions      *ReactionsService\n\tRepositories   *RepositoriesService\n\tSearch         *SearchService\n\tTeams          *TeamsService\n\tUsers          *UsersService\n}\n\nfunc NewClient(httpClient *http.Client) *Client {\n\tif httpClient == nil {\n\t\thttpClient = &http.Client{}\n\t}\n\tbaseURL, _ := url.Parse(defaultBaseURL)\n\tuploadURL, _ := url.Parse(uploadBaseURL)\n\n\tc := &Client{client: httpClient, BaseURL: baseURL, UserAgent: userAgent, UploadURL: uploadURL}\n\tc.common.client = c\n\tc.Actions = (*ActionsService)(&c.common)\n\tc.Activity = (*ActivityService)(&c.common)\n\tc.Admin = (*AdminService)(&c.common)\n\tc.Apps = (*AppsService)(&c.common)\n\tc.Authorizations = (*AuthorizationsService)(&c.common)\n\tc.Checks = (*ChecksService)(&c.common)\n\tc.Gists = (*GistsService)(&c.common)\n\tc.Git = (*GitService)(&c.common)\n\tc.Gitignores = (*GitignoresService)(&c.common)\n\tc.Interactions = (*InteractionsService)(&c.common)\n\tc.Issues = (*IssuesService)(&c.common)\n\tc.Licenses = (*LicensesService)(&c.common)\n\tc.Marketplace = &MarketplaceService{client: c}\n\tc.Migrations = (*MigrationService)(&c.common)\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Projects = (*ProjectsService)(&c.common)\n\tc.PullRequests = (*PullRequestsService)(&c.common)\n\tc.Reactions = (*ReactionsService)(&c.common)\n\tc.Repositories = (*RepositoriesService)(&c.common)\n\tc.Search = (*SearchService)(&c.common)\n\tc.Teams = (*TeamsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\treturn c\n}\n\nfunc (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) {\n\tif !strings.HasSuffix(c.BaseURL.Path, \"/\") {\n\t\treturn nil, fmt.Errorf(\"BaseURL must have a trailing slash, but %q does not\", c.BaseURL)\n\t}\n\tu, err := c.BaseURL.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar buf io.ReadWriter\n\tif body != nil {\n\t\tbuf = &bytes.Buffer{}\n\t\tenc := json.NewEncoder(buf)\n\t\tenc.SetEscapeHTML(false)\n\t\terr := enc.Encode(body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", mediaTypeV3)\n\tif c.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n\t}\n\treturn req, nil\n}\n\nfunc (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*Response, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"context must be non-nil\")\n\t}\n\treq = withContext(ctx, req)\n\n\trateLimitCategory := category(req.URL.Path)\n\n\tif err := c.checkRateLimitBeforeDo(req, rateLimitCategory); err != nil {\n\t\treturn &Response{\n\t\t\tResponse: err.Response,\n\t\t\tRate:     err.Rate,\n\t\t}, err\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif e, ok := err.(*url.Error); ok {\n\t\t\tif url, err := url.Parse(e.URL); err == nil {\n\t\t\t\te.URL = sanitizeURL(url).String()\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t}\n\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tresponse := newResponse(resp)\n\n\tc.rateMu.Lock()\n\tc.rateLimits[rateLimitCategory] = response.Rate\n\tc.rateMu.Unlock()\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\taerr, ok := err.(*AcceptedError)\n\t\tif ok {\n\t\t\tb, readErr := ioutil.ReadAll(resp.Body)\n\t\t\tif readErr != nil {\n\t\t\t\treturn response, readErr\n\t\t\t}\n\n\t\t\taerr.Raw = b\n\t\t\treturn response, aerr\n\t\t}\n\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\tio.Copy(w, resp.Body)\n\t\t} else {\n\t\t\tdecErr := json.NewDecoder(resp.Body).Decode(v)\n\t\t\tif decErr == io.EOF {\n\t\t\t\tdecErr = nil\n\t\t\t}\n\t\t\tif decErr != nil {\n\t\t\t\terr = decErr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn response, err\n}",
    "FSMID_for_test": 102,
    "Code_level": "Class-level"
}