{
    "Task_id": 86,
    "Github_ID": "51149151",
    "Github_Project_Name": "doorman",
    "Programming_Language": "Go",
    "suffix": ".go",
    "Interface_class": "IPC",
    "Interface_name": "Basic HTTP server using net/http with HandleFunc and ListenAndServe",
    "Instruction": "Task Description: Create a Go HTTP server that handles WebDAV requests with custom logging and special handling for certain Litmus test cases.\n\nFunction Description: The main function sets up a WebDAV server with in-memory storage (MemFS) and in-memory locking (MemLS). It includes custom logging for WebDAV operations and special handling for a specific Litmus test case (\"props: 3 (propfind_invalid2)\"). The server listens on a specified port and handles all incoming HTTP requests.\n\nInput: None (though the code uses a command-line flag for port configuration which would be handled by the flag package)\n\nOutput: None (the function runs indefinitely as a server, but may log errors or fatal conditions)\n\nNote: The actual implementation shows the server uses a port flag (not shown in parameters) and produces log output, but these are side effects rather than formal outputs.\n\n---\n\nFor completeness, if we were to describe the webdav.Handler struct being used (though not explicitly defined in this code):\n\nStruct Description: webdav.Handler is a struct from golang.org/x/net/webdav that implements http.Handler for WebDAV protocol operations.\n\nFields:\nFileSystem: webdav.FileSystem - The underlying file system implementation\nLockSystem: webdav.LockSystem - The locking system implementation\nLogger: func(*http.Request, error) - Optional function for logging requests and errors\n\nMethods:\nServeHTTP: ServeHTTP(http.ResponseWriter, *http.Request) -> None - Main handler method that processes HTTP requests according to WebDAV protocol",
    "Canonical_solution": "import (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"golang.org/x/net/webdav\"\n)\nfunc main() {\n\tflag.Parse()\n\tlog.SetFlags(0)\n\th := &webdav.Handler{\n\t\tFileSystem: webdav.NewMemFS(),\n\t\tLockSystem: webdav.NewMemLS(),\n\t\tLogger: func(r *http.Request, err error) {\n\t\t\tlitmus := r.Header.Get(\"X-Litmus\")\n\t\t\tif len(litmus) > 19 {\n\t\t\t\tlitmus = litmus[:16] + \"...\"\n\t\t\t}\n\n\t\t\tswitch r.Method {\n\t\t\tcase \"COPY\", \"MOVE\":\n\t\t\t\tdst := \"\"\n\t\t\t\tif u, err := url.Parse(r.Header.Get(\"Destination\")); err == nil {\n\t\t\t\t\tdst = u.Path\n\t\t\t\t}\n\t\t\t\to := r.Header.Get(\"Overwrite\")\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%-30so=%-2s%v\", litmus, r.Method, r.URL.Path, dst, o, err)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"%-20s%-10s%-30s%v\", litmus, r.Method, r.URL.Path, err)\n\t\t\t}\n\t\t},\n\t}\n\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"X-Litmus\") == \"props: 3 (propfind_invalid2)\" {\n\t\t\thttp.Error(w, \"400 Bad Request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}))\n\n\taddr := fmt.Sprintf(\":%d\", *port)\n\tlog.Printf(\"Serving %v\", addr)\n\tlog.Fatal(http.ListenAndServe(addr, nil))\n}",
    "FSMID_for_test": 103,
    "Code_level": "Function-level"
}