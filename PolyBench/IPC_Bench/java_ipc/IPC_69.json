{
  "Task_id": 69,
  "Github_ID": "63831271",
  "Github_Project_Name": "roncoo-pay",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Http client-side based on Java.io & HttpURLConnection",
  "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
  "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
  "FSMID_for_test": 16,
  "Code_level": "Class-level"
}