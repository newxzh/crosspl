{
  "Task_id": 230,
  "Github_ID": "55224431",
  "Github_Project_Name": "whatsmars",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Server",
  "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data (discarding it in this example). It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> void - Entry point that configures and starts the Netty server\n  - args: [String[]] - Command line arguments (not directly used)\n  - Throws: Exception - For various Netty and SSL related exceptions\n- initChannel: [initChannel(SocketChannel ch)] -> void - Initializes the channel pipeline for each new connection (inner method of ChannelInitializer)\n  - ch: [SocketChannel] - The socket channel being initialized\n  - Configures SSL handler (if enabled) and adds the main server handler to the pipeline",
  "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class DiscardServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new DiscardServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
  "FSMID_for_test": 4,
  "Code_level": "Class-level"
}