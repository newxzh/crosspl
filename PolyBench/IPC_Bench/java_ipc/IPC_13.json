{
  "Task_id": 13,
  "Github_ID": "419152443",
  "Github_Project_Name": "planetiler",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "FileChannel usage in java.nio",
  "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
  "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
  "FSMID_for_test": 9,
  "Code_level": "Class-level"
}