{
  "Task_id": 43,
  "Github_ID": "16446099",
  "Github_Project_Name": "cryptomator",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Http client-side based on HttpClient in java",
  "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
  "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
  "FSMID_for_test": 17,
  "Code_level": "Class-level"
}