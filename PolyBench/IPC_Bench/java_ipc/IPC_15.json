{
  "Task_id": 15,
  "Github_ID": "58881448",
  "Github_Project_Name": "bt",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "FileChannel usage in java.nio",
  "Instruction": "Task Description: Implement a thread-safe file storage class that provides efficient read/write operations using Java NIO's FileChannel with proper resource management and concurrency control.\n\nClass Description: CachedOpenFile is a storage implementation that manages file operations using FileChannel, providing thread-safe access through read-write locks. It supports reading and writing data blocks at specific offsets, capacity management, and ensures proper file handling.\n\nAttributes:\n- fc: FileChannel - The file channel used for all file operations\n- lock: ReadWriteLock - Provides thread-safe access control for file operations\n- capacity: long - The maximum capacity of the storage unit\n\nMethods:\n- Constructor: CachedOpenFile(Path file, long capacity) -> void - Initializes the file channel with given path and capacity, creating parent directories if needed\n- readBlock: readBlock(ByteBuffer buffer, long offset) -> int - Reads data from the specified offset into the buffer\n- writeBlock: writeBlock(ByteBuffer buffer, long offset) -> int - Writes data from the buffer to the specified offset\n- writeBlock: writeBlock(ByteBufferView buffer, long offset) -> int - Writes data from a ByteBufferView to the specified offset\n- capacity: capacity() -> long - Returns the maximum capacity of the storage\n- size: size() -> long - Returns the current size of the file\n- flush: flush() -> void - Forces any changes to be written to disk\n- lockForIoOperation: lockForIoOperation() -> void - Acquires a read lock for IO operations\n- unlockForIoOperation: unlockForIoOperation() -> void - Releases the read lock after IO operations\n- close: close() -> void - Closes the file channel and releases all resources\n- ensureOpen: ensureOpen() -> void - Private method to verify the file channel is open before operations",
  "Canonical_solution": "import bt.data.StorageUnit;\nimport bt.net.buffer.ByteBufferView;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass CachedOpenFile implements StorageUnit {\n    private final FileChannel fc;\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final long capacity;\n\n    CachedOpenFile(Path file, long capacity) {\n        try {\n            Path parent = file.getParent();\n            if (parent != null) {\n                Files.createDirectories(parent);\n            }\n            fc = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        } catch (IOException ex) {\n            throw new UncheckedIOException(\"Could not open file \" + file.toAbsolutePath(), ex);\n        }\n        this.capacity = capacity;\n    }\n\n    @Override\n    public int readBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to read past the end of file (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.read(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to read bytes (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.write(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBufferView buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return buffer.transferTo(fc, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public long capacity() {\n        return capacity;\n    }\n\n    @Override\n    public long size() {\n        ensureOpen();\n        try {\n            return fc.size();\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        }\n    }\n\n    public void flush() throws IOException {\n        if (fc.isOpen())\n            this.fc.force(false);\n    }\n\n    public void lockForIoOperation() {\n        this.lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        this.lock.readLock().unlock();\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.writeLock().lock();\n        try {\n            this.fc.close();\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    private void ensureOpen() {\n        if (!fc.isOpen()) {\n            throw new IllegalStateException(\"Cannot access a closed file.\");\n        }\n    }\n}",
  "FSMID_for_test": 9,
  "Code_level": "Class-level"
}