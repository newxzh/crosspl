{
  "Task_id": 560,
  "Github_ID": "5103785",
  "Github_Project_Name": "undertow",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net Socket",
  "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
  "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
  "FSMID_for_test": 1,
  "Code_level": "Class-level"
}