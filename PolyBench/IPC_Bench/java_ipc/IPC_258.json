{
  "Task_id": 258,
  "Github_ID": "100402355",
  "Github_Project_Name": "cruise-control",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Kafka client Producer in java",
  "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
  "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
  "FSMID_for_test": 31,
  "Code_level": "Class-level"
}