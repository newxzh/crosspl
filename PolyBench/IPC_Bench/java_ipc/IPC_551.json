{
  "Task_id": 551,
  "Github_ID": "14561598",
  "Github_Project_Name": "HotswapAgent",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net ServerSocket",
  "Instruction": "Task Description: Create a Java class that implements a simple HTTP server capable of handling GET requests, serving both static files and dynamically generated class files through Javassist's ClassPool mechanism.\n\nClass Description: The Webserver class is a multi-threaded HTTP server that listens for incoming connections on a specified port. It can serve both static files from the filesystem and dynamically generated bytecode through Javassist's class manipulation capabilities. The server follows basic HTTP/1.0 protocol and handles each client connection in a separate thread.\n\nAttributes:\n- socket: ServerSocket - The main server socket listening for incoming connections\n- classPool: ClassPool - Javassist class pool for dynamic class generation\n- translator: Translator - Optional translator for class manipulation\n- endofline: byte[] - Constant for HTTP line endings (CRLF)\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- setClassPool(ClassPool loader) -> void - Sets the Javassist ClassPool for dynamic class generation\n- addTranslator(ClassPool cp, Translator t) -> void - Configures both ClassPool and Translator for advanced class manipulation\n- end() -> void - Closes the server socket and stops the server\n- run() -> void - Main server loop that accepts connections and spawns service threads\n- process(Socket clnt) -> void - Processes an individual client connection (handles HTTP protocol)\n- readLine(InputStream in) -> String - Reads a line of input from the client\n- skipLine(InputStream in) -> int - Skips a line of input from the client\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP request and generates appropriate response\n- letUsersSendClassfile(OutputStream out, String filename, int length) -> boolean - Handles dynamic class file generation and transmission\n- sendHeader(OutputStream out, long dataLength, int filetype) -> void - Sends HTTP response headers\n- replyError(OutputStream out, BadHttpRequest e) -> void - Sends HTTP error response",
  "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    protected Translator translator;\n\n    private final static byte[] endofline = { 0x0d, 0x0a };\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n        classPool = null;\n        translator = null;\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t)\n        throws NotFoundException, CannotCompileException\n    {\n        classPool = cp;\n        translator = t;\n        t.start(classPool);\n    }\n\n    public void end() throws IOException {\n        socket.close();\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        String cmd = readLine(in);\n        while (skipLine(in) > 0){\n        }\n\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            doReply(in, out, cmd);\n        }\n        catch (BadHttpRequest e) {\n            replyError(out, e);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n        clnt.close();\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuffer buf = new StringBuffer();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n\n        in.read();      /* skip 0x0a (LF) */\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n\n        in.read();      /* skip 0x0a (LF) */\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd)\n        throws IOException, BadHttpRequest\n    {\n        int len;\n        int fileType;\n        String filename, urlName;\n\n        if (cmd.startsWith(\"GET /\"))\n            filename = urlName = cmd.substring(5, cmd.indexOf(' ', 5));\n        else\n            throw new BadHttpRequest();\n\n        len = filename.length();\n        if (letUsersSendClassfile(out, filename, len))\n            return;\n\n        checkFilename(filename, len);\n        File file = new File(filename);\n        if (file.canRead()) {\n            sendHeader(out, file.length(), typeClass);\n            FileInputStream fin = new FileInputStream(file);\n            byte[] filebuffer = new byte[4096];\n            for (;;) {\n                len = fin.read(filebuffer);\n                if (len <= 0)\n                    break;\n                out.write(filebuffer, 0, len);\n            }\n\n            fin.close();\n            return;\n        }\n\n        throw new BadHttpRequest();\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out,\n                                          String filename, int length)\n        throws IOException, BadHttpRequest\n    {\n        if (classPool == null)\n            return false;\n\n        byte[] classfile;\n        String classname\n            = filename.substring(0, length - 6).replace('/', '.');\n        try {\n            if (translator != null)\n                translator.onLoad(classPool, classname);\n\n            CtClass c = classPool.get(classname);\n            classfile = c.toBytecode();\n        }\n        catch (Exception e) {\n            throw new BadHttpRequest(e);\n        }\n\n        sendHeader(out, classfile.length, typeClass);\n        out.write(classfile);\n        return true;\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 200 OK\".getBytes());\n        out.write(endofline);\n        out.write(\"Content-Length: \".getBytes());\n        out.write(Long.toString(dataLength).getBytes());\n        out.write(endofline);\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 400 Bad Request\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}",
  "FSMID_for_test": 0,
  "Code_level": "Class-level"
}