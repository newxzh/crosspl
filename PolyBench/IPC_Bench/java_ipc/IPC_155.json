{
  "Task_id": 155,
  "Github_ID": "20415251",
  "Github_Project_Name": "docker-java",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Client",
  "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a Docker daemon, with support for SSL/TLS encryption and timeout handling.\n\nClass Description: The NettyTcpClient class provides functionality to establish and manage TCP connections to a Docker daemon using Netty framework. It handles connection initialization, SSL/TLS configuration, timeout management, and graceful shutdown.\n\nAttributes:\n- bootstrap: Bootstrap - Netty's client bootstrap for connection configuration\n- eventLoopGroup: EventLoopGroup - Manages client-side I/O threads\n- connectTimeout: Integer - Connection timeout in milliseconds\n- readTimeout: Integer - Read operation timeout in milliseconds\n- threadPrefix: String - Prefix for Netty thread names\n\nMethods:\n- init(DockerClientConfig dockerClientConfig) -> void - Initializes the Netty client with Docker configuration\n- connect(DockerClientConfig dockerClientConfig) -> DuplexChannel - Establishes connection to Docker daemon with SSL support\n- initSsl(DockerClientConfig dockerClientConfig) -> SslHandler - Configures SSL/TLS for the connection\n- enableHostNameVerification(SSLParameters sslParameters) -> SSLParameters - Enables hostname verification in SSL parameters\n- close() -> void - Shuts down the client gracefully\n- configure(T channel) -> T - Configures channel timeouts and handlers\n- ReadTimeoutHandler() -> void - Inner class handling read timeout events",
  "Canonical_solution": "import com.github.dockerjava.core.DockerClientConfig;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelConfig;\nimport io.netty.channel.ChannelFactory;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DuplexChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketTimeoutException;\nimport java.security.Security;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLParameters;\n\npublic class NettyTcpClient {\n\n    private static String threadPrefix = \"dockerjava-netty\";\n    private Bootstrap bootstrap;\n    private EventLoopGroup eventLoopGroup;\n    private Integer connectTimeout;\n    private Integer readTimeout;\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        bootstrap = new Bootstrap();\n        eventLoopGroup = new NioEventLoopGroup(0, new DefaultThreadFactory(threadPrefix));\n\n        InetAddress addr = InetAddress.getLoopbackAddress();\n        final SocketAddress proxyAddress = new InetSocketAddress(addr, 8008);\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        ChannelFactory<NioSocketChannel> factory = () -> configure(new NioSocketChannel());\n\n        bootstrap.group(eventLoopGroup).channelFactory(factory)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(final SocketChannel channel) throws Exception {\n                        channel.pipeline().addLast(new HttpClientCodec());\n                        channel.pipeline().addLast(new HttpContentDecompressor());\n                    }\n                });\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) throws InterruptedException {\n        String host = dockerClientConfig.getDockerHost().getHost();\n        int port = dockerClientConfig.getDockerHost().getPort();\n\n        if (port == -1) {\n            throw new RuntimeException(\"no port configured for \" + host);\n        }\n\n        final DuplexChannel channel = (DuplexChannel) bootstrap.connect(host, port).sync().channel();\n\n        final SslHandler ssl = initSsl(dockerClientConfig);\n\n        if (ssl != null) {\n            channel.pipeline().addFirst(ssl);\n            ssl.sslCloseFuture().addListener(future -> channel.eventLoop().execute(channel::close));\n        }\n\n        return channel;\n    }\n\n    private SslHandler initSsl(DockerClientConfig dockerClientConfig) {\n        SslHandler ssl = null;\n\n        try {\n            String host = dockerClientConfig.getDockerHost().getHost();\n            int port = dockerClientConfig.getDockerHost().getPort();\n\n            final SSLConfig sslConfig = dockerClientConfig.getSSLConfig();\n\n            if (sslConfig != null && sslConfig.getSSLContext() != null) {\n                SSLEngine engine = sslConfig.getSSLContext().createSSLEngine(host, port);\n                engine.setUseClientMode(true);\n                engine.setSSLParameters(enableHostNameVerification(engine.getSSLParameters()));\n                ssl = new SslHandler(engine);\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return ssl;\n    }\n\n    public SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public void close() throws IOException {\n        Objects.requireNonNull(eventLoopGroup, \"Factory not initialized. You probably forgot to call init()!\");\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private <T extends Channel> T configure(T channel) {\n        ChannelConfig channelConfig = channel.config();\n\n        if (connectTimeout != null) {\n            channelConfig.setConnectTimeoutMillis(connectTimeout);\n        }\n        if (readTimeout != null) {\n            channel.pipeline().addLast(\"readTimeoutHandler\", new ReadTimeoutHandler());\n        }\n\n        return channel;\n    }\n\n    private final class ReadTimeoutHandler extends IdleStateHandler {\n        private boolean alreadyTimedOut;\n\n        ReadTimeoutHandler() {\n            super(readTimeout, 0, 0, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        protected synchronized void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n            assert evt.state() == IdleState.READER_IDLE;\n            final Channel channel = ctx.channel();\n            if (channel == null || !channel.isActive() || alreadyTimedOut) {\n                return;\n            }\n            DockerClientConfig dockerClientConfig = getDockerClientConfig();\n            final Object dockerAPIEndpoint = dockerClientConfig.getDockerHost();\n            final String msg = \"Read timed out: No data received within \" + readTimeout\n                    + \"ms.  Perhaps the docker API (\" + dockerAPIEndpoint\n                    + \") is not responding normally, or perhaps you need to increase the readTimeout value.\";\n            final Exception ex = new SocketTimeoutException(msg);\n            ctx.fireExceptionCaught(ex);\n            alreadyTimedOut = true;\n        }\n    }\n}",
  "FSMID_for_test": 3,
  "Code_level": "Class-level"
}