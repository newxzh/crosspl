{
  "Task_id": 427,
  "Github_ID": "81467673",
  "Github_Project_Name": "gnirehtet",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client-side based on java.nio",
  "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
  "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
  "FSMID_for_test": 6,
  "Code_level": "Class-level"
}