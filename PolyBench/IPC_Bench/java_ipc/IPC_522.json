{
  "Task_id": 522,
  "Github_ID": "87874521",
  "Github_Project_Name": "DKVideoPlayer",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net ServerSocket",
  "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
  "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
  "FSMID_for_test": 0,
  "Code_level": "Class-level"
}