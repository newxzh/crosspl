{
  "Task_id": 417,
  "Github_ID": "88256245",
  "Github_Project_Name": "AndroidControl",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client-side Java.io",
  "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
  "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
  "FSMID_for_test": 15,
  "Code_level": "Class-level"
}