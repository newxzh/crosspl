{
  "Task_id": 589,
  "Github_ID": "205225161",
  "Github_Project_Name": "snowflake",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net Socket",
  "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
  "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
  "FSMID_for_test": 1,
  "Code_level": "Class-level"
}