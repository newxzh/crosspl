{
  "Task_id": 483,
  "Github_ID": "8083731",
  "Github_Project_Name": "Bastillion",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "WebSocket Server based on Java EE",
  "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
  "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
  "FSMID_for_test": 26,
  "Code_level": "Class-level"
}