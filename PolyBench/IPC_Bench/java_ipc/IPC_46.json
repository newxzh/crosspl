{
  "Task_id": 46,
  "Github_ID": "9342529",
  "Github_Project_Name": "crate",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Http client-side based on HttpClient in java",
  "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
  "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
  "FSMID_for_test": 17,
  "Code_level": "Class-level"
}