{
  "Task_id": 498,
  "Github_ID": "141376301",
  "Github_Project_Name": "incubator-hugegraph",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "gRPC Client in java",
  "Instruction": "Task Description: Create a gRPC client class for service discovery that handles connection management, stub creation, and remote method invocation with retry logic.\n\nClass Description: DiscoveryClient is a gRPC client implementation that manages connections to a discovery service, provides thread-safe operations, and includes automatic retry mechanisms for failed requests.\n\nAttributes:\n- requireResetStub: AtomicBoolean - Flag indicating whether the stub needs to be reset\n- channel: ManagedChannel - The gRPC communication channel\n- registerStub: DiscoveryServiceBlockingStub - Blocking stub for registration operations  \n- blockingStub: DiscoveryServiceBlockingStub - Blocking stub for general operations\n- readWriteLock: ReentrantReadWriteLock - Lock for thread-safe operations\n- pdAddresses: List<String> - Server addresses (implied from usage)\n\nMethods:\n- DiscoveryClient(String centerAddress) -> None - Constructor that initializes the client with target server address\n- getNodeInfos(Query query) -> NodeInfos - Retrieves node information from discovery service with retry logic\n- tryWithTimes(Function<V,R> function, V v) -> R - Helper method implementing retry logic for operations\n- resetStub() -> None - Resets the channel and stubs when connection issues occur  \n- resetChannel(String address) -> None - Recreates the channel and stubs with a new address\n- close() -> None - Shuts down the channel and cleans up resources\n\nThe class demonstrates proper gRPC client patterns including:\n1. Channel lifecycle management\n2. Thread-safe stub operations\n3. Connection retry mechanisms\n4. Resource cleanup\n5. Error handling for network operations",
  "Canonical_solution": "import org.apache.hugegraph.pd.grpc.discovery.DiscoveryServiceGrpc;\nimport org.apache.hugegraph.pd.grpc.discovery.NodeInfos;\nimport org.apache.hugegraph.pd.grpc.discovery.Query;\nimport org.apache.hugegraph.pd.grpc.discovery.RegisterInfo;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel = null;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub blockingStub;\n    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public DiscoveryClient(String centerAddress) {\n        resetChannel(centerAddress);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((q) -> {\n            this.readWriteLock.readLock().lock();\n            NodeInfos nodes;\n            try {\n                nodes = this.blockingStub.getNodes(q);\n            } finally {\n                this.readWriteLock.readLock().unlock();\n            }\n            return nodes;\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        R r;\n        Exception ex = null;\n        for (int i = 0; i < 3; i++) {\n            try {\n                r = function.apply(v);\n                return r;\n            } catch (Exception e) {\n                requireResetStub.set(true);\n                resetStub();\n                ex = e;\n            }\n        }\n        if (ex != null) {\n            throw new RuntimeException(\"Discovery method failed\", ex);\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        if (requireResetStub.get()) {\n            try {\n                resetChannel(pdAddresses.get(0));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to reset stub\", e);\n            }\n        }\n    }\n\n    private void resetChannel(String address) {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.get()) {\n                if (channel != null) {\n                    channel.shutdownNow();\n                    channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n                }\n                channel = ManagedChannelBuilder.forTarget(address)\n                        .usePlaintext().build();\n                this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                requireResetStub.set(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n                channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}",
  "FSMID_for_test": 23,
  "Code_level": "Class-level"
}