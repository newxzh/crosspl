{
  "Task_id": 395,
  "Github_ID": "75164823",
  "Github_Project_Name": "rocketmq",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "RocketMQ Producer in Java",
  "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to specified topics with callback handling for success and failure cases.\n\nClass Description: RMQAsyncSendProducer is a RocketMQ asynchronous message producer that sends messages to a specified topic and handles responses through callbacks. It tracks successful sends and exceptions, and provides methods for waiting for responses and shutting down the producer.\n\nAttributes:\n- nsAddr: String - The NameServer address for RocketMQ\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- sendCallback: SendCallback - Callback handler for message send results\n- successSendResult: List<SendResult> - Thread-safe list of successful send results\n- exceptionMsgCount: AtomicInteger - Counter for messages that failed to send\n- msgSize: int - The number of messages to send\n- logger: Logger - SLF4J logger instance\n- topic: String - The topic to which messages will be sent (inherited from AbstractMQProducer)\n- msgBodys: [Data Structure] - Stores message bodies (inherited from AbstractMQProducer)\n- originMsgs: [Data Structure] - Stores original messages (inherited from AbstractMQProducer)\n\nMethods:\n- RMQAsyncSendProducer(String nsAddr, String topic) -> void - Constructor that initializes the producer with NameServer address and topic\n- create() -> void - Creates and configures the DefaultMQProducer instance\n- start() -> void - Starts the producer instance\n- asyncSend(Object msg) -> void - Asynchronously sends a single message\n- asyncSend(int msgSize) -> void - Asynchronously sends multiple messages (quantity specified by msgSize)\n- asyncSend(Object msg, MessageQueueSelector selector, Object arg) -> void - Asynchronously sends a message with queue selection\n- waitForResponse(int timeoutMills) -> void - Waits for all responses until timeout\n- shutdown() -> void - Shuts down the producer (overrides AbstractMQProducer method)",
  "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.test.clientinterface.AbstractMQProducer;\nimport org.apache.rocketmq.test.sendresult.ResultWrapper;\nimport org.apache.rocketmq.test.util.RandomUtil;\nimport org.apache.rocketmq.test.util.TestUtil;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private static Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    private String nsAddr = null;\n    private DefaultMQProducer producer = null;\n    private SendCallback sendCallback = null;\n    private List<SendResult> successSendResult = Collections.synchronizedList(new ArrayList<SendResult>());\n    private AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private int msgSize = 0;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.getAndIncrement();\n            }\n        };\n        create();\n        start();\n    }\n\n    private void create() {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(RandomUtil.getStringByUUID());\n        producer.setInstanceName(RandomUtil.getStringByUUID());\n        if (nsAddr != null) {\n            producer.setNamesrvAddr(nsAddr);\n        }\n    }\n\n    private void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"producer start failed!\");\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            Message msg = new Message(topic, RandomUtil.getStringByUUID().getBytes(StandardCharsets.UTF_8));\n            this.asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, selector, arg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        long startTime = System.currentTimeMillis();\n        while (this.successSendResult.size() != this.msgSize) {\n            if (System.currentTimeMillis() - startTime < timeoutMills) {\n                TestUtil.waitForMonment(100);\n            } else {\n                logger.info(\"timeout but still not recv all response!\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
  "FSMID_for_test": 42,
  "Code_level": "Class-level"
}