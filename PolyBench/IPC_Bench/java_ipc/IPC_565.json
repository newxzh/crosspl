{
  "Task_id": 565,
  "Github_ID": "15933091",
  "Github_Project_Name": "cobar",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net Socket",
  "Instruction": "Task Description: Create a Java class that establishes and manages a TCP connection to a database server using socket programming, including authentication and basic query functionality.\n\nClass Description: The UrlConnection class provides functionality to connect to a database server, authenticate, execute queries, and manage the connection lifecycle. It handles MySQL protocol communication including handshake, authentication, and basic command execution.\n\nAttributes:\n- host: String - The hostname or IP address of the database server\n- port: int - The port number of the database server\n- user: String - The username for authentication\n- password: String - The password for authentication\n- database: String - The name of the database to connect to\n- socket: Socket - The TCP socket connection to the server\n- in: InputStream - Input stream for reading data from the server\n- out: OutputStream - Output stream for writing data to the server\n- charsetIndex: int - The character set index used for communication\n- isClosed: AtomicBoolean - Flag indicating whether the connection is closed\n\nMethods:\n- UrlConnection(String, int, String, String, String) -> void - Constructor that initializes connection parameters\n- connect(int) -> void - Establishes a connection to the server with specified timeout\n- getServerList() -> List<CobarNode> - Executes a query to retrieve server list information\n- close() -> void - Closes the connection and releases resources\n- getRowList(int) -> List<CobarNode> - Helper method to process query result rows\n- auth411(HandshakePacket) -> BinaryPacket - Handles MySQL 4.1 authentication protocol\n- auth323(byte, byte[]) -> void - Handles MySQL 3.23 authentication protocol\n- getClientFlags() -> long - Returns client capability flags for MySQL protocol",
  "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n\n        BinaryPacket initPacket = new BinaryPacket();\n        initPacket.read(in);\n        HandshakePacket hsp = new HandshakePacket();\n        hsp.read(initPacket);\n\n        this.charsetIndex = hsp.serverCharsetIndex & 0xff;\n\n        BinaryPacket bin = null;\n        try {\n            bin = auth411(hsp);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        case EOFPacket.FIELD_COUNT:\n            auth323(bin.packetId, hsp.seed);\n            break;\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        CommandPacket cmd = new CommandPacket();\n        cmd.packetId = 0;\n        cmd.command = 3;\n        cmd.arg = \"SHOW COBAR_CLUSTER\".getBytes();\n        cmd.write(out);\n        out.flush();\n\n        int fieldCount = 0;\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case ErrorPacket.FIELD_COUNT: {\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        }\n        default:\n            ResultSetHeaderPacket rsh = new ResultSetHeaderPacket();\n            rsh.read(bin);\n            fieldCount = rsh.fieldCount;\n        }\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return getRowList(fieldCount);\n            }\n            default:\n                continue;\n            }\n        }\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                }\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        List<CobarNode> list = new LinkedList<CobarNode>();\n        BinaryPacket bin = null;\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return list;\n            }\n            default:\n                RowDataPacket row = new RowDataPacket(fieldCount);\n                row.read(bin);\n                String host = new String(row.fieldValues.get(0));\n                int weight = Integer.parseInt(new String(row.fieldValues.get(1)));\n                list.add(new CobarNode(host, weight));\n            }\n        }\n    }\n\n    private BinaryPacket auth411(HandshakePacket hsp) throws IOException, NoSuchAlgorithmException {\n        AuthPacket ap = new AuthPacket();\n        ap.packetId = 1;\n        ap.clientFlags = getClientFlags();\n        ap.maxPacketSize = 1024 * 1024 * 16;\n        ap.charsetIndex = charsetIndex;\n        ap.user = user;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            byte[] password = passwd.getBytes();\n            byte[] seed = hsp.seed;\n            byte[] restOfScramble = hsp.restOfScrambleBuff;\n            byte[] authSeed = new byte[seed.length + restOfScramble.length];\n            System.arraycopy(seed, 0, authSeed, 0, seed.length);\n            System.arraycopy(restOfScramble, 0, authSeed, seed.length, restOfScramble.length);\n            ap.password = SecurityUtil.scramble411(password, authSeed);\n        }\n        ap.database = database;\n        ap.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        Reply323Packet r323 = new Reply323Packet();\n        r323.packetId = ++packetId;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            r323.seed = SecurityUtil.scramble323(passwd, new String(seed)).getBytes();\n        }\n        r323.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    private static long getClientFlags() {\n        int flag = 0;\n        flag |= Capabilities.CLIENT_LONG_PASSWORD;\n        flag |= Capabilities.CLIENT_FOUND_ROWS;\n        flag |= Capabilities.CLIENT_LONG_FLAG;\n        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;\n        flag |= Capabilities.CLIENT_ODBC;\n        flag |= Capabilities.CLIENT_IGNORE_SPACE;\n        flag |= Capabilities.CLIENT_PROTOCOL_41;\n        flag |= Capabilities.CLIENT_INTERACTIVE;\n        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;\n        flag |= Capabilities.CLIENT_TRANSACTIONS;\n        flag |= Capabilities.CLIENT_SECURE_CONNECTION;\n        return flag;\n    }\n}",
  "FSMID_for_test": 1,
  "Code_level": "Class-level"
}