{
  "Task_id": 231,
  "Github_ID": "20415251",
  "Github_Project_Name": "docker-java",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Server",
  "Instruction": "Task Description: Create a Java class that implements a fake Docker server using Netty TCP server technology to intercept and record HTTP requests while responding with empty JSON responses.\n\nClass Description: The FakeDockerServer class simulates a Docker API server for testing purposes. It captures incoming HTTP requests and responds with a static JSON response. The server uses Netty's NIO event loop groups for handling connections and implements graceful shutdown capabilities.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- parent: NioEventLoopGroup - The parent event loop group for accepting connections\n- child: NioEventLoopGroup - The child event loop group for handling connections\n- requests: List<HttpRequest> - Stores all received HTTP requests for inspection\n- channel: Channel - The server's communication channel\n\nMethods:\n- FakeDockerServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> void - Starts the server and configures request handling pipeline\n- stop() -> void - Stops the server and releases resources gracefully\n- getRequests() -> List<HttpRequest> - Returns the list of captured HTTP requests",
  "Canonical_solution": "import com.github.dockerjava.api.DockerClient;\nimport com.github.dockerjava.core.DefaultDockerClientConfig;\nimport com.github.dockerjava.core.DockerClientBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\n\npublic class FakeDockerServer {\n    private final int port;\n    private final NioEventLoopGroup parent;\n    private final NioEventLoopGroup child;\n    private final List<HttpRequest> requests = new ArrayList<>();\n    private Channel channel;\n\n    public FakeDockerServer(int port) {\n        this.port = port;\n        this.parent = new NioEventLoopGroup();\n        this.child = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(parent, child)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel socketChannel) throws Exception {\n                    ChannelPipeline pipeline = socketChannel.pipeline();\n                    pipeline.addLast(\"codec\", new HttpServerCodec());\n                    pipeline.addLast(\"httpHandler\", new SimpleChannelInboundHandler<Object>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext context, Object message) throws Exception {\n                            if (message instanceof HttpRequest) {\n                                HttpRequest request = (HttpRequest) message;\n                                requests.add(request);\n                            }\n\n                            if (message instanceof HttpContent) {\n                                FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.copiedBuffer(\"{}\", CharsetUtil.UTF_8));\n                                response.headers().set(CONTENT_TYPE, \"application/json; charset=UTF-8\");\n                                response.headers().set(CONTENT_LENGTH, response.content().readableBytes());\n                                context.writeAndFlush(response);\n                            }\n                        }\n                    });\n                }\n            });\n\n        channel = bootstrap.bind(port).syncUninterruptibly().channel();\n    }\n\n    public void stop() throws Exception {\n        parent.shutdownGracefully();\n        child.shutdownGracefully();\n        channel.closeFuture().sync();\n    }\n\n    public List<HttpRequest> getRequests() {\n        return requests;\n    }\n}",
  "FSMID_for_test": 4,
  "Code_level": "Class-level"
}