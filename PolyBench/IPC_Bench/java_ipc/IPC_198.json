{
  "Task_id": 198,
  "Github_ID": "167204613",
  "Github_Project_Name": "im-server",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Server",
  "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
  "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
  "FSMID_for_test": 4,
  "Code_level": "Class-level"
}