{
  "Task_id": 79,
  "Github_ID": "73614722",
  "Github_Project_Name": "GSYVideoPlayer",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Http client-side based on Java.io & HttpURLConnection",
  "Instruction": "Task Description: Create a Java class that implements an HTTP client for streaming content with support for caching, custom headers, and SSL verification.\n\nClass Description: HttpUrlSource is a class that provides HTTP content streaming functionality with features like range requests, redirect handling, SSL customization, and header injection. It's designed to work with a caching system and stores source information (URL, length, MIME type) persistently.\n\nAttributes:\n- sourceInfoStorage: SourceInfoStorage - Stores and retrieves source information (URL, length, MIME type)\n- headerInjector: HeaderInjector - Injects custom headers into HTTP requests\n- v: HostnameVerifier - Custom hostname verifier for SSL connections\n- trustAllCerts: TrustManager[] - Custom trust managers for SSL connections\n- sourceInfo: SourceInfo - Contains URL, content length and MIME type information\n- connection: HttpURLConnection - Active HTTP connection\n- inputStream: InputStream - Stream for reading content\n\nMethods:\n- HttpUrlSource(String, HostnameVerifier, TrustManager[]) -> void - Constructor with URL, hostname verifier and trust managers\n- HttpUrlSource(String, SourceInfoStorage, HostnameVerifier, TrustManager[]) -> void - Constructor with additional source info storage\n- HttpUrlSource(String, SourceInfoStorage, HeaderInjector, HostnameVerifier, TrustManager[]) -> void - Full constructor with all dependencies\n- length() -> long - Returns content length, fetches if not known\n- open(long) -> void - Opens connection at specified offset\n- close() -> void - Closes current connection\n- read(byte[]) -> int - Reads data into buffer\n- getMime() -> String - Returns MIME type, fetches if not known\n- getUrl() -> String - Returns source URL\n- openConnection(long, int) -> HttpURLConnection - Internal method to open connection with offset and timeout\n- injectCustomHeaders(HttpURLConnection, String) -> void - Injects custom headers into connection\n- readSourceAvailableBytes(HttpURLConnection, long, int) -> long - Calculates available bytes based on response\n- getContentLength(HttpURLConnection) -> long - Extracts content length from headers\n- fetchContentInfo() -> void - Fetches content information (length and MIME type)",
  "Canonical_solution": "import com.danikula.videocache.headers.EmptyHeadersInjector;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorageFactory;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\n\npublic class HttpUrlSource implements Source {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private final HostnameVerifier v;\n    private final TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, SourceInfoStorageFactory.newEmptySourceInfoStorage(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, new EmptyHeadersInjector(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n            new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    @Override\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    @Override\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n            : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    @Override\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    @Override\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            if (url.startsWith(\"https\") && v != null && trustAllCerts != null) {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n                ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                try {\n                    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n                    ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n            }\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        if (extraHeaders == null) {\n            return;\n        }\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
  "FSMID_for_test": 16,
  "Code_level": "Class-level"
}