{
  "Task_id": 610,
  "Github_ID": "1961837",
  "Github_Project_Name": "ttorrent",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net UDP Server or Client",
  "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
  "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
  "FSMID_for_test": 2,
  "Code_level": "Class-level"
}