{
  "Task_id": 509,
  "Github_ID": "9278888",
  "Github_Project_Name": "brave",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "gRPC Server in java",
  "Instruction": "Task Description: Create a gRPC server in Java that handles incoming requests with configurable delays and traces request contexts using Brave propagation. The server should intercept calls to collect headers and propagation data, and allow for graceful shutdown.\n\nClass Description: TestServer is a gRPC server implementation that intercepts incoming calls to collect tracing information and headers. It supports configurable response delays and maintains queues for request processing.\n\nAttributes:\n- delayQueue: BlockingQueue<Long> - Queue for storing artificial delay durations (milliseconds) to be applied to requests\n- headers: BlockingQueue<Metadata> - Queue for storing metadata headers from incoming requests\n- requests: BlockingQueue<TraceContextOrSamplingFlags> - Queue for storing extracted trace contexts from requests\n- extractor: Extractor<GrpcServerRequest> - Brave propagation extractor for trace context extraction\n- server: Server - The gRPC server instance\n\nMethods:\n- TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) -> void - Constructor that initializes the server with propagation configuration\n- start() -> void - Starts the gRPC server\n- stop() -> void - Stops the server gracefully and awaits termination\n- port() -> int - Returns the port number the server is listening on\n- takeRequest() -> TraceContextOrSamplingFlags - Retrieves the next request context from the queue (waits up to 3 seconds)\n- enqueueDelay(long millis) -> void - Adds a delay duration to be applied to the next request",
  "Canonical_solution": "import brave.propagation.Propagation;\nimport brave.propagation.TraceContext.Extractor;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport io.grpc.Metadata;\nimport io.grpc.Metadata.Key;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCall.Listener;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerInterceptors;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nclass TestServer {\n  static final Key<String> CUSTOM_KEY = Key.of(\"custom\", Metadata.ASCII_STRING_MARSHALLER);\n  final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n  final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n  final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n  final Extractor<GrpcServerRequest> extractor;\n  final Server server;\n\n  TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n    extractor = propagation.extractor(GrpcServerRequest::propagationField);\n    server = ServerBuilder.forPort(PickUnusedPort.get())\n        .addService(ServerInterceptors.intercept(\n            new GreeterImpl(null),\n            new ServerInterceptor() {\n              @Override\n              public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n                  Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                Long delay = delayQueue.poll();\n                if (delay != null) {\n                  try {\n                    Thread.sleep(delay);\n                  } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new AssertionError(\"interrupted sleeping \" + delay);\n                  }\n                }\n                TestServer.this.headers.add(headers);\n                requests.add(extractor.extract(new GrpcServerRequest(nameToKey, call, headers)));\n                return next.startCall(new SimpleForwardingServerCall<ReqT, RespT>(call) {\n                  @Override public void sendHeaders(Metadata headers) {\n                    headers.put(CUSTOM_KEY, \"brave\");\n                    super.sendHeaders(headers);\n                  }\n                }, headers);\n              }\n            }))\n        .build();\n  }\n\n  void start() throws IOException {\n    server.start();\n  }\n\n  void stop() {\n    server.shutdown();\n    try {\n      server.awaitTermination();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  int port() {\n    return server.getPort();\n  }\n\n  TraceContextOrSamplingFlags takeRequest() {\n    try {\n      return requests.poll(3, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  void enqueueDelay(long millis) {\n    this.delayQueue.add(millis);\n  }\n}",
  "FSMID_for_test": 24,
  "Code_level": "Class-level"
}