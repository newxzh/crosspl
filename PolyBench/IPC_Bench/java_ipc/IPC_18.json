{
  "Task_id": 18,
  "Github_ID": "1911523",
  "Github_Project_Name": "vert.x",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "FileChannel usage in java.nio",
  "Instruction": "Task Description: Implement an asynchronous file handling class in Java using NIO's AsynchronousFileChannel for non-blocking file operations, supporting both reading and writing with various file opening options.\n\nClass Description: AsyncFileImpl is an implementation of AsyncFile interface that provides asynchronous file operations using Java NIO. It handles file reading, writing, and closing operations in a non-blocking manner, with support for various file opening modes and permissions.\n\nAttributes:\n- vertx: VertxInternal - The Vert.x instance for asynchronous operations\n- ch: AsynchronousFileChannel - The NIO asynchronous file channel\n- context: ContextInternal - The Vert.x context for operation execution\n- closed: boolean - Flag indicating if the file is closed\n- writePos: long - Current write position in the file\n- readBufferSize: int - Size of the read buffer (default 8192)\n- handler: Handler<Buffer> - Handler for read operations\n- endHandler: Handler<Void> - Handler for end of file operations\n- readPos: long - Current read position in the file\n- readLength: long - Maximum length to read (default Long.MAX_VALUE)\n\nMethods:\n- AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) -> [Constructor] - Initializes the file channel with specified path and options\n- close() -> Future<Void> - Closes the file channel and releases resources\n- read(Buffer buffer, int offset, long position, int length) -> Future<Buffer> - Reads data from file into buffer at specified position\n- write(Buffer buffer, long position) -> Future<Void> - Writes buffer content to file at specified position\n- doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for write operation\n- doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing multiple buffers\n- doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing buffer content\n- writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) -> void - Core write implementation using CompletionHandler\n- doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) -> void - Internal method for read operation\n- check() -> void - Verifies if file is not closed\n- closeInternal(Promise<Void> handler) -> void - Internal method for closing the file channel",
  "Canonical_solution": "import io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.buffer.BufferInternal;\nimport io.vertx.core.file.AsyncFile;\nimport io.vertx.core.file.FileSystemException;\nimport io.vertx.core.file.OpenOptions;\nimport io.vertx.core.impl.Arguments;\nimport io.vertx.core.internal.ContextInternal;\nimport io.vertx.core.internal.VertxInternal;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.streams.impl.InboundBuffer;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AsyncFileImpl implements AsyncFile {\n\n    private static final Logger log = LoggerFactory.getLogger(AsyncFile.class);\n\n    private final VertxInternal vertx;\n    private final AsynchronousFileChannel ch;\n    private final ContextInternal context;\n    private boolean closed;\n    private long writePos;\n    private int readBufferSize = 8192;\n    private Handler<Buffer> handler;\n    private Handler<Void> endHandler;\n    private long readPos;\n    private long readLength = Long.MAX_VALUE;\n\n    public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) {\n        this.vertx = vertx;\n        Path file = Paths.get(path);\n        HashSet<OpenOption> opts = new HashSet<>();\n        if (options.isRead()) opts.add(StandardOpenOption.READ);\n        if (options.isWrite()) opts.add(StandardOpenOption.WRITE);\n        if (options.isCreate()) opts.add(StandardOpenOption.CREATE);\n        if (options.isCreateNew()) opts.add(StandardOpenOption.CREATE_NEW);\n        if (options.isSync()) opts.add(StandardOpenOption.SYNC);\n        if (options.isDsync()) opts.add(StandardOpenOption.DSYNC);\n        if (options.isDeleteOnClose()) opts.add(StandardOpenOption.DELETE_ON_CLOSE);\n        if (options.isSparse()) opts.add(StandardOpenOption.SPARSE);\n        if (options.isTruncateExisting()) opts.add(StandardOpenOption.TRUNCATE_EXISTING);\n        try {\n            if (options.getPerms() != null) {\n                FileAttribute<?> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(options.getPerms()));\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor(), attrs);\n            } else {\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor());\n            }\n            if (options.isAppend()) writePos = ch.size();\n        } catch (IOException e) {\n            throw new FileSystemException(e);\n        }\n        this.context = context;\n    }\n\n    @Override\n    public Future<Void> close() {\n        Promise<Void> promise = context.promise();\n        closeInternal(promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n        Promise<Buffer> promise = context.promise();\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(offset >= 0, \"offset must be >= 0\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        Arguments.require(length >= 0, \"length must be >= 0\");\n        check();\n        ByteBuffer bb = ByteBuffer.allocate(length);\n        doRead(buffer, offset, bb, position, promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Void> write(Buffer buffer, long position) {\n        Promise<Void> promise = context.promise();\n        doWrite(buffer, position, promise::handle);\n        return promise.future();\n    }\n\n    private void doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) {\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        check();\n        ByteBuf buf = ((BufferInternal)buffer).getByteBuf();\n        if (buf.nioBufferCount() > 1) {\n            doWrite(buf.nioBuffers(), position, handler);\n        } else {\n            ByteBuffer bb = buf.nioBuffer();\n            doWrite(bb, position, bb.limit(), handler);\n        }\n    }\n\n    private void doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) {\n        AtomicInteger cnt = new AtomicInteger();\n        AtomicBoolean sentFailure = new AtomicBoolean();\n        for (ByteBuffer b: buffers) {\n            int limit = b.limit();\n            doWrite(b, position, limit, ar -> {\n                if (ar.succeeded()) {\n                    if (cnt.incrementAndGet() == buffers.length) {\n                        handler.handle(ar);\n                    }\n                } else {\n                    if (sentFailure.compareAndSet(false, true)) {\n                        handler.handle(ar);\n                    }\n                }\n            });\n            position += limit;\n        }\n    }\n\n    private void doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) {\n        if (toWrite > 0) {\n            writeInternal(buff, position, handler);\n        } else {\n            handler.handle(Future.succeededFuture());\n        }\n    }\n\n    private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        ch.write(buff, position, null, new CompletionHandler<Integer, Object>() {\n            public void completed(Integer bytesWritten, Object attachment) {\n                long pos = position;\n                if (buff.hasRemaining()) {\n                    pos += bytesWritten;\n                    writeInternal(buff, pos, handler);\n                } else {\n                    context.runOnContext((v) -> {\n                        handler.handle(Future.succeededFuture());\n                    });\n                }\n            }\n\n            public void failed(Throwable exc, Object attachment) {\n                context.runOnContext((v) -> {\n                    handler.handle(Future.failedFuture(exc));\n                });\n            }\n        });\n    }\n\n    private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n        ch.read(buff, position, null, new CompletionHandler<Integer, Object>() {\n            long pos = position;\n\n            private void done() {\n                buff.flip();\n                writeBuff.setBytes(offset, buff);\n                buff.compact();\n                promise.complete(writeBuff);\n            }\n\n            public void completed(Integer bytesRead, Object attachment) {\n                if (bytesRead == -1) {\n                    done();\n                } else if (buff.hasRemaining()) {\n                    pos += bytesRead;\n                    doRead(writeBuff, offset, buff, pos, promise);\n                } else {\n                    done();\n                }\n            }\n\n            public void failed(Throwable t, Object attachment) {\n                promise.fail(t);\n            }\n        });\n    }\n\n    private void check() {\n        if (closed) {\n            throw new IllegalStateException(\"File handle is closed\");\n        }\n    }\n\n    private void closeInternal(Promise<Void> handler) {\n        check();\n        closed = true;\n        context.<Void>executeBlockingInternal(() -> {\n            ch.close();\n            return null;\n        }).onComplete(handler);\n    }\n}",
  "FSMID_for_test": 9,
  "Code_level": "Class-level"
}