{
  "Task_id": 529,
  "Github_ID": "1593731",
  "Github_Project_Name": "fqrouter",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net ServerSocket",
  "Instruction": "Task Description: Implement a Java class for handling DNS connections using TCP sockets, including server listening, client connection, message sending/receiving, and resource cleanup.\n\nClass Description: The DNSConnection class provides functionality for establishing and managing TCP-based DNS connections. It supports both server-side (incoming) and client-side (outgoing) connections, message transmission with length prefixing, and proper resource management.\n\nAttributes:\n- PORT: [int] - Constant defining the DNS port (53)\n- MAX_MSG_LEN: [int] - Maximum allowed message length (65535)\n- listener: [ServerSocket] - Server socket for incoming connections\n- socket: [Socket] - Current active socket connection\n- msgBytes: [byte[]] - Buffer for received message data\n- msgLen: [int] - Length of the current message\n- in: [BufferedInputStream] - Input stream for reading data\n- out: [OutputStream] - Output stream for writing data\n- lenBuf: [byte[]] - Buffer for message length prefix (2 bytes)\n\nMethods:\n- listen(): [void] -> [void] - Starts listening for incoming connections on the DNS port\n- stopListening(): [void] -> [void] - Stops the server socket from listening\n- openIncoming(): [void] -> [void] - Accepts an incoming client connection\n- open(InetAddress server): [void] -> [void] - Opens a connection to a DNS server\n- send(byte[] msgBytes): [void] -> [void] - Sends a message with length prefix\n- receive(boolean wait): [byte[]] -> [byte[]] - Receives a message (optionally waiting)\n- close(): [void] -> [void] - Closes the current connection and cleans up resources",
  "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic final class DNSConnection {\n\n    public static final int PORT = 53;\n    public static final int MAX_MSG_LEN = 0xFFFF;\n    protected static ServerSocket listener;\n    protected Socket socket;\n    protected byte[] msgBytes;\n    protected int msgLen;\n    protected BufferedInputStream in;\n    protected OutputStream out;\n    protected final byte[] lenBuf = new byte[2];\n\n    public DNSConnection() {}\n\n    public static void listen() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) == null) {\n            try {\n                listener = new ServerSocket(PORT);\n            } catch (SecurityException e) {\n                throw new SocketException(\"SecurityException: listen()\");\n            }\n        }\n        curListener = null;\n    }\n\n    public static void stopListening() {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            listener = null;\n            try {\n                curListener.close();\n            } catch (IOException e) {}\n            curListener = null;\n        }\n    }\n\n    public void openIncoming() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            try {\n                Socket socket = curListener.accept();\n                BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n                this.out = socket.getOutputStream();\n                this.in = in;\n                this.msgBytes = null;\n                this.socket = socket;\n                return;\n            } catch (SecurityException e) {}\n        }\n        throw new SocketException(curListener == null ? \"Not listening\" : \"SecurityException: accept()\");\n    }\n\n    public void open(InetAddress server) throws NullPointerException, IOException {\n        server.hashCode();\n        try {\n            Socket socket = new Socket(server, PORT);\n            BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n            this.out = socket.getOutputStream();\n            this.in = in;\n            this.socket = socket;\n        } catch (SecurityException e) {\n            throw new SocketException(\"SecurityException: connect(\" + server.getHostAddress() + \")\");\n        }\n        this.msgBytes = null;\n    }\n\n    public void send(byte[] msgBytes) throws NullPointerException, IOException {\n        int msgLen;\n        if ((msgLen = msgBytes.length) >= MAX_MSG_LEN)\n            msgLen = MAX_MSG_LEN;\n        OutputStream out;\n        if ((out = this.out) == null)\n            throw new SocketException(\"Connection closed\");\n        byte[] lenBuf = this.lenBuf;\n        lenBuf[0] = (byte)(msgLen >> 8);\n        lenBuf[1] = (byte)msgLen;\n        out.write(lenBuf, 0, 2);\n        out.write(msgBytes, 0, msgLen);\n        out.flush();\n    }\n\n    public byte[] receive(boolean wait) throws IOException {\n        byte[] msgBytes;\n        int msgLen, len;\n        BufferedInputStream in;\n        if ((in = this.in) == null)\n            throw new SocketException(\"Connection closed\");\n        if ((msgLen = this.msgLen) <= 0)\n            msgLen = 0;\n        if ((msgBytes = this.msgBytes) == null) {\n            do {\n                if (!wait && in.available() <= 0)\n                    return null;\n                else if ((len = in.read()) < 0)\n                    throw new EOFException();\n                else if (msgLen <= 0)\n                    this.msgLen = msgLen = len + 1;\n                else break;\n            } while (true);\n            if ((msgLen = ((msgLen - 1) << 8) | len) <= 0)\n                msgLen = 0;\n            this.msgBytes = msgBytes = new byte[msgLen];\n            msgLen = 0;\n        }\n        for (int avail; (len = msgBytes.length - (this.msgLen = msgLen)) > 0; msgLen += len)\n            if (!wait && (avail = in.available()) < len && (len = avail) <= 0)\n                return null;\n            else if ((len = in.read(msgBytes, msgLen, len)) < 0)\n                throw new EOFException();\n        this.msgBytes = null;\n        this.msgLen = 0;\n        return msgBytes;\n    }\n\n    public void close() {\n        Socket socket;\n        if ((socket = this.socket) != null) {\n            this.socket = null;\n            this.in = null;\n            this.out = null;\n            this.msgBytes = null;\n            try {\n                socket.close();\n            } catch (IOException e) {}\n            socket = null;\n        }\n    }\n}",
  "FSMID_for_test": 0,
  "Code_level": "Class-level"
}