{
  "Task_id": 270,
  "Github_ID": "5722043",
  "Github_Project_Name": "jodd",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "ProcessBuilder in java.io",
  "Instruction": "Task Description: Create a Java class that provides a fluent interface for building and executing command-line processes with configurable environment variables, working directory, and output handling.\n\nClass Description: The CommandLine class is a builder-style utility for executing external processes. It allows chaining configuration methods to set up command arguments, environment variables, working directory, and output streams before execution. The class handles process execution, stream management, and result collection.\n\nAttributes:\n- cmdLine: List<String> - Stores the command and its arguments\n- env: Map<String, String> - Stores environment variables for the process\n- cleanEnvironment: boolean - Flag to determine whether to clear existing environment variables\n- workingDirectory: File - The working directory for the process\n- outPrefix: String - Prefix for standard output lines\n- errPrefix: String - Prefix for error output lines\n- out: OutputStream - Stream for standard output\n- err: OutputStream - Stream for error output\n\nMethods:\n- cmd(String): CommandLine - Static factory method to create a new CommandLine instance with initial command\n- workingDirectory(File): CommandLine - Sets the working directory using File object\n- workingDirectory(String): CommandLine - Sets the working directory using path string\n- arg(String): CommandLine - Adds a single argument to the command\n- args(String...): CommandLine - Adds multiple arguments to the command\n- outPrefix(String): CommandLine - Sets prefix for standard output\n- errPrefix(String): CommandLine - Sets prefix for error output\n- out(OutputStream): CommandLine - Sets standard output stream\n- err(OutputStream): CommandLine - Sets error output stream\n- env(String, String): CommandLine - Adds an environment variable\n- newEnv(boolean): CommandLine - Configures whether to clean environment variables\n- run(): ProcessRunner.ProcessResult - Executes the configured command and returns the result",
  "Canonical_solution": "import jodd.io.StreamGobbler;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n\n    public static final int OK = 0;\n\n    protected final List<String> cmdLine = new ArrayList<>();\n    protected Map<String, String> env = null;\n    protected boolean cleanEnvironment = false;\n    protected File workingDirectory;\n    protected String outPrefix;\n    protected String errPrefix;\n    protected OutputStream out = System.out;\n    protected OutputStream err = System.err;\n\n    protected CommandLine(final String command) {\n        cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(final String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(final File workDirectory) {\n        this.workingDirectory = workDirectory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(final String workDirectory) {\n        this.workingDirectory = new File(workDirectory);\n        return this;\n    }\n\n    public CommandLine arg(final String argument) {\n        cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(final String... arguments) {\n        if (arguments != null && arguments.length > 0) {\n            Collections.addAll(cmdLine, arguments);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(final String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(final String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(final OutputStream out) {\n        this.out = out;\n        return this;\n    }\n\n    public CommandLine err(final OutputStream err) {\n        this.err = err;\n        return this;\n    }\n\n    public CommandLine env(final String key, final String value) {\n        if (env == null) {\n            env = new HashMap<>();\n        }\n        env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(final boolean clean) {\n        cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        out = err = baos;\n\n        try {\n            baos.write(StringUtil.join(cmdLine, ' ').getBytes());\n            baos.write(StringPool.BYTES_NEW_LINE);\n        }\n        catch (IOException ignore) {\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(cmdLine);\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n\n        processBuilder.directory(workingDirectory);\n\n        Process process = null;\n        try {\n            process = processBuilder.start();\n        }\n        catch (IOException ioex) {\n            return writeException(baos, ioex);\n        }\n\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix);\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix);\n\n        outputGobbler.start();\n        errorGobbler.start();\n\n        int result;\n        try {\n            result = process.waitFor();\n        }\n        catch (InterruptedException iex) {\n            return writeException(baos, iex);\n        }\n\n        outputGobbler.waitFor();\n        errorGobbler.waitFor();\n\n        return new ProcessRunner.ProcessResult(result, baos.toString());\n    }\n\n    private ProcessRunner.ProcessResult writeException(final ByteArrayOutputStream baos, final Exception ex) {\n        try {\n            baos.write(errPrefix.getBytes());\n        }\n        catch (IOException ignore) {\n        }\n\n        ex.printStackTrace(new PrintStream(baos));\n        return new ProcessRunner.ProcessResult(-1, baos.toString());\n    }\n}",
  "FSMID_for_test": 44,
  "Code_level": "Class-level"
}