{
  "Task_id": 132,
  "Github_ID": "74261168",
  "Github_Project_Name": "lanproxy",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Client",
  "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a proxy server, handle SSL encryption if enabled, manage connection lifecycle, and support reconnection with exponential backoff.\n\nClass Description: ProxyClientContainer is a Netty-based TCP client container that establishes and maintains a connection to a proxy server. It handles SSL encryption when configured, manages connection retries with exponential backoff, and provides channel management for proxy communication.\n\nAttributes:\n- logger: [Logger] - SLF4J logger instance for logging events\n- workerGroup: [NioEventLoopGroup] - Netty event loop group for handling I/O operations\n- bootstrap: [Bootstrap] - Primary bootstrap for proxy server connections\n- realServerBootstrap: [Bootstrap] - Bootstrap for real server connections\n- config: [Config] - Configuration instance for client settings\n- sslContext: [SSLContext] - SSL context for secure connections (nullable)\n- sleepTimeMill: [long] - Current sleep duration for reconnection attempts\n\nMethods:\n- ProxyClientContainer() -> [void] - Constructor that initializes worker group, bootstraps, and configures channel pipelines\n- start() -> [void] - Starts the client by initiating connection to proxy server\n- createSslHandler(SSLContext sslContext) -> [ChannelHandler] - Creates SSL handler for secure connections\n- connectProxyServer() -> [void] - Connects to proxy server with retry logic on failure\n- stop() -> [void] - Shuts down the client gracefully\n- channelInactive(ChannelHandlerContext ctx) -> [void] - Handles channel inactive events by triggering reconnection\n- reconnectWait() -> [void] - Implements exponential backoff for reconnection attempts",
  "Canonical_solution": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.client.handlers.ClientChannelHandler;\nimport org.fengfei.lanproxy.client.handlers.RealServerChannelHandler;\nimport org.fengfei.lanproxy.common.Config;\nimport org.fengfei.lanproxy.protocol.IdleCheckHandler;\nimport org.fengfei.lanproxy.protocol.ProxyMessage;\nimport org.fengfei.lanproxy.protocol.ProxyMessageDecoder;\nimport org.fengfei.lanproxy.protocol.ProxyMessageEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ProxyClientContainer {\n\n    private static Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n\n    private NioEventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n    private Bootstrap realServerBootstrap;\n    private Config config = Config.getInstance();\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        workerGroup = new NioEventLoopGroup();\n        realServerBootstrap = new Bootstrap();\n        realServerBootstrap.group(workerGroup);\n        realServerBootstrap.channel(NioSocketChannel.class);\n        realServerBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new RealServerChannelHandler());\n            }\n        });\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                if (Config.getInstance().getBooleanValue(\"ssl.enable\", false)) {\n                    if (sslContext == null) {\n                        sslContext = SslContextCreator.createSSLContext();\n                    }\n                    ch.pipeline().addLast(createSslHandler(sslContext));\n                }\n                ch.pipeline().addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                ch.pipeline().addLast(new ProxyMessageEncoder());\n                ch.pipeline().addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, IdleCheckHandler.WRITE_IDLE_TIME - 10, 0));\n                ch.pipeline().addLast(new ClientChannelHandler(realServerBootstrap, bootstrap, ProxyClientContainer.this));\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(true);\n        return new SslHandler(sslEngine);\n    }\n\n    private void connectProxyServer() {\n        bootstrap.connect(config.getStringValue(\"server.host\"), config.getIntValue(\"server.port\")).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ProxyMessage proxyMessage = new ProxyMessage();\n                    proxyMessage.setType(ProxyMessage.C_TYPE_AUTH);\n                    proxyMessage.setUri(config.getStringValue(\"client.key\"));\n                    future.channel().writeAndFlush(proxyMessage);\n                    sleepTimeMill = 1000;\n                    logger.info(\"connect proxy server success, {}\", future.channel());\n                } else {\n                    logger.warn(\"connect proxy server failed\", future.cause());\n                    reconnectWait();\n                    connectProxyServer();\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            if (sleepTimeMill > 60000) {\n                sleepTimeMill = 1000;\n            }\n            synchronized (this) {\n                sleepTimeMill = sleepTimeMill * 2;\n                wait(sleepTimeMill);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}",
  "FSMID_for_test": 3,
  "Code_level": "Class-level"
}