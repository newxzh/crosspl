{
  "Task_id": 121,
  "Github_ID": "222578036",
  "Github_Project_Name": "datax-web",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Client",
  "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for RPC communication, handling connection management, message sending, and resource cleanup.\n\nClass Description: NettyConnectClient is a TCP client implementation using Netty framework for RPC communication. It manages network connections, handles message encoding/decoding, and provides methods for connection validation and resource cleanup.\n\nAttributes:\n- group: [EventLoopGroup] - Manages client-side I/O threads and event processing\n- channel: [Channel] - Represents the active network connection to the server\n\nMethods:\n- init: [void]([String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory]) -> [void] - Initializes the client connection, sets up the pipeline with encoders/decoders, and establishes connection to the server\n- isValidate: [void]() -> [boolean] - Checks if the current connection is active and valid\n- close: [void]() -> [void] - Closes the active connection and releases all resources\n- send: [void]([XxlRpcRequest xxlRpcRequest]) -> [void] - Sends an RPC request through the established channel",
  "Canonical_solution": "import com.wugui.datax.rpc.remoting.invoker.XxlRpcInvokerFactory;\nimport com.wugui.datax.rpc.remoting.net.common.ConnectClient;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyDecoder;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyEncoder;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.serialize.Serializer;\nimport com.wugui.datax.rpc.util.IpUtil;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyConnectClient extends ConnectClient {\n\n    private EventLoopGroup group;\n    private Channel channel;\n\n    @Override\n    public void init(String address, final Serializer serializer, final XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        final NettyConnectClient thisClient = this;\n\n        Object[] array = IpUtil.parseIpPort(address);\n        String host = (String) array[0];\n        int port = (int) array[1];\n\n        this.group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel channel) throws Exception {\n                        channel.pipeline()\n                                .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL, TimeUnit.SECONDS))\n                                .addLast(new NettyEncoder(XxlRpcRequest.class, serializer))\n                                .addLast(new NettyDecoder(XxlRpcResponse.class, serializer))\n                                .addLast(new NettyClientHandler(xxlRpcInvokerFactory, thisClient));\n                    }\n                })\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n        this.channel = bootstrap.connect(host, port).sync().channel();\n\n        if (!isValidate()) {\n            close();\n            return;\n        }\n    }\n\n    @Override\n    public boolean isValidate() {\n        if (this.channel != null) {\n            return this.channel.isActive();\n        }\n        return false;\n    }\n\n    @Override\n    public void close() {\n        if (this.channel != null && this.channel.isActive()) {\n            this.channel.close();\n        }\n        if (this.group != null && !this.group.isShutdown()) {\n            this.group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void send(XxlRpcRequest xxlRpcRequest) throws Exception {\n        this.channel.writeAndFlush(xxlRpcRequest).sync();\n    }\n}",
  "FSMID_for_test": 3,
  "Code_level": "Class-level"
}