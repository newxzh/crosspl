{
  "Task_id": 264,
  "Github_ID": "75164823",
  "Github_Project_Name": "rocketmq",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "NIO HTTP Server in Java",
  "Instruction": "Task Description: Implement a Java class that handles asynchronous socket connections using Java NIO (Non-blocking I/O) to manage incoming connections for a high-availability service. The class should be abstract, allowing subclasses to define specific connection handling logic.\n\nClass Description: AcceptSocketService is an abstract class that extends ServiceThread to provide a non-blocking socket server implementation. It manages incoming socket connections using ServerSocketChannel and Selector, delegating the creation of specific connection handlers to subclasses through an abstract method. The class handles the lifecycle of the server socket, including startup, connection acceptance, and shutdown.\n\nAttributes:\n- socketAddressListen: [SocketAddress] - The address and port to listen for incoming connections\n- serverSocketChannel: [ServerSocketChannel] - The server socket channel for accepting connections\n- selector: [Selector] - The selector for managing multiple non-blocking channels\n- messageStoreConfig: [MessageStoreConfig] - Configuration object containing server settings\n- log: [Logger] - Logger instance for recording events and errors\n\nMethods:\n- AcceptSocketService([MessageStoreConfig messageStoreConfig]) -> [void] - Constructor that initializes the service with configuration\n- beginAccept() -> [void] - Initializes and starts the server socket channel and selector\n- shutdown([boolean interrupt]) -> [void] - Shuts down the service and cleans up resources\n- run() -> [void] - Main service loop that handles incoming connections (inherited from ServiceThread)\n- createConnection([SocketChannel sc]) -> [HAConnection] - Abstract method to be implemented by subclasses for creating connection handlers",
  "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.config.MessageStoreConfig;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\n\nprotected abstract class AcceptSocketService extends ServiceThread {\n    private final SocketAddress socketAddressListen;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private final MessageStoreConfig messageStoreConfig;\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);\n\n    public AcceptSocketService(final MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = new InetSocketAddress(messageStoreConfig.getHaListenPort());\n    }\n\n    public void beginAccept() throws Exception {\n        this.serverSocketChannel = ServerSocketChannel.open();\n        this.selector = NetworkUtil.openSelector();\n        this.serverSocketChannel.socket().setReuseAddress(true);\n        this.serverSocketChannel.socket().bind(this.socketAddressListen);\n        if (0 == messageStoreConfig.getHaListenPort()) {\n            messageStoreConfig.setHaListenPort(this.serverSocketChannel.socket().getLocalPort());\n            log.info(\"OS picked up {} to listen for HA\", messageStoreConfig.getHaListenPort());\n        }\n        this.serverSocketChannel.configureBlocking(false);\n        this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void shutdown(final boolean interrupt) {\n        super.shutdown(interrupt);\n        try {\n            if (null != this.serverSocketChannel) {\n                this.serverSocketChannel.close();\n            }\n            if (null != this.selector) {\n                this.selector.close();\n            }\n        } catch (IOException e) {\n            log.error(\"AcceptSocketService shutdown exception\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(this.getServiceName() + \" service started\");\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                Set<SelectionKey> selected = this.selector.selectedKeys();\n                if (selected != null) {\n                    for (SelectionKey k : selected) {\n                        if (k.isAcceptable()) {\n                            SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n                            if (sc != null) {\n                                log.info(\"HAService receive new connection, \" + sc.socket().getRemoteSocketAddress());\n                                try {\n                                    HAConnection conn = createConnection(sc);\n                                    conn.start();\n                                } catch (Exception e) {\n                                    log.error(\"new HAConnection exception\", e);\n                                    sc.close();\n                                }\n                            }\n                        } else {\n                            log.warn(\"Unexpected ops in select \" + k.readyOps());\n                        }\n                    }\n                    selected.clear();\n                }\n            } catch (Exception e) {\n                log.error(this.getServiceName() + \" service has exception.\", e);\n            }\n        }\n        log.info(this.getServiceName() + \" service end\");\n    }\n\n    protected abstract HAConnection createConnection(final SocketChannel sc) throws IOException;\n}",
  "FSMID_for_test": 21,
  "Code_level": "Class-level"
}