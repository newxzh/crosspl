{
  "Task_id": 265,
  "Github_ID": "272493701",
  "Github_Project_Name": "learning-note",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "NIO HTTP Server in Java",
  "Instruction": "Task Description: Implement a Java NIO HTTP server that handles client connections asynchronously, processes incoming requests, and sends responses back to clients. The server should use non-blocking I/O operations managed by a Selector to efficiently handle multiple connections.\n\nClass Description: NioHttpServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) capabilities. It manages client connections, reads incoming requests, and writes responses asynchronously. The server can also make HTTP requests to external services (like Baidu in the example) to fetch response data.\n\nAttributes:\n- charset: [Charset] - The character set used for encoding/decoding text data (UTF-8 in this case)\n- client: [HttpClient] - Apache HttpClient instance used to make external HTTP requests\n\nMethods:\n- startServer: [startServer(int port)] -> [void] - Starts the HTTP server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop to handle client connections\n- handleAccept: [handleAccept(SelectionKey key, Selector selector)] -> [void] - Handles new client connections by accepting the SocketChannel and registering it with the selector for write operations\n- handleRead: [handleRead(SelectionKey key, Selector selector)] -> [void] - Handles incoming data from clients by reading from the SocketChannel and preparing for write operations\n- handleWrite: [handleWrite(SelectionKey key, Selector selector)] -> [void] - Handles writing data to clients by sending responses through the SocketChannel and preparing for read operations\n- executeResponse: [executeResponse()] -> [String] - Makes an HTTP GET request to an external service (Baidu in the example) and returns the response body as a string",
  "Canonical_solution": "import org.apache.commons.codec.Charsets;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private static Charset charset = Charset.forName(\"UTF8\");\n    private HttpClient client = HttpClientBuilder.create().build();\n\n    public void startServer(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while (true) {\n            if (selector.select(1) > 0) {\n                Set<SelectionKey> set = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = set.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    if (key.isAcceptable()) {\n                        handleAccept(key, selector);\n                    } else if (key.isReadable()) {\n                        handleRead(key, selector);\n                    } else if (key.isWritable()) {\n                        handleWrite(key, selector);\n                    }\n                    keyIterator.remove();\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n        selector.wakeup();\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String data = executeResponse().substring(0, 100);\n        byteBuffer.put(data.getBytes());\n        clientChannel.write(byteBuffer);\n        key.interestOps(SelectionKey.OP_READ);\n        selector.wakeup();\n    }\n\n    private String executeResponse() throws IOException {\n        String data = \"\";\n        HttpGet get = new HttpGet(\"http://www.baidu.com\");\n        HttpResponse response = client.execute(get);\n        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            data = EntityUtils.toString(response.getEntity(), Charsets.UTF_8);\n        }\n        return data;\n    }\n}",
  "FSMID_for_test": 21,
  "Code_level": "Class-level"
}