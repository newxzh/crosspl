{
  "Task_id": 397,
  "Github_ID": "41334365",
  "Github_Project_Name": "sdrtrunk",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "TCP Client based on Apache MINA in java",
  "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
  "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
  "FSMID_for_test": 10,
  "Code_level": "Class-level"
}