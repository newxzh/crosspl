{
  "Task_id": 208,
  "Github_ID": "167204613",
  "Github_Project_Name": "im-server",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Server",
  "Instruction": "Task Description: Implement a Java class that creates a TCP server using Netty framework to handle HTTP file server functionality, including starting the server, configuring network options, and properly shutting down resources.\n\nClass Description: LoFileServer is a Netty-based HTTP file server that listens on a specified port, handles incoming HTTP requests, and manages server lifecycle operations. It uses Netty's non-blocking I/O model for high performance and includes proper resource cleanup.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The Netty channel representing the server's listening socket\nLogger: Logger - SLF4J logger instance for logging server events\n\nMethods:\nstart(): void - Starts the Netty server on the specified port. Configures thread groups, channel options, and HTTP pipeline handlers. Throws InterruptedException if the port is already in use or if startup fails.\nshutdown(): void - Gracefully shuts down the server by closing the channel and releasing all associated resources. Handles any interruption during shutdown.",
  "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoFileServer {\n    private static final Logger Logger = LoggerFactory.getLogger(LoFileServer.class);\n    private int port;\n    private Channel channel;\n\n    public LoFileServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        final EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_SNDBUF, 1024*1024*10)\n                .option(ChannelOption.SO_RCVBUF, 1024*1024*10)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                        socketChannel.pipeline().addLast(new HttpFileServerHandler());\n                    }\n                });\n            \n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port [{}]\", port);\n        } catch (Exception e) {\n            Logger.error(\"Port {} is already in use\", port);\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (this.channel != null) {\n            this.channel.close();\n            try {\n                this.channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown\", e);\n            }\n        }\n    }\n}",
  "FSMID_for_test": 4,
  "Code_level": "Class-level"
}