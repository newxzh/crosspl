{
  "Task_id": 249,
  "Github_ID": "739401585",
  "Github_Project_Name": "xiaoya-alist",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java RESTful API HTTP Client",
  "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
  "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
  "FSMID_for_test": 22,
  "Code_level": "Class-level"
}