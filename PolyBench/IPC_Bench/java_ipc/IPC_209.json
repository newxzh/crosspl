{
  "Task_id": 209,
  "Github_ID": "56679521",
  "Github_Project_Name": "motan",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Java Netty TCP Server",
  "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable message handler, and managing server resources efficiently.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that extends AbstractServer. It manages server lifecycle (opening/closing), handles incoming connections with configurable thread pools, and processes messages through a provided message handler. The server supports connection management, configurable worker threads, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection events\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- serverChannel: [Channel] - Represents the server's listening channel\n- messageHandler: [MessageHandler] - Processes incoming requests\n- standardThreadExecutor: [StandardThreadExecutor] - Manages worker threads for request processing\n- rejectCounter: [AtomicInteger] - Tracks rejected requests count\n- channelManage: [NettyServerChannelManage] - Manages active connections\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools, binds to port, and sets up channel pipeline. Returns true if successful.\n- close() -> [void] - Shuts down the server gracefully, releasing all resources including thread pools and channels.\n- isBound() -> [boolean] - Checks if server is actively listening for connections.\n- request(Request) -> [Response] - Throws MotanFrameworkException as server doesn't support direct requests (inherited from AbstractServer).\n\nInput:\n- URL url: Configuration parameters for server setup (port, thread counts, queue sizes etc.)\n- MessageHandler messageHandler: Handler for processing incoming messages\n\nOutput:\n- When open() succeeds: Server starts listening on specified port and returns true\n- When close() completes: All server resources are released and state set to CLOSE\n- isBound(): Returns current server binding status",
  "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.MessageHandler;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private StandardThreadExecutor standardThreadExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n    private NettyServerChannelManage channelManage;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            LoggerUtil.warn(\"NettyServer ServerChannel already Open: url=\" + url);\n            return state.isAliveState();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        LoggerUtil.info(\"NettyServer ServerChannel start Open: url=\" + url);\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        int maxServerConnection = url.getIntParameter(URLParamType.maxServerConnection.getName(), URLParamType.maxServerConnection.getIntValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.getIntValue());\n\n        int minWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER) :\n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n        int maxWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER) :\n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n\n        standardThreadExecutor = new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, \n            new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnection);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\"channel_manage\", channelManage);\n                    pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                    pipeline.addLast(\"encoder\", new NettyEncoder());\n                    pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, standardThreadExecutor));\n                }\n            });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        setLocalAddress((InetSocketAddress) serverChannel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n\n        state = ChannelState.ALIVE;\n        LoggerUtil.info(\"NettyServer ServerChannel finish Open: url=\" + url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close() {\n        if (state.isCloseState()) {\n            return;\n        }\n\n        try {\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n                bossGroup = null;\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n                workerGroup = null;\n            }\n            if (channelManage != null) {\n                channelManage.close();\n            }\n            if (standardThreadExecutor != null) {\n                standardThreadExecutor.shutdownNow();\n            }\n\n            state = ChannelState.CLOSE;\n            LoggerUtil.info(\"NettyServer close Success: url={}\", url.getUri());\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyServer close Error: url=\" + url.getUri(), e);\n        }\n    }\n\n    @Override\n    public boolean isBound() {\n        return serverChannel != null && serverChannel.isActive();\n    }\n\n    @Override\n    public Response request(Request request) throws TransportException {\n        throw new MotanFrameworkException(\"NettyServer request(Request request) method not support: url: \" + url);\n    }\n}",
  "FSMID_for_test": 4,
  "Code_level": "Class-level"
}