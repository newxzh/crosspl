{
  "Task_id": 439,
  "Github_ID": "30628859",
  "Github_Project_Name": "netty-4-user-guide-demos",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "TCP Server-side based on java.nio",
  "Instruction": "Task Description: Implement a non-blocking TCP echo server using Java NIO (New I/O) that can handle multiple client connections simultaneously. The server should echo back any data received from clients.\n\nClass Description: NonBlokingEchoServer is a Java NIO-based server implementation that uses non-blocking I/O operations to handle multiple client connections efficiently through a single thread. It utilizes Selector, ServerSocketChannel, and SocketChannel for managing connections and ByteBuffer for data operations.\n\nAttributes:\n- serverChannel: [ServerSocketChannel] - The main server channel that listens for incoming connections\n- selector: [Selector] - The multiplexor that monitors registered channels for I/O events\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- NonBlokingEchoServer(int port) -> [void] - Constructor that initializes the server with the specified port\n- start() -> [void] - Starts the server, binds to the port, and begins accepting client connections\n- handleKey(SelectionKey key) -> [void] - Handles different types of I/O events (accept, read, write)\n- handleAccept(SelectionKey key) -> [void] - Processes new client connection requests\n- handleRead(SelectionKey key) -> [void] - Reads data from connected clients\n- handleWrite(SelectionKey key) -> [void] - Writes data back to connected clients\n- close() -> [void] - Closes the server channel and selector, releasing all resources",
  "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NonBlokingEchoServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private int port;\n\n    public NonBlokingEchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        InetSocketAddress address = new InetSocketAddress(port);\n        serverChannel.bind(address);\n        serverChannel.configureBlocking(false);\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"NonBlokingEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n\n        while (true) {\n            try {\n                selector.select();\n            } catch (IOException e) {\n                System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + e.getMessage());\n            }\n            Set<SelectionKey> readyKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = readyKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                try {\n                    handleKey(key);\n                } catch (IOException ex) {\n                    key.cancel();\n                    try {\n                        key.channel().close();\n                    } catch (IOException cex) {\n                        System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + cex.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private void handleKey(SelectionKey key) throws IOException {\n        if (key.isAcceptable()) {\n            handleAccept(key);\n        } else if (key.isReadable()) {\n            handleRead(key);\n        } else if (key.isWritable()) {\n            handleWrite(key);\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = server.accept();\n        System.out.println(\"NonBlokingEchoServer\u63a5\u53d7\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\uff1a\" + socketChannel);\n        socketChannel.configureBlocking(false);\n        SelectionKey clientKey = socketChannel.register(selector,\n                SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n        ByteBuffer buffer = ByteBuffer.allocate(100);\n        clientKey.attach(buffer);\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        client.read(output);\n        System.out.println(client.getRemoteAddress() \n                + \" -> NonBlokingEchoServer\uff1a\" + output.toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        output.flip();\n        client.write(output);\n        System.out.println(\"NonBlokingEchoServer  -> \" \n                + client.getRemoteAddress() + \"\uff1a\" + output.toString());\n        output.compact();\n        key.interestOps(SelectionKey.OP_READ);\n    }\n\n    public void close() throws IOException {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
  "FSMID_for_test": 7,
  "Code_level": "Class-level"
}