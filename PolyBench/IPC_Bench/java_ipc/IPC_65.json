{
  "Task_id": 65,
  "Github_ID": "87874521",
  "Github_Project_Name": "DKVideoPlayer",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "Http client-side based on Java.io & HttpURLConnection",
  "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
  "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
  "FSMID_for_test": 16,
  "Code_level": "Class-level"
}