{
  "Task_id": 518,
  "Github_ID": "1059430",
  "Github_Project_Name": "JGroups",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net ServerSocket",
  "Instruction": "Task Description: Create a Java class that implements a TCP server for unicast communication, handling client connections and data exchange with configurable parameters for testing purposes.\n\nClass Description: UnicastTestTcpRpc is a TCP server implementation that listens for incoming client connections, processes requests, and manages data transmission with configurable buffer sizes and communication modes (synchronous/asynchronous).\n\nAttributes:\n- srv_sock: [ServerSocket] - The server socket listening for incoming connections\n- sock: [Socket] - The active client connection socket\n- sock_in: [DataInputStream] - Input stream for reading data from the client\n- sock_out: [DataOutputStream] - Output stream for writing data to the client\n\nMethods:\n- init(long, boolean, boolean, boolean, boolean, String, int, int) -> [void] - Initializes the server with configuration parameters and starts the acceptor thread\n  Parameters:\n    - sleep_time: [long] - Sleep time between operations\n    - exit_on_end: [boolean] - Whether to exit after processing\n    - busy_sleep: [boolean] - Use busy waiting instead of sleep\n    - sync: [boolean] - Use synchronous communication\n    - oob: [boolean] - Use out-of-band data\n    - addr: [String] - Address to connect to\n    - local_port: [int] - Local port to listen on\n    - dest_port: [int] - Destination port for connections\n\n- createSocket() -> [void] - Creates a new client socket connection if none exists\n- handleRequest(DataInputStream, DataOutputStream) -> [boolean] - Processes incoming client requests\n  Parameters:\n    - in: [DataInputStream] - Input stream from client\n    - out: [DataOutputStream] - Output stream to client\n  Returns: [boolean] - Whether to continue processing requests\n\n- set(Socket) -> [void] - Configures socket parameters (TCP_NODELAY, buffer sizes)\n  Parameters:\n    - socket: [Socket] - Socket to configure\n\n- stop() -> [void] - Closes all open sockets and releases resources\n- startTest(int) -> [void] - Starts the test with given parameters\n  Parameters:\n    - num: [int] - Test parameter\n\n- receiveData(long, byte[]) -> [void] - Handles received data from client\n  Parameters:\n    - val: [long] - Timestamp or identifier\n    - data: [byte[]] - Received data payload",
  "Canonical_solution": "import java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private volatile Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    static final byte START         =  0;\n    static final byte RECEIVE_ASYNC =  1;\n    static final byte RECEIVE_SYNC  =  2;\n    static final byte ACK           = 10;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob,\n                     String addr, int local_port, int dest_port) throws Exception {\n        this.srv_sock = new ServerSocket(local_port);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        \n        Thread acceptor = new Thread(() -> {\n            while(true) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                DataOutputStream out = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    set(client_sock);\n                    in = new DataInputStream(client_sock.getInputStream());\n                    out = new DataOutputStream(client_sock.getOutputStream());\n                    if(!handleRequest(in, out)) {\n                        Util.close(client_sock);\n                        Util.close(out);\n                        Util.close(in);\n                        break;\n                    }\n                }\n                catch(IOException e) {\n                    Util.close(client_sock);\n                    Util.close(out);\n                    Util.close(in);\n                    break;\n                }\n            }\n        });\n        acceptor.start();\n    }\n\n    void createSocket() throws IOException {\n        if(sock == null) {\n            sock = new Socket(InetAddress.getByName(null), 9000);\n            set(sock);\n            sock_in = new DataInputStream(sock.getInputStream());\n            sock_out = new DataOutputStream(sock.getOutputStream());\n        }\n    }\n\n    boolean handleRequest(DataInputStream in, DataOutputStream out) throws IOException {\n        while(true) {\n            byte type = (byte)in.read();\n            if(type == -1)\n                return false;\n\n            switch(type) {\n                case START:\n                    int num = in.readInt();\n                    startTest(num);\n                    break;\n                case RECEIVE_ASYNC:\n                case RECEIVE_SYNC:\n                    long val = in.readLong();\n                    int len = in.readInt();\n                    byte[] data = new byte[len];\n                    in.readFully(data, 0, data.length);\n                    receiveData(val, data);\n                    if(type == RECEIVE_SYNC) {\n                        out.writeLong(System.currentTimeMillis());\n                        out.flush();\n                    }\n                    break;\n                default:\n                    System.err.println(\"type \" + type + \" not known\");\n            }\n        }\n    }\n\n    static void set(Socket socket) throws SocketException {\n        socket.setTcpNoDelay(true);\n        socket.setReceiveBufferSize(20000000);\n        socket.setSendBufferSize(10000000);\n    }\n\n    void stop() {\n        Util.close(sock);\n        Util.close(srv_sock);\n    }\n}",
  "FSMID_for_test": 0,
  "Code_level": "Class-level"
}