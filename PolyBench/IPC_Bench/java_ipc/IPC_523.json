{
  "Task_id": 523,
  "Github_ID": "1059430",
  "Github_Project_Name": "JGroups",
  "Programming_Language": "Java",
  "suffix": ".java",
  "Interface_class": "IPC",
  "Interface_name": "java.net ServerSocket",
  "Instruction": "Task Description: Implement a TCP transport class that can function as either a server or client, handling network communication with configurable buffer sizes and TCP_NODELAY option.\n\nClass Description: TcpTransport is a class that provides TCP-based communication capabilities, acting as either a server (accepting connections) or client (initiating connections). It manages socket creation, stream handling, and includes a dedicated receiver thread for asynchronous data reception.\n\nAttributes:\n- srv_sock: [ServerSocket] - Server socket instance for accepting connections (server mode)\n- sock: [Socket] - Socket instance for communication (both modes)\n- output: [OutputStream] - Output stream for sending data\n- input: [InputStream] - Input stream for receiving data\n- receiver_thread: [Receiver] - Thread for handling incoming data\n- receiver: [RtReceiver] - Callback handler for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- out_buf_size: [int] - Output buffer size (default: 8192)\n- in_buf_size: [int] - Input buffer size (default: 8192)\n- server: [boolean] - Flag indicating server mode\n- tcp_nodelay: [boolean] - TCP_NODELAY socket option flag\n- log: [Log] - Logger instance\n\nMethods:\n- start: [void](String... options) -> [void] - Initializes the transport in either server or client mode, creates sockets and streams, starts receiver thread\n- stop: [void]() -> [void] - Closes all resources (sockets and streams)\n- send: [void](byte[] buf, int offset, int length) -> [void] - Sends data through the output stream\n- Receiver (inner class): [void](InputStream in) -> [void] - Thread class that continuously reads incoming data and notifies receiver callback",
  "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpTransport {\n    protected ServerSocket srv_sock;\n    protected Socket sock;\n    protected OutputStream output;\n    protected InputStream input;\n    protected Receiver receiver_thread;\n    protected RtReceiver receiver;\n    protected InetAddress host;\n    protected int port=7800;\n    protected int out_buf_size=8192, in_buf_size=8192;\n    protected boolean server, tcp_nodelay;\n    protected final Log log=LogFactory.getLog(TcpTransport.class);\n\n    public void start(String ... options) throws Exception {\n        if(server) {\n            srv_sock=new ServerSocket(port, 50, host);\n            Socket s=srv_sock.accept();\n            s.setTcpNoDelay(tcp_nodelay);\n            input=in_buf_size > 0? new BufferedInputStream(s.getInputStream(), in_buf_size) : s.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(s.getOutputStream(), out_buf_size) : s.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n        else {\n            sock=new Socket();\n            sock.setTcpNoDelay(tcp_nodelay);\n            sock.connect(new InetSocketAddress(host, port));\n            input=in_buf_size > 0? new BufferedInputStream(sock.getInputStream(), in_buf_size) : sock.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(sock.getOutputStream(), out_buf_size) : sock.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(sock, srv_sock, input, output);\n    }\n\n    public void send(byte[] buf, int offset, int length) throws Exception {\n        output.write(buf, offset, length);\n        output.flush();\n    }\n\n    protected class Receiver extends Thread {\n        protected final InputStream in;\n\n        public Receiver(InputStream in) {\n            this.in=in;\n        }\n\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            for(;;) {\n                try {\n                    int num=in.read(buf, 0, buf.length);\n                    if(num == -1)\n                        return;\n                    if(num != buf.length)\n                        throw new IllegalStateException(\"expected \" + buf.length + \" bytes, but got only \" + num);\n                    if(receiver != null)\n                        receiver.receive(null, buf, 0, buf.length);\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
  "FSMID_for_test": 0,
  "Code_level": "Class-level"
}