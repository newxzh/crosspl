{
  "Task_id": 128,
  "Github_ID": "34716238",
  "Github_Project_Name": "faveo-helpdesk",
  "Programming_Language": "PHP",
  "suffix": ".php",
  "Interface_class": "IPC",
  "Interface_name": "TCP client based on socket_* in PHP",
  "Instruction": "Task Description: Create a PHP class that implements a Redis client connection using TCP sockets and the phpiredis extension for efficient communication with a Redis server.\n\nClass Description: PhpiredisSocketConnection is a Redis client connection class that handles TCP socket communication with a Redis server. It manages socket creation, connection, data transmission, and response parsing using the phpiredis extension for optimal performance.\n\nAttributes:\n- reader: [resource] - The phpiredis reader resource used for parsing Redis protocol responses\n- parameters: [ParametersInterface] - Connection parameters including host, port, timeout, etc.\n\nMethods:\n- __construct(ParametersInterface $parameters) -> [void] - Initializes the connection and verifies required extensions\n- __destruct() -> [void] - Cleans up resources when the object is destroyed\n- assertExtensions() -> [void] - Verifies required PHP extensions are loaded\n- createReader() -> [resource] - Creates and configures a phpiredis reader resource\n- getStatusHandler() -> [callable] - Returns the handler for status responses\n- getErrorHandler() -> [callable] - Returns the handler for error responses\n- createResource() -> [resource] - Creates and connects the socket resource\n- connectWithTimeout(resource $socket, string $address, ParametersInterface $parameters) -> [void] - Establishes connection with timeout handling\n- write(string $buffer) -> [void] - Writes data to the socket connection\n- read() -> [mixed] - Reads and parses response from the server\n- writeRequest(CommandInterface $command) -> [void] - Formats and writes a Redis command to the server",
  "Canonical_solution": "use Predis\\Command\\CommandInterface;\nuse Predis\\NotSupportedException;\nuse Predis\\Response\\Error as ErrorResponse;\nuse Predis\\Response\\ErrorInterface as ErrorResponseInterface;\nuse Predis\\Response\\Status as StatusResponse;\n\nclass PhpiredisSocketConnection extends AbstractConnection\n{\n    private $reader;\n\n    public function __construct(ParametersInterface $parameters)\n    {\n        $this->assertExtensions();\n        parent::__construct($parameters);\n        $this->reader = $this->createReader();\n    }\n\n    public function __destruct()\n    {\n        parent::__destruct();\n        phpiredis_reader_destroy($this->reader);\n    }\n\n    protected function assertExtensions()\n    {\n        if (!extension_loaded('sockets')) {\n            throw new NotSupportedException(\n                'The \"sockets\" extension is required by this connection backend.'\n            );\n        }\n\n        if (!extension_loaded('phpiredis')) {\n            throw new NotSupportedException(\n                'The \"phpiredis\" extension is required by this connection backend.'\n            );\n        }\n    }\n\n    private function createReader()\n    {\n        $reader = phpiredis_reader_create();\n        phpiredis_reader_set_status_handler($reader, $this->getStatusHandler());\n        phpiredis_reader_set_error_handler($reader, $this->getErrorHandler());\n        return $reader;\n    }\n\n    protected function getStatusHandler()\n    {\n        static $statusHandler;\n\n        if (!$statusHandler) {\n            $statusHandler = function ($payload) {\n                return StatusResponse::get($payload);\n            };\n        }\n\n        return $statusHandler;\n    }\n\n    protected function getErrorHandler()\n    {\n        static $errorHandler;\n\n        if (!$errorHandler) {\n            $errorHandler = function ($errorMessage) {\n                return new ErrorResponse($errorMessage);\n            };\n        }\n\n        return $errorHandler;\n    }\n\n    protected function createResource()\n    {\n        $parameters = $this->parameters;\n\n        if ($parameters->scheme === 'unix') {\n            $address = $parameters->path;\n            $domain = AF_UNIX;\n            $protocol = 0;\n        } else {\n            if (false === $address = self::getAddress($parameters)) {\n                $this->onConnectionError(\"Cannot resolve the address of '$parameters->host'.\");\n            }\n\n            $domain = filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;\n            $protocol = SOL_TCP;\n        }\n\n        if (false === $socket = @socket_create($domain, SOCK_STREAM, $protocol)) {\n            $this->emitSocketError();\n        }\n\n        $this->setSocketOptions($socket, $parameters);\n        $this->connectWithTimeout($socket, $address, $parameters);\n\n        return $socket;\n    }\n\n    private function connectWithTimeout($socket, $address, ParametersInterface $parameters)\n    {\n        socket_set_nonblock($socket);\n\n        if (@socket_connect($socket, $address, (int) $parameters->port) === false) {\n            $error = socket_last_error();\n            if ($error != SOCKET_EINPROGRESS && $error != SOCKET_EALREADY) {\n                $this->emitSocketError();\n            }\n        }\n\n        socket_set_block($socket);\n\n        $null = null;\n        $selectable = array($socket);\n\n        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);\n        $timeoutSecs = floor($timeout);\n        $timeoutUSecs = ($timeout - $timeoutSecs) * 1000000;\n\n        $selected = socket_select($selectable, $selectable, $null, $timeoutSecs, $timeoutUSecs);\n\n        if ($selected === 2) {\n            $this->onConnectionError('Connection refused.', SOCKET_ECONNREFUSED);\n        }\n\n        if ($selected === 0) {\n            $this->onConnectionError('Connection timed out.', SOCKET_ETIMEDOUT);\n        }\n\n        if ($selected === false) {\n            $this->emitSocketError();\n        }\n    }\n\n    protected function write($buffer)\n    {\n        $socket = $this->getResource();\n\n        while (($length = strlen($buffer)) > 0) {\n            $written = socket_write($socket, $buffer, $length);\n\n            if ($length === $written) {\n                return;\n            }\n\n            if ($written === false) {\n                $this->onConnectionError('Error while writing bytes to the server.');\n            }\n\n            $buffer = substr($buffer, $written);\n        }\n    }\n\n    public function read()\n    {\n        $socket = $this->getResource();\n        $reader = $this->reader;\n\n        while (PHPIREDIS_READER_STATE_INCOMPLETE === $state = phpiredis_reader_get_state($reader)) {\n            if (@socket_recv($socket, $buffer, 4096, 0) === false || $buffer === '' || $buffer === null) {\n                $this->emitSocketError();\n            }\n\n            phpiredis_reader_feed($reader, $buffer);\n        }\n\n        if ($state === PHPIREDIS_READER_STATE_COMPLETE) {\n            return phpiredis_reader_get_reply($reader);\n        } else {\n            $this->onProtocolError(phpiredis_reader_get_error($reader));\n            return;\n        }\n    }\n\n    public function writeRequest(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        array_unshift($arguments, $command->getId());\n        $this->write(phpiredis_format_command($arguments));\n    }\n}",
  "FSMID_for_test": 137,
  "Code_level": "Class-level"
}