{
  "Task_id": 61,
  "Github_ID": "40277672",
  "Github_Project_Name": "phpspider",
  "Programming_Language": "PHP",
  "suffix": ".php",
  "Interface_class": "IPC",
  "Interface_name": "HTTP client using cURL in PHP",
  "Instruction": "Task Description: Create a PHP class that provides HTTP client functionality using cURL, supporting various HTTP methods, headers, cookies, proxies, and file uploads.\n\nClass Description: The `requests` class is a static HTTP client implementation that handles HTTP requests through cURL. It supports GET, POST, and other HTTP methods, manages cookies, headers, user agents, proxies, and file uploads. The class maintains connection settings and request history.\n\nAttributes:\n\nVERSION: [string] - The version number of the requests class\nch: [resource|null] - The cURL handle resource\ntimeout: [int|array] - Timeout settings for the connection\nencoding: [string|null] - Request encoding\noutput_encoding: [string|null] - Response encoding\ncookies: [array] - Global cookies to be sent with requests\nrawheaders: [array] - Request headers\ndomain_cookies: [array] - Domain-specific cookies\nheaders: [array] - Response headers\nuseragents: [array] - List of user agent strings\nclient_ips: [array] - List of client IP addresses for spoofing\nproxies: [array] - List of proxy servers\nraw: [string] - Raw response including headers\nhead: [string] - Response headers\ncontent: [string] - Response body\ntext: [string] - Processed response text\ninfo: [array] - cURL request information\nhistory: [int] - HTTP redirect history status code\nstatus_code: [int] - HTTP response status code\nerror: [string] - Error message if request fails\n\nMethods:\n\ninit(): [void] -> [resource] - Initializes the cURL session with default settings\nrequest($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL) -> [string|bool] - Executes an HTTP request to the specified URL with given parameters\n_is_url($url) -> [bool] - Validates if the input string is a valid URL\nget_cookies($domain = '') -> [array] - Retrieves cookies for a specific domain\nget_response_headers($header) -> [array] - Parses response headers\nget_response_cookies($header, $domain) -> [void] - Extracts cookies from response headers\nsplit_header_body() -> [array] - Splits response into headers and body\nget_history($header) -> [int] - Gets redirect history from response headers\nget_mimetype($filepath) -> [string] - Gets MIME type of a file",
  "Canonical_solution": "namespace phpspider\\core;\n\nclass requests\n{\n    const VERSION = '2.0.1';\n    protected static $ch = null;\n\n    public static $timeout = 15;\n    public static $encoding = null;\n    public static $output_encoding = null;\n    public static $cookies = array();\n    public static $rawheaders = array();\n    public static $domain_cookies = array();\n    public static $headers = array();\n    public static $useragents = array(\"requests/2.0.0\");\n    public static $client_ips = array();\n    public static $proxies = array();\n    public static $raw = \"\";\n    public static $head = \"\";\n    public static $content = \"\";\n    public static $text = \"\";\n    public static $info = array();\n    public static $history = 302;\n    public static $status_code = 0;\n    public static $error = \"\";\n\n    public static function init()\n    {\n        if (!is_resource(self::$ch))\n        {\n            self::$ch = curl_init();\n            curl_setopt(self::$ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt(self::$ch, CURLOPT_HEADER, false);\n            curl_setopt(self::$ch, CURLOPT_USERAGENT, \"phpspider-requests/\".self::VERSION);\n            if (is_array(self::$timeout))\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, self::$timeout[0]);\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout[1]);\n            }\n            else\n            {\n                curl_setopt(self::$ch, CURLOPT_CONNECTTIMEOUT, ceil(self::$timeout / 2));\n                curl_setopt(self::$ch, CURLOPT_TIMEOUT, self::$timeout);\n            }\n            curl_setopt(self::$ch, CURLOPT_MAXREDIRS, 5);\n            curl_setopt(self::$ch, CURLOPT_NOSIGNAL, true);\n        }\n        return self::$ch;\n    }\n\n    public static function request($url, $method = 'GET', $fields = array(), $files = array(), $allow_redirects = true, $cert = NULL)\n    {\n        $method = strtoupper($method);\n        if(!self::_is_url($url))\n        {\n            self::$error = \"You have requested URL ({$url}) is not a valid HTTP address\";\n            return false;\n        }\n\n        if ($method == 'GET' && !empty($fields))\n        {\n            $url = $url.(strpos($url, '?') === false ? '?' : '&').http_build_query($fields);\n        }\n\n        $parse_url = parse_url($url);\n        if (empty($parse_url) || empty($parse_url['host']) || !in_array($parse_url['scheme'], array('http', 'https')))\n        {\n            self::$error = \"No connection adapters were found for '{$url}'\";\n            return false;\n        }\n\n        curl_setopt(self::$ch, CURLOPT_URL, $url);\n\n        if ($method != 'GET')\n        {\n            if ($method == 'POST')\n            {\n                $tmpheaders = array_change_key_case(self::$rawheaders, CASE_LOWER);\n                if (isset($tmpheaders['content-type']) && $tmpheaders['content-type'] == 'application/json')\n                {\n                    curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n                }\n                else\n                {\n                    curl_setopt(self::$ch, CURLOPT_POST, true);\n                }\n\n                $file_fields = array();\n                if (!empty($files))\n                {\n                    foreach ($files as $postname => $file)\n                    {\n                        $filepath = realpath($file);\n                        if (!file_exists($filepath))\n                        {\n                            continue;\n                        }\n                        $filename = basename($filepath);\n                        $type = self::get_mimetype($filepath);\n                        $file_fields[$postname] = curl_file_create($filepath, $type, $filename);\n                    }\n                }\n\n                if (empty($file_fields))\n                {\n                    if (is_array($fields))\n                    {\n                        $fields = http_build_query($fields);\n                    }\n                }\n                else\n                {\n                    if (is_array($fields) && !empty($fields))\n                    {\n                        $fields = array_merge($fields, $file_fields);\n                    }\n                    else\n                    {\n                        $fields = $file_fields;\n                    }\n                }\n                curl_setopt(self::$ch, CURLOPT_POSTFIELDS, $fields);\n            }\n            else\n            {\n                self::$rawheaders['X-HTTP-Method-Override'] = $method;\n                curl_setopt(self::$ch, CURLOPT_CUSTOMREQUEST, $method);\n            }\n        }\n\n        $cookies = self::get_cookies();\n        $domain_cookies = self::get_cookies($parse_url['host']);\n        $cookies = array_merge($cookies, $domain_cookies);\n        if (!empty($cookies))\n        {\n            foreach ($cookies as $key=>$value)\n            {\n                $cookie_arr[] = $key.'='.$value;\n            }\n            $cookies = implode('; ', $cookie_arr);\n            curl_setopt(self::$ch, CURLOPT_COOKIE, $cookies);\n        }\n\n        if (!empty(self::$useragents))\n        {\n            $key = rand(0, count(self::$useragents) - 1);\n            self::$rawheaders['User-Agent'] = self::$useragents[$key];\n        }\n\n        if (!empty(self::$client_ips))\n        {\n            $key = rand(0, count(self::$client_ips) - 1);\n            self::$rawheaders['CLIENT-IP'] = self::$client_ips[$key];\n            self::$rawheaders['X-FORWARDED-FOR'] = self::$client_ips[$key];\n        }\n\n        if (self::$rawheaders)\n        {\n            $http_headers = array();\n            foreach (self::$rawheaders as $k=>$v)\n            {\n                $http_headers[] = $k.': '.$v;\n            }\n            curl_setopt(self::$ch, CURLOPT_HTTPHEADER, $http_headers);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_ENCODING, 'gzip');\n\n        if ($parse_url['scheme'] == 'https')\n        {\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYPEER, false);\n            curl_setopt(self::$ch, CURLOPT_SSL_VERIFYHOST, false);\n        }\n\n        if (self::$proxies)\n        {\n            $key = rand(0, count(self::$proxies) - 1);\n            $proxy = self::$proxies[$key];\n            curl_setopt(self::$ch, CURLOPT_PROXY, $proxy);\n        }\n\n        curl_setopt(self::$ch, CURLOPT_HEADER, true);\n        if ($allow_redirects)\n        {\n            curl_setopt(self::$ch, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        self::$raw = curl_exec(self::$ch);\n        self::$info = curl_getinfo(self::$ch);\n        self::$status_code = self::$info['http_code'];\n        if (self::$raw === false)\n        {\n            self::$error = 'Curl error: ' . curl_error(self::$ch);\n        }\n\n        curl_close(self::$ch);\n\n        list($header, $text) = self::split_header_body();\n        self::$history = self::get_history($header);\n        self::$headers = self::get_response_headers($header);\n        self::get_response_cookies($header, $parse_url['host']);\n        return $text;\n    }\n\n    private static function _is_url($url)\n    {\n        $pattern = \"/\\b(([\\w-]+:\\/\\/?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/)))/\";\n        return preg_match($pattern, $url) ? true : false;\n    }\n}",
  "FSMID_for_test": 132,
  "Code_level": "Class-level"
}