{
  "Task_id": 67,
  "Github_ID": "2536618",
  "Github_Project_Name": "thinkphp",
  "Programming_Language": "PHP",
  "suffix": ".php",
  "Interface_class": "IPC",
  "Interface_name": "HTTP client using cURL in PHP",
  "Instruction": "Task Description: Create a PHP class for handling HTTP requests using cURL with support for various HTTP methods, streaming, authentication, and proxy configuration.\n\nClass Description: The BcsRequestcore class provides a comprehensive wrapper around PHP's cURL functions to handle HTTP requests. It supports GET, POST, PUT, DELETE, and HEAD methods, with features for request customization, streaming uploads/downloads, authentication, and proxy support. The class manages the entire request lifecycle including preparation, execution, and response processing.\n\nAttributes:\n\nrequest_url: [string] - The URL to send the request to\nrequest_headers: [array] - Associative array of request headers\nrequest_body: [string] - The request body content\nresponse: [mixed] - The raw response from the server\nresponse_headers: [array] - Parsed response headers\nresponse_body: [string] - The response body content\nresponse_code: [int] - HTTP response status code\nresponse_info: [array] - Additional response information\ncurl_handle: [resource] - The cURL handle resource\nmethod: [string] - HTTP method (GET, POST, PUT, DELETE, HEAD)\nproxy: [array|null] - Proxy configuration details\nusername: [string|null] - Authentication username\npassword: [string|null] - Authentication password\ncurlopts: [array|null] - Additional cURL options\ndebug_mode: [bool] - Flag for debug mode\nrequest_class: [string] - Class name for request handling\nresponse_class: [string] - Class name for response handling\nuseragent: [string] - User agent string\nread_file: [string|null] - File path for streaming read\nread_stream: [resource|null] - Stream resource for reading\nread_stream_size: [int|null] - Size of read stream\nread_stream_read: [int] - Bytes read from stream\nwrite_file: [string|null] - File path for streaming write\nwrite_stream: [resource|null] - Stream resource for writing\nseek_position: [int|null] - Seek position for streams\nregistered_streaming_read_callback: [callable|null] - Callback for streaming read\nregistered_streaming_write_callback: [callable|null] - Callback for streaming write\n\nMethods:\n\n__construct([string|null $url], [array|null $proxy], [array|null $helpers]) -> [self] - Initializes the request object with optional URL, proxy, and helper classes\n__destruct() -> [self] - Cleans up any open file handles\nsetCredentials([string $user], [string $pass]) -> [self] - Sets basic authentication credentials\naddHeader([string $key], [string $value]) -> [self] - Adds a request header\nremoveHeader([string $key]) -> [self] - Removes a request header\nsetMethod([string $method]) -> [self] - Sets the HTTP method\nsetUseragent([string $ua]) -> [self] - Sets the user agent string\nsetBody([string $body]) -> [self] - Sets the request body\nsetRequestUrl([string $url]) -> [self] - Sets the request URL\nsetCurlopts([array $curlopts]) -> [self] - Sets additional cURL options\nsetReadStreamSize([int $size]) -> [self] - Sets the read stream size\nsetReadStream([resource $resource], [int|null $size]) -> [self] - Sets a stream resource for reading\nsetReadFile([string $location]) -> [self] - Sets a file for streaming read\nsetWriteStream([resource $resource]) -> [self] - Sets a stream resource for writing\nsetWriteFile([string $location]) -> [self] - Sets a file for streaming write\nsetProxy([string $proxy]) -> [self] - Configures proxy settings\nsetSeekPosition([int|null $position]) -> [self] - Sets the seek position for streams\nregisterStreamingReadCallback([callable $callback]) -> [self] - Registers a streaming read callback\nregisterStreamingWriteCallback([callable $callback]) -> [self] - Registers a streaming write callback\nprepRequest() -> [resource] - Prepares and returns a cURL handle with configured options\nsendRequest([bool $parse = false]) -> [mixed] - Executes the request and returns response\nprocessResponse([resource|null $curl_handle], [mixed|null $response]) -> [mixed] - Processes the response into headers and body\nisBaeEnv() -> [bool] - Checks if running in Baidu App Engine environment\ngetResponseHeader([string|null $header]) -> [mixed] - Gets specific or all response headers\ngetResponseBody() -> [string] - Gets the response body\ngetResponseCode() -> [int] - Gets the HTTP response code",
  "Canonical_solution": "use Think\\Upload\\Driver\\Bcs\\BCS_RequestCore_Exception as BCS_RequestCore_Exception;\n\nclass BcsRequestcore\n{\n    public $request_url;\n    public $request_headers;\n    public $request_body;\n    public $response;\n    public $response_headers;\n    public $response_body;\n    public $response_code;\n    public $response_info;\n    public $curl_handle;\n    public $method;\n    public $proxy = null;\n    public $username = null;\n    public $password = null;\n    public $curlopts = null;\n    public $debug_mode = false;\n    public $request_class = 'BCS_RequestCore';\n    public $response_class = 'BCS_ResponseCore';\n    public $useragent = 'BCS_RequestCore/1.4.2';\n    public $read_file = null;\n    public $read_stream = null;\n    public $read_stream_size = null;\n    public $read_stream_read = 0;\n    public $write_file = null;\n    public $write_stream = null;\n    public $seek_position = null;\n    public $registered_streaming_read_callback = null;\n    public $registered_streaming_write_callback = null;\n\n    const HTTP_GET = 'GET';\n    const HTTP_POST = 'POST';\n    const HTTP_PUT = 'PUT';\n    const HTTP_DELETE = 'DELETE';\n    const HTTP_HEAD = 'HEAD';\n\n    public function __construct($url = null, $proxy = null, $helpers = null)\n    {\n        $this->request_url = $url;\n        $this->method = self::HTTP_GET;\n        $this->request_headers = array();\n        $this->request_body = '';\n\n        if (isset($helpers['request']) && !empty($helpers['request'])) {\n            $this->request_class = $helpers['request'];\n        }\n\n        if (isset($helpers['response']) && !empty($helpers['response'])) {\n            $this->response_class = $helpers['response'];\n        }\n\n        if ($proxy) {\n            $this->setProxy($proxy);\n        }\n\n        return $this;\n    }\n\n    public function __destruct()\n    {\n        if (isset($this->read_file) && isset($this->read_stream)) {\n            fclose($this->read_stream);\n        }\n        if (isset($this->write_file) && isset($this->write_stream)) {\n            fclose($this->write_stream);\n        }\n        return $this;\n    }\n\n    public function setCredentials($user, $pass)\n    {\n        $this->username = $user;\n        $this->password = $pass;\n        return $this;\n    }\n\n    public function addHeader($key, $value)\n    {\n        $this->request_headers[$key] = $value;\n        return $this;\n    }\n\n    public function removeHeader($key)\n    {\n        if (isset($this->request_headers[$key])) {\n            unset($this->request_headers[$key]);\n        }\n        return $this;\n    }\n\n    public function setMethod($method)\n    {\n        $this->method = strtoupper($method);\n        return $this;\n    }\n\n    public function setUseragent($ua)\n    {\n        $this->useragent = $ua;\n        return $this;\n    }\n\n    public function setBody($body)\n    {\n        $this->request_body = $body;\n        return $this;\n    }\n\n    public function setRequestUrl($url)\n    {\n        $this->request_url = $url;\n        return $this;\n    }\n\n    public function setCurlopts($curlopts)\n    {\n        $this->curlopts = $curlopts;\n        return $this;\n    }\n\n    public function setReadStreamSize($size)\n    {\n        $this->read_stream_size = $size;\n        return $this;\n    }\n\n    public function setReadStream($resource, $size = null)\n    {\n        if (!isset($size) || $size < 0) {\n            $stats = fstat($resource);\n            if ($stats && $stats['size'] >= 0) {\n                $position = ftell($resource);\n                if (false !== $position && $position >= 0) {\n                    $size = $stats['size'] - $position;\n                }\n            }\n        }\n        $this->read_stream = $resource;\n        return $this->setReadStreamSize($size);\n    }\n\n    public function setReadFile($location)\n    {\n        $this->read_file = $location;\n        $read_file_handle = fopen($location, 'r');\n        return $this->setReadStream($read_file_handle);\n    }\n\n    public function setWriteStream($resource)\n    {\n        $this->write_stream = $resource;\n        return $this;\n    }\n\n    public function setWriteFile($location)\n    {\n        $this->write_file = $location;\n        $write_file_handle = fopen($location, 'w');\n        return $this->setWriteStream($write_file_handle);\n    }\n\n    public function setProxy($proxy)\n    {\n        $proxy = parse_url($proxy);\n        $proxy['user'] = isset($proxy['user']) ? $proxy['user'] : null;\n        $proxy['pass'] = isset($proxy['pass']) ? $proxy['pass'] : null;\n        $proxy['port'] = isset($proxy['port']) ? $proxy['port'] : null;\n        $this->proxy = $proxy;\n        return $this;\n    }\n\n    public function setSeekPosition($position)\n    {\n        $this->seek_position = isset($position) ? (integer) $position : null;\n        return $this;\n    }\n\n    public function registerStreamingReadCallback($callback)\n    {\n        $this->registered_streaming_read_callback = $callback;\n        return $this;\n    }\n\n    public function registerStreamingWriteCallback($callback)\n    {\n        $this->registered_streaming_write_callback = $callback;\n        return $this;\n    }\n\n    public function prepRequest()\n    {\n        $curl_handle = curl_init();\n        curl_setopt($curl_handle, CURLOPT_URL, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_FILETIME, true);\n        curl_setopt($curl_handle, CURLOPT_FRESH_CONNECT, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($curl_handle, CURLOPT_SSL_VERIFYHOST, true);\n        curl_setopt($curl_handle, CURLOPT_CLOSEPOLICY, CURLCLOSEPOLICY_LEAST_RECENTLY_USED);\n        curl_setopt($curl_handle, CURLOPT_MAXREDIRS, 5);\n        curl_setopt($curl_handle, CURLOPT_HEADER, true);\n        curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, true);\n        curl_setopt($curl_handle, CURLOPT_TIMEOUT, 5184000);\n        curl_setopt($curl_handle, CURLOPT_CONNECTTIMEOUT, 120);\n        curl_setopt($curl_handle, CURLOPT_NOSIGNAL, true);\n        curl_setopt($curl_handle, CURLOPT_REFERER, $this->request_url);\n        curl_setopt($curl_handle, CURLOPT_USERAGENT, $this->useragent);\n        curl_setopt($curl_handle, CURLOPT_READFUNCTION, array($this, 'streaming_read_callback'));\n\n        if ($this->debug_mode) {\n            curl_setopt($curl_handle, CURLOPT_VERBOSE, true);\n        }\n\n        if ($this->proxy) {\n            curl_setopt($curl_handle, CURLOPT_HTTPPROXYTUNNEL, true);\n            $host = $this->proxy['host'];\n            $host .= ($this->proxy['port']) ? ':' . $this->proxy['port'] : '';\n            curl_setopt($curl_handle, CURLOPT_PROXY, $host);\n            if (isset($this->proxy['user']) && isset($this->proxy['pass'])) {\n                curl_setopt($curl_handle, CURLOPT_PROXYUSERPWD, $this->proxy['user'] . ':' . $this->proxy['pass']);\n            }\n        }\n\n        if ($this->username && $this->password) {\n            curl_setopt($curl_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n            curl_setopt($curl_handle, CURLOPT_USERPWD, $this->username . ':' . $this->password);\n        }\n\n        if (extension_loaded('zlib')) {\n            curl_setopt($curl_handle, CURLOPT_ENCODING, '');\n        }\n\n        if (isset($this->request_headers) && count($this->request_headers)) {\n            $temp_headers = array();\n            foreach ($this->request_headers as $k => $v) {\n                $temp_headers[] = $k . ': ' . $v;\n            }\n            curl_setopt($curl_handle, CURLOPT_HTTPHEADER, $temp_headers);\n        }\n\n        switch ($this->method) {\n            case self::HTTP_PUT:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, 'PUT');\n                if (isset($this->read_stream)) {\n                    if (!isset($this->read_stream_size) || $this->read_stream_size < 0) {\n                        throw new BCS_RequestCore_Exception('The stream size for the streaming upload cannot be determined.');\n                    }\n                    curl_setopt($curl_handle, CURLOPT_INFILESIZE, $this->read_stream_size);\n                    curl_setopt($curl_handle, CURLOPT_UPLOAD, true);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n            case self::HTTP_POST:\n                curl_setopt($curl_handle, CURLOPT_POST, true);\n                curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                break;\n            case self::HTTP_HEAD:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, self::HTTP_HEAD);\n                curl_setopt($curl_handle, CURLOPT_NOBODY, 1);\n                break;\n            default:\n                curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, $this->method);\n                if (isset($this->write_stream)) {\n                    curl_setopt($curl_handle, CURLOPT_WRITEFUNCTION, array($this, 'streaming_write_callback'));\n                    curl_setopt($curl_handle, CURLOPT_HEADER, false);\n                } else {\n                    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $this->request_body);\n                }\n                break;\n        }\n\n        if (isset($this->curlopts) && sizeof($this->curlopts) > 0) {\n            foreach ($this->curlopts as $k => $v) {\n                curl_setopt($curl_handle, $k, $v);\n            }\n        }\n\n        return $curl_handle;\n    }\n\n    public function sendRequest($parse = false)\n    {\n        if (false === $this->isBaeEnv()) {\n            set_time_limit(0);\n        }\n\n        $curl_handle = $this->prepRequest();\n        $this->response = curl_exec($curl_handle);\n\n        if (false === $this->response ||\n            (self::HTTP_GET === $this->method &&\n                curl_errno($curl_handle) === CURLE_PARTIAL_FILE)) {\n            throw new BCS_RequestCore_Exception('cURL resource: ' . (string) $curl_handle . '; cURL error: ' . curl_error($curl_handle) . ' (' . curl_errno($curl_handle) . ')');\n        }\n\n        $parsed_response = $this->processResponse($curl_handle, $this->response);\n        curl_close($curl_handle);\n\n        if ($parse) {\n            return $parsed_response;\n        }\n\n        return $this->response;\n    }\n\n    public function processResponse($curl_handle = null, $response = null)\n    {\n        if ($curl_handle && $response) {\n            $this->curl_handle = $curl_handle;\n            $this->response = $response;\n        }\n\n        if (is_resource($this->curl_handle)) {\n            $header_size = curl_getinfo($this->curl_handle, CURLINFO_HEADER_SIZE);\n            $this->response_headers = substr($this->response, 0, $header_size);\n            $this->response_body = substr($this->response, $header_size);\n            $this->response_code = curl_getinfo($this->curl_handle, CURLINFO_HTTP_CODE);\n            $this->response_info = curl_getinfo($this->curl_handle);\n\n            $this->response_headers = explode(\"\\r\\n\\r\\n\", trim($this->response_headers));\n            $this->response_headers = array_pop($this->response_headers);\n            $this->response_headers = explode(\"\\r\\n\", $this->response_headers);\n            array_shift($this->response_headers);\n\n            $header_assoc = array();\n            foreach ($this->response_headers as $header) {\n                $kv = explode(': ', $header);\n                $header_assoc[$kv[0]] = $kv[1];\n            }\n\n            $this->response_headers = $header_assoc;\n            $this->response_headers['_info'] = $this->response_info;\n            $this->response_headers['_info']['method'] = $this->method;\n\n            if ($curl_handle && $response) {\n                $class = '\\Think\\Upload\\Driver\\Bcs\\\\' . $this->response_class;\n                return new $class($this->response_headers, $this->response_body, $this->response_code, $this->curl_handle);\n            }\n        }\n\n        return false;\n    }\n\n    private function isBaeEnv()\n    {\n        if (isset($_SERVER['HTTP_HOST'])) {\n            $host = $_SERVER['HTTP_HOST'];\n            $pos = strpos($host, '.');\n            if (false !== $pos) {\n                $substr = substr($host, $pos + 1);\n                if ('duapp.com' == $substr) {\n                    return true;\n                }\n            }\n        }\n        if (isset($_SERVER[\"HTTP_BAE_LOGID\"])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public function getResponseHeader($header = null)\n    {\n        if ($header) {\n            return $this->response_headers[$header];\n        }\n        return $this->response_headers;\n    }\n\n    public function getResponseBody()\n    {\n        return $this->response_body;\n    }\n\n    public function getResponseCode()\n    {\n        return $this->response_code;\n    }\n}",
  "FSMID_for_test": 132,
  "Code_level": "Class-level"
}