{
  "Task_id": 150,
  "Github_ID": "34716238",
  "Github_Project_Name": "faveo-helpdesk",
  "Programming_Language": "PHP",
  "suffix": ".php",
  "Interface_class": "IPC",
  "Interface_name": "pipe based on proc_open in PHP",
  "Instruction": "Task Description: Create a PHP class that manages the execution of a subprocess using proc_open, handles input/output through pipes, and provides timeout functionality for process execution.\n\nClass Description: DefaultPhpProcess is a class that extends AbstractPhpProcess and provides concrete implementation for running PHP jobs in a subprocess. It handles process creation, I/O management through pipes, timeout enforcement, and resource cleanup.\n\nAttributes:\ntempFile: string - Temporary file path used for storing job input when stdin is not used\nstdin: mixed - Input source for the subprocess\nenv: array - Environment variables for the subprocess\ntimeout: int - Maximum execution time in seconds before process termination\n\nMethods:\nrunJob(string $job, array $settings = []) -> array - Executes a PHP job with optional settings, returns output and error\ngetHandles() -> array - Returns empty array by default, can be overridden to provide custom handles\nrunProcess(string $job, array $settings) -> array - Core method that manages process execution and I/O handling\nprocess(resource $pipe, string $job) -> void - Writes job input to the process pipe\ncleanup() -> void - Cleans up temporary resources (files)\nuseTemporaryFile() -> bool - Determines whether to use temporary files for input (default false)",
  "Canonical_solution": "use function array_merge;\nuse function fclose;\nuse function file_put_contents;\nuse function fread;\nuse function fwrite;\nuse function is_array;\nuse function is_resource;\nuse function proc_close;\nuse function proc_open;\nuse function proc_terminate;\nuse function rewind;\nuse function sprintf;\nuse function stream_get_contents;\nuse function stream_select;\nuse function sys_get_temp_dir;\nuse function tempnam;\nuse function unlink;\nuse PHPUnit\\Framework\\Exception;\n\nclass DefaultPhpProcess extends AbstractPhpProcess\n{\n    protected $tempFile;\n\n    public function runJob(string $job, array $settings = []): array\n    {\n        if ($this->stdin || $this->useTemporaryFile()) {\n            if (!($this->tempFile = tempnam(sys_get_temp_dir(), 'PHPUnit')) ||\n                file_put_contents($this->tempFile, $job) === false) {\n                throw new Exception(\n                    'Unable to write temporary file'\n                );\n            }\n\n            $job = $this->stdin;\n        }\n\n        return $this->runProcess($job, $settings);\n    }\n\n    protected function getHandles(): array\n    {\n        return [];\n    }\n\n    protected function runProcess(string $job, array $settings): array\n    {\n        $handles = $this->getHandles();\n\n        $env = null;\n\n        if ($this->env) {\n            $env = $_SERVER ?? [];\n            unset($env['argv'], $env['argc']);\n            $env = array_merge($env, $this->env);\n\n            foreach ($env as $envKey => $envVar) {\n                if (is_array($envVar)) {\n                    unset($env[$envKey]);\n                }\n            }\n        }\n\n        $pipeSpec = [\n            0 => $handles[0] ?? ['pipe', 'r'],\n            1 => $handles[1] ?? ['pipe', 'w'],\n            2 => $handles[2] ?? ['pipe', 'w'],\n        ];\n\n        $process = proc_open(\n            $this->getCommand($settings, $this->tempFile),\n            $pipeSpec,\n            $pipes,\n            null,\n            $env\n        );\n\n        if (!is_resource($process)) {\n            throw new Exception(\n                'Unable to spawn worker process'\n            );\n        }\n\n        if ($job) {\n            $this->process($pipes[0], $job);\n        }\n\n        fclose($pipes[0]);\n\n        $stderr = $stdout = '';\n\n        if ($this->timeout) {\n            unset($pipes[0]);\n\n            while (true) {\n                $r = $pipes;\n                $w = null;\n                $e = null;\n\n                $n = @stream_select($r, $w, $e, $this->timeout);\n\n                if ($n === false) {\n                    break;\n                }\n\n                if ($n === 0) {\n                    proc_terminate($process, 9);\n\n                    throw new Exception(\n                        sprintf(\n                            'Job execution aborted after %d seconds',\n                            $this->timeout\n                        )\n                    );\n                }\n\n                if ($n > 0) {\n                    foreach ($r as $pipe) {\n                        $pipeOffset = 0;\n\n                        foreach ($pipes as $i => $origPipe) {\n                            if ($pipe === $origPipe) {\n                                $pipeOffset = $i;\n\n                                break;\n                            }\n                        }\n\n                        if (!$pipeOffset) {\n                            break;\n                        }\n\n                        $line = fread($pipe, 8192);\n\n                        if ($line === '' || $line === false) {\n                            fclose($pipes[$pipeOffset]);\n\n                            unset($pipes[$pipeOffset]);\n                        } elseif ($pipeOffset === 1) {\n                            $stdout .= $line;\n                        } else {\n                            $stderr .= $line;\n                        }\n                    }\n\n                    if (empty($pipes)) {\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (isset($pipes[1])) {\n                $stdout = stream_get_contents($pipes[1]);\n\n                fclose($pipes[1]);\n            }\n\n            if (isset($pipes[2])) {\n                $stderr = stream_get_contents($pipes[2]);\n\n                fclose($pipes[2]);\n            }\n        }\n\n        if (isset($handles[1])) {\n            rewind($handles[1]);\n\n            $stdout = stream_get_contents($handles[1]);\n\n            fclose($handles[1]);\n        }\n\n        if (isset($handles[2])) {\n            rewind($handles[2]);\n\n            $stderr = stream_get_contents($handles[2]);\n\n            fclose($handles[2]);\n        }\n\n        proc_close($process);\n\n        $this->cleanup();\n\n        return ['stdout' => $stdout, 'stderr' => $stderr];\n    }\n\n    protected function process($pipe, string $job): void\n    {\n        fwrite($pipe, $job);\n    }\n\n    protected function cleanup(): void\n    {\n        if ($this->tempFile) {\n            unlink($this->tempFile);\n        }\n    }\n\n    protected function useTemporaryFile(): bool\n    {\n        return false;\n    }\n}",
  "FSMID_for_test": 145,
  "Code_level": "Class-level"
}