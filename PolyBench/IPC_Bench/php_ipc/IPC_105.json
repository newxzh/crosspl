{
  "Task_id": 105,
  "Github_ID": "13546918",
  "Github_Project_Name": "FruityWifi",
  "Programming_Language": "PHP",
  "suffix": ".php",
  "Interface_class": "IPC",
  "Interface_name": "HTTP client using fsockopen in PHP",
  "Instruction": "Task Description: Create a PHP class for handling HTTP/HTTPS communications using either socket-based connections (via fsockopen) or cURL, supporting both standard and persistent connections, with proper header and cookie management.\n\nClass Description: The soap_transport_http class provides low-level HTTP transport capabilities for SOAP communications, supporting both socket and cURL implementations. It handles connection management, request/response processing, and error handling.\n\nAttributes:\n- url: string - The target URL for HTTP requests\n- uri: string - The URI portion of the URL\n- scheme: string - The protocol scheme (http/https)\n- host: string - The target hostname\n- port: string - The target port number\n- path: string - The path portion of the URL\n- request_method: string - HTTP method (default: POST)\n- protocol_version: string - HTTP version (default: 1.0)\n- outgoing_headers: array - Headers to be sent with the request\n- incoming_headers: array - Headers received in the response\n- outgoing_payload: string - Data to be sent in the request\n- incoming_payload: string - Data received in the response\n- persistentConnection: bool - Flag for persistent connections\n- use_curl: bool - Flag to use cURL instead of sockets\n- proxy: array|null - Proxy configuration if used\n\nMethods:\n- __construct(string $url, array $curl_options=null, bool $use_curl=false) -> void - Initializes the transport with target URL and options\n- connect(int $connection_timeout=0, int $response_timeout=30) -> bool - Establishes connection to server\n- send(string $data, int $timeout=0, int $response_timeout=30, array $cookies=null) -> mixed - Sends data and returns response\n- sendRequest(string $data, array $cookies=null) -> bool - Sends the HTTP request with headers\n- getResponse() -> string|bool - Reads and processes the server response\n- setHeader(string $name, string $value) -> void - Adds a header to outgoing request\n- setCurlOption(mixed $option, mixed $value) -> void - Sets cURL option when using cURL\n- parseCookie(string $cookie_str) -> array|bool - Parses Set-Cookie header into array",
  "Canonical_solution": "class soap_transport_http extends nusoap_base {\n    var $url = '';\n    var $uri = '';\n    var $digest_uri = '';\n    var $scheme = '';\n    var $host = '';\n    var $port = '';\n    var $path = '';\n    var $request_method = 'POST';\n    var $protocol_version = '1.0';\n    var $encoding = '';\n    var $outgoing_headers = array();\n    var $incoming_headers = array();\n    var $incoming_cookies = array();\n    var $outgoing_payload = '';\n    var $incoming_payload = '';\n    var $response_status_line;\n    var $useSOAPAction = true;\n    var $persistentConnection = false;\n    var $ch = false;\n    var $ch_options = array();\n    var $use_curl = false;\n    var $proxy = null;\n    var $username = '';\n    var $password = '';\n    var $authtype = '';\n    var $digestRequest = array();\n    var $certRequest = array();\n\n    function soap_transport_http($url, $curl_options = NULL, $use_curl = false) {\n        parent::nusoap_base();\n        $this->debug(\"ctor url=$url use_curl=$use_curl curl_options:\");\n        $this->appendDebug($this->varDump($curl_options));\n        $this->setURL($url);\n        if (is_array($curl_options)) {\n            $this->ch_options = $curl_options;\n        }\n        $this->use_curl = $use_curl;\n        preg_match('/\\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);\n        $this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');\n    }\n\n    function connect($connection_timeout=0,$response_timeout=30) {\n        $this->debug(\"connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port\");\n        if ($this->io_method() == 'socket') {\n            if (!is_array($this->proxy)) {\n                $host = $this->host;\n                $port = $this->port;\n            } else {\n                $host = $this->proxy['host'];\n                $port = $this->proxy['port'];\n            }\n\n            if($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){\n                if (!feof($this->fp)) {\n                    $this->debug('Re-use persistent connection');\n                    return true;\n                }\n                fclose($this->fp);\n                $this->debug('Closed persistent connection at EOF');\n            }\n\n            if ($this->scheme == 'ssl') {\n                $host = 'ssl://' . $host;\n            }\n            $this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);\n\n            if($connection_timeout > 0){\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);\n            } else {\n                $this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);\n            }\n            \n            if(!$this->fp) {\n                $msg = 'Couldn\\'t open socket connection to server ' . $this->url;\n                if ($this->errno) {\n                    $msg .= ', Error ('.$this->errno.'): '.$this->error_str;\n                } else {\n                    $msg .= ' prior to connect().  This is often a problem looking up the host name.';\n                }\n                $this->debug($msg);\n                $this->setError($msg);\n                return false;\n            }\n            \n            $this->debug('set response timeout to ' . $response_timeout);\n            socket_set_timeout( $this->fp, $response_timeout);\n\n            $this->debug('socket connected');\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            if (!extension_loaded('curl')) {\n                $this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to include cURL or change php.ini to load the PHP cURL extension.');\n                return false;\n            }\n            $this->debug('connect using cURL');\n            $this->ch = curl_init();\n            $hostURL = ($this->port != '') ? \"$this->scheme://$this->host:$this->port\" : \"$this->scheme://$this->host\";\n            $hostURL .= $this->path;\n            $this->setCurlOption(CURLOPT_URL, $hostURL);\n            if (ini_get('safe_mode') || ini_get('open_basedir')) {\n                $this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');\n            } else {\n                $this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);\n            }\n            $this->setCurlOption(CURLOPT_HEADER, 1);\n            $this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);\n            if ($this->persistentConnection) {\n                $this->persistentConnection = false;\n                $this->setHeader('Connection', 'close');\n            }\n            if ($connection_timeout != 0) {\n                $this->setCurlOption(CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);\n            }\n            if ($response_timeout != 0) {\n                $this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);\n            }\n            $this->debug('cURL connection set up');\n            return true;\n        } else {\n            $this->setError('Unknown scheme ' . $this->scheme);\n            $this->debug('Unknown scheme ' . $this->scheme);\n            return false;\n        }\n    }\n\n    function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {\n        $this->debug('entered send() with data of length: '.strlen($data));\n        $this->tryagain = true;\n        $tries = 0;\n        while ($this->tryagain) {\n            $this->tryagain = false;\n            if ($tries++ < 2) {\n                if (!$this->connect($timeout, $response_timeout)){\n                    return false;\n                }\n                if (!$this->sendRequest($data, $cookies)){\n                    return false;\n                }\n                $respdata = $this->getResponse();\n            } else {\n                $this->setError(\"Too many tries to get an OK response ($this->response_status_line)\");\n            }\n        }        \n        $this->debug('end of send()');\n        return $respdata;\n    }\n\n    function sendRequest($data, $cookies = NULL) {\n        $cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));\n        $this->buildPayload($data, $cookie_str);\n        if ($this->io_method() == 'socket') {\n            if(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {\n                $this->setError('couldn\\'t write message data to socket');\n                $this->debug('couldn\\'t write message data to socket');\n                return false;\n            }\n            $this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));\n            return true;\n        } else if ($this->io_method() == 'curl') {\n            $curl_headers = array();\n            foreach($this->outgoing_headers as $k => $v){\n                if ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {\n                    $this->debug(\"Skip cURL header $k: $v\");\n                } else {\n                    $curl_headers[] = \"$k: $v\";\n                }\n            }\n            if ($cookie_str != '') {\n                $curl_headers[] = 'Cookie: ' . $cookie_str;\n            }\n            $this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);\n            $this->debug('set cURL HTTP headers');\n            if ($this->request_method == \"POST\") {\n                $this->setCurlOption(CURLOPT_POST, 1);\n                $this->setCurlOption(CURLOPT_POSTFIELDS, $data);\n                $this->debug('set cURL POST data');\n            }\n            foreach ($this->ch_options as $key => $val) {\n                $this->setCurlOption($key, $val);\n            }\n            $this->debug('set cURL payload');\n            return true;\n        }\n    }\n\n    function getResponse(){\n        $this->incoming_payload = '';\n        if ($this->io_method() == 'socket') {\n            $data = '';\n            while (!isset($lb)){\n                if(feof($this->fp)) {\n                    $this->incoming_payload = $data;\n                    $this->debug('found no headers before EOF after length ' . strlen($data));\n                    $this->debug(\"received before EOF:\\n\" . $data);\n                    $this->setError('server failed to send headers');\n                    return false;\n                }\n                $tmp = fgets($this->fp, 256);\n                $tmplen = strlen($tmp);\n                $this->debug(\"read line of $tmplen bytes: \" . trim($tmp));\n                if ($tmplen == 0) {\n                    $this->incoming_payload = $data;\n                    $this->debug('socket read of headers timed out after length ' . strlen($data));\n                    $this->debug(\"read before timeout: \" . $data);\n                    $this->setError('socket read of headers timed out');\n                    return false;\n                }\n                $data .= $tmp;\n                $pos = strpos($data,\"\\r\\n\\r\\n\");\n                if($pos > 1){\n                    $lb = \"\\r\\n\";\n                } else {\n                    $pos = strpos($data,\"\\n\\n\");\n                    if($pos > 1){\n                        $lb = \"\\n\";\n                    }\n                }\n                if (isset($lb) && preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    unset($lb);\n                    $data = '';\n                }\n            }\n            $this->incoming_payload .= $data;\n            $this->debug('found end of headers after length ' . strlen($data));\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $this->incoming_headers = array();\n            $this->incoming_cookies = array();\n            foreach($header_array as $header_line){\n                $arr = explode(':',$header_line, 2);\n                if(count($arr) > 1){\n                    $header_name = strtolower(trim($arr[0]));\n                    $this->incoming_headers[$header_name] = trim($arr[1]);\n                    if ($header_name == 'set-cookie') {\n                        $cookie = $this->parseCookie(trim($arr[1]));\n                        if ($cookie) {\n                            $this->incoming_cookies[] = $cookie;\n                            $this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);\n                        } else {\n                            $this->debug('did not find cookie in ' . trim($arr[1]));\n                        }\n                    }\n                } else if (isset($header_name)) {\n                    $this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;\n                }\n            }\n            if (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {\n                $content_length =  2147483647;\n                $chunked = true;\n                $this->debug(\"want to read chunked content\");\n            } elseif (isset($this->incoming_headers['content-length'])) {\n                $content_length = $this->incoming_headers['content-length'];\n                $chunked = false;\n                $this->debug(\"want to read content of length $content_length\");\n            } else {\n                $content_length =  2147483647;\n                $chunked = false;\n                $this->debug(\"want to read content to EOF\");\n            }\n            $data = '';\n            do {\n                if ($chunked) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk line of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk length timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk length timed out');\n                        return false;\n                    }\n                    $content_length = hexdec(trim($tmp));\n                    $this->debug(\"chunk length $content_length\");\n                }\n                $strlen = 0;\n                while (($strlen < $content_length) && (!feof($this->fp))) {\n                    $readlen = min(8192, $content_length - $strlen);\n                    $tmp = fread($this->fp, $readlen);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read buffer of $tmplen bytes\");\n                    if (($tmplen == 0) && (!feof($this->fp))) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of body timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of body timed out');\n                        return false;\n                    }\n                    $strlen += $tmplen;\n                    $data .= $tmp;\n                }\n                if ($chunked && ($content_length > 0)) {\n                    $tmp = fgets($this->fp, 256);\n                    $tmplen = strlen($tmp);\n                    $this->debug(\"read chunk terminator of $tmplen bytes\");\n                    if ($tmplen == 0) {\n                        $this->incoming_payload = $data;\n                        $this->debug('socket read of chunk terminator timed out after length ' . strlen($data));\n                        $this->debug(\"read before timeout:\\n\" . $data);\n                        $this->setError('socket read of chunk terminator timed out');\n                        return false;\n                    }\n                }\n            } while ($chunked && ($content_length > 0) && (!feof($this->fp)));\n            if (feof($this->fp)) {\n                $this->debug('read to EOF');\n            }\n            $this->debug('read body of length ' . strlen($data));\n            $this->incoming_payload .= $data;\n            $this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');\n            if(\n                (isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || \n                (! $this->persistentConnection) || feof($this->fp)){\n                fclose($this->fp);\n                $this->fp = false;\n                $this->debug('closed socket');\n            }\n            if($this->incoming_payload == ''){\n                $this->setError('no response from server');\n                return false;\n            }\n            return $data;\n        } else if ($this->io_method() == 'curl') {\n            $this->debug('send and receive with cURL');\n            $this->incoming_payload = curl_exec($this->ch);\n            $data = $this->incoming_payload;\n            $cErr = curl_error($this->ch);\n            if ($cErr != '') {\n                $err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';\n                foreach(curl_getinfo($this->ch) as $k => $v){\n                    $err .= \"$k: $v<br>\";\n                }\n                $this->debug($err);\n                $this->setError($err);\n                curl_close($this->ch);\n                return false;\n            }\n            $this->debug('No cURL error, closing cURL');\n            curl_close($this->ch);\n            $savedata = $data;\n            while ($this->isSkippableCurlHeader($data)) {\n                $this->debug(\"Found HTTP header to skip\");\n                if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                    $data = ltrim(substr($data,$pos));\n                } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                    $data = ltrim(substr($data,$pos));\n                }\n            }\n            if ($data == '') {\n                $data = $savedata;\n                while (preg_match('/^HTTP\\/1.1 100/',$data)) {\n                    if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                        $data = ltrim(substr($data,$pos));\n                    } elseif($pos = strpos($data,\"\\n\\n\") ) {\n                        $data = ltrim(substr($data,$pos));\n                    }\n                }\n            }\n            if ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\n                $lb = \"\\r\\n\";\n            } elseif( $pos = strpos($data,\"\\n\\n\")) {\n                $lb = \"\\n\";\n            } else {\n                $this->debug('no proper separation of headers and document');\n                $this->setError('no proper separation of headers and document');\n                return false;\n            }\n            $header_data = trim(substr($data,0,$pos));\n            $header_array = explode($lb,$header_data);\n            $data = ltrim(substr($data,$pos));\n            $this->debug('found proper separation of headers and document');\n            $this->debug('cleaned data, stringlen: '.strlen($data));\n            foreach ($header_array as $header_line) {\n                $arr = explode(':',$header_line",
  "FSMID_for_test": 131,
  "Code_level": "Class-level"
}